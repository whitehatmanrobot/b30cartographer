OID CallerContext,
    IN PMIB_IPFORWARD_ROW2 Row OPTIONAL,
    IN MIB_NOTIFICATION_TYPE NotificationType
    );

NETIOAPI_API
CreateIpForwardEntry2(
    IN CONST MIB_IPFORWARD_ROW2 *Row
    );
/*++

Routine Description:

    Create a route on the local computer. 

Arguments:

    Row - Supplies a MIB_IPFORWARD_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    InitializeIpForwardEntry must be used to initialize the fields of
    MIB_IPFORWARD_ROW2 with default values.  The caller can then update the
    fields it wishes to modify and invoke CreateIpForwardEntry2.

    On input, the following key fields of Row must be initialized after
    invoking InitializeIpForwardEntry:    
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. DestinationPrefix.
    3. NextHop.

--*/

NETIOAPI_API
DeleteIpForwardEntry2(
    IN CONST MIB_IPFORWARD_ROW2 *Row
    );
/*++

Routine Description:

    Delete a route on the local computer. 

Arguments:

    Row - Supplies a MIB_IPFORWARD_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:        
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. DestinationPrefix.
    3. NextHop.

--*/

NETIOAPI_API
GetBestRoute2(
    IN NET_LUID *InterfaceLuid OPTIONAL,
    IN NET_IFINDEX InterfaceIndex,
    CONST IN SOCKADDR_INET *SourceAddress,
    CONST IN SOCKADDR_INET *DestinationAddress,
    IN ULONG AddressSortOptions,
    OUT PMIB_IPFORWARD_ROW2 BestRoute,
    OUT SOCKADDR_INET *BestSourceAddress
    );
/*++

Routine Description:

    Retrieve the best route between source and destination address on a local
        computer. 

Arguments:

    InterfaceLuid - Supplies Luid to specify an interface.

    InterfaceIndex - Supplies Index to specify an interface.

    SourceAddress - Supplies source address.

    DestinationAddress - Supplies destination address.

    AddressSortOptions - Supplies AddressSortOptions.

    BestRoute - Returns the MIB structure that holds the best route.
    
    BestSourceAddress - Returns the source address of the best route. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following parameters must be supplied:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. SourceAddress.
    3. DestinationAddress.

--*/

NETIOAPI_API
GetIpForwardEntry2(
    IN OUT PMIB_IPFORWARD_ROW2 Row
    );
/*++

Routine Description:

    Retrieves information for the specified route entry on the local computer. 

Arguments:

    Route - Supplies a MIB_IPFORWARD_ROW2 structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:    
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. DestinationPrefix and NextHop can be specified.

    On output, the remaining fields of Row are filled in.

    If one or more routes matches the specified criteria,
    this API matches the first entry.
    
--*/

NETIOAPI_API
GetIpForwardTable2(
    IN ADDRESS_FAMILY Family,
    OUT PMIB_IPFORWARD_TABLE2 *Table
    );
/*++

Routine Description:

    Retrieves the route table on a local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 route entries.

        AF_INET6: Only returns IPv6 route entries.

        AF_UNSPEC: Returns both IPv4 and IPv6 route entries.

    Table - Returns the table of routes in a MIB_IPFORWARD_TABLE2 Structure. 
        Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it. 

--*/

VOID
NETIOAPI_API_
InitializeIpForwardEntry(
    OUT PMIB_IPFORWARD_ROW2 Row
    );
/*++

Routine Description:

    Initialize the MIB_IPFORWARD_ROW2 entry for use in SetIpForwardEntry2.

Arguments:

    Row - Returns an initialized PMIB_IPFORWARD_ROW2 structure. 

Return Value:

    None. 

Notes:

    InitializeIpForwardEntry must be used to initialize the fields of 
        MIB_IPFORWARD_ROW2 with default values.  The caller can then update the
        fields it wishes to modify and invoke SetIpForwardEntry2.

--*/

NETIOAPI_API
NotifyRouteChange2(
    IN ADDRESS_FAMILY AddressFamily,
    IN PIPFORWARD_CHANGE_CALLBACK Callback,
    IN PVOID CallerContext,    
    IN BOOLEAN InitialNotification,
    IN OUT HANDLE *NotificationHandle
    );
/*++

Routine Description:

    Register for notification for route changes.

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only register for IPv4 route change notifications.

        AF_INET6: Only register for IPv6 route change notifications.

        AF_UNSPEC: Register for both IPv4 and IPv6 route change notifications.

    Callback - Supplies a callback function. This function will be invoked when
        an unicast IP address notification is received.

    CallerContext - Provides the user specific caller context. This context 
        will be supplied to the callback function.

    InitialNotification - Supplies a boolean to indicate whether an 
        initialization notification should be provided. 

    NotificationHandle - Returns a handle to the notification registration. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    1. Invokation of the callback function is serialized.

    2. Use CancelMibChangeNotify2 to deregister for change notifications.

--*/

NETIOAPI_API
SetIpForwardEntry2(
    IN CONST MIB_IPFORWARD_ROW2 *Route
    );
/*++

Routine Description:

    Set the properties of a route entry. 

Arguments:

    Route - Supplies a MIB_UNICASTIPADDRESS_ROW structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    InitializeIpForwardEntry must be used to initialize the fields of
    MIB_IPFORWARD_ROW2 with default values.  The caller can then update the
    fields it wishes to modify and invoke SetIpForwardEntry2.

    On input, the following key fields of Row must be initialized after
    invoking InitializeIpForwardEntry:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.  
    2. DestinationPrefix.
    3. NextHop.

--*/

//
// Path management routines.
//

typedef struct _MIB_IPPATH_ROW {
    //
    // Key.
    //
    
    SOCKADDR_INET Source;    
    SOCKADDR_INET Destination;
    NET_LUID InterfaceLuid;
    NET_IFINDEX InterfaceIndex;  

    //
    // RO.
    //
    //
    // The current next hop.  This can change over the lifetime of a path. 
    //
    SOCKADDR_INET CurrentNextHop;

    //
    // MTU of path to destination. Includes the IP header length.
    //
    ULONG PathMtu;

    //
    // Estimated mean RTT.
    //
    ULONG RttMean;

    //
    // Mean deviation of RTT.
    //
    ULONG RttDeviation;
    union {
        ULONG LastReachable;    // Milliseconds.
        ULONG LastUnreachable;  // Milliseconds.
    };
    BOOLEAN IsReachable;

    //
    // Estimated speed.
    //
    ULONG64 LinkTransmitSpeed;
    ULONG64 LinkReceiveSpeed;

} MIB_IPPATH_ROW, *PMIB_IPPATH_ROW;

typedef struct _MIB_IPPATH_TABLE {
    ULONG NumEntries;
    MIB_IPPATH_ROW Table[ANY_SIZE];
} MIB_IPPATH_TABLE, *PMIB_IPPATH_TABLE;


NETIOAPI_API
FlushIpPathTable(
    IN ADDRESS_FAMILY Family
    );
/*++

Routine Description:

    Flush the IP Path table on the local computer.

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only flush the IPv4 path table.

        AF_INET6: Only flush the IPv6 path table.

        AF_UNSPEC: Flush both IPv4 and IPv6 path table.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/
    
NETIOAPI_API
GetIpPathEntry(
    IN OUT PMIB_IPPATH_ROW Row
    );
/*++

Routine Description:

    Retrieves information for the specified path entry on the local computer. 

Arguments:

    Row - Supplies a MIB_IPPATH_ROW structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:    
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. Source.
    3. Destination.

    On output, the remaining fields of Row are filled in.

--*/

NETIOAPI_API
GetIpPathTable(
    IN ADDRESS_FAMILY Family,
    OUT PMIB_IPPATH_TABLE *Table
    );
/*++

Routine Description:

    Retrieves the path table on a local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 paths.

        AF_INET6: Only returns IPv6 paths.

        AF_UNSPEC: Returns both IPv4 and IPv6 paths.

    Table - Returns the table of paths in a MIB_IPPATH_TABLE
        structure.  Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it.

--*/

//
// ARP and IPv6 Neighbor management routines.
//

typedef struct _MIB_IPNET_ROW2 {
    //
    // Key Struture.
    //
    SOCKADDR_INET Address;
    NET_IFINDEX InterfaceIndex;
    NET_LUID InterfaceLuid;

    //
    // Read-Write.
    //
    UCHAR PhysicalAddress[IF_MAX_PHYS_ADDRESS_LENGTH];

    //
    // Read-Only.
    //
    ULONG PhysicalAddressLength;
    NL_NEIGHBOR_STATE State;

    union {
        struct {
            BOOLEAN IsRouter : 1;
            BOOLEAN IsUnreachable : 1;
        };
        UCHAR Flags;
    };

    union {
        ULONG LastReachable;
        ULONG LastUnreachable;
    } ReachabilityTime;
} MIB_IPNET_ROW2, *PMIB_IPNET_ROW2;

typedef struct _MIB_IPNET_TABLE2 {
    ULONG NumEntries;
    MIB_IPNET_ROW2 Table[ANY_SIZE];
} MIB_IPNET_TABLE2, *PMIB_IPNET_TABLE2;

NETIOAPI_API
CreateIpNetEntry2(
    IN CONST MIB_IPNET_ROW2 *Row
    );
/*++

Routine Description:

    Create a neighbor entry on the local computer. 

Arguments:

    Row - Supplies a MIB_IPNET_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:        
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. Address.
    3. PhysicalAddress.

--*/

NETIOAPI_API
DeleteIpNetEntry2(
    IN CONST MIB_IPNET_ROW2 *Row
    );
/*++

Routine Description:

    Delete a neighbor entry on the local computer. 

Arguments:

    Row - Supplies a MIB_IPNET_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes: 

    On input, the following key fields of Row must be initialized:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified. 
    2. Address.

--*/


NETIOAPI_API
FlushIpNetTable2(
    IN ADDRESS_FAMILY Family,
    IN NET_IFINDEX InterfaceIndex
    );
/*++

Routine Description:

    Flush the neighbor entry table on the local computer. 

Arguments:

    Family - Supplies the address family. 

        AF_INET: Only flush the IPv4 neighbor table.

        AF_INET6: Only flush the IPv6 neighbor table.

        AF_UNSPEC: Flush both IPv4 and IPv6 neighbor table.

    InterfaceIndex - Supplies the Interface index.  If the index is specified,
        flush the neighbor entries on a specific interface, otherwise flush the
        neighbor entries on all the interfaces.
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/


NETIOAPI_API
GetIpNetEntry2(
    IN OUT PMIB_IPNET_ROW2 Row
    );
/*++

Routine Description:

    Retrieves information for the specified neighbor entry on the local
    computer.

Arguments:

    Row - Supplies a MIB_IPNET_ROW2 structure. 
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. Address.

    On output, the remaining fields of Row are filled in.

--*/
    
NETIOAPI_API
GetIpNetTable2(
    IN ADDRESS_FAMILY Family,
    OUT PMIB_IPNET_TABLE2 *Table
    );
/*++

Routine Description:

    Retrieves the neighbor table on the local computer. 

Arguments:

    Family - Supplies the address family.

        AF_INET: Only returns IPv4 neighbor entries.

        AF_INET6: Only returns IPv6 neighbor entries.

        AF_UNSPEC: Returns both IPv4 and IPv6 neighbor entries.

    Table - Returns the table of neighbor entries in a MIB_IPNET_TABLE2
        structure.  Use FreeMibTable to free this buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    The API allocates the buffer for Table.  Use FreeMibTable to free it.
    
--*/    

NETIOAPI_API
ResolveIpNetEntry2(
    IN OUT PMIB_IPNET_ROW2 Row,
    IN CONST SOCKADDR_INET *SourceAddress OPTIONAL
    );
/*++

Routine Description:

    Resolve the physical address of a specific neighbor. 

Arguments:

    NetEntry - Supplies a MIB_IPNET_ROW2 structure.

    SourceAddress - Supplies the source address.
    
Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    This API flushes any existing neighbor entry and resolves the MAC address
    by sending ARP requests (IPv4) or Neighbor Solicitation (IPv6).
    If source address is not provided, the API will automatically select the
    best interface to send the request on.

    On input, the following key fields of Row must be initialized:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. Address.

    On output, the remaining fields of Row are filled in.

--*/

NETIOAPI_API
SetIpNetEntry2(
    IN OUT PMIB_IPNET_ROW2 Row
    );
/*++

Routine Description:

    Set the physical address of a neighbor entry. 

Arguments:

    NetEntry - Supplies a MIB_IPNET_ROW2 structure. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    On input, the following key fields of Row must be initialized:
    1. At least one of InterfaceLuid or InterfaceIndex must be specified.
    2. Address.
    3. PhysicalAddress.     

--*/ 

//
// Teredo APIs.
//
#define MIB_INVALID_TEREDO_PORT_NUMBER 0

typedef
VOID
(*PTEREDO_PORT_CHANGE_CALLBACK) (
    IN PVOID CallerContext,
    IN USHORT Port,
    IN MIB_NOTIFICATION_TYPE NotificationType
    );

NETIOAPI_API
NotifyTeredoPortChange(
    IN PTEREDO_PORT_CHANGE_CALLBACK Callback,
    IN PVOID CallerContext,    
    IN BOOLEAN InitialNotification,
    IN OUT HANDLE *NotificationHandle
    );

NETIOAPI_API
GetTeredoPort(
    OUT USHORT *Port
    );
/*++

Routine Description:

    Get the Teredo client port. 

Arguments:

    Port - returns the Teredo port. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure.      

--*/ 


//
// Generic (not IP-specific) interface definitions.
//

NETIOAPI_API
CancelMibChangeNotify2(
    IN HANDLE NotificationHandle
    );
/*++

Routine Description:

    Deregister for change notifications.

Arguments:

    NotificationHandle - Supplies the handle returned from a notification 
        registration. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

Notes:

    Blocks until all callback have returned.
    
--*/

VOID
NETIOAPI_API_
FreeMibTable(
    IN PVOID Memory
    ); 
/*++

Routine Description:

    Free the buffer allocated by Get*Table APIs.

Arguments:

    Memory - Supplies the buffer to free.

Return Value:

    None.

--*/

NETIOAPI_API
CreateSortedAddressPairs(
    IN const PSOCKADDR_IN6 SourceAddressList OPTIONAL,
    IN ULONG SourceAddressCount,
    IN const PSOCKADDR_IN6 DestinationAddressList,
    IN ULONG DestinationAddressCount,
    IN ULONG AddressSortOptions,
    OUT PSOCKADDR_IN6_PAIR *SortedAddressPairList,
    OUT ULONG *SortedAddressPairCount
    );
/*++

Routine Description:

    Given a list of source and destination addresses, returns a list of
    pairs of addresses in sorted order.  The list is sorted by which address
    pair is best suited for communication between two peers.

    The list of source addresses is optional, in which case the function
    automatically uses all the host machine's local addresses.

Arguments:

    SourceAddressList - Supplies list of potential source addresses.
        If NULL the routine automatically uses all local addresses.
        IPv4 addresses can be specified in IPv4-mapped format.
        Reserved for future use.  Must be NULL.
    
    SourceAddressCount - Supplies the number of addresses in the 
        SourceAddressList.
        Reserved for future use.  Must be 0.        

    DestinationAddressList - Supplies list of potential destination addresses.
        IPv4 addresses can be specified in IPv4-mapped format.

    DestinationAddressCount -  Supplies the number of addresses in the 
        DestinationAddressList.

    AddressSortOptions - Reserved for future use.  Must be 0.

    SortedAddressPairList - Returns a sorted list of pairs of addresses
        in prefered order of communication.  The list must be freed with a
        single call to NetioFreeMemory.

    SortedAddressPairCount - Returns the number of address pairs in
        SortedAddressPairList.

Return Value:

    ERROR_SUCCESS on success.  WIN32 error code on error.

--*/

#endif //_WS2IPDEF_

NETIOAPI_API
ConvertInterfaceNameToLuidA(
    IN CONST CHAR *InterfaceName,
    OUT NET_LUID *InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Name to Luid.

Arguments:

    InterfaceName - Supplies the interface name to be converted.

    InterfaceLuid - Returns the interface Luid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceNameToLuidW(
    IN CONST WCHAR *InterfaceName,
    OUT NET_LUID *InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Name to Luid.

Arguments:

    InterfaceName - Supplies the interface name to be converted.

    InterfaceLuid - Returns the interface Luid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceLuidToNameA(
    IN CONST NET_LUID *InterfaceLuid,
    __out_ecount(Length) PSTR InterfaceName,
    __in SIZE_T Length
    );
/*++

Routine Description:

    Convert an Interface Luid to Name.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceName - Returns the interface name.

    Lenght - Supplies the length of the InterfaceName buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceLuidToNameW(
    IN CONST NET_LUID *InterfaceLuid,
    __out_ecount(Length) PWSTR InterfaceName,
    __in SIZE_T Length
    );
/*++

Routine Description:

    Convert an Interface Luid to Name.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceName - Returns the interface name.

    Length - Supplies the length of the InterfaceName buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceLuidToIndex(
    IN CONST NET_LUID *InterfaceLuid,
    OUT PNET_IFINDEX InterfaceIndex
    );
/*++

Routine Description:

    Convert an Interface Luid to Index.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceName - Returns the interface Index.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceIndexToLuid(
    IN NET_IFINDEX InterfaceIndex,
    OUT PNET_LUID InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Index to Luid.

Arguments:

    InterfaceName - Supplies the interface Index to be converted.

    InterfaceLuid - Returns the interface Luid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceLuidToAlias(
    IN CONST NET_LUID *InterfaceLuid,
    __out_ecount(Length) PWSTR InterfaceAlias,
    __in SIZE_T Length
    );
/*++

Routine Description:

    Convert an Interface Luid to Alias.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceAlias - Returns the interface Alias.

    Length - Supplies the length of InterfaceAlias buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceAliasToLuid(
    IN CONST WCHAR *InterfaceAlias,
    OUT PNET_LUID InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Alias to Luid.

Arguments:

    InterfaceAlias - Supplies the null terminated interface Alias.

    InterfaceLuid - Returns the interface Luid. 

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceLuidToGuid(
    IN CONST NET_LUID *InterfaceLuid,
    OUT GUID *InterfaceGuid
    );
/*++

Routine Description:

    Convert an Interface Luid to Guid.

Arguments:

    InterfaceLuid - Supplies the interface Luid to be converted.

    InterfaceGuid - Returns the interface Guid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
ConvertInterfaceGuidToLuid(
    IN CONST GUID *InterfaceGuid,
    OUT PNET_LUID InterfaceLuid
    );
/*++

Routine Description:

    Convert an Interface Luid to Guid.

Arguments:

    InterfaceGuid - Supplies the interface Guid to be converted.

    InterfaceGuid - Returns the interface Luid.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

#define IF_NAMESIZE NDIS_IF_MAX_STRING_SIZE

NET_IFINDEX
NETIOAPI_API_
if_nametoindex(
    __in PCSTR InterfaceName
    );
/*++

Routine Description:

    Convert an Interface name to Index.

Arguments:

    InterfaceName - Supplies the null terminated interface name to convert.

Return Value:

    Interface index on success, 0 otherwise.

--*/
    
PCHAR
NETIOAPI_API_
if_indextoname(
    __in NET_IFINDEX InterfaceIndex,
    __out_ecount(IF_NAMESIZE) PCHAR InterfaceName
    );
/*++

Routine Description:

    Convert an Interface index to Name.

Arguments:

    InterfaceIndex - Supplies the Interface index to convert.

    InterfaceName - Returns the null terminated interface name.

Return Value:

    Interface name on success, NULL otherwise.

Notes:

    The length of InterfaceName buffer must be equal to or greater than 
        IF_NAMESIZE.

--*/

NET_IF_COMPARTMENT_ID
NETIOAPI_API_
GetCurrentThreadCompartmentId(
    VOID
    );
/*++

Routine Description:

    Get the compartment ID of current thread.

Arguments:

    None.

Return Value:

    The compartment ID of current thread.

--*/

NETIOAPI_API
SetCurrentThreadCompartmentId(
    IN NET_IF_COMPARTMENT_ID CompartmentId
    );
/*++

Routine Description:

    Set the compartment ID of current thread.

Arguments:

    CompartmentId - Supplies the compartment ID to be set.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 


--*/

NET_IF_COMPARTMENT_ID
NETIOAPI_API_
GetSessionCompartmentId(
    IN ULONG SessionId
    );
/*++

Routine Description:

    Get the compartment ID of the session.

Arguments:

    SessionId - Supplies the session ID.

Return Value:

    The compartment ID of the session.

--*/


NETIOAPI_API
SetSessionCompartmentId(
    IN ULONG SessionId,
    IN NET_IF_COMPARTMENT_ID CompartmentId
    );
/*++

Routine Description:

    Set the compartment ID of the session.

Arguments:

    SessionId - Supplies the session ID.

    CompartmentId - Supplies the compartment ID to be set.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

NETIOAPI_API
GetNetworkInformation(
    __in CONST NET_IF_NETWORK_GUID *NetworkGuid,
    __out PNET_IF_COMPARTMENT_ID CompartmentId,
    __out PULONG SiteId,
    __out_ecount(Length) PWCHAR NetworkName,
    __in ULONG Length
    );
/*++

Routine Description:

    Get the network information.

Arguments:

    NetworkGuid - Supplies the Network GUID.

    CompartmentId - Returns the compartment ID.

    SiteId - Returns Site ID.

    NetowrkName - Returns the network name.

    Length - Supplies the length of NetworkName buffer.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/
    
NETIOAPI_API
SetNetworkInformation(
    __in CONST NET_IF_NETWORK_GUID *NetworkGuid,
    __in NET_IF_COMPARTMENT_ID CompartmentId,
    __in CONST WCHAR *NetworkName
    );
/*++

Routine Description:

    Set the Network Information.

Arguments:

    NetworkGuid - Supplies the session ID.

    CompartmentId - Supplies the compartment ID to be set.

    NetworkName - Supplies the Network name to be set.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/

#pragma warning(pop) 

NETIOAPI_API
ConvertLengthToIpv4Mask(
    IN ULONG MaskLength,
    OUT PULONG Mask
    );
/*++

Routine Description:

    Converts a prefixLength to a subnet mask.

Arguments:

    MaskLength - Prefix Length.

    Mask - Mask generated.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/   

NETIOAPI_API
ConvertIpv4MaskToLength(
    IN ULONG Mask,
    OUT PUINT8 MaskLength
    );
/*++

Routine Description:

    Converts a subnet mask to a prefix length.

Arguments:

    Mask - Subnet mask to use.

    MaskLength - Prefix length computed.

Return Value:

    User-Mode: NO_ERROR on success, error code on failure.

    Kernel-Mode: STATUS_SUCCESS on success, error code on failure. 

--*/   

//
//4201.
//
#ifdef __cplusplus
}
#endif

#endif // _NETIOAPI_H_.
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\netmon.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for netmon.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netmon_h__
#define __netmon_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDelaydC_FWD_DEFINED__
#define __IDelaydC_FWD_DEFINED__
typedef interface IDelaydC IDelaydC;
#endif 	/* __IDelaydC_FWD_DEFINED__ */


#ifndef __IRTC_FWD_DEFINED__
#define __IRTC_FWD_DEFINED__
typedef interface IRTC IRTC;
#endif 	/* __IRTC_FWD_DEFINED__ */


#ifndef __IStats_FWD_DEFINED__
#define __IStats_FWD_DEFINED__
typedef interface IStats IStats;
#endif 	/* __IStats_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_netmon_0000_0000 */
/* [local] */ 

//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) Microsoft Corporation. All rights reserved.
//
//  MODULE: netmon.h
//
//  This is the consolidated include file for all Network Monitor components.
//
//  It contains the contents of these files from previous SDKs:
//
//      NPPTypes.h
//      Finder.h
//      NMSupp.h
//      BHTypes.h
//      NMErr.h
//      BHFilter.h
//      Frame.h
//      Parser.h
//      IniLib.h
//      NMExpert.h      (previously Expert.h)
//      Netmon.h        (previously bh.h)
//      NMBlob.h        (previously blob.h)
//      NMRegHelp.h     (previously reghelp.h)
//      NMIpStructs.h   (previously IpStructs.h)
//      NMIcmpStructs.h (previously IcmpStructs.h)
//      NMIpxStructs.h  (previously IpxStructs.h)
//      NMTcpStructs.h  (previously TcpStructs.h)
//
//      IDelaydC.idl
//      IRTC.idl
//      IStats.idl
//
//=============================================================================
#include <winerror.h>
#include <winerror.h>

#pragma pack(1)
// For backward compatability with old SDK versions, all structures within this header
// file will be byte packed on x86 platforms. All other platforms will only have those
// structures that will be used to decode network data packed.
#ifdef _X86_
#pragma pack(1)
#else
#pragma pack()
#endif

// yes we know that many of our structures have:
// warning C4200: nonstandard extension used : zero-sized array in struct/union
// this is OK and intended
#pragma warning(disable:4200)
//=============================================================================
//=============================================================================
//  (NPPTypes.h)
//=============================================================================
//=============================================================================
typedef BYTE *LPBYTE;

typedef const void *HBLOB;

//=============================================================================
// General constants.
//=============================================================================
#define	MAC_TYPE_UNKNOWN	( 0 )

#define	MAC_TYPE_ETHERNET	( 1 )

#define	MAC_TYPE_TOKENRING	( 2 )

#define	MAC_TYPE_FDDI	( 3 )

#define	MAC_TYPE_ATM	( 4 )

#define	MAC_TYPE_1394	( 5 )

#define	MACHINE_NAME_LENGTH	( 16 )

#define	USER_NAME_LENGTH	( 32 )

#define	ADAPTER_COMMENT_LENGTH	( 32 )

#define	CONNECTION_FLAGS_WANT_CONVERSATION_STATS	( 0x1 )

//=============================================================================
//  Transmit statistics structure.
//=============================================================================
typedef struct _TRANSMITSTATS
    {
    DWORD TotalFramesSent;
    DWORD TotalBytesSent;
    DWORD TotalTransmitErrors;
    } 	TRANSMITSTATS;

typedef TRANSMITSTATS *LPTRANSMITSTATS;

#define	TRANSMITSTATS_SIZE	( sizeof( TRANSMITSTATS  ) )

//=============================================================================
//  Statistics structure.
//=============================================================================
typedef struct _STATISTICS
    {
    __int64 TimeElapsed;
    DWORD TotalFramesCaptured;
    DWORD TotalBytesCaptured;
    DWORD TotalFramesFiltered;
    DWORD TotalBytesFiltered;
    DWORD TotalMulticastsFiltered;
    DWORD TotalBroadcastsFiltered;
    DWORD TotalFramesSeen;
    DWORD TotalBytesSeen;
    DWORD TotalMulticastsReceived;
    DWORD TotalBroadcastsReceived;
    DWORD TotalFramesDropped;
    DWORD TotalFramesDroppedFromBuffer;
    DWORD MacFramesReceived;
    DWORD MacCRCErrors;
    __int64 MacBytesReceivedEx;
    DWORD MacFramesDropped_NoBuffers;
    DWORD MacMulticastsReceived;
    DWORD MacBroadcastsReceived;
    DWORD MacFramesDropped_HwError;
    } 	STATISTICS;

typedef STATISTICS *LPSTATISTICS;

#define	STATISTICS_SIZE	( sizeof( STATISTICS  ) )

//=============================================================================
//  Address structures
//=============================================================================

// These structures are used to decode network data and so need to be packed

#pragma pack(push, 1)
#define	MAX_NAME_SIZE	( 32 )

#define	IP_ADDRESS_SIZE	( 4 )

#define	MAC_ADDRESS_SIZE	( 6 )

#define	IP6_ADDRESS_SIZE	( 16 )

// Q: What is the maximum address size that we could have to copy?
// A: IP6 
#define	MAX_ADDRESS_SIZE	( 16 )

#define	ADDRESS_TYPE_ETHERNET	( 0 )

#define	ADDRESS_TYPE_IP	( 1 )

#define	ADDRESS_TYPE_IPX	( 2 )

#define	ADDRESS_TYPE_TOKENRING	( 3 )

#define	ADDRESS_TYPE_FDDI	( 4 )

#define	ADDRESS_TYPE_XNS	( 5 )

#define	ADDRESS_TYPE_ANY	( 6 )

#define	ADDRESS_TYPE_ANY_GROUP	( 7 )

#define	ADDRESS_TYPE_FIND_HIGHEST	( 8 )

#define	ADDRESS_TYPE_VINES_IP	( 9 )

#define	ADDRESS_TYPE_LOCAL_ONLY	( 10 )

#define	ADDRESS_TYPE_ATM	( 11 )

#define	ADDRESS_TYPE_1394	( 12 )

#define	ADDRESS_TYPE_IP6	( 13 )

#define	ADDRESSTYPE_FLAGS_NORMALIZE	( 0x1 )

#define	ADDRESSTYPE_FLAGS_BIT_REVERSE	( 0x2 )

// Vines IP Address Structure
typedef struct _VINES_IP_ADDRESS
    {
    DWORD NetID;
    WORD SubnetID;
    } 	VINES_IP_ADDRESS;

typedef VINES_IP_ADDRESS *LPVINES_IP_ADDRESS;

#define	VINES_IP_ADDRESS_SIZE	( sizeof( VINES_IP_ADDRESS  ) )

// IPX Address Structure
typedef struct _IPX_ADDR
    {
    BYTE Subnet[ 4 ];
    BYTE Address[ 6 ];
    } 	IPX_ADDR;

typedef IPX_ADDR *LPIPX_ADDR;

#define	IPX_ADDR_SIZE	( sizeof( IPX_ADDR  ) )

// XNS Address Structure
typedef IPX_ADDR XNS_ADDRESS;

typedef IPX_ADDR *LPXNS_ADDRESS;

// ETHERNET SOURCE ADDRESS
typedef struct _ETHERNET_SRC_ADDRESS
{
    BYTE    RoutingBit:     1;
    BYTE    LocalBit:       1;
    BYTE    Byte0:          6;
    BYTE    Reserved[5];

} ETHERNET_SRC_ADDRESS;
typedef ETHERNET_SRC_ADDRESS *LPETHERNET_SRC_ADDRESS;
// ETHERNET DESTINATION ADDRESS
typedef struct _ETHERNET_DST_ADDRESS
{
    BYTE    GroupBit:       1;
    BYTE    AdminBit:       1;
    BYTE    Byte0:          6;
    BYTE    Reserved[5];
} ETHERNET_DST_ADDRESS;
typedef ETHERNET_DST_ADDRESS *LPETHERNET_DST_ADDRESS;

// FDDI addresses
typedef ETHERNET_SRC_ADDRESS FDDI_SRC_ADDRESS;
typedef ETHERNET_DST_ADDRESS FDDI_DST_ADDRESS;

typedef FDDI_SRC_ADDRESS *LPFDDI_SRC_ADDRESS;
typedef FDDI_DST_ADDRESS *LPFDDI_DST_ADDRESS;

// TOKENRING Source Address
typedef struct _TOKENRING_SRC_ADDRESS
{
    BYTE    Byte0:          6;
    BYTE    LocalBit:       1;
    BYTE    RoutingBit:     1;
    BYTE    Byte1;
    BYTE    Byte2:          7;
    BYTE    Functional:     1;
    BYTE    Reserved[3];
} TOKENRING_SRC_ADDRESS;
typedef TOKENRING_SRC_ADDRESS *LPTOKENRING_SRC_ADDRESS;

// TOKENRING Destination Address
typedef struct _TOKENRING_DST_ADDRESS
{
    BYTE    Byte0:          6;
    BYTE    AdminBit:       1;
    BYTE    GroupBit:       1;
    BYTE    Reserved[5];
} TOKENRING_DST_ADDRESS;
typedef TOKENRING_DST_ADDRESS *LPTOKENRING_DST_ADDRESS;
// Address Structure
typedef struct _ADDRESS2
{
    DWORD                       Type;

    union
    {
        // ADDRESS_TYPE_ETHERNET
        // ADDRESS_TYPE_TOKENRING
        // ADDRESS_TYPE_FDDI
        BYTE                    MACAddress[MAC_ADDRESS_SIZE];

        // IP
        BYTE                    IPAddress[IP_ADDRESS_SIZE];

        // IP6
        BYTE                    IP6Address[IP6_ADDRESS_SIZE];

        // raw IPX
        BYTE                    IPXRawAddress[IPX_ADDR_SIZE];

        // real IPX
        IPX_ADDR                IPXAddress;

        // raw Vines IP
        BYTE                    VinesIPRawAddress[VINES_IP_ADDRESS_SIZE];

        // real Vines IP
        VINES_IP_ADDRESS        VinesIPAddress;

        // ethernet with bits defined
        ETHERNET_SRC_ADDRESS    EthernetSrcAddress;

        // ethernet with bits defined
        ETHERNET_DST_ADDRESS    EthernetDstAddress;

        // tokenring with bits defined
        TOKENRING_SRC_ADDRESS   TokenringSrcAddress;

        // tokenring with bits defined
        TOKENRING_DST_ADDRESS   TokenringDstAddress;

        // fddi with bits defined
        FDDI_SRC_ADDRESS        FddiSrcAddress;

        // fddi with bits defined
        FDDI_DST_ADDRESS        FddiDstAddress;
    };
    
    WORD                        Flags;
} ADDRESS2;
typedef ADDRESS2 *LPADDRESS2;
#define ADDRESS2_SIZE   sizeof(ADDRESS2)


#pragma pack(pop)
//=============================================================================
//  Address Pair Structure
//=============================================================================
#define	ADDRESS_FLAGS_MATCH_DST	( 0x1 )

#define	ADDRESS_FLAGS_MATCH_SRC	( 0x2 )

#define	ADDRESS_FLAGS_EXCLUDE	( 0x4 )

#define	ADDRESS_FLAGS_DST_GROUP_ADDR	( 0x8 )

#define	ADDRESS_FLAGS_MATCH_BOTH	( 0x3 )

typedef struct _ADDRESSPAIR2
{
    WORD        AddressFlags;
    WORD        NalReserved;
    ADDRESS2    DstAddress;
    ADDRESS2    SrcAddress;

} ADDRESSPAIR2;
typedef ADDRESSPAIR2 *LPADDRESSPAIR2;
#define ADDRESSPAIR2_SIZE  sizeof(ADDRESSPAIR2)
//=============================================================================
//  Address table.
//=============================================================================
#define	MAX_ADDRESS_PAIRS	( 8 )

typedef struct _ADDRESSTABLE2
{
    DWORD           nAddressPairs;
    DWORD           nNonMacAddressPairs;
    ADDRESSPAIR2    AddressPair[MAX_ADDRESS_PAIRS];

} ADDRESSTABLE2;

typedef ADDRESSTABLE2 *LPADDRESSTABLE2;
#define ADDRESSTABLE2_SIZE sizeof(ADDRESSTABLE2)
//=============================================================================
//  Network information.
//=============================================================================
#define	NETWORKINFO_FLAGS_PMODE_NOT_SUPPORTED	( 0x1 )

#define	NETWORKINFO_FLAGS_REMOTE_NAL	( 0x4 )

#define	NETWORKINFO_FLAGS_REMOTE_NAL_CONNECTED	( 0x8 )

#define	NETWORKINFO_FLAGS_REMOTE_CARD	( 0x10 )

#define	NETWORKINFO_FLAGS_RAS	( 0x20 )

#define NETWORKINFO_RESERVED_FIELD_SIZE (FIELD_OFFSET(ADDRESS2,IPXAddress) + sizeof(IPX_ADDR))
typedef struct _NETWORKINFO
{
    BYTE            PermanentAddr[6];       //... Permanent MAC address
    BYTE            CurrentAddr[6];         //... Current  MAC address
    BYTE            Reserved[NETWORKINFO_RESERVED_FIELD_SIZE];
    DWORD           LinkSpeed;              //... Link speed in Mbits.
    DWORD           MacType;                //... Media type.
    DWORD           MaxFrameSize;           //... Max frame size allowed.
    DWORD           Flags;                  //... Informational flags.
    DWORD           TimestampScaleFactor;   //... 1 = 1/1 ms, 10 = 1/10 ms, 100 = 1/100 ms, etc.
    BYTE            NodeName[32];           //... Name of remote workstation.
    BOOL            PModeSupported;         //... Card claims to support P-Mode
    BYTE            Comment[ADAPTER_COMMENT_LENGTH]; // Adapter comment field.

} NETWORKINFO;
typedef NETWORKINFO *LPNETWORKINFO;
#define NETWORKINFO_SIZE    sizeof(NETWORKINFO)
#define	MINIMUM_FRAME_SIZE	( 32 )

//=============================================================================
//  Pattern structure.
//=============================================================================
#define	MAX_PATTERN_LENGTH	( 16 )

// When set this flag will cause those frames which do NOT have the specified pattern
// in the proper stop to be kept.
#define	PATTERN_MATCH_FLAGS_NOT	( 0x1 )

#define	PATTERN_MATCH_FLAGS_RESERVED_1	( 0x2 )

// When set this flag indicates that the user is not interested in a pattern match within 
// IP or IPX, but in the protocol that follows.  The driver will ensure that the protocol
// given in OffsetBasis is there and then that the port in the fram matches the port given.
// It will then calculate the offset from the beginning of the protocol that follows IP or IPX.
// NOTE: This flag is ignored if it is used with any OffsetBasis other than 
// OFFSET_BASIS_RELATIVE_TO_IPX or OFFSET_BASIS_RELATIVE_TO_IP
#define	PATTERN_MATCH_FLAGS_PORT_SPECIFIED	( 0x8 )

// The offset given is relative to the beginning of the frame. The 
// PATTERN_MATCH_FLAGS_PORT_SPECIFIED flag is ignored.
#define	OFFSET_BASIS_RELATIVE_TO_FRAME	( 0 )

// The offset given is relative to the beginning of the Effective Protocol.
// The Effective Protocol is defined as the protocol that follows
// the last protocol that determines Etype/SAP. In normal terms this means 
// that the Effective Protocol will be IP, IPX, XNS, or any of their ilk.
// The PATTERN_MATCH_FLAGS_PORT_SPECIFIED flag is ignored.
#define	OFFSET_BASIS_RELATIVE_TO_EFFECTIVE_PROTOCOL	( 1 )

// The offset given is relative to the beginning of IPX. If IPX is not present
// then the frame does not match. If the PATTERN_MATCH_FLAGS_PORT_SPECIFIED
// flag is set then the offset is relative to the beginning of the protocol
// which follows IPX.
#define	OFFSET_BASIS_RELATIVE_TO_IPX	( 2 )

// The offset given is relative to the beginning of IP. If IP is not present
// then the frame does not match. If the PATTERN_MATCH_FLAGS_PORT_SPECIFIED
// flag is set then the offset is relative to the beginning of the protocol
// which follows IP.
#define	OFFSET_BASIS_RELATIVE_TO_IP	( 3 )

// The offset given is relative to the beginning of IP6. If IP6 is not present
// then the frame does not match. If the PATTERN_MATCH_FLAGS_PORT_SPECIFIED
// flag is set then the offset is relative to the beginning of the protocol
// which follows IP6.
#define	OFFSET_BASIS_RELATIVE_TO_IP6	( 4 )

typedef /* [public][public][public][public][public][public][public][public][public] */ union __MIDL___MIDL_itf_netmon_0000_0000_0001
    {
    BYTE NextHeader;
    BYTE IPPort;
    WORD ByteSwappedIPXPort;
    } 	GENERIC_PORT;

typedef struct _PATTERNMATCH
    {
    DWORD Flags;
    BYTE OffsetBasis;
    GENERIC_PORT Port;
    WORD Offset;
    WORD Length;
    BYTE PatternToMatch[ 16 ];
    } 	PATTERNMATCH;

typedef PATTERNMATCH *LPPATTERNMATCH;

#define	PATTERNMATCH_SIZE	( sizeof( PATTERNMATCH  ) )

//=============================================================================
//  Expression structure.
//=============================================================================
#define	MAX_PATTERNS	( 4 )

typedef struct _ANDEXP
    {
    DWORD nPatternMatches;
    PATTERNMATCH PatternMatch[ 4 ];
    } 	ANDEXP;

typedef ANDEXP *LPANDEXP;

#define	ANDEXP_SIZE	( sizeof( ANDEXP  ) )

typedef struct _EXPRESSION
    {
    DWORD nAndExps;
    ANDEXP AndExp[ 4 ];
    } 	EXPRESSION;

typedef EXPRESSION *LPEXPRESSION;

#define	EXPRESSION_SIZE	( sizeof( EXPRESSION  ) )

//=============================================================================
//  Trigger.
//=============================================================================
#define	TRIGGER_TYPE_PATTERN_MATCH	( 1 )

#define	TRIGGER_TYPE_BUFFER_CONTENT	( 2 )

#define	TRIGGER_TYPE_PATTERN_MATCH_THEN_BUFFER_CONTENT	( 3 )

#define	TRIGGER_TYPE_BUFFER_CONTENT_THEN_PATTERN_MATCH	( 4 )

#define	TRIGGER_FLAGS_FRAME_RELATIVE	( 0 )

#define	TRIGGER_FLAGS_DATA_RELATIVE	( 0x1 )

#define	TRIGGER_ACTION_NOTIFY	( 0 )

#define	TRIGGER_ACTION_STOP	( 0x2 )

#define	TRIGGER_ACTION_PAUSE	( 0x3 )

#define	TRIGGER_BUFFER_FULL_25_PERCENT	( 0 )

#define	TRIGGER_BUFFER_FULL_50_PERCENT	( 1 )

#define	TRIGGER_BUFFER_FULL_75_PERCENT	( 2 )

#define	TRIGGER_BUFFER_FULL_100_PERCENT	( 3 )

typedef struct _TRIGGER
    {
    BOOL TriggerActive;
    BYTE TriggerType;
    BYTE TriggerAction;
    DWORD TriggerFlags;
    PATTERNMATCH TriggerPatternMatch;
    DWORD TriggerBufferSize;
    DWORD TriggerReserved;
    char TriggerCommandLine[ 260 ];
    } 	TRIGGER;

typedef TRIGGER *LPTRIGGER;

#define	TRIGGER_SIZE	( sizeof( TRIGGER  ) )

//=============================================================================
//  Capture filter.
//=============================================================================
//  Capture filter flags. By default all frames are rejected and
//  Network Monitor enables them based on the CAPTUREFILTER flags
//  defined below.
#define	CAPTUREFILTER_FLAGS_INCLUDE_ALL_SAPS	( 0x1 )

#define	CAPTUREFILTER_FLAGS_INCLUDE_ALL_ETYPES	( 0x2 )

#define	CAPTUREFILTER_FLAGS_TRIGGER	( 0x4 )

#define	CAPTUREFILTER_FLAGS_LOCAL_ONLY	( 0x8 )

// throw away our internal comment frames
#define	CAPTUREFILTER_FLAGS_DISCARD_COMMENTS	( 0x10 )

// Keep SMT and Token Ring MAC frames
#define	CAPTUREFILTER_FLAGS_KEEP_RAW	( 0x20 )

#define	CAPTUREFILTER_FLAGS_INCLUDE_ALL	( 0x3 )

#define	BUFFER_FULL_25_PERCENT	( 0 )

#define	BUFFER_FULL_50_PERCENT	( 1 )

#define	BUFFER_FULL_75_PERCENT	( 2 )

#define	BUFFER_FULL_100_PERCENT	( 3 )

typedef struct _CAPTUREFILTER
{
    DWORD           FilterFlags;      
    LPBYTE          lpSapTable;       
    LPWORD          lpEtypeTable;     
    WORD            nSaps;            
    WORD            nEtypes;          
    LPADDRESSTABLE2 AddressTable;     
    EXPRESSION      FilterExpression; 
    TRIGGER         Trigger;          
    DWORD           nFrameBytesToCopy;
    DWORD           Reserved;

} CAPTUREFILTER;
typedef CAPTUREFILTER *LPCAPTUREFILTER;
#define CAPTUREFILTER_SIZE    sizeof(CAPTUREFILTER)
//=============================================================================
//  Frame type.
//=============================================================================
//  TimeStamp is in 1/1,000,000th seconds.
typedef struct _FRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    BYTE MacFrame[ 1 ];
    } 	FRAME;

typedef FRAME *LPFRAME;

typedef FRAME UNALIGNED *ULPFRAME;
#define	FRAME_SIZE	( sizeof( FRAME  ) )

//=============================================================================
//  Frame descriptor type.
//=============================================================================
#define	LOW_PROTOCOL_IPX	( OFFSET_BASIS_RELATIVE_TO_IPX )

#define	LOW_PROTOCOL_IP	( OFFSET_BASIS_RELATIVE_TO_IP )

#define	LOW_PROTOCOL_IP6	( OFFSET_BASIS_RELATIVE_TO_IP6 )

#define	LOW_PROTOCOL_UNKNOWN	( ( BYTE  )-1 )

typedef struct _FRAME_DESCRIPTOR
    {
    LPBYTE FramePointer;
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    WORD Etype;
    BYTE Sap;
    BYTE LowProtocol;
    WORD LowProtocolOffset;
    /* [switch_type] */ union 
        {
        WORD Reserved;
        BYTE IPPort;
        WORD ByteSwappedIPXPort;
        } 	HighPort;
    WORD HighProtocolOffset;
    } 	FRAME_DESCRIPTOR;

typedef FRAME_DESCRIPTOR *LPFRAME_DESCRIPTOR;

#define	FRAME_DESCRIPTOR_SIZE	( sizeof( FRAME_DESCRIPTOR  ) )

//=============================================================================
//  Frame descriptor table.
//=============================================================================
typedef struct _FRAMETABLE
    {
    DWORD FrameTableLength;
    DWORD StartIndex;
    DWORD EndIndex;
    DWORD FrameCount;
    FRAME_DESCRIPTOR Frames[ 1 ];
    } 	FRAMETABLE;

typedef FRAMETABLE *LPFRAMETABLE;

//=============================================================================
//  Station statistics.
//=============================================================================
#define	STATIONSTATS_FLAGS_INITIALIZED	( 0x1 )

#define	STATIONSTATS_FLAGS_EVENTPOSTED	( 0x2 )

#define	STATIONSTATS_POOL_SIZE	( 100 )

typedef struct _STATIONSTATS
    {
    DWORD NextStationStats;
    DWORD SessionPartnerList;
    DWORD Flags;
    BYTE StationAddress[ 6 ];
    WORD Pad;
    DWORD TotalPacketsReceived;
    DWORD TotalDirectedPacketsSent;
    DWORD TotalBroadcastPacketsSent;
    DWORD TotalMulticastPacketsSent;
    DWORD TotalBytesReceived;
    DWORD TotalBytesSent;
    } 	STATIONSTATS;

typedef STATIONSTATS *LPSTATIONSTATS;

#define	STATIONSTATS_SIZE	( sizeof( STATIONSTATS  ) )

//=============================================================================
//  Session statistics.
//=============================================================================
#define	SESSION_FLAGS_INITIALIZED	( 0x1 )

#define	SESSION_FLAGS_EVENTPOSTED	( 0x2 )

#define	SESSION_POOL_SIZE	( 100 )

typedef struct _SESSIONSTATS
    {
    DWORD NextSession;
    DWORD StationOwner;
    DWORD StationPartner;
    DWORD Flags;
    DWORD TotalPacketsSent;
    } 	SESSIONSTATS;

typedef SESSIONSTATS *LPSESSIONSTATS;

#define	SESSIONSTATS_SIZE	( sizeof( SESSIONSTATS  ) )

//=============================================================================
//  Station Query
//=============================================================================

// These structures are obsolete and should not be used
// They are included so that our interfaces need not change

#pragma pack(push, 1)
typedef struct _STATIONQUERY
    {
    DWORD Flags;
    BYTE BCDVerMinor;
    BYTE BCDVerMajor;
    DWORD LicenseNumber;
    BYTE MachineName[ 16 ];
    BYTE UserName[ 32 ];
    BYTE Reserved[ 32 ];
    BYTE AdapterAddress[ 6 ];
    WCHAR WMachineName[ 16 ];
    WCHAR WUserName[ 32 ];
    } 	STATIONQUERY;

typedef STATIONQUERY *LPSTATIONQUERY;

#define	STATIONQUERY_SIZE	( sizeof( STATIONQUERY  ) )


#pragma pack(pop)
//=============================================================================
//   structure.
//=============================================================================
typedef struct _QUERYTABLE
    {
    DWORD nStationQueries;
    STATIONQUERY StationQuery[ 1 ];
    } 	QUERYTABLE;

typedef QUERYTABLE *LPQUERYTABLE;

#define	QUERYTABLE_SIZE	( sizeof( QUERYTABLE  ) )

//=============================================================================
//  The LINK structure is used to chain structures together into a list.
//=============================================================================
typedef struct _LINK *LPLINK;

typedef struct _LINK
    {
    LPLINK PrevLink;
    LPLINK NextLink;
    } 	LINK;

//=============================================================================
//  Security Response packet
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
#define	MAX_SECURITY_BREACH_REASON_SIZE	( 100 )

#define	MAX_SIGNATURE_LENGTH	( 128 )

#define	MAX_USER_NAME_LENGTH	( 256 )

typedef struct _SECURITY_PERMISSION_RESPONSE
    {
    UINT Version;
    DWORD RandomNumber;
    BYTE MachineName[ 16 ];
    BYTE Address[ 6 ];
    BYTE UserName[ 256 ];
    BYTE Reason[ 100 ];
    DWORD SignatureLength;
    BYTE Signature[ 128 ];
    } 	SECURITY_PERMISSION_RESPONSE;

typedef SECURITY_PERMISSION_RESPONSE *LPSECURITY_PERMISSION_RESPONSE;

typedef SECURITY_PERMISSION_RESPONSE UNALIGNED * ULPSECURITY_PERMISSION_RESPONSE;
#define	SECURITY_PERMISSION_RESPONSE_SIZE	( sizeof( SECURITY_PERMISSION_RESPONSE  ) )


#pragma pack(pop)
//=============================================================================
//  Callback type
//=============================================================================
// generic events
#define	UPDATE_EVENT_TERMINATE_THREAD	( 0 )

#define	UPDATE_EVENT_NETWORK_STATUS	( 0x1 )

// rtc events
#define	UPDATE_EVENT_RTC_INTERVAL_ELAPSED	( 0x2 )

#define	UPDATE_EVENT_RTC_FRAME_TABLE_FULL	( 0x3 )

#define	UPDATE_EVENT_RTC_BUFFER_FULL	( 0x4 )

// delayed events
#define	UPDATE_EVENT_TRIGGER_BUFFER_CONTENT	( 0x5 )

#define	UPDATE_EVENT_TRIGGER_PATTERN_MATCH	( 0x6 )

#define	UPDATE_EVENT_TRIGGER_BUFFER_PATTERN	( 0x7 )

#define	UPDATE_EVENT_TRIGGER_PATTERN_BUFFER	( 0x8 )

// transmit events
#define	UPDATE_EVENT_TRANSMIT_STATUS	( 0x9 )

// Security events
#define	UPDATE_EVENT_SECURITY_BREACH	( 0xa )

// Remote failure event
#define	UPDATE_EVENT_REMOTE_FAILURE	( 0xb )

// actions
#define	UPDATE_ACTION_TERMINATE_THREAD	( 0 )

#define	UPDATE_ACTION_NOTIFY	( 0x1 )

#define	UPDATE_ACTION_STOP_CAPTURE	( 0x2 )

#define	UPDATE_ACTION_PAUSE_CAPTURE	( 0x3 )

#define	UPDATE_ACTION_RTC_BUFFER_SWITCH	( 0x4 )

typedef struct _UPDATE_EVENT
    {
    USHORT Event;
    DWORD Action;
    DWORD Status;
    DWORD Value;
    __int64 TimeStamp;
    DWORD_PTR lpUserContext;
    DWORD_PTR lpReserved;
    UINT FramesDropped;
    /* [switch_type] */ union 
        {
        DWORD Reserved;
        LPFRAMETABLE lpFrameTable;
        DWORD_PTR lpPacketQueue;
        SECURITY_PERMISSION_RESPONSE SecurityResponse;
        } 	;
    LPSTATISTICS lpFinalStats;
    } 	UPDATE_EVENT;

typedef UPDATE_EVENT *PUPDATE_EVENT;

// note for c++ users:
// the declaration for this callback should be in the public part of the header file:
// static WINAPI DWORD NetworkCallback( UPDATE_EVENT events);
// and the implementation should be, in the protected section of the cpp file:
// DWORD WINAPI ClassName::NetworkCallback( UPDATE_EVENT events) {};
//typedef DWORD (WINAPI *LPNETWORKCALLBACKPROC)( UPDATE_EVENT);
typedef DWORD (WINAPI *LPNETWORKCALLBACKPROC)( UPDATE_EVENT);
//=============================================================================
//  NETWORKSTATUS data structure.
//=============================================================================
typedef struct _NETWORKSTATUS
    {
    DWORD State;
    DWORD Flags;
    } 	NETWORKSTATUS;

typedef NETWORKSTATUS *LPNETWORKSTATUS;

#define	NETWORKSTATUS_SIZE	( sizeof( NETWORKSTATUS  ) )

#define	NETWORKSTATUS_STATE_VOID	( 0 )

#define	NETWORKSTATUS_STATE_INIT	( 1 )

#define	NETWORKSTATUS_STATE_CAPTURING	( 2 )

#define	NETWORKSTATUS_STATE_PAUSED	( 3 )

#define	NETWORKSTATUS_FLAGS_TRIGGER_PENDING	( 0x1 )

#define MAKE_WORD(l, h)         (((WORD) (l)) | (((WORD) (h)) << 8))
#define MAKE_LONG(l, h)         (((DWORD) (l)) | (((DWORD) (h)) << 16L))
#define MAKE_SIG(a, b, c, d)    MAKE_LONG(MAKE_WORD(a, b), MAKE_WORD(c, d))
//=============================================================================
//  STATISTICS parameter structure.
//=============================================================================
#define	MAX_SESSIONS	( 100 )

#define	MAX_STATIONS	( 100 )

typedef struct _STATISTICSPARAM
    {
    DWORD StatisticsSize;
    STATISTICS Statistics;
    DWORD StatisticsTableEntries;
    STATIONSTATS StatisticsTable[ 100 ];
    DWORD SessionTableEntries;
    SESSIONSTATS SessionTable[ 100 ];
    } 	STATISTICSPARAM;

typedef STATISTICSPARAM *LPSTATISTICSPARAM;

#define	STATISTICSPARAM_SIZE	( sizeof( STATISTICSPARAM  ) )

//=============================================================================
//  Capture file header.
//=============================================================================

// This structure is used to decode file data and so needs to be packed

#pragma pack(push, 1)
#define	CAPTUREFILE_VERSION_MAJOR	( 2 )

#define	CAPTUREFILE_VERSION_MINOR	( 0 )

#define MakeVersion(Major, Minor)   ((DWORD) MAKEWORD(Minor, Major))
#define GetCurrentVersion()         MakeVersion(CAPTUREFILE_VERSION_MAJOR, CAPTUREFILE_VERSION_MINOR)
#define NETMON_1_0_CAPTUREFILE_SIGNATURE     MAKE_IDENTIFIER('R', 'T', 'S', 'S')
#define NETMON_2_0_CAPTUREFILE_SIGNATURE     MAKE_IDENTIFIER('G', 'M', 'B', 'U')
typedef struct _CAPTUREFILE_HEADER_VALUES
    {
    DWORD Signature;
    BYTE BCDVerMinor;
    BYTE BCDVerMajor;
    WORD MacType;
    SYSTEMTIME TimeStamp;
    DWORD FrameTableOffset;
    DWORD FrameTableLength;
    DWORD UserDataOffset;
    DWORD UserDataLength;
    DWORD CommentDataOffset;
    DWORD CommentDataLength;
    DWORD StatisticsOffset;
    DWORD StatisticsLength;
    DWORD NetworkInfoOffset;
    DWORD NetworkInfoLength;
    DWORD ConversationStatsOffset;
    DWORD ConversationStatsLength;
    } 	CAPTUREFILE_HEADER_VALUES;

typedef CAPTUREFILE_HEADER_VALUES *LPCAPTUREFILE_HEADER_VALUES;

#define	CAPTUREFILE_HEADER_VALUES_SIZE	( sizeof( CAPTUREFILE_HEADER_VALUES  ) )


#pragma pack(pop)
//=============================================================================
//  Capture file.
//=============================================================================

// This structure is used to decode file data and so needs to be packed

#pragma pack(push, 1)
typedef struct _CAPTUREFILE_HEADER
    {
    union 
        {
        CAPTUREFILE_HEADER_VALUES ActualHeader;
        BYTE Buffer[ 72 ];
        } 	;
    BYTE Reserved[ 56 ];
    } 	CAPTUREFILE_HEADER;

typedef CAPTUREFILE_HEADER *LPCAPTUREFILE_HEADER;

#define	CAPTUREFILE_HEADER_SIZE	( sizeof( CAPTUREFILE_HEADER  ) )


#pragma pack(pop)
//=============================================================================
//  Stats Frame definitions.
//=============================================================================

// These structures are used to create network data and so need to be packed

#pragma pack(push, 1)
typedef struct _EFRAMEHDR
    {
    BYTE SrcAddress[ 6 ];
    BYTE DstAddress[ 6 ];
    WORD Length;
    BYTE DSAP;
    BYTE SSAP;
    BYTE Control;
    BYTE ProtocolID[ 3 ];
    WORD EtherType;
    } 	EFRAMEHDR;

typedef struct _TRFRAMEHDR
    {
    BYTE AC;
    BYTE FC;
    BYTE SrcAddress[ 6 ];
    BYTE DstAddress[ 6 ];
    BYTE DSAP;
    BYTE SSAP;
    BYTE Control;
    BYTE ProtocolID[ 3 ];
    WORD EtherType;
    } 	TRFRAMEHDR;

#define	DEFAULT_TR_AC	( 0 )

#define	DEFAULT_TR_FC	( 0x40 )

#define	DEFAULT_SAP	( 0xaa )

#define	DEFAULT_CONTROL	( 0x3 )

#define	DEFAULT_ETHERTYPE	( 0x8419 )

typedef struct _FDDIFRAMEHDR
    {
    BYTE FC;
    BYTE SrcAddress[ 6 ];
    BYTE DstAddress[ 6 ];
    BYTE DSAP;
    BYTE SSAP;
    BYTE Control;
    BYTE ProtocolID[ 3 ];
    WORD EtherType;
    } 	FDDIFRAMEHDR;

#define	DEFAULT_FDDI_FC	( 0x10 )

typedef struct _FDDISTATFRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    FDDIFRAMEHDR FrameHeader;
    BYTE FrameID[ 4 ];
    DWORD Flags;
    DWORD FrameType;
    WORD StatsDataLen;
    DWORD StatsVersion;
    STATISTICS Statistics;
    } 	FDDISTATFRAME;

typedef FDDISTATFRAME *LPFDDISTATFRAME;

typedef FDDISTATFRAME UNALIGNED *ULPFDDISTATFRAME;
#define	FDDISTATFRAME_SIZE	( sizeof( FDDISTATFRAME  ) )

typedef struct _ATMFRAMEHDR
    {
    BYTE SrcAddress[ 6 ];
    BYTE DstAddress[ 6 ];
    WORD Vpi;
    WORD Vci;
    } 	ATMFRAMEHDR;

typedef struct _ATMSTATFRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    ATMFRAMEHDR FrameHeader;
    BYTE FrameID[ 4 ];
    DWORD Flags;
    DWORD FrameType;
    WORD StatsDataLen;
    DWORD StatsVersion;
    STATISTICS Statistics;
    } 	ATMSTATFRAME;

typedef ATMSTATFRAME *LPATMSTATFRAME;

typedef ATMSTATFRAME UNALIGNED *ULPATMSTATFRAME;
#define	ATMSTATFRAME_SIZE	( sizeof( ATMSTATFRAME  ) )

typedef struct _TRSTATFRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    TRFRAMEHDR FrameHeader;
    BYTE FrameID[ 4 ];
    DWORD Flags;
    DWORD FrameType;
    WORD StatsDataLen;
    DWORD StatsVersion;
    STATISTICS Statistics;
    } 	TRSTATFRAME;

typedef TRSTATFRAME *LPTRSTATFRAME;

typedef TRSTATFRAME UNALIGNED *ULPTRSTATFRAME;
#define	TRSTATFRAME_SIZE	( sizeof( TRSTATFRAME  ) )

typedef struct _ESTATFRAME
    {
    __int64 TimeStamp;
    DWORD FrameLength;
    DWORD nBytesAvail;
    EFRAMEHDR FrameHeader;
    BYTE FrameID[ 4 ];
    DWORD Flags;
    DWORD FrameType;
    WORD StatsDataLen;
    DWORD StatsVersion;
    STATISTICS Statistics;
    } 	ESTATFRAME;

typedef ESTATFRAME *LPESTATFRAME;

typedef ESTATFRAME UNALIGNED *ULPESTATFRAME;
#define	ESTATFRAME_SIZE	( sizeof( ESTATFRAME  ) )

#define	STATISTICS_VERSION_1_0	( 0 )

#define	STATISTICS_VERSION_2_0	( 0x20 )

#define	MAX_STATSFRAME_SIZE	( sizeof( TRSTATFRAME  ) )

#define	STATS_FRAME_TYPE	( 103 )


#pragma pack(pop)
//****************************************************************************
//****************************************************************************
// Obsolete structures
// The newer structures (named with a 2 appended) should be used
//****************************************************************************
//****************************************************************************

#pragma pack(push, 1)
// Address Structure
// Obsolete, ADDRESS2 should be used
typedef struct _ADDRESS
{
    DWORD                       Type;

    union
    {
        // ADDRESS_TYPE_ETHERNET
        // ADDRESS_TYPE_TOKENRING
        // ADDRESS_TYPE_FDDI
        BYTE                    MACAddress[MAC_ADDRESS_SIZE];

        // IP
        BYTE                    IPAddress[IP_ADDRESS_SIZE];

        // raw IPX
        BYTE                    IPXRawAddress[IPX_ADDR_SIZE];

        // real IPX
        IPX_ADDR                IPXAddress;

        // raw Vines IP
        BYTE                    VinesIPRawAddress[VINES_IP_ADDRESS_SIZE];

        // real Vines IP
        VINES_IP_ADDRESS        VinesIPAddress;

        // ethernet with bits defined
        ETHERNET_SRC_ADDRESS    EthernetSrcAddress;

        // ethernet with bits defined
        ETHERNET_DST_ADDRESS    EthernetDstAddress;

        // tokenring with bits defined
        TOKENRING_SRC_ADDRESS   TokenringSrcAddress;

        // tokenring with bits defined
        TOKENRING_DST_ADDRESS   TokenringDstAddress;

        // fddi with bits defined
        FDDI_SRC_ADDRESS        FddiSrcAddress;

        // fddi with bits defined
        FDDI_DST_ADDRESS        FddiDstAddress;
    };
    
    WORD                        Flags;
} ADDRESS;
typedef ADDRESS *LPADDRESS;
#define ADDRESS_SIZE   sizeof(ADDRESS)


#pragma pack(pop)
// Obsolete, ADDRESSPAIR2 should be used
typedef struct _ADDRESSPAIR
{
    WORD        AddressFlags;
    WORD        NalReserved;
    ADDRESS     DstAddress;
    ADDRESS     SrcAddress;

} ADDRESSPAIR;
typedef ADDRESSPAIR *LPADDRESSPAIR;
#define ADDRESSPAIR_SIZE  sizeof(ADDRESSPAIR)
// Obsolete, ADDRESSTABLE2 should be used
typedef struct _ADDRESSTABLE
{
    DWORD           nAddressPairs;
    DWORD           nNonMacAddressPairs;
    ADDRESSPAIR     AddressPair[MAX_ADDRESS_PAIRS];

} ADDRESSTABLE;

typedef ADDRESSTABLE *LPADDRESSTABLE;
#define ADDRESSTABLE_SIZE sizeof(ADDRESSTABLE)
// Obsolete, ADDRESSINFO2 should be used
typedef struct _ADDRESSINFO
{
    ADDRESS        Address;
    WCHAR          Name[MAX_NAME_SIZE];
    DWORD          Flags;
    LPVOID         lpAddressInstData;

} ADDRESSINFO;
typedef struct _ADDRESSINFO *LPADDRESSINFO;
#define ADDRESSINFO_SIZE    sizeof(ADDRESSINFO)
// Obsolete, ADDRESSINFOTABLE2 should be used
typedef struct _ADDRESSINFOTABLE
{
    DWORD         nAddressInfos;
    LPADDRESSINFO lpAddressInfo[0];

} ADDRESSINFOTABLE;
typedef ADDRESSINFOTABLE *LPADDRESSINFOTABLE;
#define ADDRESSINFOTABLE_SIZE   sizeof(ADDRESSINFOTABLE)
//****************************************************************************
//****************************************************************************
// Obsolete functions
// The newer functions should be used
//****************************************************************************
//****************************************************************************
// Obsolete, SetNPPAddress2FilterInBlob should be used
DWORD _cdecl SetNPPAddressFilterInBlob( HBLOB hBlob,
                                 LPADDRESSTABLE pAddressTable);
// Obsolete, GetNPPAddress2FilterFromBlob should be used
DWORD _cdecl GetNPPAddressFilterFromBlob( HBLOB hBlob,
                                   LPADDRESSTABLE pAddressTable,
                                   HBLOB hErrorBlob);
//=============================================================================
//=============================================================================
//  (NMEvent.h)
//=============================================================================
//=============================================================================

#pragma pack(push, 8)
// NMCOLUMNTYPE
typedef /* [public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_netmon_0000_0000_0005
    {	NMCOLUMNTYPE_UINT8	= 0,
	NMCOLUMNTYPE_SINT8	= ( NMCOLUMNTYPE_UINT8 + 1 ) ,
	NMCOLUMNTYPE_UINT16	= ( NMCOLUMNTYPE_SINT8 + 1 ) ,
	NMCOLUMNTYPE_SINT16	= ( NMCOLUMNTYPE_UINT16 + 1 ) ,
	NMCOLUMNTYPE_UINT32	= ( NMCOLUMNTYPE_SINT16 + 1 ) ,
	NMCOLUMNTYPE_SINT32	= ( NMCOLUMNTYPE_UINT32 + 1 ) ,
	NMCOLUMNTYPE_FLOAT64	= ( NMCOLUMNTYPE_SINT32 + 1 ) ,
	NMCOLUMNTYPE_FRAME	= ( NMCOLUMNTYPE_FLOAT64 + 1 ) ,
	NMCOLUMNTYPE_YESNO	= ( NMCOLUMNTYPE_FRAME + 1 ) ,
	NMCOLUMNTYPE_ONOFF	= ( NMCOLUMNTYPE_YESNO + 1 ) ,
	NMCOLUMNTYPE_TRUEFALSE	= ( NMCOLUMNTYPE_ONOFF + 1 ) ,
	NMCOLUMNTYPE_MACADDR	= ( NMCOLUMNTYPE_TRUEFALSE + 1 ) ,
	NMCOLUMNTYPE_IPXADDR	= ( NMCOLUMNTYPE_MACADDR + 1 ) ,
	NMCOLUMNTYPE_IPADDR	= ( NMCOLUMNTYPE_IPXADDR + 1 ) ,
	NMCOLUMNTYPE_VARTIME	= ( NMCOLUMNTYPE_IPADDR + 1 ) ,
	NMCOLUMNTYPE_STRING	= ( NMCOLUMNTYPE_VARTIME + 1 ) 
    } 	NMCOLUMNTYPE;

// NMCOLUMNVARIANT
typedef struct _NMCOLUMNVARIANT
    {
    NMCOLUMNTYPE Type;
    union 
        {
        BYTE Uint8Val;
        char Sint8Val;
        WORD Uint16Val;
        short Sint16Val;
        DWORD Uint32Val;
        long Sint32Val;
        DOUBLE Float64Val;
        DWORD FrameVal;
        BOOL YesNoVal;
        BOOL OnOffVal;
        BOOL TrueFalseVal;
        BYTE MACAddrVal[ 6 ];
        IPX_ADDR IPXAddrVal;
        DWORD IPAddrVal;
        DOUBLE VarTimeVal;
        LPCSTR pStringVal;
        } 	Value;
    } 	NMCOLUMNVARIANT;

// COLUMNINFO
typedef struct _NMCOLUMNINFO
    {
    LPSTR szColumnName;
    NMCOLUMNVARIANT VariantData;
    } 	NMCOLUMNINFO;

typedef NMCOLUMNINFO *PNMCOLUMNINFO;

// JTYPE
typedef LPSTR JTYPE;

// EVENTDATA
#ifdef MIDL_PASS
typedef struct _NMEVENTDATA
    {
    LPSTR pszReserved;
    BYTE Version;
    DWORD EventIdent;
    DWORD Flags;
    DWORD Severity;
    BYTE NumColumns;
    LPSTR szSourceName;
    LPSTR szEventName;
    LPSTR szDescription;
    LPSTR szMachine;
    JTYPE Justification;
    PVOID pvReserved;
    SYSTEMTIME SysTime;
    NMCOLUMNINFO Column[ 1 ];
    } 	NMEVENTDATA;

#else  // MIDL_PASS
typedef struct _NMEVENTDATA 
{                            
    LPSTR      pszReserved;  // Reserved
    BYTE       Version;      // Version for this structure (must be 0)
    DWORD      EventIdent;   // ID for this event
    DWORD      Flags;        // Flags for Expert generated and others
    DWORD      Severity;     // Severity level
    BYTE       NumColumns;   // Number of optional columns for this event
    LPSTR      szSourceName; // Name of Expert
    LPSTR      szEventName;  // Name of event
    LPSTR      szDescription;// Description of event
    LPSTR      szMachine;    // Name (or IPADDRESS?) of the machine supplying the event (NULL for Experts usually)
    JTYPE      Justification;// Justification pane info (currently a string, but possible structure)
    PVOID      pvReserved;   // Reserved
    SYSTEMTIME SysTime;      // Systemtime of the event
    NMCOLUMNINFO Column[0];    
} NMEVENTDATA;
#endif // MIDL_PASS
typedef NMEVENTDATA *PNMEVENTDATA;


#pragma pack(pop)
// EVENT FLAGS
#define	NMEVENTFLAG_EXPERT	( 0x1 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_SEVERITY	( 0x80000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_SOURCE	( 0x40000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_EVENT_NAME	( 0x20000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_DESCRIPTION	( 0x10000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_MACHINE	( 0x8000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_TIME	( 0x4000000 )

#define	NMEVENTFLAG_DO_NOT_DISPLAY_DATE	( 0x2000000 )

//#define NMEVENTFLAG_DO_NOT_DISPLAY_FIXED_COLUMNS (NMEVENTFLAG_DO_NOT_DISPLAY_SEVERITY   | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_SOURCE     | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_EVENT_NAME | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_DESCRIPTION| \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_MACHINE    | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_TIME       | \
//                                                  NMEVENTFLAG_DO_NOT_DISPLAY_DATE )
#define	NMEVENTFLAG_DO_NOT_DISPLAY_FIXED_COLUMNS	( 0xfe000000 )


enum _NMEVENT_SEVERITIES
    {	NMEVENT_SEVERITY_INFORMATIONAL	= 0,
	NMEVENT_SEVERITY_WARNING	= ( NMEVENT_SEVERITY_INFORMATIONAL + 1 ) ,
	NMEVENT_SEVERITY_STRONG_WARNING	= ( NMEVENT_SEVERITY_WARNING + 1 ) ,
	NMEVENT_SEVERITY_ERROR	= ( NMEVENT_SEVERITY_STRONG_WARNING + 1 ) ,
	NMEVENT_SEVERITY_SEVERE_ERROR	= ( NMEVENT_SEVERITY_ERROR + 1 ) ,
	NMEVENT_SEVERITY_CRITICAL_ERROR	= ( NMEVENT_SEVERITY_SEVERE_ERROR + 1 ) 
    } ;
//=============================================================================
//=============================================================================
// (Finder.h)
//=============================================================================
//=============================================================================
//=============================================================================
// Structures use by NPPs & the Finder
//=============================================================================
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0000_0007
    {
    DWORD dwNumBlobs;
    HBLOB hBlobs[ 1 ];
    } 	BLOB_TABLE;

typedef BLOB_TABLE *PBLOB_TABLE;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0000_0008
    {
    DWORD size;
    BYTE *pBytes;
    } 	MBLOB;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0000_0009
    {
    DWORD dwNumBlobs;
    MBLOB mBlobs[ 1 ];
    } 	MBLOB_TABLE;

typedef MBLOB_TABLE *PMBLOB_TABLE;

//=============================================================================
// Functions called by monitors, tools, netmon
//=============================================================================
DWORD _cdecl GetNPPBlobTable(HBLOB          hFilterBlob,  
                      PBLOB_TABLE*   ppBlobTable);

DWORD _cdecl GetNPPBlobFromUI(HWND          hwnd,
                       HBLOB         hFilterBlob,
                       HBLOB*        phBlob);          

DWORD _cdecl GetNPPBlobFromUIExU(HWND          hwnd,
                          HBLOB         hFilterBlob,
                          HBLOB*        phBlob,
                          char*         szHelpFileName);          

DWORD _cdecl SelectNPPBlobFromTable( HWND   hwnd,
                              PBLOB_TABLE    pBlobTable,
                              HBLOB*         hBlob);

DWORD _cdecl SelectNPPBlobFromTableExU( HWND   hwnd,
                                 PBLOB_TABLE    pBlobTable,
                                 HBLOB*         hBlob,
                                 char*          szHelpFileName);

//=============================================================================
// Helper functions provided by the Finder
//=============================================================================

__inline DWORD BLOB_TABLE_SIZE(DWORD dwNumBlobs)
{
    return (DWORD) (sizeof(BLOB_TABLE)+dwNumBlobs*sizeof(HBLOB));
}

__inline PBLOB_TABLE  AllocBlobTable(DWORD dwNumBlobs)
{
    DWORD size = BLOB_TABLE_SIZE(dwNumBlobs);

    return (PBLOB_TABLE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}

__inline DWORD MBLOB_TABLE_SIZE(DWORD dwNumBlobs)
{
    return (DWORD) (sizeof(MBLOB_TABLE)+dwNumBlobs*sizeof(MBLOB));
}

__inline PMBLOB_TABLE  AllocMBlobTable(DWORD dwNumBlobs)
{
    DWORD size = MBLOB_TABLE_SIZE(dwNumBlobs);

    return (PMBLOB_TABLE)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}

//=============================================================================
// Functions provided by NPPs, called by the Finder
//=============================================================================

// For NPP's that can return a Blob table without additional configuration.
DWORD _cdecl GetNPPBlobs(PBLOB_TABLE*       ppBlobTable);
typedef DWORD (_cdecl FAR* BLOBSPROC) (PBLOB_TABLE*       ppBlobTable);

// For NPP's that need additional information to return a Blob table.
DWORD _cdecl GetConfigBlob(HBLOB*      phBlob);
typedef DWORD (_cdecl FAR* GETCFGBLOB) (HBLOB, HBLOB*);
typedef DWORD (_cdecl FAR* CFGPROC) (HWND               hwnd,
                              HBLOB              SpecialBlob,
                              PBLOB_TABLE*       ppBlobTable);

//=============================================================================
// Handy functions
//=============================================================================
BOOL  _cdecl FilterNPPBlob(HBLOB hBlob, HBLOB FilterBlob);

BOOL  _cdecl RaiseNMEvent(HINSTANCE    hInstance,
                   WORD         EventType, 
                   DWORD        EventID,
                   WORD         nStrings, 
                   const char** aInsertStrs,
                   LPVOID       lpvData,
                   DWORD        dwDataSize);

//=============================================================================
//=============================================================================
//  (NMmonitor.h)
//=============================================================================
//=============================================================================
//=============================================================================
//=============================================================================
//  (NMSupp.h)
//=============================================================================
//=============================================================================

#ifndef __cplusplus
#ifndef try
#define try                         __try
#endif // try

#ifndef except
#define except                      __except
#endif // except
#endif // __cplusplus
//=============================================================================
//  Windows version constants.
//=============================================================================
#define	WINDOWS_VERSION_UNKNOWN	( 0 )

#define	WINDOWS_VERSION_WIN32S	( 1 )

#define	WINDOWS_VERSION_WIN32C	( 2 )

#define	WINDOWS_VERSION_WIN32	( 3 )

//=============================================================================
//  Frame masks.
//=============================================================================
#define	FRAME_MASK_ETHERNET	( ( BYTE  )~0x1 )

#define	FRAME_MASK_TOKENRING	( ( BYTE  )~0x80 )

#define	FRAME_MASK_FDDI	( ( BYTE  )~0x1 )

//=============================================================================
//  Object heap type.
//=============================================================================
typedef LPVOID HOBJECTHEAP;

//=============================================================================
//  Object cleanup procedure.
//=============================================================================

typedef VOID (WINAPI *OBJECTPROC)(HOBJECTHEAP, LPVOID);

//=============================================================================
//  Network Monitor timers.
//=============================================================================
typedef struct _TIMER *HTIMER;

typedef VOID (WINAPI *BHTIMERPROC)(LPVOID);

HTIMER WINAPI BhSetTimer(BHTIMERPROC TimerProc, LPVOID InstData, DWORD TimeOut);

VOID   WINAPI BhKillTimer(HTIMER hTimer);

//=============================================================================
//  Network Monitor global error API.
//=============================================================================

DWORD  WINAPI BhGetLastError(VOID);

DWORD  WINAPI BhSetLastError(DWORD Error);

//=============================================================================
//  Object manager function prototypes.
//=============================================================================

HOBJECTHEAP WINAPI CreateObjectHeap(DWORD ObjectSize, OBJECTPROC ObjectProc);

HOBJECTHEAP WINAPI DestroyObjectHeap(HOBJECTHEAP hObjectHeap);

LPVOID      WINAPI AllocObject(HOBJECTHEAP hObjectHeap);

LPVOID      WINAPI FreeObject(HOBJECTHEAP hObjectHeap, LPVOID ObjectMemory);

DWORD       WINAPI GrowObjectHeap(HOBJECTHEAP hObjectHeap, DWORD nObjects);

DWORD       WINAPI GetObjectHeapSize(HOBJECTHEAP hObjectHeap);

VOID        WINAPI PurgeObjectHeap(HOBJECTHEAP hObjectHeap);

//=============================================================================
//  Memory functions.
//=============================================================================

LPVOID     WINAPI AllocMemory(SIZE_T size);

LPVOID     WINAPI ReallocMemory(LPVOID ptr, SIZE_T NewSize);

VOID       WINAPI FreeMemory(LPVOID ptr);

VOID       WINAPI TestMemory(LPVOID ptr);

SIZE_T     WINAPI MemorySize(LPVOID ptr);

HANDLE     WINAPI MemoryHandle(LPBYTE ptr);

//=============================================================================
//  EXPRESSION API's
//=============================================================================

LPEXPRESSION         WINAPI InitializeExpression(LPEXPRESSION Expression);

LPPATTERNMATCH       WINAPI InitializePattern(LPPATTERNMATCH Pattern, LPVOID ptr, DWORD offset, DWORD length);

LPEXPRESSION         WINAPI AndExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

LPEXPRESSION         WINAPI OrExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

LPPATTERNMATCH       WINAPI NegatePattern(LPPATTERNMATCH Pattern);

LPADDRESSTABLE2      WINAPI AdjustOperatorPrecedence(LPADDRESSTABLE2 AddressTable);

LPADDRESS2           WINAPI NormalizeAddress(LPADDRESS2 Address);

LPADDRESSTABLE2      WINAPI NormalizeAddressTable(LPADDRESSTABLE2 AddressTable);

//=============================================================================
//  MISC. API's
//=============================================================================

DWORD                WINAPI BhGetWindowsVersion(VOID);

BOOL                 WINAPI IsDaytona(VOID);

VOID                 _cdecl dprintf(LPSTR format, ...);

//=============================================================================
//=============================================================================
//  (BHTypes.h)
//=============================================================================
//=============================================================================
//=============================================================================
//  Unaligned base type definitions.
//=============================================================================
typedef VOID        UNALIGNED   *ULPVOID;
typedef BYTE        UNALIGNED   *ULPBYTE;
typedef WORD        UNALIGNED   *ULPWORD;
typedef DWORD       UNALIGNED   *ULPDWORD;
typedef CHAR        UNALIGNED   *ULPSTR;
typedef SYSTEMTIME  UNALIGNED   *ULPSYSTEMTIME;
//=============================================================================
//  Handle definitions.
//=============================================================================
typedef struct _PARSER *HPARSER;

typedef struct _CAPFRAMEDESC *HFRAME;

typedef struct _CAPTURE *HCAPTURE;

typedef struct _FILTER *HFILTER;

typedef struct _ADDRESSDB *HADDRESSDB;

typedef struct _PROTOCOL *HPROTOCOL;

typedef DWORD_PTR HPROPERTY;

typedef HPROTOCOL *LPHPROTOCOL;

//=============================================================================
//  GetTableSize() -- The following macro is used to calculate the actual
//                    length of Network Monitor variable-length table structures.
//
//  EXAMPLE:
//
//  GetTableSize(PROTOCOLTABLESIZE, 
//               ProtocolTable->nProtocols, 
//               sizeof(HPROTOCOL))
//=============================================================================
#define GetTableSize(TableBaseSize, nElements, ElementSize) ((TableBaseSize) + ((nElements) * (ElementSize)))
//=============================================================================
//  Object type identifiers.
//=============================================================================
typedef DWORD OBJECTTYPE;

#ifndef MAKE_IDENTIFIER
#define MAKE_IDENTIFIER(a, b, c, d)     ((DWORD) MAKELONG(MAKEWORD(a, b), MAKEWORD(c, d)))
#endif // MAKE_IDENTIFIER
#define HANDLE_TYPE_INVALID             MAKE_IDENTIFIER(-1, -1, -1, -1)
#define HANDLE_TYPE_CAPTURE             MAKE_IDENTIFIER('C', 'A', 'P', '$')
#define HANDLE_TYPE_PARSER              MAKE_IDENTIFIER('P', 'S', 'R', '$')
#define HANDLE_TYPE_ADDRESSDB           MAKE_IDENTIFIER('A', 'D', 'R', '$')
#define HANDLE_TYPE_PROTOCOL            MAKE_IDENTIFIER('P', 'R', 'T', '$')
#define HANDLE_TYPE_BUFFER              MAKE_IDENTIFIER('B', 'U', 'F', '$')
//=============================================================================
//  Network Monitor constant definitions.
//=============================================================================
#define INLINE  __inline
#define BHAPI   WINAPI
#define	MAX_NAME_LENGTH	( 16 )

#define	MAX_ADDR_LENGTH	( 6 )

//=============================================================================
//  Ethernet type (ETYPE) constant definitions.
//=============================================================================
#define	ETYPE_LOOP	( 0x9000 )

#define	ETYPE_3COM_NETMAP1	( 0x9001 )

#define	ETYPE_3COM_NETMAP2	( 0x9002 )

#define	ETYPE_IBM_RT	( 0x80d5 )

#define	ETYPE_NETWARE	( 0x8137 )

#define	ETYPE_XNS1	( 0x600 )

#define	ETYPE_XNS2	( 0x807 )

#define	ETYPE_3COM_NBP0	( 0x3c00 )

#define	ETYPE_3COM_NBP1	( 0x3c01 )

#define	ETYPE_3COM_NBP2	( 0x3c02 )

#define	ETYPE_3COM_NBP3	( 0x3c03 )

#define	ETYPE_3COM_NBP4	( 0x3c04 )

#define	ETYPE_3COM_NBP5	( 0x3c05 )

#define	ETYPE_3COM_NBP6	( 0x3c06 )

#define	ETYPE_3COM_NBP7	( 0x3c07 )

#define	ETYPE_3COM_NBP8	( 0x3c08 )

#define	ETYPE_3COM_NBP9	( 0x3c09 )

#define	ETYPE_3COM_NBP10	( 0x3c0a )

#define	ETYPE_IP	( 0x800 )

#define	ETYPE_ARP1	( 0x806 )

#define	ETYPE_ARP2	( 0x807 )

#define	ETYPE_RARP	( 0x8035 )

#define	ETYPE_TRLR0	( 0x1000 )

#define	ETYPE_TRLR1	( 0x1001 )

#define	ETYPE_TRLR2	( 0x1002 )

#define	ETYPE_TRLR3	( 0x1003 )

#define	ETYPE_TRLR4	( 0x1004 )

#define	ETYPE_TRLR5	( 0x1005 )

#define	ETYPE_PUP	( 0x200 )

#define	ETYPE_PUP_ARP	( 0x201 )

#define	ETYPE_APPLETALK_ARP	( 0x80f3 )

#define	ETYPE_APPLETALK_LAP	( 0x809b )

#define	ETYPE_SNMP	( 0x814c )

//=============================================================================
//  LLC (802.2) SAP constant definitions.
//=============================================================================
#define	SAP_SNAP	( 0xaa )

#define	SAP_BPDU	( 0x42 )

#define	SAP_IBM_NM	( 0xf4 )

#define	SAP_IBM_NETBIOS	( 0xf0 )

#define	SAP_SNA1	( 0x4 )

#define	SAP_SNA2	( 0x5 )

#define	SAP_SNA3	( 0x8 )

#define	SAP_SNA4	( 0xc )

#define	SAP_NETWARE1	( 0x10 )

#define	SAP_NETWARE2	( 0xe0 )

#define	SAP_NETWARE3	( 0xfe )

#define	SAP_IP	( 0x6 )

#define	SAP_X25	( 0x7e )

#define	SAP_RPL1	( 0xf8 )

#define	SAP_RPL2	( 0xfc )

#define	SAP_UB	( 0xfa )

#define	SAP_XNS	( 0x80 )

//=============================================================================
//  Property constants
//=============================================================================
// data types
#define	PROP_TYPE_VOID	( 0 )

#define	PROP_TYPE_SUMMARY	( 0x1 )

#define	PROP_TYPE_BYTE	( 0x2 )

#define	PROP_TYPE_WORD	( 0x3 )

#define	PROP_TYPE_DWORD	( 0x4 )

#define	PROP_TYPE_LARGEINT	( 0x5 )

#define	PROP_TYPE_ADDR	( 0x6 )

#define	PROP_TYPE_TIME	( 0x7 )

#define	PROP_TYPE_STRING	( 0x8 )

#define	PROP_TYPE_IP_ADDRESS	( 0x9 )

#define	PROP_TYPE_IPX_ADDRESS	( 0xa )

#define	PROP_TYPE_BYTESWAPPED_WORD	( 0xb )

#define	PROP_TYPE_BYTESWAPPED_DWORD	( 0xc )

#define	PROP_TYPE_TYPED_STRING	( 0xd )

#define	PROP_TYPE_RAW_DATA	( 0xe )

#define	PROP_TYPE_COMMENT	( 0xf )

#define	PROP_TYPE_SRCFRIENDLYNAME	( 0x10 )

#define	PROP_TYPE_DSTFRIENDLYNAME	( 0x11 )

#define	PROP_TYPE_TOKENRING_ADDRESS	( 0x12 )

#define	PROP_TYPE_FDDI_ADDRESS	( 0x13 )

#define	PROP_TYPE_ETHERNET_ADDRESS	( 0x14 )

#define	PROP_TYPE_OBJECT_IDENTIFIER	( 0x15 )

#define	PROP_TYPE_VINES_IP_ADDRESS	( 0x16 )

#define	PROP_TYPE_VAR_LEN_SMALL_INT	( 0x17 )

#define	PROP_TYPE_ATM_ADDRESS	( 0x18 )

#define	PROP_TYPE_1394_ADDRESS	( 0x19 )

#define	PROP_TYPE_IP6_ADDRESS	( 0x1a )

// data qualifiers
#define	PROP_QUAL_NONE	( 0 )

#define	PROP_QUAL_RANGE	( 0x1 )

#define	PROP_QUAL_SET	( 0x2 )

#define	PROP_QUAL_BITFIELD	( 0x3 )

#define	PROP_QUAL_LABELED_SET	( 0x4 )

#define	PROP_QUAL_LABELED_BITFIELD	( 0x8 )

#define	PROP_QUAL_CONST	( 0x9 )

#define	PROP_QUAL_FLAGS	( 0xa )

#define	PROP_QUAL_ARRAY	( 0xb )

//=============================================================================
//  LARGEINT structure defined in winnt.h
//=============================================================================
typedef LARGE_INTEGER *LPLARGEINT;

typedef LARGE_INTEGER UNALIGNED *ULPLARGEINT;
//=============================================================================
//  Range structure.
//=============================================================================
typedef struct _RANGE
    {
    DWORD MinValue;
    DWORD MaxValue;
    } 	RANGE;

typedef RANGE *LPRANGE;

//=============================================================================
//  LABELED_BYTE structure
//=============================================================================
typedef struct _LABELED_BYTE
    {
    BYTE Value;
    LPSTR Label;
    } 	LABELED_BYTE;

typedef LABELED_BYTE *LPLABELED_BYTE;

//=============================================================================
//  LABELED_WORD structure
//=============================================================================
typedef struct _LABELED_WORD
    {
    WORD Value;
    LPSTR Label;
    } 	LABELED_WORD;

typedef LABELED_WORD *LPLABELED_WORD;

//=============================================================================
//  LABELED_DWORD structure
//=============================================================================
typedef struct _LABELED_DWORD
    {
    DWORD Value;
    LPSTR Label;
    } 	LABELED_DWORD;

typedef LABELED_DWORD *LPLABELED_DWORD;

//=============================================================================
//  LABELED_LARGEINT structure
//=============================================================================
typedef struct _LABELED_LARGEINT
    {
    LARGE_INTEGER Value;
    LPSTR Label;
    } 	LABELED_LARGEINT;

typedef LABELED_LARGEINT *LPLABELED_LARGEINT;

//=============================================================================
//  LABELED_SYSTEMTIME structure
//=============================================================================
typedef struct _LABELED_SYSTEMTIME
    {
    SYSTEMTIME Value;
    LPSTR Label;
    } 	LABELED_SYSTEMTIME;

typedef LABELED_SYSTEMTIME *LPLABELED_SYSTEMTIME;

//=============================================================================
//  LABELED_BIT structure
//=============================================================================
// BitNumber starts at 0, up to 256 bits.
typedef struct _LABELED_BIT
    {
    BYTE BitNumber;
    LPSTR LabelOff;
    LPSTR LabelOn;
    } 	LABELED_BIT;

typedef LABELED_BIT *LPLABELED_BIT;

//=============================================================================
//  TYPED_STRING structure
//=============================================================================
#define	TYPED_STRING_NORMAL	( 1 )

#define	TYPED_STRING_UNICODE	( 2 )

#define	TYPED_STRING_EXFLAG	( 1 )

// Typed Strings are always Ex, so to actually Ex we set fStringEx and put the Ex data in Byte
typedef struct _TYPED_STRING
{
    BYTE    StringType:7;
    BYTE    fStringEx:1;
    LPSTR   lpString;
    BYTE    Byte[0];
} TYPED_STRING;

typedef TYPED_STRING *LPTYPED_STRING;
//=============================================================================
//  OBJECT_IDENTIFIER structure
//=============================================================================
typedef struct _OBJECT_IDENTIFIER
    {
    DWORD Length;
    LPDWORD lpIdentifier;
    } 	OBJECT_IDENTIFIER;

typedef OBJECT_IDENTIFIER *LPOBJECT_IDENTIFIER;

//=============================================================================
//  Set structure.
//=============================================================================
typedef struct _SET
    {
    DWORD nEntries;
    union 
        {
        LPVOID lpVoidTable;
        LPBYTE lpByteTable;
        LPWORD lpWordTable;
        LPDWORD lpDwordTable;
        LPLARGEINT lpLargeIntTable;
        LPSYSTEMTIME lpSystemTimeTable;
        LPLABELED_BYTE lpLabeledByteTable;
        LPLABELED_WORD lpLabeledWordTable;
        LPLABELED_DWORD lpLabeledDwordTable;
        LPLABELED_LARGEINT lpLabeledLargeIntTable;
        LPLABELED_SYSTEMTIME lpLabeledSystemTimeTable;
        LPLABELED_BIT lpLabeledBit;
        } 	;
    } 	SET;

typedef SET *LPSET;

//=============================================================================
//  String table.
//=============================================================================
typedef struct _STRINGTABLE
{
    DWORD           nStrings;
    LPSTR           String[0];

} STRINGTABLE;

typedef STRINGTABLE *LPSTRINGTABLE;
#define STRINGTABLE_SIZE    sizeof(STRINGTABLE)

//=============================================================================
//  RECOGNIZEDATA structure.
//
//  This structure to keep track of the start of each recognized protocol.
//=============================================================================
typedef struct _RECOGNIZEDATA
    {
    WORD ProtocolID;
    WORD nProtocolOffset;
    LPVOID InstData;
    } 	RECOGNIZEDATA;

typedef RECOGNIZEDATA *LPRECOGNIZEDATA;

//=============================================================================
//  RECOGNIZEDATATABLE structure.
//
//  This structure to keep track of the start of each RECOGNIZEDATA structure
//=============================================================================
typedef struct _RECOGNIZEDATATABLE
{
    WORD            nRecognizeDatas;    //... number of RECOGNIZEDATA structures
    RECOGNIZEDATA   RecognizeData[0];   //... array of RECOGNIZEDATA structures follows

} RECOGNIZEDATATABLE;

typedef RECOGNIZEDATATABLE * LPRECOGNIZEDATATABLE;

//=============================================================================
//  Property information structure.
//=============================================================================
typedef struct _PROPERTYINFO
    {
    HPROPERTY hProperty;
    DWORD Version;
    LPSTR Label;
    LPSTR Comment;
    BYTE DataType;
    BYTE DataQualifier;
    union 
        {
        LPVOID lpExtendedInfo;
        LPRANGE lpRange;
        LPSET lpSet;
        DWORD Bitmask;
        DWORD Value;
        } 	;
    WORD FormatStringSize;
    LPVOID InstanceData;
    } 	PROPERTYINFO;

typedef PROPERTYINFO *LPPROPERTYINFO;

#define	PROPERTYINFO_SIZE	( sizeof( PROPERTYINFO  ) )

//=============================================================================
//  Property instance Extended structure.
//=============================================================================
typedef struct _PROPERTYINSTEX
{
    WORD        Length;         //... length of raw data in frame
    WORD        LengthEx;       //... number of bytes following
    ULPVOID     lpData;         //... pointer to raw data in frame

    union
    {
        BYTE            Byte[];     //... table of bytes follows
        WORD            Word[];     //... table of words follows
        DWORD           Dword[];    //... table of Dwords follows
        LARGE_INTEGER   LargeInt[]; //... table of LARGEINT structures to follow
        SYSTEMTIME      SysTime[];  //... table of SYSTEMTIME structures follows
        TYPED_STRING    TypedString;//... a typed_string that may have extended data
    };
} PROPERTYINSTEX;
typedef PROPERTYINSTEX *LPPROPERTYINSTEX;
typedef PROPERTYINSTEX UNALIGNED *ULPPROPERTYINSTEX;
#define PROPERTYINSTEX_SIZE     sizeof(PROPERTYINSTEX)
//=============================================================================
//  Property instance structure.
//=============================================================================
typedef struct _PROPERTYINST
{
    LPPROPERTYINFO          lpPropertyInfo;     // pointer to property info
    LPSTR                   szPropertyText;     // pointer to string description

    union
    {
        LPVOID              lpData;             // pointer to data
        ULPBYTE             lpByte;             // bytes
        ULPWORD             lpWord;             // words
        ULPDWORD            lpDword;            // dwords

        ULPLARGEINT         lpLargeInt;         // LargeInt
        ULPSYSTEMTIME       lpSysTime;          // pointer to SYSTEMTIME structures
        LPPROPERTYINSTEX    lpPropertyInstEx;   // pointer to propertyinstex (if DataLength = -1)
    };

    WORD                    DataLength;         // length of data, or flag for propertyinstex struct
    WORD                    Level   : 4  ;      // level information        ............1111
    WORD                    HelpID  : 12 ;      // context ID for helpfile  111111111111....
                     //    ---------------
                     // total of 16 bits == 1 WORD == DWORD ALIGNED structure
                            // Interpretation Flags:  Flags that define attach time information to the
                            // interpretation of the property.  For example, in RPC, the client can be
                            // Intel format and the server can be non-Intel format... thus the property
                            // database cannot describe the property at database creation time.
    DWORD                   IFlags;

} PROPERTYINST;
typedef PROPERTYINST *LPPROPERTYINST;
#define PROPERTYINST_SIZE   sizeof(PROPERTYINST)

// Flags passed at AttachPropertyInstance and AttachPropertyInstanceEx time in the IFlags field:
// flag for error condition ...............1
#define	IFLAG_ERROR	( 0x1 )

// is the WORD or DWORD byte non-Intel format at attach time?
#define	IFLAG_SWAPPED	( 0x2 )

// is the STRING UNICODE at attach time?
#define	IFLAG_UNICODE	( 0x4 )

//=============================================================================
//  Property instance table structure.
//=============================================================================
typedef struct _PROPERTYINSTTABLE
    {
    WORD nPropertyInsts;
    WORD nPropertyInstIndex;
    } 	PROPERTYINSTTABLE;

typedef PROPERTYINSTTABLE *LPPROPERTYINSTTABLE;

#define	PROPERTYINSTTABLE_SIZE	( sizeof( PROPERTYINSTTABLE  ) )

//=============================================================================
//  Property table structure.
//=============================================================================
typedef struct _PROPERTYTABLE
{
    LPVOID                  lpFormatBuffer;             //... Opaque.                       (PRIVATE)
    DWORD                   FormatBufferLength;         //... Opaque.                       (PRIVATE)
    DWORD                   nTotalPropertyInsts;        //... total number of propertyinstances in array
    LPPROPERTYINST          lpFirstPropertyInst;        //... array of property instances
    BYTE                    nPropertyInstTables;        //... total PropertyIndexTables following
    PROPERTYINSTTABLE       PropertyInstTable[0];       //... array of propertyinstance index table structures

} PROPERTYTABLE;

typedef PROPERTYTABLE *LPPROPERTYTABLE;

#define PROPERTYTABLE_SIZE sizeof(PROPERTYTABLE)
//=============================================================================
//  Protocol entry points.
//=============================================================================

typedef VOID    (WINAPI *REGISTER)(HPROTOCOL);

typedef VOID    (WINAPI *DEREGISTER)(HPROTOCOL);

typedef LPBYTE  (WINAPI *RECOGNIZEFRAME)(HFRAME, ULPBYTE, ULPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, LPDWORD, LPHPROTOCOL, PDWORD_PTR);

typedef LPBYTE  (WINAPI *ATTACHPROPERTIES)(HFRAME, ULPBYTE, ULPBYTE, DWORD, DWORD, HPROTOCOL, DWORD, DWORD_PTR);

typedef DWORD   (WINAPI *FORMATPROPERTIES)(HFRAME, ULPBYTE, ULPBYTE, DWORD, LPPROPERTYINST);

//=============================================================================
//  Protocol entry point structure.
//=============================================================================

typedef struct _ENTRYPOINTS
{
    REGISTER            Register;               //... Protocol Register() entry point.
    DEREGISTER          Deregister;             //... Protocol Deregister() entry point.
    RECOGNIZEFRAME      RecognizeFrame;         //... Protocol RecognizeFrame() entry point.
    ATTACHPROPERTIES    AttachProperties;       //... Protocol AttachProperties() entry point.
    FORMATPROPERTIES    FormatProperties;       //... Protocol FormatProperties() entry point.

} ENTRYPOINTS;

typedef ENTRYPOINTS *LPENTRYPOINTS;

#define ENTRYPOINTS_SIZE sizeof(ENTRYPOINTS)

//=============================================================================
//  Property database structure.
//=============================================================================
typedef struct _PROPERTYDATABASE
{
    DWORD           nProperties;                 //... Number of properties in database.
    LPPROPERTYINFO  PropertyInfo[0];             //... Array of property info pointers.

} PROPERTYDATABASE;
#define PROPERTYDATABASE_SIZE   sizeof(PROPERTYDATABASE)
typedef PROPERTYDATABASE *LPPROPERTYDATABASE;

//=============================================================================
//  Protocol info structure (PUBLIC portion of HPROTOCOL).
//=============================================================================
typedef struct _PROTOCOLINFO
{
    DWORD               ProtocolID;             //... Prootocol ID of owning protocol.
    LPPROPERTYDATABASE  PropertyDatabase;       //... Property database.
    BYTE                ProtocolName[16];       //... Protocol name.
    BYTE                HelpFile[16];           //... Optional helpfile name.
    BYTE                Comment[128];           //... Comment describing protocol.
} PROTOCOLINFO;
typedef PROTOCOLINFO *LPPROTOCOLINFO;
#define PROTOCOLINFO_SIZE   sizeof(PROTOCOLINFO)

//=============================================================================
//  Protocol Table.
//=============================================================================
typedef struct _PROTOCOLTABLE
    {
    DWORD nProtocols;
    HPROTOCOL hProtocol[ 1 ];
    } 	PROTOCOLTABLE;

typedef PROTOCOLTABLE *LPPROTOCOLTABLE;

#define	PROTOCOLTABLE_SIZE	( ( sizeof( PROTOCOLTABLE  ) - sizeof( HPROTOCOL  ) )  )

#define PROTOCOLTABLE_ACTUAL_SIZE(p) GetTableSize(PROTOCOLTABLE_SIZE, (p)->nProtocols, sizeof(HPROTOCOL))
//=============================================================================
//  AddressInfo structure
//=============================================================================
#define	SORT_BYADDRESS	( 0 )

#define	SORT_BYNAME	( 1 )

#define	PERMANENT_NAME	( 0x100 )

typedef struct _ADDRESSINFO2
{
    ADDRESS2       Address;
    WCHAR          Name[MAX_NAME_SIZE];
    DWORD          Flags;
    LPVOID         lpAddressInstData;

} ADDRESSINFO2;
typedef struct _ADDRESSINFO2 *LPADDRESSINFO2;
#define ADDRESSINFO2_SIZE    sizeof(ADDRESSINFO2)
//=============================================================================
//  AddressInfoTable
//=============================================================================
typedef struct _ADDRESSINFOTABLE2
{
    DWORD         nAddressInfos;
    LPADDRESSINFO2 lpAddressInfo[0];

} ADDRESSINFOTABLE2;
typedef ADDRESSINFOTABLE2 *LPADDRESSINFOTABLE2;
#define ADDRESSINFOTABLE2_SIZE   sizeof(ADDRESSINFOTABLE2)
//=============================================================================
//  callback procedures.
//=============================================================================

typedef DWORD (WINAPI *FILTERPROC)(HCAPTURE, HFRAME, LPVOID);

//=============================================================================
//=============================================================================
//  (NMErr.h)
//=============================================================================
//=============================================================================
//  The operation succeeded.
#define	NMERR_SUCCESS	( 0 )

//  An error occured creating a memory-mapped file.
#define	NMERR_MEMORY_MAPPED_FILE_ERROR	( 1 )

//  The handle to a filter is invalid.
#define	NMERR_INVALID_HFILTER	( 2 )

//  Capturing has already been started.
#define	NMERR_CAPTURING	( 3 )

//  Capturing has not been started.
#define	NMERR_NOT_CAPTURING	( 4 )

//  The are no frames available.
#define	NMERR_NO_MORE_FRAMES	( 5 )

//  The buffer is too small to complete the operation.
#define	NMERR_BUFFER_TOO_SMALL	( 6 )

//  No protocol was able to recognize the frame.
#define	NMERR_FRAME_NOT_RECOGNIZED	( 7 )

//  The file already exists.
#define	NMERR_FILE_ALREADY_EXISTS	( 8 )

//  A needed device driver was not found or is not loaded.
#define	NMERR_DRIVER_NOT_FOUND	( 9 )

//  This address aready exists in the database.
#define	NMERR_ADDRESS_ALREADY_EXISTS	( 10 )

//  The frame handle is invalid.
#define	NMERR_INVALID_HFRAME	( 11 )

//  The protocol handle is invalid.
#define	NMERR_INVALID_HPROTOCOL	( 12 )

//  The property handle is invalid.
#define	NMERR_INVALID_HPROPERTY	( 13 )

//  The the object has been locked.  
#define	NMERR_LOCKED	( 14 )

//  A pop operation was attempted on an empty stack.
#define	NMERR_STACK_EMPTY	( 15 )

//  A push operation was attempted on an full stack.
#define	NMERR_STACK_OVERFLOW	( 16 )

//  There are too many protocols active.
#define	NMERR_TOO_MANY_PROTOCOLS	( 17 )

//  The file was not found.
#define	NMERR_FILE_NOT_FOUND	( 18 )

//  No memory was available.  Shut down windows to free up resources.
#define	NMERR_OUT_OF_MEMORY	( 19 )

//  The capture is already in the paused state.
#define	NMERR_CAPTURE_PAUSED	( 20 )

//  There are no buffers available or present.
#define	NMERR_NO_BUFFERS	( 21 )

//  There are already buffers present.
#define	NMERR_BUFFERS_ALREADY_EXIST	( 22 )

//  The object is not locked.
#define	NMERR_NOT_LOCKED	( 23 )

//  A integer type was out of range.
#define	NMERR_OUT_OF_RANGE	( 24 )

//  An object was locked too many times.
#define	NMERR_LOCK_NESTING_TOO_DEEP	( 25 )

//  A parser failed to load.
#define	NMERR_LOAD_PARSER_FAILED	( 26 )

//  A parser failed to unload.
#define	NMERR_UNLOAD_PARSER_FAILED	( 27 )

//  The address database handle is invalid.
#define	NMERR_INVALID_HADDRESSDB	( 28 )

//  The MAC address was not found in the database.
#define	NMERR_ADDRESS_NOT_FOUND	( 29 )

//  The network software was not found in the system.
#define	NMERR_NETWORK_NOT_PRESENT	( 30 )

//  There is no property database for a protocol.
#define	NMERR_NO_PROPERTY_DATABASE	( 31 )

//  A property was not found in the database.
#define	NMERR_PROPERTY_NOT_FOUND	( 32 )

//  The property database handle is in valid.
#define	NMERR_INVALID_HPROPERTYDB	( 33 )

//  The protocol has not been enabled.
#define	NMERR_PROTOCOL_NOT_ENABLED	( 34 )

//  The protocol DLL could not be found.
#define	NMERR_PROTOCOL_NOT_FOUND	( 35 )

//  The parser DLL is not valid.
#define	NMERR_INVALID_PARSER_DLL	( 36 )

//  There are no properties attached.
#define	NMERR_NO_ATTACHED_PROPERTIES	( 37 )

//  There are no frames in the buffer.
#define	NMERR_NO_FRAMES	( 38 )

//  The capture file format is not valid.
#define	NMERR_INVALID_FILE_FORMAT	( 39 )

//  The OS could not create a temporary file.
#define	NMERR_COULD_NOT_CREATE_TEMPFILE	( 40 )

//  There is not enough MS-DOS memory available.
#define	NMERR_OUT_OF_DOS_MEMORY	( 41 )

//  There are no protocols enabled.
#define	NMERR_NO_PROTOCOLS_ENABLED	( 42 )

//  The MAC type is invalid or unsupported.
#define	NMERR_UNKNOWN_MACTYPE	( 46 )

//  There is no routing information present in the MAC frame.
#define	NMERR_ROUTING_INFO_NOT_PRESENT	( 47 )

//  The network handle is invalid.
#define	NMERR_INVALID_HNETWORK	( 48 )

//  The network is already open.
#define	NMERR_NETWORK_ALREADY_OPENED	( 49 )

//  The network is not open.
#define	NMERR_NETWORK_NOT_OPENED	( 50 )

//  The frame was not found in the buffer.
#define	NMERR_FRAME_NOT_FOUND	( 51 )

//  There are no handles available.
#define	NMERR_NO_HANDLES	( 53 )

//  The network ID is invalid.
#define	NMERR_INVALID_NETWORK_ID	( 54 )

//  The capture handle is invalid.
#define	NMERR_INVALID_HCAPTURE	( 55 )

//  The protocol has already been enabled.
#define	NMERR_PROTOCOL_ALREADY_ENABLED	( 56 )

//  The filter expression is invalid.
#define	NMERR_FILTER_INVALID_EXPRESSION	( 57 )

//  A transmit error occured.
#define	NMERR_TRANSMIT_ERROR	( 58 )

//  The buffer handle is invalid.
#define	NMERR_INVALID_HBUFFER	( 59 )

//  The specified data is unknown or invalid.
#define	NMERR_INVALID_DATA	( 60 )

//  The MS-DOS/NDIS 2.0 network driver is not loaded.
#define	NMERR_MSDOS_DRIVER_NOT_LOADED	( 61 )

//  The Windows VxD/NDIS 3.0 network driver is not loaded.
#define	NMERR_WINDOWS_DRIVER_NOT_LOADED	( 62 )

//  The MS-DOS/NDIS 2.0 driver had an init-time failure.
#define	NMERR_MSDOS_DRIVER_INIT_FAILURE	( 63 )

//  The Windows/NDIS 3.0 driver had an init-time failure.
#define	NMERR_WINDOWS_DRIVER_INIT_FAILURE	( 64 )

//  The network driver is busy and cannot handle requests.
#define	NMERR_NETWORK_BUSY	( 65 )

//  The capture is not paused.
#define	NMERR_CAPTURE_NOT_PAUSED	( 66 )

//  The frame/packet length is not valid.
#define	NMERR_INVALID_PACKET_LENGTH	( 67 )

//  An internal exception occured.
#define	NMERR_INTERNAL_EXCEPTION	( 69 )

//  The MAC driver does not support promiscious mode.
#define	NMERR_PROMISCUOUS_MODE_NOT_SUPPORTED	( 70 )

//  The MAC driver failed to open.
#define	NMERR_MAC_DRIVER_OPEN_FAILURE	( 71 )

//  The protocol went off the end of the frame.
#define	NMERR_RUNAWAY_PROTOCOL	( 72 )

//  An asynchronous operation is still pending.
#define	NMERR_PENDING	( 73 )

//  Access is denied.
#define	NMERR_ACCESS_DENIED	( 74 )

//  The password handle is invalid.
#define	NMERR_INVALID_HPASSWORD	( 75 )

//  A bad parameter was detected.
#define	NMERR_INVALID_PARAMETER	( 76 )

//  An error occured reading the file.
#define	NMERR_FILE_READ_ERROR	( 77 )

//  An error occured writing to the file.
#define	NMERR_FILE_WRITE_ERROR	( 78 )

//  The protocol has not been registered
#define	NMERR_PROTOCOL_NOT_REGISTERED	( 79 )

//  The frame does not contain an IP address.
#define	NMERR_IP_ADDRESS_NOT_FOUND	( 80 )

//  The transmit request was cancelled.
#define	NMERR_TRANSMIT_CANCELLED	( 81 )

//  The operation cannot be performed on a capture with 1 or more locked frames.
#define	NMERR_LOCKED_FRAMES	( 82 )

//  A cancel transmit request was submitted but there were no transmits pending.
#define	NMERR_NO_TRANSMITS_PENDING	( 83 )

//  Path not found.
#define	NMERR_PATH_NOT_FOUND	( 84 )

//  A windows error has occured.
#define	NMERR_WINDOWS_ERROR	( 85 )

//  The handle to the frame has no frame number.
#define	NMERR_NO_FRAME_NUMBER	( 86 )

//  The frame is not associated with any capture.
#define	NMERR_FRAME_HAS_NO_CAPTURE	( 87 )

//  The frame is already associated with a capture.
#define	NMERR_FRAME_ALREADY_HAS_CAPTURE	( 88 )

//  The NAL is not remotable.
#define	NMERR_NAL_IS_NOT_REMOTE	( 89 )

//  The API is not supported
#define	NMERR_NOT_SUPPORTED	( 90 )

//  Network Monitor should discard the current frame. 
//  This error code is only used during a filtered SaveCapture() API call.
#define	NMERR_DISCARD_FRAME	( 91 )

//  Network Monitor should cancel the current save. 
//  This error code is only used during a filtered SaveCapture() API call.
#define	NMERR_CANCEL_SAVE_CAPTURE	( 92 )

//  The connection to the remote machine has been lost
#define	NMERR_LOST_CONNECTION	( 93 )

//  The media/mac type is not valid.
#define	NMERR_INVALID_MEDIA_TYPE	( 94 )

//  The Remote Agent is currently in use
#define	NMERR_AGENT_IN_USE	( 95 )

//  The request has timed out
#define	NMERR_TIMEOUT	( 96 )

//  The remote agent has been disconnected
#define	NMERR_DISCONNECTED	( 97 )

//  A timer required for operation failed creation
#define	NMERR_SETTIMER_FAILED	( 98 )

//  A network error occured.
#define	NMERR_NETWORK_ERROR	( 99 )

//  Frame callback procedure is not valid
#define	NMERR_INVALID_FRAMESPROC	( 100 )

//  Capture type specified is unknown
#define	NMERR_UNKNOWN_CAPTURETYPE	( 101 )

// The NPP is not connected to a network.
#define	NMERR_NOT_CONNECTED	( 102 )

// The NPP is already connected to a network.
#define	NMERR_ALREADY_CONNECTED	( 103 )

// The registry tag does not indicate a known configuration.
#define	NMERR_INVALID_REGISTRY_CONFIGURATION	( 104 )

// The NPP is currently configured for delayed capturing.
#define	NMERR_DELAYED	( 105 )

// The NPP is not currently configured for delayed capturing.
#define	NMERR_NOT_DELAYED	( 106 )

// The NPP is currently configured for real time capturing.
#define	NMERR_REALTIME	( 107 )

// The NPP is not currently configured for real time capturing.
#define	NMERR_NOT_REALTIME	( 108 )

// The NPP is currently configured for stats only capturing.
#define	NMERR_STATS_ONLY	( 109 )

// The NPP is not currently configured for stats only capturing.
#define	NMERR_NOT_STATS_ONLY	( 110 )

// The NPP is currently configured for transmitting.
#define	NMERR_TRANSMIT	( 111 )

// The NPP is not currently configured for transmitting.
#define	NMERR_NOT_TRANSMIT	( 112 )

// The NPP is currently transmitting
#define	NMERR_TRANSMITTING	( 113 )

// The specified capture file hard disk is not local
#define	NMERR_DISK_NOT_LOCAL_FIXED	( 114 )

// Could not create the default capture directory on the given disk
#define	NMERR_COULD_NOT_CREATE_DIRECTORY	( 115 )

// The default capture directory was not set in the registry:
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\nm\Parameters\CapturePath
#define	NMERR_NO_DEFAULT_CAPTURE_DIRECTORY	( 116 )

//  The capture file is an uplevel version that this netmon does not understand
#define	NMERR_UPLEVEL_CAPTURE_FILE	( 117 )

//  An expert failed to load.
#define	NMERR_LOAD_EXPERT_FAILED	( 118 )

//  An expert failed to report its EXPERT_INFO structs.
#define	NMERR_EXPERT_REPORT_FAILED	( 119 )

//  Registry API call failed.
#define	NMERR_REG_OPERATION_FAILED	( 120 )

//  Registry API call failed.
#define	NMERR_NO_DLLS_FOUND	( 121 )

//  There are no conversation stats, they were not asked for.
#define	NMERR_NO_CONVERSATION_STATS	( 122 )

//  We have received a security response packet from a security monitor.
#define	NMERR_SECURITY_BREACH_CAPTURE_DELETED	( 123 )

//  The given frame failed the display filter.
#define	NMERR_FRAME_FAILED_FILTER	( 124 )

//  Netmon wants the Expert to stop running.
#define	NMERR_EXPERT_TERMINATE	( 125 )

//  Netmon needs the remote machine to be a server.
#define	NMERR_REMOTE_NOT_A_SERVER	( 126 )

//  Netmon needs the remote machine to be a server.
#define	NMERR_REMOTE_VERSION_OUTOFSYNC	( 127 )

//  The supplied group is an invalid handle
#define	NMERR_INVALID_EXPERT_GROUP	( 128 )

//  The supplied expert name cannot be found
#define	NMERR_INVALID_EXPERT_NAME	( 129 )

//  The supplied expert name cannot be found
#define	NMERR_INVALID_EXPERT_HANDLE	( 130 )

//  The supplied group name already exists
#define	NMERR_GROUP_NAME_ALREADY_EXISTS	( 131 )

//  The supplied group name is invalid
#define	NMERR_INVALID_GROUP_NAME	( 132 )

//  The supplied Expert is already in the group.  
#define	NMERR_EXPERT_ALREADY_IN_GROUP	( 133 )

//  The Expert cannot be deleted from the group because it is not in the group
#define	NMERR_EXPERT_NOT_IN_GROUP	( 134 )

//  The COM object has not been initialized
#define	NMERR_NOT_INITIALIZED	( 135 )

//  Cannot perform function to Root group
#define	NMERR_INVALID_GROUP_ROOT	( 136 )

//  Potential data structure mismatch between NdisNpp and Driver.
#define	NMERR_BAD_VERSION	( 137 )

// The NPP is currently configured for ESP capturing.
#define	NMERR_ESP	( 138 )

// The NPP is not currently configured for ESP capturing.
#define	NMERR_NOT_ESP	( 139 )

//=============================================================================
// Blob Errors
//=============================================================================
#define	NMERR_BLOB_NOT_INITIALIZED	( 1000 )

#define	NMERR_INVALID_BLOB	( 1001 )

#define	NMERR_UPLEVEL_BLOB	( 1002 )

#define	NMERR_BLOB_ENTRY_ALREADY_EXISTS	( 1003 )

#define	NMERR_BLOB_ENTRY_DOES_NOT_EXIST	( 1004 )

#define	NMERR_AMBIGUOUS_SPECIFIER	( 1005 )

#define	NMERR_BLOB_OWNER_NOT_FOUND	( 1006 )

#define	NMERR_BLOB_CATEGORY_NOT_FOUND	( 1007 )

#define	NMERR_UNKNOWN_CATEGORY	( 1008 )

#define	NMERR_UNKNOWN_TAG	( 1009 )

#define	NMERR_BLOB_CONVERSION_ERROR	( 1010 )

#define	NMERR_ILLEGAL_TRIGGER	( 1011 )

#define	NMERR_BLOB_STRING_INVALID	( 1012 )

//=============================================================================
// FINDER errors
//=============================================================================
#define	NMERR_UNABLE_TO_LOAD_LIBRARY	( 1013 )

#define	NMERR_UNABLE_TO_GET_PROCADDR	( 1014 )

#define	NMERR_CLASS_NOT_REGISTERED	( 1015 )

#define	NMERR_INVALID_REMOTE_COMPUTERNAME	( 1016 )

#define	NMERR_RPC_REMOTE_FAILURE	( 1017 )

#define	NMERR_NO_NPPS	( 3016 )

#define	NMERR_NO_MATCHING_NPPS	( 3017 )

#define	NMERR_NO_NPP_SELECTED	( 3018 )

#define	NMERR_NO_INPUT_BLOBS	( 3019 )

#define	NMERR_NO_NPP_DLLS	( 3020 )

#define	NMERR_NO_VALID_NPP_DLLS	( 3021 )

//=============================================================================
// Error Macros
//=============================================================================
#ifndef INLINE
#define INLINE __inline
#endif // INLINE
// normal Network Monitor errors will be put into the code portion of an hresult
// for return from OLE objects:
// these two macros will help to create and crack the scode
INLINE HRESULT NMERR_TO_HRESULT( DWORD nmerror )
{
    HRESULT hResult;
    if (nmerror == NMERR_SUCCESS)
        hResult = NOERROR;
    else
        hResult = MAKE_HRESULT( SEVERITY_ERROR,FACILITY_ITF, (WORD)nmerror) ;

    return hResult;
}
//We use to decide whether the first bit was set to 1 or 0, not regarding 
//whether the result passed with a warning set in the low word.  Now we 
//disregard the first bit and pass back the warning.
INLINE DWORD HRESULT_TO_NMERR( HRESULT hResult )
{
    return HRESULT_CODE(hResult);
}
//=============================================================================
//=============================================================================
//  (BHFilter.h)
//=============================================================================
//=============================================================================
//============================================================================
//  types
//============================================================================
typedef HFILTER *LPHFILTER;

typedef DWORD FILTERACTIONTYPE;

typedef DWORD VALUETYPE;

// check for protocols existing in the frame.

// ProtocolPart
// this is the raw data for a Protocol based expression
//
// WHAT             FIELD          DESCRIPTION                  EXAMPLE
// ----             -----          -----------                  -------
// Count of Protocol(nPropertyDBs) Number of protocols to pass  5
// PropertyDB Table (PropertyDB)    Table of HPROTOCOL        SMB, LLC, MAC
//
// NOTE: the nPropertyDBs field may also be the following, which implies that
// all are selected but that none have actually been put into the structure
#define	PROTOCOL_NUM_ANY	( -1 )

typedef PROTOCOLTABLE PROTOCOLTABLETYPE;

typedef PROTOCOLTABLETYPE *LPPROTOCOLTABLETYPE;

// filter bits stores who passed what filter per frame to speed up
//  the filter process...  This is actually an array.
typedef DWORD FILTERBITS;

typedef FILTERBITS *LPFILTERBITS;

typedef SYSTEMTIME *LPTIME;

typedef SYSTEMTIME UNALIGNED * ULPTIME;
// The Filter Object is the basic unit of the postfix stack.
// I need to restart the convert property to value if the comparison does not match.
// To do this, I need the original pointer to the property.  Pull the hProperty out of
// the union so that the pointer to the property is saved.
typedef struct _FILTEROBJECT2
{
    FILTERACTIONTYPE    Action;     // Object action, see codes below
    HPROPERTY           hProperty;  // property key
    union
    {
        VALUETYPE           Value;           // value of the object.
        HPROTOCOL           hProtocol;       // protocol key.
        LPVOID              lpArray;         // if array, length is ItemCount below.
        LPPROTOCOLTABLETYPE lpProtocolTable; // list of protocols to see if exist in frame.
        LPADDRESS2          lpAddress;       // kernel type address, mac or ip
        ULPLARGEINT         lpLargeInt;      // Double DWORD used by NT
        ULPTIME             lpTime;          // pointer to SYSTEMTIME
        LPOBJECT_IDENTIFIER lpOID;           // pointer to OBJECT_IDENTIFIER

    };
    union
    {
        WORD            ByteCount;      // Number of BYTES!
        WORD            ByteOffset;     // offset for array compare
    };

    struct _FILTEROBJECT2 * pNext;   // reserved

} FILTEROBJECT2;

typedef FILTEROBJECT2 * LPFILTEROBJECT2;

#define FILTERINFO_SIZE (sizeof(FILTEROBJECT2) )



typedef struct _FILTERDESC2
{
    WORD            NumEntries;
    WORD            Flags;          // private
    LPFILTEROBJECT2 lpStack;
    LPFILTEROBJECT2 lpKeepLast;
    LPVOID          UIInstanceData; // UI specific information.
    LPFILTERBITS    lpFilterBits;   // cache who passed
    LPFILTERBITS    lpCheckBits;    // have we looked at it yet?
    
} FILTERDESC2;

typedef FILTERDESC2 * LPFILTERDESC2;

#define FILTERDESC2_SIZE sizeof(FILTERDESC2)
// Obsolete, FILTEROBJECT2 should be used
typedef struct _FILTEROBJECT
{
    FILTERACTIONTYPE    Action;     // Object action, see codes below
    HPROPERTY           hProperty;  // property key
    union
    {
        VALUETYPE           Value;           // value of the object.
        HPROTOCOL           hProtocol;       // protocol key.
        LPVOID              lpArray;         // if array, length is ItemCount below.
        LPPROTOCOLTABLETYPE lpProtocolTable; // list of protocols to see if exist in frame.
        LPADDRESS           lpAddress;       // kernel type address, mac or ip
        ULPLARGEINT         lpLargeInt;      // Double DWORD used by NT
        ULPTIME             lpTime;          // pointer to SYSTEMTIME
        LPOBJECT_IDENTIFIER lpOID;           // pointer to OBJECT_IDENTIFIER

    };
    union
    {
        WORD            ByteCount;      // Number of BYTES!
        WORD            ByteOffset;     // offset for array compare
    };

    struct _FILTEROBJECT * pNext;   // reserved

} FILTEROBJECT;
typedef FILTEROBJECT * LPFILTEROBJECT;
// Obsolete, FILTERDESC2 should be used
typedef struct _FILTERDESC
{
    WORD            NumEntries;
    WORD            Flags;          // private
    LPFILTEROBJECT  lpStack;
    LPFILTEROBJECT  lpKeepLast;
    LPVOID          UIInstanceData; // UI specific information.
    LPFILTERBITS    lpFilterBits;   // cache who passed
    LPFILTERBITS    lpCheckBits;    // have we looked at it yet?
    
} FILTERDESC;
typedef FILTERDESC * LPFILTERDESC;
#define FILTERDESC_SIZE sizeof(FILTERDESC)
//============================================================================
//  Macros.
//============================================================================
#define FilterGetUIInstanceData(hfilt)         (((LPFILTERDESC2)hfilt)->UIInstanceData)
#define FilterSetUIInstanceData(hfilt,inst)    (((LPFILTERDESC2)hfilt)->UIInstanceData = (LPVOID)inst)
//============================================================================
//  defines
//============================================================================
#define	FILTERFREEPOOLSTART	( 20 )

#define	INVALIDELEMENT	( -1 )

#define	INVALIDVALUE	( ( VALUETYPE  )-9999 )

// use filter failed to check the return code on FilterFrame.
#define	FILTER_FAIL_WITH_ERROR	( -1 )

#define	FILTER_PASSED	( TRUE )

#define	FILTER_FAILED	( FALSE )

#define	FILTERACTION_INVALID	( 0 )

#define	FILTERACTION_PROPERTY	( 1 )

#define	FILTERACTION_VALUE	( 2 )

#define	FILTERACTION_STRING	( 3 )

#define	FILTERACTION_ARRAY	( 4 )

#define	FILTERACTION_AND	( 5 )

#define	FILTERACTION_OR	( 6 )

#define	FILTERACTION_XOR	( 7 )

#define	FILTERACTION_PROPERTYEXIST	( 8 )

#define	FILTERACTION_CONTAINSNC	( 9 )

#define	FILTERACTION_CONTAINS	( 10 )

#define	FILTERACTION_NOT	( 11 )

#define	FILTERACTION_EQUALNC	( 12 )

#define	FILTERACTION_EQUAL	( 13 )

#define	FILTERACTION_NOTEQUALNC	( 14 )

#define	FILTERACTION_NOTEQUAL	( 15 )

#define	FILTERACTION_GREATERNC	( 16 )

#define	FILTERACTION_GREATER	( 17 )

#define	FILTERACTION_LESSNC	( 18 )

#define	FILTERACTION_LESS	( 19 )

#define	FILTERACTION_GREATEREQUALNC	( 20 )

#define	FILTERACTION_GREATEREQUAL	( 21 )

#define	FILTERACTION_LESSEQUALNC	( 22 )

#define	FILTERACTION_LESSEQUAL	( 23 )

#define	FILTERACTION_PLUS	( 24 )

#define	FILTERACTION_MINUS	( 25 )

#define	FILTERACTION_ADDRESS	( 26 )

#define	FILTERACTION_ADDRESSANY	( 27 )

#define	FILTERACTION_FROM	( 28 )

#define	FILTERACTION_TO	( 29 )

#define	FILTERACTION_FROMTO	( 30 )

#define	FILTERACTION_AREBITSON	( 31 )

#define	FILTERACTION_AREBITSOFF	( 32 )

#define	FILTERACTION_PROTOCOLSEXIST	( 33 )

#define	FILTERACTION_PROTOCOLEXIST	( 34 )

#define	FILTERACTION_ARRAYEQUAL	( 35 )

#define	FILTERACTION_DEREFPROPERTY	( 36 )

#define	FILTERACTION_LARGEINT	( 37 )

#define	FILTERACTION_TIME	( 38 )

#define	FILTERACTION_ADDR_ETHER	( 39 )

#define	FILTERACTION_ADDR_TOKEN	( 40 )

#define	FILTERACTION_ADDR_FDDI	( 41 )

#define	FILTERACTION_ADDR_IPX	( 42 )

#define	FILTERACTION_ADDR_IP	( 43 )

#define	FILTERACTION_OID	( 44 )

#define	FILTERACTION_OID_CONTAINS	( 45 )

#define	FILTERACTION_OID_BEGINS_WITH	( 46 )

#define	FILTERACTION_OID_ENDS_WITH	( 47 )

#define	FILTERACTION_ADDR_VINES	( 48 )

#define	FILTERACTION_ADDR_IP6	( 49 )

#define	FILTERACTION_EXPRESSION	( 97 )

#define	FILTERACTION_BOOL	( 98 )

#define	FILTERACTION_NOEVAL	( 99 )

#define	FILTER_NO_MORE_FRAMES	( 0xffffffff )

#define	FILTER_CANCELED	( 0xfffffffe )

#define	FILTER_DIRECTION_NEXT	( TRUE )

#define	FILTER_DIRECTION_PREV	( FALSE )

//============================================================================
//  Helper functions.
//============================================================================
typedef BOOL (WINAPI *STATUSPROC)(DWORD, HCAPTURE, HFILTER, LPVOID);
//=============================================================================
//  FILTER API's.
//=============================================================================

HFILTER  WINAPI CreateFilter(VOID);

DWORD    WINAPI DestroyFilter(HFILTER hFilter);

HFILTER  WINAPI FilterDuplicate(HFILTER hFilter);

DWORD    WINAPI DisableParserFilter(HFILTER hFilter, HPARSER hParser);

DWORD    WINAPI EnableParserFilter(HFILTER hFilter, HPARSER hParser);

DWORD    WINAPI FilterAddObject(HFILTER hFilter, LPFILTEROBJECT2 lpFilterObject );

VOID     WINAPI FilterFlushBits(HFILTER hFilter);

DWORD    WINAPI FilterFrame(HFRAME hFrame, HFILTER hFilter, HCAPTURE hCapture);
    // returns -1 == check BH set last error
    //          0 == FALSE
    //          1 == TRUE

BOOL     WINAPI FilterAttachesProperties(HFILTER hFilter);

DWORD WINAPI FilterFindFrame (  HFILTER     hFilter,
                                HCAPTURE    hCapture,
                                DWORD       nFrame,
                                STATUSPROC  StatusProc,
                                LPVOID      UIInstance,
                                DWORD       TimeDelta,
                                BOOL        FilterDirection );

HFRAME FilterFindPropertyInstance ( HFRAME          hFrame, 
                                    HFILTER         hMasterFilter, 
                                    HCAPTURE        hCapture,
                                    HFILTER         hInstanceFilter,
                                    LPPROPERTYINST  *lpPropRestartKey,
                                    STATUSPROC      StatusProc,
                                    LPVOID          UIInstance,
                                    DWORD           TimeDelta,
                                    BOOL            FilterForward );


VOID WINAPI SetCurrentFilter(HFILTER);
HFILTER WINAPI GetCurrentFilter(VOID);

//=============================================================================
//=============================================================================
//  (Frame.h)
//=============================================================================
//=============================================================================
//=============================================================================
//  802.3 and ETHERNET MAC structure.
//=============================================================================
typedef struct _ETHERNET
{
    BYTE    DstAddr[MAX_ADDR_LENGTH];   //... destination address.
    BYTE    SrcAddr[MAX_ADDR_LENGTH];   //... source address.
    union
    {
        WORD    Length;                 //... 802.3 length field.
        WORD    Type;                   //... Ethernet type field.
    };
    BYTE    Info[0];                    //... information field.

} ETHERNET;
typedef ETHERNET *LPETHERNET;
typedef ETHERNET UNALIGNED *ULPETHERNET;
#define ETHERNET_SIZE   sizeof(ETHERNET)
#define	ETHERNET_HEADER_LENGTH	( 14 )

#define	ETHERNET_DATA_LENGTH	( 0x5dc )

#define	ETHERNET_FRAME_LENGTH	( 0x5ea )

#define	ETHERNET_FRAME_TYPE	( 0x600 )

//=============================================================================
//  Header for NM_ATM Packets.
//=============================================================================

typedef struct _NM_ATM
    {
    UCHAR DstAddr[ 6 ];
    UCHAR SrcAddr[ 6 ];
    ULONG Vpi;
    ULONG Vci;
    } 	NM_ATM;

typedef NM_ATM *PNM_ATM;

typedef NM_ATM *UPNM_ATM;

#define NM_ATM_HEADER_LENGTH sizeof(NM_ATM)

#pragma pack(push, 1)
typedef struct _NM_1394
    {
    UCHAR DstAddr[ 6 ];
    UCHAR SrcAddr[ 6 ];
    ULONGLONG VcId;
    } 	NM_1394;

typedef NM_1394 *PNM_1394;

typedef NM_1394 *UPNM_1394;

#define NM_1394_HEADER_LENGTH sizeof(NM_1394)
//=============================================================================
//  802.5 (TOKENRING) MAC structure.
//=============================================================================

// This structure is used to decode network data and so needs to be packed
typedef struct _TOKENRING
{
    BYTE    AccessCtrl;                 //... access control field.
    BYTE    FrameCtrl;                  //... frame control field.
    BYTE    DstAddr[MAX_ADDR_LENGTH];   //... destination address.
    BYTE    SrcAddr[MAX_ADDR_LENGTH];   //... source address.
    union
    {
        BYTE    Info[0];                //... information field.
        WORD    RoutingInfo[0];         //... routing information field.
    };
} TOKENRING;

typedef TOKENRING *LPTOKENRING;
typedef TOKENRING UNALIGNED *ULPTOKENRING;
#define TOKENRING_SIZE  sizeof(TOKENRING)
#define	TOKENRING_HEADER_LENGTH	( 14 )

#define	TOKENRING_SA_ROUTING_INFO	( 0x80 )

#define	TOKENRING_SA_LOCAL	( 0x40 )

#define	TOKENRING_DA_LOCAL	( 0x40 )

#define	TOKENRING_DA_GROUP	( 0x80 )

#define	TOKENRING_RC_LENGTHMASK	( 0x1f )

#define	TOKENRING_BC_MASK	( 0xe0 )

#define	TOKENRING_TYPE_MAC	( 0 )

#define	TOKENRING_TYPE_LLC	( 0x40 )


#pragma pack(pop)
//=============================================================================
//  FDDI MAC structure.
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
typedef struct _FDDI
{
    BYTE    FrameCtrl;                  //... frame control field.
    BYTE    DstAddr[MAX_ADDR_LENGTH];   //... destination address.
    BYTE    SrcAddr[MAX_ADDR_LENGTH];   //... source address.
    BYTE    Info[0];                    //... information field.

} FDDI;
#define FDDI_SIZE       sizeof(FDDI)
typedef FDDI *LPFDDI;
typedef FDDI UNALIGNED *ULPFDDI;
#define	FDDI_HEADER_LENGTH	( 13 )

#define	FDDI_TYPE_MAC	( 0 )

#define	FDDI_TYPE_LLC	( 0x10 )

#define	FDDI_TYPE_LONG_ADDRESS	( 0x40 )


#pragma pack(pop)
//=============================================================================
//  LLC (802.2)
//=============================================================================

// This structure is used to decode network data and so needs to be packed

#pragma pack(push, 1)
typedef struct _LLC
    {
    BYTE dsap;
    BYTE ssap;
    struct 
        {
        union 
            {
            BYTE Command;
            BYTE NextSend;
            } 	;
        union 
            {
            BYTE NextRecv;
            BYTE Data[ 1 ];
            } 	;
        } 	ControlField;
    } 	LLC;

typedef LLC *LPLLC;

typedef LLC UNALIGNED *ULPLLC;
#define	LLC_SIZE	( sizeof( LLC  ) )


#pragma pack(pop)
//=============================================================================
//  Helper macros.
//=============================================================================

#define IsRoutingInfoPresent(f) ((((ULPTOKENRING) (f))->SrcAddr[0] & TOKENRING_SA_ROUTING_INFO) ? TRUE : FALSE)

#define GetRoutingInfoLength(f) (IsRoutingInfoPresent(f) \
                                 ? (((ULPTOKENRING) (f))->RoutingInfo[0] & TOKENRING_RC_LENGTHMASK) : 0)

//=============================================================================
//=============================================================================
//  (Parser.h)
//=============================================================================
//=============================================================================

//=============================================================================
//  Format Procedure Type.
//
//  NOTE: All format functions *must* be declared as WINAPIV not WINAPI!
//=============================================================================

typedef VOID (WINAPIV *FORMAT)(LPPROPERTYINST, ...);

//  The protocol recognized the frame and moved the pointer to end of its
//  protocol header. Network Monitor uses the protocols follow set to continue
//  parsing.
#define	PROTOCOL_STATUS_RECOGNIZED	( 0 )

//  The protocol did not recognized the frame and did not move the pointer
//  (i.e. the start data pointer which was passed in). Network Monitor uses the
//  protocols follow set to continue parsing.
#define	PROTOCOL_STATUS_NOT_RECOGNIZED	( 1 )

//  The protocol recognized the frame and claimed it all for itself,
//  and parsing terminates.
#define	PROTOCOL_STATUS_CLAIMED	( 2 )

//  The protocol recognized the frame and moved the pointer to end of its
//  protocol header. The current protocol requests that Network Monitor 
//  continue parsing at a known next protocol by returning the next protocols
//  handle back to Network Monitor. In this case, the follow of the current 
//  protocol, if any, is not used.
#define	PROTOCOL_STATUS_NEXT_PROTOCOL	( 3 )

//=============================================================================
//  Macros.
//=============================================================================

extern  BYTE HexTable[];

#define XCHG(x)         MAKEWORD( HIBYTE(x), LOBYTE(x) )

#define DXCHG(x)        MAKELONG( XCHG(HIWORD(x)), XCHG(LOWORD(x)) )

#define LONIBBLE(b) ((BYTE) ((b) & 0x0F))

#define HINIBBLE(b)     ((BYTE) ((b) >> 4))

#define HEX(b)          (HexTable[LONIBBLE(b)])

#define SWAPBYTES(w)    ((w) = XCHG(w))

#define SWAPWORDS(d)    ((d) = DXCHG(d))

//=============================================================================
//  All the MAC frame types combined.
//=============================================================================
typedef union _MACFRAME
{
    LPBYTE      MacHeader;              //... generic pointer.
    LPETHERNET  Ethernet;               //... ethernet pointer.
    LPTOKENRING Tokenring;              //... tokenring pointer.
    LPFDDI      Fddi;                   //... FDDI pointer.

} MACFRAME;
typedef MACFRAME *LPMACFRAME;

#define HOT_SIGNATURE       MAKE_IDENTIFIER('H', 'O', 'T', '$')
#define HOE_SIGNATURE       MAKE_IDENTIFIER('H', 'O', 'E', '$')
typedef struct _HANDOFFENTRY
    {
    DWORD hoe_sig;
    DWORD hoe_ProtIdentNumber;
    HPROTOCOL hoe_ProtocolHandle;
    DWORD hoe_ProtocolData;
    } 	HANDOFFENTRY;

typedef HANDOFFENTRY *LPHANDOFFENTRY;

typedef struct _HANDOFFTABLE
    {
    DWORD hot_sig;
    DWORD hot_NumEntries;
    LPHANDOFFENTRY hot_Entries;
    } 	HANDOFFTABLE;

typedef struct _HANDOFFTABLE *LPHANDOFFTABLE;

//=============================================================================
//  Parser helper macros.
//=============================================================================

INLINE LPVOID GetPropertyInstanceData(LPPROPERTYINST PropertyInst)
{
    if ( PropertyInst->DataLength != (WORD) -1 )
    {
        return PropertyInst->lpData;
    }

    return (LPVOID) PropertyInst->lpPropertyInstEx->Byte;
}

#define GetPropertyInstanceDataValue(p, type)  ((type *) GetPropertyInstanceData(p))[0]

INLINE DWORD GetPropertyInstanceFrameDataLength(LPPROPERTYINST PropertyInst)
{
    if ( PropertyInst->DataLength != (WORD) -1 )
    {
        return PropertyInst->DataLength;
    }

    return PropertyInst->lpPropertyInstEx->Length;
}

INLINE DWORD GetPropertyInstanceExDataLength(LPPROPERTYINST PropertyInst)
{
    if ( PropertyInst->DataLength == (WORD) -1 )
    {
        PropertyInst->lpPropertyInstEx->Length;
    }

    return (WORD) -1;
}

//=============================================================================
//  Parser helper functions.
//=============================================================================

LPLABELED_WORD  WINAPI GetProtocolDescriptionTable(LPDWORD TableSize);

LPLABELED_WORD  WINAPI GetProtocolDescription(DWORD ProtocolID);

DWORD        WINAPI GetMacHeaderLength(LPVOID MacHeader, DWORD MacType);

DWORD        WINAPI GetLLCHeaderLength(LPLLC Frame);

DWORD        WINAPI GetEtype(LPVOID MacHeader, DWORD MacType);

DWORD        WINAPI GetSaps(LPVOID MacHeader, DWORD MacType);

BOOL         WINAPI IsLLCPresent(LPVOID MacHeader, DWORD MacType);

VOID         WINAPI CanonicalizeHexString(LPSTR hex, LPSTR dest, DWORD len);

void         WINAPI CanonHex(UCHAR * pDest, UCHAR * pSource, int iLen, BOOL fOx );

DWORD        WINAPI ByteToBinary(LPSTR string, DWORD ByteValue);

DWORD        WINAPI WordToBinary(LPSTR string, DWORD WordValue);

DWORD        WINAPI DwordToBinary(LPSTR string, DWORD DwordValue);

LPSTR        WINAPI AddressToString(LPSTR string, BYTE *lpAddress);

LPBYTE       WINAPI StringToAddress(BYTE *lpAddress, LPSTR string);

LPDWORD      WINAPI VarLenSmallIntToDword( LPBYTE  pValue, 
                                                  WORD    ValueLen, 
                                                  BOOL    fIsByteswapped,
                                                  LPDWORD lpDword );

LPBYTE       WINAPI LookupByteSetString (LPSET lpSet, BYTE Value);

LPBYTE       WINAPI LookupWordSetString (LPSET lpSet, WORD Value);

LPBYTE       WINAPI LookupDwordSetString (LPSET lpSet, DWORD Value);

DWORD        WINAPIV FormatByteFlags(LPSTR string, DWORD ByteValue, DWORD BitMask);

DWORD        WINAPIV FormatWordFlags(LPSTR string, DWORD WordValue, DWORD BitMask);

DWORD        WINAPIV FormatDwordFlags(LPSTR string, DWORD DwordValue, DWORD BitMask);

LPSTR        WINAPIV FormatTimeAsString(SYSTEMTIME *time, LPSTR string);

VOID         WINAPIV FormatLabeledByteSetAsFlags(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatLabeledWordSetAsFlags(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatLabeledDwordSetAsFlags(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatPropertyDataAsByte(LPPROPERTYINST lpPropertyInst, DWORD Base);

VOID         WINAPIV FormatPropertyDataAsWord(LPPROPERTYINST lpPropertyInst, DWORD Base);

VOID         WINAPIV FormatPropertyDataAsDword(LPPROPERTYINST lpPropertyInst, DWORD Base);

VOID         WINAPIV FormatLabeledByteSet(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatLabeledWordSet(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatLabeledDwordSet(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatPropertyDataAsInt64(LPPROPERTYINST lpPropertyInst, DWORD Base);

VOID         WINAPIV FormatPropertyDataAsTime(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatPropertyDataAsString(LPPROPERTYINST lpPropertyInst);

VOID         WINAPIV FormatPropertyDataAsHexString(LPPROPERTYINST lpPropertyInst);

// Parsers should NOT call LockFrame().  If a parser takes a lock and then gets
// faulted or returns without unlocking, it leaves the system in a state where
// it cannot change protocols or cut/copy frames.  Parsers should use ParserTemporaryLockFrame
// which grants a lock ONLY during the context of the api entry into the parser.  The 
// lock is released on exit from the parser for that frame.
ULPBYTE       WINAPI ParserTemporaryLockFrame(HFRAME hFrame);

LPVOID       WINAPI GetCCInstPtr(VOID);
VOID         WINAPI SetCCInstPtr(LPVOID lpCurCaptureInst);
LPVOID       WINAPI CCHeapAlloc(DWORD dwBytes, BOOL bZeroInit);
LPVOID       WINAPI CCHeapReAlloc(LPVOID lpMem, DWORD dwBytes, BOOL bZeroInit);
BOOL         WINAPI CCHeapFree(LPVOID lpMem);
SIZE_T       WINAPI CCHeapSize(LPVOID lpMem);

BOOL _cdecl BERGetInteger( ULPBYTE  pCurrentPointer,
                           ULPBYTE *ppValuePointer,
                           LPDWORD pHeaderLength,
                           LPDWORD pDataLength,
                           ULPBYTE *ppNext);
BOOL _cdecl BERGetString( ULPBYTE  pCurrentPointer,
                          ULPBYTE *ppValuePointer,
                          LPDWORD pHeaderLength,
                          LPDWORD pDataLength,
                          ULPBYTE *ppNext);
BOOL _cdecl BERGetHeader( ULPBYTE  pCurrentPointer,
                          ULPBYTE  pTag,
                          LPDWORD pHeaderLength,
                          LPDWORD pDataLength,
                          ULPBYTE *ppNext);

//=============================================================================
//  Parser Finder Structures.
//=============================================================================
#define	MAX_PROTOCOL_COMMENT_LEN	( 256 )

#define	NETMON_MAX_PROTOCOL_NAME_LEN	( 16 )

// the constant MAX_PROTOCOL_NAME_LEN conflicts with one of the same name
// but different size in rtutils.h.
// So if both headers are included, we do not define MAX_PROTOCOL_NAME_LEN.
#ifndef MAX_PROTOCOL_NAME_LEN
#define	MAX_PROTOCOL_NAME_LEN	( NETMON_MAX_PROTOCOL_NAME_LEN )

#else
#undef MAX_PROTOCOL_NAME_LEN
#endif
// Handoff Value Format Base
typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_netmon_0000_0000_0015
    {	HANDOFF_VALUE_FORMAT_BASE_UNKNOWN	= 0,
	HANDOFF_VALUE_FORMAT_BASE_DECIMAL	= 10,
	HANDOFF_VALUE_FORMAT_BASE_HEX	= 16
    } 	PF_HANDOFFVALUEFORMATBASE;

// PF_HANDOFFENTRY
typedef struct _PF_HANDOFFENTRY
    {
    char szIniFile[ 260 ];
    char szIniSection[ 260 ];
    char szProtocol[ 16 ];
    DWORD dwHandOffValue;
    PF_HANDOFFVALUEFORMATBASE ValueFormatBase;
    } 	PF_HANDOFFENTRY;

typedef PF_HANDOFFENTRY *PPF_HANDOFFENTRY;

// PF_HANDOFFSET
typedef struct _PF_HANDOFFSET
{
    DWORD           nEntries;
    PF_HANDOFFENTRY Entry[0];

} PF_HANDOFFSET;
typedef PF_HANDOFFSET* PPF_HANDOFFSET;
// FOLLOWENTRY
typedef struct _PF_FOLLOWENTRY
    {
    char szProtocol[ 16 ];
    } 	PF_FOLLOWENTRY;

typedef PF_FOLLOWENTRY *PPF_FOLLOWENTRY;

// PF_FOLLOWSET
typedef struct _PF_FOLLOWSET
{
    DWORD           nEntries;
    PF_FOLLOWENTRY  Entry[0];

} PF_FOLLOWSET;
typedef PF_FOLLOWSET* PPF_FOLLOWSET;

// PARSERINFO - contains information about a single parser
typedef struct _PF_PARSERINFO
{
    char szProtocolName[NETMON_MAX_PROTOCOL_NAME_LEN];
    char szComment[MAX_PROTOCOL_COMMENT_LEN];
    char szHelpFile[MAX_PATH];

    PPF_FOLLOWSET pWhoCanPrecedeMe;
    PPF_FOLLOWSET pWhoCanFollowMe;

    PPF_HANDOFFSET pWhoHandsOffToMe;
    PPF_HANDOFFSET pWhoDoIHandOffTo;

} PF_PARSERINFO;
typedef PF_PARSERINFO* PPF_PARSERINFO;

// PF_PARSERDLLINFO - contains information about a single parser DLL
typedef struct _PF_PARSERDLLINFO
{             
//    char          szDLLName[MAX_PATH];
    DWORD         nParsers;
    PF_PARSERINFO ParserInfo[0];

} PF_PARSERDLLINFO;
typedef PF_PARSERDLLINFO* PPF_PARSERDLLINFO;
//=============================================================================
//=============================================================================
//  (IniLib.h)
//=============================================================================
//=============================================================================
#define	INI_PATH_LENGTH	( 256 )

#define	MAX_HANDOFF_ENTRY_LENGTH	( 80 )

#define	MAX_PROTOCOL_NAME	( 40 )

#define	NUMALLOCENTRIES	( 10 )

#define	RAW_INI_STR_LEN	( 200 )

#define PARSERS_SUBDIR              "PARSERS"
#define INI_EXTENSION               "INI"
#define BASE10_FORMAT_STR           "%ld=%s %ld"
#define BASE16_FORMAT_STR           "%lx=%s %lx"
// Given "XNS" or "TCP" or whatever BuildINIPath will return fully qual. path to "XNS.INI" or "TCP.INI"
LPSTR _cdecl BuildINIPath( char     *FullPath,
                           char     *IniFileName );

// Builds Handoff Set
DWORD     WINAPI CreateHandoffTable(LPSTR               secName,
                                    LPSTR               iniFile,
                                    LPHANDOFFTABLE *    hTable,
                                    DWORD               nMaxProtocolEntries,
                                    DWORD               base);

HPROTOCOL WINAPI GetProtocolFromTable(LPHANDOFFTABLE  hTable, // lp to Handoff Table...
                                      DWORD           ItemToFind,       // port number etc...
                                      PDWORD_PTR      lpInstData );   // inst data to give to next protocol

VOID      WINAPI DestroyHandoffTable( LPHANDOFFTABLE hTable );

BOOLEAN WINAPI IsRawIPXEnabled(LPSTR               secName,
                               LPSTR               iniFile,
                               LPSTR               CurProtocol );

//=============================================================================
//=============================================================================
//  (NMExpert.h)
//=============================================================================
//=============================================================================
#define	EXPERTSTRINGLENGTH	( 260 )

#define	EXPERTGROUPNAMELENGTH	( 25 )

// HEXPERTKEY tracks running experts. It is only used by experts for 
// self reference. It refers to a RUNNINGEXPERT (an internal only structure)..
typedef LPVOID HEXPERTKEY;

typedef HEXPERTKEY *PHEXPERTKEY;

// HEXPERT tracks loaded experts. It refers to an EXPERTENUMINFO.
typedef LPVOID HEXPERT;

typedef HEXPERT *PHEXPERT;

// HRUNNINGEXPERT tracks a currently running expert.
// It refers to a RUNNINGEXPERT (an internal only structure).
typedef LPVOID HRUNNINGEXPERT;

typedef HRUNNINGEXPERT *PHRUNNINGEXPERT;

typedef struct _EXPERTENUMINFO * PEXPERTENUMINFO;
typedef struct _EXPERTCONFIG   * PEXPERTCONFIG;
typedef struct _EXPERTSTARTUPINFO * PEXPERTSTARTUPINFO;
// Definitions needed to call experts
#define EXPERTENTRY_REGISTER      "Register"
#define EXPERTENTRY_CONFIGURE     "Configure"
#define EXPERTENTRY_RUN           "Run"
typedef BOOL (WINAPI * PEXPERTREGISTERPROC)( PEXPERTENUMINFO );
typedef BOOL (WINAPI * PEXPERTCONFIGPROC)  ( HEXPERTKEY, PEXPERTCONFIG*, PEXPERTSTARTUPINFO, DWORD, HWND );
typedef BOOL (WINAPI * PEXPERTRUNPROC)     ( HEXPERTKEY, PEXPERTCONFIG, PEXPERTSTARTUPINFO, DWORD, HWND);
// EXPERTENUMINFO describes an expert that NetMon has loaded from disk. 
// It does not include any configuration or runtime information.
typedef struct _EXPERTENUMINFO
{
    char      szName[EXPERTSTRINGLENGTH];
    char      szVendor[EXPERTSTRINGLENGTH];
    char      szDescription[EXPERTSTRINGLENGTH];
    DWORD     Version;    
    DWORD     Flags;
    char      szDllName[MAX_PATH];      // private, dont' touch
    HEXPERT   hExpert;                  // private, don't touch
    HINSTANCE hModule;                  // private, don't touch
    PEXPERTREGISTERPROC pRegisterProc;  // private, don't touch
    PEXPERTCONFIGPROC   pConfigProc;    // private, don't touch
    PEXPERTRUNPROC      pRunProc;       // private, don't touch

} EXPERTENUMINFO;
typedef EXPERTENUMINFO * PEXPERTENUMINFO;
#define	EXPERT_ENUM_FLAG_CONFIGURABLE	( 0x1 )

#define	EXPERT_ENUM_FLAG_VIEWER_PRIVATE	( 0x2 )

#define	EXPERT_ENUM_FLAG_NO_VIEWER	( 0x4 )

#define	EXPERT_ENUM_FLAG_ADD_ME_TO_RMC_IN_SUMMARY	( 0x10 )

#define	EXPERT_ENUM_FLAG_ADD_ME_TO_RMC_IN_DETAIL	( 0x20 )

// EXPERTSTARTUPINFO
// This gives the Expert an indication of where he came from.
// Note: if the lpPropertyInst->PropertyInfo->DataQualifier == PROP_QUAL_FLAGS
// then the sBitField structure is filled in
typedef struct _EXPERTSTARTUPINFO
{
    DWORD           Flags;
    HCAPTURE        hCapture;
    char            szCaptureFile[MAX_PATH];
    DWORD           dwFrameNumber;
    HPROTOCOL       hProtocol;

    LPPROPERTYINST  lpPropertyInst;

    struct
    {
        BYTE    BitNumber;
        BOOL    bOn;
    } sBitfield;

} EXPERTSTARTUPINFO;
// EXPERTCONFIG
// This is a generic holder for an Expert's config data.
typedef struct  _EXPERTCONFIG
{
    DWORD   RawConfigLength;
    BYTE    RawConfigData[0];

} EXPERTCONFIG;
typedef EXPERTCONFIG * PEXPERTCONFIG;
// CONFIGUREDEXPERT
// This structure associates a loaded expert with its configuration data.
typedef struct
{
    HEXPERT         hExpert;
    DWORD           StartupFlags;
    PEXPERTCONFIG   pConfig;
} CONFIGUREDEXPERT;
typedef CONFIGUREDEXPERT * PCONFIGUREDEXPERT;
// EXPERTFRAMEDESCRIPTOR - passed back to the expert to fulfil the request for a frame
typedef struct
{
    DWORD                FrameNumber;         // Frame Number.
    HFRAME               hFrame;              // Handle to the frame.
    ULPFRAME             pFrame;              // pointer to frame.
    LPRECOGNIZEDATATABLE lpRecognizeDataTable;// pointer to table of RECOGNIZEDATA structures.
    LPPROPERTYTABLE      lpPropertyTable;     // pointer to property table.

} EXPERTFRAMEDESCRIPTOR;
typedef EXPERTFRAMEDESCRIPTOR * LPEXPERTFRAMEDESCRIPTOR;
#define	GET_SPECIFIED_FRAME	( 0 )

#define	GET_FRAME_NEXT_FORWARD	( 1 )

#define	GET_FRAME_NEXT_BACKWARD	( 2 )

#define	FLAGS_DEFER_TO_UI_FILTER	( 0x1 )

#define	FLAGS_ATTACH_PROPERTIES	( 0x2 )

// EXPERTSTATUSENUM
// gives the possible values for the status field in the EXPERTSTATUS structure
typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_netmon_0000_0000_0016
    {	EXPERTSTATUS_INACTIVE	= 0,
	EXPERTSTATUS_STARTING	= ( EXPERTSTATUS_INACTIVE + 1 ) ,
	EXPERTSTATUS_RUNNING	= ( EXPERTSTATUS_STARTING + 1 ) ,
	EXPERTSTATUS_PROBLEM	= ( EXPERTSTATUS_RUNNING + 1 ) ,
	EXPERTSTATUS_ABORTED	= ( EXPERTSTATUS_PROBLEM + 1 ) ,
	EXPERTSTATUS_DONE	= ( EXPERTSTATUS_ABORTED + 1 ) 
    } 	EXPERTSTATUSENUMERATION;

// EXPERTSUBSTATUS bitfield 
// gives the possible values for the substatus field in the EXPERTSTATUS structure
#define	EXPERTSUBSTATUS_ABORTED_USER	( 0x1 )

#define	EXPERTSUBSTATUS_ABORTED_LOAD_FAIL	( 0x2 )

#define	EXPERTSUBSTATUS_ABORTED_THREAD_FAIL	( 0x4 )

#define	EXPERTSUBSTATUS_ABORTED_BAD_ENTRY	( 0x8 )

// EXPERTSTATUS
// Indicates the current status of a running expert.
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0000_0017
    {
    EXPERTSTATUSENUMERATION Status;
    DWORD SubStatus;
    DWORD PercentDone;
    DWORD Frame;
    char szStatusText[ 260 ];
    } 	EXPERTSTATUS;

typedef EXPERTSTATUS *PEXPERTSTATUS;

// EXPERT STARTUP FLAGS
#define	EXPERT_STARTUP_FLAG_USE_STARTUP_DATA_OVER_CONFIG_DATA	( 0x1 )

//=============================================================================
//=============================================================================
//  (NetMon.h)
//=============================================================================
//=============================================================================
//  A frame with no number contains this value as its frame number.
#define	INVALID_FRAME_NUMBER	( ( DWORD  )-1 )

//=============================================================================
//  Capture file flags.
//=============================================================================
#define CAPTUREFILE_OPEN                OPEN_EXISTING
#define CAPTUREFILE_CREATE              CREATE_NEW
//=============================================================================
//  CAPTURE CONTEXT API's.
//=============================================================================

LPSYSTEMTIME         WINAPI GetCaptureTimeStamp(HCAPTURE hCapture);

DWORD                WINAPI GetCaptureMacType(HCAPTURE hCapture);

DWORD                WINAPI GetCaptureTotalFrames(HCAPTURE hCapture);

LPSTR                WINAPI GetCaptureComment(HCAPTURE hCapture);

//=============================================================================
//  FRAME HELP API's.
//=============================================================================

DWORD                WINAPI MacTypeToAddressType(DWORD MacType);

DWORD                WINAPI AddressTypeToMacType(DWORD AddressType);

DWORD                WINAPI GetFrameDstAddressOffset(HFRAME hFrame, DWORD AddressType, LPDWORD AddressLength);

DWORD                WINAPI GetFrameSrcAddressOffset(HFRAME hFrame, DWORD AddressType, LPDWORD AddressLength);

HCAPTURE             WINAPI GetFrameCaptureHandle(HFRAME hFrame);


DWORD                WINAPI GetFrameDestAddress(HFRAME       hFrame,
                                                       LPADDRESS2    lpAddress,
                                                       DWORD        AddressType,
                                                       DWORD        Flags);

DWORD                WINAPI GetFrameSourceAddress(HFRAME     hFrame,
                                                         LPADDRESS2  lpAddress,
                                                         DWORD      AddressType,
                                                         DWORD      Flags);

DWORD                WINAPI GetFrameMacHeaderLength(HFRAME hFrame);

BOOL                 WINAPI CompareFrameDestAddress(HFRAME hFrame, LPADDRESS2 lpAddress);

BOOL                 WINAPI CompareFrameSourceAddress(HFRAME hFrame, LPADDRESS2 lpAddress);

DWORD                WINAPI GetFrameLength(HFRAME hFrame);

DWORD                WINAPI GetFrameStoredLength(HFRAME hFrame);

DWORD                WINAPI GetFrameMacType(HFRAME hFrame);

DWORD                WINAPI GetFrameMacHeaderLength(HFRAME hFrame);

DWORD                WINAPI GetFrameNumber(HFRAME hFrame);

__int64              WINAPI GetFrameTimeStamp(HFRAME hFrame);

ULPFRAME             WINAPI GetFrameFromFrameHandle(HFRAME hFrame);

//=============================================================================
//  FRAME API's.
//=============================================================================

HFRAME               WINAPI ModifyFrame(HCAPTURE hCapture,
                                               DWORD    FrameNumber,
                                               LPBYTE   FrameData,
                                               DWORD    FrameLength,
                                               __int64  TimeStamp);

HFRAME               WINAPI FindNextFrame(HFRAME hCurrentFrame,
                                                LPSTR ProtocolName,
                                                LPADDRESS2 lpDestAddress,
                                                LPADDRESS2 lpSrcAddress,
                                                LPWORD ProtocolOffset,
                                                DWORD  OriginalFrameNumber,
                                                DWORD  nHighestFrame);

HFRAME               WINAPI FindPreviousFrame(HFRAME hCurrentFrame,
                                                    LPSTR ProtocolName,
                                                    LPADDRESS2 lpDstAddress,
                                                    LPADDRESS2 lpSrcAddress,
                                                    LPWORD ProtocolOffset,
                                                    DWORD  OriginalFrameNumber,
                                                    DWORD  nLowestFrame );

HCAPTURE             WINAPI GetFrameCaptureHandle(HFRAME);

HFRAME               WINAPI GetFrame(HCAPTURE hCapture, DWORD FrameNumber);

LPRECOGNIZEDATATABLE WINAPI GetFrameRecognizeData(HFRAME hFrame);

//=============================================================================
//  Protocol API's.
//=============================================================================

HPROTOCOL            WINAPI CreateProtocol(LPSTR ProtocolName,
                                                  LPENTRYPOINTS lpEntryPoints,
                                                  DWORD cbEntryPoints);

VOID                 WINAPI DestroyProtocol(HPROTOCOL hProtocol);

LPPROTOCOLINFO       WINAPI GetProtocolInfo(HPROTOCOL hProtocol);

HPROPERTY            WINAPI GetProperty(HPROTOCOL hProtocol, LPSTR PropertyName);

HPROTOCOL            WINAPI GetProtocolFromName(LPSTR ProtocolName);

DWORD                WINAPI GetProtocolStartOffset(HFRAME hFrame, LPSTR ProtocolName);

DWORD                WINAPI GetProtocolStartOffsetHandle(HFRAME hFrame, HPROTOCOL hProtocol);

DWORD                WINAPI GetPreviousProtocolOffsetByName(HFRAME hFrame,
                                                                   DWORD  dwStartOffset,
                                                                   LPSTR  szProtocolName,
                                                                   DWORD* pdwPreviousOffset);

LPPROTOCOLTABLE      WINAPI GetEnabledProtocols(HCAPTURE hCapture);

//=============================================================================
//  Property API's.
//=============================================================================

DWORD                WINAPI CreatePropertyDatabase(HPROTOCOL hProtocol, DWORD nProperties);

DWORD                WINAPI DestroyPropertyDatabase(HPROTOCOL hProtocol);

HPROPERTY            WINAPI AddProperty(HPROTOCOL hProtocol, LPPROPERTYINFO PropertyInfo);

BOOL                 WINAPI AttachPropertyInstance(HFRAME    hFrame,
                                                          HPROPERTY hProperty,
                                                          DWORD     Length,
                                                          ULPVOID   lpData,
                                                          DWORD     HelpID,
                                                          DWORD     Level,
                                                          DWORD     IFlags);

BOOL                 WINAPI AttachPropertyInstanceEx(HFRAME      hFrame,
                                                            HPROPERTY   hProperty,
                                                            DWORD       Length,
                                                            ULPVOID     lpData,
                                                            DWORD       ExLength,
                                                            ULPVOID     lpExData,
                                                            DWORD       HelpID,
                                                            DWORD       Level,
                                                            DWORD       IFlags);

LPPROPERTYINST       WINAPI FindPropertyInstance(HFRAME hFrame, HPROPERTY hProperty);

LPPROPERTYINST       WINAPI FindPropertyInstanceRestart (HFRAME      hFrame, 
                                                                HPROPERTY   hProperty, 
                                                                LPPROPERTYINST *lpRestartKey, 
                                                                BOOL        DirForward );

LPPROPERTYINFO       WINAPI GetPropertyInfo(HPROPERTY hProperty);

LPSTR                WINAPI GetPropertyText(HFRAME hFrame, LPPROPERTYINST lpPI, LPSTR szBuffer, DWORD BufferSize);

DWORD                WINAPI ResetPropertyInstanceLength( LPPROPERTYINST lpProp, 
                                                                WORD nOrgLen, 
                                                                WORD nNewLen );
//=============================================================================
//  MISC. API's.
//=============================================================================

DWORD                WINAPI GetCaptureCommentFromFilename(LPSTR lpFilename, LPSTR lpComment, DWORD BufferSize);

int                  WINAPI CompareAddresses(LPADDRESS2 lpAddress1, LPADDRESS2 lpAddress2);

DWORD                WINAPIV FormatPropertyInstance(LPPROPERTYINST lpPropertyInst, ...);

SYSTEMTIME *         WINAPI AdjustSystemTime(SYSTEMTIME *SystemTime, __int64 TimeDelta);

LPSTR                WINAPI NMRtlIpv6AddressToStringA(const BYTE IP6Addr[],LPSTR S);

LPWSTR               WINAPI NMRtlIpv6AddressToStringW(const BYTE IP6Addr[], LPWSTR S);

ULONG                WINAPI NMRtlIpv6StringToAddressA(LPCSTR S, LPCSTR *Terminator, BYTE IP6Addr[]);

ULONG                WINAPI NMRtlIpv6StringToAddressW(LPCWSTR S, LPCWSTR *Terminator, BYTE IP6Addr[]);

//=============================================================================
//  EXPERT API's for use by Experts
//=============================================================================

DWORD WINAPI ExpertGetFrame( IN HEXPERTKEY hExpertKey,
                                    IN DWORD Direction,
                                    IN DWORD RequestFlags,
                                    IN DWORD RequestedFrameNumber,
                                    IN HFILTER hFilter,
                                    OUT LPEXPERTFRAMEDESCRIPTOR pEFrameDescriptor);

LPVOID WINAPI ExpertAllocMemory( IN  HEXPERTKEY hExpertKey,
                                        IN  SIZE_T nBytes,
                                        OUT DWORD* pError);

LPVOID WINAPI ExpertReallocMemory( IN  HEXPERTKEY hExpertKey,
                                          IN  LPVOID pOriginalMemory,
                                          IN  SIZE_T nBytes,
                                          OUT DWORD* pError);

DWORD WINAPI ExpertFreeMemory( IN HEXPERTKEY hExpertKey,
                                      IN LPVOID pOriginalMemory);

SIZE_T WINAPI ExpertMemorySize( IN HEXPERTKEY hExpertKey,
                                       IN LPVOID pOriginalMemory);

DWORD WINAPI ExpertIndicateStatus( IN HEXPERTKEY              hExpertKey, 
                                          IN EXPERTSTATUSENUMERATION Status,
                                          IN DWORD                   SubStatus,
                                          IN const char *            szText,
                                          IN LONG                    PercentDone);

DWORD WINAPI ExpertSubmitEvent( IN HEXPERTKEY   hExpertKey,
                                       IN PNMEVENTDATA pExpertEvent);

DWORD WINAPI ExpertGetStartupInfo( IN  HEXPERTKEY hExpertKey,
                                          OUT PEXPERTSTARTUPINFO pExpertStartupInfo);

//=============================================================================
//  DEBUG API's.
//=============================================================================
#ifdef DEBUG

//=============================================================================
//  BreakPoint() macro.
//=============================================================================
// We do not want breakpoints in our code any more...
// so we are defining DebugBreak(), usually a system call, to be
// just a dprintf. BreakPoint() is still defined as DebugBreak().

#ifdef DebugBreak
#undef DebugBreak
#endif // DebugBreak

#define DebugBreak()    dprintf("DebugBreak Called at %s:%s", __FILE__, __LINE__);
#define BreakPoint()    DebugBreak()

#endif // DEBUG
//=============================================================================
//=============================================================================
//  (NMBlob.h)
//=============================================================================
//=============================================================================
//=============================================================================
// Blob Constants
//=============================================================================
#define	INITIAL_RESTART_KEY	( 0xffffffff )

//=============================================================================
// Blob Core Helper Routines 
//=============================================================================
DWORD _cdecl CreateBlob(HBLOB * phBlob);

DWORD _cdecl DestroyBlob(HBLOB hBlob);

DWORD _cdecl SetStringInBlob(HBLOB  hBlob,        
                      const char * pOwnerName,    
                      const char * pCategoryName, 
                      const char * pTagName,      
                      const char * pString);      

DWORD _cdecl SetWStringInBlob(HBLOB  hBlob,       
                      const char * pOwnerName,    
                      const char * pCategoryName, 
                      const char * pTagName,      
                      const WCHAR * pwString);    

DWORD _cdecl ConvertWStringToHexString(const WCHAR *pwsz,
                        char ** ppsz);

DWORD _cdecl GetStringFromBlob(HBLOB   hBlob,
                        const char *  pOwnerName,
                        const char *  pCategoryName,
                        const char *  pTagName,
                        const char ** ppString);

DWORD _cdecl ConvertHexStringToWString(CHAR *psz,
                        WCHAR **ppwsz);

DWORD _cdecl GetWStringFromBlob(HBLOB   hBlob,
                        const char *  pOwnerName,
                        const char *  pCategoryName,
                        const char *  pTagName,
                        WCHAR ** ppwString);

DWORD _cdecl GetStringsFromBlob(HBLOB   hBlob,
                         const char * pRequestedOwnerName,
                         const char * pRequestedCategoryName,
                         const char * pRequestedTagName,
                         const char ** ppReturnedOwnerName,
                         const char ** ppReturnedCategoryName,
                         const char ** ppReturnedTagName,
                         const char ** ppReturnedString,
                         DWORD *       pRestartKey);

DWORD _cdecl RemoveFromBlob(HBLOB   hBlob,
                     const char *  pOwnerName,
                     const char *  pCategoryName,
                     const char *  pTagName);

DWORD _cdecl LockBlob(HBLOB hBlob);

DWORD _cdecl UnlockBlob(HBLOB hBlob);

DWORD _cdecl FindUnknownBlobCategories( HBLOB hBlob,
                                 const char *  pOwnerName,
                                 const char *  pKnownCategoriesTable[],
                                 HBLOB hUnknownCategoriesBlob);

//=============================================================================
// Blob Helper Routines 
//=============================================================================
DWORD _cdecl MergeBlob(HBLOB hDstBlob,
                HBLOB hSrcBlob); 

DWORD _cdecl DuplicateBlob (HBLOB hSrcBlob,
                     HBLOB *hBlobThatWillBeCreated ); 

DWORD _cdecl WriteBlobToFile(HBLOB  hBlob,
                      const char * pFileName);

DWORD _cdecl ReadBlobFromFile(HBLOB* phBlob,
                       const char * pFileName);

DWORD _cdecl RegCreateBlobKey(HKEY hkey, const char* szBlobName, HBLOB hBlob);

DWORD _cdecl RegOpenBlobKey(HKEY hkey, const char* szBlobName, HBLOB* phBlob);

DWORD _cdecl MarshalBlob(HBLOB hBlob, DWORD* pSize, BYTE** ppBytes);

DWORD _cdecl UnMarshalBlob(HBLOB* phBlob, DWORD Size, BYTE* pBytes);

DWORD _cdecl SetDwordInBlob(HBLOB hBlob,
                     const char *  pOwnerName,
                     const char *  pCategoryName,
                     const char *  pTagName,
                     DWORD         Dword);

DWORD _cdecl GetDwordFromBlob(HBLOB   hBlob,
                       const char *  pOwnerName,
                       const char *  pCategoryName,
                       const char *  pTagName,
                       DWORD      *  pDword);

DWORD _cdecl SetBoolInBlob(HBLOB   hBlob,
                    const char *  pOwnerName,
                    const char *  pCategoryName,
                    const char *  pTagName,
                    BOOL          Bool);

DWORD _cdecl GetBoolFromBlob(HBLOB   hBlob,
                      const char *  pOwnerName,
                      const char *  pCategoryName,
                      const char *  pTagName,
                      BOOL       *  pBool);

DWORD _cdecl GetMacAddressFromBlob(HBLOB   hBlob,
                            const char *  pOwnerName,
                            const char *  pCategoryName,
                            const char *  pTagName,
                            BYTE *  pMacAddress);

DWORD _cdecl SetMacAddressInBlob(HBLOB   hBlob,
                          const char *  pOwnerName,
                          const char *  pCategoryName,
                          const char *  pTagName,
                          const BYTE *  pMacAddress);

DWORD _cdecl FindUnknownBlobTags( HBLOB hBlob,
                           const char *  pOwnerName,
                           const char *  pCategoryName,
                           const char *  pKnownTagsTable[],
                           HBLOB hUnknownTagsBlob);

//=============================================================================
// Blob NPP Helper Routines
//=============================================================================
DWORD _cdecl SetNetworkInfoInBlob(HBLOB hBlob, 
                           LPNETWORKINFO lpNetworkInfo);

DWORD _cdecl GetNetworkInfoFromBlob(HBLOB hBlob, 
                             LPNETWORKINFO lpNetworkInfo);

DWORD _cdecl CreateNPPInterface ( HBLOB hBlob,
                           REFIID iid,
                           void ** ppvObject);

DWORD _cdecl SetClassIDInBlob(HBLOB hBlob,
                       const char* pOwnerName,
                       const char* pCategoryName,
                       const char* pTagName,
                       const CLSID*  pClsID);

DWORD _cdecl GetClassIDFromBlob(HBLOB hBlob,
                         const char* pOwnerName,
                         const char* pCategoryName,
                         const char* pTagName,
                         CLSID * pClsID);

DWORD _cdecl SetNPPPatternFilterInBlob( HBLOB hBlob,
                                 LPEXPRESSION pExpression,
                                 HBLOB hErrorBlob);

DWORD _cdecl GetNPPPatternFilterFromBlob( HBLOB hBlob,
                                   LPEXPRESSION pExpression,
                                   HBLOB hErrorBlob);

DWORD _cdecl SetNPPAddress2FilterInBlob( HBLOB hBlob,
                                 LPADDRESSTABLE2 pAddressTable);

DWORD _cdecl GetNPPAddress2FilterFromBlob( HBLOB hBlob,
                                   LPADDRESSTABLE2 pAddressTable,
                                   HBLOB hErrorBlob);

DWORD _cdecl SetNPPTriggerInBlob( HBLOB hBlob,
                           LPTRIGGER   pTrigger,
                           HBLOB hErrorBlob);

DWORD _cdecl GetNPPTriggerFromBlob( HBLOB hBlob,
                             LPTRIGGER   pTrigger,
                             HBLOB hErrorBlob);

DWORD _cdecl SetNPPEtypeSapFilter(HBLOB  hBlob, 
                           WORD   nSaps,
                           WORD   nEtypes,
                           LPBYTE lpSapTable,
                           LPWORD lpEtypeTable,
                           DWORD  FilterFlags,
                           HBLOB  hErrorBlob);

DWORD _cdecl GetNPPEtypeSapFilter(HBLOB  hBlob, 
                           WORD   *pnSaps,
                           WORD   *pnEtypes,
                           LPBYTE *ppSapTable,
                           LPWORD *ppEtypeTable,
                           DWORD  *pFilterFlags,
                           HBLOB  hErrorBlob);

// GetNPPMacTypeAsNumber maps the tag NPP:NetworkInfo:MacType to the MAC_TYPE_*
// defined in the NPPTYPES.h.  If the tag is unavailable, the API returns MAC_TYPE_UNKNOWN.
DWORD _cdecl GetNPPMacTypeAsNumber(HBLOB hBlob, 
                            LPDWORD lpMacType);

// See if a remote catagory exists... and make sure that the remote computername
// isn't the same as the local computername.
BOOL  _cdecl IsRemoteNPP ( HBLOB hBLOB);

//=============================================================================
// npp tag definitions
//=============================================================================
#define OWNER_NPP               "NPP"

#define CATEGORY_NETWORKINFO        "NetworkInfo"
#define TAG_MACTYPE                     "MacType"
#define TAG_CURRENTADDRESS              "CurrentAddress"
#define TAG_LINKSPEED                   "LinkSpeed"
#define TAG_MAXFRAMESIZE                "MaxFrameSize"
#define TAG_FLAGS                       "Flags"
#define TAG_TIMESTAMPSCALEFACTOR        "TimeStampScaleFactor"
#define TAG_COMMENT                     "Comment"
#define TAG_NODENAME                    "NodeName"
#define TAG_NAME                        "Name"
#define TAG_FAKENPP                     "Fake"
#define TAG_PROMISCUOUS_MODE            "PMode"

#define CATEGORY_LOCATION           "Location"
#define TAG_RAS                         "Dial-up Connection"
#define TAG_MACADDRESS                  "MacAddress"
#define TAG_CLASSID                     "ClassID"
#define TAG_NAME                        "Name"
#define TAG_CONNECTIONNAME              "Connection Name"
#define TAG_FRIENDLYNAME                "Friendly Name"

#define CATEGORY_CONFIG             "Config"
#define TAG_FRAME_SIZE                  "FrameSize"
#define TAG_UPDATE_FREQUENCY            "UpdateFreq"
#define TAG_BUFFER_SIZE                 "BufferSize"
#define TAG_PATTERN_DESIGNATOR          "PatternMatch"
#define TAG_PATTERN                     "Pattern"
#define TAG_ADDRESS_PAIR                "AddressPair"
#define TAG_CONNECTIONFLAGS             "ConnectionFlags"
#define TAG_ETYPES                      "Etypes"
#define TAG_SAPS                        "Saps"
#define TAG_NO_CONVERSATION_STATS       "NoConversationStats"
#define TAG_NO_STATS_FRAME              "NoStatsFrame"
#define TAG_DONT_DELETE_EMPTY_CAPTURE   "DontDeleteEmptyCapture"
#define TAG_WANT_PROTOCOL_INFO          "WantProtocolInfo"
#define TAG_INTERFACE_DELAYED_CAPTURE   "IDdC"
#define TAG_INTERFACE_REALTIME_CAPTURE  "IRTC"
#define TAG_INTERFACE_STATS             "ISts"
#define TAG_INTERFACE_TRANSMIT          "IXmt"
#define TAG_LOCAL_ONLY                  "LocalOnly"
// Is_Remote is set to TRUE by NPPs that go remote.  Note that when you
//  are looking for a remote NPP, you probably also need to ask for
//  blobs that have the TAG_GET_SPECIAL_BLOBS bool set
#define TAG_IS_REMOTE                   "IsRemote"


#define CATEGORY_TRIGGER            "Trigger"
#define TAG_TRIGGER                     "Trigger"

#define CATEGORY_FINDER             "Finder"
#define TAG_ROOT                        "Root"
#define TAG_PROCNAME                    "ProcName"
#define TAG_DISP_STRING                 "Display"
#define TAG_DLL_FILENAME                "DLLName"
#define TAG_GET_SPECIAL_BLOBS           "Specials"

#define CATEGORY_REMOTE              "Remote"
#define TAG_REMOTECOMPUTER              "RemoteComputer"
#define TAG_REMOTECLASSID               "ClassID"


//=============================================================================
// npp value definitions
//=============================================================================
// Mac types
#define PROTOCOL_STRING_ETHERNET_TXT   "ETHERNET"
#define PROTOCOL_STRING_TOKENRING_TXT  "TOKENRING"
#define PROTOCOL_STRING_FDDI_TXT       "FDDI"
#define PROTOCOL_STRING_ATM_TXT        "ATM"
#define PROTOCOL_STRING_1394_TXT       "IP/1394"

// lower protocols
#define PROTOCOL_STRING_IP_TXT         "IP"
#define PROTOCOL_STRING_IP6_TXT        "IP6"
#define PROTOCOL_STRING_IPX_TXT        "IPX"
#define PROTOCOL_STRING_XNS_TXT        "XNS"
#define PROTOCOL_STRING_VINES_IP_TXT   "VINES IP"

// upper protocols
#define PROTOCOL_STRING_ICMP_TXT       "ICMP"
#define PROTOCOL_STRING_TCP_TXT        "TCP"
#define PROTOCOL_STRING_UDP_TXT        "UDP"
#define PROTOCOL_STRING_SPX_TXT        "SPX"
#define PROTOCOL_STRING_NCP_TXT        "NCP"

// pseudo protocols
#define PROTOCOL_STRING_ANY_TXT        "ANY"
#define PROTOCOL_STRING_ANY_GROUP_TXT  "ANY GROUP"
#define PROTOCOL_STRING_HIGHEST_TXT    "HIGHEST"
#define PROTOCOL_STRING_LOCAL_ONLY_TXT "LOCAL ONLY"
#define PROTOCOL_STRING_UNKNOWN_TXT    "UNKNOWN"
#define PROTOCOL_STRING_DATA_TXT       "DATA"
#define PROTOCOL_STRING_FRAME_TXT      "FRAME"
#define PROTOCOL_STRING_NONE_TXT       "NONE"
#define PROTOCOL_STRING_EFFECTIVE_TXT  "EFFECTIVE"

#define ADDRESS_PAIR_INCLUDE_TXT    "INCLUDE"
#define ADDRESS_PAIR_EXCLUDE_TXT    "EXCLUDE"

#define INCLUDE_ALL_EXCEPT_TXT      "INCLUDE ALL EXCEPT"
#define EXCLUDE_ALL_EXCEPT_TXT      "EXCLUDE ALL EXCEPT"

#define PATTERN_MATCH_OR_TXT        "OR("
#define PATTERN_MATCH_AND_TXT       "AND("

#define TRIGGER_PATTERN_TXT               "PATTERN MATCH"
#define TRIGGER_BUFFER_TXT                "BUFFER CONTENT"

#define TRIGGER_NOTIFY_TXT      "NOTIFY"
#define TRIGGER_STOP_TXT        "STOP"
#define TRIGGER_PAUSE_TXT       "PAUSE"

#define TRIGGER_25_PERCENT_TXT  "25 PERCENT"
#define TRIGGER_50_PERCENT_TXT  "50 PERCENT"
#define TRIGGER_75_PERCENT_TXT  "75 PERCENT"
#define TRIGGER_100_PERCENT_TXT "100 PERCENT"

#define PATTERN_MATCH_NOT_TXT   "NOT"

//=============================================================================
//=============================================================================
// (NMRegHelp.h)
//=============================================================================
//=============================================================================

// Registry helpers
LPCSTR _cdecl FindOneOf(LPCSTR p1, LPCSTR p2);

LONG _cdecl recursiveDeleteKey(HKEY hKeyParent,            // Parent of key to delete.
                        const char* lpszKeyChild);  // Key to delete.

BOOL _cdecl SubkeyExists(const char* pszPath,              // Path of key to check
                  const char* szSubkey);            // Key to check

BOOL _cdecl setKeyAndValue(const char* szKey, 
                    const char* szSubkey, 
                    const char* szValue,
                    const char* szName) ;

//=============================================================================
//=============================================================================
// (NMIpStructs.h)
//=============================================================================
//=============================================================================

// These structures are used to decode network data and so need to be packed

#pragma pack(push, 1)
//
// IP Packet Structure
//
typedef struct _IP 
{
    union 
    {
        BYTE   Version;
        BYTE   HdrLen;
    };
    BYTE ServiceType;
    WORD TotalLen;
    WORD ID;
    union 
    {
        WORD   Flags;
        WORD   FragOff;
    };
    BYTE TimeToLive;
    BYTE Protocol;
    WORD HdrChksum;
    DWORD   SrcAddr;
    DWORD   DstAddr;
    BYTE Options[0];
} IP;

typedef IP * LPIP;
typedef IP UNALIGNED * ULPIP;
// Psuedo Header used for CheckSum Calculations
typedef struct _PSUHDR
    {
    DWORD ph_SrcIP;
    DWORD ph_DstIP;
    UCHAR ph_Zero;
    UCHAR ph_Proto;
    WORD ph_ProtLen;
    } 	PSUHDR;

typedef PSUHDR UNALIGNED * LPPSUHDR;
//
// IP Bitmasks that are useful
// (and the appropriate bit shifts, as well)
//

#define IP_VERSION_MASK ((BYTE) 0xf0)
#define IP_VERSION_SHIFT (4)
#define IP_HDRLEN_MASK  ((BYTE) 0x0f)
#define IP_HDRLEN_SHIFT (0)
#define IP_PRECEDENCE_MASK ((BYTE) 0xE0)
#define IP_PRECEDENCE_SHIFT   (5)
#define IP_TOS_MASK ((BYTE) 0x1E)
#define IP_TOS_SHIFT   (1)
#define IP_DELAY_MASK   ((BYTE) 0x10)
#define IP_THROUGHPUT_MASK ((BYTE) 0x08)
#define IP_RELIABILITY_MASK   ((BYTE) 0x04)
#define IP_FLAGS_MASK   ((BYTE) 0xE0)
#define IP_FLAGS_SHIFT  (13)
#define IP_DF_MASK   ((BYTE) 0x40)
#define IP_MF_MASK   ((BYTE) 0x20)
#define IP_MF_SHIFT     (5)
#define IP_FRAGOFF_MASK ((WORD) 0x1FFF)
#define IP_FRAGOFF_SHIFT   (3)
#define IP_TCC_MASK  ((DWORD) 0xFFFFFF00)
#define IP_TIME_OPTS_MASK  ((BYTE) 0x0F)
#define IP_MISS_STNS_MASK  ((BYTE) 0xF0)

#define IP_TIME_OPTS_SHIFT (0)
#define IP_MISS_STNS_SHIFT  (4)

//
// Offset to checksum field in ip header
//
#define IP_CHKSUM_OFF   10

INLINE BYTE IP_Version(ULPIP pIP)
{
    return (pIP->Version & IP_VERSION_MASK) >> IP_VERSION_SHIFT;
}

INLINE DWORD IP_HdrLen(ULPIP pIP)
{
    return ((pIP->HdrLen & IP_HDRLEN_MASK) >> IP_HDRLEN_SHIFT) << 2;
}

INLINE WORD IP_FragOff(ULPIP pIP)
{
    return (XCHG(pIP->FragOff) & IP_FRAGOFF_MASK) << IP_FRAGOFF_SHIFT;
}

INLINE DWORD IP_TotalLen(ULPIP pIP)
{
    return XCHG(pIP->TotalLen);
}

INLINE DWORD IP_MoreFragments(ULPIP pIP)
{
    return (pIP->Flags & IP_MF_MASK) >> IP_MF_SHIFT;
}
//
// Well known ports in the TCP/IP protocol (See RFC 1060)
//
#define PORT_TCPMUX              1  // TCP Port Service Multiplexer
#define PORT_RJE                 5  // Remote Job Entry
#define PORT_ECHO                7  // Echo
#define PORT_DISCARD             9  // Discard
#define PORT_USERS              11  // Active users
#define PORT_DAYTIME            13  // Daytime
#define PORT_NETSTAT            15  // Netstat
#define PORT_QUOTE              17  // Quote of the day
#define PORT_CHARGEN            19  // Character Generator
#define PORT_FTPDATA            20  // File transfer [default data]
#define PORT_FTP                21  // File transfer [Control]
#define PORT_TELNET             23  // Telnet
#define PORT_SMTP               25  // Simple Mail Transfer
#define PORT_NSWFE              27  // NSW User System FE
#define PORT_MSGICP             29  // MSG ICP
#define PORT_MSGAUTH            31  // MSG Authentication
#define PORT_DSP                33  // Display Support
#define PORT_PRTSERVER          35  // any private printer server
#define PORT_TIME               37  // Time
#define PORT_RLP                39  // Resource Location Protocol
#define PORT_GRAPHICS           41  // Graphics
#define PORT_NAMESERVER         42  // Host Name Server
#define PORT_NICNAME            43  // Who is
#define PORT_MPMFLAGS           44  // MPM Flags 
#define PORT_MPM                45  // Message Processing Module [recv]
#define PORT_MPMSND             46  // MPM [default send]
#define PORT_NIFTP              47  // NI FTP
#define PORT_LOGIN              49  // Login Host Protocol
#define PORT_LAMAINT            51  // IMP Logical Address Maintenance
#define PORT_DOMAIN             53  // Domain Name Server
#define PORT_ISIGL              55  // ISI Graphics Language
#define PORT_ANYTERMACC         57  // any private terminal access
#define PORT_ANYFILESYS         59  // any private file service
#define PORT_NIMAIL             61  // NI Mail
#define PORT_VIAFTP             63  // VIA Systems - FTP
#define PORT_TACACSDS           65  // TACACS - Database Service
#define PORT_BOOTPS             67  // Bootstrap Protocol server
#define PORT_BOOTPC             68  // Bootstrap Protocol client
#define PORT_TFTP               69  // Trivial File Transfer
#define PORT_NETRJS1            71  // Remote Job service
#define PORT_NETRJS2            72  // Remote Job service
#define PORT_NETRJS3            73  // Remote Job service
#define PORT_NETRJS4            74  // Remote Job service
#define PORT_ANYDIALOUT         75  // any private dial out service
#define PORT_ANYRJE             77  // any private RJE service
#define PORT_FINGER             79  // Finger
#define PORT_HTTP               80  // HTTP (www)
#define PORT_HOSTS2NS           81  // Hosts2 Name Server
#define PORT_MITMLDEV1          83  // MIT ML Device
#define PORT_MITMLDEV2          85  // MIT ML Device
#define PORT_ANYTERMLINK        87  // any private terminal link
#define PORT_SUMITTG            89  // SU/MIT Telnet Gateway
#define PORT_MITDOV             91  // MIT Dover Spooler
#define PORT_DCP                93  // Device Control Protocol
#define PORT_SUPDUP             95  // SUPDUP
#define PORT_SWIFTRVF           97  // Swift Remote Vitural File Protocol
#define PORT_TACNEWS            98  // TAC News
#define PORT_METAGRAM           99  // Metagram Relay
#define PORT_NEWACCT           100  // [Unauthorized use]
#define PORT_HOSTNAME          101  // NIC Host Name Server
#define PORT_ISOTSAP           102  // ISO-TSAP
#define PORT_X400              103  // X400
#define PORT_X400SND           104  // X400 - SND
#define PORT_CSNETNS           105  // Mailbox Name Nameserver
#define PORT_RTELNET           107  // Remote Telnet Service
#define PORT_POP2              109  // Post Office Protocol - version 2
#define PORT_POP3              110  // Post Office Protocol - version 3
#define PORT_SUNRPC            111  // SUN Remote Procedure Call
#define PORT_AUTH              113  // Authentication
#define PORT_SFTP              115  // Simple File Transfer Protocol
#define PORT_UUCPPATH          117  // UUCP Path Service
#define PORT_NNTP              119  // Network News Transfer Protocol
#define PORT_ERPC              121  // Encore Expedited Remote Proc. Call
#define PORT_NTP               123  // Network Time Protocol
#define PORT_LOCUSMAP          125  // Locus PC-Interface Net Map Sesrver
#define PORT_LOCUSCON          127  // Locus PC-Interface Conn Server
#define PORT_PWDGEN            129  // Password Generator Protocol
#define PORT_CISCOFNA          130  // CISCO FNATIVE
#define PORT_CISCOTNA          131  // CISCO TNATIVE
#define PORT_CISCOSYS          132  // CISCO SYSMAINT
#define PORT_STATSRV           133  // Statistics Service
#define PORT_INGRESNET         134  // Ingres net service
#define PORT_LOCSRV            135  // Location Service
#define PORT_PROFILE           136  // PROFILE Naming System
#define PORT_NETBIOSNS         137  // NETBIOS Name Service
#define PORT_NETBIOSDGM        138  // NETBIOS Datagram Service
#define PORT_NETBIOSSSN        139  // NETBIOS Session Service
#define PORT_EMFISDATA         140  // EMFIS Data Service
#define PORT_EMFISCNTL         141  // EMFIS Control Service
#define PORT_BLIDM             142  // Britton-Lee IDM
#define PORT_IMAP2             143  // Interim Mail Access Protocol v2
#define PORT_NEWS              144  // NewS
#define PORT_UAAC              145  // UAAC protocol
#define PORT_ISOTP0            146  // ISO-IP0
#define PORT_ISOIP             147  // ISO-IP
#define PORT_CRONUS            148  // CRONUS-Support
#define PORT_AED512            149  // AED 512 Emulation Service
#define PORT_SQLNET            150  // SQL-NET
#define PORT_HEMS              151  // HEMS
#define PORT_BFTP              152  // Background File Transfer Protocol
#define PORT_SGMP              153  // SGMP
#define PORT_NETSCPROD         154  // NETSC
#define PORT_NETSCDEV          155  // NETSC
#define PORT_SQLSRV            156  // SQL service
#define PORT_KNETCMP           157  // KNET/VM Command/Message Protocol
#define PORT_PCMAILSRV         158  // PCMail server
#define PORT_NSSROUTING        159  // NSS routing
#define PORT_SGMPTRAPS         160  // SGMP-TRAPS
#define PORT_SNMP              161  // SNMP
#define PORT_SNMPTRAP          162  // SNMPTRAP
#define PORT_CMIPMANAGE        163  // CMIP/TCP Manager
#define PORT_CMIPAGENT         164  // CMIP/TCP Agent
#define PORT_XNSCOURIER        165  // Xerox
#define PORT_SNET              166  // Sirius Systems
#define PORT_NAMP              167  // NAMP
#define PORT_RSVD              168  // RSVC
#define PORT_SEND              169  // SEND
#define PORT_PRINTSRV          170  // Network Postscript
#define PORT_MULTIPLEX         171  // Network Innovations Multiples
#define PORT_CL1               172  // Network Innovations CL/1
#define PORT_XYPLEXMUX         173  // Xyplex
#define PORT_MAILQ             174  // MAILQ
#define PORT_VMNET             175  // VMNET
#define PORT_GENRADMUX         176  // GENRAD-MUX
#define PORT_XDMCP             177  // X Display Manager Control Protocol
#define PORT_NEXTSTEP          178  // NextStep Window Server
#define PORT_BGP               179  // Border Gateway Protocol
#define PORT_RIS               180  // Intergraph
#define PORT_UNIFY             181  // Unify
#define PORT_UNISYSCAM         182  // Unisys-Cam
#define PORT_OCBINDER          183  // OCBinder
#define PORT_OCSERVER          184  // OCServer
#define PORT_REMOTEKIS         185  // Remote-KIS
#define PORT_KIS               186  // KIS protocol
#define PORT_ACI               187  // Application Communication Interface
#define PORT_MUMPS             188  // MUMPS
#define PORT_QFT               189  // Queued File Transport
#define PORT_GACP              190  // Gateway Access Control Protocol
#define PORT_PROSPERO          191  // Prospero
#define PORT_OSUNMS            192  // OSU Network Monitoring System
#define PORT_SRMP              193  // Spider Remote Monitoring Protocol
#define PORT_IRC               194  // Internet Relay Chat Protocol
#define PORT_DN6NLMAUD         195  // DNSIX Network Level Module Audit
#define PORT_DN6SMMRED         196  // DSNIX Session Mgt Module Audit Redirector
#define PORT_DLS               197  // Directory Location Service
#define PORT_DLSMON            198  // Directory Location Service Monitor
#define PORT_ATRMTP            201  // AppleTalk Routing Maintenance
#define PORT_ATNBP             202  // AppleTalk Name Binding
#define PORT_AT3               203  // AppleTalk Unused
#define PORT_ATECHO            204  // AppleTalk Echo
#define PORT_AT5               205  // AppleTalk Unused
#define PORT_ATZIS             206  // AppleTalk Zone Information
#define PORT_AT7               207  // AppleTalk Unused
#define PORT_AT8               208  // AppleTalk Unused
#define PORT_SURMEAS           243  // Survey Measurement
#define PORT_LINK              245  // LINK
#define PORT_DSP3270           246  // Display Systems Protocol
#define PORT_LDAP1             389  // LDAP
#define PORT_ISAKMP            500  // ISAKMP
#define PORT_REXEC             512  // Remote Process Execution
#define PORT_RLOGIN            513  // Remote login a la telnet
#define PORT_RSH               514  // Remote command
#define PORT_LPD               515  // Line printer spooler - LPD
#define PORT_RIP               520  // TCP=? / UDP=RIP
#define PORT_TEMPO             526  // Newdate
#define PORT_COURIER           530  // rpc
#define PORT_NETNEWS           532  // READNEWS
#define PORT_UUCPD             540  // UUCPD
#define PORT_KLOGIN            543  //
#define PORT_KSHELL            544  // krcmd
#define PORT_DSF               555  //
#define PORT_REMOTEEFS         556  // RFS server
#define PORT_CHSHELL           562  // chmod
#define PORT_METER             570  // METER
#define PORT_PCSERVER          600  // SUN IPC Server
#define PORT_NQS               607  // NQS
#define PORT_HMMP_INDICATION   612  //     
#define PORT_HMMP_OPERATION    613  //     
#define PORT_MDQS              666  // MDQS
#define PORT_LPD721            721  // LPD Client (lpd client ports 721 - 731)
#define PORT_LPD722            722  // LPD Client (see RFC 1179)
#define PORT_LPD723            723  // LPD Client
#define PORT_LPD724            724  // LPD Client
#define PORT_LPD725            725  // LPD Client
#define PORT_LPD726            726  // LPD Client
#define PORT_LPD727            727  // LPD Client
#define PORT_LPD728            728  // LPD Client
#define PORT_LPD729            729  // LPD Client
#define PORT_LPD730            730  // LPD Client
#define PORT_LPD731            731  // LPD Client
#define PORT_RFILE             750  // RFILE
#define PORT_PUMP              751  // PUMP
#define PORT_QRH               752  // QRH
#define PORT_RRH               753  // RRH
#define PORT_TELL              754  // TELL
#define PORT_NLOGIN            758  // NLOGIN
#define PORT_CON               759  // CON
#define PORT_NS                760  // NS
#define PORT_RXE               761  // RXE
#define PORT_QUOTAD            762  // QUOTAD
#define PORT_CYCLESERV         763  // CYCLESERV
#define PORT_OMSERV            764  // OMSERV
#define PORT_WEBSTER           765  // WEBSTER
#define PORT_PHONEBOOK         767  // PHONE
#define PORT_VID               769  // VID
#define PORT_RTIP              771  // RTIP
#define PORT_CYCLESERV2        772  // CYCLESERV-2
#define PORT_SUBMIT            773  // submit
#define PORT_RPASSWD           774  // RPASSWD
#define PORT_ENTOMB            775  // ENTOMB
#define PORT_WPAGES            776  // WPAGES
#define PORT_WPGS              780  // wpgs
#define PORT_MDBSDAEMON        800  // MDBS DAEMON
#define PORT_DEVICE            801  // DEVICE
#define PORT_MAITRD            997  // MAITRD
#define PORT_BUSBOY            998  // BUSBOY
#define PORT_GARCON            999  // GARCON
#define PORT_NFS              2049  // NFS
#define PORT_LDAP2            3268  // LDAP
#define PORT_PPTP             5678  // PPTP

//=============================================================================
//=============================================================================
// (NMIcmpStructs.h)
//=============================================================================
//=============================================================================

//
// ICMP Frame Structure
//
typedef struct _RequestReplyFields
    {
    WORD ID;
    WORD SeqNo;
    } 	ReqReply;

typedef struct _ParameterProblemFields
    {
    BYTE Pointer;
    BYTE junk[ 3 ];
    } 	ParmProb;

typedef struct _TimestampFields
    {
    DWORD tsOrig;
    DWORD tsRecv;
    DWORD tsXmit;
    } 	TS;

typedef struct _RouterAnnounceHeaderFields
    {
    BYTE NumAddrs;
    BYTE AddrEntrySize;
    WORD Lifetime;
    } 	RouterAH;

typedef struct _RouterAnnounceEntry
    {
    DWORD Address;
    DWORD PreferenceLevel;
    } 	RouterAE;

typedef struct _ICMP 
{
   BYTE Type;
   BYTE Code;
   WORD Checksum;
   union
   {
      DWORD    Unused;
      DWORD    Address;
      ReqReply RR;
      ParmProb PP;
      RouterAH RAH;     
   };

   union
   {
      TS       Time;
      IP       IP;
      RouterAE RAE[0];
   };
} ICMP;

typedef ICMP * LPICMP;
typedef ICMP UNALIGNED * ULPICMP;
#define	ICMP_HEADER_LENGTH	( 8 )

// # of *BYTES* of IP data to attach to
// datagram in addition to IP header
#define	ICMP_IP_DATA_LENGTH	( 8 )

//
// ICMP Packet Types
//
#define	ECHO_REPLY	( 0 )

#define	DESTINATION_UNREACHABLE	( 3 )

#define	SOURCE_QUENCH	( 4 )

#define	REDIRECT	( 5 )

#define	ECHO	( 8 )

#define	ROUTER_ADVERTISEMENT	( 9 )

#define	ROUTER_SOLICITATION	( 10 )

#define	TIME_EXCEEDED	( 11 )

#define	PARAMETER_PROBLEM	( 12 )

#define	TIMESTAMP	( 13 )

#define	TIMESTAMP_REPLY	( 14 )

#define	INFORMATION_REQUEST	( 15 )

#define	INFORMATION_REPLY	( 16 )

#define	ADDRESS_MASK_REQUEST	( 17 )

#define	ADDRESS_MASK_REPLY	( 18 )

//=============================================================================
//=============================================================================
// (NMIpxStructs.h)
//=============================================================================
//=============================================================================
//  IPX
typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0000_0018
    {
    UCHAR ha_address[ 6 ];
    } 	HOST_ADDRESS;

typedef struct _IPXADDRESS
    {
    ULONG ipx_NetNumber;
    HOST_ADDRESS ipx_HostAddr;
    } 	IPXADDRESS;

typedef IPXADDRESS UNALIGNED * PIPXADDRESS;
typedef struct _NET_ADDRESS
    {
    IPXADDRESS na_IPXAddr;
    USHORT na_socket;
    } 	NET_ADDRESS;

typedef NET_ADDRESS UNALIGNED * UPNET_ADDRESS;
// IPX Internetwork Packet eXchange Protocol Header.
typedef /* [public][public] */ struct __MIDL___MIDL_itf_netmon_0000_0000_0019
    {
    USHORT ipx_checksum;
    USHORT ipx_length;
    UCHAR ipx_xport_control;
    UCHAR ipx_packet_type;
    NET_ADDRESS ipx_dest;
    NET_ADDRESS ipx_source;
    } 	IPX_HDR;

typedef IPX_HDR UNALIGNED * ULPIPX_HDR;
//  SPX - Sequenced Packet Protocol
typedef struct _SPX_HDR
    {
    IPX_HDR spx_idp_hdr;
    UCHAR spx_conn_ctrl;
    UCHAR spx_data_type;
    USHORT spx_src_conn_id;
    USHORT spx_dest_conn_id;
    USHORT spx_sequence_num;
    USHORT spx_ack_num;
    USHORT spx_alloc_num;
    } 	SPX_HDR;

typedef SPX_HDR UNALIGNED *PSPX_HDR;
//=============================================================================
//=============================================================================
// (NMTcpStructs.h)
//=============================================================================
//=============================================================================
//
// TCP Packet Structure
//
typedef struct _TCP
    {
    WORD SrcPort;
    WORD DstPort;
    DWORD SeqNum;
    DWORD AckNum;
    BYTE DataOff;
    BYTE Flags;
    WORD Window;
    WORD Chksum;
    WORD UrgPtr;
    } 	TCP;

typedef TCP *LPTCP;

typedef TCP UNALIGNED * ULPTCP;
INLINE DWORD TCP_HdrLen(ULPTCP pTCP)
{
    return (pTCP->DataOff & 0xf0) >> 2;
}

INLINE DWORD TCP_SrcPort(ULPTCP pTCP)
{
    return XCHG(pTCP->SrcPort);
}

INLINE DWORD TCP_DstPort(ULPTCP pTCP)
{
    return XCHG(pTCP->DstPort);
}
//
// TCP Option Opcodes
//
#define	TCP_OPTION_ENDOFOPTIONS	( 0 )

#define	TCP_OPTION_NOP	( 1 )

#define	TCP_OPTION_MAXSEGSIZE	( 2 )

#define	TCP_OPTION_WSCALE	( 3 )

#define	TCP_OPTION_SACK_PERMITTED	( 4 )

#define	TCP_OPTION_SACK	( 5 )

#define	TCP_OPTION_TIMESTAMPS	( 8 )

//
// TCP Flags
//
#define	TCP_FLAG_URGENT	( 0x20 )

#define	TCP_FLAG_ACK	( 0x10 )

#define	TCP_FLAG_PUSH	( 0x8 )

#define	TCP_FLAG_RESET	( 0x4 )

#define	TCP_FLAG_SYN	( 0x2 )

#define	TCP_FLAG_FIN	( 0x1 )

//
// TCP Field Masks
//
#define	TCP_RESERVED_MASK	( 0xfc0 )


#pragma pack(pop)
//****************************************************************************
//****************************************************************************
// IDelaydC - used by a consumer to get frames after a capture has completed.
//****************************************************************************
//****************************************************************************
#define	DEFAULT_DELAYED_BUFFER_SIZE	( 1 )

#define	USE_DEFAULT_DRIVE_LETTER	( 0 )

#define	RTC_FRAME_SIZE_FULL	( 0 )



extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0000_v0_0_s_ifspec;

#ifndef __IDelaydC_INTERFACE_DEFINED__
#define __IDelaydC_INTERFACE_DEFINED__

/* interface IDelaydC */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDelaydC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BFF9C030-B58F-11ce-B5B0-00AA006CB37D")
    IDelaydC : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [out] */ char *pFileName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [out] */ LPSTATISTICS lpStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalStatistics( 
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversationStatistics( 
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpecialFrame( 
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDelaydCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDelaydC * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDelaydC * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDelaydC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IDelaydC * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IDelaydC * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IDelaydC * This,
            /* [out] */ NETWORKSTATUS *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IDelaydC * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IDelaydC * This,
            /* [out] */ char *pFileName);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IDelaydC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IDelaydC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IDelaydC * This,
            /* [out] */ LPSTATISTICS lpStats);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlState )( 
            IDelaydC * This,
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalStatistics )( 
            IDelaydC * This,
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversationStatistics )( 
            IDelaydC * This,
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpecialFrame )( 
            IDelaydC * This,
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStations )( 
            IDelaydC * This,
            /* [out][in] */ QUERYTABLE *lpQueryTable);
        
        END_INTERFACE
    } IDelaydCVtbl;

    interface IDelaydC
    {
        CONST_VTBL struct IDelaydCVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDelaydC_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDelaydC_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDelaydC_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDelaydC_Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)	\
    ( (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob) ) 

#define IDelaydC_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IDelaydC_QueryStatus(This,pNetworkStatus)	\
    ( (This)->lpVtbl -> QueryStatus(This,pNetworkStatus) ) 

#define IDelaydC_Configure(This,hConfigurationBlob,hErrorBlob)	\
    ( (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob) ) 

#define IDelaydC_Start(This,pFileName)	\
    ( (This)->lpVtbl -> Start(This,pFileName) ) 

#define IDelaydC_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IDelaydC_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IDelaydC_Stop(This,lpStats)	\
    ( (This)->lpVtbl -> Stop(This,lpStats) ) 

#define IDelaydC_GetControlState(This,IsRunnning,IsPaused)	\
    ( (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused) ) 

#define IDelaydC_GetTotalStatistics(This,lpStats,fClearAfterReading)	\
    ( (This)->lpVtbl -> GetTotalStatistics(This,lpStats,fClearAfterReading) ) 

#define IDelaydC_GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)	\
    ( (This)->lpVtbl -> GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading) ) 

#define IDelaydC_InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)	\
    ( (This)->lpVtbl -> InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength) ) 

#define IDelaydC_QueryStations(This,lpQueryTable)	\
    ( (This)->lpVtbl -> QueryStations(This,lpQueryTable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDelaydC_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netmon_0000_0001 */
/* [local] */ 

//****************************************************************************
//****************************************************************************
// IRTC - used by a consumer to get an interface to local entry points
// necessary to do real time capture processing.  It includes a method
// for handing a callback to the NPP.
//****************************************************************************
//****************************************************************************
#define	DEFAULT_RTC_BUFFER_SIZE	( 0x100000 )



extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0001_v0_0_s_ifspec;

#ifndef __IRTC_INTERFACE_DEFINED__
#define __IRTC_INTERFACE_DEFINED__

/* interface IRTC */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IRTC;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4811EA40-B582-11ce-B5AF-00AA006CB37D")
    IRTC : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID FramesCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalStatistics( 
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversationStatistics( 
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpecialFrame( 
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRTCVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IRTC * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IRTC * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IRTC * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID FramesCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IRTC * This,
            /* [out] */ NETWORKSTATUS *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IRTC * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IRTC * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlState )( 
            IRTC * This,
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalStatistics )( 
            IRTC * This,
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversationStatistics )( 
            IRTC * This,
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpecialFrame )( 
            IRTC * This,
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStations )( 
            IRTC * This,
            /* [out][in] */ QUERYTABLE *lpQueryTable);
        
        END_INTERFACE
    } IRTCVtbl;

    interface IRTC
    {
        CONST_VTBL struct IRTCVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRTC_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IRTC_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IRTC_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IRTC_Connect(This,hInputBlob,StatusCallbackProc,FramesCallbackProc,UserContext,hErrorBlob)	\
    ( (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,FramesCallbackProc,UserContext,hErrorBlob) ) 

#define IRTC_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IRTC_QueryStatus(This,pNetworkStatus)	\
    ( (This)->lpVtbl -> QueryStatus(This,pNetworkStatus) ) 

#define IRTC_Configure(This,hConfigurationBlob,hErrorBlob)	\
    ( (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob) ) 

#define IRTC_Start(This)	\
    ( (This)->lpVtbl -> Start(This) ) 

#define IRTC_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IRTC_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IRTC_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IRTC_GetControlState(This,IsRunnning,IsPaused)	\
    ( (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused) ) 

#define IRTC_GetTotalStatistics(This,lpStats,fClearAfterReading)	\
    ( (This)->lpVtbl -> GetTotalStatistics(This,lpStats,fClearAfterReading) ) 

#define IRTC_GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)	\
    ( (This)->lpVtbl -> GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading) ) 

#define IRTC_InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)	\
    ( (This)->lpVtbl -> InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength) ) 

#define IRTC_QueryStations(This,lpQueryTable)	\
    ( (This)->lpVtbl -> QueryStations(This,lpQueryTable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IRTC_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netmon_0000_0002 */
/* [local] */ 

//****************************************************************************
//****************************************************************************
// IStats - used by a consumer to get just statistics, no frames.
//****************************************************************************
//****************************************************************************


extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0002_v0_0_s_ifspec;

#ifndef __IStats_INTERFACE_DEFINED__
#define __IStats_INTERFACE_DEFINED__

/* interface IStats */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IStats;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("944AD530-B09D-11ce-B59C-00AA006CB37D")
    IStats : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Disconnect( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStatus( 
            /* [out] */ NETWORKSTATUS *pNetworkStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetControlState( 
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTotalStatistics( 
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversationStatistics( 
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InsertSpecialFrame( 
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryStations( 
            /* [out][in] */ QUERYTABLE *lpQueryTable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStatsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IStats * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IStats * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IStats * This,
            /* [in] */ HBLOB hInputBlob,
            /* [in] */ LPVOID StatusCallbackProc,
            /* [in] */ LPVOID UserContext,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStatus )( 
            IStats * This,
            /* [out] */ NETWORKSTATUS *pNetworkStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Configure )( 
            IStats * This,
            /* [in] */ HBLOB hConfigurationBlob,
            /* [out] */ HBLOB hErrorBlob);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            IStats * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetControlState )( 
            IStats * This,
            /* [out] */ BOOL *IsRunnning,
            /* [out] */ BOOL *IsPaused);
        
        HRESULT ( STDMETHODCALLTYPE *GetTotalStatistics )( 
            IStats * This,
            /* [out] */ LPSTATISTICS lpStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversationStatistics )( 
            IStats * This,
            /* [out] */ DWORD *nSessions,
            /* [size_is][out] */ LPSESSIONSTATS lpSessionStats,
            /* [out] */ DWORD *nStations,
            /* [size_is][out] */ LPSTATIONSTATS lpStationStats,
            /* [in] */ BOOL fClearAfterReading);
        
        HRESULT ( STDMETHODCALLTYPE *InsertSpecialFrame )( 
            IStats * This,
            /* [in] */ DWORD FrameType,
            /* [in] */ DWORD Flags,
            /* [in] */ BYTE *pUserData,
            /* [in] */ DWORD UserDataLength);
        
        HRESULT ( STDMETHODCALLTYPE *QueryStations )( 
            IStats * This,
            /* [out][in] */ QUERYTABLE *lpQueryTable);
        
        END_INTERFACE
    } IStatsVtbl;

    interface IStats
    {
        CONST_VTBL struct IStatsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStats_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IStats_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IStats_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IStats_Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob)	\
    ( (This)->lpVtbl -> Connect(This,hInputBlob,StatusCallbackProc,UserContext,hErrorBlob) ) 

#define IStats_Disconnect(This)	\
    ( (This)->lpVtbl -> Disconnect(This) ) 

#define IStats_QueryStatus(This,pNetworkStatus)	\
    ( (This)->lpVtbl -> QueryStatus(This,pNetworkStatus) ) 

#define IStats_Configure(This,hConfigurationBlob,hErrorBlob)	\
    ( (This)->lpVtbl -> Configure(This,hConfigurationBlob,hErrorBlob) ) 

#define IStats_Start(This)	\
    ( (This)->lpVtbl -> Start(This) ) 

#define IStats_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IStats_Resume(This)	\
    ( (This)->lpVtbl -> Resume(This) ) 

#define IStats_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IStats_GetControlState(This,IsRunnning,IsPaused)	\
    ( (This)->lpVtbl -> GetControlState(This,IsRunnning,IsPaused) ) 

#define IStats_GetTotalStatistics(This,lpStats,fClearAfterReading)	\
    ( (This)->lpVtbl -> GetTotalStatistics(This,lpStats,fClearAfterReading) ) 

#define IStats_GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading)	\
    ( (This)->lpVtbl -> GetConversationStatistics(This,nSessions,lpSessionStats,nStations,lpStationStats,fClearAfterReading) ) 

#define IStats_InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength)	\
    ( (This)->lpVtbl -> InsertSpecialFrame(This,FrameType,Flags,pUserData,UserDataLength) ) 

#define IStats_QueryStations(This,lpQueryTable)	\
    ( (This)->lpVtbl -> QueryStations(This,lpQueryTable) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IStats_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netmon_0000_0003 */
/* [local] */ 

#pragma warning(default:4200)

#pragma pack()


extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netmon_0000_0003_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\netprov.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for netprov.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netprov_h__
#define __netprov_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IProvisioningDomain_FWD_DEFINED__
#define __IProvisioningDomain_FWD_DEFINED__
typedef interface IProvisioningDomain IProvisioningDomain;
#endif 	/* __IProvisioningDomain_FWD_DEFINED__ */


#ifndef __IProvisioningProfileWireless_FWD_DEFINED__
#define __IProvisioningProfileWireless_FWD_DEFINED__
typedef interface IProvisioningProfileWireless IProvisioningProfileWireless;
#endif 	/* __IProvisioningProfileWireless_FWD_DEFINED__ */


#ifndef __NetProvisioning_FWD_DEFINED__
#define __NetProvisioning_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetProvisioning NetProvisioning;
#else
typedef struct NetProvisioning NetProvisioning;
#endif /* __cplusplus */

#endif 	/* __NetProvisioning_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "prsht.h"
#include "msxml.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_netprov_0000_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation. All rights reserved.
//
//--------------------------------------------------------------------------
#if ( _MSC_VER >= 800 )
#pragma warning(disable:4201)
#endif




extern RPC_IF_HANDLE __MIDL_itf_netprov_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netprov_0000_0000_v0_0_s_ifspec;

#ifndef __IProvisioningDomain_INTERFACE_DEFINED__
#define __IProvisioningDomain_INTERFACE_DEFINED__

/* interface IProvisioningDomain */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProvisioningDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c96fbd50-24dd-11d8-89fb-00904b2ea9c6")
    IProvisioningDomain : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Add( 
            /* [string][in] */ __RPC__in LPCWSTR pszwPathToFolder) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Query( 
            /* [string][in] */ __RPC__in LPCWSTR pszwDomain,
            /* [string][in] */ __RPC__in LPCWSTR pszwLanguage,
            /* [string][in] */ __RPC__in LPCWSTR pszwXPathQuery,
            /* [out] */ __RPC__deref_out_opt IXMLDOMNodeList **Nodes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvisioningDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProvisioningDomain * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProvisioningDomain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProvisioningDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *Add )( 
            IProvisioningDomain * This,
            /* [string][in] */ __RPC__in LPCWSTR pszwPathToFolder);
        
        HRESULT ( STDMETHODCALLTYPE *Query )( 
            IProvisioningDomain * This,
            /* [string][in] */ __RPC__in LPCWSTR pszwDomain,
            /* [string][in] */ __RPC__in LPCWSTR pszwLanguage,
            /* [string][in] */ __RPC__in LPCWSTR pszwXPathQuery,
            /* [out] */ __RPC__deref_out_opt IXMLDOMNodeList **Nodes);
        
        END_INTERFACE
    } IProvisioningDomainVtbl;

    interface IProvisioningDomain
    {
        CONST_VTBL struct IProvisioningDomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvisioningDomain_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProvisioningDomain_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProvisioningDomain_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProvisioningDomain_Add(This,pszwPathToFolder)	\
    ( (This)->lpVtbl -> Add(This,pszwPathToFolder) ) 

#define IProvisioningDomain_Query(This,pszwDomain,pszwLanguage,pszwXPathQuery,Nodes)	\
    ( (This)->lpVtbl -> Query(This,pszwDomain,pszwLanguage,pszwXPathQuery,Nodes) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProvisioningDomain_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_netprov_0000_0001 */
/* [local] */ 

//
// WZC Wireless CreateProfile private error codes (returned in *pulStatus)
// WZC_PROFILE_SUCCESS is applicable only if the HRESULT returned is also
// S_OK
//
#define     WZC_PROFILE_SUCCESS                                         0
#define     WZC_PROFILE_XML_ERROR_NO_VERSION                            1
#define     WZC_PROFILE_XML_ERROR_BAD_VERSION                           2
#define     WZC_PROFILE_XML_ERROR_UNSUPPORTED_VERSION                   3
#define     WZC_PROFILE_XML_ERROR_SSID_NOT_FOUND                        4
#define     WZC_PROFILE_XML_ERROR_BAD_SSID                              5
#define     WZC_PROFILE_XML_ERROR_CONNECTION_TYPE                       6
#define     WZC_PROFILE_XML_ERROR_AUTHENTICATION                        7
#define     WZC_PROFILE_XML_ERROR_ENCRYPTION                            8
#define     WZC_PROFILE_XML_ERROR_KEY_PROVIDED_AUTOMATICALLY            9
#define     WZC_PROFILE_XML_ERROR_1X_ENABLED                            10
#define     WZC_PROFILE_XML_ERROR_EAP_METHOD                            11
#define     WZC_PROFILE_XML_ERROR_BAD_KEY_INDEX                         12
#define     WZC_PROFILE_XML_ERROR_KEY_INDEX_RANGE                       13
#define     WZC_PROFILE_XML_ERROR_BAD_NETWORK_KEY                       14
#define     WZC_PROFILE_CONFIG_ERROR_INVALID_AUTH_FOR_CONNECTION_TYPE   15
#define     WZC_PROFILE_CONFIG_ERROR_INVALID_ENCRYPTION_FOR_AUTHMODE    16
#define     WZC_PROFILE_CONFIG_ERROR_KEY_REQUIRED                       17
#define     WZC_PROFILE_CONFIG_ERROR_KEY_INDEX_REQUIRED                 18
#define     WZC_PROFILE_CONFIG_ERROR_KEY_INDEX_NOT_APPLICABLE           19
#define     WZC_PROFILE_CONFIG_ERROR_1X_NOT_ALLOWED                     20
#define     WZC_PROFILE_CONFIG_ERROR_1X_NOT_ALLOWED_KEY_REQUIRED        21
#define     WZC_PROFILE_CONFIG_ERROR_1X_NOT_ENABLED_KEY_PROVIDED        22
#define     WZC_PROFILE_CONFIG_ERROR_EAP_METHOD_REQUIRED                23
#define     WZC_PROFILE_CONFIG_ERROR_EAP_METHOD_NOT_APPLICABLE          24
#define     WZC_PROFILE_CONFIG_ERROR_WPA_NOT_SUPPORTED                  25
#define     WZC_PROFILE_CONFIG_ERROR_WPA_ENCRYPTION_NOT_SUPPORTED       26
#define     WZC_PROFILE_SET_ERROR_DUPLICATE_NETWORK                     27
#define     WZC_PROFILE_SET_ERROR_MEMORY_ALLOCATION                     28
#define     WZC_PROFILE_SET_ERROR_READING_1X_CONFIG                     29
#define     WZC_PROFILE_SET_ERROR_WRITING_1X_CONFIG                     30
#define     WZC_PROFILE_SET_ERROR_WRITING_WZC_CFG                       31
#define     WZC_PROFILE_API_ERROR_NOT_SUPPORTED                         32
#define     WZC_PROFILE_API_ERROR_FAILED_TO_LOAD_XML                    33
#define     WZC_PROFILE_API_ERROR_FAILED_TO_LOAD_SCHEMA                 34
#define     WZC_PROFILE_API_ERROR_XML_VALIDATION_FAILED                 35
#define     WZC_PROFILE_API_ERROR_INTERNAL                              36


extern RPC_IF_HANDLE __MIDL_itf_netprov_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_netprov_0000_0001_v0_0_s_ifspec;

#ifndef __IProvisioningProfileWireless_INTERFACE_DEFINED__
#define __IProvisioningProfileWireless_INTERFACE_DEFINED__

/* interface IProvisioningProfileWireless */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IProvisioningProfileWireless;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("c96fbd51-24dd-11d8-89fb-00904b2ea9c6")
    IProvisioningProfileWireless : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateProfile( 
            /* [in] */ __RPC__in BSTR bstrXMLWirelessConfigProfile,
            /* [in] */ __RPC__in BSTR bstrXMLConnectionConfigProfile,
            /* [in] */ __RPC__in GUID *pAdapterInstanceGuid,
            /* [out] */ __RPC__out ULONG *pulStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IProvisioningProfileWirelessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IProvisioningProfileWireless * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IProvisioningProfileWireless * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IProvisioningProfileWireless * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateProfile )( 
            IProvisioningProfileWireless * This,
            /* [in] */ __RPC__in BSTR bstrXMLWirelessConfigProfile,
            /* [in] */ __RPC__in BSTR bstrXMLConnectionConfigProfile,
            /* [in] */ __RPC__in GUID *pAdapterInstanceGuid,
            /* [out] */ __RPC__out ULONG *pulStatus);
        
        END_INTERFACE
    } IProvisioningProfileWirelessVtbl;

    interface IProvisioningProfileWireless
    {
        CONST_VTBL struct IProvisioningProfileWirelessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IProvisioningProfileWireless_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IProvisioningProfileWireless_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IProvisioningProfileWireless_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IProvisioningProfileWireless_CreateProfile(This,bstrXMLWirelessConfigProfile,bstrXMLConnectionConfigProfile,pAdapterInstanceGuid,pulStatus)	\
    ( (This)->lpVtbl -> CreateProfile(This,bstrXMLWirelessConfigProfile,bstrXMLConnectionConfigProfile,pAdapterInstanceGuid,pulStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IProvisioningProfileWireless_INTERFACE_DEFINED__ */



#ifndef __NETPROVLib_LIBRARY_DEFINED__
#define __NETPROVLib_LIBRARY_DEFINED__

/* library NETPROVLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_NETPROVLib;

EXTERN_C const CLSID CLSID_NetProvisioning;

#ifdef __cplusplus

class DECLSPEC_UUID("2aa2b5fe-b846-4d07-810c-b21ee45320e3")
NetProvisioning;
#endif
#endif /* __NETPROVLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\nldef.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    nldef.h

Abstract:

    This module contains basic network layer definitions.
    Previously some of these were duplicated in both routprot.h and
    iprtrmib.h.

Author:
Environment:

    user mode or kernel mode

--*/

#ifndef _NLDEF_
#define _NLDEF_
#pragma once

#define NL_MAX_METRIC_COMPONENT ((((ULONG) 1) << 31) - 1)

typedef enum {
    //
    // These values are from iptypes.h.
    // They need to fit in a 4 bit field.
    //
    IpPrefixOriginOther = 0,
    IpPrefixOriginManual,
    IpPrefixOriginWellKnown,
    IpPrefixOriginDhcp,
    IpPrefixOriginRouterAdvertisement,
    IpPrefixOriginUnchanged = 1 << 4
} NL_PREFIX_ORIGIN;

//
// TODO: Remove these definitions.
//
#define NlpoOther               IpPrefixOriginOther
#define NlpoManual              IpPrefixOriginManual
#define NlpoWellKnown           IpPrefixOriginWellKnown
#define NlpoDhcp                IpPrefixOriginDhcp
#define NlpoRouterAdvertisement IpPrefixOriginRouterAdvertisement

typedef enum {
    //
    // TODO: Remove the Nlso* definitions.
    //
    NlsoOther = 0,
    NlsoManual,
    NlsoWellKnown,
    NlsoDhcp,
    NlsoLinkLayerAddress,
    NlsoRandom,

    //
    // These values are from in iptypes.h.
    // They need to fit in a 4 bit field.
    //
    IpSuffixOriginOther = 0,
    IpSuffixOriginManual,
    IpSuffixOriginWellKnown,
    IpSuffixOriginDhcp,
    IpSuffixOriginLinkLayerAddress,
    IpSuffixOriginRandom,
    IpSuffixOriginUnchanged = 1 << 4
} NL_SUFFIX_ORIGIN;

typedef enum {
    //
    // TODO: Remove the Nlds* definitions.
    //
    NldsInvalid,
    NldsTentative,
    NldsDuplicate,
    NldsDeprecated,
    NldsPreferred,

    //
    // These values are from in iptypes.h.
    //
    IpDadStateInvalid    = 0,
    IpDadStateTentative,
    IpDadStateDuplicate,
    IpDadStateDeprecated,
    IpDadStatePreferred,
} NL_DAD_STATE;

//
// MIB_IPPROTO_* values were previously in iprtrmib.h.
// PROTO_IP_* values were previously in routprot.h.
//
#define MAKE_ROUTE_PROTOCOL(suffix, value) \
    MIB_IPPROTO_ ## suffix = value, \
    PROTO_IP_ ## suffix    = value

//
// Routing protocol values from RFC.
//
typedef enum {
    //
    // TODO: Remove the RouteProtocol* definitions.
    //
    RouteProtocolOther   = 1,
    RouteProtocolLocal   = 2,
    RouteProtocolNetMgmt = 3,
    RouteProtocolIcmp    = 4,
    RouteProtocolEgp     = 5,
    RouteProtocolGgp     = 6,
    RouteProtocolHello   = 7,
    RouteProtocolRip     = 8,
    RouteProtocolIsIs    = 9,
    RouteProtocolEsIs    = 10,
    RouteProtocolCisco   = 11,
    RouteProtocolBbn     = 12,
    RouteProtocolOspf    = 13,
    RouteProtocolBgp     = 14,

    MAKE_ROUTE_PROTOCOL(OTHER,   1),
    MAKE_ROUTE_PROTOCOL(LOCAL,   2),
    MAKE_ROUTE_PROTOCOL(NETMGMT, 3),
    MAKE_ROUTE_PROTOCOL(ICMP,    4),
    MAKE_ROUTE_PROTOCOL(EGP,     5),
    MAKE_ROUTE_PROTOCOL(GGP,     6),
    MAKE_ROUTE_PROTOCOL(HELLO,   7),
    MAKE_ROUTE_PROTOCOL(RIP,     8),
    MAKE_ROUTE_PROTOCOL(IS_IS,   9),
    MAKE_ROUTE_PROTOCOL(ES_IS,  10),
    MAKE_ROUTE_PROTOCOL(CISCO,  11),
    MAKE_ROUTE_PROTOCOL(BBN,    12),
    MAKE_ROUTE_PROTOCOL(OSPF,   13),
    MAKE_ROUTE_PROTOCOL(BGP,    14),

    //
    // Windows-specific definitions.
    //
    MAKE_ROUTE_PROTOCOL(NT_AUTOSTATIC,     10002),
    MAKE_ROUTE_PROTOCOL(NT_STATIC,         10006),
    MAKE_ROUTE_PROTOCOL(NT_STATIC_NON_DOD, 10007),

} NL_ROUTE_PROTOCOL, *PNL_ROUTE_PROTOCOL;

typedef enum {
    NlatUnspecified,
    NlatUnicast,
    NlatAnycast,
    NlatMulticast,
    NlatBroadcast,
    NlatInvalid
} NL_ADDRESS_TYPE, *PNL_ADDRESS_TYPE;

//
// NL_ROUTE_ORIGIN
//
// Define route origin values.
//

typedef enum _NL_ROUTE_ORIGIN {
    NlroManual,
    NlroWellKnown,
    NlroDHCP,
    NlroRouterAdvertisement,
    Nlro6to4,
} NL_ROUTE_ORIGIN, *PNL_ROUTE_ORIGIN;

//
// NL_NEIGHBOR_STATE
//
// Define network layer neighbor state.  RFC 2461, section 7.3.2 has details.
// Note: Only state names are documented, we chose the values used here.
//

typedef enum _NL_NEIGHBOR_STATE {
    NlnsUnreachable,
    NlnsIncomplete,
    NlnsProbe,
    NlnsDelay,
    NlnsStale,
    NlnsReachable,
    NlnsPermanent,
    NlnsMaximum,
} NL_NEIGHBOR_STATE, *PNL_NEIGHBOR_STATE;

typedef enum _NL_LINK_LOCAL_ADDRESS_BEHAVIOR{
    LinkLocalAlwaysOff = 0,     // Never use link locals.
    LinkLocalDelayed,           // Use link locals only if no other addresses. 
                                // (default for IPv4).
                                // Legacy mapping: IPAutoconfigurationEnabled.
    LinkLocalAlwaysOn,          // Always use link locals (default for IPv6). 
    LinkLocalUnchanged = -1
} NL_LINK_LOCAL_ADDRESS_BEHAVIOR;

#pragma warning(push)
#pragma warning(disable:4214)

typedef struct _NL_INTERFACE_OFFLOAD_ROD {
    BOOLEAN NlChecksumSupported : 1;
    BOOLEAN NlOptionsSupported : 1;
    BOOLEAN TlDatagramChecksumSupported : 1;
    BOOLEAN TlStreamChecksumSupported : 1;
    BOOLEAN TlStreamOptionsSupported : 1;
    BOOLEAN FastPathCompatible : 1;
    BOOLEAN TlLargeSendOffloadSupported : 1;
    BOOLEAN TlGiantSendOffloadSupported : 1;
} NL_INTERFACE_OFFLOAD_ROD, *PNL_INTERFACE_OFFLOAD_ROD;

#pragma warning(pop)

typedef enum _NL_ROUTER_DISCOVERY_BEHAVIOR {
    RouterDiscoveryDisabled = 0, 
    RouterDiscoveryEnabled, 
    RouterDiscoveryDhcp, 
    RouterDiscoveryUnchanged = -1
} NL_ROUTER_DISCOVERY_BEHAVIOR;

typedef enum _NL_BANDWIDTH_FLAG {
    NlbwDisabled = 0,
    NlbwEnabled,
    NlbwUnchanged = -1
} NL_BANDWIDTH_FLAG, *PNL_BANDWIDTH_FLAG;

typedef struct _NL_PATH_BANDWIDTH_ROD {
    ULONG64 Bandwidth;
    ULONG64 Instability;
    BOOLEAN BandwidthPeaked;
} NL_PATH_BANDWIDTH_ROD, *PNL_PATH_BANDWIDTH_ROD;

#define NET_IF_CURRENT_SESSION ((ULONG)-1)

#endif // _NLDEF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NetSh.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    netsh.h

Abstract:
    This file contains definitions which are needed by all NetSh helper DLLs.

--*/

#ifndef _NETSH_H_
#define _NETSH_H_

#if _MSC_VER > 1000
#pragma once
#endif

#pragma warning(push)
#pragma warning(disable:4201) // nameless struct/union

#ifdef __cplusplus
extern "C" {
#endif

//
// Error codes
//
#define NETSH_ERROR_BASE                        15000
#define ERROR_NO_ENTRIES                        (NETSH_ERROR_BASE + 0)
#define ERROR_INVALID_SYNTAX                    (NETSH_ERROR_BASE + 1)
#define ERROR_PROTOCOL_NOT_IN_TRANSPORT         (NETSH_ERROR_BASE + 2)
#define ERROR_NO_CHANGE                         (NETSH_ERROR_BASE + 3)
#define ERROR_CMD_NOT_FOUND                     (NETSH_ERROR_BASE + 4)
#define ERROR_ENTRY_PT_NOT_FOUND                (NETSH_ERROR_BASE + 5)
#define ERROR_DLL_LOAD_FAILED                   (NETSH_ERROR_BASE + 6)
#define ERROR_INIT_DISPLAY                      (NETSH_ERROR_BASE + 7)
#define ERROR_TAG_ALREADY_PRESENT               (NETSH_ERROR_BASE + 8)
#define ERROR_INVALID_OPTION_TAG                (NETSH_ERROR_BASE + 9)
#define ERROR_NO_TAG                            (NETSH_ERROR_BASE + 10)
#define ERROR_MISSING_OPTION                    (NETSH_ERROR_BASE + 11)
#define ERROR_TRANSPORT_NOT_PRESENT             (NETSH_ERROR_BASE + 12)
#define ERROR_SHOW_USAGE                        (NETSH_ERROR_BASE + 13)
#define ERROR_INVALID_OPTION_VALUE              (NETSH_ERROR_BASE + 14)
#define ERROR_OKAY                              (NETSH_ERROR_BASE + 15)
#define ERROR_CONTINUE_IN_PARENT_CONTEXT        (NETSH_ERROR_BASE + 16)
#define ERROR_SUPPRESS_OUTPUT                   (NETSH_ERROR_BASE + 17)
#define ERROR_HELPER_ALREADY_REGISTERED         (NETSH_ERROR_BASE + 18)
#define ERROR_CONTEXT_ALREADY_REGISTERED        (NETSH_ERROR_BASE + 19)
#define NETSH_ERROR_END                ERROR_CONTEXT_ALREADY_REGISTERED

// Flags
enum NS_CMD_FLAGS
{
    CMD_FLAG_PRIVATE     = 0x01, // not valid in sub-contexts
    CMD_FLAG_INTERACTIVE = 0x02, // not valid from outside netsh
    CMD_FLAG_LOCAL       = 0x08, // not valid from a remote machine
    CMD_FLAG_ONLINE      = 0x10, // not valid in offline/non-commit mode
    CMD_FLAG_HIDDEN      = 0x20, // hide from help but allow execution
    CMD_FLAG_LIMIT_MASK  = 0xffff,
    CMD_FLAG_PRIORITY    = 0x80000000 // ulPriority field is used*/
};

typedef enum _NS_REQS
{
    NS_REQ_ZERO           = 0,
    NS_REQ_PRESENT        = 1,
    NS_REQ_ALLOW_MULTIPLE = 2,
    NS_REQ_ONE_OR_MORE    = 3
} NS_REQS;

enum NS_EVENTS
{
    NS_EVENT_LOOP       = 0x00010000,
    NS_EVENT_LAST_N     = 0x00000001,
    NS_EVENT_LAST_SECS  = 0x00000002,
    NS_EVENT_FROM_N     = 0x00000004,
    NS_EVENT_FROM_START = 0x00000008
};

enum NS_MODE_CHANGE
{
    NETSH_COMMIT                   = 0,
    NETSH_UNCOMMIT                 = 1,
    NETSH_FLUSH                    = 2,
    NETSH_COMMIT_STATE             = 3,
    NETSH_SAVE                     = 4
};


#define NS_GET_EVENT_IDS_FN_NAME    "GetEventIds"

#define MAX_NAME_LEN                    MAX_DLL_NAME

#define NETSH_VERSION_50                0x0005000

#define NETSH_ARG_DELIMITER             L"="
#define NETSH_CMD_DELIMITER             L" "

#define NETSH_MAX_TOKEN_LENGTH          64
#define NETSH_MAX_CMD_TOKEN_LENGTH      128

#define NETSH_ROOT_GUID { 0, 0, 0, { 0, 0, 0, 0, 0, 0, 0, 0 } }

#define DEFAULT_CONTEXT_PRIORITY 100

typedef struct _TOKEN_VALUE
{
    LPCWSTR  pwszToken; // literal token string
    DWORD    dwValue;   // ID of info string
} TOKEN_VALUE, *PTOKEN_VALUE;

// Macros
#define CREATE_CMD_ENTRY(t,f)            {CMD_##t, f, HLP_##t, HLP_##t##_EX, CMD_FLAG_PRIVATE, NULL}
#define CREATE_CMD_ENTRY_EX(t,f,i)       {CMD_##t, f, HLP_##t, HLP_##t##_EX, i, NULL}
#define CREATE_CMD_ENTRY_EX_VER(t,f,i,v) {CMD_##t, f, HLP_##t, HLP_##t##_EX, i, v}

#define CREATE_CMD_GROUP_ENTRY(t,s)            {CMD_##t, HLP_##t, sizeof(s)/sizeof(CMD_ENTRY), 0, s, NULL }
#define CREATE_CMD_GROUP_ENTRY_EX(t,s,i)       {CMD_##t, HLP_##t, sizeof(s)/sizeof(CMD_ENTRY), i, s, NULL }
#define CREATE_CMD_GROUP_ENTRY_EX_VER(t,s,i,v) {CMD_##t, HLP_##t, sizeof(s)/sizeof(CMD_ENTRY), i, s, v }

#define NUM_TOKENS_IN_TABLE(TokenArray) sizeof(TokenArray)/sizeof(TOKEN_VALUE)
#define NUM_TAGS_IN_TABLE(TagsArray)    sizeof(TagsArray)/sizeof(TAG_TYPE)

#define GET_RESOURCE_STRING_FN_NAME    "GetResourceString"

// Callbacks

typedef
DWORD
(WINAPI GET_RESOURCE_STRING_FN)(
    IN  DWORD   dwMsgID,         // resource identifier
    OUT LPWSTR  lpBuffer,        // resource buffer
    IN  DWORD   nBufferMax       // size of buffer in characters
    );

typedef GET_RESOURCE_STRING_FN *PGET_RESOURCE_STRING_FN;

typedef
DWORD
(WINAPI NS_CONTEXT_COMMIT_FN)(
    IN  DWORD       dwAction
    );

typedef NS_CONTEXT_COMMIT_FN *PNS_CONTEXT_COMMIT_FN;

typedef
DWORD
(WINAPI NS_CONTEXT_CONNECT_FN)(
    IN  LPCWSTR      pwszMachine
    );

typedef NS_CONTEXT_CONNECT_FN *PNS_CONTEXT_CONNECT_FN;

typedef struct _NS_CONTEXT_ATTRIBUTES NS_CONTEXT_ATTRIBUTES;

typedef
DWORD
(WINAPI NS_CONTEXT_DUMP_FN)(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    );

typedef NS_CONTEXT_DUMP_FN *PNS_CONTEXT_DUMP_FN;

typedef
DWORD
(WINAPI NS_DLL_STOP_FN)(
    IN  DWORD       dwReserved
    );

typedef NS_DLL_STOP_FN *PNS_DLL_STOP_FN;

typedef
DWORD
(WINAPI NS_HELPER_START_FN)(
    IN  CONST GUID *pguidParent,
    IN  DWORD       dwVersion
    );

typedef NS_HELPER_START_FN *PNS_HELPER_START_FN;

typedef
DWORD
(WINAPI NS_HELPER_STOP_FN)(
    IN  DWORD       dwReserved
    );

typedef NS_HELPER_STOP_FN *PNS_HELPER_STOP_FN;

typedef DWORD (FN_HANDLE_CMD)(
    IN      LPCWSTR   pwszMachine,
    __inout_ecount(dwArgCount) LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    );

typedef FN_HANDLE_CMD *PFN_HANDLE_CMD;

typedef
BOOL
(WINAPI NS_OSVERSIONCHECK)(
    __in  UINT     CIMOSType,                   // WMI: Win32_OperatingSystem  OSType
    __in  UINT     CIMOSProductSuite,           // WMI: Win32_OperatingSystem  OSProductSuite
    __in  LPCWSTR  CIMOSVersion,                // WMI: Win32_OperatingSystem  Version
    __in  LPCWSTR  CIMOSBuildNumber,            // WMI: Win32_OperatingSystem  BuildNumber
    __in  LPCWSTR  CIMServicePackMajorVersion,  // WMI: Win32_OperatingSystem  ServicePackMajorVersion
    __in  LPCWSTR  CIMServicePackMinorVersion,  // WMI: Win32_OperatingSystem  ServicePackMinorVersion
    __in  UINT     uiReserved,
    __in  DWORD    dwReserved
    );

typedef NS_OSVERSIONCHECK *PNS_OSVERSIONCHECK;

// Structures
typedef struct _NS_HELPER_ATTRIBUTES
{
    union
    {
        struct
        {
            DWORD       dwVersion;
            DWORD       dwReserved;
        };
        ULONGLONG       _ullAlign;
    };
    GUID                      guidHelper;           // GUID associated with the helper
    PNS_HELPER_START_FN       pfnStart;             // Function to start this helper
    PNS_HELPER_STOP_FN        pfnStop;              // Function to stop this helper
} NS_HELPER_ATTRIBUTES, *PNS_HELPER_ATTRIBUTES;

typedef struct _CMD_ENTRY
{
    LPCWSTR             pwszCmdToken;        // The token for the command
    PFN_HANDLE_CMD      pfnCmdHandler;       // The function which handles this command
    DWORD               dwShortCmdHelpToken; // The short help message
    DWORD               dwCmdHlpToken;       // The message to display if the only thing after the command is a help token (HELP, /?, -?, ?)
    DWORD               dwFlags;             // Flags (see CMD_FLAGS_xxx above)
    PNS_OSVERSIONCHECK  pOsVersionCheck;     // Check for the version of the OS this command can run against
} CMD_ENTRY, *PCMD_ENTRY;

typedef struct _CMD_GROUP_ENTRY
{
    LPCWSTR         pwszCmdGroupToken;      // The token for the command verb
    DWORD           dwShortCmdHelpToken;    // The message to display in a command listing.
    ULONG           ulCmdGroupSize;         // The number of entries in the cmd table
    DWORD           dwFlags;                // Flags (see CMD_FLAG_xxx)
    PCMD_ENTRY      pCmdGroup;              // The command table
    PNS_OSVERSIONCHECK  pOsVersionCheck;    // Check for the version of the OS this command can run against
} CMD_GROUP_ENTRY, *PCMD_GROUP_ENTRY;

typedef struct _NS_CONTEXT_ATTRIBUTES
{
    union
    {
        struct
        {
            DWORD       dwVersion;
            DWORD       dwReserved;
        };
        ULONGLONG       _ullAlign;
    };

    LPWSTR                   pwszContext;          // Name of the context
    GUID                     guidHelper;           // GUID of the helper servicing this context
    DWORD                    dwFlags;              // Flags limiting when context is available. (See CMD_FLAG_xxx)
    ULONG                    ulPriority;           // Priority field is only relevant if CMD_FLAG_PRIORITY is set in dwFlags
    ULONG                    ulNumTopCmds;         // Number of top-level commands
    struct _CMD_ENTRY        (*pTopCmds)[];        // Array of top-level commands
    ULONG                    ulNumGroups;          // Number of command groups
    struct _CMD_GROUP_ENTRY  (*pCmdGroups)[];      // Array of command groups

    PNS_CONTEXT_COMMIT_FN    pfnCommitFn;
    PNS_CONTEXT_DUMP_FN      pfnDumpFn;
    PNS_CONTEXT_CONNECT_FN   pfnConnectFn;
    PVOID                    pReserved;
    PNS_OSVERSIONCHECK       pfnOsVersionCheck;

} NS_CONTEXT_ATTRIBUTES, *PNS_CONTEXT_ATTRIBUTES;

typedef CONST struct _NS_CONTEXT_ATTRIBUTES * PCNS_CONTEXT_ATTRIBUTES;

typedef struct _TAG_TYPE
{
    LPCWSTR  pwszTag;     // tag string
    DWORD    dwRequired;  // required or not
    BOOL     bPresent;    // present or not
} TAG_TYPE, *PTAG_TYPE;

typedef
DWORD
(NS_DLL_INIT_FN)(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    );

typedef NS_DLL_INIT_FN *PNS_DLL_INIT_FN;

DWORD WINAPI MatchEnumTag(
    IN  HANDLE             hModule,
    IN  LPCWSTR            pwcArg,
    IN  DWORD              dwNumArg,
    IN  CONST TOKEN_VALUE *pEnumTable,
    OUT PDWORD             pdwValue
    );

BOOL WINAPI MatchToken(
    IN  LPCWSTR  pwszUserToken,
    IN  LPCWSTR  pwszCmdToken
    );

DWORD WINAPI PreprocessCommand(
    __in_opt                   HANDLE    hModule,
    __inout_ecount(dwArgCount) LPWSTR   *ppwcArguments,
    __in                       DWORD     dwCurrentIndex,
    __in                       DWORD     dwArgCount,
    __inout_opt                TAG_TYPE *pttTags,
    __in                       DWORD     dwTagCount,
    __in                       DWORD     dwMinArgs,
    __in                       DWORD     dwMaxArgs,
    __out_opt                  DWORD    *pdwTagType
    );

DWORD PrintError(
    IN  HANDLE  hModule, OPTIONAL
    IN  DWORD   dwErrId,
    ...
    );

DWORD PrintMessageFromModule(
    IN  HANDLE  hModule,
    IN  DWORD   dwMsgId,
    ...
    );

DWORD PrintMessage(
    IN  LPCWSTR  pwszFormat,
    ...
    );

DWORD WINAPI RegisterContext(
    IN    CONST NS_CONTEXT_ATTRIBUTES *pChildContext
    );

DWORD WINAPI RegisterHelper(
    IN    CONST GUID                 *pguidParentContext,
    IN    CONST NS_HELPER_ATTRIBUTES *pfnRegisterSubContext
    );

#ifdef __cplusplus
}
#endif

#pragma warning(pop)

#endif // _NETSH_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\netfw.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for netfw.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __netfw_h__
#define __netfw_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __INetFwRemoteAdminSettings_FWD_DEFINED__
#define __INetFwRemoteAdminSettings_FWD_DEFINED__
typedef interface INetFwRemoteAdminSettings INetFwRemoteAdminSettings;
#endif 	/* __INetFwRemoteAdminSettings_FWD_DEFINED__ */


#ifndef __INetFwIcmpSettings_FWD_DEFINED__
#define __INetFwIcmpSettings_FWD_DEFINED__
typedef interface INetFwIcmpSettings INetFwIcmpSettings;
#endif 	/* __INetFwIcmpSettings_FWD_DEFINED__ */


#ifndef __INetFwOpenPort_FWD_DEFINED__
#define __INetFwOpenPort_FWD_DEFINED__
typedef interface INetFwOpenPort INetFwOpenPort;
#endif 	/* __INetFwOpenPort_FWD_DEFINED__ */


#ifndef __INetFwOpenPorts_FWD_DEFINED__
#define __INetFwOpenPorts_FWD_DEFINED__
typedef interface INetFwOpenPorts INetFwOpenPorts;
#endif 	/* __INetFwOpenPorts_FWD_DEFINED__ */


#ifndef __INetFwService_FWD_DEFINED__
#define __INetFwService_FWD_DEFINED__
typedef interface INetFwService INetFwService;
#endif 	/* __INetFwService_FWD_DEFINED__ */


#ifndef __INetFwServices_FWD_DEFINED__
#define __INetFwServices_FWD_DEFINED__
typedef interface INetFwServices INetFwServices;
#endif 	/* __INetFwServices_FWD_DEFINED__ */


#ifndef __INetFwAuthorizedApplication_FWD_DEFINED__
#define __INetFwAuthorizedApplication_FWD_DEFINED__
typedef interface INetFwAuthorizedApplication INetFwAuthorizedApplication;
#endif 	/* __INetFwAuthorizedApplication_FWD_DEFINED__ */


#ifndef __INetFwAuthorizedApplications_FWD_DEFINED__
#define __INetFwAuthorizedApplications_FWD_DEFINED__
typedef interface INetFwAuthorizedApplications INetFwAuthorizedApplications;
#endif 	/* __INetFwAuthorizedApplications_FWD_DEFINED__ */


#ifndef __INetFwRule_FWD_DEFINED__
#define __INetFwRule_FWD_DEFINED__
typedef interface INetFwRule INetFwRule;
#endif 	/* __INetFwRule_FWD_DEFINED__ */


#ifndef __INetFwRules_FWD_DEFINED__
#define __INetFwRules_FWD_DEFINED__
typedef interface INetFwRules INetFwRules;
#endif 	/* __INetFwRules_FWD_DEFINED__ */


#ifndef __INetFwServiceRestriction_FWD_DEFINED__
#define __INetFwServiceRestriction_FWD_DEFINED__
typedef interface INetFwServiceRestriction INetFwServiceRestriction;
#endif 	/* __INetFwServiceRestriction_FWD_DEFINED__ */


#ifndef __INetFwProfile_FWD_DEFINED__
#define __INetFwProfile_FWD_DEFINED__
typedef interface INetFwProfile INetFwProfile;
#endif 	/* __INetFwProfile_FWD_DEFINED__ */


#ifndef __INetFwPolicy_FWD_DEFINED__
#define __INetFwPolicy_FWD_DEFINED__
typedef interface INetFwPolicy INetFwPolicy;
#endif 	/* __INetFwPolicy_FWD_DEFINED__ */


#ifndef __INetFwPolicy2_FWD_DEFINED__
#define __INetFwPolicy2_FWD_DEFINED__
typedef interface INetFwPolicy2 INetFwPolicy2;
#endif 	/* __INetFwPolicy2_FWD_DEFINED__ */


#ifndef __INetFwMgr_FWD_DEFINED__
#define __INetFwMgr_FWD_DEFINED__
typedef interface INetFwMgr INetFwMgr;
#endif 	/* __INetFwMgr_FWD_DEFINED__ */


#ifndef __INetFwRemoteAdminSettings_FWD_DEFINED__
#define __INetFwRemoteAdminSettings_FWD_DEFINED__
typedef interface INetFwRemoteAdminSettings INetFwRemoteAdminSettings;
#endif 	/* __INetFwRemoteAdminSettings_FWD_DEFINED__ */


#ifndef __INetFwIcmpSettings_FWD_DEFINED__
#define __INetFwIcmpSettings_FWD_DEFINED__
typedef interface INetFwIcmpSettings INetFwIcmpSettings;
#endif 	/* __INetFwIcmpSettings_FWD_DEFINED__ */


#ifndef __INetFwOpenPort_FWD_DEFINED__
#define __INetFwOpenPort_FWD_DEFINED__
typedef interface INetFwOpenPort INetFwOpenPort;
#endif 	/* __INetFwOpenPort_FWD_DEFINED__ */


#ifndef __INetFwOpenPorts_FWD_DEFINED__
#define __INetFwOpenPorts_FWD_DEFINED__
typedef interface INetFwOpenPorts INetFwOpenPorts;
#endif 	/* __INetFwOpenPorts_FWD_DEFINED__ */


#ifndef __INetFwService_FWD_DEFINED__
#define __INetFwService_FWD_DEFINED__
typedef interface INetFwService INetFwService;
#endif 	/* __INetFwService_FWD_DEFINED__ */


#ifndef __INetFwServices_FWD_DEFINED__
#define __INetFwServices_FWD_DEFINED__
typedef interface INetFwServices INetFwServices;
#endif 	/* __INetFwServices_FWD_DEFINED__ */


#ifndef __INetFwAuthorizedApplication_FWD_DEFINED__
#define __INetFwAuthorizedApplication_FWD_DEFINED__
typedef interface INetFwAuthorizedApplication INetFwAuthorizedApplication;
#endif 	/* __INetFwAuthorizedApplication_FWD_DEFINED__ */


#ifndef __INetFwAuthorizedApplications_FWD_DEFINED__
#define __INetFwAuthorizedApplications_FWD_DEFINED__
typedef interface INetFwAuthorizedApplications INetFwAuthorizedApplications;
#endif 	/* __INetFwAuthorizedApplications_FWD_DEFINED__ */


#ifndef __INetFwServiceRestriction_FWD_DEFINED__
#define __INetFwServiceRestriction_FWD_DEFINED__
typedef interface INetFwServiceRestriction INetFwServiceRestriction;
#endif 	/* __INetFwServiceRestriction_FWD_DEFINED__ */


#ifndef __INetFwRule_FWD_DEFINED__
#define __INetFwRule_FWD_DEFINED__
typedef interface INetFwRule INetFwRule;
#endif 	/* __INetFwRule_FWD_DEFINED__ */


#ifndef __INetFwRules_FWD_DEFINED__
#define __INetFwRules_FWD_DEFINED__
typedef interface INetFwRules INetFwRules;
#endif 	/* __INetFwRules_FWD_DEFINED__ */


#ifndef __INetFwProfile_FWD_DEFINED__
#define __INetFwProfile_FWD_DEFINED__
typedef interface INetFwProfile INetFwProfile;
#endif 	/* __INetFwProfile_FWD_DEFINED__ */


#ifndef __INetFwPolicy_FWD_DEFINED__
#define __INetFwPolicy_FWD_DEFINED__
typedef interface INetFwPolicy INetFwPolicy;
#endif 	/* __INetFwPolicy_FWD_DEFINED__ */


#ifndef __INetFwPolicy2_FWD_DEFINED__
#define __INetFwPolicy2_FWD_DEFINED__
typedef interface INetFwPolicy2 INetFwPolicy2;
#endif 	/* __INetFwPolicy2_FWD_DEFINED__ */


#ifndef __INetFwMgr_FWD_DEFINED__
#define __INetFwMgr_FWD_DEFINED__
typedef interface INetFwMgr INetFwMgr;
#endif 	/* __INetFwMgr_FWD_DEFINED__ */


#ifndef __NetFwRule_FWD_DEFINED__
#define __NetFwRule_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetFwRule NetFwRule;
#else
typedef struct NetFwRule NetFwRule;
#endif /* __cplusplus */

#endif 	/* __NetFwRule_FWD_DEFINED__ */


#ifndef __NetFwOpenPort_FWD_DEFINED__
#define __NetFwOpenPort_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetFwOpenPort NetFwOpenPort;
#else
typedef struct NetFwOpenPort NetFwOpenPort;
#endif /* __cplusplus */

#endif 	/* __NetFwOpenPort_FWD_DEFINED__ */


#ifndef __NetFwAuthorizedApplication_FWD_DEFINED__
#define __NetFwAuthorizedApplication_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetFwAuthorizedApplication NetFwAuthorizedApplication;
#else
typedef struct NetFwAuthorizedApplication NetFwAuthorizedApplication;
#endif /* __cplusplus */

#endif 	/* __NetFwAuthorizedApplication_FWD_DEFINED__ */


#ifndef __NetFwPolicy2_FWD_DEFINED__
#define __NetFwPolicy2_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetFwPolicy2 NetFwPolicy2;
#else
typedef struct NetFwPolicy2 NetFwPolicy2;
#endif /* __cplusplus */

#endif 	/* __NetFwPolicy2_FWD_DEFINED__ */


#ifndef __NetFwMgr_FWD_DEFINED__
#define __NetFwMgr_FWD_DEFINED__

#ifdef __cplusplus
typedef class NetFwMgr NetFwMgr;
#else
typedef struct NetFwMgr NetFwMgr;
#endif /* __cplusplus */

#endif 	/* __NetFwMgr_FWD_DEFINED__ */


/* header files for imported files */
#include "icftypes.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __INetFwRemoteAdminSettings_INTERFACE_DEFINED__
#define __INetFwRemoteAdminSettings_INTERFACE_DEFINED__

/* interface INetFwRemoteAdminSettings */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwRemoteAdminSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D4BECDDF-6F73-4A83-B832-9C66874CD20E")
    INetFwRemoteAdminSettings : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IpVersion( 
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_IpVersion( 
            /* [in] */ NET_FW_IP_VERSION ipVersion) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Scope( 
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Scope( 
            /* [in] */ NET_FW_SCOPE scope) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemoteAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RemoteAddresses( 
            /* [in] */ __RPC__in BSTR remoteAddrs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwRemoteAdminSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwRemoteAdminSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwRemoteAdminSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwRemoteAdminSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwRemoteAdminSettings * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwRemoteAdminSettings * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwRemoteAdminSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwRemoteAdminSettings * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IpVersion )( 
            INetFwRemoteAdminSettings * This,
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IpVersion )( 
            INetFwRemoteAdminSettings * This,
            /* [in] */ NET_FW_IP_VERSION ipVersion);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Scope )( 
            INetFwRemoteAdminSettings * This,
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Scope )( 
            INetFwRemoteAdminSettings * This,
            /* [in] */ NET_FW_SCOPE scope);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAddresses )( 
            INetFwRemoteAdminSettings * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemoteAddresses )( 
            INetFwRemoteAdminSettings * This,
            /* [in] */ __RPC__in BSTR remoteAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            INetFwRemoteAdminSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            INetFwRemoteAdminSettings * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        END_INTERFACE
    } INetFwRemoteAdminSettingsVtbl;

    interface INetFwRemoteAdminSettings
    {
        CONST_VTBL struct INetFwRemoteAdminSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwRemoteAdminSettings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwRemoteAdminSettings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwRemoteAdminSettings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwRemoteAdminSettings_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwRemoteAdminSettings_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwRemoteAdminSettings_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwRemoteAdminSettings_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwRemoteAdminSettings_get_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> get_IpVersion(This,ipVersion) ) 

#define INetFwRemoteAdminSettings_put_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> put_IpVersion(This,ipVersion) ) 

#define INetFwRemoteAdminSettings_get_Scope(This,scope)	\
    ( (This)->lpVtbl -> get_Scope(This,scope) ) 

#define INetFwRemoteAdminSettings_put_Scope(This,scope)	\
    ( (This)->lpVtbl -> put_Scope(This,scope) ) 

#define INetFwRemoteAdminSettings_get_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> get_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwRemoteAdminSettings_put_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> put_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwRemoteAdminSettings_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define INetFwRemoteAdminSettings_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwRemoteAdminSettings_INTERFACE_DEFINED__ */


#ifndef __INetFwIcmpSettings_INTERFACE_DEFINED__
#define __INetFwIcmpSettings_INTERFACE_DEFINED__

/* interface INetFwIcmpSettings */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwIcmpSettings;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A6207B2E-7CDD-426A-951E-5E1CBC5AFEAD")
    INetFwIcmpSettings : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowOutboundDestinationUnreachable( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowOutboundDestinationUnreachable( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowRedirect( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowRedirect( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowInboundEchoRequest( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowInboundEchoRequest( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowOutboundTimeExceeded( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowOutboundTimeExceeded( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowOutboundParameterProblem( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowOutboundParameterProblem( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowOutboundSourceQuench( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowOutboundSourceQuench( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowInboundRouterRequest( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowInboundRouterRequest( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowInboundTimestampRequest( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowInboundTimestampRequest( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowInboundMaskRequest( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowInboundMaskRequest( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowOutboundPacketTooBig( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowOutboundPacketTooBig( 
            /* [in] */ VARIANT_BOOL allow) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwIcmpSettingsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwIcmpSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwIcmpSettings * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwIcmpSettings * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwIcmpSettings * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwIcmpSettings * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwIcmpSettings * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwIcmpSettings * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowOutboundDestinationUnreachable )( 
            INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowOutboundDestinationUnreachable )( 
            INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowRedirect )( 
            INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowRedirect )( 
            INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowInboundEchoRequest )( 
            INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowInboundEchoRequest )( 
            INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowOutboundTimeExceeded )( 
            INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowOutboundTimeExceeded )( 
            INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowOutboundParameterProblem )( 
            INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowOutboundParameterProblem )( 
            INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowOutboundSourceQuench )( 
            INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowOutboundSourceQuench )( 
            INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowInboundRouterRequest )( 
            INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowInboundRouterRequest )( 
            INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowInboundTimestampRequest )( 
            INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowInboundTimestampRequest )( 
            INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowInboundMaskRequest )( 
            INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowInboundMaskRequest )( 
            INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AllowOutboundPacketTooBig )( 
            INetFwIcmpSettings * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *allow);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_AllowOutboundPacketTooBig )( 
            INetFwIcmpSettings * This,
            /* [in] */ VARIANT_BOOL allow);
        
        END_INTERFACE
    } INetFwIcmpSettingsVtbl;

    interface INetFwIcmpSettings
    {
        CONST_VTBL struct INetFwIcmpSettingsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwIcmpSettings_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwIcmpSettings_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwIcmpSettings_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwIcmpSettings_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwIcmpSettings_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwIcmpSettings_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwIcmpSettings_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwIcmpSettings_get_AllowOutboundDestinationUnreachable(This,allow)	\
    ( (This)->lpVtbl -> get_AllowOutboundDestinationUnreachable(This,allow) ) 

#define INetFwIcmpSettings_put_AllowOutboundDestinationUnreachable(This,allow)	\
    ( (This)->lpVtbl -> put_AllowOutboundDestinationUnreachable(This,allow) ) 

#define INetFwIcmpSettings_get_AllowRedirect(This,allow)	\
    ( (This)->lpVtbl -> get_AllowRedirect(This,allow) ) 

#define INetFwIcmpSettings_put_AllowRedirect(This,allow)	\
    ( (This)->lpVtbl -> put_AllowRedirect(This,allow) ) 

#define INetFwIcmpSettings_get_AllowInboundEchoRequest(This,allow)	\
    ( (This)->lpVtbl -> get_AllowInboundEchoRequest(This,allow) ) 

#define INetFwIcmpSettings_put_AllowInboundEchoRequest(This,allow)	\
    ( (This)->lpVtbl -> put_AllowInboundEchoRequest(This,allow) ) 

#define INetFwIcmpSettings_get_AllowOutboundTimeExceeded(This,allow)	\
    ( (This)->lpVtbl -> get_AllowOutboundTimeExceeded(This,allow) ) 

#define INetFwIcmpSettings_put_AllowOutboundTimeExceeded(This,allow)	\
    ( (This)->lpVtbl -> put_AllowOutboundTimeExceeded(This,allow) ) 

#define INetFwIcmpSettings_get_AllowOutboundParameterProblem(This,allow)	\
    ( (This)->lpVtbl -> get_AllowOutboundParameterProblem(This,allow) ) 

#define INetFwIcmpSettings_put_AllowOutboundParameterProblem(This,allow)	\
    ( (This)->lpVtbl -> put_AllowOutboundParameterProblem(This,allow) ) 

#define INetFwIcmpSettings_get_AllowOutboundSourceQuench(This,allow)	\
    ( (This)->lpVtbl -> get_AllowOutboundSourceQuench(This,allow) ) 

#define INetFwIcmpSettings_put_AllowOutboundSourceQuench(This,allow)	\
    ( (This)->lpVtbl -> put_AllowOutboundSourceQuench(This,allow) ) 

#define INetFwIcmpSettings_get_AllowInboundRouterRequest(This,allow)	\
    ( (This)->lpVtbl -> get_AllowInboundRouterRequest(This,allow) ) 

#define INetFwIcmpSettings_put_AllowInboundRouterRequest(This,allow)	\
    ( (This)->lpVtbl -> put_AllowInboundRouterRequest(This,allow) ) 

#define INetFwIcmpSettings_get_AllowInboundTimestampRequest(This,allow)	\
    ( (This)->lpVtbl -> get_AllowInboundTimestampRequest(This,allow) ) 

#define INetFwIcmpSettings_put_AllowInboundTimestampRequest(This,allow)	\
    ( (This)->lpVtbl -> put_AllowInboundTimestampRequest(This,allow) ) 

#define INetFwIcmpSettings_get_AllowInboundMaskRequest(This,allow)	\
    ( (This)->lpVtbl -> get_AllowInboundMaskRequest(This,allow) ) 

#define INetFwIcmpSettings_put_AllowInboundMaskRequest(This,allow)	\
    ( (This)->lpVtbl -> put_AllowInboundMaskRequest(This,allow) ) 

#define INetFwIcmpSettings_get_AllowOutboundPacketTooBig(This,allow)	\
    ( (This)->lpVtbl -> get_AllowOutboundPacketTooBig(This,allow) ) 

#define INetFwIcmpSettings_put_AllowOutboundPacketTooBig(This,allow)	\
    ( (This)->lpVtbl -> put_AllowOutboundPacketTooBig(This,allow) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwIcmpSettings_INTERFACE_DEFINED__ */


#ifndef __INetFwOpenPort_INTERFACE_DEFINED__
#define __INetFwOpenPort_INTERFACE_DEFINED__

/* interface INetFwOpenPort */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwOpenPort;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E0483BA0-47FF-4D9C-A6D6-7741D0B195F7")
    INetFwOpenPort : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IpVersion( 
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_IpVersion( 
            /* [in] */ NET_FW_IP_VERSION ipVersion) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ __RPC__out NET_FW_IP_PROTOCOL *ipProtocol) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Protocol( 
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Port( 
            /* [retval][out] */ __RPC__out LONG *portNumber) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Port( 
            /* [in] */ LONG portNumber) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Scope( 
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Scope( 
            /* [in] */ NET_FW_SCOPE scope) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemoteAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RemoteAddresses( 
            /* [in] */ __RPC__in BSTR remoteAddrs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BuiltIn( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *builtIn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwOpenPortVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwOpenPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwOpenPort * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwOpenPort * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwOpenPort * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwOpenPort * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwOpenPort * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwOpenPort * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            INetFwOpenPort * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            INetFwOpenPort * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IpVersion )( 
            INetFwOpenPort * This,
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IpVersion )( 
            INetFwOpenPort * This,
            /* [in] */ NET_FW_IP_VERSION ipVersion);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            INetFwOpenPort * This,
            /* [retval][out] */ __RPC__out NET_FW_IP_PROTOCOL *ipProtocol);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Protocol )( 
            INetFwOpenPort * This,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Port )( 
            INetFwOpenPort * This,
            /* [retval][out] */ __RPC__out LONG *portNumber);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Port )( 
            INetFwOpenPort * This,
            /* [in] */ LONG portNumber);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Scope )( 
            INetFwOpenPort * This,
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Scope )( 
            INetFwOpenPort * This,
            /* [in] */ NET_FW_SCOPE scope);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAddresses )( 
            INetFwOpenPort * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemoteAddresses )( 
            INetFwOpenPort * This,
            /* [in] */ __RPC__in BSTR remoteAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            INetFwOpenPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            INetFwOpenPort * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BuiltIn )( 
            INetFwOpenPort * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *builtIn);
        
        END_INTERFACE
    } INetFwOpenPortVtbl;

    interface INetFwOpenPort
    {
        CONST_VTBL struct INetFwOpenPortVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwOpenPort_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwOpenPort_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwOpenPort_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwOpenPort_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwOpenPort_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwOpenPort_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwOpenPort_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwOpenPort_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define INetFwOpenPort_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define INetFwOpenPort_get_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> get_IpVersion(This,ipVersion) ) 

#define INetFwOpenPort_put_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> put_IpVersion(This,ipVersion) ) 

#define INetFwOpenPort_get_Protocol(This,ipProtocol)	\
    ( (This)->lpVtbl -> get_Protocol(This,ipProtocol) ) 

#define INetFwOpenPort_put_Protocol(This,ipProtocol)	\
    ( (This)->lpVtbl -> put_Protocol(This,ipProtocol) ) 

#define INetFwOpenPort_get_Port(This,portNumber)	\
    ( (This)->lpVtbl -> get_Port(This,portNumber) ) 

#define INetFwOpenPort_put_Port(This,portNumber)	\
    ( (This)->lpVtbl -> put_Port(This,portNumber) ) 

#define INetFwOpenPort_get_Scope(This,scope)	\
    ( (This)->lpVtbl -> get_Scope(This,scope) ) 

#define INetFwOpenPort_put_Scope(This,scope)	\
    ( (This)->lpVtbl -> put_Scope(This,scope) ) 

#define INetFwOpenPort_get_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> get_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwOpenPort_put_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> put_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwOpenPort_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define INetFwOpenPort_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#define INetFwOpenPort_get_BuiltIn(This,builtIn)	\
    ( (This)->lpVtbl -> get_BuiltIn(This,builtIn) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwOpenPort_INTERFACE_DEFINED__ */


#ifndef __INetFwOpenPorts_INTERFACE_DEFINED__
#define __INetFwOpenPorts_INTERFACE_DEFINED__

/* interface INetFwOpenPorts */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwOpenPorts;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0E9D7FA-E07E-430A-B19A-090CE82D92E2")
    INetFwOpenPorts : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt INetFwOpenPort *port) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ LONG portNumber,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ LONG portNumber,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol,
            /* [retval][out] */ __RPC__deref_out_opt INetFwOpenPort **openPort) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwOpenPortsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwOpenPorts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwOpenPorts * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwOpenPorts * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwOpenPorts * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwOpenPorts * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwOpenPorts * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwOpenPorts * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            INetFwOpenPorts * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            INetFwOpenPorts * This,
            /* [in] */ __RPC__in_opt INetFwOpenPort *port);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            INetFwOpenPorts * This,
            /* [in] */ LONG portNumber,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            INetFwOpenPorts * This,
            /* [in] */ LONG portNumber,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol,
            /* [retval][out] */ __RPC__deref_out_opt INetFwOpenPort **openPort);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            INetFwOpenPorts * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum);
        
        END_INTERFACE
    } INetFwOpenPortsVtbl;

    interface INetFwOpenPorts
    {
        CONST_VTBL struct INetFwOpenPortsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwOpenPorts_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwOpenPorts_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwOpenPorts_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwOpenPorts_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwOpenPorts_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwOpenPorts_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwOpenPorts_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwOpenPorts_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define INetFwOpenPorts_Add(This,port)	\
    ( (This)->lpVtbl -> Add(This,port) ) 

#define INetFwOpenPorts_Remove(This,portNumber,ipProtocol)	\
    ( (This)->lpVtbl -> Remove(This,portNumber,ipProtocol) ) 

#define INetFwOpenPorts_Item(This,portNumber,ipProtocol,openPort)	\
    ( (This)->lpVtbl -> Item(This,portNumber,ipProtocol,openPort) ) 

#define INetFwOpenPorts_get__NewEnum(This,newEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,newEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwOpenPorts_INTERFACE_DEFINED__ */


#ifndef __INetFwService_INTERFACE_DEFINED__
#define __INetFwService_INTERFACE_DEFINED__

/* interface INetFwService */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79FD57C8-908E-4A36-9888-D5B3F0A444CF")
    INetFwService : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__out NET_FW_SERVICE_TYPE *type) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Customized( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *customized) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IpVersion( 
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_IpVersion( 
            /* [in] */ NET_FW_IP_VERSION ipVersion) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Scope( 
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Scope( 
            /* [in] */ NET_FW_SCOPE scope) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemoteAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RemoteAddresses( 
            /* [in] */ __RPC__in BSTR remoteAddrs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_GloballyOpenPorts( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwOpenPorts **openPorts) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwService * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwService * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwService * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwService * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwService * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            INetFwService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            INetFwService * This,
            /* [retval][out] */ __RPC__out NET_FW_SERVICE_TYPE *type);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Customized )( 
            INetFwService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *customized);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IpVersion )( 
            INetFwService * This,
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IpVersion )( 
            INetFwService * This,
            /* [in] */ NET_FW_IP_VERSION ipVersion);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Scope )( 
            INetFwService * This,
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Scope )( 
            INetFwService * This,
            /* [in] */ NET_FW_SCOPE scope);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAddresses )( 
            INetFwService * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemoteAddresses )( 
            INetFwService * This,
            /* [in] */ __RPC__in BSTR remoteAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            INetFwService * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            INetFwService * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GloballyOpenPorts )( 
            INetFwService * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwOpenPorts **openPorts);
        
        END_INTERFACE
    } INetFwServiceVtbl;

    interface INetFwService
    {
        CONST_VTBL struct INetFwServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwService_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwService_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwService_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwService_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwService_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwService_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwService_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwService_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define INetFwService_get_Type(This,type)	\
    ( (This)->lpVtbl -> get_Type(This,type) ) 

#define INetFwService_get_Customized(This,customized)	\
    ( (This)->lpVtbl -> get_Customized(This,customized) ) 

#define INetFwService_get_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> get_IpVersion(This,ipVersion) ) 

#define INetFwService_put_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> put_IpVersion(This,ipVersion) ) 

#define INetFwService_get_Scope(This,scope)	\
    ( (This)->lpVtbl -> get_Scope(This,scope) ) 

#define INetFwService_put_Scope(This,scope)	\
    ( (This)->lpVtbl -> put_Scope(This,scope) ) 

#define INetFwService_get_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> get_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwService_put_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> put_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwService_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define INetFwService_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#define INetFwService_get_GloballyOpenPorts(This,openPorts)	\
    ( (This)->lpVtbl -> get_GloballyOpenPorts(This,openPorts) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwService_INTERFACE_DEFINED__ */


#ifndef __INetFwServices_INTERFACE_DEFINED__
#define __INetFwServices_INTERFACE_DEFINED__

/* interface INetFwServices */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("79649BB4-903E-421B-94C9-79848E79F6EE")
    INetFwServices : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ NET_FW_SERVICE_TYPE svcType,
            /* [retval][out] */ __RPC__deref_out_opt INetFwService **service) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwServices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwServices * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwServices * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwServices * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwServices * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            INetFwServices * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            INetFwServices * This,
            /* [in] */ NET_FW_SERVICE_TYPE svcType,
            /* [retval][out] */ __RPC__deref_out_opt INetFwService **service);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            INetFwServices * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum);
        
        END_INTERFACE
    } INetFwServicesVtbl;

    interface INetFwServices
    {
        CONST_VTBL struct INetFwServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwServices_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwServices_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwServices_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwServices_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwServices_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwServices_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwServices_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwServices_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define INetFwServices_Item(This,svcType,service)	\
    ( (This)->lpVtbl -> Item(This,svcType,service) ) 

#define INetFwServices_get__NewEnum(This,newEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,newEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwServices_INTERFACE_DEFINED__ */


#ifndef __INetFwAuthorizedApplication_INTERFACE_DEFINED__
#define __INetFwAuthorizedApplication_INTERFACE_DEFINED__

/* interface INetFwAuthorizedApplication */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwAuthorizedApplication;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B5E64FFA-C2C5-444E-A301-FB5E00018050")
    INetFwAuthorizedApplication : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ProcessImageFileName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *imageFileName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ProcessImageFileName( 
            /* [in] */ __RPC__in BSTR imageFileName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IpVersion( 
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_IpVersion( 
            /* [in] */ NET_FW_IP_VERSION ipVersion) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Scope( 
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Scope( 
            /* [in] */ NET_FW_SCOPE scope) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemoteAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RemoteAddresses( 
            /* [in] */ __RPC__in BSTR remoteAddrs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwAuthorizedApplicationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwAuthorizedApplication * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwAuthorizedApplication * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwAuthorizedApplication * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwAuthorizedApplication * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwAuthorizedApplication * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwAuthorizedApplication * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwAuthorizedApplication * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            INetFwAuthorizedApplication * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            INetFwAuthorizedApplication * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ProcessImageFileName )( 
            INetFwAuthorizedApplication * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *imageFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ProcessImageFileName )( 
            INetFwAuthorizedApplication * This,
            /* [in] */ __RPC__in BSTR imageFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IpVersion )( 
            INetFwAuthorizedApplication * This,
            /* [retval][out] */ __RPC__out NET_FW_IP_VERSION *ipVersion);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IpVersion )( 
            INetFwAuthorizedApplication * This,
            /* [in] */ NET_FW_IP_VERSION ipVersion);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Scope )( 
            INetFwAuthorizedApplication * This,
            /* [retval][out] */ __RPC__out NET_FW_SCOPE *scope);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Scope )( 
            INetFwAuthorizedApplication * This,
            /* [in] */ NET_FW_SCOPE scope);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAddresses )( 
            INetFwAuthorizedApplication * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemoteAddresses )( 
            INetFwAuthorizedApplication * This,
            /* [in] */ __RPC__in BSTR remoteAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            INetFwAuthorizedApplication * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            INetFwAuthorizedApplication * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        END_INTERFACE
    } INetFwAuthorizedApplicationVtbl;

    interface INetFwAuthorizedApplication
    {
        CONST_VTBL struct INetFwAuthorizedApplicationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwAuthorizedApplication_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwAuthorizedApplication_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwAuthorizedApplication_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwAuthorizedApplication_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwAuthorizedApplication_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwAuthorizedApplication_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwAuthorizedApplication_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwAuthorizedApplication_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define INetFwAuthorizedApplication_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define INetFwAuthorizedApplication_get_ProcessImageFileName(This,imageFileName)	\
    ( (This)->lpVtbl -> get_ProcessImageFileName(This,imageFileName) ) 

#define INetFwAuthorizedApplication_put_ProcessImageFileName(This,imageFileName)	\
    ( (This)->lpVtbl -> put_ProcessImageFileName(This,imageFileName) ) 

#define INetFwAuthorizedApplication_get_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> get_IpVersion(This,ipVersion) ) 

#define INetFwAuthorizedApplication_put_IpVersion(This,ipVersion)	\
    ( (This)->lpVtbl -> put_IpVersion(This,ipVersion) ) 

#define INetFwAuthorizedApplication_get_Scope(This,scope)	\
    ( (This)->lpVtbl -> get_Scope(This,scope) ) 

#define INetFwAuthorizedApplication_put_Scope(This,scope)	\
    ( (This)->lpVtbl -> put_Scope(This,scope) ) 

#define INetFwAuthorizedApplication_get_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> get_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwAuthorizedApplication_put_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> put_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwAuthorizedApplication_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define INetFwAuthorizedApplication_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwAuthorizedApplication_INTERFACE_DEFINED__ */


#ifndef __INetFwAuthorizedApplications_INTERFACE_DEFINED__
#define __INetFwAuthorizedApplications_INTERFACE_DEFINED__

/* interface INetFwAuthorizedApplications */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwAuthorizedApplications;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("644EFD52-CCF9-486C-97A2-39F352570B30")
    INetFwAuthorizedApplications : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt INetFwAuthorizedApplication *app) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ __RPC__in BSTR imageFileName) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ __RPC__in BSTR imageFileName,
            /* [retval][out] */ __RPC__deref_out_opt INetFwAuthorizedApplication **app) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwAuthorizedApplicationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwAuthorizedApplications * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwAuthorizedApplications * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwAuthorizedApplications * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwAuthorizedApplications * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwAuthorizedApplications * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwAuthorizedApplications * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwAuthorizedApplications * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            INetFwAuthorizedApplications * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            INetFwAuthorizedApplications * This,
            /* [in] */ __RPC__in_opt INetFwAuthorizedApplication *app);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            INetFwAuthorizedApplications * This,
            /* [in] */ __RPC__in BSTR imageFileName);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            INetFwAuthorizedApplications * This,
            /* [in] */ __RPC__in BSTR imageFileName,
            /* [retval][out] */ __RPC__deref_out_opt INetFwAuthorizedApplication **app);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            INetFwAuthorizedApplications * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum);
        
        END_INTERFACE
    } INetFwAuthorizedApplicationsVtbl;

    interface INetFwAuthorizedApplications
    {
        CONST_VTBL struct INetFwAuthorizedApplicationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwAuthorizedApplications_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwAuthorizedApplications_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwAuthorizedApplications_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwAuthorizedApplications_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwAuthorizedApplications_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwAuthorizedApplications_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwAuthorizedApplications_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwAuthorizedApplications_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define INetFwAuthorizedApplications_Add(This,app)	\
    ( (This)->lpVtbl -> Add(This,app) ) 

#define INetFwAuthorizedApplications_Remove(This,imageFileName)	\
    ( (This)->lpVtbl -> Remove(This,imageFileName) ) 

#define INetFwAuthorizedApplications_Item(This,imageFileName,app)	\
    ( (This)->lpVtbl -> Item(This,imageFileName,app) ) 

#define INetFwAuthorizedApplications_get__NewEnum(This,newEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,newEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwAuthorizedApplications_INTERFACE_DEFINED__ */


#ifndef __INetFwRule_INTERFACE_DEFINED__
#define __INetFwRule_INTERFACE_DEFINED__

/* interface INetFwRule */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwRule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AF230D27-BABA-4E42-ACED-F524F22CFCE2")
    INetFwRule : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Name( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *desc) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Description( 
            /* [in] */ __RPC__in BSTR desc) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ApplicationName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *imageFileName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ApplicationName( 
            /* [in] */ __RPC__in BSTR imageFileName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceName( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *serviceName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ServiceName( 
            /* [in] */ __RPC__in BSTR serviceName) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Protocol( 
            /* [retval][out] */ __RPC__out LONG *protocol) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Protocol( 
            /* [in] */ LONG protocol) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LocalPorts( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *portNumbers) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_LocalPorts( 
            /* [in] */ __RPC__in BSTR portNumbers) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemotePorts( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *portNumbers) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RemotePorts( 
            /* [in] */ __RPC__in BSTR portNumbers) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LocalAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *localAddrs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_LocalAddresses( 
            /* [in] */ __RPC__in BSTR localAddrs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemoteAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_RemoteAddresses( 
            /* [in] */ __RPC__in BSTR remoteAddrs) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IcmpTypesAndCodes( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *icmpTypesAndCodes) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_IcmpTypesAndCodes( 
            /* [in] */ __RPC__in BSTR icmpTypesAndCodes) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Direction( 
            /* [retval][out] */ __RPC__out NET_FW_RULE_DIRECTION *dir) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Direction( 
            /* [in] */ NET_FW_RULE_DIRECTION dir) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Interfaces( 
            /* [retval][out] */ __RPC__out VARIANT *interfaces) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Interfaces( 
            /* [in] */ VARIANT interfaces) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_InterfaceTypes( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *interfaceTypes) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_InterfaceTypes( 
            /* [in] */ __RPC__in BSTR interfaceTypes) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Grouping( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *context) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Grouping( 
            /* [in] */ __RPC__in BSTR context) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Profiles( 
            /* [retval][out] */ __RPC__out long *profileTypesBitmask) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Profiles( 
            /* [in] */ long profileTypesBitmask) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_EdgeTraversal( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EdgeTraversal( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Action( 
            /* [retval][out] */ __RPC__out NET_FW_ACTION *action) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Action( 
            /* [in] */ NET_FW_ACTION action) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwRuleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwRule * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwRule * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwRule * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwRule * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwRule * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwRule * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwRule * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *name);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Name )( 
            INetFwRule * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Description )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *desc);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Description )( 
            INetFwRule * This,
            /* [in] */ __RPC__in BSTR desc);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ApplicationName )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *imageFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ApplicationName )( 
            INetFwRule * This,
            /* [in] */ __RPC__in BSTR imageFileName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceName )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *serviceName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceName )( 
            INetFwRule * This,
            /* [in] */ __RPC__in BSTR serviceName);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Protocol )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__out LONG *protocol);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Protocol )( 
            INetFwRule * This,
            /* [in] */ LONG protocol);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LocalPorts )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *portNumbers);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LocalPorts )( 
            INetFwRule * This,
            /* [in] */ __RPC__in BSTR portNumbers);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemotePorts )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *portNumbers);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemotePorts )( 
            INetFwRule * This,
            /* [in] */ __RPC__in BSTR portNumbers);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LocalAddresses )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *localAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_LocalAddresses )( 
            INetFwRule * This,
            /* [in] */ __RPC__in BSTR localAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAddresses )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *remoteAddrs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_RemoteAddresses )( 
            INetFwRule * This,
            /* [in] */ __RPC__in BSTR remoteAddrs);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IcmpTypesAndCodes )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *icmpTypesAndCodes);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_IcmpTypesAndCodes )( 
            INetFwRule * This,
            /* [in] */ __RPC__in BSTR icmpTypesAndCodes);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Direction )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__out NET_FW_RULE_DIRECTION *dir);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Direction )( 
            INetFwRule * This,
            /* [in] */ NET_FW_RULE_DIRECTION dir);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Interfaces )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__out VARIANT *interfaces);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Interfaces )( 
            INetFwRule * This,
            /* [in] */ VARIANT interfaces);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_InterfaceTypes )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *interfaceTypes);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_InterfaceTypes )( 
            INetFwRule * This,
            /* [in] */ __RPC__in BSTR interfaceTypes);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Enabled )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Enabled )( 
            INetFwRule * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Grouping )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *context);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Grouping )( 
            INetFwRule * This,
            /* [in] */ __RPC__in BSTR context);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Profiles )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__out long *profileTypesBitmask);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Profiles )( 
            INetFwRule * This,
            /* [in] */ long profileTypesBitmask);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_EdgeTraversal )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_EdgeTraversal )( 
            INetFwRule * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Action )( 
            INetFwRule * This,
            /* [retval][out] */ __RPC__out NET_FW_ACTION *action);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_Action )( 
            INetFwRule * This,
            /* [in] */ NET_FW_ACTION action);
        
        END_INTERFACE
    } INetFwRuleVtbl;

    interface INetFwRule
    {
        CONST_VTBL struct INetFwRuleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwRule_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwRule_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwRule_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwRule_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwRule_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwRule_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwRule_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwRule_get_Name(This,name)	\
    ( (This)->lpVtbl -> get_Name(This,name) ) 

#define INetFwRule_put_Name(This,name)	\
    ( (This)->lpVtbl -> put_Name(This,name) ) 

#define INetFwRule_get_Description(This,desc)	\
    ( (This)->lpVtbl -> get_Description(This,desc) ) 

#define INetFwRule_put_Description(This,desc)	\
    ( (This)->lpVtbl -> put_Description(This,desc) ) 

#define INetFwRule_get_ApplicationName(This,imageFileName)	\
    ( (This)->lpVtbl -> get_ApplicationName(This,imageFileName) ) 

#define INetFwRule_put_ApplicationName(This,imageFileName)	\
    ( (This)->lpVtbl -> put_ApplicationName(This,imageFileName) ) 

#define INetFwRule_get_ServiceName(This,serviceName)	\
    ( (This)->lpVtbl -> get_ServiceName(This,serviceName) ) 

#define INetFwRule_put_ServiceName(This,serviceName)	\
    ( (This)->lpVtbl -> put_ServiceName(This,serviceName) ) 

#define INetFwRule_get_Protocol(This,protocol)	\
    ( (This)->lpVtbl -> get_Protocol(This,protocol) ) 

#define INetFwRule_put_Protocol(This,protocol)	\
    ( (This)->lpVtbl -> put_Protocol(This,protocol) ) 

#define INetFwRule_get_LocalPorts(This,portNumbers)	\
    ( (This)->lpVtbl -> get_LocalPorts(This,portNumbers) ) 

#define INetFwRule_put_LocalPorts(This,portNumbers)	\
    ( (This)->lpVtbl -> put_LocalPorts(This,portNumbers) ) 

#define INetFwRule_get_RemotePorts(This,portNumbers)	\
    ( (This)->lpVtbl -> get_RemotePorts(This,portNumbers) ) 

#define INetFwRule_put_RemotePorts(This,portNumbers)	\
    ( (This)->lpVtbl -> put_RemotePorts(This,portNumbers) ) 

#define INetFwRule_get_LocalAddresses(This,localAddrs)	\
    ( (This)->lpVtbl -> get_LocalAddresses(This,localAddrs) ) 

#define INetFwRule_put_LocalAddresses(This,localAddrs)	\
    ( (This)->lpVtbl -> put_LocalAddresses(This,localAddrs) ) 

#define INetFwRule_get_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> get_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwRule_put_RemoteAddresses(This,remoteAddrs)	\
    ( (This)->lpVtbl -> put_RemoteAddresses(This,remoteAddrs) ) 

#define INetFwRule_get_IcmpTypesAndCodes(This,icmpTypesAndCodes)	\
    ( (This)->lpVtbl -> get_IcmpTypesAndCodes(This,icmpTypesAndCodes) ) 

#define INetFwRule_put_IcmpTypesAndCodes(This,icmpTypesAndCodes)	\
    ( (This)->lpVtbl -> put_IcmpTypesAndCodes(This,icmpTypesAndCodes) ) 

#define INetFwRule_get_Direction(This,dir)	\
    ( (This)->lpVtbl -> get_Direction(This,dir) ) 

#define INetFwRule_put_Direction(This,dir)	\
    ( (This)->lpVtbl -> put_Direction(This,dir) ) 

#define INetFwRule_get_Interfaces(This,interfaces)	\
    ( (This)->lpVtbl -> get_Interfaces(This,interfaces) ) 

#define INetFwRule_put_Interfaces(This,interfaces)	\
    ( (This)->lpVtbl -> put_Interfaces(This,interfaces) ) 

#define INetFwRule_get_InterfaceTypes(This,interfaceTypes)	\
    ( (This)->lpVtbl -> get_InterfaceTypes(This,interfaceTypes) ) 

#define INetFwRule_put_InterfaceTypes(This,interfaceTypes)	\
    ( (This)->lpVtbl -> put_InterfaceTypes(This,interfaceTypes) ) 

#define INetFwRule_get_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> get_Enabled(This,enabled) ) 

#define INetFwRule_put_Enabled(This,enabled)	\
    ( (This)->lpVtbl -> put_Enabled(This,enabled) ) 

#define INetFwRule_get_Grouping(This,context)	\
    ( (This)->lpVtbl -> get_Grouping(This,context) ) 

#define INetFwRule_put_Grouping(This,context)	\
    ( (This)->lpVtbl -> put_Grouping(This,context) ) 

#define INetFwRule_get_Profiles(This,profileTypesBitmask)	\
    ( (This)->lpVtbl -> get_Profiles(This,profileTypesBitmask) ) 

#define INetFwRule_put_Profiles(This,profileTypesBitmask)	\
    ( (This)->lpVtbl -> put_Profiles(This,profileTypesBitmask) ) 

#define INetFwRule_get_EdgeTraversal(This,enabled)	\
    ( (This)->lpVtbl -> get_EdgeTraversal(This,enabled) ) 

#define INetFwRule_put_EdgeTraversal(This,enabled)	\
    ( (This)->lpVtbl -> put_EdgeTraversal(This,enabled) ) 

#define INetFwRule_get_Action(This,action)	\
    ( (This)->lpVtbl -> get_Action(This,action) ) 

#define INetFwRule_put_Action(This,action)	\
    ( (This)->lpVtbl -> put_Action(This,action) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwRule_INTERFACE_DEFINED__ */


#ifndef __INetFwRules_INTERFACE_DEFINED__
#define __INetFwRules_INTERFACE_DEFINED__

/* interface INetFwRules */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwRules;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9C4C6277-5027-441E-AFAE-CA1F542DA009")
    INetFwRules : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ __RPC__out long *count) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ __RPC__in_opt INetFwRule *rule) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ __RPC__in BSTR name) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item( 
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__deref_out_opt INetFwRule **rule) = 0;
        
        virtual /* [restricted][propget][id] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwRulesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwRules * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwRules * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwRules * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwRules * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwRules * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwRules * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwRules * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            INetFwRules * This,
            /* [retval][out] */ __RPC__out long *count);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Add )( 
            INetFwRules * This,
            /* [in] */ __RPC__in_opt INetFwRule *rule);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            INetFwRules * This,
            /* [in] */ __RPC__in BSTR name);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *Item )( 
            INetFwRules * This,
            /* [in] */ __RPC__in BSTR name,
            /* [retval][out] */ __RPC__deref_out_opt INetFwRule **rule);
        
        /* [restricted][propget][id] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            INetFwRules * This,
            /* [retval][out] */ __RPC__deref_out_opt IUnknown **newEnum);
        
        END_INTERFACE
    } INetFwRulesVtbl;

    interface INetFwRules
    {
        CONST_VTBL struct INetFwRulesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwRules_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwRules_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwRules_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwRules_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwRules_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwRules_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwRules_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwRules_get_Count(This,count)	\
    ( (This)->lpVtbl -> get_Count(This,count) ) 

#define INetFwRules_Add(This,rule)	\
    ( (This)->lpVtbl -> Add(This,rule) ) 

#define INetFwRules_Remove(This,name)	\
    ( (This)->lpVtbl -> Remove(This,name) ) 

#define INetFwRules_Item(This,name,rule)	\
    ( (This)->lpVtbl -> Item(This,name,rule) ) 

#define INetFwRules_get__NewEnum(This,newEnum)	\
    ( (This)->lpVtbl -> get__NewEnum(This,newEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwRules_INTERFACE_DEFINED__ */


#ifndef __INetFwServiceRestriction_INTERFACE_DEFINED__
#define __INetFwServiceRestriction_INTERFACE_DEFINED__

/* interface INetFwServiceRestriction */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwServiceRestriction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8267BBE3-F890-491C-B7B6-2DB1EF0E5D2B")
    INetFwServiceRestriction : public IDispatch
    {
    public:
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RestrictService( 
            /* [in] */ __RPC__in BSTR serviceName,
            /* [in] */ __RPC__in BSTR appName,
            /* [in] */ VARIANT_BOOL restrictService,
            /* [in] */ VARIANT_BOOL serviceSidRestricted) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ServiceRestricted( 
            /* [in] */ __RPC__in BSTR serviceName,
            /* [in] */ __RPC__in BSTR appName,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *serviceRestricted) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Rules( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwRules **rules) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwServiceRestrictionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwServiceRestriction * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwServiceRestriction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwServiceRestriction * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwServiceRestriction * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwServiceRestriction * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwServiceRestriction * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwServiceRestriction * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RestrictService )( 
            INetFwServiceRestriction * This,
            /* [in] */ __RPC__in BSTR serviceName,
            /* [in] */ __RPC__in BSTR appName,
            /* [in] */ VARIANT_BOOL restrictService,
            /* [in] */ VARIANT_BOOL serviceSidRestricted);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *ServiceRestricted )( 
            INetFwServiceRestriction * This,
            /* [in] */ __RPC__in BSTR serviceName,
            /* [in] */ __RPC__in BSTR appName,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *serviceRestricted);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rules )( 
            INetFwServiceRestriction * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwRules **rules);
        
        END_INTERFACE
    } INetFwServiceRestrictionVtbl;

    interface INetFwServiceRestriction
    {
        CONST_VTBL struct INetFwServiceRestrictionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwServiceRestriction_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwServiceRestriction_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwServiceRestriction_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwServiceRestriction_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwServiceRestriction_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwServiceRestriction_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwServiceRestriction_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwServiceRestriction_RestrictService(This,serviceName,appName,restrictService,serviceSidRestricted)	\
    ( (This)->lpVtbl -> RestrictService(This,serviceName,appName,restrictService,serviceSidRestricted) ) 

#define INetFwServiceRestriction_ServiceRestricted(This,serviceName,appName,serviceRestricted)	\
    ( (This)->lpVtbl -> ServiceRestricted(This,serviceName,appName,serviceRestricted) ) 

#define INetFwServiceRestriction_get_Rules(This,rules)	\
    ( (This)->lpVtbl -> get_Rules(This,rules) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwServiceRestriction_INTERFACE_DEFINED__ */


#ifndef __INetFwProfile_INTERFACE_DEFINED__
#define __INetFwProfile_INTERFACE_DEFINED__

/* interface INetFwProfile */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("174A0DDA-E9F9-449D-993B-21AB667CA456")
    INetFwProfile : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ __RPC__out NET_FW_PROFILE_TYPE *type) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FirewallEnabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_FirewallEnabled( 
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ExceptionsNotAllowed( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *notAllowed) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ExceptionsNotAllowed( 
            /* [in] */ VARIANT_BOOL notAllowed) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_NotificationsDisabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *disabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_NotificationsDisabled( 
            /* [in] */ VARIANT_BOOL disabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UnicastResponsesToMulticastBroadcastDisabled( 
            /* [retval][out] */ __RPC__out VARIANT_BOOL *disabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_UnicastResponsesToMulticastBroadcastDisabled( 
            /* [in] */ VARIANT_BOOL disabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_RemoteAdminSettings( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwRemoteAdminSettings **remoteAdminSettings) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IcmpSettings( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwIcmpSettings **icmpSettings) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_GloballyOpenPorts( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwOpenPorts **openPorts) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Services( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwServices **services) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_AuthorizedApplications( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwAuthorizedApplications **apps) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwProfile * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwProfile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwProfile * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwProfile * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwProfile * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwProfile * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwProfile * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Type )( 
            INetFwProfile * This,
            /* [retval][out] */ __RPC__out NET_FW_PROFILE_TYPE *type);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FirewallEnabled )( 
            INetFwProfile * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FirewallEnabled )( 
            INetFwProfile * This,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExceptionsNotAllowed )( 
            INetFwProfile * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *notAllowed);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ExceptionsNotAllowed )( 
            INetFwProfile * This,
            /* [in] */ VARIANT_BOOL notAllowed);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_NotificationsDisabled )( 
            INetFwProfile * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *disabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_NotificationsDisabled )( 
            INetFwProfile * This,
            /* [in] */ VARIANT_BOOL disabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UnicastResponsesToMulticastBroadcastDisabled )( 
            INetFwProfile * This,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *disabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UnicastResponsesToMulticastBroadcastDisabled )( 
            INetFwProfile * This,
            /* [in] */ VARIANT_BOOL disabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_RemoteAdminSettings )( 
            INetFwProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwRemoteAdminSettings **remoteAdminSettings);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IcmpSettings )( 
            INetFwProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwIcmpSettings **icmpSettings);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_GloballyOpenPorts )( 
            INetFwProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwOpenPorts **openPorts);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Services )( 
            INetFwProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwServices **services);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_AuthorizedApplications )( 
            INetFwProfile * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwAuthorizedApplications **apps);
        
        END_INTERFACE
    } INetFwProfileVtbl;

    interface INetFwProfile
    {
        CONST_VTBL struct INetFwProfileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwProfile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwProfile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwProfile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwProfile_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwProfile_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwProfile_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwProfile_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwProfile_get_Type(This,type)	\
    ( (This)->lpVtbl -> get_Type(This,type) ) 

#define INetFwProfile_get_FirewallEnabled(This,enabled)	\
    ( (This)->lpVtbl -> get_FirewallEnabled(This,enabled) ) 

#define INetFwProfile_put_FirewallEnabled(This,enabled)	\
    ( (This)->lpVtbl -> put_FirewallEnabled(This,enabled) ) 

#define INetFwProfile_get_ExceptionsNotAllowed(This,notAllowed)	\
    ( (This)->lpVtbl -> get_ExceptionsNotAllowed(This,notAllowed) ) 

#define INetFwProfile_put_ExceptionsNotAllowed(This,notAllowed)	\
    ( (This)->lpVtbl -> put_ExceptionsNotAllowed(This,notAllowed) ) 

#define INetFwProfile_get_NotificationsDisabled(This,disabled)	\
    ( (This)->lpVtbl -> get_NotificationsDisabled(This,disabled) ) 

#define INetFwProfile_put_NotificationsDisabled(This,disabled)	\
    ( (This)->lpVtbl -> put_NotificationsDisabled(This,disabled) ) 

#define INetFwProfile_get_UnicastResponsesToMulticastBroadcastDisabled(This,disabled)	\
    ( (This)->lpVtbl -> get_UnicastResponsesToMulticastBroadcastDisabled(This,disabled) ) 

#define INetFwProfile_put_UnicastResponsesToMulticastBroadcastDisabled(This,disabled)	\
    ( (This)->lpVtbl -> put_UnicastResponsesToMulticastBroadcastDisabled(This,disabled) ) 

#define INetFwProfile_get_RemoteAdminSettings(This,remoteAdminSettings)	\
    ( (This)->lpVtbl -> get_RemoteAdminSettings(This,remoteAdminSettings) ) 

#define INetFwProfile_get_IcmpSettings(This,icmpSettings)	\
    ( (This)->lpVtbl -> get_IcmpSettings(This,icmpSettings) ) 

#define INetFwProfile_get_GloballyOpenPorts(This,openPorts)	\
    ( (This)->lpVtbl -> get_GloballyOpenPorts(This,openPorts) ) 

#define INetFwProfile_get_Services(This,services)	\
    ( (This)->lpVtbl -> get_Services(This,services) ) 

#define INetFwProfile_get_AuthorizedApplications(This,apps)	\
    ( (This)->lpVtbl -> get_AuthorizedApplications(This,apps) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwProfile_INTERFACE_DEFINED__ */


#ifndef __INetFwPolicy_INTERFACE_DEFINED__
#define __INetFwPolicy_INTERFACE_DEFINED__

/* interface INetFwPolicy */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwPolicy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D46D2478-9AC9-4008-9DC7-5563CE5536CC")
    INetFwPolicy : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentProfile( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwProfile **profile) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetProfileByType( 
            /* [in] */ NET_FW_PROFILE_TYPE profileType,
            /* [retval][out] */ __RPC__deref_out_opt INetFwProfile **profile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwPolicyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwPolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwPolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwPolicy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwPolicy * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwPolicy * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwPolicy * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwPolicy * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentProfile )( 
            INetFwPolicy * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwProfile **profile);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *GetProfileByType )( 
            INetFwPolicy * This,
            /* [in] */ NET_FW_PROFILE_TYPE profileType,
            /* [retval][out] */ __RPC__deref_out_opt INetFwProfile **profile);
        
        END_INTERFACE
    } INetFwPolicyVtbl;

    interface INetFwPolicy
    {
        CONST_VTBL struct INetFwPolicyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwPolicy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwPolicy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwPolicy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwPolicy_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwPolicy_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwPolicy_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwPolicy_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwPolicy_get_CurrentProfile(This,profile)	\
    ( (This)->lpVtbl -> get_CurrentProfile(This,profile) ) 

#define INetFwPolicy_GetProfileByType(This,profileType,profile)	\
    ( (This)->lpVtbl -> GetProfileByType(This,profileType,profile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwPolicy_INTERFACE_DEFINED__ */


#ifndef __INetFwPolicy2_INTERFACE_DEFINED__
#define __INetFwPolicy2_INTERFACE_DEFINED__

/* interface INetFwPolicy2 */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwPolicy2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("98325047-C671-4174-8D81-DEFCD3F03186")
    INetFwPolicy2 : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentProfileTypes( 
            /* [retval][out] */ __RPC__out long *profileTypesBitmask) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_FirewallEnabled( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_FirewallEnabled( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ExcludedInterfaces( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out VARIANT *interfaces) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ExcludedInterfaces( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT interfaces) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_BlockAllInboundTraffic( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *Block) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BlockAllInboundTraffic( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL Block) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_NotificationsDisabled( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *disabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_NotificationsDisabled( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL disabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_UnicastResponsesToMulticastBroadcastDisabled( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *disabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_UnicastResponsesToMulticastBroadcastDisabled( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL disabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Rules( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwRules **rules) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_ServiceRestriction( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwServiceRestriction **ServiceRestriction) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EnableRuleGroup( 
            /* [in] */ long profileTypesBitmask,
            /* [in] */ __RPC__in BSTR group,
            /* [in] */ VARIANT_BOOL enable) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsRuleGroupEnabled( 
            /* [in] */ long profileTypesBitmask,
            /* [in] */ __RPC__in BSTR group,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RestoreLocalFirewallDefaults( void) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DefaultInboundAction( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out NET_FW_ACTION *action) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DefaultInboundAction( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ NET_FW_ACTION action) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_DefaultOutboundAction( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out NET_FW_ACTION *action) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DefaultOutboundAction( 
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ NET_FW_ACTION action) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_IsRuleGroupCurrentlyEnabled( 
            /* [in] */ __RPC__in BSTR group,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LocalPolicyModifyState( 
            /* [retval][out] */ __RPC__out NET_FW_MODIFY_STATE *modifyState) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwPolicy2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwPolicy2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwPolicy2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwPolicy2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwPolicy2 * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwPolicy2 * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwPolicy2 * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwPolicy2 * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentProfileTypes )( 
            INetFwPolicy2 * This,
            /* [retval][out] */ __RPC__out long *profileTypesBitmask);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_FirewallEnabled )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_FirewallEnabled )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ExcludedInterfaces )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out VARIANT *interfaces);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_ExcludedInterfaces )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT interfaces);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_BlockAllInboundTraffic )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *Block);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_BlockAllInboundTraffic )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL Block);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_NotificationsDisabled )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *disabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_NotificationsDisabled )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL disabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_UnicastResponsesToMulticastBroadcastDisabled )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *disabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_UnicastResponsesToMulticastBroadcastDisabled )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ VARIANT_BOOL disabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_Rules )( 
            INetFwPolicy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwRules **rules);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceRestriction )( 
            INetFwPolicy2 * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwServiceRestriction **ServiceRestriction);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *EnableRuleGroup )( 
            INetFwPolicy2 * This,
            /* [in] */ long profileTypesBitmask,
            /* [in] */ __RPC__in BSTR group,
            /* [in] */ VARIANT_BOOL enable);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsRuleGroupEnabled )( 
            INetFwPolicy2 * This,
            /* [in] */ long profileTypesBitmask,
            /* [in] */ __RPC__in BSTR group,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RestoreLocalFirewallDefaults )( 
            INetFwPolicy2 * This);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultInboundAction )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out NET_FW_ACTION *action);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultInboundAction )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ NET_FW_ACTION action);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_DefaultOutboundAction )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [retval][out] */ __RPC__out NET_FW_ACTION *action);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE *put_DefaultOutboundAction )( 
            INetFwPolicy2 * This,
            /* [in] */ NET_FW_PROFILE_TYPE2 profileType,
            /* [in] */ NET_FW_ACTION action);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_IsRuleGroupCurrentlyEnabled )( 
            INetFwPolicy2 * This,
            /* [in] */ __RPC__in BSTR group,
            /* [retval][out] */ __RPC__out VARIANT_BOOL *enabled);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LocalPolicyModifyState )( 
            INetFwPolicy2 * This,
            /* [retval][out] */ __RPC__out NET_FW_MODIFY_STATE *modifyState);
        
        END_INTERFACE
    } INetFwPolicy2Vtbl;

    interface INetFwPolicy2
    {
        CONST_VTBL struct INetFwPolicy2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwPolicy2_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwPolicy2_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwPolicy2_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwPolicy2_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwPolicy2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwPolicy2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwPolicy2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwPolicy2_get_CurrentProfileTypes(This,profileTypesBitmask)	\
    ( (This)->lpVtbl -> get_CurrentProfileTypes(This,profileTypesBitmask) ) 

#define INetFwPolicy2_get_FirewallEnabled(This,profileType,enabled)	\
    ( (This)->lpVtbl -> get_FirewallEnabled(This,profileType,enabled) ) 

#define INetFwPolicy2_put_FirewallEnabled(This,profileType,enabled)	\
    ( (This)->lpVtbl -> put_FirewallEnabled(This,profileType,enabled) ) 

#define INetFwPolicy2_get_ExcludedInterfaces(This,profileType,interfaces)	\
    ( (This)->lpVtbl -> get_ExcludedInterfaces(This,profileType,interfaces) ) 

#define INetFwPolicy2_put_ExcludedInterfaces(This,profileType,interfaces)	\
    ( (This)->lpVtbl -> put_ExcludedInterfaces(This,profileType,interfaces) ) 

#define INetFwPolicy2_get_BlockAllInboundTraffic(This,profileType,Block)	\
    ( (This)->lpVtbl -> get_BlockAllInboundTraffic(This,profileType,Block) ) 

#define INetFwPolicy2_put_BlockAllInboundTraffic(This,profileType,Block)	\
    ( (This)->lpVtbl -> put_BlockAllInboundTraffic(This,profileType,Block) ) 

#define INetFwPolicy2_get_NotificationsDisabled(This,profileType,disabled)	\
    ( (This)->lpVtbl -> get_NotificationsDisabled(This,profileType,disabled) ) 

#define INetFwPolicy2_put_NotificationsDisabled(This,profileType,disabled)	\
    ( (This)->lpVtbl -> put_NotificationsDisabled(This,profileType,disabled) ) 

#define INetFwPolicy2_get_UnicastResponsesToMulticastBroadcastDisabled(This,profileType,disabled)	\
    ( (This)->lpVtbl -> get_UnicastResponsesToMulticastBroadcastDisabled(This,profileType,disabled) ) 

#define INetFwPolicy2_put_UnicastResponsesToMulticastBroadcastDisabled(This,profileType,disabled)	\
    ( (This)->lpVtbl -> put_UnicastResponsesToMulticastBroadcastDisabled(This,profileType,disabled) ) 

#define INetFwPolicy2_get_Rules(This,rules)	\
    ( (This)->lpVtbl -> get_Rules(This,rules) ) 

#define INetFwPolicy2_get_ServiceRestriction(This,ServiceRestriction)	\
    ( (This)->lpVtbl -> get_ServiceRestriction(This,ServiceRestriction) ) 

#define INetFwPolicy2_EnableRuleGroup(This,profileTypesBitmask,group,enable)	\
    ( (This)->lpVtbl -> EnableRuleGroup(This,profileTypesBitmask,group,enable) ) 

#define INetFwPolicy2_IsRuleGroupEnabled(This,profileTypesBitmask,group,enabled)	\
    ( (This)->lpVtbl -> IsRuleGroupEnabled(This,profileTypesBitmask,group,enabled) ) 

#define INetFwPolicy2_RestoreLocalFirewallDefaults(This)	\
    ( (This)->lpVtbl -> RestoreLocalFirewallDefaults(This) ) 

#define INetFwPolicy2_get_DefaultInboundAction(This,profileType,action)	\
    ( (This)->lpVtbl -> get_DefaultInboundAction(This,profileType,action) ) 

#define INetFwPolicy2_put_DefaultInboundAction(This,profileType,action)	\
    ( (This)->lpVtbl -> put_DefaultInboundAction(This,profileType,action) ) 

#define INetFwPolicy2_get_DefaultOutboundAction(This,profileType,action)	\
    ( (This)->lpVtbl -> get_DefaultOutboundAction(This,profileType,action) ) 

#define INetFwPolicy2_put_DefaultOutboundAction(This,profileType,action)	\
    ( (This)->lpVtbl -> put_DefaultOutboundAction(This,profileType,action) ) 

#define INetFwPolicy2_get_IsRuleGroupCurrentlyEnabled(This,group,enabled)	\
    ( (This)->lpVtbl -> get_IsRuleGroupCurrentlyEnabled(This,group,enabled) ) 

#define INetFwPolicy2_get_LocalPolicyModifyState(This,modifyState)	\
    ( (This)->lpVtbl -> get_LocalPolicyModifyState(This,modifyState) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwPolicy2_INTERFACE_DEFINED__ */


#ifndef __INetFwMgr_INTERFACE_DEFINED__
#define __INetFwMgr_INTERFACE_DEFINED__

/* interface INetFwMgr */
/* [dual][uuid][object] */ 


EXTERN_C const IID IID_INetFwMgr;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F7898AF5-CAC4-4632-A2EC-DA06E5111AF2")
    INetFwMgr : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_LocalPolicy( 
            /* [retval][out] */ __RPC__deref_out_opt INetFwPolicy **localPolicy) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentProfileType( 
            /* [retval][out] */ __RPC__out NET_FW_PROFILE_TYPE *profileType) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RestoreDefaults( void) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsPortAllowed( 
            /* [in] */ __RPC__in BSTR imageFileName,
            /* [in] */ NET_FW_IP_VERSION ipVersion,
            /* [in] */ LONG portNumber,
            /* [in] */ __RPC__in BSTR localAddress,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol,
            /* [out] */ __RPC__out VARIANT *allowed,
            /* [out] */ __RPC__out VARIANT *restricted) = 0;
        
        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsIcmpTypeAllowed( 
            /* [in] */ NET_FW_IP_VERSION ipVersion,
            /* [in] */ __RPC__in BSTR localAddress,
            /* [in] */ BYTE type,
            /* [out] */ __RPC__out VARIANT *allowed,
            /* [out] */ __RPC__out VARIANT *restricted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct INetFwMgrVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            INetFwMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            INetFwMgr * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            INetFwMgr * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            INetFwMgr * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            INetFwMgr * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            INetFwMgr * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            INetFwMgr * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_LocalPolicy )( 
            INetFwMgr * This,
            /* [retval][out] */ __RPC__deref_out_opt INetFwPolicy **localPolicy);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE *get_CurrentProfileType )( 
            INetFwMgr * This,
            /* [retval][out] */ __RPC__out NET_FW_PROFILE_TYPE *profileType);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *RestoreDefaults )( 
            INetFwMgr * This);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsPortAllowed )( 
            INetFwMgr * This,
            /* [in] */ __RPC__in BSTR imageFileName,
            /* [in] */ NET_FW_IP_VERSION ipVersion,
            /* [in] */ LONG portNumber,
            /* [in] */ __RPC__in BSTR localAddress,
            /* [in] */ NET_FW_IP_PROTOCOL ipProtocol,
            /* [out] */ __RPC__out VARIANT *allowed,
            /* [out] */ __RPC__out VARIANT *restricted);
        
        /* [id] */ HRESULT ( STDMETHODCALLTYPE *IsIcmpTypeAllowed )( 
            INetFwMgr * This,
            /* [in] */ NET_FW_IP_VERSION ipVersion,
            /* [in] */ __RPC__in BSTR localAddress,
            /* [in] */ BYTE type,
            /* [out] */ __RPC__out VARIANT *allowed,
            /* [out] */ __RPC__out VARIANT *restricted);
        
        END_INTERFACE
    } INetFwMgrVtbl;

    interface INetFwMgr
    {
        CONST_VTBL struct INetFwMgrVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define INetFwMgr_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define INetFwMgr_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define INetFwMgr_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define INetFwMgr_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define INetFwMgr_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define INetFwMgr_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define INetFwMgr_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define INetFwMgr_get_LocalPolicy(This,localPolicy)	\
    ( (This)->lpVtbl -> get_LocalPolicy(This,localPolicy) ) 

#define INetFwMgr_get_CurrentProfileType(This,profileType)	\
    ( (This)->lpVtbl -> get_CurrentProfileType(This,profileType) ) 

#define INetFwMgr_RestoreDefaults(This)	\
    ( (This)->lpVtbl -> RestoreDefaults(This) ) 

#define INetFwMgr_IsPortAllowed(This,imageFileName,ipVersion,portNumber,localAddress,ipProtocol,allowed,restricted)	\
    ( (This)->lpVtbl -> IsPortAllowed(This,imageFileName,ipVersion,portNumber,localAddress,ipProtocol,allowed,restricted) ) 

#define INetFwMgr_IsIcmpTypeAllowed(This,ipVersion,localAddress,type,allowed,restricted)	\
    ( (This)->lpVtbl -> IsIcmpTypeAllowed(This,ipVersion,localAddress,type,allowed,restricted) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __INetFwMgr_INTERFACE_DEFINED__ */



#ifndef __NetFwPublicTypeLib_LIBRARY_DEFINED__
#define __NetFwPublicTypeLib_LIBRARY_DEFINED__

/* library NetFwPublicTypeLib */
/* [version][uuid] */ 

















EXTERN_C const IID LIBID_NetFwPublicTypeLib;

EXTERN_C const CLSID CLSID_NetFwRule;

#ifdef __cplusplus

class DECLSPEC_UUID("2C5BC43E-3369-4C33-AB0C-BE9469677AF4")
NetFwRule;
#endif

EXTERN_C const CLSID CLSID_NetFwOpenPort;

#ifdef __cplusplus

class DECLSPEC_UUID("0CA545C6-37AD-4A6C-BF92-9F7610067EF5")
NetFwOpenPort;
#endif

EXTERN_C const CLSID CLSID_NetFwAuthorizedApplication;

#ifdef __cplusplus

class DECLSPEC_UUID("EC9846B3-2762-4A6B-A214-6ACB603462D2")
NetFwAuthorizedApplication;
#endif

EXTERN_C const CLSID CLSID_NetFwPolicy2;

#ifdef __cplusplus

class DECLSPEC_UUID("E2B3C97F-6AE1-41AC-817A-F6F92166D7DD")
NetFwPolicy2;
#endif

EXTERN_C const CLSID CLSID_NetFwMgr;

#ifdef __cplusplus

class DECLSPEC_UUID("304CE942-6E39-40D8-943A-B913C40C9CD4")
NetFwMgr;
#endif
#endif /* __NetFwPublicTypeLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize64(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal64(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal64(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree64(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\nmsupp.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1991-1999. All rights reserved.
//
//  MODULE: bhsupp.h
//=============================================================================

#if !defined(_NMSUPP_H)

#define _NMSUPP_H

#pragma pack(1)

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __cplusplus
#ifndef try
#define try                         __try
#endif

#ifndef except
#define except                      __except
#endif
#endif

//=============================================================================
//  Windows version constants.
//=============================================================================

#define WINDOWS_VERSION_UNKNOWN     0
#define WINDOWS_VERSION_WIN32S      1
#define WINDOWS_VERSION_WIN32C      2
#define WINDOWS_VERSION_WIN32       3

//=============================================================================
//  Frame masks.
//=============================================================================

#define FRAME_MASK_ETHERNET         ((BYTE) ~0x01)
#define FRAME_MASK_TOKENRING        ((BYTE) ~0x80)
#define FRAME_MASK_FDDI             ((BYTE) ~0x01)

//=============================================================================
//  ACCESSRIGHTS
//=============================================================================

typedef enum _ACCESSRIGHTS
{
    AccessRightsNoAccess,               //... Access denied, invalid password.
    AccessRightsMonitoring,             //... Monitoring mode only.
    AccessRightsUserAccess,             //... User-level access rights.
    AccessRightsAllAccess               //... All access.
} ACCESSRIGHTS;

typedef ACCESSRIGHTS *PACCESSRIGHTS;

typedef LPVOID HPASSWORD;

#define HANDLE_TYPE_PASSWORD            MAKE_IDENTIFIER('P', 'W', 'D', '$')

//=============================================================================
//  Object heap type.
//=============================================================================

typedef LPVOID HOBJECTHEAP;                 //... Opaque.

//=============================================================================
//  Object cleanup procedure.
//=============================================================================

typedef VOID (WINAPI *OBJECTPROC)(HOBJECTHEAP, LPVOID);

#pragma pack()

//=============================================================================
//  Network Monitor timers.
//=============================================================================

typedef struct _TIMER *HTIMER;

typedef VOID (WINAPI *BHTIMERPROC)(LPVOID);

extern  HTIMER WINAPI BhSetTimer(BHTIMERPROC TimerProc, LPVOID InstData, DWORD TimeOut);

extern  VOID   WINAPI BhKillTimer(HTIMER hTimer);

//=============================================================================
//  Network Monitor driver support.
//=============================================================================

extern LPVOID WINAPI BhAllocSystemMemory(DWORD nBytes);

extern LPVOID WINAPI BhFreeSystemMemory(LPVOID ptr);

extern LPVOID WINAPI BhGetNetworkRequestAddress(DWORD NalRequestType);

//=============================================================================
//  Network Monitor global error API.
//=============================================================================

extern DWORD  WINAPI BhGetLastError(VOID);

extern DWORD  WINAPI BhSetLastError(DWORD Error);

//=============================================================================
//  Object manager function prototypes.
//=============================================================================

extern HOBJECTHEAP WINAPI CreateObjectHeap(DWORD ObjectSize, OBJECTPROC ObjectProc);

extern HOBJECTHEAP WINAPI DestroyObjectHeap(HOBJECTHEAP hObjectHeap);

extern LPVOID      WINAPI AllocObject(HOBJECTHEAP hObjectHeap);

extern LPVOID      WINAPI FreeObject(HOBJECTHEAP hObjectHeap, LPVOID ObjectMemory);

extern DWORD       WINAPI GrowObjectHeap(HOBJECTHEAP hObjectHeap, DWORD nObjects);

extern DWORD       WINAPI GetObjectHeapSize(HOBJECTHEAP hObjectHeap);

extern VOID        WINAPI PurgeObjectHeap(HOBJECTHEAP hObjectHeap);

//=============================================================================
//  Memory functions.
//=============================================================================

extern LPVOID     WINAPI AllocMemory(SIZE_T size);

extern LPVOID     WINAPI ReallocMemory(LPVOID ptr, SIZE_T NewSize);

extern VOID       WINAPI FreeMemory(LPVOID ptr);

extern VOID       WINAPI TestMemory(LPVOID ptr);

extern SIZE_T     WINAPI MemorySize(LPVOID ptr);

extern HANDLE     WINAPI MemoryHandle(LPBYTE ptr);

//=============================================================================
//  Password API's.
//=============================================================================

extern HPASSWORD    WINAPI CreatePassword(LPSTR password);

extern VOID         WINAPI DestroyPassword(HPASSWORD hPassword);

extern ACCESSRIGHTS WINAPI ValidatePassword(HPASSWORD hPassword);

//=============================================================================
//  EXPRESSION API's
//=============================================================================

extern LPEXPRESSION         WINAPI InitializeExpression(LPEXPRESSION Expression);

extern LPPATTERNMATCH       WINAPI InitializePattern(LPPATTERNMATCH Pattern, LPVOID ptr, DWORD offset, DWORD length);

extern LPEXPRESSION         WINAPI AndExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

extern LPEXPRESSION         WINAPI OrExpression(LPEXPRESSION Expression, LPPATTERNMATCH Pattern);

extern LPPATTERNMATCH       WINAPI NegatePattern(LPPATTERNMATCH Pattern);

extern LPADDRESSTABLE       WINAPI AdjustOperatorPrecedence(LPADDRESSTABLE AddressTable);

extern LPADDRESS            WINAPI NormalizeAddress(LPADDRESS Address);

extern LPADDRESSTABLE       WINAPI NormalizeAddressTable(LPADDRESSTABLE AddressTable);

//=============================================================================
//  SERVICE API's
//=============================================================================

extern HANDLE               WINAPI BhOpenService(LPSTR ServiceName);

extern VOID                 WINAPI BhCloseService(HANDLE ServiceHandle);

extern DWORD                WINAPI BhStartService(HANDLE ServiceHandle);

extern DWORD                WINAPI BhStopService(HANDLE ServiceHandle);

//=============================================================================
//  MISC. API's
//=============================================================================

extern DWORD                WINAPI BhGetWindowsVersion(VOID);

extern BOOL                 WINAPI IsDaytona(VOID);

extern VOID                 _cdecl dprintf(LPSTR format, ...);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\nsemail.h ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (c) Microsoft Corporation.  All rights reserved.
//
// File:     nsemail.h
//
// Abstract: NS_EMAIL namespace related definitions
//
//----------------------------------------------------------------------------

#ifndef _NSEMAIL_H_
#define _NSEMAIL_H_

typedef enum napi_provider_type_tag
{ 
    ProviderType_Application = 1, 
    ProviderType_Service, 
} NAPI_PROVIDER_TYPE;

typedef enum napi_provider_level_tag
{ 
    ProviderLevel_None = 0,
    ProviderLevel_Secondary, 
    ProviderLevel_Primary
} NAPI_PROVIDER_LEVEL;

//-----------------------------------------------------------------------------
// 
// Layout of Installation Blob for Email Naming NSPv2 Providers:
//
// +-------------------------------------------------------------------------+
// |                     NAPI_PROVIDER_INSTALLATION_BLOB                     |
// | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
// | dwVersion                                                               |
// | dwProviderType                                                          |
// | fSupportsWildCard                                                       |
// | cDomains (equal to N in this example)                                   |
// | OffsetFirstDomain (aligned offset of NAPI_DOMAIN_DESCRIPTION_BLOB # 1)  |
// | +---------------------------------------------------------------------+ |
// | |                   NAPI_DOMAIN_DESCRIPTION_BLOB # 1                  | |
// | | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + |
// | | AuthLevel                                                           | |
// | | cchDomainName                                                       | |
// | | OffsetNextDomainDescription (aligned offset of Domain Blob # 2)     | |
// | | OffsetThisDomainName (aligned offset of Domain Name 1)              | |
// | +---------------------------------------------------------------------+ |
// | +---------------------------------------------------------------------+ |
// | |                   NAPI_DOMAIN_DESCRIPTION_BLOB # 2                  | |
// | | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + |
// | | AuthLevel                                                           | |
// | | cchDomainName                                                       | |
// | | OffsetNextDomainDescription (aligned offset of Domain Blob # 3)     | |
// | | OffsetThisDomainName (aligned offset of Domain Name 2)              | |
// | +---------------------------------------------------------------------+ |
// | ... ... ...                                                             |
// | ... ... ...                                                             |
// | ... ... ...                                                             |
// | +---------------------------------------------------------------------+ |
// | |                   NAPI_DOMAIN_DESCRIPTION_BLOB # N                  | |
// | | - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + |
// | | AuthLevel                                                           | |
// | | cchDomainName                                                       | |
// | | OffsetNextDomainDescription (should be 0 if N is the last domain)   | |
// | | OffsetThisDomainName (aligned offset of Domain Name N)              | |
// | +---------------------------------------------------------------------+ |
// | Domain Name 1                                                           |
// | Domain Name 2                                                           |
// | ... ... ...                                                             |
// | Domain Name N                                                           |
// +-------------------------------------------------------------------------+
//
// Notes: - The above NAPI_PROVIDER_INSTALLATION_BLOB must be passed to 
//          WSCInstallNameSpaceEx encapsulated in a winsock2.h's BLOB 
//          (typedef struct _BLOB { ULONG  cbSize; BYTE * pBlobData;} BLOB;)
//          by storing its address in pBlobData, and its total size in 
//          cbSize.
//        - The NAPI_PROVIDER_INSTALLATION_BLOB must be at an address at
//          least 4-bytes aligned, better if machine-pointer-size aligned.
//        - Domain Blob (NAPI_DOMAIN_DESCRIPTION_BLOB) offsets need to be 
//          4-bytes aligned. 
//        - Domain Name offsets need to be 2-bytes aligned.
//        - Domain Names are strings of UNICODE chars and they must be at
//          least cchDomainName UNICODE chars long. Zero-termination is 
//          recommended but not required.
//        - Domain Blobs (NAPI_DOMAIN_DESCRIPTION_BLOBs) do not need to be 
//          contiguous and Domain Name strings do not need to be in order 
//          or grouped after the Domain Blobs, as in the example above.
//          They may appear in any order and also interleaved with Domain 
//          Blobs, as long as the alignment rules are respected.
//       
//-----------------------------------------------------------------------------

typedef struct napi_domain_description_blob_tag
{
    DWORD   AuthLevel;
    DWORD   cchDomainName;
    DWORD   OffsetNextDomainDescription;
    DWORD   OffsetThisDomainName;
} NAPI_DOMAIN_DESCRIPTION_BLOB;

typedef struct napi_provider_installation_blob_tag
{
    DWORD   dwVersion;
    DWORD   dwProviderType;
    DWORD   fSupportsWildCard;
    ULONG   cDomains;
    ULONG   OffsetFirstDomain;
} NAPI_PROVIDER_INSTALLATION_BLOB;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\newdev.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    newdev.h

Abstract:

    Public header file for Windows NT Driver Installation DLL.

--*/

#ifndef _INC_NEWDEV
#define _INC_NEWDEV

#include <pshpack1.h>   // Assume byte packing throughout
#include <setupapi.h>   // for HDEVINFO, PSP_DEVINFO_DATA, and PSP_DRVINFO_DATA

#ifdef __cplusplus
extern "C" {
#endif

//
// Flags for UpdateDriverForPlugAndPlayDevices
//
#define INSTALLFLAG_FORCE               0x00000001  // Force the installation of the specified driver
#define INSTALLFLAG_READONLY            0x00000002  // Do a read-only install (no file copy)
#define INSTALLFLAG_NONINTERACTIVE      0x00000004  // No UI shown at all. API will fail if any UI must be shown.
#define INSTALLFLAG_BITS                0x00000007

#if (WINVER >= _WIN32_WINNT_WIN2K)

BOOL
WINAPI
UpdateDriverForPlugAndPlayDevicesA(
    __in_opt  HWND hwndParent,
    __in      LPCSTR HardwareId,
    __in      LPCSTR FullInfPath,
    __in      DWORD InstallFlags,
    __out_opt PBOOL bRebootRequired
    );

BOOL
WINAPI
UpdateDriverForPlugAndPlayDevicesW(
    __in_opt  HWND hwndParent,
    __in      LPCWSTR HardwareId,
    __in      LPCWSTR FullInfPath,
    __in      DWORD InstallFlags,
    __out_opt PBOOL bRebootRequired
    );

#ifdef UNICODE
#define UpdateDriverForPlugAndPlayDevices UpdateDriverForPlugAndPlayDevicesW
#else
#define UpdateDriverForPlugAndPlayDevices UpdateDriverForPlugAndPlayDevicesA
#endif
#endif // (WINVER >= _WIN32_WINNT_WIN2K)

#if (WINVER >= _WIN32_WINNT_LONGHORN)
//
// Flags for DiInstallDevice
//
#define DIIDFLAG_SHOWSEARCHUI           0x00000001      // Show search UI if no drivers can be found.
#define DIIDFLAG_NOFINISHINSTALLUI      0x00000002      // Do NOT show the finish install UI.
#define DIIDFLAG_INSTALLNULLDRIVER      0x00000004      // Install the NULL driver on this device.
#define DIIDFLAG_BITS                   0x00000007

BOOL
WINAPI
DiInstallDevice(
    __in_opt  HWND hwndParent,
    __in      HDEVINFO DeviceInfoSet,
    __in      PSP_DEVINFO_DATA DeviceInfoData,
    __in_opt  PSP_DRVINFO_DATA DriverInfoData,
    __in      DWORD Flags,
    __out_opt PBOOL NeedReboot    OPTIONAL
    );
#endif // (WINVER >= _WIN32_WINNT_LONGHORN)

#if (WINVER >= _WIN32_WINNT_LONGHORN)

//
// Flags for DiInstallDriver
//
#define DIIRFLAG_INF_ALREADY_COPIED 0x00000001   // Don't copy inf, it has been published
#define DIIRFLAG_FORCE_INF          0x00000002   // use the inf as if users picked it.
#define DIIRFLAG_HW_USING_THE_INF   0x00000004   // limit installs on hw using the inf
#define DIIRFLAG_HOTPATCH           0x00000008   // Perform a hotpatch service pack install
#define DIIRFLAG_NOBACKUP           0x00000010   // install w/o backup and no rollback
#define DIIRFLAG_BITS ( DIIRFLAG_FORCE_INF | DIIRFLAG_HOTPATCH)
#define DIIRFLAG_SYSTEM_BITS ( DIIRFLAG_INF_ALREADY_COPIED |\
                               DIIRFLAG_FORCE_INF |\
                               DIIRFLAG_HW_USING_THE_INF |\
                               DIIRFLAG_HOTPATCH |\
                               DIIRFLAG_NOBACKUP )

BOOL
WINAPI
DiInstallDriverW(
    __in_opt  HWND hwndParent,
    __in      LPCWSTR InfPath,
    __in      DWORD Flags,
    __out_opt PBOOL NeedReboot
    );
    
BOOL
WINAPI
DiInstallDriverA(
    __in      HWND hwndParent,
    __in      LPCSTR InfPath,
    __in      DWORD Flags,
    __out_opt PBOOL NeedReboot
    );

#ifdef UNICODE
#define DiInstallDriver DiInstallDriverW
#else
#define DiInstallDriver DiInstallDriverA
#endif
#endif // (WINVER >= _WIN32_WINNT_LONGHORN)

#if (WINVER >= _WIN32_WINNT_LONGHORN)
BOOL
WINAPI
DiShowUpdateDevice(
    __in_opt  HWND hwndParent,
    __in      HDEVINFO DeviceInfoSet,
    __in      PSP_DEVINFO_DATA DeviceInfoData,
    __in      DWORD Flags,
    __out_opt PBOOL NeedReboot
    );


//
// DiRollbackDriver Flag values
//
#define ROLLBACK_FLAG_NO_UI             0x00000001  // don't show any UI (this could cause failures if UI must be displayed)
#define ROLLBACK_BITS                   0x00000001


BOOL
WINAPI
DiRollbackDriver(
    __in      HDEVINFO DeviceInfoSet,
    __in      PSP_DEVINFO_DATA DeviceInfoData,
    __in_opt  HWND hwndParent,
    __in      DWORD Flags,
    __out_opt PBOOL NeedReboot
    );
#endif // (WINVER >= _WIN32_WINNT_LONGHORN)


#ifdef __cplusplus
}
#endif

#include <poppack.h>

#endif // _INC_NEWDEV
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\nettypes.h ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    nettypes.h

Abstract:

    This header file contains type definitions for the NT TDI, NDI,
    DDI, and PDI interfaces which are not specific to a single interface.

Revision History:

--*/

#ifndef _NETTYPES_
#define _NETTYPES_

//
// The following basic type is used to provide extensibility in request
// and response packets.  The OFFSET type is used to contain a value which
// is interpreted as a relative address consisting of a number of bytes
// from the beginning of the immediate parent structure.
//

typedef ULONG OFFSET;

//
// The following basic type is used throughout all the layers to pass a
// string through an I/O interface which does not allow embedded pointers.
// To allocate a FLAT_STRING, one must make room for the correct number of
// buffer bytes in the allocation.
//

typedef struct _FLAT_STRING {
    SHORT MaximumLength;            // total size of string buffer.
    SHORT Length;                   // number of bytes represented in string.
    char Buffer [1];                // the buffer itself follows this struct.
} FLAT_STRING, *PFLAT_STRING;

//
// Basic type used to represent a network name, typically as a component of
// a transport address structure through the TDI.  This type is also passed
// through the NDI interface.  This type is declared as a structure so that
// it can be extended easily without modifying applications, even though it
// currently only has one element.
//
//

typedef struct _NETWORK_NAME {
    FLAT_STRING Name;                   // network name in FLAT_STRING format.
} NETWORK_NAME, *PNETWORK_NAME;

//
// Basic type used to represent an address at the hardware level of the
// network.  Hardware addresses are abstract types which are mapped to
// adapter addresses by the physical provider.  See the Physical Driver
// Interface specification for details on how this is accomplished.
//

#define HARDWARE_ADDRESS_LENGTH     6   // number of octets in a hardware address.

typedef struct _HARDWARE_ADDRESS {
    UCHAR Address [HARDWARE_ADDRESS_LENGTH];
} HARDWARE_ADDRESS, *PHARDWARE_ADDRESS;

//
// Network management variable types used by all interface levels.
//

#define NETMAN_VARTYPE_ULONG            0       // type is a ULONG.
#define NETMAN_VARTYPE_HARDWARE_ADDRESS 1       // type is a HARDWARE_ADDRESS.
#define NETMAN_VARTYPE_STRING           2       // type is a FLAT_STRING.

#endif // _NETTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\nmappstr.h ===
//****************************************************************************
//  Module:     SDK
//  File:       NMAPPSTR.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1999-2002
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#ifndef _NM_APPLET_STRINGS_H_
#define _NM_APPLET_STRINGS_H_

//
// This is used to register applets such that the NetMeeting process knows
// how to launch the applet process.
//

//
// Registry folder for applets.
//

#define NM_APPLET_KEY TEXT("SOFTWARE\\Microsoft\\Conferencing\\T.120 Applets")

//
// Registry sub-folders for applets with standard keys.
//

#define NM_STD_KEY_TYPE     TEXT("Object Key")

//
// Registry sub-folders for applets with non-standard keys.
//

#define NM_NONSTD_KEY_TYPE  TEXT("NonStd Key")

//
// Registry keys for applets
//

#define NM_REGVAL_APP_PATH      TEXT("Path")            // required
#define NM_REGVAL_CMD_LINE      TEXT("CmdLine")         // optional
#define NM_REGVAL_CURR_DIR      TEXT("Directory")       // optional
#define NM_REGVAL_MANUFACTURER  TEXT("Manufacturer")    // optional
#define NM_REGVAL_PRODUCT_NAME  TEXT("ProductName")     // optional
#define NM_REGVAL_DESCRIPTION   TEXT("Description")     // optional

//
// Environment variables for invoke information
//

#define NM_ENV_NODE_ID          TEXT("_node_id")    // conference ID
#define NM_ENV_CONF_ID          TEXT("_conf_id")    // initiator's node ID


#endif // _NM_APPLET_STRINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\nsscore.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for nsscore.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __nsscore_h__
#define __nsscore_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IWMSClassObject_FWD_DEFINED__
#define __IWMSClassObject_FWD_DEFINED__
typedef interface IWMSClassObject IWMSClassObject;
#endif 	/* __IWMSClassObject_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "wmscontext.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_nsscore_0000_0000 */
/* [local] */ 

//*****************************************************************************
//
// Microsoft Windows Media
// Copyright (C) Microsoft Corporation. All rights reserved.
//
// Automatically generated by Midl from nsscore.idl
//
// DO NOT EDIT THIS FILE.
//
//*****************************************************************************
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
EXTERN_GUID( IID_IWMSClassObject, 0xF54E23A4,0x1B1A,0x11d1,0x9E,0x90,0x00,0x60,0x97,0xD2,0xD7,0xCF );


extern RPC_IF_HANDLE __MIDL_itf_nsscore_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_nsscore_0000_0000_v0_0_s_ifspec;

#ifndef __IWMSClassObject_INTERFACE_DEFINED__
#define __IWMSClassObject_INTERFACE_DEFINED__

/* interface IWMSClassObject */
/* [object][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IWMSClassObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F54E23A4-1B1A-11d1-9E90-006097D2D7CF")
    IWMSClassObject : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateInstance( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AllocIWMSPacket( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AllocIWMSPacketList( 
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AllocIWMSContext( 
            /* [in] */ __RPC__in REFIID riid,
            /* [in] */ WMS_CONTEXT_TYPE ContextType,
            /* [in] */ __RPC__in_opt IUnknown *pRelatedContext,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AllocIWMSCommandContext( 
            /* [in] */ __RPC__in REFIID riid,
            /* [in] */ __RPC__in_opt IUnknown *pRelatedContext,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWMSClassObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IWMSClassObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IWMSClassObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IWMSClassObject * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *CreateInstance )( 
            IWMSClassObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocIWMSPacket )( 
            IWMSClassObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocIWMSPacketList )( 
            IWMSClassObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocIWMSContext )( 
            IWMSClassObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [in] */ WMS_CONTEXT_TYPE ContextType,
            /* [in] */ __RPC__in_opt IUnknown *pRelatedContext,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AllocIWMSCommandContext )( 
            IWMSClassObject * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [in] */ __RPC__in_opt IUnknown *pRelatedContext,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppunk);
        
        END_INTERFACE
    } IWMSClassObjectVtbl;

    interface IWMSClassObject
    {
        CONST_VTBL struct IWMSClassObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWMSClassObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IWMSClassObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IWMSClassObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IWMSClassObject_CreateInstance(This,riid,ppunk)	\
    ( (This)->lpVtbl -> CreateInstance(This,riid,ppunk) ) 

#define IWMSClassObject_AllocIWMSPacket(This,riid,ppunk)	\
    ( (This)->lpVtbl -> AllocIWMSPacket(This,riid,ppunk) ) 

#define IWMSClassObject_AllocIWMSPacketList(This,riid,ppunk)	\
    ( (This)->lpVtbl -> AllocIWMSPacketList(This,riid,ppunk) ) 

#define IWMSClassObject_AllocIWMSContext(This,riid,ContextType,pRelatedContext,ppunk)	\
    ( (This)->lpVtbl -> AllocIWMSContext(This,riid,ContextType,pRelatedContext,ppunk) ) 

#define IWMSClassObject_AllocIWMSCommandContext(This,riid,pRelatedContext,ppunk)	\
    ( (This)->lpVtbl -> AllocIWMSCommandContext(This,riid,pRelatedContext,ppunk) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IWMSClassObject_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\nmapptyp.h ===
//****************************************************************************
//  Module:     SDK
//  File:       NMAPPTYP.H
//  Content:    
//              
//
//  Copyright (c) Microsoft Corporation 1999-2002
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//****************************************************************************

#if ! defined(_NM_APPLET_TYPE_H_) && ! defined(__iapplet_h__)
#define _NM_APPLET_TYPE_H_

//
// GCC/MCS Base Types
//

typedef USHORT          AppletSessionID;
typedef USHORT          AppletChannelID;
typedef AppletChannelID AppletUserID;
typedef AppletUserID    AppletNodeID;
typedef USHORT          AppletTokenID;
typedef USHORT          AppletEntityID;

typedef ULONG           AppletConfID;

typedef UINT            AppletRequestTag;


//
// GCC Registry
//

typedef enum tagAppletRegistryCommand
{
    APPLET_REGISTER_CHANNEL  = 0,
    APPLET_ASSIGN_TOKEN      = 1,
    APPLET_SET_PARAMETER     = 2,
    APPLET_RETRIEVE_ENTRY    = 3,
    APPLET_DELETE_ENTRY      = 4,
    APPLET_ALLOCATE_HANDLE   = 5,
    APPLET_MONITOR           = 6, // nyi in SDK
}
    AppletRegistryCommand;


typedef enum tagAppletRegistryItemType
{
    APPLET_REGISTRY_CHANNEL_ID  = 1,
    APPLET_REGISTRY_TOKEN_ID    = 2,
    APPLET_REGISTRY_PARAMETER   = 3,
    APPLET_REGISTRY_NONE        = 4,
}
    AppletRegistryItemType;


typedef enum tagAppletModificationRights
{
    APPLET_OWNER_RIGHTS                     = 0,
    APPLET_SESSION_RIGHTS                   = 1,
    APPLET_PUBLIC_RIGHTS                    = 2,
    APPLET_NO_MODIFICATION_RIGHTS_SPECIFIED = 3,
}
    AppletModificationRights;


//
// MCS Channel
//

typedef enum tagAppletChannelCommand
{
    APPLET_JOIN_CHANNEL         = 0,
    APPLET_LEAVE_CHANNEL        = 1,
    APPLET_CONVENE_CHANNEL      = 2,
    APPLET_DISBAND_CHANNEL      = 3,
    APPLET_ADMIT_CHANNEL        = 4,
    APPLET_EXPEL_CHANNEL        = 5,	// indication only
}
    AppletChannelCommand;


typedef enum tagAppletChannelType
{
    APPLET_STATIC_CHANNEL               = 0,
    APPLET_DYNAMIC_MULTICAST_CHANNEL    = 1,
    APPLET_DYNAMIC_PRIVATE_CHANNEL      = 2,
    APPLET_DYNAMIC_USER_ID_CHANNEL      = 3,
    APPLET_NO_CHANNEL_TYPE_SPECIFIED    = 4
}
    AppletChannelType;


//
// MCS Token
//

typedef enum tagAppletTokenCommand
{
    APPLET_GRAB_TOKEN          = 0,
    APPLET_INHIBIT_TOKEN       = 1,
    APPLET_GIVE_TOKEN          = 2,
    APPLET_PLEASE_TOKEN        = 3,
    APPLET_RELEASE_TOKEN       = 4,
    APPLET_TEST_TOKEN          = 5,
    APPLET_GIVE_TOKEN_RESPONSE = 6,
}
    AppletTokenCommand;


typedef enum tagAppletTokenStatus
{
    APPLET_TOKEN_NOT_IN_USE         = 0,
    APPLET_TOKEN_SELF_GRABBED       = 1,
    APPLET_TOKEN_OTHER_GRABBED      = 2,
    APPLET_TOKEN_SELF_INHIBITED     = 3,
    APPLET_TOKEN_OTHER_INHIBITED    = 4,
    APPLET_TOKEN_SELF_RECIPIENT     = 5,
    APPLET_TOKEN_SELF_GIVING        = 6,
    APPLET_TOKEN_OTHER_GIVING       = 7,
}
    AppletTokenStatus;


//
// GCC Capability
//

typedef enum tagAppletCapabilityType
{
    APPLET_UNKNOWN_CAP_TYPE             = 0, // for non-collapsing caps
    APPLET_LOGICAL_CAPABILITY           = 1,
    APPLET_UNSIGNED_MINIMUM_CAPABILITY  = 2,
    APPLET_UNSIGNED_MAXIMUM_CAPABILITY  = 3,
}
    AppletCapabilityType;


typedef struct tagAppletCapabilityClass
{
    AppletCapabilityType    eType;
    ULONG                   nMinOrMax;
}
    AppletCapabilityClass;


typedef enum tagAppletCapIDType
{
	APPLET_STANDARD_CAPABILITY  = 0,
	APPLET_NONSTD_CAPABILITY	= 1,
}
    AppletCapIDType;


//
// GCC/MCS Resource Allocation Command
//

typedef enum tagAppletResourceAllocCommand
{
    APPLET_JOIN_DYNAMIC_CHANNEL     = 0, // compete among all members
    APPLET_GRAB_TOKEN_REQUEST		= 1, // nyi in SDK
}
    AppletResourceAllocCommand;

//
// Send Data
//

typedef enum tagAppletPriority
{
    APPLET_TOP_PRIORITY     = 0,
    APPLET_HIGH_PRIORITY    = 1,
    APPLET_MEDIUM_PRIORITY  = 2,
    APPLET_LOW_PRIORITY     = 3,
}
    AppletPriority;


//
// Key Type
//

typedef enum tagAppletKeyType
{
	APPLET_OBJECT_KEY		= 1,
	APPLET_H221_NONSTD_KEY	= 2,
}
	AppletKeyType;


//
// Error Code
//

enum tagAppletErrorCode
{
    APPLET_E_NO_SERVICE       		= 0x82000001,
    APPLET_E_SERVICE_FAIL      		= 0x82000002,
    APPLET_E_ALREADY_REGISTERED  	= 0x82000003,
    APPLET_E_NOT_REGISTERED      	= 0x82000004,
    APPLET_E_INVALID_CONFERENCE  	= 0x82000005,
    APPLET_E_INVALID_COOKIE      	= 0x82000006,
    APPLET_E_ALREADY_JOIN        	= 0x82000007,
    APPLET_E_NOT_JOINED          	= 0x82000008,
    APPLET_E_INVALID_JOIN_REQUEST	= 0x82000009,
    APPLET_E_ENTRY_ALREADY_EXISTS   = 0x8200000a,
    APPLET_E_ENTRY_DOES_NOT_EXIST   = 0x8200000b,
    APPLET_E_NOT_OWNER              = 0x8200000c,
    APPLET_E_NOT_ADVISED            = 0x8200000d,
    APPLET_E_ALREADY_ADVISED        = 0x8200000e,
};


//
// Reason Code
//

typedef enum tagAppletReason
{
    APPLET_R_UNSPECIFIED            = 0,
    APPLET_R_CONFERENCE_GONE        = 1,
    APPLET_R_USER_REJECTED          = 2,
    APPLET_R_RESOURCE_PURGED        = 3,
}
    AppletReason;


#endif // _NM_APPLET_BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NspAPI.h ===
/*++

Copyright (c) 1991-1998  Microsoft Corporation

Module Name:

    nspapi.h

Abstract:

    Name Space Provider API prototypes and manifests. See the
    "Windows NT NameSpace Provider Specification" document for
    details.


Environment:

    User Mode -Win32

Notes:

    You must include "basetyps.h" first. Some types should
    use definitions from base files rather than redefine here.
    Unfortunately, so such base file exists.

--*/

#ifndef _NSPAPI_INCLUDED
#define _NSPAPI_INCLUDED

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#ifndef _tagBLOB_DEFINED
#define _tagBLOB_DEFINED
#define _BLOB_DEFINED
#define _LPBLOB_DEFINED
typedef struct _BLOB {
    ULONG cbSize ;
#ifdef MIDL_PASS
    [size_is(cbSize)] BYTE *pBlobData;
#else  // MIDL_PASS
    BYTE *pBlobData ;
#endif // MIDL_PASS
} BLOB, *LPBLOB ;
#endif

#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct _GUID
{
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[8];
} GUID;
#endif /* GUID_DEFINED */

#ifndef __LPGUID_DEFINED__
#define __LPGUID_DEFINED__
typedef GUID *LPGUID;
#endif


//
// Service categories
//
#define SERVICE_RESOURCE            (0x00000001)
#define SERVICE_SERVICE             (0x00000002)
#define SERVICE_LOCAL               (0x00000004)

//
// Operation used when calling SetService()
//
#define SERVICE_REGISTER            (0x00000001)
#define SERVICE_DEREGISTER          (0x00000002)
#define SERVICE_FLUSH               (0x00000003)
#define SERVICE_ADD_TYPE            (0x00000004)
#define SERVICE_DELETE_TYPE         (0x00000005)

//
// Flags that affect the operations above
//
#define SERVICE_FLAG_DEFER          (0x00000001)
#define SERVICE_FLAG_HARD           (0x00000002)

//
// Used as input to GetService() for setting the dwProps parameter
//
#define PROP_COMMENT                (0x00000001)
#define PROP_LOCALE                 (0x00000002)
#define PROP_DISPLAY_HINT           (0x00000004)
#define PROP_VERSION                (0x00000008)
#define PROP_START_TIME             (0x00000010)
#define PROP_MACHINE                (0x00000020)
#define PROP_ADDRESSES              (0x00000100)
#define PROP_SD                     (0x00000200)
#define PROP_ALL                    (0x80000000)

//
// Flags that describe attributes of Service Addresses
//

#define SERVICE_ADDRESS_FLAG_RPC_CN (0x00000001)
#define SERVICE_ADDRESS_FLAG_RPC_DG (0x00000002)
#define SERVICE_ADDRESS_FLAG_RPC_NB (0x00000004)

//
// Name Spaces
//

#define NS_DEFAULT                  (0)

#define NS_SAP                      (1)
#define NS_NDS                      (2)
#define NS_PEER_BROWSE              (3)

#define NS_TCPIP_LOCAL              (10)
#define NS_TCPIP_HOSTS              (11)
#define NS_DNS                      (12)
#define NS_NETBT                    (13)
#define NS_WINS                     (14)

#define NS_NBP                      (20)

#define NS_MS                       (30)
#define NS_STDA                     (31)
#define NS_NTDS                     (32)

#define NS_X500                     (40)
#define NS_NIS                      (41)

#define NS_VNS                      (50)

//
// Name space attributes.
//
#define NSTYPE_HIERARCHICAL         (0x00000001)
#define NSTYPE_DYNAMIC              (0x00000002)
#define NSTYPE_ENUMERABLE           (0x00000004)
#define NSTYPE_WORKGROUP            (0x00000008)

//
// Transport attributes.
//
#define XP_CONNECTIONLESS           (0x00000001)
#define XP_GUARANTEED_DELIVERY      (0x00000002)
#define XP_GUARANTEED_ORDER         (0x00000004)
#define XP_MESSAGE_ORIENTED         (0x00000008)
#define XP_PSEUDO_STREAM            (0x00000010)
#define XP_GRACEFUL_CLOSE           (0x00000020)
#define XP_EXPEDITED_DATA           (0x00000040)
#define XP_CONNECT_DATA             (0x00000080)
#define XP_DISCONNECT_DATA          (0x00000100)
#define XP_SUPPORTS_BROADCAST       (0x00000200)
#define XP_SUPPORTS_MULTICAST       (0x00000400)
#define XP_BANDWIDTH_ALLOCATION     (0x00000800)
#define XP_FRAGMENTATION            (0x00001000)
#define XP_ENCRYPTS                 (0x00002000)

//
// Resolution flags for GetAddressByName().
//
#define RES_SOFT_SEARCH             (0x00000001)
#define RES_FIND_MULTIPLE           (0x00000002)
#define RES_SERVICE                 (0x00000004)

//
// Well known value names for Service Types
//

#define SERVICE_TYPE_VALUE_SAPIDA        "SapId"
#define SERVICE_TYPE_VALUE_SAPIDW       L"SapId"

#define SERVICE_TYPE_VALUE_CONNA         "ConnectionOriented"
#define SERVICE_TYPE_VALUE_CONNW        L"ConnectionOriented"

#define SERVICE_TYPE_VALUE_TCPPORTA      "TcpPort"
#define SERVICE_TYPE_VALUE_TCPPORTW     L"TcpPort"

#define SERVICE_TYPE_VALUE_UDPPORTA      "UdpPort"
#define SERVICE_TYPE_VALUE_UDPPORTW     L"UdpPort"

#ifdef UNICODE

#define SERVICE_TYPE_VALUE_SAPID        SERVICE_TYPE_VALUE_SAPIDW
#define SERVICE_TYPE_VALUE_CONN         SERVICE_TYPE_VALUE_CONNW
#define SERVICE_TYPE_VALUE_TCPPORT      SERVICE_TYPE_VALUE_TCPPORTW
#define SERVICE_TYPE_VALUE_UDPPORT      SERVICE_TYPE_VALUE_UDPPORTW

#else // not UNICODE

#define SERVICE_TYPE_VALUE_SAPID        SERVICE_TYPE_VALUE_SAPIDA
#define SERVICE_TYPE_VALUE_CONN         SERVICE_TYPE_VALUE_CONNA
#define SERVICE_TYPE_VALUE_TCPPORT      SERVICE_TYPE_VALUE_TCPPORTA
#define SERVICE_TYPE_VALUE_UDPPORT      SERVICE_TYPE_VALUE_UDPPORTA

#endif


//
// status flags returned by SetService
//
#define SET_SERVICE_PARTIAL_SUCCESS  (0x00000001)

//
// Name Space Information
//
typedef struct _NS_INFOA {
    DWORD dwNameSpace ;
    DWORD dwNameSpaceFlags ;
    LPSTR   lpNameSpace ;
} NS_INFOA,  * PNS_INFOA, FAR * LPNS_INFOA;
//
// Name Space Information
//
typedef struct _NS_INFOW {
    DWORD dwNameSpace ;
    DWORD dwNameSpaceFlags ;
    LPWSTR  lpNameSpace ;
} NS_INFOW,  * PNS_INFOW, FAR * LPNS_INFOW;
#ifdef UNICODE
typedef NS_INFOW NS_INFO;
typedef PNS_INFOW PNS_INFO;
typedef LPNS_INFOW LPNS_INFO;
#else
typedef NS_INFOA NS_INFO;
typedef PNS_INFOA PNS_INFO;
typedef LPNS_INFOA LPNS_INFO;
#endif // UNICODE

//
// Service Type Values. The structures are used to define named Service
// Type specific values. This structure is self relative and has no pointers.
//
typedef struct _SERVICE_TYPE_VALUE {
    DWORD dwNameSpace ;
    DWORD dwValueType ;
    DWORD dwValueSize ;
    DWORD dwValueNameOffset ;
    DWORD dwValueOffset ;
} SERVICE_TYPE_VALUE, *PSERVICE_TYPE_VALUE, FAR *LPSERVICE_TYPE_VALUE ;

//
// An absolute version of above. This structure does contain pointers.
//
typedef struct _SERVICE_TYPE_VALUE_ABSA  {
    DWORD dwNameSpace ;
    DWORD dwValueType ;
    DWORD dwValueSize ;
    LPSTR   lpValueName ;
    PVOID lpValue ;
} SERVICE_TYPE_VALUE_ABSA,
  *PSERVICE_TYPE_VALUE_ABSA,
  FAR *LPSERVICE_TYPE_VALUE_ABSA;
//
// An absolute version of above. This structure does contain pointers.
//
typedef struct _SERVICE_TYPE_VALUE_ABSW  {
    DWORD dwNameSpace ;
    DWORD dwValueType ;
    DWORD dwValueSize ;
    LPWSTR  lpValueName ;
    PVOID lpValue ;
} SERVICE_TYPE_VALUE_ABSW,
  *PSERVICE_TYPE_VALUE_ABSW,
  FAR *LPSERVICE_TYPE_VALUE_ABSW;
#ifdef UNICODE
typedef SERVICE_TYPE_VALUE_ABSW SERVICE_TYPE_VALUE_ABS;
typedef PSERVICE_TYPE_VALUE_ABSW PSERVICE_TYPE_VALUE_ABS;
typedef LPSERVICE_TYPE_VALUE_ABSW LPSERVICE_TYPE_VALUE_ABS;
#else
typedef SERVICE_TYPE_VALUE_ABSA SERVICE_TYPE_VALUE_ABS;
typedef PSERVICE_TYPE_VALUE_ABSA PSERVICE_TYPE_VALUE_ABS;
typedef LPSERVICE_TYPE_VALUE_ABSA LPSERVICE_TYPE_VALUE_ABS;
#endif // UNICODE

//
// Service Type Information. Contains the name of the Service Type and
// and an array of SERVICE_NS_TYPE_VALUE structures. This structure is self
// relative and has no pointers in it.
//
typedef struct _SERVICE_TYPE_INFO {
    DWORD dwTypeNameOffset ;
    DWORD dwValueCount ;
    SERVICE_TYPE_VALUE Values[1] ;
} SERVICE_TYPE_INFO, *PSERVICE_TYPE_INFO, FAR *LPSERVICE_TYPE_INFO ;

typedef struct _SERVICE_TYPE_INFO_ABSA {
    LPSTR   lpTypeName ;
    DWORD dwValueCount ;
    SERVICE_TYPE_VALUE_ABSA Values[1] ;
} SERVICE_TYPE_INFO_ABSA,
  *PSERVICE_TYPE_INFO_ABSA,
  FAR *LPSERVICE_TYPE_INFO_ABSA ;
typedef struct _SERVICE_TYPE_INFO_ABSW {
    LPWSTR  lpTypeName ;
    DWORD dwValueCount ;
    SERVICE_TYPE_VALUE_ABSW Values[1] ;
} SERVICE_TYPE_INFO_ABSW,
  *PSERVICE_TYPE_INFO_ABSW,
  FAR *LPSERVICE_TYPE_INFO_ABSW ;
#ifdef UNICODE
typedef SERVICE_TYPE_INFO_ABSW SERVICE_TYPE_INFO_ABS;
typedef PSERVICE_TYPE_INFO_ABSW PSERVICE_TYPE_INFO_ABS;
typedef LPSERVICE_TYPE_INFO_ABSW LPSERVICE_TYPE_INFO_ABS;
#else
typedef SERVICE_TYPE_INFO_ABSA SERVICE_TYPE_INFO_ABS;
typedef PSERVICE_TYPE_INFO_ABSA PSERVICE_TYPE_INFO_ABS;
typedef LPSERVICE_TYPE_INFO_ABSA LPSERVICE_TYPE_INFO_ABS;
#endif // UNICODE


//
// A Single Address definition.
//
typedef struct _SERVICE_ADDRESS {
    DWORD   dwAddressType ;
    DWORD   dwAddressFlags ;
    DWORD   dwAddressLength ;
    DWORD   dwPrincipalLength ;
#ifdef MIDL_PASS
    [size_is(dwAddressLength)] BYTE *lpAddress;
#else  // MIDL_PASS
    BYTE   *lpAddress ;
#endif // MIDL_PASS
#ifdef MIDL_PASS
    [size_is(dwPrincipalLength)] BYTE *lpPrincipal;
#else  // MIDL_PASS
    BYTE   *lpPrincipal ;
#endif // MIDL_PASS
} SERVICE_ADDRESS, *PSERVICE_ADDRESS, *LPSERVICE_ADDRESS;

//
// Addresses used by the service. Contains array of SERVICE_ADDRESS.
//
typedef struct _SERVICE_ADDRESSES {
    DWORD           dwAddressCount ;
#ifdef MIDL_PASS
    [size_is(dwAddressCount)] SERVICE_ADDRESS Addressses[*];
#else  // MIDL_PASS
    SERVICE_ADDRESS Addresses[1] ;
#endif // MIDL_PASS
} SERVICE_ADDRESSES, *PSERVICE_ADDRESSES, *LPSERVICE_ADDRESSES;


//
// Service Information.
//
typedef struct _SERVICE_INFOA {
    LPGUID lpServiceType ;
    LPSTR   lpServiceName ;
    LPSTR   lpComment ;
    LPSTR   lpLocale ;
    DWORD dwDisplayHint ;
    DWORD dwVersion ;
    DWORD dwTime ;
    LPSTR   lpMachineName ;
    LPSERVICE_ADDRESSES lpServiceAddress ;
    BLOB ServiceSpecificInfo ;
} SERVICE_INFOA, *PSERVICE_INFOA, FAR * LPSERVICE_INFOA ;
//
// Service Information.
//
typedef struct _SERVICE_INFOW {
    LPGUID lpServiceType ;
    LPWSTR  lpServiceName ;
    LPWSTR  lpComment ;
    LPWSTR  lpLocale ;
    DWORD dwDisplayHint ;
    DWORD dwVersion ;
    DWORD dwTime ;
    LPWSTR  lpMachineName ;
    LPSERVICE_ADDRESSES lpServiceAddress ;
    BLOB ServiceSpecificInfo ;
} SERVICE_INFOW, *PSERVICE_INFOW, FAR * LPSERVICE_INFOW ;
#ifdef UNICODE
typedef SERVICE_INFOW SERVICE_INFO;
typedef PSERVICE_INFOW PSERVICE_INFO;
typedef LPSERVICE_INFOW LPSERVICE_INFO;
#else
typedef SERVICE_INFOA SERVICE_INFO;
typedef PSERVICE_INFOA PSERVICE_INFO;
typedef LPSERVICE_INFOA LPSERVICE_INFO;
#endif // UNICODE


//
// Name Space & Service Information
//
typedef struct _NS_SERVICE_INFOA {
    DWORD dwNameSpace ;
    SERVICE_INFOA ServiceInfo ;
} NS_SERVICE_INFOA, *PNS_SERVICE_INFOA, FAR * LPNS_SERVICE_INFOA ;
//
// Name Space & Service Information
//
typedef struct _NS_SERVICE_INFOW {
    DWORD dwNameSpace ;
    SERVICE_INFOW ServiceInfo ;
} NS_SERVICE_INFOW, *PNS_SERVICE_INFOW, FAR * LPNS_SERVICE_INFOW ;
#ifdef UNICODE
typedef NS_SERVICE_INFOW NS_SERVICE_INFO;
typedef PNS_SERVICE_INFOW PNS_SERVICE_INFO;
typedef LPNS_SERVICE_INFOW LPNS_SERVICE_INFO;
#else
typedef NS_SERVICE_INFOA NS_SERVICE_INFO;
typedef PNS_SERVICE_INFOA PNS_SERVICE_INFO;
typedef LPNS_SERVICE_INFOA LPNS_SERVICE_INFO;
#endif // UNICODE

#ifndef __CSADDR_DEFINED__
#define __CSADDR_DEFINED__

//
// SockAddr Information
//
typedef struct _SOCKET_ADDRESS {
    LPSOCKADDR lpSockaddr ;
    INT iSockaddrLength ;
} SOCKET_ADDRESS, *PSOCKET_ADDRESS, FAR * LPSOCKET_ADDRESS ;

//
// CSAddr Information
//
typedef struct _CSADDR_INFO {
    SOCKET_ADDRESS LocalAddr ;
    SOCKET_ADDRESS RemoteAddr ;
    INT iSocketType ;
    INT iProtocol ;
} CSADDR_INFO, *PCSADDR_INFO, FAR * LPCSADDR_INFO ;

#endif

//
// Protocol Information
//
typedef struct _PROTOCOL_INFOA {
    DWORD dwServiceFlags ;
    INT iAddressFamily ;
    INT iMaxSockAddr ;
    INT iMinSockAddr ;
    INT iSocketType ;
    INT iProtocol ;
    DWORD dwMessageSize ;
    LPSTR   lpProtocol ;
} PROTOCOL_INFOA, *PPROTOCOL_INFOA, FAR * LPPROTOCOL_INFOA ;
//
// Protocol Information
//
typedef struct _PROTOCOL_INFOW {
    DWORD dwServiceFlags ;
    INT iAddressFamily ;
    INT iMaxSockAddr ;
    INT iMinSockAddr ;
    INT iSocketType ;
    INT iProtocol ;
    DWORD dwMessageSize ;
    LPWSTR  lpProtocol ;
} PROTOCOL_INFOW, *PPROTOCOL_INFOW, FAR * LPPROTOCOL_INFOW ;
#ifdef UNICODE
typedef PROTOCOL_INFOW PROTOCOL_INFO;
typedef PPROTOCOL_INFOW PPROTOCOL_INFO;
typedef LPPROTOCOL_INFOW LPPROTOCOL_INFO;
#else
typedef PROTOCOL_INFOA PROTOCOL_INFO;
typedef PPROTOCOL_INFOA PPROTOCOL_INFO;
typedef LPPROTOCOL_INFOA LPPROTOCOL_INFO;
#endif // UNICODE

//
// NETRESOURCE2 Structure
//
typedef struct _NETRESOURCE2A {
    DWORD dwScope ;
    DWORD dwType ;
    DWORD dwUsage ;
    DWORD dwDisplayType ;
    LPSTR   lpLocalName ;
    LPSTR   lpRemoteName ;
    LPSTR   lpComment ;
    NS_INFO ns_info ;
    GUID ServiceType ;
    DWORD dwProtocols ;
    LPINT lpiProtocols ;
} NETRESOURCE2A, *PNETRESOURCE2A, FAR * LPNETRESOURCE2A ;
//
// NETRESOURCE2 Structure
//
typedef struct _NETRESOURCE2W {
    DWORD dwScope ;
    DWORD dwType ;
    DWORD dwUsage ;
    DWORD dwDisplayType ;
    LPWSTR  lpLocalName ;
    LPWSTR  lpRemoteName ;
    LPWSTR  lpComment ;
    NS_INFO ns_info ;
    GUID ServiceType ;
    DWORD dwProtocols ;
    LPINT lpiProtocols ;
} NETRESOURCE2W, *PNETRESOURCE2W, FAR * LPNETRESOURCE2W ;
#ifdef UNICODE
typedef NETRESOURCE2W NETRESOURCE2;
typedef PNETRESOURCE2W PNETRESOURCE2;
typedef LPNETRESOURCE2W LPNETRESOURCE2;
#else
typedef NETRESOURCE2A NETRESOURCE2;
typedef PNETRESOURCE2A PNETRESOURCE2;
typedef LPNETRESOURCE2A LPNETRESOURCE2;
#endif // UNICODE

typedef  DWORD (* LPFN_NSPAPI) (VOID ) ;

//
// Structures for using the service routines asynchronously.
//
typedef
VOID
(*LPSERVICE_CALLBACK_PROC) (
    IN LPARAM lParam,
    IN HANDLE hAsyncTaskHandle
    );

typedef struct _SERVICE_ASYNC_INFO {
    LPSERVICE_CALLBACK_PROC lpServiceCallbackProc;
    LPARAM lParam;
    HANDLE hAsyncTaskHandle;
} SERVICE_ASYNC_INFO, *PSERVICE_ASYNC_INFO, FAR * LPSERVICE_ASYNC_INFO;

//
// Public NSP API prototypes.
//
INT
APIENTRY
EnumProtocolsA (
    IN     LPINT           lpiProtocols,
    IN OUT LPVOID          lpProtocolBuffer,
    IN OUT LPDWORD         lpdwBufferLength
    );
//
// Public NSP API prototypes.
//
INT
APIENTRY
EnumProtocolsW (
    IN     LPINT           lpiProtocols,
    IN OUT LPVOID          lpProtocolBuffer,
    IN OUT LPDWORD         lpdwBufferLength
    );
#ifdef UNICODE
#define EnumProtocols  EnumProtocolsW
#else
#define EnumProtocols  EnumProtocolsA
#endif // !UNICODE

INT
APIENTRY
GetAddressByNameA (
    IN     DWORD                dwNameSpace,
    IN     LPGUID               lpServiceType,
    IN     LPSTR              lpServiceName OPTIONAL,
    IN     LPINT                lpiProtocols OPTIONAL,
    IN     DWORD                dwResolution,
    IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo OPTIONAL,
    IN OUT LPVOID               lpCsaddrBuffer,
    IN OUT LPDWORD              lpdwBufferLength,
    IN OUT LPSTR              lpAliasBuffer OPTIONAL,
    IN OUT LPDWORD              lpdwAliasBufferLength OPTIONAL
    );
INT
APIENTRY
GetAddressByNameW (
    IN     DWORD                dwNameSpace,
    IN     LPGUID               lpServiceType,
    IN     LPWSTR              lpServiceName OPTIONAL,
    IN     LPINT                lpiProtocols OPTIONAL,
    IN     DWORD                dwResolution,
    IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo OPTIONAL,
    IN OUT LPVOID               lpCsaddrBuffer,
    IN OUT LPDWORD              lpdwBufferLength,
    IN OUT LPWSTR              lpAliasBuffer OPTIONAL,
    IN OUT LPDWORD              lpdwAliasBufferLength OPTIONAL
    );
#ifdef UNICODE
#define GetAddressByName  GetAddressByNameW
#else
#define GetAddressByName  GetAddressByNameA
#endif // !UNICODE

INT
APIENTRY
GetTypeByNameA (
    IN     LPSTR         lpServiceName,
    IN OUT LPGUID          lpServiceType
    );
INT
APIENTRY
GetTypeByNameW (
    IN     LPWSTR         lpServiceName,
    IN OUT LPGUID          lpServiceType
    );
#ifdef UNICODE
#define GetTypeByName  GetTypeByNameW
#else
#define GetTypeByName  GetTypeByNameA
#endif // !UNICODE

INT
APIENTRY
GetNameByTypeA (
    IN     LPGUID          lpServiceType,
    IN OUT LPSTR         lpServiceName,
    IN     DWORD           dwNameLength
    );
INT
APIENTRY
GetNameByTypeW (
    IN     LPGUID          lpServiceType,
    IN OUT LPWSTR         lpServiceName,
    IN     DWORD           dwNameLength
    );
#ifdef UNICODE
#define GetNameByType  GetNameByTypeW
#else
#define GetNameByType  GetNameByTypeA
#endif // !UNICODE

INT
APIENTRY
SetServiceA (
    IN     DWORD                dwNameSpace,
    IN     DWORD                dwOperation,
    IN     DWORD                dwFlags,
    IN     LPSERVICE_INFOA      lpServiceInfo,
    IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo,
    IN OUT LPDWORD              lpdwStatusFlags
    );
INT
APIENTRY
SetServiceW (
    IN     DWORD                dwNameSpace,
    IN     DWORD                dwOperation,
    IN     DWORD                dwFlags,
    IN     LPSERVICE_INFOW      lpServiceInfo,
    IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo,
    IN OUT LPDWORD              lpdwStatusFlags
    );
#ifdef UNICODE
#define SetService  SetServiceW
#else
#define SetService  SetServiceA
#endif // !UNICODE

INT
APIENTRY
GetServiceA (
    IN     DWORD                dwNameSpace,
    IN     LPGUID               lpGuid,
    IN     LPSTR              lpServiceName,
    IN     DWORD                dwProperties,
    IN OUT LPVOID               lpBuffer,
    IN OUT LPDWORD              lpdwBufferSize,
    IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo
    );
INT
APIENTRY
GetServiceW (
    IN     DWORD                dwNameSpace,
    IN     LPGUID               lpGuid,
    IN     LPWSTR              lpServiceName,
    IN     DWORD                dwProperties,
    IN OUT LPVOID               lpBuffer,
    IN OUT LPDWORD              lpdwBufferSize,
    IN     LPSERVICE_ASYNC_INFO lpServiceAsyncInfo
    );
#ifdef UNICODE
#define GetService  GetServiceW
#else
#define GetService  GetServiceA
#endif // !UNICODE

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif  // _NSPAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\Npapi.h ===
/*---------------------------------------------------------------
THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED
TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
PARTICULAR PURPOSE.

Copyright (C) 1991 - 2000.  Microsoft Corporation.  All rights reserved.

npapi.h

Abstract:

    Network Provider API prototypes and manifests.  A network provider
    is a client of the Win32 Winnet driver.  See the "NT/Win32 Network
    Provider API Specification" document for further details.


Environment:

    User Mode -Win32

Notes:

    This file currently contains the function typedefs that will be needed
    by the winnet driver to support multiple providers using LoadLibrary.

---------------------------------------------------------------*/


#ifndef _NPAPI_INCLUDED
#define _NPAPI_INCLUDED

//
//  CONNECTIONS
//

DWORD APIENTRY
NPAddConnection (
                LPNETRESOURCEW lpNetResource,
                LPWSTR  lpPassword,
                LPWSTR  lpUserName
                );

typedef DWORD (*PF_NPAddConnection) (
                                    LPNETRESOURCEW lpNetResource,
                                    LPWSTR  lpPassword,
                                    LPWSTR  lpUserName
                                    );


DWORD APIENTRY
NPAddConnection3 (
                 HWND            hwndOwner,
                 LPNETRESOURCEW  lpNetResource,
                 LPTSTR          lpPassword,
                 LPTSTR          lpUserName,
                 DWORD           dwFlags
                 );

typedef DWORD (*PF_NPAddConnection3) (
                                     HWND              hwndOwner,
                                     LPNETRESOURCEW    lpNetResource,
                                     LPWSTR            lpPassword,
                                     LPWSTR            lpUserName,
                                     DWORD             dwFlags
                                     );


DWORD APIENTRY
NPCancelConnection (
                   LPWSTR  lpName,
                   BOOL    fForce
                   );
typedef DWORD (*PF_NPCancelConnection) (
                                       LPWSTR  lpName,
                                       BOOL    fForce
                                       );

DWORD APIENTRY
NPGetConnection (
                LPWSTR   lpLocalName,
                LPWSTR   lpRemoteName,
                LPDWORD  lpnBufferLen
                );
typedef DWORD (*PF_NPGetConnection) (
                                    LPWSTR   lpLocalName,
                                    LPWSTR   lpRemoteName,
                                    LPDWORD  lpnBufferLen
                                    );


DWORD APIENTRY
NPGetUniversalName (
                   LPWSTR   lpLocalPath,
                   DWORD    dwInfoLevel,
                   LPVOID   lpBuffer,
                   LPDWORD  lpBufferSize
                   );
typedef DWORD (*PF_NPGetUniversalName) (
                                       LPWSTR   lpLocalPath,
                                       DWORD    dwInfoLevel,
                                       LPVOID   lpBuffer,
                                       LPDWORD  lpnBufferSize
                                       );

DWORD APIENTRY
NPOpenEnum (
           DWORD       dwScope,
           DWORD       dwType,
           DWORD       dwUsage,
           LPNETRESOURCEW   lpNetResource,
           LPHANDLE         lphEnum
           );
typedef DWORD (*PF_NPOpenEnum) (
                               DWORD       dwScope,
                               DWORD       dwType,
                               DWORD       dwUsage,
                               LPNETRESOURCEW   lpNetResource,
                               LPHANDLE         lphEnum
                               );

DWORD APIENTRY
NPEnumResource (
               HANDLE  hEnum,
               LPDWORD lpcCount,
               LPVOID  lpBuffer,
               LPDWORD lpBufferSize
               );
typedef DWORD (*PF_NPEnumResource) (
                                   HANDLE  hEnum,
                                   LPDWORD lpcCount,
                                   LPVOID  lpBuffer,
                                   LPDWORD lpBufferSize
                                   );

DWORD APIENTRY
NPCloseEnum (
            HANDLE   hEnum
            );
typedef DWORD (*PF_NPCloseEnum) (
                                HANDLE   hEnum
                                );


//
//  CAPABILITIES
//

#define WNNC_SPEC_VERSION      0x00000001
#define WNNC_SPEC_VERSION51    0x00050001
#define WNNC_NET_TYPE          0x00000002
#define WNNC_NET_NONE          0x00000000
/*
 removed because of macro definition warnings
#define  WNNC_NET_MSNET         0x00000100
#define  WNNC_NET_LANMAN        0x00000200
#define  WNNC_NET_NETWARE       0x00000300
#define  WNNC_NET_VINES         0x00000400
*/

#define  WNNC_DRIVER_VERSION        0x00000003

#define  WNNC_USER                  0x00000004
#define  WNNC_USR_GETUSER           0x00000001

#define  WNNC_CONNECTION            0x00000006
#define  WNNC_CON_ADDCONNECTION     0x00000001
#define  WNNC_CON_CANCELCONNECTION  0x00000002
#define  WNNC_CON_GETCONNECTIONS    0x00000004
#define  WNNC_CON_ADDCONNECTION3    0x00000008

#define  WNNC_DIALOG                0x00000008
#define  WNNC_DLG_DEVICEMODE        0x00000001
#define  WNNC_DLG_PROPERTYDIALOG    0x00000020
#define  WNNC_DLG_SEARCHDIALOG      0x00000040
#define  WNNC_DLG_FORMATNETWORKNAME 0x00000080
#define  WNNC_DLG_PERMISSIONEDITOR  0x00000100

#define  WNNC_ADMIN                 0x00000009
#define  WNNC_ADM_GETDIRECTORYTYPE  0x00000001
#define  WNNC_ADM_DIRECTORYNOTIFY   0x00000002

#define  WNNC_ENUMERATION           0x0000000B
#define  WNNC_ENUM_GLOBAL           0x00000001
#define  WNNC_ENUM_LOCAL            0x00000002

#define  WNNC_START                 0x0000000C
#define  WNNC_WAIT_FOR_START        0x00000001



DWORD APIENTRY
NPGetCaps (
          DWORD   ndex
          );
typedef DWORD (*PF_NPGetCaps) (
                              DWORD   ndex
                              );

//
//  OTHER
//

DWORD APIENTRY
NPGetUser (
          LPWSTR  lpName,
          LPWSTR  lpUserName,
          LPDWORD lpnBufferLen
          );
typedef DWORD (*PF_NPGetUser) (
                              LPWSTR  lpName,
                              LPWSTR  lpUserName,
                              LPDWORD lpnBufferLen
                              );

#define WNTYPE_DRIVE    1
#define WNTYPE_FILE     2
#define WNTYPE_PRINTER  3
#define WNTYPE_COMM     4

#define WNPS_FILE       0
#define WNPS_DIR        1
#define WNPS_MULT       2

DWORD APIENTRY
NPDeviceMode(
            HWND hParent
            );
typedef DWORD (*PF_NPDeviceMode) (
                                 HWND hParent
                                 );

// flag for search dialog
#define WNSRCH_REFRESH_FIRST_LEVEL 0x00000001

DWORD APIENTRY
NPSearchDialog(
              HWND   hwndParent,
              LPNETRESOURCEW lpNetResource,
              LPVOID  lpBuffer,
              DWORD   cbBuffer,
              LPDWORD lpnFlags
              );
typedef DWORD (*PF_NPSearchDialog) (
                                   HWND   hwndParent,
                                   LPNETRESOURCEW lpNetResource,
                                   LPVOID  lpBuffer,
                                   DWORD   cbBuffer,
                                   LPDWORD lpnFlags
                                   );

/*
 removed because of macro definition warnings
// flags for format network name
#define WNFMT_MULTILINE           0x00000001
#define WNFMT_ABBREVIATED         0x00000002
#define WNFMT_INENUM              0x00000010
*/
DWORD APIENTRY
NPFormatNetworkName(
                   LPWSTR   lpRemoteName,
                   LPWSTR   lpFormattedName,
                   LPDWORD  lpnLength,
                   DWORD    dwFlags,
                   DWORD    dwAveCharPerLine
                   );
typedef DWORD (*PF_NPFormatNetworkName) (
                                        LPWSTR   lpRemoteName,
                                        LPWSTR   lpFormattedName,
                                        LPDWORD  lpnLength,
                                        DWORD    dwFlags,
                                        DWORD    dwAveCharPerLine
                                        );

DWORD APIENTRY
NPGetPropertyText(
                 DWORD  iButton,
                 DWORD  nPropSel,
                 LPWSTR lpName,
                 LPWSTR lpButtonName,
                 DWORD  nButtonNameLen,
                 DWORD  nType
                 );
typedef DWORD (*PF_NPGetPropertyText) (
                                      DWORD  iButton,
                                      DWORD  nPropSel,
                                      LPWSTR lpName,
                                      LPWSTR lpButtonName,
                                      DWORD  nButtonNameLen,
                                      DWORD  nType
                                      );

DWORD APIENTRY
NPPropertyDialog(
                HWND   hwndParent,
                DWORD  iButtonDlg,
                DWORD  nPropSel,
                LPWSTR lpFileName,
                DWORD  nType
                );
typedef DWORD (*PF_NPPropertyDialog) (
                                     HWND   hwndParent,
                                     DWORD  iButtonDlg,
                                     DWORD  nPropSel,
                                     LPWSTR lpFileName,
                                     DWORD  nType
                                     );


//
//  ADMIN
//

#define WNDT_NORMAL   0
#define WNDT_NETWORK  1

#define WNDN_MKDIR    1
#define WNDN_RMDIR    2
#define WNDN_MVDIR    3

DWORD APIENTRY
NPGetDirectoryType (
                   LPWSTR  lpName,
                   LPINT   lpType,
                   BOOL    bFlushCache
                   );
typedef DWORD (*PF_NPGetDirectoryType) (
                                       LPWSTR  lpName,
                                       LPINT   lpType,
                                       BOOL    bFlushCache
                                       );

DWORD APIENTRY
NPDirectoryNotify (
                  HWND    hwnd,
                  LPWSTR  lpDir,
                  DWORD   dwOper
                  );
typedef DWORD (*PF_NPDirectoryNotify) (
                                      HWND    hwnd,
                                      LPWSTR  lpDir,
                                      DWORD   dwOper
                                      );

VOID
WNetSetLastErrorA(
                 DWORD   err,
                 LPSTR   lpError,
                 LPSTR   lpProviders
                 );

VOID
WNetSetLastErrorW(
                 DWORD   err,
                 LPWSTR  lpError,
                 LPWSTR  lpProviders
                 );

#ifdef UNICODE
   #define WNetSetLastError   WNetSetLastErrorW
#else
   #define WNetSetLastError   WNetSetLastErrorA
#endif  // UNICODE

//
//  CREDENTIAL MANAGEMENT and other classes of providers
//


// Define the Net/Authentication and othr Provider Classes
#define WN_NETWORK_CLASS            0x00000001
#define WN_CREDENTIAL_CLASS         0x00000002
#define WN_PRIMARY_AUTHENT_CLASS    0x00000004
#define WN_SERVICE_CLASS            0x00000008

#define WN_VALID_LOGON_ACCOUNT      0x00000001
#define WN_NT_PASSWORD_CHANGED      0x00000002

DWORD APIENTRY
NPLogonNotify (
              PLUID               lpLogonId,
              LPCWSTR             lpAuthentInfoType,
              LPVOID              lpAuthentInfo,
              LPCWSTR             lpPreviousAuthentInfoType,
              LPVOID              lpPreviousAuthentInfo,
              LPWSTR              lpStationName,
              LPVOID              StationHandle,
              LPWSTR              *lpLogonScript
              );
typedef DWORD (*PF_NPLogonNotify) (
                                  PLUID               lpLogonId,
                                  LPCWSTR             lpAuthentInfoType,
                                  LPVOID              lpAuthentInfo,
                                  LPCWSTR             lpPreviousAuthentInfoType,
                                  LPVOID              lpPreviousAuthentInfo,
                                  LPWSTR              lpStationName,
                                  LPVOID              StationHandle,
                                  LPWSTR              *lpLogonScript
                                  );

DWORD APIENTRY
NPPasswordChangeNotify (
                       LPCWSTR             lpAuthentInfoType,
                       LPVOID              lpAuthentInfo,
                       LPCWSTR             lpPreviousAuthentInfoType,
                       LPVOID              lpPreviousAuthentInfo,
                       LPWSTR              lpStationName,
                       LPVOID              StationHandle,
                       DWORD               dwChangeInfo
                       );

typedef DWORD (*PF_NPPasswordChangeNotify) (
                                           LPCWSTR             lpAuthentInfoType,
                                           LPVOID              lpAuthentInfo,
                                           LPCWSTR             lpPreviousAuthentInfoType,
                                           LPVOID              lpPreviousAuthentInfo,
                                           LPWSTR              lpStationName,
                                           LPVOID              StationHandle,
                                           DWORD               dwChangeInfo
                                           );

//
//  CONNECTION NOTIFICATION
//

//
// NotifyStatus
//
#define NOTIFY_PRE      0x00000001
#define NOTIFY_POST     0x00000002

typedef struct _NOTIFYINFO
{
   DWORD       dwNotifyStatus;
   DWORD       dwOperationStatus;
   LPVOID      lpContext;
} NOTIFYINFO, *LPNOTIFYINFO;

typedef struct _NOTIFYADD
{
   HWND            hwndOwner;
   NETRESOURCE     NetResource;
   DWORD           dwAddFlags;
} NOTIFYADD, *LPNOTIFYADD;

typedef struct _NOTIFYCANCEL
{
   LPTSTR      lpName;
   LPTSTR      lpProvider;
   DWORD       dwFlags;
   BOOL        fForce;
} NOTIFYCANCEL, *LPNOTIFYCANCEL;


DWORD APIENTRY
AddConnectNotify (
                 LPNOTIFYINFO        lpNotifyInfo,
                 LPNOTIFYADD         lpAddInfo
                 );

typedef DWORD (*PF_AddConnectNotify) (
                                     LPNOTIFYINFO        lpNotifyInfo,
                                     LPNOTIFYADD         lpAddInfo
                                     );

DWORD APIENTRY
CancelConnectNotify (
                    LPNOTIFYINFO        lpNotifyInfo,
                    LPNOTIFYCANCEL      lpCancelInfo
                    );

typedef DWORD (*PF_CancelConnectNotify) (
                                        LPNOTIFYINFO        lpNotifyInfo,
                                        LPNOTIFYCANCEL      lpCancelInfo
                                        );

//
// Permission editor dialogs
//

//
// Capabilities bits of permission editor dialogs
//
#define WNPERMC_PERM  0x00000001
#define WNPERMC_AUDIT 0x00000002
#define WNPERMC_OWNER 0x00000004

DWORD APIENTRY
NPFMXGetPermCaps (
                 LPWSTR lpDriveName
                 );

typedef DWORD (*PF_NPFMXGetPermCaps) (
                                     LPWSTR lpDriveName
                                     );

//
// Type of security dialog
//
#define WNPERM_DLG_PERM   0
#define WNPERM_DLG_AUDIT  1
#define WNPERM_DLG_OWNER  2

DWORD APIENTRY
NPFMXEditPerm (
              LPWSTR lpDriveName,
              HWND   hwndFMX,
              DWORD  nDialogType
              );

typedef DWORD (*PF_NPFMXEditPerm) (
                                  LPWSTR lpDriveName,
                                  HWND   hwndFMX,
                                  DWORD  nDialogType
                                  );

DWORD APIENTRY
NPFMXGetPermHelp (
                 LPWSTR  lpDriveName,
                 DWORD   nDialogType,
                 BOOL    fDirectory,
                 LPVOID  lpFileNameBuffer,
                 LPDWORD lpBufferSize,
                 LPDWORD lpnHelpContext
                 );

typedef DWORD (*PF_NPFMXGetPermHelp) (
                                     LPWSTR  lpDriveName,
                                     DWORD   nDialogType,
                                     BOOL    fDirectory,
                                     LPVOID  lpFileNameBuffer,
                                     LPDWORD lpBufferSize,
                                     LPDWORD lpnHelpContext
                                     );

#endif  // _NPAPI_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\nserror.h ===
/*++

  Microsoft Windows Media Technology
  Copyright (C) Microsoft Corporation.  All Rights Reserved.

Module Name:

    nserror.mc

Abstract:

    Definitions for Windows Media events.

Author:


Revision History:

Notes:

    This file is used by the MC tool to generate the nserror.h file

**************************** READ ME ******************************************

 Here are the commented error ranges for the Windows Media Technologies Group


 LEGACY RANGES

     0  -  199 = General NetShow errors

   200  -  399 = NetShow error events

   400  -  599 = NetShow monitor events

   600  -  799 = NetShow IMmsAutoServer errors

  1000  - 1199 = NetShow MCMADM errors


 NEW RANGES

  2000 -  2999 = ASF (defined in ASFERR.MC)

  3000 -  3999 = Windows Media SDK

  4000 -  4999 = Windows Media Player

  5000 -  5999 = Windows Media Server

  6000 -  6999 = Windows Media HTTP/RTSP result codes (defined in NETERROR.MC)

  7000 -  7999 = Windows Media Tools

  8000 -  8999 = Windows Media Content Discovery

  9000 -  9999 = Windows Media Real Time Collaboration

 10000 - 10999 = Windows Media Digital Rights Management

 11000 - 11999 = Windows Media Setup

 12000 - 12999 = Windows Media Networking

 13000 - 13999 = Windows Media Client Media Services

**************************** READ ME ******************************************

--*/

#ifndef _NSERROR_H
#define _NSERROR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)

#ifdef RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) _sc
#else // RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)
#endif // RC_INVOKED


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Success Events
//
/////////////////////////////////////////////////////////////////////////

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_NS_WIN32                0x7
#define FACILITY_NS                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: NS_S_CALLPENDING
//
// MessageText:
//
// The requested operation is pending completion.%0
//
#define NS_S_CALLPENDING                 _HRESULT_TYPEDEF_(0x000D0000L)

//
// MessageId: NS_S_CALLABORTED
//
// MessageText:
//
// The requested operation was aborted by the client.%0
//
#define NS_S_CALLABORTED                 _HRESULT_TYPEDEF_(0x000D0001L)

//
// MessageId: NS_S_STREAM_TRUNCATED
//
// MessageText:
//
// The stream was purposefully stopped before completion.%0
//
#define NS_S_STREAM_TRUNCATED            _HRESULT_TYPEDEF_(0x000D0002L)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Warning Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_W_SERVER_BANDWIDTH_LIMIT
//
// MessageText:
//
// The maximum filebitrate value specified is greater than the server's configured maximum bandwidth.%0
//
#define NS_W_SERVER_BANDWIDTH_LIMIT      _HRESULT_TYPEDEF_(0x800D0003L)

//
// MessageId: NS_W_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
// The maximum bandwidth value specified is less than the maximum filebitrate.%0
//
#define NS_W_FILE_BANDWIDTH_LIMIT        _HRESULT_TYPEDEF_(0x800D0004L)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_NOCONNECTION
//
// MessageText:
//
// There is no connection established with the Windows Media server. The operation failed.%0
//
#define NS_E_NOCONNECTION                _HRESULT_TYPEDEF_(0xC00D0005L)

//
// MessageId: NS_E_CANNOTCONNECT
//
// MessageText:
//
// Unable to establish a connection to the server.%0
//
#define NS_E_CANNOTCONNECT               _HRESULT_TYPEDEF_(0xC00D0006L)

//
// MessageId: NS_E_CANNOTDESTROYTITLE
//
// MessageText:
//
// Unable to destroy the title.%0
//
#define NS_E_CANNOTDESTROYTITLE          _HRESULT_TYPEDEF_(0xC00D0007L)

//
// MessageId: NS_E_CANNOTRENAMETITLE
//
// MessageText:
//
// Unable to rename the title.%0
//
#define NS_E_CANNOTRENAMETITLE           _HRESULT_TYPEDEF_(0xC00D0008L)

//
// MessageId: NS_E_CANNOTOFFLINEDISK
//
// MessageText:
//
// Unable to offline disk.%0
//
#define NS_E_CANNOTOFFLINEDISK           _HRESULT_TYPEDEF_(0xC00D0009L)

//
// MessageId: NS_E_CANNOTONLINEDISK
//
// MessageText:
//
// Unable to online disk.%0
//
#define NS_E_CANNOTONLINEDISK            _HRESULT_TYPEDEF_(0xC00D000AL)

//
// MessageId: NS_E_NOREGISTEREDWALKER
//
// MessageText:
//
// There is no file parser registered for this type of file.%0
//
#define NS_E_NOREGISTEREDWALKER          _HRESULT_TYPEDEF_(0xC00D000BL)

//
// MessageId: NS_E_NOFUNNEL
//
// MessageText:
//
// There is no data connection established.%0
//
#define NS_E_NOFUNNEL                    _HRESULT_TYPEDEF_(0xC00D000CL)

//
// MessageId: NS_E_NO_LOCALPLAY
//
// MessageText:
//
// Failed to load the local play DLL.%0
//
#define NS_E_NO_LOCALPLAY                _HRESULT_TYPEDEF_(0xC00D000DL)

//
// MessageId: NS_E_NETWORK_BUSY
//
// MessageText:
//
// The network is busy.%0
//
#define NS_E_NETWORK_BUSY                _HRESULT_TYPEDEF_(0xC00D000EL)

//
// MessageId: NS_E_TOO_MANY_SESS
//
// MessageText:
//
// The server session limit was exceeded.%0
//
#define NS_E_TOO_MANY_SESS               _HRESULT_TYPEDEF_(0xC00D000FL)

//
// MessageId: NS_E_ALREADY_CONNECTED
//
// MessageText:
//
// The network connection already exists.%0
//
#define NS_E_ALREADY_CONNECTED           _HRESULT_TYPEDEF_(0xC00D0010L)

//
// MessageId: NS_E_INVALID_INDEX
//
// MessageText:
//
// Index %1 is invalid.%0
//
#define NS_E_INVALID_INDEX               _HRESULT_TYPEDEF_(0xC00D0011L)

//
// MessageId: NS_E_PROTOCOL_MISMATCH
//
// MessageText:
//
// There is no protocol or protocol version supported by both the client and the server.%0
//
#define NS_E_PROTOCOL_MISMATCH           _HRESULT_TYPEDEF_(0xC00D0012L)

//
// MessageId: NS_E_TIMEOUT
//
// MessageText:
//
// The server, a computer set up to offer multimedia content to other computers, could not handle your request for multimedia content in a timely manner.  Please try again later.%0
//
#define NS_E_TIMEOUT                     _HRESULT_TYPEDEF_(0xC00D0013L)

//
// MessageId: NS_E_NET_WRITE
//
// MessageText:
//
// Error writing to the network.%0
//
#define NS_E_NET_WRITE                   _HRESULT_TYPEDEF_(0xC00D0014L)

//
// MessageId: NS_E_NET_READ
//
// MessageText:
//
// Error reading from the network.%0
//
#define NS_E_NET_READ                    _HRESULT_TYPEDEF_(0xC00D0015L)

//
// MessageId: NS_E_DISK_WRITE
//
// MessageText:
//
// Error writing to a disk.%0
//
#define NS_E_DISK_WRITE                  _HRESULT_TYPEDEF_(0xC00D0016L)

//
// MessageId: NS_E_DISK_READ
//
// MessageText:
//
// Error reading from a disk.%0
//
#define NS_E_DISK_READ                   _HRESULT_TYPEDEF_(0xC00D0017L)

//
// MessageId: NS_E_FILE_WRITE
//
// MessageText:
//
// Error writing to a file.%0
//
#define NS_E_FILE_WRITE                  _HRESULT_TYPEDEF_(0xC00D0018L)

//
// MessageId: NS_E_FILE_READ
//
// MessageText:
//
// Error reading from a file.%0
//
#define NS_E_FILE_READ                   _HRESULT_TYPEDEF_(0xC00D0019L)

//
// MessageId: NS_E_FILE_NOT_FOUND
//
// MessageText:
//
// The system cannot find the file specified.%0
//
#define NS_E_FILE_NOT_FOUND              _HRESULT_TYPEDEF_(0xC00D001AL)

//
// MessageId: NS_E_FILE_EXISTS
//
// MessageText:
//
// The file already exists.%0
//
#define NS_E_FILE_EXISTS                 _HRESULT_TYPEDEF_(0xC00D001BL)

//
// MessageId: NS_E_INVALID_NAME
//
// MessageText:
//
// The file name, directory name, or volume label syntax is incorrect.%0
//
#define NS_E_INVALID_NAME                _HRESULT_TYPEDEF_(0xC00D001CL)

//
// MessageId: NS_E_FILE_OPEN_FAILED
//
// MessageText:
//
// Failed to open a file.%0
//
#define NS_E_FILE_OPEN_FAILED            _HRESULT_TYPEDEF_(0xC00D001DL)

//
// MessageId: NS_E_FILE_ALLOCATION_FAILED
//
// MessageText:
//
// Unable to allocate a file.%0
//
#define NS_E_FILE_ALLOCATION_FAILED      _HRESULT_TYPEDEF_(0xC00D001EL)

//
// MessageId: NS_E_FILE_INIT_FAILED
//
// MessageText:
//
// Unable to initialize a file.%0
//
#define NS_E_FILE_INIT_FAILED            _HRESULT_TYPEDEF_(0xC00D001FL)

//
// MessageId: NS_E_FILE_PLAY_FAILED
//
// MessageText:
//
// Unable to play a file.%0
//
#define NS_E_FILE_PLAY_FAILED            _HRESULT_TYPEDEF_(0xC00D0020L)

//
// MessageId: NS_E_SET_DISK_UID_FAILED
//
// MessageText:
//
// Could not set the disk UID.%0
//
#define NS_E_SET_DISK_UID_FAILED         _HRESULT_TYPEDEF_(0xC00D0021L)

//
// MessageId: NS_E_INDUCED
//
// MessageText:
//
// An error was induced for testing purposes.%0
//
#define NS_E_INDUCED                     _HRESULT_TYPEDEF_(0xC00D0022L)

//
// MessageId: NS_E_CCLINK_DOWN
//
// MessageText:
//
// Two Content Servers failed to communicate.%0
//
#define NS_E_CCLINK_DOWN                 _HRESULT_TYPEDEF_(0xC00D0023L)

//
// MessageId: NS_E_INTERNAL
//
// MessageText:
//
// An unknown error occurred.%0
//
#define NS_E_INTERNAL                    _HRESULT_TYPEDEF_(0xC00D0024L)

//
// MessageId: NS_E_BUSY
//
// MessageText:
//
// The requested resource is in use.%0
//
#define NS_E_BUSY                        _HRESULT_TYPEDEF_(0xC00D0025L)

//
// MessageId: NS_E_UNRECOGNIZED_STREAM_TYPE
//
// MessageText:
//
// The specified protocol is not recognized. Be sure that the file name and syntax, such as slashes, are correct for the protocol.%0
//
#define NS_E_UNRECOGNIZED_STREAM_TYPE    _HRESULT_TYPEDEF_(0xC00D0026L)

//
// MessageId: NS_E_NETWORK_SERVICE_FAILURE
//
// MessageText:
//
// The network service provider failed.%0
//
#define NS_E_NETWORK_SERVICE_FAILURE     _HRESULT_TYPEDEF_(0xC00D0027L)

//
// MessageId: NS_E_NETWORK_RESOURCE_FAILURE
//
// MessageText:
//
// An attempt to acquire a network resource failed.%0
//
#define NS_E_NETWORK_RESOURCE_FAILURE    _HRESULT_TYPEDEF_(0xC00D0028L)

//
// MessageId: NS_E_CONNECTION_FAILURE
//
// MessageText:
//
// The network connection has failed.%0
//
#define NS_E_CONNECTION_FAILURE          _HRESULT_TYPEDEF_(0xC00D0029L)

//
// MessageId: NS_E_SHUTDOWN
//
// MessageText:
//
// The session is being terminated locally.%0
//
#define NS_E_SHUTDOWN                    _HRESULT_TYPEDEF_(0xC00D002AL)

//
// MessageId: NS_E_INVALID_REQUEST
//
// MessageText:
//
// The request is invalid in the current state.%0
//
#define NS_E_INVALID_REQUEST             _HRESULT_TYPEDEF_(0xC00D002BL)

//
// MessageId: NS_E_INSUFFICIENT_BANDWIDTH
//
// MessageText:
//
// There is insufficient bandwidth available to fulfill the request.%0
//
#define NS_E_INSUFFICIENT_BANDWIDTH      _HRESULT_TYPEDEF_(0xC00D002CL)

//
// MessageId: NS_E_NOT_REBUILDING
//
// MessageText:
//
// The disk is not rebuilding.%0
//
#define NS_E_NOT_REBUILDING              _HRESULT_TYPEDEF_(0xC00D002DL)

//
// MessageId: NS_E_LATE_OPERATION
//
// MessageText:
//
// An operation requested for a particular time could not be carried out on schedule.%0
//
#define NS_E_LATE_OPERATION              _HRESULT_TYPEDEF_(0xC00D002EL)

//
// MessageId: NS_E_INVALID_DATA
//
// MessageText:
//
// Invalid or corrupt data was encountered.%0
//
#define NS_E_INVALID_DATA                _HRESULT_TYPEDEF_(0xC00D002FL)

//
// MessageId: NS_E_FILE_BANDWIDTH_LIMIT
//
// MessageText:
//
// The bandwidth required to stream a file is higher than the maximum file bandwidth allowed on the server.%0
//
#define NS_E_FILE_BANDWIDTH_LIMIT        _HRESULT_TYPEDEF_(0xC00D0030L)

//
// MessageId: NS_E_OPEN_FILE_LIMIT
//
// MessageText:
//
// The client cannot have any more files open simultaneously.%0
//
#define NS_E_OPEN_FILE_LIMIT             _HRESULT_TYPEDEF_(0xC00D0031L)

//
// MessageId: NS_E_BAD_CONTROL_DATA
//
// MessageText:
//
// The server received invalid data from the client on the control connection.%0
//
#define NS_E_BAD_CONTROL_DATA            _HRESULT_TYPEDEF_(0xC00D0032L)

//
// MessageId: NS_E_NO_STREAM
//
// MessageText:
//
// There is no stream available.%0
//
#define NS_E_NO_STREAM                   _HRESULT_TYPEDEF_(0xC00D0033L)

//
// MessageId: NS_E_STREAM_END
//
// MessageText:
//
// There is no more data in the stream.%0
//
#define NS_E_STREAM_END                  _HRESULT_TYPEDEF_(0xC00D0034L)

//
// MessageId: NS_E_SERVER_NOT_FOUND
//
// MessageText:
//
// The specified server could not be found.%0
//
#define NS_E_SERVER_NOT_FOUND            _HRESULT_TYPEDEF_(0xC00D0035L)

//
// MessageId: NS_E_DUPLICATE_NAME
//
// MessageText:
//
// The specified name is already in use.
//
#define NS_E_DUPLICATE_NAME              _HRESULT_TYPEDEF_(0xC00D0036L)

//
// MessageId: NS_E_DUPLICATE_ADDRESS
//
// MessageText:
//
// The specified address is already in use.
//
#define NS_E_DUPLICATE_ADDRESS           _HRESULT_TYPEDEF_(0xC00D0037L)

//
// MessageId: NS_E_BAD_MULTICAST_ADDRESS
//
// MessageText:
//
// The specified address is not a valid multicast address.
//
#define NS_E_BAD_MULTICAST_ADDRESS       _HRESULT_TYPEDEF_(0xC00D0038L)

//
// MessageId: NS_E_BAD_ADAPTER_ADDRESS
//
// MessageText:
//
// The specified adapter address is invalid.
//
#define NS_E_BAD_ADAPTER_ADDRESS         _HRESULT_TYPEDEF_(0xC00D0039L)

//
// MessageId: NS_E_BAD_DELIVERY_MODE
//
// MessageText:
//
// The specified delivery mode is invalid.
//
#define NS_E_BAD_DELIVERY_MODE           _HRESULT_TYPEDEF_(0xC00D003AL)

//
// MessageId: NS_E_INVALID_CHANNEL
//
// MessageText:
//
// The specified station does not exist.
//
#define NS_E_INVALID_CHANNEL             _HRESULT_TYPEDEF_(0xC00D003BL)

//
// MessageId: NS_E_INVALID_STREAM
//
// MessageText:
//
// The specified stream does not exist.
//
#define NS_E_INVALID_STREAM              _HRESULT_TYPEDEF_(0xC00D003CL)

//
// MessageId: NS_E_INVALID_ARCHIVE
//
// MessageText:
//
// The specified archive could not be opened.
//
#define NS_E_INVALID_ARCHIVE             _HRESULT_TYPEDEF_(0xC00D003DL)

//
// MessageId: NS_E_NOTITLES
//
// MessageText:
//
// The system cannot find any titles on the server.%0
//
#define NS_E_NOTITLES                    _HRESULT_TYPEDEF_(0xC00D003EL)

//
// MessageId: NS_E_INVALID_CLIENT
//
// MessageText:
//
// The system cannot find the client specified.%0
//
#define NS_E_INVALID_CLIENT              _HRESULT_TYPEDEF_(0xC00D003FL)

//
// MessageId: NS_E_INVALID_BLACKHOLE_ADDRESS
//
// MessageText:
//
// The Blackhole Address is not initialized.%0
//
#define NS_E_INVALID_BLACKHOLE_ADDRESS   _HRESULT_TYPEDEF_(0xC00D0040L)

//
// MessageId: NS_E_INCOMPATIBLE_FORMAT
//
// MessageText:
//
// The station does not support the stream format.
//
#define NS_E_INCOMPATIBLE_FORMAT         _HRESULT_TYPEDEF_(0xC00D0041L)

//
// MessageId: NS_E_INVALID_KEY
//
// MessageText:
//
// The specified key is not valid.
//
#define NS_E_INVALID_KEY                 _HRESULT_TYPEDEF_(0xC00D0042L)

//
// MessageId: NS_E_INVALID_PORT
//
// MessageText:
//
// The specified port is not valid.
//
#define NS_E_INVALID_PORT                _HRESULT_TYPEDEF_(0xC00D0043L)

//
// MessageId: NS_E_INVALID_TTL
//
// MessageText:
//
// The specified TTL is not valid.
//
#define NS_E_INVALID_TTL                 _HRESULT_TYPEDEF_(0xC00D0044L)

//
// MessageId: NS_E_STRIDE_REFUSED
//
// MessageText:
//
// The request to fast forward or rewind could not be fulfilled.
//
#define NS_E_STRIDE_REFUSED              _HRESULT_TYPEDEF_(0xC00D0045L)

//
// IMmsAutoServer Errors
//
//
// MessageId: NS_E_MMSAUTOSERVER_CANTFINDWALKER
//
// MessageText:
//
// Unable to load the appropriate file parser.%0
//
#define NS_E_MMSAUTOSERVER_CANTFINDWALKER _HRESULT_TYPEDEF_(0xC00D0046L)

//
// MessageId: NS_E_MAX_BITRATE
//
// MessageText:
//
// Cannot exceed the maximum bandwidth limit.%0
//
#define NS_E_MAX_BITRATE                 _HRESULT_TYPEDEF_(0xC00D0047L)

//
// MessageId: NS_E_LOGFILEPERIOD
//
// MessageText:
//
// Invalid value for LogFilePeriod.%0
//
#define NS_E_LOGFILEPERIOD               _HRESULT_TYPEDEF_(0xC00D0048L)

//
// MessageId: NS_E_MAX_CLIENTS
//
// MessageText:
//
// Cannot exceed the maximum client limit.%0
// 
//
#define NS_E_MAX_CLIENTS                 _HRESULT_TYPEDEF_(0xC00D0049L)

//
// MessageId: NS_E_LOG_FILE_SIZE
//
// MessageText:
//
// The maximum log file size has been reached.%0
// 
//
#define NS_E_LOG_FILE_SIZE               _HRESULT_TYPEDEF_(0xC00D004AL)

//
// MessageId: NS_E_MAX_FILERATE
//
// MessageText:
//
// Cannot exceed the maximum file rate.%0
//
#define NS_E_MAX_FILERATE                _HRESULT_TYPEDEF_(0xC00D004BL)

//
// File Walker Errors
//
//
// MessageId: NS_E_WALKER_UNKNOWN
//
// MessageText:
//
// Unknown file type.%0
//
#define NS_E_WALKER_UNKNOWN              _HRESULT_TYPEDEF_(0xC00D004CL)

//
// MessageId: NS_E_WALKER_SERVER
//
// MessageText:
//
// The specified file, %1, cannot be loaded onto the specified server, %2.%0
//
#define NS_E_WALKER_SERVER               _HRESULT_TYPEDEF_(0xC00D004DL)

//
// MessageId: NS_E_WALKER_USAGE
//
// MessageText:
//
// There was a usage error with file parser.%0
//
#define NS_E_WALKER_USAGE                _HRESULT_TYPEDEF_(0xC00D004EL)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Monitor Events
//
/////////////////////////////////////////////////////////////////////////


 // Tiger Events

 // %1 is the tiger name

//
// MessageId: NS_I_TIGER_START
//
// MessageText:
//
// The Title Server %1 is running.%0
//
#define NS_I_TIGER_START                 _HRESULT_TYPEDEF_(0x400D004FL)

//
// MessageId: NS_E_TIGER_FAIL
//
// MessageText:
//
// The Title Server %1 has failed.%0
//
#define NS_E_TIGER_FAIL                  _HRESULT_TYPEDEF_(0xC00D0050L)


 // Cub Events

 // %1 is the cub ID
 // %2 is the cub name

//
// MessageId: NS_I_CUB_START
//
// MessageText:
//
// Content Server %1 (%2) is starting.%0
//
#define NS_I_CUB_START                   _HRESULT_TYPEDEF_(0x400D0051L)

//
// MessageId: NS_I_CUB_RUNNING
//
// MessageText:
//
// Content Server %1 (%2) is running.%0
//
#define NS_I_CUB_RUNNING                 _HRESULT_TYPEDEF_(0x400D0052L)

//
// MessageId: NS_E_CUB_FAIL
//
// MessageText:
//
// Content Server %1 (%2) has failed.%0
//
#define NS_E_CUB_FAIL                    _HRESULT_TYPEDEF_(0xC00D0053L)


 // Disk Events

 // %1 is the tiger disk ID
 // %2 is the device name
 // %3 is the cub ID
//
// MessageId: NS_I_DISK_START
//
// MessageText:
//
// Disk %1 ( %2 ) on Content Server %3, is running.%0
//
#define NS_I_DISK_START                  _HRESULT_TYPEDEF_(0x400D0054L)

//
// MessageId: NS_E_DISK_FAIL
//
// MessageText:
//
// Disk %1 ( %2 ) on Content Server %3, has failed.%0
//
#define NS_E_DISK_FAIL                   _HRESULT_TYPEDEF_(0xC00D0055L)

//
// MessageId: NS_I_DISK_REBUILD_STARTED
//
// MessageText:
//
// Started rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_STARTED        _HRESULT_TYPEDEF_(0x400D0056L)

//
// MessageId: NS_I_DISK_REBUILD_FINISHED
//
// MessageText:
//
// Finished rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_FINISHED       _HRESULT_TYPEDEF_(0x400D0057L)

//
// MessageId: NS_I_DISK_REBUILD_ABORTED
//
// MessageText:
//
// Aborted rebuilding disk %1 ( %2 ) on Content Server %3.%0
//
#define NS_I_DISK_REBUILD_ABORTED        _HRESULT_TYPEDEF_(0x400D0058L)


 // Admin Events

//
// MessageId: NS_I_LIMIT_FUNNELS
//
// MessageText:
//
// A NetShow administrator at network location %1 set the data stream limit to %2 streams.%0
//
#define NS_I_LIMIT_FUNNELS               _HRESULT_TYPEDEF_(0x400D0059L)

//
// MessageId: NS_I_START_DISK
//
// MessageText:
//
// A NetShow administrator at network location %1 started disk %2.%0
//
#define NS_I_START_DISK                  _HRESULT_TYPEDEF_(0x400D005AL)

//
// MessageId: NS_I_STOP_DISK
//
// MessageText:
//
// A NetShow administrator at network location %1 stopped disk %2.%0
//
#define NS_I_STOP_DISK                   _HRESULT_TYPEDEF_(0x400D005BL)

//
// MessageId: NS_I_STOP_CUB
//
// MessageText:
//
// A NetShow administrator at network location %1 stopped Content Server %2.%0
//
#define NS_I_STOP_CUB                    _HRESULT_TYPEDEF_(0x400D005CL)

//
// MessageId: NS_I_KILL_USERSESSION
//
// MessageText:
//
// A NetShow administrator at network location %1 aborted user session %2 from the system.%0
//
#define NS_I_KILL_USERSESSION            _HRESULT_TYPEDEF_(0x400D005DL)

//
// MessageId: NS_I_KILL_CONNECTION
//
// MessageText:
//
// A NetShow administrator at network location %1 aborted obsolete connection %2 from the system.%0
//
#define NS_I_KILL_CONNECTION             _HRESULT_TYPEDEF_(0x400D005EL)

//
// MessageId: NS_I_REBUILD_DISK
//
// MessageText:
//
// A NetShow administrator at network location %1 started rebuilding disk %2.%0
//
#define NS_I_REBUILD_DISK                _HRESULT_TYPEDEF_(0x400D005FL)

//
// MessageId: NS_W_UNKNOWN_EVENT
//
// MessageText:
//
// Unknown %1 event encountered.%0
//
#define NS_W_UNKNOWN_EVENT               _HRESULT_TYPEDEF_(0x800D0060L)


 // Alerts

//
// MessageId: NS_E_MAX_FUNNELS_ALERT
//
// MessageText:
//
// The NetShow data stream limit of %1 streams was reached.%0
//
#define NS_E_MAX_FUNNELS_ALERT           _HRESULT_TYPEDEF_(0xC00D0060L)

//
// MessageId: NS_E_ALLOCATE_FILE_FAIL
//
// MessageText:
//
// The NetShow Video Server was unable to allocate a %1 block file named %2.%0
//
#define NS_E_ALLOCATE_FILE_FAIL          _HRESULT_TYPEDEF_(0xC00D0061L)

//
// MessageId: NS_E_PAGING_ERROR
//
// MessageText:
//
// A Content Server was unable to page a block.%0
//
#define NS_E_PAGING_ERROR                _HRESULT_TYPEDEF_(0xC00D0062L)

//
// MessageId: NS_E_BAD_BLOCK0_VERSION
//
// MessageText:
//
// Disk %1 has unrecognized control block version %2.%0
//
#define NS_E_BAD_BLOCK0_VERSION          _HRESULT_TYPEDEF_(0xC00D0063L)

//
// MessageId: NS_E_BAD_DISK_UID
//
// MessageText:
//
// Disk %1 has incorrect uid %2.%0
//
#define NS_E_BAD_DISK_UID                _HRESULT_TYPEDEF_(0xC00D0064L)

//
// MessageId: NS_E_BAD_FSMAJOR_VERSION
//
// MessageText:
//
// Disk %1 has unsupported file system major version %2.%0
//
#define NS_E_BAD_FSMAJOR_VERSION         _HRESULT_TYPEDEF_(0xC00D0065L)

//
// MessageId: NS_E_BAD_STAMPNUMBER
//
// MessageText:
//
// Disk %1 has bad stamp number in control block.%0
//
#define NS_E_BAD_STAMPNUMBER             _HRESULT_TYPEDEF_(0xC00D0066L)

//
// MessageId: NS_E_PARTIALLY_REBUILT_DISK
//
// MessageText:
//
// Disk %1 is partially reconstructed.%0
//
#define NS_E_PARTIALLY_REBUILT_DISK      _HRESULT_TYPEDEF_(0xC00D0067L)

//
// MessageId: NS_E_ENACTPLAN_GIVEUP
//
// MessageText:
//
// EnactPlan gives up.%0
//
#define NS_E_ENACTPLAN_GIVEUP            _HRESULT_TYPEDEF_(0xC00D0068L)


 // MCMADM warnings/errors

//
// MessageId: MCMADM_I_NO_EVENTS
//
// MessageText:
//
// Event initialization failed, there will be no MCM events.%0
//
#define MCMADM_I_NO_EVENTS               _HRESULT_TYPEDEF_(0x400D0069L)

//
// MessageId: MCMADM_E_REGKEY_NOT_FOUND
//
// MessageText:
//
// The key was not found in the registry.%0
//
#define MCMADM_E_REGKEY_NOT_FOUND        _HRESULT_TYPEDEF_(0xC00D006AL)

//
// MessageId: NS_E_NO_FORMATS
//
// MessageText:
//
// The publishing point cannot be started because the server does not have the appropriate stream formats. Use the Multicast Announcement Wizard to create a new announcement for this publishing point.%0
//
#define NS_E_NO_FORMATS                  _HRESULT_TYPEDEF_(0xC00D006BL)

//
// MessageId: NS_E_NO_REFERENCES
//
// MessageText:
//
// No reference URLs were found in an ASX file.%0
//
#define NS_E_NO_REFERENCES               _HRESULT_TYPEDEF_(0xC00D006CL)

//
// MessageId: NS_E_WAVE_OPEN
//
// MessageText:
//
// Error opening wave device, the device might be in use.%0
//
#define NS_E_WAVE_OPEN                   _HRESULT_TYPEDEF_(0xC00D006DL)

//
// MessageId: NS_I_LOGGING_FAILED
//
// MessageText:
//
// The logging operation failed.
//
#define NS_I_LOGGING_FAILED              _HRESULT_TYPEDEF_(0x400D006EL)

//
// MessageId: NS_E_CANNOTCONNECTEVENTS
//
// MessageText:
//
// Unable to establish a connection to the NetShow event monitor service.%0
//
#define NS_E_CANNOTCONNECTEVENTS         _HRESULT_TYPEDEF_(0xC00D006FL)

//
// MessageId: NS_I_LIMIT_BANDWIDTH
//
// MessageText:
//
// A NetShow administrator at network location %1 set the maximum bandwidth limit to %2 bps.%0
//
#define NS_I_LIMIT_BANDWIDTH             _HRESULT_TYPEDEF_(0x400D0070L)

//
// MessageId: NS_E_NO_DEVICE
//
// MessageText:
//
// No device driver is present on the system.%0
//
#define NS_E_NO_DEVICE                   _HRESULT_TYPEDEF_(0xC00D0071L)

//
// MessageId: NS_E_NO_SPECIFIED_DEVICE
//
// MessageText:
//
// No specified device driver is present.%0
//
#define NS_E_NO_SPECIFIED_DEVICE         _HRESULT_TYPEDEF_(0xC00D0072L)


// NOTENOTE!!!
//
// Due to legacy problems these error codes live inside the ASF error code range
//
//
// MessageId: NS_E_NOTHING_TO_DO
//
// MessageText:
//
//  NS_E_NOTHING_TO_DO
//
#define NS_E_NOTHING_TO_DO               _HRESULT_TYPEDEF_(0xC00D07F1L)

//
// MessageId: NS_E_NO_MULTICAST
//
// MessageText:
//
// Not receiving data from the server.%0
//
#define NS_E_NO_MULTICAST                _HRESULT_TYPEDEF_(0xC00D07F2L)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Error Events
//
// IdRange = 200..399
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_MONITOR_GIVEUP
//
// MessageText:
//
// Netshow Events Monitor is not operational and has been disconnected.%0
//
#define NS_E_MONITOR_GIVEUP              _HRESULT_TYPEDEF_(0xC00D00C8L)

//
// MessageId: NS_E_REMIRRORED_DISK
//
// MessageText:
//
// Disk %1 is remirrored.%0
//
#define NS_E_REMIRRORED_DISK             _HRESULT_TYPEDEF_(0xC00D00C9L)

//
// MessageId: NS_E_INSUFFICIENT_DATA
//
// MessageText:
//
// Insufficient data found.%0
//
#define NS_E_INSUFFICIENT_DATA           _HRESULT_TYPEDEF_(0xC00D00CAL)

//
// MessageId: NS_E_ASSERT
//
// MessageText:
//
// %1 failed in file %2 line %3.%0
//
#define NS_E_ASSERT                      _HRESULT_TYPEDEF_(0xC00D00CBL)

//
// MessageId: NS_E_BAD_ADAPTER_NAME
//
// MessageText:
//
// The specified adapter name is invalid.%0
//
#define NS_E_BAD_ADAPTER_NAME            _HRESULT_TYPEDEF_(0xC00D00CCL)

//
// MessageId: NS_E_NOT_LICENSED
//
// MessageText:
//
// The application is not licensed for this feature.%0
//
#define NS_E_NOT_LICENSED                _HRESULT_TYPEDEF_(0xC00D00CDL)

//
// MessageId: NS_E_NO_SERVER_CONTACT
//
// MessageText:
//
// Unable to contact the server.%0
//
#define NS_E_NO_SERVER_CONTACT           _HRESULT_TYPEDEF_(0xC00D00CEL)

//
// MessageId: NS_E_TOO_MANY_TITLES
//
// MessageText:
//
// Maximum number of titles exceeded.%0
//
#define NS_E_TOO_MANY_TITLES             _HRESULT_TYPEDEF_(0xC00D00CFL)

//
// MessageId: NS_E_TITLE_SIZE_EXCEEDED
//
// MessageText:
//
// Maximum size of a title exceeded.%0
//
#define NS_E_TITLE_SIZE_EXCEEDED         _HRESULT_TYPEDEF_(0xC00D00D0L)

//
// MessageId: NS_E_UDP_DISABLED
//
// MessageText:
//
// UDP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_UDP_DISABLED                _HRESULT_TYPEDEF_(0xC00D00D1L)

//
// MessageId: NS_E_TCP_DISABLED
//
// MessageText:
//
// TCP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_TCP_DISABLED                _HRESULT_TYPEDEF_(0xC00D00D2L)

//
// MessageId: NS_E_HTTP_DISABLED
//
// MessageText:
//
// HTTP protocol not enabled. Not trying %1!ls!.%0
//
#define NS_E_HTTP_DISABLED               _HRESULT_TYPEDEF_(0xC00D00D3L)

//
// MessageId: NS_E_LICENSE_EXPIRED
//
// MessageText:
//
// The product license has expired.%0
//
#define NS_E_LICENSE_EXPIRED             _HRESULT_TYPEDEF_(0xC00D00D4L)

//
// MessageId: NS_E_TITLE_BITRATE
//
// MessageText:
//
// Source file exceeds the per title maximum bitrate. See NetShow Theater documentation for more information.%0
//
#define NS_E_TITLE_BITRATE               _HRESULT_TYPEDEF_(0xC00D00D5L)

//
// MessageId: NS_E_EMPTY_PROGRAM_NAME
//
// MessageText:
//
// The program name cannot be empty.%0
//
#define NS_E_EMPTY_PROGRAM_NAME          _HRESULT_TYPEDEF_(0xC00D00D6L)

//
// MessageId: NS_E_MISSING_CHANNEL
//
// MessageText:
//
// Station %1 does not exist.%0
//
#define NS_E_MISSING_CHANNEL             _HRESULT_TYPEDEF_(0xC00D00D7L)

//
// MessageId: NS_E_NO_CHANNELS
//
// MessageText:
//
// You need to define at least one station before this operation can complete.%0
//
#define NS_E_NO_CHANNELS                 _HRESULT_TYPEDEF_(0xC00D00D8L)


/////////////////////////////////////////////////////////////////////
// This error message is to replace previous NS_E_INVALID_INDEX which
// takes an index value for the error message string.  For some application
// obtain the idex value at reporting error time is very difficult, so we
// use this string to avoid the problem.
//////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_INVALID_INDEX2
//
// MessageText:
//
// The index specified is invalid.%0
//
#define NS_E_INVALID_INDEX2              _HRESULT_TYPEDEF_(0xC00D00D9L)


/////////////////////////////////////////////////////////////////////////
//
// NETSHOW Monitor Events
//
// IdRange = 400..599
//
// Admin Events:
//
// Alerts:
//
// Title Server:
//      %1 is the Title Server name
//
// Content Server:
//      %1 is the Content Server ID
//      %2 is the Content Server name
//      %3 is the Peer Content Server name (optional)
//
// Disks:
//      %1 is the Title Server disk ID
//      %2 is the device name
//      %3 is the Content Server ID
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_CUB_FAIL_LINK
//
// MessageText:
//
// Content Server %1 (%2) has failed its link to Content Server %3.%0
//
#define NS_E_CUB_FAIL_LINK               _HRESULT_TYPEDEF_(0xC00D0190L)

//
// MessageId: NS_I_CUB_UNFAIL_LINK
//
// MessageText:
//
// Content Server %1 (%2) has established its link to Content Server %3.%0
//
#define NS_I_CUB_UNFAIL_LINK             _HRESULT_TYPEDEF_(0x400D0191L)

//
// MessageId: NS_E_BAD_CUB_UID
//
// MessageText:
//
// Content Server %1 (%2) has incorrect uid %3.%0
//
#define NS_E_BAD_CUB_UID                 _HRESULT_TYPEDEF_(0xC00D0192L)

//
// MessageId: NS_I_RESTRIPE_START
//
// MessageText:
//
// Restripe operation has started.%0
//
#define NS_I_RESTRIPE_START              _HRESULT_TYPEDEF_(0x400D0193L)

//
// MessageId: NS_I_RESTRIPE_DONE
//
// MessageText:
//
// Restripe operation has completed.%0
//
#define NS_I_RESTRIPE_DONE               _HRESULT_TYPEDEF_(0x400D0194L)

//
// MessageId: NS_E_GLITCH_MODE
//
// MessageText:
//
// Server unreliable because multiple components failed.%0
//
#define NS_E_GLITCH_MODE                 _HRESULT_TYPEDEF_(0xC00D0195L)

//
// MessageId: NS_I_RESTRIPE_DISK_OUT
//
// MessageText:
//
// Content disk %1 (%2) on Content Server %3 has been restriped out.%0
//
#define NS_I_RESTRIPE_DISK_OUT           _HRESULT_TYPEDEF_(0x400D0196L)

//
// MessageId: NS_I_RESTRIPE_CUB_OUT
//
// MessageText:
//
// Content server %1 (%2) has been restriped out.%0
//
#define NS_I_RESTRIPE_CUB_OUT            _HRESULT_TYPEDEF_(0x400D0197L)

//
// MessageId: NS_I_DISK_STOP
//
// MessageText:
//
// Disk %1 ( %2 ) on Content Server %3, has been offlined.%0
//
#define NS_I_DISK_STOP                   _HRESULT_TYPEDEF_(0x400D0198L)

//
// MessageId: NS_I_CATATONIC_FAILURE
//
// MessageText:
//
// Disk %1 ( %2 ) on Content Server %3, will be failed because it is catatonic.%0
//
#define NS_I_CATATONIC_FAILURE           _HRESULT_TYPEDEF_(0x800D0199L)

//
// MessageId: NS_I_CATATONIC_AUTO_UNFAIL
//
// MessageText:
//
// Disk %1 ( %2 ) on Content Server %3, auto online from catatonic state.%0
//
#define NS_I_CATATONIC_AUTO_UNFAIL       _HRESULT_TYPEDEF_(0x800D019AL)

//
// MessageId: NS_E_NO_MEDIA_PROTOCOL
//
// MessageText:
//
// Content Server %1 (%2) is unable to communicate with the Media System Network Protocol.%0
//
#define NS_E_NO_MEDIA_PROTOCOL           _HRESULT_TYPEDEF_(0xC00D019BL)


//
// Advanced Streaming Format (ASF) codes occupy MessageIds 2000-2999
//
// See ASFErr.mc for more details - please do not define any symbols
// in that range in this file.
//


/////////////////////////////////////////////////////////////////////////
//
// Windows Media SDK Errors
//
// IdRange = 3000-3199
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_INVALID_INPUT_FORMAT
//
// MessageText:
//
// The input media format is invalid.%0
//
#define NS_E_INVALID_INPUT_FORMAT        _HRESULT_TYPEDEF_(0xC00D0BB8L)

//
// MessageId: NS_E_MSAUDIO_NOT_INSTALLED
//
// MessageText:
//
// The MSAudio codec is not installed on this system.%0
//
#define NS_E_MSAUDIO_NOT_INSTALLED       _HRESULT_TYPEDEF_(0xC00D0BB9L)

//
// MessageId: NS_E_UNEXPECTED_MSAUDIO_ERROR
//
// MessageText:
//
// An unexpected error occurred with the MSAudio codec.%0
//
#define NS_E_UNEXPECTED_MSAUDIO_ERROR    _HRESULT_TYPEDEF_(0xC00D0BBAL)

//
// MessageId: NS_E_INVALID_OUTPUT_FORMAT
//
// MessageText:
//
// The output media format is invalid.%0
//
#define NS_E_INVALID_OUTPUT_FORMAT       _HRESULT_TYPEDEF_(0xC00D0BBBL)

//
// MessageId: NS_E_NOT_CONFIGURED
//
// MessageText:
//
// The object must be fully configured before audio samples can be processed.%0
//
#define NS_E_NOT_CONFIGURED              _HRESULT_TYPEDEF_(0xC00D0BBCL)

//
// MessageId: NS_E_PROTECTED_CONTENT
//
// MessageText:
//
// You need a license to perform the requested operation on this media file.%0
//
#define NS_E_PROTECTED_CONTENT           _HRESULT_TYPEDEF_(0xC00D0BBDL)

//
// MessageId: NS_E_LICENSE_REQUIRED
//
// MessageText:
//
// You need a license to perform the requested operation on this media file.%0
//
#define NS_E_LICENSE_REQUIRED            _HRESULT_TYPEDEF_(0xC00D0BBEL)

//
// MessageId: NS_E_TAMPERED_CONTENT
//
// MessageText:
//
// This media file is corrupted or invalid. Contact the content provider for a new file.%0
//
#define NS_E_TAMPERED_CONTENT            _HRESULT_TYPEDEF_(0xC00D0BBFL)

//
// MessageId: NS_E_LICENSE_OUTOFDATE
//
// MessageText:
//
// The license for this media file has expired. Get a new license or contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_OUTOFDATE           _HRESULT_TYPEDEF_(0xC00D0BC0L)

//
// MessageId: NS_E_LICENSE_INCORRECT_RIGHTS
//
// MessageText:
//
// You are not allowed to open this file. Contact the content provider for further assistance.%0
//
#define NS_E_LICENSE_INCORRECT_RIGHTS    _HRESULT_TYPEDEF_(0xC00D0BC1L)

//
// MessageId: NS_E_AUDIO_CODEC_NOT_INSTALLED
//
// MessageText:
//
// The requested audio codec is not installed on this system.%0
//
#define NS_E_AUDIO_CODEC_NOT_INSTALLED   _HRESULT_TYPEDEF_(0xC00D0BC2L)

//
// MessageId: NS_E_AUDIO_CODEC_ERROR
//
// MessageText:
//
// An unexpected error occurred with the audio codec.%0
//
#define NS_E_AUDIO_CODEC_ERROR           _HRESULT_TYPEDEF_(0xC00D0BC3L)

//
// MessageId: NS_E_VIDEO_CODEC_NOT_INSTALLED
//
// MessageText:
//
// The requested video codec is not installed on this system.%0
//
#define NS_E_VIDEO_CODEC_NOT_INSTALLED   _HRESULT_TYPEDEF_(0xC00D0BC4L)

//
// MessageId: NS_E_VIDEO_CODEC_ERROR
//
// MessageText:
//
// An unexpected error occurred with the video codec.%0
//
#define NS_E_VIDEO_CODEC_ERROR           _HRESULT_TYPEDEF_(0xC00D0BC5L)

//
// MessageId: NS_E_INVALIDPROFILE
//
// MessageText:
//
// The Profile is invalid.%0
//
#define NS_E_INVALIDPROFILE              _HRESULT_TYPEDEF_(0xC00D0BC6L)

//
// MessageId: NS_E_INCOMPATIBLE_VERSION
//
// MessageText:
//
// A new version of the SDK is needed to play the requested content.%0
//
#define NS_E_INCOMPATIBLE_VERSION        _HRESULT_TYPEDEF_(0xC00D0BC7L)

//
// MessageId: NS_S_REBUFFERING
//
// MessageText:
//
// The requested operation has caused the source to rebuffer.%0
//
#define NS_S_REBUFFERING                 _HRESULT_TYPEDEF_(0x000D0BC8L)

//
// MessageId: NS_S_DEGRADING_QUALITY
//
// MessageText:
//
// The requested operation has caused the source to degrade codec quality.%0
//
#define NS_S_DEGRADING_QUALITY           _HRESULT_TYPEDEF_(0x000D0BC9L)

//
// MessageId: NS_E_OFFLINE_MODE
//
// MessageText:
//
// The requested URL is not available in offline mode.%0
//
#define NS_E_OFFLINE_MODE                _HRESULT_TYPEDEF_(0xC00D0BCAL)

//
// MessageId: NS_E_NOT_CONNECTED
//
// MessageText:
//
// The requested URL cannot be accessed because there is no network connection.%0
//
#define NS_E_NOT_CONNECTED               _HRESULT_TYPEDEF_(0xC00D0BCBL)

//
// MessageId: NS_E_TOO_MUCH_DATA
//
// MessageText:
//
// The encoding process was unable to keep up with the amount of supplied data.%0
//
#define NS_E_TOO_MUCH_DATA               _HRESULT_TYPEDEF_(0xC00D0BCCL)

//
// MessageId: NS_E_UNSUPPORTED_PROPERTY
//
// MessageText:
//
// The given property is not supported.%0
//
#define NS_E_UNSUPPORTED_PROPERTY        _HRESULT_TYPEDEF_(0xC00D0BCDL)

//
// MessageId: NS_E_8BIT_WAVE_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player cannot copy the files to the CD because they are 8-bit. Convert the files to 16-bit, 44-kHz stereo files by using Sound Recorder or another audio-processing program, and then try again.%0
//
#define NS_E_8BIT_WAVE_UNSUPPORTED       _HRESULT_TYPEDEF_(0xC00D0BCEL)

//
// MessageId: NS_E_NO_MORE_SAMPLES
//
// MessageText:
//
// There are no more samples in the current range.%0
//
#define NS_E_NO_MORE_SAMPLES             _HRESULT_TYPEDEF_(0xC00D0BCFL)

//
// MessageId: NS_E_INVALID_SAMPLING_RATE
//
// MessageText:
//
// The given sampling rate is invalid.%0
//
#define NS_E_INVALID_SAMPLING_RATE       _HRESULT_TYPEDEF_(0xC00D0BD0L)

//
// MessageId: NS_E_MAX_PACKET_SIZE_TOO_SMALL
//
// MessageText:
//
// The given maximum packet size is too small to accommodate this profile
//
#define NS_E_MAX_PACKET_SIZE_TOO_SMALL   _HRESULT_TYPEDEF_(0xC00D0BD1L)

//
// MessageId: NS_E_LATE_PACKET
//
// MessageText:
//
// The packet arrived too late to be of use
//
#define NS_E_LATE_PACKET                 _HRESULT_TYPEDEF_(0xC00D0BD2L)

//
// MessageId: NS_E_DUPLICATE_PACKET
//
// MessageText:
//
// The packet is a duplicate of one received before
//
#define NS_E_DUPLICATE_PACKET            _HRESULT_TYPEDEF_(0xC00D0BD3L)

//
// MessageId: NS_E_SDK_BUFFERTOOSMALL
//
// MessageText:
//
// Supplied buffer is too small
//
#define NS_E_SDK_BUFFERTOOSMALL          _HRESULT_TYPEDEF_(0xC00D0BD4L)

//
// MessageId: NS_E_INVALID_NUM_PASSES
//
// MessageText:
//
// The wrong number of preprocessing passes was used for the stream's output type
//
#define NS_E_INVALID_NUM_PASSES          _HRESULT_TYPEDEF_(0xC00D0BD5L)

//
// MessageId: NS_E_ATTRIBUTE_READ_ONLY
//
// MessageText:
//
// An attempt was made to add, modify, or delete a read only attribute
//
#define NS_E_ATTRIBUTE_READ_ONLY         _HRESULT_TYPEDEF_(0xC00D0BD6L)

//
// MessageId: NS_E_ATTRIBUTE_NOT_ALLOWED
//
// MessageText:
//
// An attempt was made to add attribute that is not allowed for the given media type
//
#define NS_E_ATTRIBUTE_NOT_ALLOWED       _HRESULT_TYPEDEF_(0xC00D0BD7L)

//
// MessageId: NS_E_INVALID_EDL
//
// MessageText:
//
// The EDL provided is invalid
//
#define NS_E_INVALID_EDL                 _HRESULT_TYPEDEF_(0xC00D0BD8L)

//
// MessageId: NS_E_DATA_UNIT_EXTENSION_TOO_LARGE
//
// MessageText:
//
// The Data Unit Extension data was too large to be used.%0
//
#define NS_E_DATA_UNIT_EXTENSION_TOO_LARGE _HRESULT_TYPEDEF_(0xC00D0BD9L)

//
// MessageId: NS_E_CODEC_DMO_ERROR
//
// MessageText:
//
// An unexpected error occurred with a DMO codec.%0
//
#define NS_E_CODEC_DMO_ERROR             _HRESULT_TYPEDEF_(0xC00D0BDAL)

//
// MessageId: NS_S_TRANSCRYPTOR_EOF
//
// MessageText:
//
// The transcryptor object has reached end of file.%0
//
#define NS_S_TRANSCRYPTOR_EOF            _HRESULT_TYPEDEF_(0x000D0BDBL)

//
// MessageId: NS_E_FEATURE_DISABLED_BY_GROUP_POLICY
//
// MessageText:
//
// This feature has been disabled by group policy.%0
//
#define NS_E_FEATURE_DISABLED_BY_GROUP_POLICY _HRESULT_TYPEDEF_(0xC00D0BDCL)

//
// MessageId: NS_E_FEATURE_DISABLED_IN_SKU
//
// MessageText:
//
// This feature is disabled in this SKU.%0
//
#define NS_E_FEATURE_DISABLED_IN_SKU     _HRESULT_TYPEDEF_(0xC00D0BDDL)



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Player Errors
//
// IdRange = 4000 - 4999
//
/////////////////////////////////////////////////////////////////////////

//
// WMP CD Filter Error codes
//
//
// MessageId: NS_E_NO_CD
//
// MessageText:
//
// There is no CD in the CD drive. Insert a CD, and then try again.%0
//
#define NS_E_NO_CD                       _HRESULT_TYPEDEF_(0xC00D0FA0L)

//
// MessageId: NS_E_CANT_READ_DIGITAL
//
// MessageText:
//
// Windows Media Player could not use digital playback to play the CD. To switch to analog playback, on the Tools menu, click Options, and then click the Devices tab. Double-click the CD drive, and then in the Playback area, click Analog. For additional assistance, click Web Help.%0
//
#define NS_E_CANT_READ_DIGITAL           _HRESULT_TYPEDEF_(0xC00D0FA1L)

//
// MessageId: NS_E_DEVICE_DISCONNECTED
//
// MessageText:
//
// Windows Media Player no longer detects a connected portable device. Reconnect your portable device, and then try synchronizing the file again.%0
//
#define NS_E_DEVICE_DISCONNECTED         _HRESULT_TYPEDEF_(0xC00D0FA2L)

//
// MessageId: NS_E_DEVICE_NOT_SUPPORT_FORMAT
//
// MessageText:
//
// Windows Media Player cannot play the file. The portable device does not support the specified file type.%0
//
#define NS_E_DEVICE_NOT_SUPPORT_FORMAT   _HRESULT_TYPEDEF_(0xC00D0FA3L)

//
// MessageId: NS_E_SLOW_READ_DIGITAL
//
// MessageText:
//
// Windows Media Player could not use digital playback to play the CD. The Player has automatically switched the CD drive to analog playback. To switch back to digital CD playback, use the Devices tab. For additional assistance, click Web Help.%0
//
#define NS_E_SLOW_READ_DIGITAL           _HRESULT_TYPEDEF_(0xC00D0FA4L)

//
// MessageId: NS_E_MIXER_INVALID_LINE
//
// MessageText:
//
// An invalid line error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_LINE          _HRESULT_TYPEDEF_(0xC00D0FA5L)

//
// MessageId: NS_E_MIXER_INVALID_CONTROL
//
// MessageText:
//
// An invalid control error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_CONTROL       _HRESULT_TYPEDEF_(0xC00D0FA6L)

//
// MessageId: NS_E_MIXER_INVALID_VALUE
//
// MessageText:
//
// An invalid value error occurred in the mixer.%0
//
#define NS_E_MIXER_INVALID_VALUE         _HRESULT_TYPEDEF_(0xC00D0FA7L)

//
// MessageId: NS_E_MIXER_UNKNOWN_MMRESULT
//
// MessageText:
//
// An unrecognized MMRESULT occurred in the mixer.%0
//
#define NS_E_MIXER_UNKNOWN_MMRESULT      _HRESULT_TYPEDEF_(0xC00D0FA8L)

//
// MessageId: NS_E_USER_STOP
//
// MessageText:
//
// User has stopped the operation.%0
//
#define NS_E_USER_STOP                   _HRESULT_TYPEDEF_(0xC00D0FA9L)

//
// MessageId: NS_E_MP3_FORMAT_NOT_FOUND
//
// MessageText:
//
// Windows Media Player cannot rip the track because a compatible MP3 encoder is not installed on your computer. Install a compatible MP3 encoder or choose a different format to rip to (such as Windows Media Audio).%0
//
#define NS_E_MP3_FORMAT_NOT_FOUND        _HRESULT_TYPEDEF_(0xC00D0FAAL)

//
// MessageId: NS_E_CD_READ_ERROR_NO_CORRECTION
//
// MessageText:
//
// Windows Media Player cannot read the CD. The disc might be dirty or damaged. Turn on error correction, and then try again.%0
//
#define NS_E_CD_READ_ERROR_NO_CORRECTION _HRESULT_TYPEDEF_(0xC00D0FABL)

//
// MessageId: NS_E_CD_READ_ERROR
//
// MessageText:
//
// Windows Media Player cannot read the CD. The disc might be dirty or damaged or the CD drive might be malfunctioning.%0
//
#define NS_E_CD_READ_ERROR               _HRESULT_TYPEDEF_(0xC00D0FACL)

//
// MessageId: NS_E_CD_SLOW_COPY
//
// MessageText:
//
// For best performance, do not play CD tracks while ripping them.%0
//
#define NS_E_CD_SLOW_COPY                _HRESULT_TYPEDEF_(0xC00D0FADL)

//
// MessageId: NS_E_CD_COPYTO_CD
//
// MessageText:
//
// It is not possible to directly burn tracks from one CD to another CD. You must first rip the tracks from the CD to your computer, and then burn the files to a blank CD.%0
//
#define NS_E_CD_COPYTO_CD                _HRESULT_TYPEDEF_(0xC00D0FAEL)

//
// MessageId: NS_E_MIXER_NODRIVER
//
// MessageText:
//
// Could not open a sound mixer driver.%0
//
#define NS_E_MIXER_NODRIVER              _HRESULT_TYPEDEF_(0xC00D0FAFL)

//
// MessageId: NS_E_REDBOOK_ENABLED_WHILE_COPYING
//
// MessageText:
//
// Windows Media Player cannot rip tracks from the CD correctly because the CD drive settings in Device Manager do not match the CD drive settings in the Player.%0
//
#define NS_E_REDBOOK_ENABLED_WHILE_COPYING _HRESULT_TYPEDEF_(0xC00D0FB0L)

//
// MessageId: NS_E_CD_REFRESH
//
// MessageText:
//
// Windows Media Player is busy reading the CD.%0
//
#define NS_E_CD_REFRESH                  _HRESULT_TYPEDEF_(0xC00D0FB1L)

//
// MessageId: NS_E_CD_DRIVER_PROBLEM
//
// MessageText:
//
// Windows Media Player could not use digital playback to play the CD. The Player has automatically switched the CD drive to analog playback. To switch back to digital CD playback, use the Devices tab. For additional assistance, click Web Help.%0
//
#define NS_E_CD_DRIVER_PROBLEM           _HRESULT_TYPEDEF_(0xC00D0FB2L)

//
// MessageId: NS_E_WONT_DO_DIGITAL
//
// MessageText:
//
// Windows Media Player could not use digital playback to play the CD. The Player has automatically switched the CD drive to analog playback. To switch back to digital CD playback, use the Devices tab. For additional assistance, click Web Help.%0
//
#define NS_E_WONT_DO_DIGITAL             _HRESULT_TYPEDEF_(0xC00D0FB3L)

//
// WMP IWMPXMLParser Error codes
//
//
// MessageId: NS_E_WMPXML_NOERROR
//
// MessageText:
//
// A call was made to GetParseError on the XML parser but there was no error to retrieve.%0
//
#define NS_E_WMPXML_NOERROR              _HRESULT_TYPEDEF_(0xC00D0FB4L)

//
// MessageId: NS_E_WMPXML_ENDOFDATA
//
// MessageText:
//
// The XML Parser ran out of data while parsing.%0
//
#define NS_E_WMPXML_ENDOFDATA            _HRESULT_TYPEDEF_(0xC00D0FB5L)

//
// MessageId: NS_E_WMPXML_PARSEERROR
//
// MessageText:
//
// A generic parse error occurred in the XML parser but no information is available.%0
//
#define NS_E_WMPXML_PARSEERROR           _HRESULT_TYPEDEF_(0xC00D0FB6L)

//
// MessageId: NS_E_WMPXML_ATTRIBUTENOTFOUND
//
// MessageText:
//
// A call get GetNamedAttribute or GetNamedAttributeIndex on the XML parser resulted in the index not being found.%0
//
#define NS_E_WMPXML_ATTRIBUTENOTFOUND    _HRESULT_TYPEDEF_(0xC00D0FB7L)

//
// MessageId: NS_E_WMPXML_PINOTFOUND
//
// MessageText:
//
// A call was made go GetNamedPI on the XML parser, but the requested Processing Instruction was not found.%0
//
#define NS_E_WMPXML_PINOTFOUND           _HRESULT_TYPEDEF_(0xC00D0FB8L)

//
// MessageId: NS_E_WMPXML_EMPTYDOC
//
// MessageText:
//
// Persist was called on the XML parser, but the parser has no data to persist.%0
//
#define NS_E_WMPXML_EMPTYDOC             _HRESULT_TYPEDEF_(0xC00D0FB9L)

//
// Miscellaneous Media Player Error codes
//
//
// MessageId: NS_E_WMP_PATH_ALREADY_IN_LIBRARY
//
// MessageText:
//
// This file path is already in the library.%0
//
#define NS_E_WMP_PATH_ALREADY_IN_LIBRARY _HRESULT_TYPEDEF_(0xC00D0FBAL)

//
// MessageId: NS_E_WMP_FILESCANALREADYSTARTED
//
// MessageText:
//
// Windows Media Player is already searching for files to add to your library. Wait for the current process to finish before attempting to search again.%0
//
#define NS_E_WMP_FILESCANALREADYSTARTED  _HRESULT_TYPEDEF_(0xC00D0FBEL)

//
// MessageId: NS_E_WMP_HME_INVALIDOBJECTID
//
// MessageText:
//
// Windows Media Player is unable to find the media you are looking for.%0
//
#define NS_E_WMP_HME_INVALIDOBJECTID     _HRESULT_TYPEDEF_(0xC00D0FBFL)

//
// MessageId: NS_E_WMP_MF_CODE_EXPIRED
//
// MessageText:
//
// A component of Windows Media Player is out-of-date. If you are running a pre-release version of Windows, try upgrading to a more recent version.%0
//
#define NS_E_WMP_MF_CODE_EXPIRED         _HRESULT_TYPEDEF_(0xC00D0FC0L)

//
// MessageId: NS_E_WMP_HME_NOTSEARCHABLEFORITEMS
//
// MessageText:
//
// This container does not support search on items.%0
//
#define NS_E_WMP_HME_NOTSEARCHABLEFORITEMS _HRESULT_TYPEDEF_(0xC00D0FC1L)

//
// MessageId: NS_E_WMP_ADDTOLIBRARY_FAILED
//
// MessageText:
//
// Windows Media Player encountered a problem while adding one or more files to the library. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_ADDTOLIBRARY_FAILED     _HRESULT_TYPEDEF_(0xC00D0FC7L)

//
// MessageId: NS_E_WMP_WINDOWSAPIFAILURE
//
// MessageText:
//
// A Windows API call failed but no error information was available.%0
//
#define NS_E_WMP_WINDOWSAPIFAILURE       _HRESULT_TYPEDEF_(0xC00D0FC8L)

//
// MessageId: NS_E_WMP_RECORDING_NOT_ALLOWED
//
// MessageText:
//
// This file does not have burn rights. If you obtained this file from an online store, go to the online store to get burn rights.%0
//
#define NS_E_WMP_RECORDING_NOT_ALLOWED   _HRESULT_TYPEDEF_(0xC00D0FC9L)

//
// MessageId: NS_E_DEVICE_NOT_READY
//
// MessageText:
//
// Windows Media Player no longer detects a connected portable device. Reconnect your portable device, and then try to sync the file again.%0
//
#define NS_E_DEVICE_NOT_READY            _HRESULT_TYPEDEF_(0xC00D0FCAL)

//
// MessageId: NS_E_DAMAGED_FILE
//
// MessageText:
//
// Windows Media Player cannot play the file because it is corrupted.%0
//
#define NS_E_DAMAGED_FILE                _HRESULT_TYPEDEF_(0xC00D0FCBL)

//
// MessageId: NS_E_MPDB_GENERIC
//
// MessageText:
//
// Windows Media Player encountered an error while attempting to access information in the library. Try restarting the Player.%0
//
#define NS_E_MPDB_GENERIC                _HRESULT_TYPEDEF_(0xC00D0FCCL)

//
// MessageId: NS_E_FILE_FAILED_CHECKS
//
// MessageText:
//
// The file cannot be added to the library because it is smaller than the "Skip files smaller than" setting. To add the file, change the setting on the Library tab. For additional assistance, click Web Help.%0
//
#define NS_E_FILE_FAILED_CHECKS          _HRESULT_TYPEDEF_(0xC00D0FCDL)

//
// MessageId: NS_E_MEDIA_LIBRARY_FAILED
//
// MessageText:
//
// Windows Media Player cannot create the library. You must be logged on as an administrator or a member of the Administrators group to install the Player. For more information, contact your system administrator.%0
//
#define NS_E_MEDIA_LIBRARY_FAILED        _HRESULT_TYPEDEF_(0xC00D0FCEL)

//
// MessageId: NS_E_SHARING_VIOLATION
//
// MessageText:
//
// The file is already in use. Close other programs that might be using the file, or stop playing the file, and then try again.%0
//
#define NS_E_SHARING_VIOLATION           _HRESULT_TYPEDEF_(0xC00D0FCFL)

//
// MessageId: NS_E_NO_ERROR_STRING_FOUND
//
// MessageText:
//
// Windows Media Player has encountered an unknown error.%0
//
#define NS_E_NO_ERROR_STRING_FOUND       _HRESULT_TYPEDEF_(0xC00D0FD0L)

//
// MessageId: NS_E_WMPOCX_NO_REMOTE_CORE
//
// MessageText:
//
// The Windows Media Player ActiveX control cannot connect to remote media services, but will continue with local media services.%0
//
#define NS_E_WMPOCX_NO_REMOTE_CORE       _HRESULT_TYPEDEF_(0xC00D0FD1L)

//
// MessageId: NS_E_WMPOCX_NO_ACTIVE_CORE
//
// MessageText:
//
// The requested method or property is not available because the Windows Media Player ActiveX control has not been properly activated.%0
//
#define NS_E_WMPOCX_NO_ACTIVE_CORE       _HRESULT_TYPEDEF_(0xC00D0FD2L)

//
// MessageId: NS_E_WMPOCX_NOT_RUNNING_REMOTELY
//
// MessageText:
//
// The Windows Media Player ActiveX control is not running in remote mode.%0
//
#define NS_E_WMPOCX_NOT_RUNNING_REMOTELY _HRESULT_TYPEDEF_(0xC00D0FD3L)

//
// MessageId: NS_E_WMPOCX_NO_REMOTE_WINDOW
//
// MessageText:
//
// An error occurred while trying to get the remote Windows Media Player window.%0
//
#define NS_E_WMPOCX_NO_REMOTE_WINDOW     _HRESULT_TYPEDEF_(0xC00D0FD4L)

//
// MessageId: NS_E_WMPOCX_ERRORMANAGERNOTAVAILABLE
//
// MessageText:
//
// Windows Media Player has encountered an unknown error.%0
//
#define NS_E_WMPOCX_ERRORMANAGERNOTAVAILABLE _HRESULT_TYPEDEF_(0xC00D0FD5L)

//
// MessageId: NS_E_PLUGIN_NOTSHUTDOWN
//
// MessageText:
//
// Windows Media Player was not closed properly. A damaged or incompatible plug-in might have caused the problem to occur. As a precaution, all optional plug-ins have been disabled.%0
//
#define NS_E_PLUGIN_NOTSHUTDOWN          _HRESULT_TYPEDEF_(0xC00D0FD6L)

//
// MessageId: NS_E_WMP_CANNOT_FIND_FOLDER
//
// MessageText:
//
// Windows Media Player cannot find the specified path. Verify that the path is typed correctly. If it is, the path does not exist in the specified location, or the computer where the path is located is not available.%0
//
#define NS_E_WMP_CANNOT_FIND_FOLDER      _HRESULT_TYPEDEF_(0xC00D0FD7L)

//
// MessageId: NS_E_WMP_STREAMING_RECORDING_NOT_ALLOWED
//
// MessageText:
//
// Windows Media Player cannot save a file that is being streamed.%0
//
#define NS_E_WMP_STREAMING_RECORDING_NOT_ALLOWED _HRESULT_TYPEDEF_(0xC00D0FD8L)

//
// MessageId: NS_E_WMP_PLUGINDLL_NOTFOUND
//
// MessageText:
//
// Windows Media Player cannot find the selected plug-in. The Player will try to remove it from the menu. To use this plug-in, install it again.%0
//
#define NS_E_WMP_PLUGINDLL_NOTFOUND      _HRESULT_TYPEDEF_(0xC00D0FD9L)

//
// MessageId: NS_E_NEED_TO_ASK_USER
//
// MessageText:
//
// Action requires input from the user.%0
//
#define NS_E_NEED_TO_ASK_USER            _HRESULT_TYPEDEF_(0xC00D0FDAL)

//
// MessageId: NS_E_WMPOCX_PLAYER_NOT_DOCKED
//
// MessageText:
//
// The Windows Media Player ActiveX control must be in a docked state for this action to be performed.%0
//
#define NS_E_WMPOCX_PLAYER_NOT_DOCKED    _HRESULT_TYPEDEF_(0xC00D0FDBL)

//
// MessageId: NS_E_WMP_EXTERNAL_NOTREADY
//
// MessageText:
//
// The Windows Media Player external object is not ready.%0
//
#define NS_E_WMP_EXTERNAL_NOTREADY       _HRESULT_TYPEDEF_(0xC00D0FDCL)

//
// MessageId: NS_E_WMP_MLS_STALE_DATA
//
// MessageText:
//
// Windows Media Player cannot perform the requested action. Your computer's time and date might not be set correctly.%0
//
#define NS_E_WMP_MLS_STALE_DATA          _HRESULT_TYPEDEF_(0xC00D0FDDL)    

//
// Generic Media PlayerUI error codes
//
//
// MessageId: NS_E_WMP_UI_SUBCONTROLSNOTSUPPORTED
//
// MessageText:
//
// The control (%s) does not support creation of sub-controls, yet (%d) sub-controls have been specified.%0
//
#define NS_E_WMP_UI_SUBCONTROLSNOTSUPPORTED _HRESULT_TYPEDEF_(0xC00D0FDEL)

//
// MessageId: NS_E_WMP_UI_VERSIONMISMATCH
//
// MessageText:
//
// Version mismatch: (%.1f required, %.1f found).%0
//
#define NS_E_WMP_UI_VERSIONMISMATCH      _HRESULT_TYPEDEF_(0xC00D0FDFL)

//
// MessageId: NS_E_WMP_UI_NOTATHEMEFILE
//
// MessageText:
//
// The layout manager was given valid XML that wasn't a theme file.%0
//
#define NS_E_WMP_UI_NOTATHEMEFILE        _HRESULT_TYPEDEF_(0xC00D0FE0L)

//
// MessageId: NS_E_WMP_UI_SUBELEMENTNOTFOUND
//
// MessageText:
//
// The %s subelement could not be found on the %s object.%0
//
#define NS_E_WMP_UI_SUBELEMENTNOTFOUND   _HRESULT_TYPEDEF_(0xC00D0FE1L)

//
// MessageId: NS_E_WMP_UI_VERSIONPARSE
//
// MessageText:
//
// An error occurred parsing the version tag.\nValid version tags are of the form:\n\n\t<?wmp version='1.0'?>.%0
//
#define NS_E_WMP_UI_VERSIONPARSE         _HRESULT_TYPEDEF_(0xC00D0FE2L)

//
// MessageId: NS_E_WMP_UI_VIEWIDNOTFOUND
//
// MessageText:
//
// The view specified in for the 'currentViewID' property (%s) was not found in this theme file.%0
//
#define NS_E_WMP_UI_VIEWIDNOTFOUND       _HRESULT_TYPEDEF_(0xC00D0FE3L)

//
// MessageId: NS_E_WMP_UI_PASSTHROUGH
//
// MessageText:
//
// This error used internally for hit testing.%0
//
#define NS_E_WMP_UI_PASSTHROUGH          _HRESULT_TYPEDEF_(0xC00D0FE4L)

//
// MessageId: NS_E_WMP_UI_OBJECTNOTFOUND
//
// MessageText:
//
// Attributes were specified for the %s object, but the object was not available to send them to.%0
//
#define NS_E_WMP_UI_OBJECTNOTFOUND       _HRESULT_TYPEDEF_(0xC00D0FE5L)

//
// MessageId: NS_E_WMP_UI_SECONDHANDLER
//
// MessageText:
//
// The %s event already has a handler, the second handler was ignored.%0
//
#define NS_E_WMP_UI_SECONDHANDLER        _HRESULT_TYPEDEF_(0xC00D0FE6L)

//
// MessageId: NS_E_WMP_UI_NOSKININZIP
//
// MessageText:
//
// No .wms file found in skin archive.%0
//
#define NS_E_WMP_UI_NOSKININZIP          _HRESULT_TYPEDEF_(0xC00D0FE7L)

//
// MessageId: NS_S_WMP_UI_VERSIONMISMATCH
//
// MessageText:
//
// An upgrade may be needed for the theme manager to correctly show this skin. Skin reports version: %.1f.%0
//
#define NS_S_WMP_UI_VERSIONMISMATCH      _HRESULT_TYPEDEF_(0x000D0FE8L)

//
// MessageId: NS_S_WMP_EXCEPTION
//
// MessageText:
//
// An error occurred in one of the UI components.%0
//
#define NS_S_WMP_EXCEPTION               _HRESULT_TYPEDEF_(0x000D0FE9L)

//
// MessageId: NS_E_WMP_URLDOWNLOADFAILED
//
// MessageText:
//
// Windows Media Player encountered a problem while downloading the file. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_URLDOWNLOADFAILED       _HRESULT_TYPEDEF_(0xC00D0FEAL)

//
// MessageId: NS_E_WMPOCX_UNABLE_TO_LOAD_SKIN
//
// MessageText:
//
// The Windows Media Player ActiveX control cannot load the requested uiMode and cannot roll back to the existing uiMode.%0
//
#define NS_E_WMPOCX_UNABLE_TO_LOAD_SKIN  _HRESULT_TYPEDEF_(0xC00D0FEBL)

//
// MessageId: NS_E_WMP_INVALID_SKIN
//
// MessageText:
//
// Windows Media Player encountered a problem with the skin file. The skin file might not be valid.%0
//
#define NS_E_WMP_INVALID_SKIN            _HRESULT_TYPEDEF_(0xC00D0FECL)

//
// MessageId: NS_E_WMP_SENDMAILFAILED
//
// MessageText:
//
// Windows Media Player cannot send the link because your e-mail program is not responding. Verify that your e-mail program is configured properly, and then try again. For more information about e-mail, see Windows Help.%0
//
#define NS_E_WMP_SENDMAILFAILED          _HRESULT_TYPEDEF_(0xC00D0FEDL)

//
// MessageId: NS_E_WMP_LOCKEDINSKINMODE
//
// MessageText:
//
// Windows Media Player cannot switch to full mode because your computer administrator has locked this skin.%0
//
#define NS_E_WMP_LOCKEDINSKINMODE        _HRESULT_TYPEDEF_(0xC00D0FEEL)

//
// MessageId: NS_E_WMP_FAILED_TO_SAVE_FILE
//
// MessageText:
//
// Windows Media Player encountered a problem while saving the file. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_FAILED_TO_SAVE_FILE     _HRESULT_TYPEDEF_(0xC00D0FEFL)

//Save As
//
// MessageId: NS_E_WMP_SAVEAS_READONLY
//
// MessageText:
//
// Windows Media Player cannot overwrite a read-only file. Try using a different file name.%0
//
#define NS_E_WMP_SAVEAS_READONLY         _HRESULT_TYPEDEF_(0xC00D0FF0L)

//
// MessageId: NS_E_WMP_FAILED_TO_SAVE_PLAYLIST
//
// MessageText:
//
// Windows Media Player encountered a problem while creating or saving the playlist. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_FAILED_TO_SAVE_PLAYLIST _HRESULT_TYPEDEF_(0xC00D0FF1L)

//
// MessageId: NS_E_WMP_FAILED_TO_OPEN_WMD
//
// MessageText:
//
// Windows Media Player cannot open the Windows Media Download file. The file might be damaged.%0
//
#define NS_E_WMP_FAILED_TO_OPEN_WMD      _HRESULT_TYPEDEF_(0xC00D0FF2L)

//
// MessageId: NS_E_WMP_CANT_PLAY_PROTECTED
//
// MessageText:
//
// The file cannot be added to the library because it is a protected DVR-MS file. This content cannot be played back by Windows Media Player.%0
//
#define NS_E_WMP_CANT_PLAY_PROTECTED     _HRESULT_TYPEDEF_(0xC00D0FF3L)

//
// MessageId: NS_E_SHARING_STATE_OUT_OF_SYNC
//
// MessageText:
//
// Media sharing has been turned off because a required Windows setting or component has changed. For additional assistance, click Web Help.%0
//
#define NS_E_SHARING_STATE_OUT_OF_SYNC   _HRESULT_TYPEDEF_(0xC00D0FF4L)

// Additional remoting error(s)
//
// MessageId: NS_E_WMPOCX_REMOTE_PLAYER_ALREADY_RUNNING
//
// MessageText:
//
// Exclusive Services launch failed because the Windows Media Player is already running.%0
//
#define NS_E_WMPOCX_REMOTE_PLAYER_ALREADY_RUNNING _HRESULT_TYPEDEF_(0xC00D0FFAL)

//
// WMP Regional button control
//
//
// MessageId: NS_E_WMP_RBC_JPGMAPPINGIMAGE
//
// MessageText:
//
// JPG Images are not recommended for use as a mappingImage.%0
//
#define NS_E_WMP_RBC_JPGMAPPINGIMAGE     _HRESULT_TYPEDEF_(0xC00D1004L)

//
// MessageId: NS_E_WMP_JPGTRANSPARENCY
//
// MessageText:
//
// JPG Images are not recommended when using a transparencyColor.%0
//
#define NS_E_WMP_JPGTRANSPARENCY         _HRESULT_TYPEDEF_(0xC00D1005L)

//
// WMP Slider control
//
//
// MessageId: NS_E_WMP_INVALID_MAX_VAL
//
// MessageText:
//
// The Max property cannot be less than Min property.%0
//
#define NS_E_WMP_INVALID_MAX_VAL         _HRESULT_TYPEDEF_(0xC00D1009L)

//
// MessageId: NS_E_WMP_INVALID_MIN_VAL
//
// MessageText:
//
// The Min property cannot be greater than Max property.%0
//
#define NS_E_WMP_INVALID_MIN_VAL         _HRESULT_TYPEDEF_(0xC00D100AL)

//
// WMP CustomSlider control
//
//
// MessageId: NS_E_WMP_CS_JPGPOSITIONIMAGE
//
// MessageText:
//
// JPG Images are not recommended for use as a positionImage.%0
//
#define NS_E_WMP_CS_JPGPOSITIONIMAGE     _HRESULT_TYPEDEF_(0xC00D100EL)

//
// MessageId: NS_E_WMP_CS_NOTEVENLYDIVISIBLE
//
// MessageText:
//
// The (%s) image's size is not evenly divisible by the positionImage's size.%0
//
#define NS_E_WMP_CS_NOTEVENLYDIVISIBLE   _HRESULT_TYPEDEF_(0xC00D100FL)

//
// WMP ZIP Decoder
//
//
// MessageId: NS_E_WMPZIP_NOTAZIPFILE
//
// MessageText:
//
// The ZIP reader opened a file and its signature did not match that of the ZIP files.%0
//
#define NS_E_WMPZIP_NOTAZIPFILE          _HRESULT_TYPEDEF_(0xC00D1018L)

//
// MessageId: NS_E_WMPZIP_CORRUPT
//
// MessageText:
//
// The ZIP reader has detected that the file is corrupted.%0
//
#define NS_E_WMPZIP_CORRUPT              _HRESULT_TYPEDEF_(0xC00D1019L)

//
// MessageId: NS_E_WMPZIP_FILENOTFOUND
//
// MessageText:
//
// GetFileStream, SaveToFile, or SaveTemp file was called on the ZIP reader with a file name that was not found in the ZIP file.%0
//
#define NS_E_WMPZIP_FILENOTFOUND         _HRESULT_TYPEDEF_(0xC00D101AL)

//
// WMP Image Decoding Error codes
//
//
// MessageId: NS_E_WMP_IMAGE_FILETYPE_UNSUPPORTED
//
// MessageText:
//
// Image type not supported.%0
//
#define NS_E_WMP_IMAGE_FILETYPE_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D1022L)

//
// MessageId: NS_E_WMP_IMAGE_INVALID_FORMAT
//
// MessageText:
//
// Image file may be corrupt.%0
//
#define NS_E_WMP_IMAGE_INVALID_FORMAT    _HRESULT_TYPEDEF_(0xC00D1023L)

//
// MessageId: NS_E_WMP_GIF_UNEXPECTED_ENDOFFILE
//
// MessageText:
//
// Unexpected end of file. GIF file may be corrupt.%0
//
#define NS_E_WMP_GIF_UNEXPECTED_ENDOFFILE _HRESULT_TYPEDEF_(0xC00D1024L)

//
// MessageId: NS_E_WMP_GIF_INVALID_FORMAT
//
// MessageText:
//
// Invalid GIF file.%0
//
#define NS_E_WMP_GIF_INVALID_FORMAT      _HRESULT_TYPEDEF_(0xC00D1025L)

//
// MessageId: NS_E_WMP_GIF_BAD_VERSION_NUMBER
//
// MessageText:
//
// Invalid GIF version. Only 87a or 89a supported.%0
//
#define NS_E_WMP_GIF_BAD_VERSION_NUMBER  _HRESULT_TYPEDEF_(0xC00D1026L)

//
// MessageId: NS_E_WMP_GIF_NO_IMAGE_IN_FILE
//
// MessageText:
//
// No images found in GIF file.%0
//
#define NS_E_WMP_GIF_NO_IMAGE_IN_FILE    _HRESULT_TYPEDEF_(0xC00D1027L)

//
// MessageId: NS_E_WMP_PNG_INVALIDFORMAT
//
// MessageText:
//
// Invalid PNG image file format.%0
//
#define NS_E_WMP_PNG_INVALIDFORMAT       _HRESULT_TYPEDEF_(0xC00D1028L)

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_BITDEPTH
//
// MessageText:
//
// PNG bitdepth not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_BITDEPTH _HRESULT_TYPEDEF_(0xC00D1029L)

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_COMPRESSION
//
// MessageText:
//
// Compression format defined in PNG file not supported,%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_COMPRESSION _HRESULT_TYPEDEF_(0xC00D102AL)

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_FILTER
//
// MessageText:
//
// Filter method defined in PNG file not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_FILTER  _HRESULT_TYPEDEF_(0xC00D102BL)

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_INTERLACE
//
// MessageText:
//
// Interlace method defined in PNG file not supported.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_INTERLACE _HRESULT_TYPEDEF_(0xC00D102CL)

//
// MessageId: NS_E_WMP_PNG_UNSUPPORTED_BAD_CRC
//
// MessageText:
//
// Bad CRC in PNG file.%0
//
#define NS_E_WMP_PNG_UNSUPPORTED_BAD_CRC _HRESULT_TYPEDEF_(0xC00D102DL)

//
// MessageId: NS_E_WMP_BMP_INVALID_BITMASK
//
// MessageText:
//
// Invalid bitmask in BMP file.%0
//
#define NS_E_WMP_BMP_INVALID_BITMASK     _HRESULT_TYPEDEF_(0xC00D102EL)

//
// MessageId: NS_E_WMP_BMP_TOPDOWN_DIB_UNSUPPORTED
//
// MessageText:
//
// Topdown DIB not supported.%0
//
#define NS_E_WMP_BMP_TOPDOWN_DIB_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D102FL)

//
// MessageId: NS_E_WMP_BMP_BITMAP_NOT_CREATED
//
// MessageText:
//
// Bitmap could not be created.%0
//
#define NS_E_WMP_BMP_BITMAP_NOT_CREATED  _HRESULT_TYPEDEF_(0xC00D1030L)

//
// MessageId: NS_E_WMP_BMP_COMPRESSION_UNSUPPORTED
//
// MessageText:
//
// Compression format defined in BMP not supported.%0
//
#define NS_E_WMP_BMP_COMPRESSION_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D1031L)

//
// MessageId: NS_E_WMP_BMP_INVALID_FORMAT
//
// MessageText:
//
// Invalid Bitmap format.%0
//
#define NS_E_WMP_BMP_INVALID_FORMAT      _HRESULT_TYPEDEF_(0xC00D1032L)

//
// MessageId: NS_E_WMP_JPG_JERR_ARITHCODING_NOTIMPL
//
// MessageText:
//
// JPEG Arithmetic coding not supported.%0
//
#define NS_E_WMP_JPG_JERR_ARITHCODING_NOTIMPL _HRESULT_TYPEDEF_(0xC00D1033L)

//
// MessageId: NS_E_WMP_JPG_INVALID_FORMAT
//
// MessageText:
//
// Invalid JPEG format.%0
//
#define NS_E_WMP_JPG_INVALID_FORMAT      _HRESULT_TYPEDEF_(0xC00D1034L)

//
// MessageId: NS_E_WMP_JPG_BAD_DCTSIZE
//
// MessageText:
//
// Invalid JPEG format.%0
//
#define NS_E_WMP_JPG_BAD_DCTSIZE         _HRESULT_TYPEDEF_(0xC00D1035L)

//
// MessageId: NS_E_WMP_JPG_BAD_VERSION_NUMBER
//
// MessageText:
//
// Internal version error. Unexpected JPEG library version.%0
//
#define NS_E_WMP_JPG_BAD_VERSION_NUMBER  _HRESULT_TYPEDEF_(0xC00D1036L)

//
// MessageId: NS_E_WMP_JPG_BAD_PRECISION
//
// MessageText:
//
// Internal JPEG Library error. Unsupported JPEG data precision.%0
//
#define NS_E_WMP_JPG_BAD_PRECISION       _HRESULT_TYPEDEF_(0xC00D1037L)

//
// MessageId: NS_E_WMP_JPG_CCIR601_NOTIMPL
//
// MessageText:
//
// JPEG CCIR601 not supported.%0
//
#define NS_E_WMP_JPG_CCIR601_NOTIMPL     _HRESULT_TYPEDEF_(0xC00D1038L)

//
// MessageId: NS_E_WMP_JPG_NO_IMAGE_IN_FILE
//
// MessageText:
//
// No image found in JPEG file.%0
//
#define NS_E_WMP_JPG_NO_IMAGE_IN_FILE    _HRESULT_TYPEDEF_(0xC00D1039L)

//
// MessageId: NS_E_WMP_JPG_READ_ERROR
//
// MessageText:
//
// Could not read JPEG file.%0
//
#define NS_E_WMP_JPG_READ_ERROR          _HRESULT_TYPEDEF_(0xC00D103AL)

//
// MessageId: NS_E_WMP_JPG_FRACT_SAMPLE_NOTIMPL
//
// MessageText:
//
// JPEG Fractional sampling not supported.%0
//
#define NS_E_WMP_JPG_FRACT_SAMPLE_NOTIMPL _HRESULT_TYPEDEF_(0xC00D103BL)

//
// MessageId: NS_E_WMP_JPG_IMAGE_TOO_BIG
//
// MessageText:
//
// JPEG image too large. Maximum image size supported is 65500 X 65500.%0
//
#define NS_E_WMP_JPG_IMAGE_TOO_BIG       _HRESULT_TYPEDEF_(0xC00D103CL)

//
// MessageId: NS_E_WMP_JPG_UNEXPECTED_ENDOFFILE
//
// MessageText:
//
// Unexpected end of file reached in JPEG file.%0
//
#define NS_E_WMP_JPG_UNEXPECTED_ENDOFFILE _HRESULT_TYPEDEF_(0xC00D103DL)

//
// MessageId: NS_E_WMP_JPG_SOF_UNSUPPORTED
//
// MessageText:
//
// Unsupported JPEG SOF marker found.%0
//
#define NS_E_WMP_JPG_SOF_UNSUPPORTED     _HRESULT_TYPEDEF_(0xC00D103EL)

//
// MessageId: NS_E_WMP_JPG_UNKNOWN_MARKER
//
// MessageText:
//
// Unknown JPEG marker found.%0
//
#define NS_E_WMP_JPG_UNKNOWN_MARKER      _HRESULT_TYPEDEF_(0xC00D103FL)

//
// MessageId: NS_S_WMP_LOADED_GIF_IMAGE
//
// MessageText:
//
// Successfully loaded a GIF file.%0
//
#define NS_S_WMP_LOADED_GIF_IMAGE        _HRESULT_TYPEDEF_(0x000D1040L)

//
// MessageId: NS_S_WMP_LOADED_PNG_IMAGE
//
// MessageText:
//
// Successfully loaded a PNG file.%0
//
#define NS_S_WMP_LOADED_PNG_IMAGE        _HRESULT_TYPEDEF_(0x000D1041L)

//
// MessageId: NS_S_WMP_LOADED_BMP_IMAGE
//
// MessageText:
//
// Successfully loaded a BMP file.%0
//
#define NS_S_WMP_LOADED_BMP_IMAGE        _HRESULT_TYPEDEF_(0x000D1042L)

//
// MessageId: NS_S_WMP_LOADED_JPG_IMAGE
//
// MessageText:
//
// Successfully loaded a JPG file.%0
//
#define NS_S_WMP_LOADED_JPG_IMAGE        _HRESULT_TYPEDEF_(0x000D1043L)

//
// MessageId: NS_E_WMP_FAILED_TO_OPEN_IMAGE
//
// MessageText:
//
// Windows Media Player cannot display the picture file. The player either does not support the picture type or the picture is corrupted.%0
//
#define NS_E_WMP_FAILED_TO_OPEN_IMAGE    _HRESULT_TYPEDEF_(0xC00D1044L)

//
// WMP DAI Error code
//
//
// MessageId: NS_E_WMP_DAI_SONGTOOSHORT
//
// MessageText:
//
// Windows Media Player cannot compute a Digital Audio Id for the song. It is too short.%0
//
#define NS_E_WMP_DAI_SONGTOOSHORT        _HRESULT_TYPEDEF_(0xC00D1049L)

//
// WMP WM Runtime Error codes
//
//
// MessageId: NS_E_WMG_RATEUNAVAILABLE
//
// MessageText:
//
// Windows Media Player cannot play the file at the requested speed.%0
//
#define NS_E_WMG_RATEUNAVAILABLE         _HRESULT_TYPEDEF_(0xC00D104AL)

//
// MessageId: NS_E_WMG_PLUGINUNAVAILABLE
//
// MessageText:
//
// The rendering or digital signal processing plug-in cannot be instantiated.%0
//
#define NS_E_WMG_PLUGINUNAVAILABLE       _HRESULT_TYPEDEF_(0xC00D104BL)

//
// MessageId: NS_E_WMG_CANNOTQUEUE
//
// MessageText:
//
// The file cannot be queued for seamless playback.%0
//
#define NS_E_WMG_CANNOTQUEUE             _HRESULT_TYPEDEF_(0xC00D104CL)

//
// MessageId: NS_E_WMG_PREROLLLICENSEACQUISITIONNOTALLOWED
//
// MessageText:
//
// Windows Media Player cannot download media usage rights for a file in the playlist.%0
//
#define NS_E_WMG_PREROLLLICENSEACQUISITIONNOTALLOWED _HRESULT_TYPEDEF_(0xC00D104DL)

//
// MessageId: NS_E_WMG_UNEXPECTEDPREROLLSTATUS
//
// MessageText:
//
// Windows Media Player encountered an error while trying to queue a file.%0
//
#define NS_E_WMG_UNEXPECTEDPREROLLSTATUS _HRESULT_TYPEDEF_(0xC00D104EL)

//
// MessageId: NS_S_WMG_FORCE_DROP_FRAME
//
// MessageText:
//
// Drop this frame.%0
//
#define NS_S_WMG_FORCE_DROP_FRAME        _HRESULT_TYPEDEF_(0x000D104FL)

//
// MessageId: NS_E_WMG_INVALID_COPP_CERTIFICATE
//
// MessageText:
//
// Windows Media Player cannot play the protected file. The Player cannot verify that the connection to your video card is secure. Try installing an updated device driver for your video card.%0
//
#define NS_E_WMG_INVALID_COPP_CERTIFICATE _HRESULT_TYPEDEF_(0xC00D1051L)

//
// MessageId: NS_E_WMG_COPP_SECURITY_INVALID
//
// MessageText:
//
// Windows Media Player cannot play the protected file. The Player detected that the connection to your hardware might not be secure.%0
//
#define NS_E_WMG_COPP_SECURITY_INVALID   _HRESULT_TYPEDEF_(0xC00D1052L)

//
// MessageId: NS_E_WMG_COPP_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player output link protection is unsupported on this system.%0
//
#define NS_E_WMG_COPP_UNSUPPORTED        _HRESULT_TYPEDEF_(0xC00D1053L)

//
// MessageId: NS_E_WMG_INVALIDSTATE
//
// MessageText:
//
// Operation attempted in an invalid graph state.%0
//
#define NS_E_WMG_INVALIDSTATE            _HRESULT_TYPEDEF_(0xC00D1054L)

//
// MessageId: NS_E_WMG_SINKALREADYEXISTS
//
// MessageText:
//
// A renderer cannot be inserted in a stream while one already exists.%0
//
#define NS_E_WMG_SINKALREADYEXISTS       _HRESULT_TYPEDEF_(0xC00D1055L)

//
// MessageId: NS_E_WMG_NOSDKINTERFACE
//
// MessageText:
//
// The Windows Media SDK interface needed to complete the operation does not exist at this time.%0
//
#define NS_E_WMG_NOSDKINTERFACE          _HRESULT_TYPEDEF_(0xC00D1056L)

//
// MessageId: NS_E_WMG_NOTALLOUTPUTSRENDERED
//
// MessageText:
//
// Windows Media Player cannot play a portion of the file because it requires a codec that either could not be downloaded or that is not supported by the Player.%0
//
#define NS_E_WMG_NOTALLOUTPUTSRENDERED   _HRESULT_TYPEDEF_(0xC00D1057L)

//
// MessageId: NS_E_WMG_FILETRANSFERNOTALLOWED
//
// MessageText:
//
// File transfer streams are not allowed in the standalone Player.%0
//
#define NS_E_WMG_FILETRANSFERNOTALLOWED  _HRESULT_TYPEDEF_(0xC00D1058L)

//
// MessageId: NS_E_WMR_UNSUPPORTEDSTREAM
//
// MessageText:
//
// Windows Media Player cannot play the file. The Player does not support the format you are trying to play.%0
//
#define NS_E_WMR_UNSUPPORTEDSTREAM       _HRESULT_TYPEDEF_(0xC00D1059L)

//
// MessageId: NS_E_WMR_PINNOTFOUND
//
// MessageText:
//
// An operation was attempted on a pin that does not exist in the DirectShow filter graph.%0
//
#define NS_E_WMR_PINNOTFOUND             _HRESULT_TYPEDEF_(0xC00D105AL)

//
// MessageId: NS_E_WMR_WAITINGONFORMATSWITCH
//
// MessageText:
//
// Specified operation cannot be completed while waiting for a media format change from the SDK.%0
//
#define NS_E_WMR_WAITINGONFORMATSWITCH   _HRESULT_TYPEDEF_(0xC00D105BL)

//
// MessageId: NS_E_WMR_NOSOURCEFILTER
//
// MessageText:
//
// Specified operation cannot be completed because the source filter does not exist.%0
//
#define NS_E_WMR_NOSOURCEFILTER          _HRESULT_TYPEDEF_(0xC00D105CL)

//
// MessageId: NS_E_WMR_PINTYPENOMATCH
//
// MessageText:
//
// The specified type does not match this pin.%0
//
#define NS_E_WMR_PINTYPENOMATCH          _HRESULT_TYPEDEF_(0xC00D105DL)

//
// MessageId: NS_E_WMR_NOCALLBACKAVAILABLE
//
// MessageText:
//
// The WMR Source Filter does not have a callback available.%0
//
#define NS_E_WMR_NOCALLBACKAVAILABLE     _HRESULT_TYPEDEF_(0xC00D105EL)

//
// MessageId: NS_S_WMR_ALREADYRENDERED
//
// MessageText:
//
// The specified stream has already been rendered.%0
//
#define NS_S_WMR_ALREADYRENDERED         _HRESULT_TYPEDEF_(0x000D105FL)

//
// MessageId: NS_S_WMR_PINTYPEPARTIALMATCH
//
// MessageText:
//
// The specified type partially matches this pin type.%0
//
#define NS_S_WMR_PINTYPEPARTIALMATCH     _HRESULT_TYPEDEF_(0x000D1060L)

//
// MessageId: NS_S_WMR_PINTYPEFULLMATCH
//
// MessageText:
//
// The specified type fully matches this pin type.%0
//
#define NS_S_WMR_PINTYPEFULLMATCH        _HRESULT_TYPEDEF_(0x000D1061L)

//
// MessageId: NS_E_WMR_SAMPLEPROPERTYNOTSET
//
// MessageText:
//
// The specified property has not been set on this sample.%0
//
#define NS_E_WMR_SAMPLEPROPERTYNOTSET    _HRESULT_TYPEDEF_(0xC00D1062L)

//
// MessageId: NS_E_WMR_CANNOT_RENDER_BINARY_STREAM
//
// MessageText:
//
// A plug-in is required to correctly play the file. To determine if the plug-in is available to download, click Web Help.%0
//
#define NS_E_WMR_CANNOT_RENDER_BINARY_STREAM _HRESULT_TYPEDEF_(0xC00D1063L)

//
// MessageId: NS_E_WMG_LICENSE_TAMPERED
//
// MessageText:
//
// Windows Media Player cannot play the file because your media usage rights are corrupted. If you previously backed up your media usage rights, try restoring them.%0
//
#define NS_E_WMG_LICENSE_TAMPERED        _HRESULT_TYPEDEF_(0xC00D1064L)

//
// MessageId: NS_E_WMR_WILLNOT_RENDER_BINARY_STREAM
//
// MessageText:
//
// Windows Media Player cannot play protected files that contain binary streams.%0
//
#define NS_E_WMR_WILLNOT_RENDER_BINARY_STREAM _HRESULT_TYPEDEF_(0xC00D1065L)

//
// MessageId: NS_S_WMG_ADVISE_DROP_FRAME
//
// MessageText:
//
// The timestamp is late compared to the current render position. Advise dropping this frame.%0
//
#define NS_S_WMG_ADVISE_DROP_FRAME       _HRESULT_TYPEDEF_(0x000D1066L)

//
// MessageId: NS_S_WMG_ADVISE_DROP_TO_KEYFRAME
//
// MessageText:
//
// The timestamp is severely late compared to the current render position. Advise dropping everything up to the next key frame.%0
//
#define NS_S_WMG_ADVISE_DROP_TO_KEYFRAME _HRESULT_TYPEDEF_(0x000D1067L)

//
// WMP Playlist Error codes
//
//
// MessageId: NS_E_WMX_UNRECOGNIZED_PLAYLIST_FORMAT
//
// MessageText:
//
// Windows Media Player cannot play the playlist because it is not valid.%0
//
#define NS_E_WMX_UNRECOGNIZED_PLAYLIST_FORMAT _HRESULT_TYPEDEF_(0xC00D1068L)

//
// MessageId: NS_E_ASX_INVALIDFORMAT
//
// MessageText:
//
// Windows Media Player cannot play the playlist because it is not valid.%0
//
#define NS_E_ASX_INVALIDFORMAT           _HRESULT_TYPEDEF_(0xC00D1069L)

//
// MessageId: NS_E_ASX_INVALIDVERSION
//
// MessageText:
//
// A later version of Windows Media Player might be required to play this playlist.%0
//
#define NS_E_ASX_INVALIDVERSION          _HRESULT_TYPEDEF_(0xC00D106AL)

//
// MessageId: NS_E_ASX_INVALID_REPEAT_BLOCK
//
// MessageText:
//
// The format of a REPEAT loop within the current playlist file is not valid.%0
//
#define NS_E_ASX_INVALID_REPEAT_BLOCK    _HRESULT_TYPEDEF_(0xC00D106BL)

//
// MessageId: NS_E_ASX_NOTHING_TO_WRITE
//
// MessageText:
//
// Windows Media Player cannot save the playlist because it does not contain any items.%0
//
#define NS_E_ASX_NOTHING_TO_WRITE        _HRESULT_TYPEDEF_(0xC00D106CL)

//
// MessageId: NS_E_URLLIST_INVALIDFORMAT
//
// MessageText:
//
// Windows Media Player cannot play the playlist because it is not valid.%0
//
#define NS_E_URLLIST_INVALIDFORMAT       _HRESULT_TYPEDEF_(0xC00D106DL)

//
// MessageId: NS_E_WMX_ATTRIBUTE_DOES_NOT_EXIST
//
// MessageText:
//
// The specified attribute does not exist.%0
//
#define NS_E_WMX_ATTRIBUTE_DOES_NOT_EXIST _HRESULT_TYPEDEF_(0xC00D106EL)

//
// MessageId: NS_E_WMX_ATTRIBUTE_ALREADY_EXISTS
//
// MessageText:
//
// The specified attribute already exists.%0
//
#define NS_E_WMX_ATTRIBUTE_ALREADY_EXISTS _HRESULT_TYPEDEF_(0xC00D106FL)

//
// MessageId: NS_E_WMX_ATTRIBUTE_UNRETRIEVABLE
//
// MessageText:
//
// Cannot retrieve the specified attribute.%0
//
#define NS_E_WMX_ATTRIBUTE_UNRETRIEVABLE _HRESULT_TYPEDEF_(0xC00D1070L)

//
// MessageId: NS_E_WMX_ITEM_DOES_NOT_EXIST
//
// MessageText:
//
// The specified item does not exist in the current playlist.%0
//
#define NS_E_WMX_ITEM_DOES_NOT_EXIST     _HRESULT_TYPEDEF_(0xC00D1071L)

//
// MessageId: NS_E_WMX_ITEM_TYPE_ILLEGAL
//
// MessageText:
//
// Items of the specified type cannot be created within the current playlist.%0
//
#define NS_E_WMX_ITEM_TYPE_ILLEGAL       _HRESULT_TYPEDEF_(0xC00D1072L)

//
// MessageId: NS_E_WMX_ITEM_UNSETTABLE
//
// MessageText:
//
// The specified item cannot be set in the current playlist.%0
//
#define NS_E_WMX_ITEM_UNSETTABLE         _HRESULT_TYPEDEF_(0xC00D1073L)

//
// MessageId: NS_E_WMX_PLAYLIST_EMPTY
//
// MessageText:
//
// Windows Media Player cannot perform the requested action because the playlist does not contain any items.%0
//
#define NS_E_WMX_PLAYLIST_EMPTY          _HRESULT_TYPEDEF_(0xC00D1074L)

//
// MessageId: NS_E_MLS_SMARTPLAYLIST_FILTER_NOT_REGISTERED
//
// MessageText:
//
// The specified auto playlist contains a filter type that is either not valid or is not installed on this computer.%0
//
#define NS_E_MLS_SMARTPLAYLIST_FILTER_NOT_REGISTERED _HRESULT_TYPEDEF_(0xC00D1075L)

//
// MessageId: NS_E_WMX_INVALID_FORMAT_OVER_NESTING
//
// MessageText:
//
// Windows Media Player cannot play the file because the associated playlist contains too many nested playlists.%0
//
#define NS_E_WMX_INVALID_FORMAT_OVER_NESTING _HRESULT_TYPEDEF_(0xC00D1076L)

//
// WMP Core  Error codes
//
//
// MessageId: NS_E_WMPCORE_NOSOURCEURLSTRING
//
// MessageText:
//
// Windows Media Player cannot find the file. Verify that the path is typed correctly. If it is, the file might not exist in the specified location, or the computer where the file is stored might not be available.%0
//
#define NS_E_WMPCORE_NOSOURCEURLSTRING   _HRESULT_TYPEDEF_(0xC00D107CL)

//
// MessageId: NS_E_WMPCORE_COCREATEFAILEDFORGITOBJECT
//
// MessageText:
//
// Failed to create the Global Interface Table.%0
//
#define NS_E_WMPCORE_COCREATEFAILEDFORGITOBJECT _HRESULT_TYPEDEF_(0xC00D107DL)

//
// MessageId: NS_E_WMPCORE_FAILEDTOGETMARSHALLEDEVENTHANDLERINTERFACE
//
// MessageText:
//
// Failed to get the marshaled graph event handler interface.%0
//
#define NS_E_WMPCORE_FAILEDTOGETMARSHALLEDEVENTHANDLERINTERFACE _HRESULT_TYPEDEF_(0xC00D107EL)

//
// MessageId: NS_E_WMPCORE_BUFFERTOOSMALL
//
// MessageText:
//
// Buffer is too small for copying media type.%0
//
#define NS_E_WMPCORE_BUFFERTOOSMALL      _HRESULT_TYPEDEF_(0xC00D107FL)

//
// MessageId: NS_E_WMPCORE_UNAVAILABLE
//
// MessageText:
//
// The current state of the Player does not allow this operation.%0
//
#define NS_E_WMPCORE_UNAVAILABLE         _HRESULT_TYPEDEF_(0xC00D1080L)

//
// MessageId: NS_E_WMPCORE_INVALIDPLAYLISTMODE
//
// MessageText:
//
// The playlist manager does not understand the current play mode (for example, shuffle or normal).%0
//
#define NS_E_WMPCORE_INVALIDPLAYLISTMODE _HRESULT_TYPEDEF_(0xC00D1081L)

//
// MessageId: NS_E_WMPCORE_ITEMNOTINPLAYLIST
//
// MessageText:
//
// Windows Media Player cannot play the file because it is not in the current playlist.%0
//
#define NS_E_WMPCORE_ITEMNOTINPLAYLIST   _HRESULT_TYPEDEF_(0xC00D1086L)

//
// MessageId: NS_E_WMPCORE_PLAYLISTEMPTY
//
// MessageText:
//
// There are no items in the playlist. Add items to the playlist, and then try again.%0
//
#define NS_E_WMPCORE_PLAYLISTEMPTY       _HRESULT_TYPEDEF_(0xC00D1087L)

//
// MessageId: NS_E_WMPCORE_NOBROWSER
//
// MessageText:
//
// The Web page cannot be displayed because no Web browser is installed on your computer.%0
//
#define NS_E_WMPCORE_NOBROWSER           _HRESULT_TYPEDEF_(0xC00D1088L)

//
// MessageId: NS_E_WMPCORE_UNRECOGNIZED_MEDIA_URL
//
// MessageText:
//
// Windows Media Player cannot find the specified file. Verify the path is typed correctly. If it is, the file does not exist in the specified location, or the computer where the file is stored is not available.%0
//
#define NS_E_WMPCORE_UNRECOGNIZED_MEDIA_URL _HRESULT_TYPEDEF_(0xC00D1089L)

//
// MessageId: NS_E_WMPCORE_GRAPH_NOT_IN_LIST
//
// MessageText:
//
// Graph with the specified URL was not found in the prerolled graph list.%0
//
#define NS_E_WMPCORE_GRAPH_NOT_IN_LIST   _HRESULT_TYPEDEF_(0xC00D108AL)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EMPTY_OR_SINGLE_MEDIA
//
// MessageText:
//
// Windows Media Player cannot perform the requested operation because there is only one item in the playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_EMPTY_OR_SINGLE_MEDIA _HRESULT_TYPEDEF_(0xC00D108BL)

//
// MessageId: NS_E_WMPCORE_ERRORSINKNOTREGISTERED
//
// MessageText:
//
// An error sink was never registered for the calling object.%0
//
#define NS_E_WMPCORE_ERRORSINKNOTREGISTERED _HRESULT_TYPEDEF_(0xC00D108CL)

//
// MessageId: NS_E_WMPCORE_ERRORMANAGERNOTAVAILABLE
//
// MessageText:
//
// The error manager is not available to respond to errors.%0
//
#define NS_E_WMPCORE_ERRORMANAGERNOTAVAILABLE _HRESULT_TYPEDEF_(0xC00D108DL)

//
// MessageId: NS_E_WMPCORE_WEBHELPFAILED
//
// MessageText:
//
// The Web Help URL cannot be opened.%0
//
#define NS_E_WMPCORE_WEBHELPFAILED       _HRESULT_TYPEDEF_(0xC00D108EL)

//
// MessageId: NS_E_WMPCORE_MEDIA_ERROR_RESUME_FAILED
//
// MessageText:
//
// Could not resume playing next item in playlist.%0
//
#define NS_E_WMPCORE_MEDIA_ERROR_RESUME_FAILED _HRESULT_TYPEDEF_(0xC00D108FL)

//
// MessageId: NS_E_WMPCORE_NO_REF_IN_ENTRY
//
// MessageText:
//
// Windows Media Player cannot play the file because the associated playlist does not contain any items or the playlist is not valid.%0
//
#define NS_E_WMPCORE_NO_REF_IN_ENTRY     _HRESULT_TYPEDEF_(0xC00D1090L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_EMPTY
//
// MessageText:
//
// An empty string for playlist attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_EMPTY _HRESULT_TYPEDEF_(0xC00D1091L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_ILLEGAL
//
// MessageText:
//
// A playlist attribute name that is not valid was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_NAME_ILLEGAL _HRESULT_TYPEDEF_(0xC00D1092L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_EMPTY
//
// MessageText:
//
// An empty string for a playlist attribute value was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_EMPTY _HRESULT_TYPEDEF_(0xC00D1093L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_ILLEGAL
//
// MessageText:
//
// An illegal value for a playlist attribute was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ATTRIBUTE_VALUE_ILLEGAL _HRESULT_TYPEDEF_(0xC00D1094L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_EMPTY
//
// MessageText:
//
// An empty string for a playlist item attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_EMPTY _HRESULT_TYPEDEF_(0xC00D1095L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_ILLEGAL
//
// MessageText:
//
// An illegal value for a playlist item attribute name was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_NAME_ILLEGAL _HRESULT_TYPEDEF_(0xC00D1096L)

//
// MessageId: NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_VALUE_EMPTY
//
// MessageText:
//
// An illegal value for a playlist item attribute was found.%0
//
#define NS_E_WMPCORE_WMX_LIST_ITEM_ATTRIBUTE_VALUE_EMPTY _HRESULT_TYPEDEF_(0xC00D1097L)

//
// MessageId: NS_E_WMPCORE_LIST_ENTRY_NO_REF
//
// MessageText:
//
// The playlist does not contain any items.%0
//
#define NS_E_WMPCORE_LIST_ENTRY_NO_REF   _HRESULT_TYPEDEF_(0xC00D1098L)

//
// MessageId: NS_E_WMPCORE_MISNAMED_FILE
//
// MessageText:
//
// Windows Media Player cannot play the file. The file is either corrupted or the Player does not support the format you are trying to play.%0
//
#define NS_E_WMPCORE_MISNAMED_FILE       _HRESULT_TYPEDEF_(0xC00D1099L)

//
// MessageId: NS_E_WMPCORE_CODEC_NOT_TRUSTED
//
// MessageText:
//
// The codec downloaded for this file does not appear to be properly signed, so it cannot be installed.%0
//
#define NS_E_WMPCORE_CODEC_NOT_TRUSTED   _HRESULT_TYPEDEF_(0xC00D109AL)

//
// MessageId: NS_E_WMPCORE_CODEC_NOT_FOUND
//
// MessageText:
//
// Windows Media Player cannot play the file. One or more codecs required to play the file could not be found.%0
//
#define NS_E_WMPCORE_CODEC_NOT_FOUND     _HRESULT_TYPEDEF_(0xC00D109BL)

//
// MessageId: NS_E_WMPCORE_CODEC_DOWNLOAD_NOT_ALLOWED
//
// MessageText:
//
// Windows Media Player cannot play the file because a required codec is not installed on your computer. To try downloading the codec, turn on the "Download codecs automatically" option.%0
//
#define NS_E_WMPCORE_CODEC_DOWNLOAD_NOT_ALLOWED _HRESULT_TYPEDEF_(0xC00D109CL)

//
// MessageId: NS_E_WMPCORE_ERROR_DOWNLOADING_PLAYLIST
//
// MessageText:
//
// Windows Media Player encountered a problem while downloading the playlist. For additional assistance, click Web Help.%0
//
#define NS_E_WMPCORE_ERROR_DOWNLOADING_PLAYLIST _HRESULT_TYPEDEF_(0xC00D109DL)

//
// MessageId: NS_E_WMPCORE_FAILED_TO_BUILD_PLAYLIST
//
// MessageText:
//
// Failed to build the playlist.%0
//
#define NS_E_WMPCORE_FAILED_TO_BUILD_PLAYLIST _HRESULT_TYPEDEF_(0xC00D109EL)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NONE
//
// MessageText:
//
// Playlist has no alternates to switch into.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NONE _HRESULT_TYPEDEF_(0xC00D109FL)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_EXHAUSTED
//
// MessageText:
//
// No more playlist alternates available to switch to.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_EXHAUSTED _HRESULT_TYPEDEF_(0xC00D10A0L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NAME_NOT_FOUND
//
// MessageText:
//
// Could not find the name of the alternate playlist to switch into.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_NAME_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D10A1L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_MORPH_FAILED
//
// MessageText:
//
// Failed to switch to an alternate for this media.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_MORPH_FAILED _HRESULT_TYPEDEF_(0xC00D10A2L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_INIT_FAILED
//
// MessageText:
//
// Failed to initialize an alternate for the media.%0
//
#define NS_E_WMPCORE_PLAYLIST_ITEM_ALTERNATE_INIT_FAILED _HRESULT_TYPEDEF_(0xC00D10A3L)

//
// MessageId: NS_E_WMPCORE_MEDIA_ALTERNATE_REF_EMPTY
//
// MessageText:
//
// No URL specified for the roll over Refs in the playlist file.%0
//
#define NS_E_WMPCORE_MEDIA_ALTERNATE_REF_EMPTY _HRESULT_TYPEDEF_(0xC00D10A4L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_NO_EVENT_NAME
//
// MessageText:
//
// Encountered a playlist with no name.%0
//
#define NS_E_WMPCORE_PLAYLIST_NO_EVENT_NAME _HRESULT_TYPEDEF_(0xC00D10A5L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EVENT_ATTRIBUTE_ABSENT
//
// MessageText:
//
// A required attribute in the event block of the playlist was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_EVENT_ATTRIBUTE_ABSENT _HRESULT_TYPEDEF_(0xC00D10A6L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EVENT_EMPTY
//
// MessageText:
//
// No items were found in the event block of the playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_EVENT_EMPTY _HRESULT_TYPEDEF_(0xC00D10A7L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_STACK_EMPTY
//
// MessageText:
//
// No playlist was found while returning from a nested playlist.%0
//
#define NS_E_WMPCORE_PLAYLIST_STACK_EMPTY _HRESULT_TYPEDEF_(0xC00D10A8L)

//
// MessageId: NS_E_WMPCORE_CURRENT_MEDIA_NOT_ACTIVE
//
// MessageText:
//
// The media item is not active currently.%0
//
#define NS_E_WMPCORE_CURRENT_MEDIA_NOT_ACTIVE _HRESULT_TYPEDEF_(0xC00D10A9L)

//
// MessageId: NS_E_WMPCORE_USER_CANCEL
//
// MessageText:
//
// Windows Media Player cannot perform the requested action because you chose to cancel it.%0
//
#define NS_E_WMPCORE_USER_CANCEL         _HRESULT_TYPEDEF_(0xC00D10ABL)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_EMPTY
//
// MessageText:
//
// Windows Media Player encountered a problem with the playlist. The format of the playlist is not valid.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_EMPTY _HRESULT_TYPEDEF_(0xC00D10ACL)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_START_MEDIA_NONE
//
// MessageText:
//
// Media object corresponding to start of a playlist repeat block was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_START_MEDIA_NONE _HRESULT_TYPEDEF_(0xC00D10ADL)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_REPEAT_END_MEDIA_NONE
//
// MessageText:
//
// Media object corresponding to the end of a playlist repeat block was not found.%0
//
#define NS_E_WMPCORE_PLAYLIST_REPEAT_END_MEDIA_NONE _HRESULT_TYPEDEF_(0xC00D10AEL)

//
// MessageId: NS_E_WMPCORE_INVALID_PLAYLIST_URL
//
// MessageText:
//
// The playlist URL supplied to the playlist manager is not valid.%0
//
#define NS_E_WMPCORE_INVALID_PLAYLIST_URL _HRESULT_TYPEDEF_(0xC00D10AFL)

//
// MessageId: NS_E_WMPCORE_MISMATCHED_RUNTIME
//
// MessageText:
//
// Windows Media Player cannot play the file because it is corrupted.%0
//
#define NS_E_WMPCORE_MISMATCHED_RUNTIME  _HRESULT_TYPEDEF_(0xC00D10B0L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_IMPORT_FAILED_NO_ITEMS
//
// MessageText:
//
// Windows Media Player cannot add the playlist to the library because the playlist does not contain any items.%0
//
#define NS_E_WMPCORE_PLAYLIST_IMPORT_FAILED_NO_ITEMS _HRESULT_TYPEDEF_(0xC00D10B1L)

//
// MessageId: NS_E_WMPCORE_VIDEO_TRANSFORM_FILTER_INSERTION
//
// MessageText:
//
// An error has occurred that could prevent the changing of the video contrast on this media.%0
//
#define NS_E_WMPCORE_VIDEO_TRANSFORM_FILTER_INSERTION _HRESULT_TYPEDEF_(0xC00D10B2L)

//
// MessageId: NS_E_WMPCORE_MEDIA_UNAVAILABLE
//
// MessageText:
//
// Windows Media Player cannot play the file. If the file is located on the Internet, connect to the Internet. If the file is located on a removable storage card, insert the storage card.%0
//
#define NS_E_WMPCORE_MEDIA_UNAVAILABLE   _HRESULT_TYPEDEF_(0xC00D10B3L)

//
// MessageId: NS_E_WMPCORE_WMX_ENTRYREF_NO_REF
//
// MessageText:
//
// The playlist contains an ENTRYREF for which no href was parsed. Check the syntax of playlist file.%0
//
#define NS_E_WMPCORE_WMX_ENTRYREF_NO_REF _HRESULT_TYPEDEF_(0xC00D10B4L)

//
// MessageId: NS_E_WMPCORE_NO_PLAYABLE_MEDIA_IN_PLAYLIST
//
// MessageText:
//
// Windows Media Player cannot play any items in the playlist. To find information about the problem, click the Now Playing tab, and then click the icon next to each file in the List pane.%0
//
#define NS_E_WMPCORE_NO_PLAYABLE_MEDIA_IN_PLAYLIST _HRESULT_TYPEDEF_(0xC00D10B5L)

//
// MessageId: NS_E_WMPCORE_PLAYLIST_EMPTY_NESTED_PLAYLIST_SKIPPED_ITEMS
//
// MessageText:
//
// Windows Media Player cannot play some or all of the items in the playlist because the playlist is nested.%0
//
#define NS_E_WMPCORE_PLAYLIST_EMPTY_NESTED_PLAYLIST_SKIPPED_ITEMS _HRESULT_TYPEDEF_(0xC00D10B6L)

//
// MessageId: NS_E_WMPCORE_BUSY
//
// MessageText:
//
// Windows Media Player cannot play the file at this time. Try again later.%0
//
#define NS_E_WMPCORE_BUSY                _HRESULT_TYPEDEF_(0xC00D10B7L)

//
// MessageId: NS_E_WMPCORE_MEDIA_CHILD_PLAYLIST_UNAVAILABLE
//
// MessageText:
//
// There is no child playlist available for this media item at this time.%0
//
#define NS_E_WMPCORE_MEDIA_CHILD_PLAYLIST_UNAVAILABLE _HRESULT_TYPEDEF_(0xC00D10B8L)

//
// MessageId: NS_E_WMPCORE_MEDIA_NO_CHILD_PLAYLIST
//
// MessageText:
//
// There is no child playlist for this media item.%0
//
#define NS_E_WMPCORE_MEDIA_NO_CHILD_PLAYLIST _HRESULT_TYPEDEF_(0xC00D10B9L)

//
// MessageId: NS_E_WMPCORE_FILE_NOT_FOUND
//
// MessageText:
//
// Windows Media Player cannot find the file. The link from the item in the library to its associated digital media file might be broken. To fix the problem, try repairing the link or removing the item from the library.%0
//
#define NS_E_WMPCORE_FILE_NOT_FOUND      _HRESULT_TYPEDEF_(0xC00D10BAL)

//
// MessageId: NS_E_WMPCORE_TEMP_FILE_NOT_FOUND
//
// MessageText:
//
// The temporary file was not found.%0
//
#define NS_E_WMPCORE_TEMP_FILE_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D10BBL)

//
// MessageId: NS_E_WMDM_REVOKED
//
// MessageText:
//
// Windows Media Player cannot sync the file because the device needs to be updated.%0
//
#define NS_E_WMDM_REVOKED                _HRESULT_TYPEDEF_(0xC00D10BCL)

//
// MessageId: NS_E_DDRAW_GENERIC
//
// MessageText:
//
// Windows Media Player cannot play the video because there is a problem with your video card.%0
//
#define NS_E_DDRAW_GENERIC               _HRESULT_TYPEDEF_(0xC00D10BDL)

//
// MessageId: NS_E_DISPLAY_MODE_CHANGE_FAILED
//
// MessageText:
//
// Windows Media Player failed to change the screen mode for full-screen video playback.%0
//
#define NS_E_DISPLAY_MODE_CHANGE_FAILED  _HRESULT_TYPEDEF_(0xC00D10BEL)

//
// MessageId: NS_E_PLAYLIST_CONTAINS_ERRORS
//
// MessageText:
//
// Windows Media Player cannot play one or more files.  For additional information, right-click an item that cannot be played, and then click Error Details.%0
//
#define NS_E_PLAYLIST_CONTAINS_ERRORS    _HRESULT_TYPEDEF_(0xC00D10BFL)

//
// MessageId: NS_E_CHANGING_PROXY_NAME
//
// MessageText:
//
// Cannot change the proxy name if the proxy setting is not set to custom.%0
//
#define NS_E_CHANGING_PROXY_NAME         _HRESULT_TYPEDEF_(0xC00D10C0L)

//
// MessageId: NS_E_CHANGING_PROXY_PORT
//
// MessageText:
//
// Cannot change the proxy port if the proxy setting is not set to custom.%0
//
#define NS_E_CHANGING_PROXY_PORT         _HRESULT_TYPEDEF_(0xC00D10C1L)

//
// MessageId: NS_E_CHANGING_PROXY_EXCEPTIONLIST
//
// MessageText:
//
// Cannot change the proxy exception list if the proxy setting is not set to custom.%0
//
#define NS_E_CHANGING_PROXY_EXCEPTIONLIST _HRESULT_TYPEDEF_(0xC00D10C2L)

//
// MessageId: NS_E_CHANGING_PROXYBYPASS
//
// MessageText:
//
// Cannot change the proxy bypass flag if the proxy setting is not set to custom.%0
//
#define NS_E_CHANGING_PROXYBYPASS        _HRESULT_TYPEDEF_(0xC00D10C3L)

//
// MessageId: NS_E_CHANGING_PROXY_PROTOCOL_NOT_FOUND
//
// MessageText:
//
// Cannot find the specified protocol.%0
//
#define NS_E_CHANGING_PROXY_PROTOCOL_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D10C4L)

//
// MessageId: NS_E_GRAPH_NOAUDIOLANGUAGE
//
// MessageText:
//
// Cannot change the language settings. Either the graph has no audio or the audio only supports one language.%0
//
#define NS_E_GRAPH_NOAUDIOLANGUAGE       _HRESULT_TYPEDEF_(0xC00D10C5L)

//
// MessageId: NS_E_GRAPH_NOAUDIOLANGUAGESELECTED
//
// MessageText:
//
// The graph has no audio language selected.%0
//
#define NS_E_GRAPH_NOAUDIOLANGUAGESELECTED _HRESULT_TYPEDEF_(0xC00D10C6L)

//
// MessageId: NS_E_CORECD_NOTAMEDIACD
//
// MessageText:
//
// This is not a media CD.%0
//
#define NS_E_CORECD_NOTAMEDIACD          _HRESULT_TYPEDEF_(0xC00D10C7L)

//
// MessageId: NS_E_WMPCORE_MEDIA_URL_TOO_LONG
//
// MessageText:
//
// Windows Media Player cannot play the file because the URL is too long.%0
//
#define NS_E_WMPCORE_MEDIA_URL_TOO_LONG  _HRESULT_TYPEDEF_(0xC00D10C8L)

//
// MessageId: NS_E_WMPFLASH_CANT_FIND_COM_SERVER
//
// MessageText:
//
// To play the selected item, you must install the Macromedia Flash Player. To download the Macromedia Flash Player, go to the Adobe Web site.%0
//
#define NS_E_WMPFLASH_CANT_FIND_COM_SERVER _HRESULT_TYPEDEF_(0xC00D10C9L)

//
// MessageId: NS_E_WMPFLASH_INCOMPATIBLEVERSION
//
// MessageText:
//
// To play the selected item, you must install a later version of the Macromedia Flash Player. To download the Macromedia Flash Player, go to the Adobe Web site.%0
//
#define NS_E_WMPFLASH_INCOMPATIBLEVERSION _HRESULT_TYPEDEF_(0xC00D10CAL)

//
// MessageId: NS_E_WMPOCXGRAPH_IE_DISALLOWS_ACTIVEX_CONTROLS
//
// MessageText:
//
// Windows Media Player cannot play the file because your Internet security settings prohibit the use of ActiveX controls.%0
//
#define NS_E_WMPOCXGRAPH_IE_DISALLOWS_ACTIVEX_CONTROLS _HRESULT_TYPEDEF_(0xC00D10CBL)

//
// MessageId: NS_E_NEED_CORE_REFERENCE
//
// MessageText:
//
// The use of this method requires an existing reference to the Player object.%0
//
#define NS_E_NEED_CORE_REFERENCE         _HRESULT_TYPEDEF_(0xC00D10CCL)

//
// MessageId: NS_E_MEDIACD_READ_ERROR
//
// MessageText:
//
// Windows Media Player cannot play the CD. The disc might be dirty or damaged.%0
//
#define NS_E_MEDIACD_READ_ERROR          _HRESULT_TYPEDEF_(0xC00D10CDL)

//
// MessageId: NS_E_IE_DISALLOWS_ACTIVEX_CONTROLS
//
// MessageText:
//
// Windows Media Player cannot play the file because your Internet security settings prohibit the use of ActiveX controls.%0
//
#define NS_E_IE_DISALLOWS_ACTIVEX_CONTROLS _HRESULT_TYPEDEF_(0xC00D10CEL)

//
// MessageId: NS_E_FLASH_PLAYBACK_NOT_ALLOWED
//
// MessageText:
//
// Flash playback has been turned off in Windows Media Player.%0
//
#define NS_E_FLASH_PLAYBACK_NOT_ALLOWED  _HRESULT_TYPEDEF_(0xC00D10CFL)

//
// MessageId: NS_E_UNABLE_TO_CREATE_RIP_LOCATION
//
// MessageText:
//
// Windows Media Player cannot rip the CD because a valid rip location cannot be created.%0
//
#define NS_E_UNABLE_TO_CREATE_RIP_LOCATION _HRESULT_TYPEDEF_(0xC00D10D0L)

//
// MessageId: NS_E_WMPCORE_SOME_CODECS_MISSING
//
// MessageText:
//
// Windows Media Player cannot play the file because a required codec is not installed on your computer.%0
//
#define NS_E_WMPCORE_SOME_CODECS_MISSING _HRESULT_TYPEDEF_(0xC00D10D1L)

//
// MessageId: NS_E_WMP_RIP_FAILED
//
// MessageText:
//
// Windows Media Player cannot rip one or more tracks from the CD.%0
//
#define NS_E_WMP_RIP_FAILED              _HRESULT_TYPEDEF_(0xC00D10D2L)

//
// MessageId: NS_E_WMP_FAILED_TO_RIP_TRACK
//
// MessageText:
//
// Windows Media Player encountered a problem while ripping the track from the CD. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_FAILED_TO_RIP_TRACK     _HRESULT_TYPEDEF_(0xC00D10D3L)

//
// MessageId: NS_E_WMP_ERASE_FAILED
//
// MessageText:
//
// Windows Media Player encountered a problem while erasing the disc. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_ERASE_FAILED            _HRESULT_TYPEDEF_(0xC00D10D4L)

//
// MessageId: NS_E_WMP_FORMAT_FAILED
//
// MessageText:
//
// Windows Media Player encountered a problem while formatting the device. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_FORMAT_FAILED           _HRESULT_TYPEDEF_(0xC00D10D5L)

//
// MessageId: NS_E_WMP_CANNOT_BURN_NON_LOCAL_FILE
//
// MessageText:
//
// This file cannot be burned to a CD because it is not located on your computer.%0
//
#define NS_E_WMP_CANNOT_BURN_NON_LOCAL_FILE _HRESULT_TYPEDEF_(0xC00D10D6L)

//
// MessageId: NS_E_WMP_FILE_TYPE_CANNOT_BURN_TO_AUDIO_CD
//
// MessageText:
//
// It is not possible to burn this file type to an audio CD. Windows Media Player can burn the following file types to an audio CD: WMA, MP3, or WAV.%0
//
#define NS_E_WMP_FILE_TYPE_CANNOT_BURN_TO_AUDIO_CD _HRESULT_TYPEDEF_(0xC00D10D7L)

//
// MessageId: NS_E_WMP_FILE_DOES_NOT_FIT_ON_CD
//
// MessageText:
//
// This file is too large to fit on a disc.%0
//
#define NS_E_WMP_FILE_DOES_NOT_FIT_ON_CD _HRESULT_TYPEDEF_(0xC00D10D8L)

//
// MessageId: NS_E_WMP_FILE_NO_DURATION
//
// MessageText:
//
// It is not possible to determine if this file can fit on a disc because Windows Media Player cannot detect the length of the file. Playing the file before burning may enable the Player to detect the file length.%0
//
#define NS_E_WMP_FILE_NO_DURATION        _HRESULT_TYPEDEF_(0xC00D10D9L)

//
// MessageId: NS_E_PDA_FAILED_TO_BURN
//
// MessageText:
//
// Windows Media Player encountered a problem while burning the file to the disc. For additional assistance, click Web Help.%0
//
#define NS_E_PDA_FAILED_TO_BURN          _HRESULT_TYPEDEF_(0xC00D10DAL)

//
// MessageId: NS_S_NEED_TO_BUY_BURN_RIGHTS
//
// MessageText:
//
// No burn rights. You will be prompted to buy burn rights when you try to burn this file to an audio CD.%0
//
#define NS_S_NEED_TO_BUY_BURN_RIGHTS     _HRESULT_TYPEDEF_(0x000D10DBL)

//
// MessageId: NS_E_FAILED_DOWNLOAD_ABORT_BURN
//
// MessageText:
//
// Windows Media Player cannot burn the audio CD because some items in the list that you chose to buy could not be downloaded from the online store.%0
//
#define NS_E_FAILED_DOWNLOAD_ABORT_BURN  _HRESULT_TYPEDEF_(0xC00D10DCL)

//
// MessageId: NS_E_WMPCORE_DEVICE_DRIVERS_MISSING
//
// MessageText:
//
// Windows Media Player cannot play the file. Try using Windows Update or Device Manager to update the device drivers for your audio and video cards. For information about using Windows Update or Device Manager, see Windows Help.%0
//
#define NS_E_WMPCORE_DEVICE_DRIVERS_MISSING _HRESULT_TYPEDEF_(0xC00D10DDL)

//
// WMP Core  Success codes
//
//
// MessageId: NS_S_WMPCORE_PLAYLISTCLEARABORT
//
// MessageText:
//
// Failed to clear playlist because it was aborted by user.%0
//
#define NS_S_WMPCORE_PLAYLISTCLEARABORT  _HRESULT_TYPEDEF_(0x000D10FEL)

//
// MessageId: NS_S_WMPCORE_PLAYLISTREMOVEITEMABORT
//
// MessageText:
//
// Failed to remove item in the playlist since it was aborted by user.%0
//
#define NS_S_WMPCORE_PLAYLISTREMOVEITEMABORT _HRESULT_TYPEDEF_(0x000D10FFL)

//
// MessageId: NS_S_WMPCORE_PLAYLIST_CREATION_PENDING
//
// MessageText:
//
// Playlist is being generated asynchronously.%0
//
#define NS_S_WMPCORE_PLAYLIST_CREATION_PENDING _HRESULT_TYPEDEF_(0x000D1102L)

//
// MessageId: NS_S_WMPCORE_MEDIA_VALIDATION_PENDING
//
// MessageText:
//
// Validation of the media is pending...%0
//
#define NS_S_WMPCORE_MEDIA_VALIDATION_PENDING _HRESULT_TYPEDEF_(0x000D1103L)

//
// MessageId: NS_S_WMPCORE_PLAYLIST_REPEAT_SECONDARY_SEGMENTS_IGNORED
//
// MessageText:
//
// Encountered more than one Repeat block during ASX processing.%0
//
#define NS_S_WMPCORE_PLAYLIST_REPEAT_SECONDARY_SEGMENTS_IGNORED _HRESULT_TYPEDEF_(0x000D1104L)

//
// MessageId: NS_S_WMPCORE_COMMAND_NOT_AVAILABLE
//
// MessageText:
//
// Current state of WMP disallows calling this method or property.%0
//
#define NS_S_WMPCORE_COMMAND_NOT_AVAILABLE _HRESULT_TYPEDEF_(0x000D1105L)

//
// MessageId: NS_S_WMPCORE_PLAYLIST_NAME_AUTO_GENERATED
//
// MessageText:
//
// Name for the playlist has been auto generated.%0
//
#define NS_S_WMPCORE_PLAYLIST_NAME_AUTO_GENERATED _HRESULT_TYPEDEF_(0x000D1106L)

//
// MessageId: NS_S_WMPCORE_PLAYLIST_IMPORT_MISSING_ITEMS
//
// MessageText:
//
// The imported playlist does not contain all items from the original.%0
//
#define NS_S_WMPCORE_PLAYLIST_IMPORT_MISSING_ITEMS _HRESULT_TYPEDEF_(0x000D1107L)

//
// MessageId: NS_S_WMPCORE_PLAYLIST_COLLAPSED_TO_SINGLE_MEDIA
//
// MessageText:
//
// The M3U playlist has been ignored because it only contains one item.%0
//
#define NS_S_WMPCORE_PLAYLIST_COLLAPSED_TO_SINGLE_MEDIA _HRESULT_TYPEDEF_(0x000D1108L)

//
// MessageId: NS_S_WMPCORE_MEDIA_CHILD_PLAYLIST_OPEN_PENDING
//
// MessageText:
//
// The open for the child playlist associated with this media is pending.%0
//
#define NS_S_WMPCORE_MEDIA_CHILD_PLAYLIST_OPEN_PENDING _HRESULT_TYPEDEF_(0x000D1109L)

//
// MessageId: NS_S_WMPCORE_MORE_NODES_AVAIABLE
//
// MessageText:
//
// More nodes support the interface requested, but the array for returning them is full.%0
//
#define NS_S_WMPCORE_MORE_NODES_AVAIABLE _HRESULT_TYPEDEF_(0x000D110AL)

//
// WMP Internet Manager error codes
//
//
// MessageId: NS_E_WMPIM_USEROFFLINE
//
// MessageText:
//
// Windows Media Player has detected that you are not connected to the Internet. Connect to the Internet, and then try again.%0
//
#define NS_E_WMPIM_USEROFFLINE           _HRESULT_TYPEDEF_(0xC00D1126L)

//
// MessageId: NS_E_WMPIM_USERCANCELED
//
// MessageText:
//
// The attempt to connect to the Internet was canceled.%0
//
#define NS_E_WMPIM_USERCANCELED          _HRESULT_TYPEDEF_(0xC00D1127L)

//
// MessageId: NS_E_WMPIM_DIALUPFAILED
//
// MessageText:
//
// The attempt to connect to the Internet failed.%0
//
#define NS_E_WMPIM_DIALUPFAILED          _HRESULT_TYPEDEF_(0xC00D1128L)

//
// MessageId: NS_E_WINSOCK_ERROR_STRING
//
// MessageText:
//
// Windows Media Player has encountered an unknown network error.%0
//
#define NS_E_WINSOCK_ERROR_STRING        _HRESULT_TYPEDEF_(0xC00D1129L)

//
// WMP Backup and restore error and success codes
//
//
// MessageId: NS_E_WMPBR_NOLISTENER
//
// MessageText:
//
// No window is currently listening to Backup and Restore events.%0
//
#define NS_E_WMPBR_NOLISTENER            _HRESULT_TYPEDEF_(0xC00D1130L)

//
// MessageId: NS_E_WMPBR_BACKUPCANCEL
//
// MessageText:
//
// Your media usage rights were not backed up because the backup was canceled.%0
//
#define NS_E_WMPBR_BACKUPCANCEL          _HRESULT_TYPEDEF_(0xC00D1131L)

//
// MessageId: NS_E_WMPBR_RESTORECANCEL
//
// MessageText:
//
// Your media usage rights were not restored because the restoration was canceled.%0
//
#define NS_E_WMPBR_RESTORECANCEL         _HRESULT_TYPEDEF_(0xC00D1132L)

//
// MessageId: NS_E_WMPBR_ERRORWITHURL
//
// MessageText:
//
// An error occurred while backing up or restoring your media usage rights. A required Web page cannot be displayed.%0
//
#define NS_E_WMPBR_ERRORWITHURL          _HRESULT_TYPEDEF_(0xC00D1133L)

//
// MessageId: NS_E_WMPBR_NAMECOLLISION
//
// MessageText:
//
// Your media usage rights were not backed up because the backup was canceled.%0
//
#define NS_E_WMPBR_NAMECOLLISION         _HRESULT_TYPEDEF_(0xC00D1134L)

//
// MessageId: NS_S_WMPBR_SUCCESS
//
// MessageText:
//
// Backup or Restore successful!.%0
//
#define NS_S_WMPBR_SUCCESS               _HRESULT_TYPEDEF_(0x000D1135L)

//
// MessageId: NS_S_WMPBR_PARTIALSUCCESS
//
// MessageText:
//
// Transfer complete with limitations.%0
//
#define NS_S_WMPBR_PARTIALSUCCESS        _HRESULT_TYPEDEF_(0x000D1136L)

//
// MessageId: NS_E_WMPBR_DRIVE_INVALID
//
// MessageText:
//
// Windows Media Player cannot restore your media usage rights from the specified location. Choose another location, and then try again.%0
//
#define NS_E_WMPBR_DRIVE_INVALID         _HRESULT_TYPEDEF_(0xC00D1137L)

//
// MessageId: NS_E_WMPBR_BACKUPRESTOREFAILED
//
// MessageText:
//
// Windows Media Player cannot backup or restore your media usage rights.%0
//
#define NS_E_WMPBR_BACKUPRESTOREFAILED   _HRESULT_TYPEDEF_(0xC00D1138L)

//
// WMP Effects Success codes
//
//
// MessageId: NS_S_WMPEFFECT_TRANSPARENT
//
// MessageText:
//
// Request to the effects control to change transparency status to transparent.%0
//
#define NS_S_WMPEFFECT_TRANSPARENT       _HRESULT_TYPEDEF_(0x000D1144L)

//
// MessageId: NS_S_WMPEFFECT_OPAQUE
//
// MessageText:
//
// Request to the effects control to change transparency status to opaque.%0
//
#define NS_S_WMPEFFECT_OPAQUE            _HRESULT_TYPEDEF_(0x000D1145L)

//
// WMP Application Success codes
//
//
// MessageId: NS_S_OPERATION_PENDING
//
// MessageText:
//
// The requested application pane is performing an operation and will not be released.%0
//
#define NS_S_OPERATION_PENDING           _HRESULT_TYPEDEF_(0x000D114EL)

//
// WMP Convert Plugin error codes
//
//
// MessageId: NS_E_WMP_CONVERT_FILE_FAILED
//
// MessageText:
//
// Windows Media Player cannot add the file to the library.%0
//
#define NS_E_WMP_CONVERT_FILE_FAILED     _HRESULT_TYPEDEF_(0xC00D1158L)

//
// MessageId: NS_E_WMP_CONVERT_NO_RIGHTS_ERRORURL
//
// MessageText:
//
// Windows Media Player cannot add the file to the library because the content provider prohibits it. For assistance, contact the company that provided the file.%0
//
#define NS_E_WMP_CONVERT_NO_RIGHTS_ERRORURL _HRESULT_TYPEDEF_(0xC00D1159L)

//
// MessageId: NS_E_WMP_CONVERT_NO_RIGHTS_NOERRORURL
//
// MessageText:
//
// Windows Media Player cannot add the file to the library because the content provider prohibits it. For assistance, contact the company that provided the file.%0
//
#define NS_E_WMP_CONVERT_NO_RIGHTS_NOERRORURL _HRESULT_TYPEDEF_(0xC00D115AL)

//
// MessageId: NS_E_WMP_CONVERT_FILE_CORRUPT
//
// MessageText:
//
// Windows Media Player cannot add the file to the library. The file might not be valid.%0
//
#define NS_E_WMP_CONVERT_FILE_CORRUPT    _HRESULT_TYPEDEF_(0xC00D115BL)

//
// MessageId: NS_E_WMP_CONVERT_PLUGIN_UNAVAILABLE_ERRORURL
//
// MessageText:
//
// Windows Media Player cannot add the file to the library. The plug-in required to add the file is not installed properly. For assistance, click Web Help to display the Web site of the company that provided the file.%0
//
#define NS_E_WMP_CONVERT_PLUGIN_UNAVAILABLE_ERRORURL _HRESULT_TYPEDEF_(0xC00D115CL)

//
// MessageId: NS_E_WMP_CONVERT_PLUGIN_UNAVAILABLE_NOERRORURL
//
// MessageText:
//
// Windows Media Player cannot add the file to the library. The plug-in required to add the file is not installed properly. For assistance, contact the company that provided the file.%0
//
#define NS_E_WMP_CONVERT_PLUGIN_UNAVAILABLE_NOERRORURL _HRESULT_TYPEDEF_(0xC00D115DL)

//
// MessageId: NS_E_WMP_CONVERT_PLUGIN_UNKNOWN_FILE_OWNER
//
// MessageText:
//
// Windows Media Player cannot add the file to the library. The plug-in required to add the file is not installed properly. For assistance, contact the company that provided the file.%0
//
#define NS_E_WMP_CONVERT_PLUGIN_UNKNOWN_FILE_OWNER _HRESULT_TYPEDEF_(0xC00D115EL)

//
// WMP DVD Error Codes
//
//
// MessageId: NS_E_DVD_DISC_COPY_PROTECT_OUTPUT_NS
//
// MessageText:
//
// Windows Media Player cannot play this DVD. Try installing an updated driver for your video card or obtaining a newer video card.%0
//
#define NS_E_DVD_DISC_COPY_PROTECT_OUTPUT_NS _HRESULT_TYPEDEF_(0xC00D1160L)

//
// MessageId: NS_E_DVD_DISC_COPY_PROTECT_OUTPUT_FAILED
//
// MessageText:
//
// This DVD's resolution exceeds the maximum allowed by your component video outputs. Try reducing your screen resolution to 640 x 480, or turn off analog component outputs and use a VGA connection to your monitor.%0
//
#define NS_E_DVD_DISC_COPY_PROTECT_OUTPUT_FAILED _HRESULT_TYPEDEF_(0xC00D1161L)

//
// MessageId: NS_E_DVD_NO_SUBPICTURE_STREAM
//
// MessageText:
//
// Windows Media Player cannot display subtitles or highlights in DVD menus. Reinstall the DVD decoder or contact the DVD drive manufacturer to obtain an updated decoder.%0
//
#define NS_E_DVD_NO_SUBPICTURE_STREAM    _HRESULT_TYPEDEF_(0xC00D1162L)

//
// MessageId: NS_E_DVD_COPY_PROTECT
//
// MessageText:
//
// Windows Media Player cannot play this DVD because there is a problem with digital copy protection between your DVD drive, decoder, and video card. Try installing an updated driver for your video card.%0
//
#define NS_E_DVD_COPY_PROTECT            _HRESULT_TYPEDEF_(0xC00D1163L)

//
// MessageId: NS_E_DVD_AUTHORING_PROBLEM
//
// MessageText:
//
// Windows Media Player cannot play the DVD. The disc was created in a manner that the Player does not support.%0
//
#define NS_E_DVD_AUTHORING_PROBLEM       _HRESULT_TYPEDEF_(0xC00D1164L)

//
// MessageId: NS_E_DVD_INVALID_DISC_REGION
//
// MessageText:
//
// Windows Media Player cannot play the DVD because the disc prohibits playback in your region of the world. You must obtain a disc that is intended for your geographic region.%0
//
#define NS_E_DVD_INVALID_DISC_REGION     _HRESULT_TYPEDEF_(0xC00D1165L)

//
// MessageId: NS_E_DVD_COMPATIBLE_VIDEO_CARD
//
// MessageText:
//
// Windows Media Player cannot play the DVD because your video card does not support DVD playback.%0
//
#define NS_E_DVD_COMPATIBLE_VIDEO_CARD   _HRESULT_TYPEDEF_(0xC00D1166L)

//
// MessageId: NS_E_DVD_MACROVISION
//
// MessageText:
//
// Windows Media Player cannot play this DVD because it is not possible to turn on analog copy protection on the output display. Try installing an updated driver for your video card.%0
//
#define NS_E_DVD_MACROVISION             _HRESULT_TYPEDEF_(0xC00D1167L)

//
// MessageId: NS_E_DVD_SYSTEM_DECODER_REGION
//
// MessageText:
//
// Windows Media Player cannot play the DVD because the region assigned to your DVD drive does not match the region assigned to your DVD decoder.%0
//
#define NS_E_DVD_SYSTEM_DECODER_REGION   _HRESULT_TYPEDEF_(0xC00D1168L)

//
// MessageId: NS_E_DVD_DISC_DECODER_REGION
//
// MessageText:
//
// Windows Media Player cannot play the DVD because the disc prohibits playback in your region of the world. You must obtain a disc that is intended for your geographic region.%0
//
#define NS_E_DVD_DISC_DECODER_REGION     _HRESULT_TYPEDEF_(0xC00D1169L)

//
// MessageId: NS_E_DVD_NO_VIDEO_STREAM
//
// MessageText:
//
// Windows Media Player cannot play DVD video. You might need to adjust your Windows display settings. Open display settings in Control Panel, and then try lowering your screen resolution and color quality settings.%0
//
#define NS_E_DVD_NO_VIDEO_STREAM         _HRESULT_TYPEDEF_(0xC00D116AL)

//
// MessageId: NS_E_DVD_NO_AUDIO_STREAM
//
// MessageText:
//
// Windows Media Player cannot play DVD audio. Verify that your sound card is set up correctly, and then try again.%0
//
#define NS_E_DVD_NO_AUDIO_STREAM         _HRESULT_TYPEDEF_(0xC00D116BL)

//
// MessageId: NS_E_DVD_GRAPH_BUILDING
//
// MessageText:
//
// Windows Media Player cannot play DVD video. Close any open files and quit any other programs, and then try again. If the problem persists, restart your computer.%0
//
#define NS_E_DVD_GRAPH_BUILDING          _HRESULT_TYPEDEF_(0xC00D116CL)

//
// MessageId: NS_E_DVD_NO_DECODER
//
// MessageText:
//
// Windows Media Player cannot play the DVD because a compatible DVD decoder is not installed on your computer.%0
//
#define NS_E_DVD_NO_DECODER              _HRESULT_TYPEDEF_(0xC00D116DL)

//
// MessageId: NS_E_DVD_PARENTAL
//
// MessageText:
//
// Windows Media Player cannot play the scene because it has a parental rating higher than the rating that you are authorized to view.%0
//
#define NS_E_DVD_PARENTAL                _HRESULT_TYPEDEF_(0xC00D116EL)

//
// MessageId: NS_E_DVD_CANNOT_JUMP
//
// MessageText:
//
// Windows Media Player cannot skip to the requested location on the DVD.%0
//
#define NS_E_DVD_CANNOT_JUMP             _HRESULT_TYPEDEF_(0xC00D116FL)

//
// MessageId: NS_E_DVD_DEVICE_CONTENTION
//
// MessageText:
//
// Windows Media Player cannot play the DVD because it is currently in use by another program. Quit the other program that is using the DVD, and then try again.%0
//
#define NS_E_DVD_DEVICE_CONTENTION       _HRESULT_TYPEDEF_(0xC00D1170L)

//
// MessageId: NS_E_DVD_NO_VIDEO_MEMORY
//
// MessageText:
//
// Windows Media Player cannot play DVD video. You might need to adjust your Windows display settings. Open display settings in Control Panel, and then try lowering your screen resolution and color quality settings.%0
//
#define NS_E_DVD_NO_VIDEO_MEMORY         _HRESULT_TYPEDEF_(0xC00D1171L)

//
// MessageId: NS_E_DVD_CANNOT_COPY_PROTECTED
//
// MessageText:
//
// Windows Media Player cannot rip the DVD because it is copy protected.%0
//
#define NS_E_DVD_CANNOT_COPY_PROTECTED   _HRESULT_TYPEDEF_(0xC00D1172L)

//
// MessageId: NS_E_DVD_REQUIRED_PROPERTY_NOT_SET
//
// MessageText:
//
// One of more of the required properties has not been set.%0
//
#define NS_E_DVD_REQUIRED_PROPERTY_NOT_SET _HRESULT_TYPEDEF_(0xC00D1173L)

//
// MessageId: NS_E_DVD_INVALID_TITLE_CHAPTER
//
// MessageText:
//
// The specified title and/or chapter number does not exist on this DVD.%0
//
#define NS_E_DVD_INVALID_TITLE_CHAPTER   _HRESULT_TYPEDEF_(0xC00D1174L)

//
// WMP PDA Error codes
//
//
// MessageId: NS_E_NO_CD_BURNER
//
// MessageText:
//
// Windows Media Player cannot burn the files because the Player cannot find a burner. If the burner is connected properly, try using Windows Update to install the latest device driver.%0
//
#define NS_E_NO_CD_BURNER                _HRESULT_TYPEDEF_(0xC00D1176L)

//
// MessageId: NS_E_DEVICE_IS_NOT_READY
//
// MessageText:
//
// Windows Media Player does not detect storage media in the selected device. Insert storage media into the device, and then try again.%0
//
#define NS_E_DEVICE_IS_NOT_READY         _HRESULT_TYPEDEF_(0xC00D1177L)

//
// MessageId: NS_E_PDA_UNSUPPORTED_FORMAT
//
// MessageText:
//
// Windows Media Player cannot sync this file. The Player might not support the file type.%0
//
#define NS_E_PDA_UNSUPPORTED_FORMAT      _HRESULT_TYPEDEF_(0xC00D1178L)

//
// MessageId: NS_E_NO_PDA
//
// MessageText:
//
// Windows Media Player does not detect a portable device. Connect your portable device, and then try again.%0
//
#define NS_E_NO_PDA                      _HRESULT_TYPEDEF_(0xC00D1179L)

//
// MessageId: NS_E_PDA_UNSPECIFIED_ERROR
//
// MessageText:
//
// Windows Media Player encountered an error while communicating with the device. The storage card on the device might be full, the device might be turned off, or the device might not allow playlists or folders to be created on it.%0
//
#define NS_E_PDA_UNSPECIFIED_ERROR       _HRESULT_TYPEDEF_(0xC00D117AL)

//
// MessageId: NS_E_MEMSTORAGE_BAD_DATA
//
// MessageText:
//
// Windows Media Player encountered an error while burning a CD.%0
//
#define NS_E_MEMSTORAGE_BAD_DATA         _HRESULT_TYPEDEF_(0xC00D117BL)

//
// MessageId: NS_E_PDA_FAIL_SELECT_DEVICE
//
// MessageText:
//
// Windows Media Player encountered an error while communicating with a portable device or CD drive.%0
//
#define NS_E_PDA_FAIL_SELECT_DEVICE      _HRESULT_TYPEDEF_(0xC00D117CL)

//
// MessageId: NS_E_PDA_FAIL_READ_WAVE_FILE
//
// MessageText:
//
// Windows Media Player cannot open the WAV file.%0
//
#define NS_E_PDA_FAIL_READ_WAVE_FILE     _HRESULT_TYPEDEF_(0xC00D117DL)

//
// MessageId: NS_E_IMAPI_LOSSOFSTREAMING
//
// MessageText:
//
// Windows Media Player failed to burn all the files to the CD. Select a slower recording speed, and then try again.%0
//
#define NS_E_IMAPI_LOSSOFSTREAMING       _HRESULT_TYPEDEF_(0xC00D117EL)

//
// MessageId: NS_E_PDA_DEVICE_FULL
//
// MessageText:
//
// There is not enough storage space on the portable device to complete this operation. Delete some unneeded files on the portable device, and then try again.%0
//
#define NS_E_PDA_DEVICE_FULL             _HRESULT_TYPEDEF_(0xC00D117FL)

//
// MessageId: NS_E_FAIL_LAUNCH_ROXIO_PLUGIN
//
// MessageText:
//
// Windows Media Player cannot burn the files. Verify that your burner is connected properly, and then try again. If the problem persists, reinstall the Player.%0
//
#define NS_E_FAIL_LAUNCH_ROXIO_PLUGIN    _HRESULT_TYPEDEF_(0xC00D1180L)

//
// MessageId: NS_E_PDA_DEVICE_FULL_IN_SESSION
//
// MessageText:
//
// Windows Media Player did not sync some files to the device because there is not enough storage space on the device.%0
//
#define NS_E_PDA_DEVICE_FULL_IN_SESSION  _HRESULT_TYPEDEF_(0xC00D1181L)

//
// MessageId: NS_E_IMAPI_MEDIUM_INVALIDTYPE
//
// MessageText:
//
// The disc in the burner is not valid. Insert a blank disc into the burner, and then try again.%0
//
#define NS_E_IMAPI_MEDIUM_INVALIDTYPE    _HRESULT_TYPEDEF_(0xC00D1182L)

//
// MessageId: NS_E_PDA_MANUALDEVICE
//
// MessageText:
//
// Windows Media Player cannot perform the requested action because the device does not support sync.%0
//
#define NS_E_PDA_MANUALDEVICE            _HRESULT_TYPEDEF_(0xC00D1183L)

//
// MessageId: NS_E_PDA_PARTNERSHIPNOTEXIST
//
// MessageText:
//
// To perform the requested action, you must first set up sync with the device.%0
//
#define NS_E_PDA_PARTNERSHIPNOTEXIST     _HRESULT_TYPEDEF_(0xC00D1184L)

//
// MessageId: NS_E_PDA_CANNOT_CREATE_ADDITIONAL_SYNC_RELATIONSHIP
//
// MessageText:
//
// You have already created sync partnerships with 16 devices. To create a new sync partnership, you must first end an existing partnership.%0
//
#define NS_E_PDA_CANNOT_CREATE_ADDITIONAL_SYNC_RELATIONSHIP _HRESULT_TYPEDEF_(0xC00D1185L)

//
// MessageId: NS_E_PDA_NO_TRANSCODE_OF_DRM
//
// MessageText:
//
// Windows Media Player cannot sync the file because protected files cannot be converted to the required quality level or file format.%0
//
#define NS_E_PDA_NO_TRANSCODE_OF_DRM     _HRESULT_TYPEDEF_(0xC00D1186L)

//
// MessageId: NS_E_PDA_TRANSCODECACHEFULL
//
// MessageText:
//
// The folder that stores converted files is full. Either empty the folder or increase its size, and then try again.%0
//
#define NS_E_PDA_TRANSCODECACHEFULL      _HRESULT_TYPEDEF_(0xC00D1187L)

//
// MessageId: NS_E_PDA_TOO_MANY_FILE_COLLISIONS
//
// MessageText:
//
// There are too many files with the same name in the folder on the device. Change the file name or sync to a different folder.%0
//
#define NS_E_PDA_TOO_MANY_FILE_COLLISIONS _HRESULT_TYPEDEF_(0xC00D1188L)

//
// MessageId: NS_E_PDA_CANNOT_TRANSCODE
//
// MessageText:
//
// Windows Media Player cannot convert the file to the format required by the device.%0
//
#define NS_E_PDA_CANNOT_TRANSCODE        _HRESULT_TYPEDEF_(0xC00D1189L)

//
// MessageId: NS_E_PDA_TOO_MANY_FILES_IN_DIRECTORY
//
// MessageText:
//
// You have reached the maximum number of files your device allows in a folder. If your device supports playback from subfolders, try creating subfolders on the device and storing some files in them.%0
//
#define NS_E_PDA_TOO_MANY_FILES_IN_DIRECTORY _HRESULT_TYPEDEF_(0xC00D118AL)

//
// MessageId: NS_E_PROCESSINGSHOWSYNCWIZARD
//
// MessageText:
//
// Windows Media Player is already trying to start the Device Setup Wizard.%0
//
#define NS_E_PROCESSINGSHOWSYNCWIZARD    _HRESULT_TYPEDEF_(0xC00D118BL)

//
// MessageId: NS_E_PDA_TRANSCODE_NOT_PERMITTED
//
// MessageText:
//
// Windows Media Player cannot convert this file format. If an updated version of the codec used to compress this file is available, install it and then try to sync the file again.%0
//
#define NS_E_PDA_TRANSCODE_NOT_PERMITTED _HRESULT_TYPEDEF_(0xC00D118CL)

//
// MessageId: NS_E_PDA_INITIALIZINGDEVICES
//
// MessageText:
//
// Windows Media Player is busy setting up devices. Try again later.%0
//
#define NS_E_PDA_INITIALIZINGDEVICES     _HRESULT_TYPEDEF_(0xC00D118DL)

//
// MessageId: NS_E_PDA_OBSOLETE_SP
//
// MessageText:
//
// Your device is using an outdated driver that is no longer supported by Windows Media Player. For additional assistance, click Web Help.%0
//
#define NS_E_PDA_OBSOLETE_SP             _HRESULT_TYPEDEF_(0xC00D118EL)

//
// MessageId: NS_E_PDA_TITLE_COLLISION
//
// MessageText:
//
// Windows Media Player cannot sync the file because a file with the same name already exists on the device. Change the file name or try to sync the file to a different folder.%0
//
#define NS_E_PDA_TITLE_COLLISION         _HRESULT_TYPEDEF_(0xC00D118FL)

//
// MessageId: NS_E_PDA_DEVICESUPPORTDISABLED
//
// MessageText:
//
// Automatic and manual sync have been turned off temporarily. To sync to a device, restart Windows Media Player.%0
//
#define NS_E_PDA_DEVICESUPPORTDISABLED   _HRESULT_TYPEDEF_(0xC00D1190L)

//
// MessageId: NS_E_PDA_NO_LONGER_AVAILABLE
//
// MessageText:
//
// This device is not available. Connect the device to the computer, and then try again.%0
//
#define NS_E_PDA_NO_LONGER_AVAILABLE     _HRESULT_TYPEDEF_(0xC00D1191L)

//
// MessageId: NS_E_PDA_ENCODER_NOT_RESPONDING
//
// MessageText:
//
// Windows Media Player cannot sync the file because an error occurred while converting the file to another quality level or format. If the problem persists, remove the file from the list of files to sync.%0
//
#define NS_E_PDA_ENCODER_NOT_RESPONDING  _HRESULT_TYPEDEF_(0xC00D1192L)

//
// MessageId: NS_E_PDA_CANNOT_SYNC_FROM_LOCATION
//
// MessageText:
//
// Windows Media Player cannot sync the file to your device. The file might be stored in a location that is not supported. Copy the file from its current location to your hard disk, add it to your library, and then try to sync the file again.%0
//
#define NS_E_PDA_CANNOT_SYNC_FROM_LOCATION _HRESULT_TYPEDEF_(0xC00D1193L)

//
// General Remapped Error codes in WMP
//
//
// MessageId: NS_E_WMP_PROTOCOL_PROBLEM
//
// MessageText:
//
// Windows Media Player cannot open the specified URL. Verify that the Player is configured to use all available protocols, and then try again.%0
//
#define NS_E_WMP_PROTOCOL_PROBLEM        _HRESULT_TYPEDEF_(0xC00D1194L)

//
// MessageId: NS_E_WMP_NO_DISK_SPACE
//
// MessageText:
//
// Windows Media Player cannot perform the requested action because there is not enough storage space on your computer. Delete some unneeded files on your hard disk, and then try again.%0
//
#define NS_E_WMP_NO_DISK_SPACE           _HRESULT_TYPEDEF_(0xC00D1195L)

//
// MessageId: NS_E_WMP_LOGON_FAILURE
//
// MessageText:
//
// The server denied access to the file. Verify that you are using the correct user name and password.%0
//
#define NS_E_WMP_LOGON_FAILURE           _HRESULT_TYPEDEF_(0xC00D1196L)

//
// MessageId: NS_E_WMP_CANNOT_FIND_FILE
//
// MessageText:
//
// Windows Media Player cannot find the file. If you are trying to play, burn, or sync an item that is in your library, the item might point to a file that has been moved, renamed, or deleted.%0
//
#define NS_E_WMP_CANNOT_FIND_FILE        _HRESULT_TYPEDEF_(0xC00D1197L)

//
// MessageId: NS_E_WMP_SERVER_INACCESSIBLE
//
// MessageText:
//
// Windows Media Player cannot connect to the server. The server name might not be correct, the server might not be available, or your proxy settings might not be correct.%0
//
#define NS_E_WMP_SERVER_INACCESSIBLE     _HRESULT_TYPEDEF_(0xC00D1198L)

//
// MessageId: NS_E_WMP_UNSUPPORTED_FORMAT
//
// MessageText:
//
// Windows Media Player cannot play the file. The Player might not support the file type or might not support the codec that was used to compress the file.%0
//
#define NS_E_WMP_UNSUPPORTED_FORMAT      _HRESULT_TYPEDEF_(0xC00D1199L)

//
// MessageId: NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT
//
// MessageText:
//
// Windows Media Player cannot play the file. The Player might not support the file type or a required codec might not be installed on your computer.%0
//
#define NS_E_WMP_DSHOW_UNSUPPORTED_FORMAT _HRESULT_TYPEDEF_(0xC00D119AL)

//
// MessageId: NS_E_WMP_PLAYLIST_EXISTS
//
// MessageText:
//
// Windows Media Player cannot create the playlist because the name already exists. Type a different playlist name.%0
//
#define NS_E_WMP_PLAYLIST_EXISTS         _HRESULT_TYPEDEF_(0xC00D119BL)

//
// MessageId: NS_E_WMP_NONMEDIA_FILES
//
// MessageText:
//
// Windows Media Player cannot delete the playlist because it contains items that are not digital media files. Any digital media files in the playlist were deleted.%0
//
#define NS_E_WMP_NONMEDIA_FILES          _HRESULT_TYPEDEF_(0xC00D119CL)

//
// MessageId: NS_E_WMP_INVALID_ASX
//
// MessageText:
//
// The playlist cannot be opened because it is stored in a shared folder on another computer. If possible, move the playlist to the playlists folder on your computer.%0
//
#define NS_E_WMP_INVALID_ASX             _HRESULT_TYPEDEF_(0xC00D119DL)

//
// MessageId: NS_E_WMP_ALREADY_IN_USE
//
// MessageText:
//
// Windows Media Player is already in use. Stop playing any items, close all Player dialog boxes, and then try again.%0
//
#define NS_E_WMP_ALREADY_IN_USE          _HRESULT_TYPEDEF_(0xC00D119EL)

//
// MessageId: NS_E_WMP_IMAPI_FAILURE
//
// MessageText:
//
// Windows Media Player encountered an error while burning. Verify that the burner is connected properly and that the disc is clean and not damaged.%0
//
#define NS_E_WMP_IMAPI_FAILURE           _HRESULT_TYPEDEF_(0xC00D119FL)

//
// MessageId: NS_E_WMP_WMDM_FAILURE
//
// MessageText:
//
// Windows Media Player has encountered an unknown error with your portable device. Reconnect your portable device, and then try again.%0
//
#define NS_E_WMP_WMDM_FAILURE            _HRESULT_TYPEDEF_(0xC00D11A0L)

//
// MessageId: NS_E_WMP_CODEC_NEEDED_WITH_4CC
//
// MessageText:
//
// A codec is required to play this file. To determine if this codec is available to download from the Web, click Web Help.%0
//
#define NS_E_WMP_CODEC_NEEDED_WITH_4CC   _HRESULT_TYPEDEF_(0xC00D11A1L)

//
// MessageId: NS_E_WMP_CODEC_NEEDED_WITH_FORMATTAG
//
// MessageText:
//
// An audio codec is needed to play this file. To determine if this codec is available to download from the Web, click Web Help.%0
//
#define NS_E_WMP_CODEC_NEEDED_WITH_FORMATTAG _HRESULT_TYPEDEF_(0xC00D11A2L)

//
// MessageId: NS_E_WMP_MSSAP_NOT_AVAILABLE
//
// MessageText:
//
// To play the file, you must install the latest Windows service pack. To install the service pack from the Windows Update Web site, click Web Help.%0
//
#define NS_E_WMP_MSSAP_NOT_AVAILABLE     _HRESULT_TYPEDEF_(0xC00D11A3L)

//
// MessageId: NS_E_WMP_WMDM_INTERFACEDEAD
//
// MessageText:
//
// Windows Media Player no longer detects a portable device. Reconnect your portable device, and then try again.%0
//
#define NS_E_WMP_WMDM_INTERFACEDEAD      _HRESULT_TYPEDEF_(0xC00D11A4L)

//
// MessageId: NS_E_WMP_WMDM_NOTCERTIFIED
//
// MessageText:
//
// Windows Media Player cannot sync the file because the portable device does not support protected files.%0
//
#define NS_E_WMP_WMDM_NOTCERTIFIED       _HRESULT_TYPEDEF_(0xC00D11A5L)

//
// MessageId: NS_E_WMP_WMDM_LICENSE_NOTEXIST
//
// MessageText:
//
// This file does not have sync rights. If you obtained this file from an online store, go to the online store to get sync rights.%0
//
#define NS_E_WMP_WMDM_LICENSE_NOTEXIST   _HRESULT_TYPEDEF_(0xC00D11A6L)

//
// MessageId: NS_E_WMP_WMDM_LICENSE_EXPIRED
//
// MessageText:
//
// Windows Media Player cannot sync the file because the sync rights have expired. Go to the content provider's online store to get new sync rights.%0
//
#define NS_E_WMP_WMDM_LICENSE_EXPIRED    _HRESULT_TYPEDEF_(0xC00D11A7L)

//
// MessageId: NS_E_WMP_WMDM_BUSY
//
// MessageText:
//
// The portable device is already in use. Wait until the current task finishes or quit other programs that might be using the portable device, and then try again.%0
//
#define NS_E_WMP_WMDM_BUSY               _HRESULT_TYPEDEF_(0xC00D11A8L)

//
// MessageId: NS_E_WMP_WMDM_NORIGHTS
//
// MessageText:
//
// Windows Media Player cannot sync the file because the content provider or device prohibits it. You might be able to resolve this problem by going to the content provider's online store to get sync rights.%0
//
#define NS_E_WMP_WMDM_NORIGHTS           _HRESULT_TYPEDEF_(0xC00D11A9L)

//
// MessageId: NS_E_WMP_WMDM_INCORRECT_RIGHTS
//
// MessageText:
//
// The content provider has not granted you the right to sync this file. Go to the content provider's online store to get sync rights.%0
//
#define NS_E_WMP_WMDM_INCORRECT_RIGHTS   _HRESULT_TYPEDEF_(0xC00D11AAL)

//
// MessageId: NS_E_WMP_IMAPI_GENERIC
//
// MessageText:
//
// Windows Media Player cannot burn the files to the CD. Verify that the disc is clean and not damaged. If necessary, select a slower recording speed or try a different brand of blank discs.%0
//
#define NS_E_WMP_IMAPI_GENERIC           _HRESULT_TYPEDEF_(0xC00D11ABL)

//
// MessageId: NS_E_WMP_IMAPI_DEVICE_NOTPRESENT
//
// MessageText:
//
// Windows Media Player cannot burn the files. Verify that the burner is connected properly, and then try again.%0
//
#define NS_E_WMP_IMAPI_DEVICE_NOTPRESENT _HRESULT_TYPEDEF_(0xC00D11ADL)

//
// MessageId: NS_E_WMP_IMAPI_DEVICE_BUSY
//
// MessageText:
//
// Windows Media Player cannot burn the files. Verify that the burner is connected properly and that the disc is clean and not damaged. If the burner is already in use, wait until the current task finishes or quit other programs that might be using the burner.%0
//
#define NS_E_WMP_IMAPI_DEVICE_BUSY       _HRESULT_TYPEDEF_(0xC00D11AEL)

//
// MessageId: NS_E_WMP_IMAPI_LOSS_OF_STREAMING
//
// MessageText:
//
// Windows Media Player cannot burn the files to the CD.%0
//
#define NS_E_WMP_IMAPI_LOSS_OF_STREAMING _HRESULT_TYPEDEF_(0xC00D11AFL)

//
// MessageId: NS_E_WMP_SERVER_UNAVAILABLE
//
// MessageText:
//
// Windows Media Player cannot play the file. The server might not be available or there might be a problem with your network or firewall settings.%0
//
#define NS_E_WMP_SERVER_UNAVAILABLE      _HRESULT_TYPEDEF_(0xC00D11B0L)

//
// MessageId: NS_E_WMP_FILE_OPEN_FAILED
//
// MessageText:
//
// Windows Media Player encountered a problem while playing the file. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_FILE_OPEN_FAILED        _HRESULT_TYPEDEF_(0xC00D11B1L)

//
// MessageId: NS_E_WMP_VERIFY_ONLINE
//
// MessageText:
//
// Windows Media Player must connect to the Internet to verify the file's media usage rights. Connect to the Internet, and then try again.%0
//
#define NS_E_WMP_VERIFY_ONLINE           _HRESULT_TYPEDEF_(0xC00D11B2L)

//
// MessageId: NS_E_WMP_SERVER_NOT_RESPONDING
//
// MessageText:
//
// Windows Media Player cannot play the file because a network error occurred. The server might not be available. Verify that you are connected to the network and that your proxy settings are correct.%0
//
#define NS_E_WMP_SERVER_NOT_RESPONDING   _HRESULT_TYPEDEF_(0xC00D11B3L)

//
// MessageId: NS_E_WMP_DRM_CORRUPT_BACKUP
//
// MessageText:
//
// Windows Media Player cannot restore your media usage rights because it could not find any backed up rights on your computer.%0
//
#define NS_E_WMP_DRM_CORRUPT_BACKUP      _HRESULT_TYPEDEF_(0xC00D11B4L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_SERVER_UNAVAILABLE
//
// MessageText:
//
// Windows Media Player cannot download media usage rights because the server is not available (for example, the server might be busy or not online).%0
//
#define NS_E_WMP_DRM_LICENSE_SERVER_UNAVAILABLE _HRESULT_TYPEDEF_(0xC00D11B5L)

//
// MessageId: NS_E_WMP_NETWORK_FIREWALL
//
// MessageText:
//
// Windows Media Player cannot play the file. A network firewall might be preventing the Player from opening the file by using the UDP transport protocol. If you typed a URL in the Open URL dialog box, try using a different transport protocol (for example, "http:").%0
//
#define NS_E_WMP_NETWORK_FIREWALL        _HRESULT_TYPEDEF_(0xC00D11B6L)

//
// MessageId: NS_E_WMP_NO_REMOVABLE_MEDIA
//
// MessageText:
//
// Insert the removable media, and then try again.%0
//
#define NS_E_WMP_NO_REMOVABLE_MEDIA      _HRESULT_TYPEDEF_(0xC00D11B7L)

//
// MessageId: NS_E_WMP_PROXY_CONNECT_TIMEOUT
//
// MessageText:
//
// Windows Media Player cannot play the file because the proxy server is not responding. The proxy server might be temporarily unavailable or your Player proxy settings might not be valid.%0
//
#define NS_E_WMP_PROXY_CONNECT_TIMEOUT   _HRESULT_TYPEDEF_(0xC00D11B8L)

//
// MessageId: NS_E_WMP_NEED_UPGRADE
//
// MessageText:
//
// To play the file, you might need to install a later version of Windows Media Player. On the Help menu, click Check for Updates, and then follow the instructions. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_NEED_UPGRADE            _HRESULT_TYPEDEF_(0xC00D11B9L)

//
// MessageId: NS_E_WMP_AUDIO_HW_PROBLEM
//
// MessageText:
//
// Windows Media Player cannot play the file because there is a problem with your sound device. There might not be a sound device installed on your computer, it might be in use by another program, or it might not be functioning properly.%0
//
#define NS_E_WMP_AUDIO_HW_PROBLEM        _HRESULT_TYPEDEF_(0xC00D11BAL)

//
// MessageId: NS_E_WMP_INVALID_PROTOCOL
//
// MessageText:
//
// Windows Media Player cannot play the file because the specified protocol is not supported. If you typed a URL in the Open URL dialog box, try using a different transport protocol (for example, "http:" or "rtsp:").%0
//
#define NS_E_WMP_INVALID_PROTOCOL        _HRESULT_TYPEDEF_(0xC00D11BBL)

//
// MessageId: NS_E_WMP_INVALID_LIBRARY_ADD
//
// MessageText:
//
// Windows Media Player cannot add the file to the library because the file format is not supported.%0
//
#define NS_E_WMP_INVALID_LIBRARY_ADD     _HRESULT_TYPEDEF_(0xC00D11BCL)

//
// MessageId: NS_E_WMP_MMS_NOT_SUPPORTED
//
// MessageText:
//
// Windows Media Player cannot play the file because the specified protocol is not supported. If you typed a URL in the Open URL dialog box, try using a different transport protocol (for example, "mms:").%0
//
#define NS_E_WMP_MMS_NOT_SUPPORTED       _HRESULT_TYPEDEF_(0xC00D11BDL)

//
// MessageId: NS_E_WMP_NO_PROTOCOLS_SELECTED
//
// MessageText:
//
// Windows Media Player cannot play the file because there are no streaming protocols selected. Select one or more protocols, and then try again.%0
//
#define NS_E_WMP_NO_PROTOCOLS_SELECTED   _HRESULT_TYPEDEF_(0xC00D11BEL)

//
// MessageId: NS_E_WMP_GOFULLSCREEN_FAILED
//
// MessageText:
//
// Windows Media Player cannot switch to Full Screen. You might need to adjust your Windows display settings. Open display settings in Control Panel, and then try setting Hardware acceleration to Full.%0
//
#define NS_E_WMP_GOFULLSCREEN_FAILED     _HRESULT_TYPEDEF_(0xC00D11BFL)

//
// MessageId: NS_E_WMP_NETWORK_ERROR
//
// MessageText:
//
// Windows Media Player cannot play the file because a network error occurred. The server might not be available (for example, the server is busy or not online) or you might not be connected to the network.%0
//
#define NS_E_WMP_NETWORK_ERROR           _HRESULT_TYPEDEF_(0xC00D11C0L)

//
// MessageId: NS_E_WMP_CONNECT_TIMEOUT
//
// MessageText:
//
// Windows Media Player cannot play the file because the server is not responding. Verify that you are connected to the network, and then try again later.%0
//
#define NS_E_WMP_CONNECT_TIMEOUT         _HRESULT_TYPEDEF_(0xC00D11C1L)

//
// MessageId: NS_E_WMP_MULTICAST_DISABLED
//
// MessageText:
//
// Windows Media Player cannot play the file because the multicast protocol is not enabled. On the Tools menu, click Options, click the Network tab, and then select the Multicast check box. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_MULTICAST_DISABLED      _HRESULT_TYPEDEF_(0xC00D11C2L)

//
// MessageId: NS_E_WMP_SERVER_DNS_TIMEOUT
//
// MessageText:
//
// Windows Media Player cannot play the file because a network problem occurred. Verify that you are connected to the network, and then try again later.%0
//
#define NS_E_WMP_SERVER_DNS_TIMEOUT      _HRESULT_TYPEDEF_(0xC00D11C3L)

//
// MessageId: NS_E_WMP_PROXY_NOT_FOUND
//
// MessageText:
//
// Windows Media Player cannot play the file because the network proxy server cannot be found. Verify that your proxy settings are correct, and then try again.%0
//
#define NS_E_WMP_PROXY_NOT_FOUND         _HRESULT_TYPEDEF_(0xC00D11C4L)

//
// MessageId: NS_E_WMP_TAMPERED_CONTENT
//
// MessageText:
//
// Windows Media Player cannot play the file because it is corrupted.%0
//
#define NS_E_WMP_TAMPERED_CONTENT        _HRESULT_TYPEDEF_(0xC00D11C5L)

//
// MessageId: NS_E_WMP_OUTOFMEMORY
//
// MessageText:
//
// Your computer is running low on memory. Quit other programs, and then try again.%0
//
#define NS_E_WMP_OUTOFMEMORY             _HRESULT_TYPEDEF_(0xC00D11C6L)

//
// MessageId: NS_E_WMP_AUDIO_CODEC_NOT_INSTALLED
//
// MessageText:
//
// Windows Media Player cannot play, burn, rip, or sync the file because a required audio codec is not installed on your computer.%0
//
#define NS_E_WMP_AUDIO_CODEC_NOT_INSTALLED _HRESULT_TYPEDEF_(0xC00D11C7L)

//
// MessageId: NS_E_WMP_VIDEO_CODEC_NOT_INSTALLED
//
// MessageText:
//
// Windows Media Player cannot play the file because the required video codec is not installed on your computer.%0
//
#define NS_E_WMP_VIDEO_CODEC_NOT_INSTALLED _HRESULT_TYPEDEF_(0xC00D11C8L)

//
// MessageId: NS_E_WMP_IMAPI_DEVICE_INVALIDTYPE
//
// MessageText:
//
// Windows Media Player cannot burn the files. If the burner is busy, wait for the current task to finish. If necessary, verify that the burner is connected properly and that you have installed the latest device driver.%0
//
#define NS_E_WMP_IMAPI_DEVICE_INVALIDTYPE _HRESULT_TYPEDEF_(0xC00D11C9L)

//
// MessageId: NS_E_WMP_DRM_DRIVER_AUTH_FAILURE
//
// MessageText:
//
// Windows Media Player cannot play the protected file because there is a problem with your sound device. Try installing a new device driver or use a different sound device.%0
//
#define NS_E_WMP_DRM_DRIVER_AUTH_FAILURE _HRESULT_TYPEDEF_(0xC00D11CAL)

//
// MessageId: NS_E_WMP_NETWORK_RESOURCE_FAILURE
//
// MessageText:
//
// Windows Media Player encountered a network error. Restart the Player.%0
//
#define NS_E_WMP_NETWORK_RESOURCE_FAILURE _HRESULT_TYPEDEF_(0xC00D11CBL)

//
// MessageId: NS_E_WMP_UPGRADE_APPLICATION
//
// MessageText:
//
// Windows Media Player is not installed properly. Reinstall the Player.%0
//
#define NS_E_WMP_UPGRADE_APPLICATION     _HRESULT_TYPEDEF_(0xC00D11CCL)

//
// MessageId: NS_E_WMP_UNKNOWN_ERROR
//
// MessageText:
//
// Windows Media Player encountered an unknown error. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_UNKNOWN_ERROR           _HRESULT_TYPEDEF_(0xC00D11CDL)

//
// MessageId: NS_E_WMP_INVALID_KEY
//
// MessageText:
//
// Windows Media Player cannot play the file because the required codec is not valid.%0
//
#define NS_E_WMP_INVALID_KEY             _HRESULT_TYPEDEF_(0xC00D11CEL)

//
// MessageId: NS_E_WMP_CD_ANOTHER_USER
//
// MessageText:
//
// The CD drive is in use by another user. Wait for the task to complete, and then try again.%0
//
#define NS_E_WMP_CD_ANOTHER_USER         _HRESULT_TYPEDEF_(0xC00D11CFL)

//
// MessageId: NS_E_WMP_DRM_NEEDS_AUTHORIZATION
//
// MessageText:
//
// Windows Media Player cannot play, sync, or burn the protected file because a problem occurred with the Windows Media Digital Rights Management (DRM) system. You might need to connect to the Internet to update your DRM components. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_DRM_NEEDS_AUTHORIZATION _HRESULT_TYPEDEF_(0xC00D11D0L)

//
// MessageId: NS_E_WMP_BAD_DRIVER
//
// MessageText:
//
// Windows Media Player cannot play the file because there might be a problem with your sound or video device. Try installing an updated device driver.%0
//
#define NS_E_WMP_BAD_DRIVER              _HRESULT_TYPEDEF_(0xC00D11D1L)

//
// MessageId: NS_E_WMP_ACCESS_DENIED
//
// MessageText:
//
// Windows Media Player cannot access the file. The file might be in use, you might not have access to the computer where the file is stored, or your proxy settings might not be correct.%0
//
#define NS_E_WMP_ACCESS_DENIED           _HRESULT_TYPEDEF_(0xC00D11D2L)

//
// MessageId: NS_E_WMP_LICENSE_RESTRICTS
//
// MessageText:
//
// The content provider prohibits this action. Go to the content provider's online store to get new media usage rights.%0
//
#define NS_E_WMP_LICENSE_RESTRICTS       _HRESULT_TYPEDEF_(0xC00D11D3L)

//
// MessageId: NS_E_WMP_INVALID_REQUEST
//
// MessageText:
//
// Windows Media Player cannot perform the requested action at this time.%0
//
#define NS_E_WMP_INVALID_REQUEST         _HRESULT_TYPEDEF_(0xC00D11D4L)

//
// MessageId: NS_E_WMP_CD_STASH_NO_SPACE
//
// MessageText:
//
// Windows Media Player cannot burn the files because there is not enough free disk space to store the temporary files. Delete some unneeded files on your hard disk, and then try again.%0
//
#define NS_E_WMP_CD_STASH_NO_SPACE       _HRESULT_TYPEDEF_(0xC00D11D5L)

//
// MessageId: NS_E_WMP_DRM_NEW_HARDWARE
//
// MessageText:
//
// Your media usage rights have become corrupted or are no longer valid. This might happen if you have replaced hardware components in your computer.%0
//
#define NS_E_WMP_DRM_NEW_HARDWARE        _HRESULT_TYPEDEF_(0xC00D11D6L)

//
// MessageId: NS_E_WMP_DRM_INVALID_SIG
//
// MessageText:
//
// The required Windows Media Digital Rights Management (DRM) component cannot be validated. You might be able resolve the problem by reinstalling the Player.%0
//
#define NS_E_WMP_DRM_INVALID_SIG         _HRESULT_TYPEDEF_(0xC00D11D7L)

//
// MessageId: NS_E_WMP_DRM_CANNOT_RESTORE
//
// MessageText:
//
// You have exceeded your restore limit for the day. Try restoring your media usage rights tomorrow.%0
//
#define NS_E_WMP_DRM_CANNOT_RESTORE      _HRESULT_TYPEDEF_(0xC00D11D8L)

//
// MessageId: NS_E_WMP_BURN_DISC_OVERFLOW
//
// MessageText:
//
// Some files might not fit on the CD. The required space cannot be calculated accurately because some files might be missing duration information. To ensure the calculation is accurate, play the files that are missing duration information.%0
//
#define NS_E_WMP_BURN_DISC_OVERFLOW      _HRESULT_TYPEDEF_(0xC00D11D9L)

//
// MessageId: NS_E_WMP_DRM_GENERIC_LICENSE_FAILURE
//
// MessageText:
//
// Windows Media Player cannot verify the file's media usage rights. If you obtained this file from an online store, go to the online store to get the necessary rights.%0
//
#define NS_E_WMP_DRM_GENERIC_LICENSE_FAILURE _HRESULT_TYPEDEF_(0xC00D11DAL)

//
// MessageId: NS_E_WMP_DRM_NO_SECURE_CLOCK
//
// MessageText:
//
// It is not possible to sync because this device's internal clock is not set correctly. To set the clock, select the option to set the device clock on the Privacy tab of the Options dialog box, connect to the Internet, and then sync the device again. For additional assistance, click Web Help.%0
//
#define NS_E_WMP_DRM_NO_SECURE_CLOCK     _HRESULT_TYPEDEF_(0xC00D11DBL)

//
// MessageId: NS_E_WMP_DRM_NO_RIGHTS
//
// MessageText:
//
// Windows Media Player cannot play, burn, rip, or sync the protected file because you do not have the appropriate rights.%0
//
#define NS_E_WMP_DRM_NO_RIGHTS           _HRESULT_TYPEDEF_(0xC00D11DCL)

//
// MessageId: NS_E_WMP_DRM_INDIV_FAILED
//
// MessageText:
//
// Windows Media Player encountered an error during upgrade.%0
//
#define NS_E_WMP_DRM_INDIV_FAILED        _HRESULT_TYPEDEF_(0xC00D11DDL)

//
// MessageId: NS_E_WMP_SERVER_NONEWCONNECTIONS
//
// MessageText:
//
// Windows Media Player cannot connect to the server because it is not accepting any new connections. This could be because it has reached its maximum connection limit. Please try again later.%0
//
#define NS_E_WMP_SERVER_NONEWCONNECTIONS _HRESULT_TYPEDEF_(0xC00D11DEL)

//
// MessageId: NS_E_WMP_MULTIPLE_ERROR_IN_PLAYLIST
//
// MessageText:
//
// A number of queued files cannot be played. To find information about the problem, click the Now Playing tab, and then click the icon next to each file in the List pane.%0
//
#define NS_E_WMP_MULTIPLE_ERROR_IN_PLAYLIST _HRESULT_TYPEDEF_(0xC00D11DFL)

//
// MessageId: NS_E_WMP_IMAPI2_ERASE_FAIL
//
// MessageText:
//
// Windows Media Player encountered an error while erasing the rewritable CD or DVD. Verify that the CD or DVD burner is connected properly and that the disc is clean and not damaged.%0
//
#define NS_E_WMP_IMAPI2_ERASE_FAIL       _HRESULT_TYPEDEF_(0xC00D11E0L)

//
// MessageId: NS_E_WMP_IMAPI2_ERASE_DEVICE_BUSY
//
// MessageText:
//
// Windows Media Player cannot erase the rewritable CD or DVD. Verify that the CD or DVD burner is connected properly and that the disc is clean and not damaged. If the burner is already in use, wait until the current task finishes or quit other programs that might be using the burner.%0
//
#define NS_E_WMP_IMAPI2_ERASE_DEVICE_BUSY _HRESULT_TYPEDEF_(0xC00D11E1L)

//
// MessageId: NS_E_WMP_DRM_COMPONENT_FAILURE
//
// MessageText:
//
// A Windows Media Digital Rights Management (DRM) component encountered a problem. If you are trying to use a file that you obtained from an online store, try going to the online store and getting the appropriate usage rights.%0
//
#define NS_E_WMP_DRM_COMPONENT_FAILURE   _HRESULT_TYPEDEF_(0xC00D11E2L)

//
// MessageId: NS_E_WMP_DRM_NO_DEVICE_CERT
//
// MessageText:
//
// It is not possible to obtain device's certificate. Please contact the device manufacturer for a firmware update or for other steps to resolve this problem.%0
//
#define NS_E_WMP_DRM_NO_DEVICE_CERT      _HRESULT_TYPEDEF_(0xC00D11E3L)

//
// MessageId: NS_E_WMP_SERVER_SECURITY_ERROR
//
// MessageText:
//
// Windows Media Player encountered an error when connecting to the server. The security information from the server could not be validated.%0
//
#define NS_E_WMP_SERVER_SECURITY_ERROR   _HRESULT_TYPEDEF_(0xC00D11E4L)

//
// MessageId: NS_E_WMP_AUDIO_DEVICE_LOST
//
// MessageText:
//
// An audio device was disconnected or reconfigured. Verify that the audio device is connected, and then try to play the item again.%0
//
#define NS_E_WMP_AUDIO_DEVICE_LOST       _HRESULT_TYPEDEF_(0xC00D11E5L)

//
// MessageId: NS_E_WMP_IMAPI_MEDIA_INCOMPATIBLE
//
// MessageText:
//
// Windows Media Player could not complete burning because the disc is not compatible with your drive. Try inserting a different kind of recordable media or use a disc that supports a write speed that is compatible with your drive.%0
//
#define NS_E_WMP_IMAPI_MEDIA_INCOMPATIBLE _HRESULT_TYPEDEF_(0xC00D11E6L)

//
// WMP Sync Wizard Error codes extension 4590-4599
//
//
// MessageId: NS_E_SYNCWIZ_DEVICE_FULL
//
// MessageText:
//
// Windows Media Player cannot save the sync settings because your device is full. Delete some unneeded files on your device and then try again.%0
//
#define NS_E_SYNCWIZ_DEVICE_FULL         _HRESULT_TYPEDEF_(0xC00D11EEL)

//
// MessageId: NS_E_SYNCWIZ_CANNOT_CHANGE_SETTINGS
//
// MessageText:
//
// It is not possible to change sync settings at this time. Try again later.%0
//
#define NS_E_SYNCWIZ_CANNOT_CHANGE_SETTINGS _HRESULT_TYPEDEF_(0xC00D11EFL)

//
// MessageId: NS_E_TRANSCODE_DELETECACHEERROR
//
// MessageText:
//
// Windows Media Player cannot delete these files currently. If the Player is synchronizing, wait until it is complete and then try again.%0
//
#define NS_E_TRANSCODE_DELETECACHEERROR  _HRESULT_TYPEDEF_(0xC00D11F0L)

//
// WMP CD Filter Error codes extension
//
//
// MessageId: NS_E_CD_NO_BUFFERS_READ
//
// MessageText:
//
// Windows Media Player could not use digital mode to read the CD. The Player has automatically switched the CD drive to analog mode. To switch back to digital mode, use the Devices tab. For additional assistance, click Web Help.%0
//
#define NS_E_CD_NO_BUFFERS_READ          _HRESULT_TYPEDEF_(0xC00D11F8L)

//
// MessageId: NS_E_CD_EMPTY_TRACK_QUEUE
//
// MessageText:
//
// No CD track was specified for playback.%0
//
#define NS_E_CD_EMPTY_TRACK_QUEUE        _HRESULT_TYPEDEF_(0xC00D11F9L)

//
// MessageId: NS_E_CD_NO_READER
//
// MessageText:
//
// The CD filter was not able to create the CD reader.%0
//
#define NS_E_CD_NO_READER                _HRESULT_TYPEDEF_(0xC00D11FAL)

//
// MessageId: NS_E_CD_ISRC_INVALID
//
// MessageText:
//
// Invalid ISRC code.%0
//
#define NS_E_CD_ISRC_INVALID             _HRESULT_TYPEDEF_(0xC00D11FBL)

//
// MessageId: NS_E_CD_MEDIA_CATALOG_NUMBER_INVALID
//
// MessageText:
//
// Invalid Media Catalog Number.%0
//
#define NS_E_CD_MEDIA_CATALOG_NUMBER_INVALID _HRESULT_TYPEDEF_(0xC00D11FCL)

//
// MessageId: NS_E_SLOW_READ_DIGITAL_WITH_ERRORCORRECTION
//
// MessageText:
//
// Windows Media Player cannot play audio CDs correctly because the CD drive is slow and error correction is turned on. To increase performance, turn off playback error correction for this drive.%0
//
#define NS_E_SLOW_READ_DIGITAL_WITH_ERRORCORRECTION _HRESULT_TYPEDEF_(0xC00D11FDL)

//
// MessageId: NS_E_CD_SPEEDDETECT_NOT_ENOUGH_READS
//
// MessageText:
//
// Windows Media Player cannot estimate the CD drive's playback speed because the CD track is too short.%0
//
#define NS_E_CD_SPEEDDETECT_NOT_ENOUGH_READS _HRESULT_TYPEDEF_(0xC00D11FEL)

//
// MessageId: NS_E_CD_QUEUEING_DISABLED
//
// MessageText:
//
// Cannot queue the CD track because queuing is not enabled.%0
//
#define NS_E_CD_QUEUEING_DISABLED        _HRESULT_TYPEDEF_(0xC00D11FFL)

//
// WMP DRM error codes 4610-4630
//
//
// MessageId: NS_E_WMP_DRM_ACQUIRING_LICENSE
//
// MessageText:
//
// Windows Media Player cannot download additional media usage rights until the current download is complete.%0
//
#define NS_E_WMP_DRM_ACQUIRING_LICENSE   _HRESULT_TYPEDEF_(0xC00D1202L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_EXPIRED
//
// MessageText:
//
// The media usage rights for this file have expired or are no longer valid. If you obtained the file from an online store, sign in to the store, and then try again.%0
//
#define NS_E_WMP_DRM_LICENSE_EXPIRED     _HRESULT_TYPEDEF_(0xC00D1203L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_NOTACQUIRED
//
// MessageText:
//
// Windows Media Player cannot download the media usage rights for the file. If you obtained the file from an online store, sign in to the store, and then try again.%0
//
#define NS_E_WMP_DRM_LICENSE_NOTACQUIRED _HRESULT_TYPEDEF_(0xC00D1204L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_NOTENABLED
//
// MessageText:
//
// The media usage rights for this file are not yet valid. To see when they will become valid, right-click the file in the library, click Properties, and then click the Media Usage Rights tab.%0
//
#define NS_E_WMP_DRM_LICENSE_NOTENABLED  _HRESULT_TYPEDEF_(0xC00D1205L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_UNUSABLE
//
// MessageText:
//
// The media usage rights for this file are not valid. If you obtained this file from an online store, contact the store for assistance.%0
//
#define NS_E_WMP_DRM_LICENSE_UNUSABLE    _HRESULT_TYPEDEF_(0xC00D1206L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_CONTENT_REVOKED
//
// MessageText:
//
// The content provider has revoked the media usage rights for this file. If you obtained this file from an online store, ask the store if a new version of the file is available.%0
//
#define NS_E_WMP_DRM_LICENSE_CONTENT_REVOKED _HRESULT_TYPEDEF_(0xC00D1207L)

//
// MessageId: NS_E_WMP_DRM_LICENSE_NOSAP
//
// MessageText:
//
// The media usage rights for this file require a feature that is not supported in your current version of Windows Media Player or your current version of Windows. Try installing the latest version of the Player. If you obtained this file from an online store, contact the store for further assistance.%0
//
#define NS_E_WMP_DRM_LICENSE_NOSAP       _HRESULT_TYPEDEF_(0xC00D1208L)

//
// MessageId: NS_E_WMP_DRM_UNABLE_TO_ACQUIRE_LICENSE
//
// MessageText:
//
// Windows Media Player cannot download media usage rights at this time. Try again later.%0
//
#define NS_E_WMP_DRM_UNABLE_TO_ACQUIRE_LICENSE _HRESULT_TYPEDEF_(0xC00D1209L)

//
// MessageId: NS_E_WMP_LICENSE_REQUIRED
//
// MessageText:
//
// Windows Media Player cannot play, burn, or sync the file because the media usage rights are missing. If you obtained the file from an online store, sign in to the store, and then try again.%0
//
#define NS_E_WMP_LICENSE_REQUIRED        _HRESULT_TYPEDEF_(0xC00D120AL)

//
// MessageId: NS_E_WMP_PROTECTED_CONTENT
//
// MessageText:
//
// Windows Media Player cannot play, burn, or sync the file because the media usage rights are missing. If you obtained the file from an online store, sign in to the store, and then try again.%0
//
#define NS_E_WMP_PROTECTED_CONTENT       _HRESULT_TYPEDEF_(0xC00D120BL)

//
// WMP Policy error codes
//
//
// MessageId: NS_E_WMP_POLICY_VALUE_NOT_CONFIGURED
//
// MessageText:
//
// Windows Media Player cannot read a policy. This can occur when the policy does not exist in the registry or when the registry cannot be read.%0
//
#define NS_E_WMP_POLICY_VALUE_NOT_CONFIGURED _HRESULT_TYPEDEF_(0xC00D122AL)

//
// WMP SYNC error codes 4660 -- 4700
//
//
// MessageId: NS_E_PDA_CANNOT_SYNC_FROM_INTERNET
//
// MessageText:
//
// Windows Media Player cannot sync content streamed directly from the Internet. If possible, download the file to your computer, and then try to sync the file.%0
//
#define NS_E_PDA_CANNOT_SYNC_FROM_INTERNET _HRESULT_TYPEDEF_(0xC00D1234L)

//
// MessageId: NS_E_PDA_CANNOT_SYNC_INVALID_PLAYLIST
//
// MessageText:
//
// This playlist is not valid or is corrupted. Create a new playlist using Windows Media Player, then sync the new playlist instead.%0
//
#define NS_E_PDA_CANNOT_SYNC_INVALID_PLAYLIST _HRESULT_TYPEDEF_(0xC00D1235L)

//
// MessageId: NS_E_PDA_FAILED_TO_SYNCHRONIZE_FILE
//
// MessageText:
//
// Windows Media Player encountered a problem while synchronizing the file to the device. For additional assistance, click Web Help.%0
//
#define NS_E_PDA_FAILED_TO_SYNCHRONIZE_FILE _HRESULT_TYPEDEF_(0xC00D1236L)

//
// MessageId: NS_E_PDA_SYNC_FAILED
//
// MessageText:
//
// Windows Media Player encountered an error while synchronizing to the device.%0
//
#define NS_E_PDA_SYNC_FAILED             _HRESULT_TYPEDEF_(0xC00D1237L)

//
// MessageId: NS_E_PDA_DELETE_FAILED
//
// MessageText:
//
// Windows Media Player cannot delete a file from the device.%0
//
#define NS_E_PDA_DELETE_FAILED           _HRESULT_TYPEDEF_(0xC00D1238L)

//
// MessageId: NS_E_PDA_FAILED_TO_RETRIEVE_FILE
//
// MessageText:
//
// Windows Media Player cannot copy a file from the device to your library.%0
//
#define NS_E_PDA_FAILED_TO_RETRIEVE_FILE _HRESULT_TYPEDEF_(0xC00D1239L)

//
// MessageId: NS_E_PDA_DEVICE_NOT_RESPONDING
//
// MessageText:
//
// Windows Media Player cannot communicate with the device because the device is not responding. Try reconnecting the device, resetting the device, or contacting the device manufacturer for updated firmware.%0
//
#define NS_E_PDA_DEVICE_NOT_RESPONDING   _HRESULT_TYPEDEF_(0xC00D123AL)

//
// MessageId: NS_E_PDA_FAILED_TO_TRANSCODE_PHOTO
//
// MessageText:
//
// Windows Media Player cannot sync the picture to the device because a problem occurred while converting the file to another quality level or format. The original file might be damaged or corrupted.%0
//
#define NS_E_PDA_FAILED_TO_TRANSCODE_PHOTO _HRESULT_TYPEDEF_(0xC00D123BL)

//
// MessageId: NS_E_PDA_FAILED_TO_ENCRYPT_TRANSCODED_FILE
//
// MessageText:
//
// Windows Media Player cannot convert the file. The file might have been encrypted by the Encrypted File System (EFS). Try decrypting the file first and then synchronizing it. For information about how to decrypt a file, see Windows Help and Support.%0
//
#define NS_E_PDA_FAILED_TO_ENCRYPT_TRANSCODED_FILE _HRESULT_TYPEDEF_(0xC00D123CL)

//
// MessageId: NS_E_PDA_CANNOT_TRANSCODE_TO_AUDIO
//
// MessageText:
//
// Your device requires that this file be converted in order to play on the device. However, the device either does not support playing audio, or Windows Media Player cannot convert the file to an audio format that is supported by the device.%0
//
#define NS_E_PDA_CANNOT_TRANSCODE_TO_AUDIO _HRESULT_TYPEDEF_(0xC00D123DL)

//
// MessageId: NS_E_PDA_CANNOT_TRANSCODE_TO_VIDEO
//
// MessageText:
//
// Your device requires that this file be converted in order to play on the device. However, the device either does not support playing video, or Windows Media Player cannot convert the file to a video format that is supported by the device.%0
//
#define NS_E_PDA_CANNOT_TRANSCODE_TO_VIDEO _HRESULT_TYPEDEF_(0xC00D123EL)

//
// MessageId: NS_E_PDA_CANNOT_TRANSCODE_TO_IMAGE
//
// MessageText:
//
// Your device requires that this file be converted in order to play on the device. However, the device either does not support displaying pictures, or Windows Media Player cannot convert the file to a picture format that is supported by the device.%0
//
#define NS_E_PDA_CANNOT_TRANSCODE_TO_IMAGE _HRESULT_TYPEDEF_(0xC00D123FL)

//
// MessageId: NS_E_PDA_RETRIEVED_FILE_FILENAME_TOO_LONG
//
// MessageText:
//
// Windows Media Player cannot sync the file to your computer because the file name is too long. Try renaming the file on the device.%0
//
#define NS_E_PDA_RETRIEVED_FILE_FILENAME_TOO_LONG _HRESULT_TYPEDEF_(0xC00D1240L)

//
// MessageId: NS_E_PDA_CEWMDM_DRM_ERROR
//
// MessageText:
//
// Windows Media Player cannot sync the file because the device is not responding. This typically occurs when there is a problem with the device firmware. For additional assistance, click Web Help.%0
//
#define NS_E_PDA_CEWMDM_DRM_ERROR        _HRESULT_TYPEDEF_(0xC00D1241L)

//
// MessageId: NS_E_INCOMPLETE_PLAYLIST
//
// MessageText:
//
//  NS_E_INCOMPLETE_PLAYLIST
//
#define NS_E_INCOMPLETE_PLAYLIST         _HRESULT_TYPEDEF_(0xC00D1242L)

//
// MessageId: NS_E_PDA_SYNC_RUNNING
//
// MessageText:
//
// It is not possible to perform the requested action because sync is in progress. You can either stop sync or wait for it to complete, and then try again.%0
//
#define NS_E_PDA_SYNC_RUNNING            _HRESULT_TYPEDEF_(0xC00D1243L)

//
// MessageId: NS_E_PDA_SYNC_LOGIN_ERROR
//
// MessageText:
//
// Windows Media Player cannot sync the subscription content because you are not signed in to the online store that provided it. Sign in to the online store, and then try again.%0
//
#define NS_E_PDA_SYNC_LOGIN_ERROR        _HRESULT_TYPEDEF_(0xC00D1244L)

//
// MessageId: NS_E_PDA_TRANSCODE_CODEC_NOT_FOUND
//
// MessageText:
//
// Windows Media Player cannot convert the file to the format required by the device. One or more codecs required to convert the file could not be found.%0
//
#define NS_E_PDA_TRANSCODE_CODEC_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D1245L)

//
// MessageId: NS_E_CANNOT_SYNC_DRM_TO_NON_JANUS_DEVICE
//
// MessageText:
//
// It is not possible to sync subscription files to this device.%0
//
#define NS_E_CANNOT_SYNC_DRM_TO_NON_JANUS_DEVICE _HRESULT_TYPEDEF_(0xC00D1246L)

//
// MessageId: NS_E_CANNOT_SYNC_PREVIOUS_SYNC_RUNNING
//
// MessageText:
//
// Your device is operating slowly or is not responding. Until the device responds, it is not possible to sync again. To return the device to normal operation, try disconnecting it from the computer or resetting it.%0
//
#define NS_E_CANNOT_SYNC_PREVIOUS_SYNC_RUNNING _HRESULT_TYPEDEF_(0xC00D1247L)

//
//Background download plugin
//
//
// MessageId: NS_E_WMP_HWND_NOTFOUND
//
// MessageText:
//
// The Windows Media Player download manager cannot function properly because the Player main window cannot be found. Try restarting the Player.%0
//
#define NS_E_WMP_HWND_NOTFOUND           _HRESULT_TYPEDEF_(0xC00D125CL)

//
// MessageId: NS_E_BKGDOWNLOAD_WRONG_NO_FILES
//
// MessageText:
//
// Windows Media Player encountered a download that has the wrong number of files. This might occur if another program is trying to create jobs with the same signature as the Player.%0
//
#define NS_E_BKGDOWNLOAD_WRONG_NO_FILES  _HRESULT_TYPEDEF_(0xC00D125DL)

//
// MessageId: NS_E_BKGDOWNLOAD_COMPLETECANCELLEDJOB
//
// MessageText:
//
// Windows Media Player tried to complete a download that was already canceled. The file will not be available.%0
//
#define NS_E_BKGDOWNLOAD_COMPLETECANCELLEDJOB _HRESULT_TYPEDEF_(0xC00D125EL)

//
// MessageId: NS_E_BKGDOWNLOAD_CANCELCOMPLETEDJOB
//
// MessageText:
//
// Windows Media Player tried to cancel a download that was already completed. The file will not be removed.%0
//
#define NS_E_BKGDOWNLOAD_CANCELCOMPLETEDJOB _HRESULT_TYPEDEF_(0xC00D125FL)

//
// MessageId: NS_E_BKGDOWNLOAD_NOJOBPOINTER
//
// MessageText:
//
// Windows Media Player is trying to access a download that is not valid.%0
//
#define NS_E_BKGDOWNLOAD_NOJOBPOINTER    _HRESULT_TYPEDEF_(0xC00D1260L)

//
// MessageId: NS_E_BKGDOWNLOAD_INVALIDJOBSIGNATURE
//
// MessageText:
//
// This download was not created by Windows Media Player.%0
//
#define NS_E_BKGDOWNLOAD_INVALIDJOBSIGNATURE _HRESULT_TYPEDEF_(0xC00D1261L)

//
// MessageId: NS_E_BKGDOWNLOAD_FAILED_TO_CREATE_TEMPFILE
//
// MessageText:
//
// The Windows Media Player download manager cannot create a temporary file name. This might occur if the path is not valid or if the disk is full.%0
//
#define NS_E_BKGDOWNLOAD_FAILED_TO_CREATE_TEMPFILE _HRESULT_TYPEDEF_(0xC00D1262L)

//
// MessageId: NS_E_BKGDOWNLOAD_PLUGIN_FAILEDINITIALIZE
//
// MessageText:
//
// The Windows Media Player download manager plug-in cannot start. This might occur if the system is out of resources.%0
//
#define NS_E_BKGDOWNLOAD_PLUGIN_FAILEDINITIALIZE _HRESULT_TYPEDEF_(0xC00D1263L)

//
// MessageId: NS_E_BKGDOWNLOAD_PLUGIN_FAILEDTOMOVEFILE
//
// MessageText:
//
// The Windows Media Player download manager cannot move the file.%0
//
#define NS_E_BKGDOWNLOAD_PLUGIN_FAILEDTOMOVEFILE _HRESULT_TYPEDEF_(0xC00D1264L)

//
// MessageId: NS_E_BKGDOWNLOAD_CALLFUNCFAILED
//
// MessageText:
//
// The Windows Media Player download manager cannot perform a task because the system has no resources to allocate.%0
//
#define NS_E_BKGDOWNLOAD_CALLFUNCFAILED  _HRESULT_TYPEDEF_(0xC00D1265L)

//
// MessageId: NS_E_BKGDOWNLOAD_CALLFUNCTIMEOUT
//
// MessageText:
//
// The Windows Media Player download manager cannot perform a task because the task took too long to run.%0
//
#define NS_E_BKGDOWNLOAD_CALLFUNCTIMEOUT _HRESULT_TYPEDEF_(0xC00D1266L)

//
// MessageId: NS_E_BKGDOWNLOAD_CALLFUNCENDED
//
// MessageText:
//
// The Windows Media Player download manager cannot perform a task because the Player is terminating the service. The task will be recovered when the Player restarts.%0
//
#define NS_E_BKGDOWNLOAD_CALLFUNCENDED   _HRESULT_TYPEDEF_(0xC00D1267L)

//
// MessageId: NS_E_BKGDOWNLOAD_WMDUNPACKFAILED
//
// MessageText:
//
// The Windows Media Player download manager cannot expand a WMD file. The file will be deleted and the operation will not be completed successfully.%0
//
#define NS_E_BKGDOWNLOAD_WMDUNPACKFAILED _HRESULT_TYPEDEF_(0xC00D1268L)

//
// MessageId: NS_E_BKGDOWNLOAD_FAILEDINITIALIZE
//
// MessageText:
//
// The Windows Media Player download manager cannot start. This might occur if the system is out of resources.%0
//
#define NS_E_BKGDOWNLOAD_FAILEDINITIALIZE _HRESULT_TYPEDEF_(0xC00D1269L)

//
// MessageId: NS_E_INTERFACE_NOT_REGISTERED_IN_GIT
//
// MessageText:
//
// Windows Media Player cannot access a required functionality. This might occur if the wrong system files or Player DLLs are loaded.%0
//
#define NS_E_INTERFACE_NOT_REGISTERED_IN_GIT _HRESULT_TYPEDEF_(0xC00D126AL)

//
// MessageId: NS_E_BKGDOWNLOAD_INVALID_FILE_NAME
//
// MessageText:
//
// Windows Media Player cannot get the file name of the requested download. The requested download will be canceled.%0
//
#define NS_E_BKGDOWNLOAD_INVALID_FILE_NAME _HRESULT_TYPEDEF_(0xC00D126BL)

//
//Image Graph Errors 4750 -- 4800
//
//
// MessageId: NS_E_IMAGE_DOWNLOAD_FAILED
//
// MessageText:
//
// Windows Media Player encountered an error while downloading an image.%0
//
#define NS_E_IMAGE_DOWNLOAD_FAILED       _HRESULT_TYPEDEF_(0xC00D128EL)

//
// UDRM errors
//
//
// MessageId: NS_E_WMP_UDRM_NOUSERLIST
//
// MessageText:
//
// Windows Media Player cannot update your media usage rights because the Player cannot verify the list of activated users of this computer.%0
//
#define NS_E_WMP_UDRM_NOUSERLIST         _HRESULT_TYPEDEF_(0xC00D12C0L)

//
// MessageId: NS_E_WMP_DRM_NOT_ACQUIRING
//
// MessageText:
//
// Windows Media Player is trying to acquire media usage rights for a file that is no longer being used. Rights acquisition will stop.%0
//
#define NS_E_WMP_DRM_NOT_ACQUIRING       _HRESULT_TYPEDEF_(0xC00D12C1L)

//
// String is too large
//
//
// MessageId: NS_E_WMP_BSTR_TOO_LONG
//
// MessageText:
//
// The parameter is not valid.%0
//
#define NS_E_WMP_BSTR_TOO_LONG           _HRESULT_TYPEDEF_(0xC00D12F2L)

//
// Autoplay errors 4860 --- 4870
//
//
// MessageId: NS_E_WMP_AUTOPLAY_INVALID_STATE
//
// MessageText:
//
// The state is not valid for this request.%0
//
#define NS_E_WMP_AUTOPLAY_INVALID_STATE  _HRESULT_TYPEDEF_(0xC00D12FCL)

//
// MF mapped errors 4870 --- 4880
//
//
// MessageId: NS_E_WMP_COMPONENT_REVOKED
//
// MessageText:
//
// Windows Media Player cannot play this file until you complete the software component upgrade. After the component has been upgraded, try to play the file again.%0
//
#define NS_E_WMP_COMPONENT_REVOKED       _HRESULT_TYPEDEF_(0xC00D1306L)

//
// CURL Errors 4900 -- 4920
//
//
// MessageId: NS_E_CURL_NOTSAFE
//
// MessageText:
//
// The URL is not safe for the operation specified.%0
//
#define NS_E_CURL_NOTSAFE                _HRESULT_TYPEDEF_(0xC00D1324L)

//
// MessageId: NS_E_CURL_INVALIDCHAR
//
// MessageText:
//
// The URL contains one or more characters that are not valid.%0
//
#define NS_E_CURL_INVALIDCHAR            _HRESULT_TYPEDEF_(0xC00D1325L)

//
// MessageId: NS_E_CURL_INVALIDHOSTNAME
//
// MessageText:
//
// The URL contains a host name that is not valid.%0
//
#define NS_E_CURL_INVALIDHOSTNAME        _HRESULT_TYPEDEF_(0xC00D1326L)

//
// MessageId: NS_E_CURL_INVALIDPATH
//
// MessageText:
//
// The URL contains a path that is not valid.%0
//
#define NS_E_CURL_INVALIDPATH            _HRESULT_TYPEDEF_(0xC00D1327L)

//
// MessageId: NS_E_CURL_INVALIDSCHEME
//
// MessageText:
//
// The URL contains a scheme that is not valid.%0
//
#define NS_E_CURL_INVALIDSCHEME          _HRESULT_TYPEDEF_(0xC00D1328L)

//
// MessageId: NS_E_CURL_INVALIDURL
//
// MessageText:
//
// The URL is not valid.%0
//
#define NS_E_CURL_INVALIDURL             _HRESULT_TYPEDEF_(0xC00D1329L)

//
// MessageId: NS_E_CURL_CANTWALK
//
// MessageText:
//
// Windows Media Player cannot play the file. If you clicked a link on a Web page, the link might not be valid.%0
//
#define NS_E_CURL_CANTWALK               _HRESULT_TYPEDEF_(0xC00D132BL)

//
// MessageId: NS_E_CURL_INVALIDPORT
//
// MessageText:
//
// The URL port is not valid.%0
//
#define NS_E_CURL_INVALIDPORT            _HRESULT_TYPEDEF_(0xC00D132CL)

//
// MessageId: NS_E_CURLHELPER_NOTADIRECTORY
//
// MessageText:
//
// The URL is not a directory.%0
//
#define NS_E_CURLHELPER_NOTADIRECTORY    _HRESULT_TYPEDEF_(0xC00D132DL)

//
// MessageId: NS_E_CURLHELPER_NOTAFILE
//
// MessageText:
//
// The URL is not a file.%0
//
#define NS_E_CURLHELPER_NOTAFILE         _HRESULT_TYPEDEF_(0xC00D132EL)

//
// MessageId: NS_E_CURL_CANTDECODE
//
// MessageText:
//
// The URL contains characters that cannot be decoded. The URL might be truncated or incomplete.%0
//
#define NS_E_CURL_CANTDECODE             _HRESULT_TYPEDEF_(0xC00D132FL)

//
// MessageId: NS_E_CURLHELPER_NOTRELATIVE
//
// MessageText:
//
// The specified URL is not a relative URL.%0
//
#define NS_E_CURLHELPER_NOTRELATIVE      _HRESULT_TYPEDEF_(0xC00D1330L)

//
// MessageId: NS_E_CURL_INVALIDBUFFERSIZE
//
// MessageText:
//
// The buffer is smaller than the size specified.%0
//
#define NS_E_CURL_INVALIDBUFFERSIZE      _HRESULT_TYPEDEF_(0xC00D1331L)

//
// Subscription Service Errors 4950 -- 4969
//
//
// MessageId: NS_E_SUBSCRIPTIONSERVICE_PLAYBACK_DISALLOWED
//
// MessageText:
//
// The content provider has not granted you the right to play this file. Go to the content provider's online store to get play rights.%0
//
#define NS_E_SUBSCRIPTIONSERVICE_PLAYBACK_DISALLOWED _HRESULT_TYPEDEF_(0xC00D1356L)

//
// MessageId: NS_E_CANNOT_BUY_OR_DOWNLOAD_FROM_MULTIPLE_SERVICES
//
// MessageText:
//
// Windows Media Player cannot purchase or download content from multiple online stores.%0
//
#define NS_E_CANNOT_BUY_OR_DOWNLOAD_FROM_MULTIPLE_SERVICES _HRESULT_TYPEDEF_(0xC00D1357L)

//
// MessageId: NS_E_CANNOT_BUY_OR_DOWNLOAD_CONTENT
//
// MessageText:
//
// The file cannot be purchased or downloaded. The file might not be available from the online store.%0
//
#define NS_E_CANNOT_BUY_OR_DOWNLOAD_CONTENT _HRESULT_TYPEDEF_(0xC00D1358L)

//
// MessageId: NS_S_TRACK_BUY_REQUIRES_ALBUM_PURCHASE
//
// MessageText:
//
// The file is only available for purchase when you buy the entire album.%0
//
#define NS_S_TRACK_BUY_REQUIRES_ALBUM_PURCHASE _HRESULT_TYPEDEF_(0x000D1359L)

//
// MessageId: NS_E_NOT_CONTENT_PARTNER_TRACK
//
// MessageText:
//
// The provider of this file cannot be identified.%0
//
#define NS_E_NOT_CONTENT_PARTNER_TRACK   _HRESULT_TYPEDEF_(0xC00D135AL)

//
// MessageId: NS_E_TRACK_DOWNLOAD_REQUIRES_ALBUM_PURCHASE
//
// MessageText:
//
// The file is only available for download when you buy the entire album.%0
//
#define NS_E_TRACK_DOWNLOAD_REQUIRES_ALBUM_PURCHASE _HRESULT_TYPEDEF_(0xC00D135BL)

//
// MessageId: NS_E_TRACK_DOWNLOAD_REQUIRES_PURCHASE
//
// MessageText:
//
// You must buy the file before you can download it.%0
//
#define NS_E_TRACK_DOWNLOAD_REQUIRES_PURCHASE _HRESULT_TYPEDEF_(0xC00D135CL)

//
// MessageId: NS_E_TRACK_PURCHASE_MAXIMUM_EXCEEDED
//
// MessageText:
//
// You have exceeded the maximum number of files that can be purchased in a single transaction.%0
//
#define NS_E_TRACK_PURCHASE_MAXIMUM_EXCEEDED _HRESULT_TYPEDEF_(0xC00D135DL)

//
// MessageId: NS_S_NAVIGATION_COMPLETE_WITH_ERRORS
//
// MessageText:
//
// There were problems completing the requested navigation. There are identifiers missing in the catalog.%0
//
#define NS_S_NAVIGATION_COMPLETE_WITH_ERRORS _HRESULT_TYPEDEF_(0x000D135EL)

//
// MessageId: NS_E_SUBSCRIPTIONSERVICE_LOGIN_FAILED
//
// MessageText:
//
// Windows Media Player cannot sign in to the online store. Verify that you are using the correct user name and password. If the problem persists, the store may be temporarily unavailable.%0
//
#define NS_E_SUBSCRIPTIONSERVICE_LOGIN_FAILED _HRESULT_TYPEDEF_(0xC00D135FL)

//
// MessageId: NS_E_SUBSCRIPTIONSERVICE_DOWNLOAD_TIMEOUT
//
// MessageText:
//
// Windows Media Player cannot download this item because the server is not responding. The server might be temporarily unavailable or you may have lost your Internet connection.%0
//
#define NS_E_SUBSCRIPTIONSERVICE_DOWNLOAD_TIMEOUT _HRESULT_TYPEDEF_(0xC00D1360L)

//
// MessageId: NS_S_TRACK_ALREADY_DOWNLOADED
//
// MessageText:
//
//  NS_S_TRACK_ALREADY_DOWNLOADED
//
#define NS_S_TRACK_ALREADY_DOWNLOADED    _HRESULT_TYPEDEF_(0x000D1361L)

//
// MessageId: NS_E_CONTENT_PARTNER_STILL_INITIALIZING
//
// MessageText:
//
//  NS_E_CONTENT_PARTNER_STILL_INITIALIZING
//
#define NS_E_CONTENT_PARTNER_STILL_INITIALIZING _HRESULT_TYPEDEF_(0xC00D1362L)

//
// MessageId: NS_E_OPEN_CONTAINING_FOLDER_FAILED
//
// MessageText:
//
// The folder could not be opened.  The folder may have been moved or deleted.
//
#define NS_E_OPEN_CONTAINING_FOLDER_FAILED _HRESULT_TYPEDEF_(0xC00D1363L)

//
// Advanced Edit Dialog Errors 4970 -- 4989
//
//
// MessageId: NS_E_ADVANCEDEDIT_TOO_MANY_PICTURES
//
// MessageText:
//
// Windows Media Player could not add all of the images to the file because the images exceeded the 7 megabyte (MB) limit.%0
//
#define NS_E_ADVANCEDEDIT_TOO_MANY_PICTURES _HRESULT_TYPEDEF_(0xC00D136AL)



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Server Errors
//
// IdRange = 5000 - 5999
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_REDIRECT
//
// MessageText:
//
// The client redirected to another server.%0
//
#define NS_E_REDIRECT                    _HRESULT_TYPEDEF_(0xC00D1388L)

//
// MessageId: NS_E_STALE_PRESENTATION
//
// MessageText:
//
// The streaming media description is no longer current.%0
//
#define NS_E_STALE_PRESENTATION          _HRESULT_TYPEDEF_(0xC00D1389L)


 // Namespace Errors

//
// MessageId: NS_E_NAMESPACE_WRONG_PERSIST
//
// MessageText:
//
// It is not possible to create a persistent namespace node under a transient parent node.%0
//
#define NS_E_NAMESPACE_WRONG_PERSIST     _HRESULT_TYPEDEF_(0xC00D138AL)

//
// MessageId: NS_E_NAMESPACE_WRONG_TYPE
//
// MessageText:
//
// It is not possible to store a value in a namespace node that has a different value type.%0
//
#define NS_E_NAMESPACE_WRONG_TYPE        _HRESULT_TYPEDEF_(0xC00D138BL)

//
// MessageId: NS_E_NAMESPACE_NODE_CONFLICT
//
// MessageText:
//
// It is not possible to remove the root namespace node.%0
//
#define NS_E_NAMESPACE_NODE_CONFLICT     _HRESULT_TYPEDEF_(0xC00D138CL)

//
// MessageId: NS_E_NAMESPACE_NODE_NOT_FOUND
//
// MessageText:
//
// The specified namespace node could not be found.%0
//
#define NS_E_NAMESPACE_NODE_NOT_FOUND    _HRESULT_TYPEDEF_(0xC00D138DL)

//
// MessageId: NS_E_NAMESPACE_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer supplied to hold namespace node string is too small.%0
//
#define NS_E_NAMESPACE_BUFFER_TOO_SMALL  _HRESULT_TYPEDEF_(0xC00D138EL)

//
// MessageId: NS_E_NAMESPACE_TOO_MANY_CALLBACKS
//
// MessageText:
//
// The callback list on a namespace node is at the maximum size.%0
//
#define NS_E_NAMESPACE_TOO_MANY_CALLBACKS _HRESULT_TYPEDEF_(0xC00D138FL)

//
// MessageId: NS_E_NAMESPACE_DUPLICATE_CALLBACK
//
// MessageText:
//
// It is not possible to register an already-registered callback on a namespace node.%0
//
#define NS_E_NAMESPACE_DUPLICATE_CALLBACK _HRESULT_TYPEDEF_(0xC00D1390L)

//
// MessageId: NS_E_NAMESPACE_CALLBACK_NOT_FOUND
//
// MessageText:
//
// Cannot find the callback in the namespace when attempting to remove the callback.%0
//
#define NS_E_NAMESPACE_CALLBACK_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D1391L)

//
// MessageId: NS_E_NAMESPACE_NAME_TOO_LONG
//
// MessageText:
//
// The namespace node name exceeds the allowed maximum length.%0
//
#define NS_E_NAMESPACE_NAME_TOO_LONG     _HRESULT_TYPEDEF_(0xC00D1392L)

//
// MessageId: NS_E_NAMESPACE_DUPLICATE_NAME
//
// MessageText:
//
// Cannot create a namespace node that already exists.%0
//
#define NS_E_NAMESPACE_DUPLICATE_NAME    _HRESULT_TYPEDEF_(0xC00D1393L)

//
// MessageId: NS_E_NAMESPACE_EMPTY_NAME
//
// MessageText:
//
// The namespace node name cannot be a null string.%0
//
#define NS_E_NAMESPACE_EMPTY_NAME        _HRESULT_TYPEDEF_(0xC00D1394L)

//
// MessageId: NS_E_NAMESPACE_INDEX_TOO_LARGE
//
// MessageText:
//
// Finding a child namespace node by index failed because the index exceeded the number of children.%0
//
#define NS_E_NAMESPACE_INDEX_TOO_LARGE   _HRESULT_TYPEDEF_(0xC00D1395L)

//
// MessageId: NS_E_NAMESPACE_BAD_NAME
//
// MessageText:
//
// The namespace node name is invalid.%0
//
#define NS_E_NAMESPACE_BAD_NAME          _HRESULT_TYPEDEF_(0xC00D1396L)

//
// MessageId: NS_E_NAMESPACE_WRONG_SECURITY
//
// MessageText:
//
// It is not possible to store a value in a namespace node that has a different security type.%0
//
#define NS_E_NAMESPACE_WRONG_SECURITY    _HRESULT_TYPEDEF_(0xC00D1397L)


 // Cache Errors 5100-5199

//
// MessageId: NS_E_CACHE_ARCHIVE_CONFLICT
//
// MessageText:
//
// The archive request conflicts with other requests in progress.%0
//
#define NS_E_CACHE_ARCHIVE_CONFLICT      _HRESULT_TYPEDEF_(0xC00D13ECL)

//
// MessageId: NS_E_CACHE_ORIGIN_SERVER_NOT_FOUND
//
// MessageText:
//
// The specified origin server cannot be found.%0
//
#define NS_E_CACHE_ORIGIN_SERVER_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D13EDL)

//
// MessageId: NS_E_CACHE_ORIGIN_SERVER_TIMEOUT
//
// MessageText:
//
// The specified origin server is not responding.%0
//
#define NS_E_CACHE_ORIGIN_SERVER_TIMEOUT _HRESULT_TYPEDEF_(0xC00D13EEL)

//
// MessageId: NS_E_CACHE_NOT_BROADCAST
//
// MessageText:
//
// The internal code for HTTP status code 412 Precondition Failed due to not broadcast type.%0
//
#define NS_E_CACHE_NOT_BROADCAST         _HRESULT_TYPEDEF_(0xC00D13EFL)

//
// MessageId: NS_E_CACHE_CANNOT_BE_CACHED
//
// MessageText:
//
// The internal code for HTTP status code 403 Forbidden due to not cacheable.%0
//
#define NS_E_CACHE_CANNOT_BE_CACHED      _HRESULT_TYPEDEF_(0xC00D13F0L)

//
// MessageId: NS_E_CACHE_NOT_MODIFIED
//
// MessageText:
//
// The internal code for HTTP status code 304 Not Modified.%0
//
#define NS_E_CACHE_NOT_MODIFIED          _HRESULT_TYPEDEF_(0xC00D13F1L)


// Object Model Errors 5200-5299

//
// MessageId: NS_E_CANNOT_REMOVE_PUBLISHING_POINT
//
// MessageText:
//
// It is not possible to remove a cache or proxy publishing point.%0
//
#define NS_E_CANNOT_REMOVE_PUBLISHING_POINT _HRESULT_TYPEDEF_(0xC00D1450L)

//
// MessageId: NS_E_CANNOT_REMOVE_PLUGIN
//
// MessageText:
//
// It is not possible to remove the last instance of a type of plug-in.%0
//
#define NS_E_CANNOT_REMOVE_PLUGIN        _HRESULT_TYPEDEF_(0xC00D1451L)

//
// MessageId: NS_E_WRONG_PUBLISHING_POINT_TYPE
//
// MessageText:
//
// Cache and proxy publishing points do not support this property or method.%0
//
#define NS_E_WRONG_PUBLISHING_POINT_TYPE _HRESULT_TYPEDEF_(0xC00D1452L)

//
// MessageId: NS_E_UNSUPPORTED_LOAD_TYPE
//
// MessageText:
//
// The plug-in does not support the specified load type.%0
//
#define NS_E_UNSUPPORTED_LOAD_TYPE       _HRESULT_TYPEDEF_(0xC00D1453L)

//
// MessageId: NS_E_INVALID_PLUGIN_LOAD_TYPE_CONFIGURATION
//
// MessageText:
//
// The plug-in does not support any load types. The plug-in must support at least one load type.%0
//
#define NS_E_INVALID_PLUGIN_LOAD_TYPE_CONFIGURATION _HRESULT_TYPEDEF_(0xC00D1454L)

//
// MessageId: NS_E_INVALID_PUBLISHING_POINT_NAME
//
// MessageText:
//
// The publishing point name is invalid.%0
//
#define NS_E_INVALID_PUBLISHING_POINT_NAME _HRESULT_TYPEDEF_(0xC00D1455L)

//
// MessageId: NS_E_TOO_MANY_MULTICAST_SINKS
//
// MessageText:
//
// Only one multicast data writer plug-in can be enabled for a publishing point.%0
//
#define NS_E_TOO_MANY_MULTICAST_SINKS    _HRESULT_TYPEDEF_(0xC00D1456L)

//
// MessageId: NS_E_PUBLISHING_POINT_INVALID_REQUEST_WHILE_STARTED
//
// MessageText:
//
// The requested operation cannot be completed while the publishing point is started.%0
//
#define NS_E_PUBLISHING_POINT_INVALID_REQUEST_WHILE_STARTED _HRESULT_TYPEDEF_(0xC00D1457L)

//
// MessageId: NS_E_MULTICAST_PLUGIN_NOT_ENABLED
//
// MessageText:
//
// A multicast data writer plug-in must be enabled in order for this operation to be completed.%0
//
#define NS_E_MULTICAST_PLUGIN_NOT_ENABLED _HRESULT_TYPEDEF_(0xC00D1458L)

//
// MessageId: NS_E_INVALID_OPERATING_SYSTEM_VERSION
//
// MessageText:
//
// This feature requires Windows Server 2003, Enterprise Edition.%0
//
#define NS_E_INVALID_OPERATING_SYSTEM_VERSION _HRESULT_TYPEDEF_(0xC00D1459L)

//
// MessageId: NS_E_PUBLISHING_POINT_REMOVED
//
// MessageText:
//
// The requested operation cannot be completed because the specified publishing point has been removed.%0
//
#define NS_E_PUBLISHING_POINT_REMOVED    _HRESULT_TYPEDEF_(0xC00D145AL)

//
// MessageId: NS_E_INVALID_PUSH_PUBLISHING_POINT_START_REQUEST
//
// MessageText:
//
// Push publishing points are started when the encoder starts pushing the stream. This publishing point cannot be started by the server administrator.%0
//
#define NS_E_INVALID_PUSH_PUBLISHING_POINT_START_REQUEST _HRESULT_TYPEDEF_(0xC00D145BL)

//
// MessageId: NS_E_UNSUPPORTED_LANGUAGE
//
// MessageText:
//
// The specified language is not supported.%0
//
#define NS_E_UNSUPPORTED_LANGUAGE        _HRESULT_TYPEDEF_(0xC00D145CL)

//
// MessageId: NS_E_WRONG_OS_VERSION
//
// MessageText:
//
// Windows Media Services will only run on Windows Server 2003, Standard Edition and Windows Server 2003, Enterprise Edition.%0
//
#define NS_E_WRONG_OS_VERSION            _HRESULT_TYPEDEF_(0xC00D145DL)

//
// MessageId: NS_E_PUBLISHING_POINT_STOPPED
//
// MessageText:
//
// The operation cannot be completed because the publishing point has been stopped.%0
//
#define NS_E_PUBLISHING_POINT_STOPPED    _HRESULT_TYPEDEF_(0xC00D145EL)


// Playlist Errors 5300-5399

//
// MessageId: NS_E_PLAYLIST_ENTRY_ALREADY_PLAYING
//
// MessageText:
//
// The playlist entry is already playing.%0
//
#define NS_E_PLAYLIST_ENTRY_ALREADY_PLAYING _HRESULT_TYPEDEF_(0xC00D14B4L)

//
// MessageId: NS_E_EMPTY_PLAYLIST
//
// MessageText:
//
// The playlist or directory you are requesting does not contain content.%0
//
#define NS_E_EMPTY_PLAYLIST              _HRESULT_TYPEDEF_(0xC00D14B5L)

//
// MessageId: NS_E_PLAYLIST_PARSE_FAILURE
//
// MessageText:
//
// The server was unable to parse the requested playlist file.%0
//
#define NS_E_PLAYLIST_PARSE_FAILURE      _HRESULT_TYPEDEF_(0xC00D14B6L)

//
// MessageId: NS_E_PLAYLIST_UNSUPPORTED_ENTRY
//
// MessageText:
//
// The requested operation is not supported for this type of playlist entry.%0
//
#define NS_E_PLAYLIST_UNSUPPORTED_ENTRY  _HRESULT_TYPEDEF_(0xC00D14B7L)

//
// MessageId: NS_E_PLAYLIST_ENTRY_NOT_IN_PLAYLIST
//
// MessageText:
//
// Cannot jump to a playlist entry that is not inserted in the playlist.%0
//
#define NS_E_PLAYLIST_ENTRY_NOT_IN_PLAYLIST _HRESULT_TYPEDEF_(0xC00D14B8L)

//
// MessageId: NS_E_PLAYLIST_ENTRY_SEEK
//
// MessageText:
//
// Cannot seek to the desired playlist entry.%0
//
#define NS_E_PLAYLIST_ENTRY_SEEK         _HRESULT_TYPEDEF_(0xC00D14B9L)

//
// MessageId: NS_E_PLAYLIST_RECURSIVE_PLAYLISTS
//
// MessageText:
//
// Cannot play recursive playlist.%0
//
#define NS_E_PLAYLIST_RECURSIVE_PLAYLISTS _HRESULT_TYPEDEF_(0xC00D14BAL)

//
// MessageId: NS_E_PLAYLIST_TOO_MANY_NESTED_PLAYLISTS
//
// MessageText:
//
// The number of nested playlists exceeded the limit the server can handle.%0
//
#define NS_E_PLAYLIST_TOO_MANY_NESTED_PLAYLISTS _HRESULT_TYPEDEF_(0xC00D14BBL)

//
// MessageId: NS_E_PLAYLIST_SHUTDOWN
//
// MessageText:
//
// Cannot execute the requested operation because the playlist has been shut down by the Media Server.%0
//
#define NS_E_PLAYLIST_SHUTDOWN           _HRESULT_TYPEDEF_(0xC00D14BCL)

//
// MessageId: NS_E_PLAYLIST_END_RECEDING
//
// MessageText:
//
// The playlist has ended while receding.%0
//
#define NS_E_PLAYLIST_END_RECEDING       _HRESULT_TYPEDEF_(0xC00D14BDL)

//
// MessageId: NS_I_PLAYLIST_CHANGE_RECEDING
//
// MessageText:
//
// The playlist change occurred while receding.%0
//
#define NS_I_PLAYLIST_CHANGE_RECEDING    _HRESULT_TYPEDEF_(0x400D14BEL)


// Datapath Errors -- 5400 - 5499

//
// MessageId: NS_E_DATAPATH_NO_SINK
//
// MessageText:
//
// The data path does not have an associated data writer plug-in.%0
//
#define NS_E_DATAPATH_NO_SINK            _HRESULT_TYPEDEF_(0xC00D1518L)

//
// MessageId: NS_S_PUBLISHING_POINT_STARTED_WITH_FAILED_SINKS
//
// MessageText:
//
// The publishing point successfully started, but one or more of the requested data writer plug-ins failed.%0
//
#define NS_S_PUBLISHING_POINT_STARTED_WITH_FAILED_SINKS _HRESULT_TYPEDEF_(0x000D1519L)

//
// MessageId: NS_E_INVALID_PUSH_TEMPLATE
//
// MessageText:
//
// The specified push template is invalid.%0
//
#define NS_E_INVALID_PUSH_TEMPLATE       _HRESULT_TYPEDEF_(0xC00D151AL)

//
// MessageId: NS_E_INVALID_PUSH_PUBLISHING_POINT
//
// MessageText:
//
// The specified push publishing point is invalid.%0
//
#define NS_E_INVALID_PUSH_PUBLISHING_POINT _HRESULT_TYPEDEF_(0xC00D151BL)

//
// MessageId: NS_E_CRITICAL_ERROR
//
// MessageText:
//
// The requested operation cannot be performed because the server or publishing point is in a critical error state.%0
//
#define NS_E_CRITICAL_ERROR              _HRESULT_TYPEDEF_(0xC00D151CL)

//
// MessageId: NS_E_NO_NEW_CONNECTIONS
//
// MessageText:
//
// The content can not be played because the server is not currently accepting connections. Try connecting at a later time.%0
//
#define NS_E_NO_NEW_CONNECTIONS          _HRESULT_TYPEDEF_(0xC00D151DL)

//
// MessageId: NS_E_WSX_INVALID_VERSION
//
// MessageText:
//
// The version of this playlist is not supported by the server.%0
//
#define NS_E_WSX_INVALID_VERSION         _HRESULT_TYPEDEF_(0xC00D151EL)

//
// MessageId: NS_E_HEADER_MISMATCH
//
// MessageText:
//
// The command does not apply to the current media header user by a server component.%0
//
#define NS_E_HEADER_MISMATCH             _HRESULT_TYPEDEF_(0xC00D151FL)

//
// MessageId: NS_E_PUSH_DUPLICATE_PUBLISHING_POINT_NAME
//
// MessageText:
//
// The specified publishing point name is already in use.%0
//
#define NS_E_PUSH_DUPLICATE_PUBLISHING_POINT_NAME _HRESULT_TYPEDEF_(0xC00D1520L)


// Plugin Errors -- 5500 - 5599

//
// MessageId: NS_E_NO_SCRIPT_ENGINE
//
// MessageText:
//
// There is no script engine available for this file.%0
//
#define NS_E_NO_SCRIPT_ENGINE            _HRESULT_TYPEDEF_(0xC00D157CL)

//
// MessageId: NS_E_PLUGIN_ERROR_REPORTED
//
// MessageText:
//
// The plug-in has reported an error. See the Troubleshooting tab or the NT Application Event Log for details.%0
//
#define NS_E_PLUGIN_ERROR_REPORTED       _HRESULT_TYPEDEF_(0xC00D157DL)

//
// MessageId: NS_E_SOURCE_PLUGIN_NOT_FOUND
//
// MessageText:
//
// No enabled data source plug-in is available to access the requested content.%0
//
#define NS_E_SOURCE_PLUGIN_NOT_FOUND     _HRESULT_TYPEDEF_(0xC00D157EL)

//
// MessageId: NS_E_PLAYLIST_PLUGIN_NOT_FOUND
//
// MessageText:
//
// No enabled playlist parser plug-in is available to access the requested content.%0
//
#define NS_E_PLAYLIST_PLUGIN_NOT_FOUND   _HRESULT_TYPEDEF_(0xC00D157FL)

//
// MessageId: NS_E_DATA_SOURCE_ENUMERATION_NOT_SUPPORTED
//
// MessageText:
//
// The data source plug-in does not support enumeration.%0
//
#define NS_E_DATA_SOURCE_ENUMERATION_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D1580L)

//
// MessageId: NS_E_MEDIA_PARSER_INVALID_FORMAT
//
// MessageText:
//
// The server cannot stream the selected file because it is either damaged or corrupt. Select a different file.%0
//
#define NS_E_MEDIA_PARSER_INVALID_FORMAT _HRESULT_TYPEDEF_(0xC00D1581L)

//
// MessageId: NS_E_SCRIPT_DEBUGGER_NOT_INSTALLED
//
// MessageText:
//
// The plug-in cannot be enabled because a compatible script debugger is not installed on this system.  Install a script debugger, or disable the script debugger option on the general tab of the plug-in's properties page and try again.%0
//
#define NS_E_SCRIPT_DEBUGGER_NOT_INSTALLED _HRESULT_TYPEDEF_(0xC00D1582L)

//
// MessageId: NS_E_FEATURE_REQUIRES_ENTERPRISE_SERVER
//
// MessageText:
//
// The plug-in cannot be loaded because it requires Windows Server 2003, Enterprise Edition.%0
//
#define NS_E_FEATURE_REQUIRES_ENTERPRISE_SERVER _HRESULT_TYPEDEF_(0xC00D1583L)

//
// MessageId: NS_E_WIZARD_RUNNING
//
// MessageText:
//
// Another wizard is currently running. Please close the other wizard or wait until it finishes before attempting to run this wizard again.%0
//
#define NS_E_WIZARD_RUNNING              _HRESULT_TYPEDEF_(0xC00D1584L)

//
// MessageId: NS_E_INVALID_LOG_URL
//
// MessageText:
//
// Invalid log URL. Multicast logging URL must look like "http://servername/isapibackend.dll" .%0
//
#define NS_E_INVALID_LOG_URL             _HRESULT_TYPEDEF_(0xC00D1585L)

//
// MessageId: NS_E_INVALID_MTU_RANGE
//
// MessageText:
//
// Invalid MTU specified. The valid range for maximum packet size is between 36  and 65507 bytes .%0
//
#define NS_E_INVALID_MTU_RANGE           _HRESULT_TYPEDEF_(0xC00D1586L)

//
// MessageId: NS_E_INVALID_PLAY_STATISTICS
//
// MessageText:
//
// Invalid play statistics for logging .%0
//
#define NS_E_INVALID_PLAY_STATISTICS     _HRESULT_TYPEDEF_(0xC00D1587L)

//
// MessageId: NS_E_LOG_NEED_TO_BE_SKIPPED
//
// MessageText:
//
// The log needs to be skipped .%0
//
#define NS_E_LOG_NEED_TO_BE_SKIPPED      _HRESULT_TYPEDEF_(0xC00D1588L)

//
// MessageId: NS_E_HTTP_TEXT_DATACONTAINER_SIZE_LIMIT_EXCEEDED
//
// MessageText:
//
// The size of the data exceeded the limit the WMS HTTP Download Data Source plugin can handle.%0
//
#define NS_E_HTTP_TEXT_DATACONTAINER_SIZE_LIMIT_EXCEEDED _HRESULT_TYPEDEF_(0xC00D1589L)

//
// MessageId: NS_E_PORT_IN_USE
//
// MessageText:
//
// One usage of each socket address (protocol/network address/port) is permitted. Verify that other services or applications are not attempting to use the same port and then try to enable the plug-in again.%0
//
#define NS_E_PORT_IN_USE                 _HRESULT_TYPEDEF_(0xC00D158AL)

//
// MessageId: NS_E_PORT_IN_USE_HTTP
//
// MessageText:
//
// One usage of each socket address (protocol/network address/port) is permitted. Verify that other services (such as IIS) or applications are not attempting to use the same port and then try to enable the plug-in again.%0
//
#define NS_E_PORT_IN_USE_HTTP            _HRESULT_TYPEDEF_(0xC00D158BL)

//
// MessageId: NS_E_HTTP_TEXT_DATACONTAINER_INVALID_SERVER_RESPONSE
//
// MessageText:
//
// The WMS HTTP Download Data Source plugin was unable to receive the remote server's response.%0
//
#define NS_E_HTTP_TEXT_DATACONTAINER_INVALID_SERVER_RESPONSE _HRESULT_TYPEDEF_(0xC00D158CL)

//
// MessageId: NS_E_ARCHIVE_REACH_QUOTA
//
// MessageText:
//
// The archive plug-in has reached its quota.%0
//
#define NS_E_ARCHIVE_REACH_QUOTA         _HRESULT_TYPEDEF_(0xC00D158DL)

//
// MessageId: NS_E_ARCHIVE_ABORT_DUE_TO_BCAST
//
// MessageText:
//
// The archive plug-in aborted because the source was from broadcast.%0
//
#define NS_E_ARCHIVE_ABORT_DUE_TO_BCAST  _HRESULT_TYPEDEF_(0xC00D158EL)

//
// MessageId: NS_E_ARCHIVE_GAP_DETECTED
//
// MessageText:
//
// The archive plug-in detected an interrupt in the source.%0
//
#define NS_E_ARCHIVE_GAP_DETECTED        _HRESULT_TYPEDEF_(0xC00D158FL)

//
// MessageId: NS_E_AUTHORIZATION_FILE_NOT_FOUND
//
// MessageText:
//
// The system cannot find the file specified.%0
//
#define NS_E_AUTHORIZATION_FILE_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D1590L)



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Tools Errors
//
// IdRange = 7000 - 7999
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: NS_E_BAD_MARKIN
//
// MessageText:
//
// The mark-in time should be greater than 0 and less than the mark-out time.%0
//
#define NS_E_BAD_MARKIN                  _HRESULT_TYPEDEF_(0xC00D1B58L)

//
// MessageId: NS_E_BAD_MARKOUT
//
// MessageText:
//
// The mark-out time should be greater than the mark-in time and less than the file duration.%0
//
#define NS_E_BAD_MARKOUT                 _HRESULT_TYPEDEF_(0xC00D1B59L)

//
// MessageId: NS_E_NOMATCHING_MEDIASOURCE
//
// MessageText:
//
// No matching media type is found in the source %1.%0
//
#define NS_E_NOMATCHING_MEDIASOURCE      _HRESULT_TYPEDEF_(0xC00D1B5AL)

//
// MessageId: NS_E_UNSUPPORTED_SOURCETYPE
//
// MessageText:
//
// The specified source type is not supported.%0
//
#define NS_E_UNSUPPORTED_SOURCETYPE      _HRESULT_TYPEDEF_(0xC00D1B5BL)

//
// MessageId: NS_E_TOO_MANY_AUDIO
//
// MessageText:
//
// It is not possible to specify more than one audio input.%0
//
#define NS_E_TOO_MANY_AUDIO              _HRESULT_TYPEDEF_(0xC00D1B5CL)

//
// MessageId: NS_E_TOO_MANY_VIDEO
//
// MessageText:
//
// It is not possible to specify more than two video inputs.%0
//
#define NS_E_TOO_MANY_VIDEO              _HRESULT_TYPEDEF_(0xC00D1B5DL)

//
// MessageId: NS_E_NOMATCHING_ELEMENT
//
// MessageText:
//
// No matching element is found in the list.%0
//
#define NS_E_NOMATCHING_ELEMENT          _HRESULT_TYPEDEF_(0xC00D1B5EL)

//
// MessageId: NS_E_MISMATCHED_MEDIACONTENT
//
// MessageText:
//
// The profile's media types must match the media types defined for the session.%0
//
#define NS_E_MISMATCHED_MEDIACONTENT     _HRESULT_TYPEDEF_(0xC00D1B5FL)

//
// MessageId: NS_E_CANNOT_DELETE_ACTIVE_SOURCEGROUP
//
// MessageText:
//
// It is not possible to remove an active source while encoding.%0
//
#define NS_E_CANNOT_DELETE_ACTIVE_SOURCEGROUP _HRESULT_TYPEDEF_(0xC00D1B60L)

//
// MessageId: NS_E_AUDIODEVICE_BUSY
//
// MessageText:
//
// It is not possible to open the specified audio capture device because it is currently in use.%0
//
#define NS_E_AUDIODEVICE_BUSY            _HRESULT_TYPEDEF_(0xC00D1B61L)

//
// MessageId: NS_E_AUDIODEVICE_UNEXPECTED
//
// MessageText:
//
// It is not possible to open the specified audio capture device because an unexpected error has occurred.%0
//
#define NS_E_AUDIODEVICE_UNEXPECTED      _HRESULT_TYPEDEF_(0xC00D1B62L)

//
// MessageId: NS_E_AUDIODEVICE_BADFORMAT
//
// MessageText:
//
// The audio capture device does not support the specified audio format.%0
//
#define NS_E_AUDIODEVICE_BADFORMAT       _HRESULT_TYPEDEF_(0xC00D1B63L)

//
// MessageId: NS_E_VIDEODEVICE_BUSY
//
// MessageText:
//
// It is not possible to open the specified video capture device because it is currently in use.%0
//
#define NS_E_VIDEODEVICE_BUSY            _HRESULT_TYPEDEF_(0xC00D1B64L)

//
// MessageId: NS_E_VIDEODEVICE_UNEXPECTED
//
// MessageText:
//
// It is not possible to open the specified video capture device because an unexpected error has occurred.%0
//
#define NS_E_VIDEODEVICE_UNEXPECTED      _HRESULT_TYPEDEF_(0xC00D1B65L)

//
// MessageId: NS_E_INVALIDCALL_WHILE_ENCODER_RUNNING
//
// MessageText:
//
// This operation is not allowed while encoding.%0
//
#define NS_E_INVALIDCALL_WHILE_ENCODER_RUNNING _HRESULT_TYPEDEF_(0xC00D1B66L)

//
// MessageId: NS_E_NO_PROFILE_IN_SOURCEGROUP
//
// MessageText:
//
// No profile is set for the source.%0
//
#define NS_E_NO_PROFILE_IN_SOURCEGROUP   _HRESULT_TYPEDEF_(0xC00D1B67L)

//
// MessageId: NS_E_VIDEODRIVER_UNSTABLE
//
// MessageText:
//
// The video capture driver returned an unrecoverable error.  It is now in an unstable state.%0
//
#define NS_E_VIDEODRIVER_UNSTABLE        _HRESULT_TYPEDEF_(0xC00D1B68L)

//
// MessageId: NS_E_VIDCAPSTARTFAILED
//
// MessageText:
//
// It was not possible to start the video device.%0
//
#define NS_E_VIDCAPSTARTFAILED           _HRESULT_TYPEDEF_(0xC00D1B69L)

//
// MessageId: NS_E_VIDSOURCECOMPRESSION
//
// MessageText:
//
// The video source does not support the requested output format or color depth.%0
//
#define NS_E_VIDSOURCECOMPRESSION        _HRESULT_TYPEDEF_(0xC00D1B6AL)

//
// MessageId: NS_E_VIDSOURCESIZE
//
// MessageText:
//
// The video source does not support the requested capture size.%0
//
#define NS_E_VIDSOURCESIZE               _HRESULT_TYPEDEF_(0xC00D1B6BL)

//
// MessageId: NS_E_ICMQUERYFORMAT
//
// MessageText:
//
// It was not possible to obtain output information from the video compressor.%0
//
#define NS_E_ICMQUERYFORMAT              _HRESULT_TYPEDEF_(0xC00D1B6CL)

//
// MessageId: NS_E_VIDCAPCREATEWINDOW
//
// MessageText:
//
// It was not possible to create a video capture window.%0
//
#define NS_E_VIDCAPCREATEWINDOW          _HRESULT_TYPEDEF_(0xC00D1B6DL)

//
// MessageId: NS_E_VIDCAPDRVINUSE
//
// MessageText:
//
// There is already a stream active on this video device.%0
//
#define NS_E_VIDCAPDRVINUSE              _HRESULT_TYPEDEF_(0xC00D1B6EL)

//
// MessageId: NS_E_NO_MEDIAFORMAT_IN_SOURCE
//
// MessageText:
//
// No media format is set in source.%0
//
#define NS_E_NO_MEDIAFORMAT_IN_SOURCE    _HRESULT_TYPEDEF_(0xC00D1B6FL)

//
// MessageId: NS_E_NO_VALID_OUTPUT_STREAM
//
// MessageText:
//
// Cannot find a valid output stream from the source.%0
//
#define NS_E_NO_VALID_OUTPUT_STREAM      _HRESULT_TYPEDEF_(0xC00D1B70L)

//
// MessageId: NS_E_NO_VALID_SOURCE_PLUGIN
//
// MessageText:
//
// It was not possible to find a valid source plug-in for the specified source.%0
//
#define NS_E_NO_VALID_SOURCE_PLUGIN      _HRESULT_TYPEDEF_(0xC00D1B71L)

//
// MessageId: NS_E_NO_ACTIVE_SOURCEGROUP
//
// MessageText:
//
// No source is currently active.%0
//
#define NS_E_NO_ACTIVE_SOURCEGROUP       _HRESULT_TYPEDEF_(0xC00D1B72L)

//
// MessageId: NS_E_NO_SCRIPT_STREAM
//
// MessageText:
//
// No script stream is set in the current source.%0
//
#define NS_E_NO_SCRIPT_STREAM            _HRESULT_TYPEDEF_(0xC00D1B73L)

//
// MessageId: NS_E_INVALIDCALL_WHILE_ARCHIVAL_RUNNING
//
// MessageText:
//
// This operation is not allowed while archiving.%0
//
#define NS_E_INVALIDCALL_WHILE_ARCHIVAL_RUNNING _HRESULT_TYPEDEF_(0xC00D1B74L)

//
// MessageId: NS_E_INVALIDPACKETSIZE
//
// MessageText:
//
// The setting for the maximum packet size is not valid.%0
//
#define NS_E_INVALIDPACKETSIZE           _HRESULT_TYPEDEF_(0xC00D1B75L)

//
// MessageId: NS_E_PLUGIN_CLSID_INVALID
//
// MessageText:
//
// The plug-in CLSID specified is not valid.%0
//
#define NS_E_PLUGIN_CLSID_INVALID        _HRESULT_TYPEDEF_(0xC00D1B76L)

//
// MessageId: NS_E_UNSUPPORTED_ARCHIVETYPE
//
// MessageText:
//
// This archive type is not supported.%0
//
#define NS_E_UNSUPPORTED_ARCHIVETYPE     _HRESULT_TYPEDEF_(0xC00D1B77L)

//
// MessageId: NS_E_UNSUPPORTED_ARCHIVEOPERATION
//
// MessageText:
//
// This archive operation is not supported.%0
//
#define NS_E_UNSUPPORTED_ARCHIVEOPERATION _HRESULT_TYPEDEF_(0xC00D1B78L)

//
// MessageId: NS_E_ARCHIVE_FILENAME_NOTSET
//
// MessageText:
//
// The local archive file name was not set.%0
//
#define NS_E_ARCHIVE_FILENAME_NOTSET     _HRESULT_TYPEDEF_(0xC00D1B79L)

//
// MessageId: NS_E_SOURCEGROUP_NOTPREPARED
//
// MessageText:
//
// The source is not yet prepared.%0
//
#define NS_E_SOURCEGROUP_NOTPREPARED     _HRESULT_TYPEDEF_(0xC00D1B7AL)

//
// MessageId: NS_E_PROFILE_MISMATCH
//
// MessageText:
//
// Profiles on the sources do not match.%0
//
#define NS_E_PROFILE_MISMATCH            _HRESULT_TYPEDEF_(0xC00D1B7BL)

//
// MessageId: NS_E_INCORRECTCLIPSETTINGS
//
// MessageText:
//
// The specified crop values are not valid.%0
//
#define NS_E_INCORRECTCLIPSETTINGS       _HRESULT_TYPEDEF_(0xC00D1B7CL)

//
// MessageId: NS_E_NOSTATSAVAILABLE
//
// MessageText:
//
// No statistics are available at this time.%0
//
#define NS_E_NOSTATSAVAILABLE            _HRESULT_TYPEDEF_(0xC00D1B7DL)

//
// MessageId: NS_E_NOTARCHIVING
//
// MessageText:
//
// The encoder is not archiving.%0
//
#define NS_E_NOTARCHIVING                _HRESULT_TYPEDEF_(0xC00D1B7EL)

//
// MessageId: NS_E_INVALIDCALL_WHILE_ENCODER_STOPPED
//
// MessageText:
//
// This operation is only allowed during encoding.%0
//
#define NS_E_INVALIDCALL_WHILE_ENCODER_STOPPED _HRESULT_TYPEDEF_(0xC00D1B7FL)

//
// MessageId: NS_E_NOSOURCEGROUPS
//
// MessageText:
//
// This SourceGroupCollection doesn't contain any SourceGroups.%0
//
#define NS_E_NOSOURCEGROUPS              _HRESULT_TYPEDEF_(0xC00D1B80L)

//
// MessageId: NS_E_INVALIDINPUTFPS
//
// MessageText:
//
// This source does not have a frame rate of 30 fps. Therefore, it is not possible to apply the inverse telecine filter to the source.%0
//
#define NS_E_INVALIDINPUTFPS             _HRESULT_TYPEDEF_(0xC00D1B81L)

//
// MessageId: NS_E_NO_DATAVIEW_SUPPORT
//
// MessageText:
//
// It is not possible to display your source or output video in the Video panel.%0
//
#define NS_E_NO_DATAVIEW_SUPPORT         _HRESULT_TYPEDEF_(0xC00D1B82L)

//
// MessageId: NS_E_CODEC_UNAVAILABLE
//
// MessageText:
//
// One or more codecs required to open this content could not be found.%0
//
#define NS_E_CODEC_UNAVAILABLE           _HRESULT_TYPEDEF_(0xC00D1B83L)

//
// MessageId: NS_E_ARCHIVE_SAME_AS_INPUT
//
// MessageText:
//
// The archive file has the same name as an input file. Change one of the names before continuing.%0
//
#define NS_E_ARCHIVE_SAME_AS_INPUT       _HRESULT_TYPEDEF_(0xC00D1B84L)

//
// MessageId: NS_E_SOURCE_NOTSPECIFIED
//
// MessageText:
//
// The source has not been set up completely.%0
//
#define NS_E_SOURCE_NOTSPECIFIED         _HRESULT_TYPEDEF_(0xC00D1B85L)

//
// MessageId: NS_E_NO_REALTIME_TIMECOMPRESSION
//
// MessageText:
//
// It is not possible to apply time compression to a broadcast session.%0
//
#define NS_E_NO_REALTIME_TIMECOMPRESSION _HRESULT_TYPEDEF_(0xC00D1B86L)

//
// MessageId: NS_E_UNSUPPORTED_ENCODER_DEVICE
//
// MessageText:
//
// It is not possible to open this device.%0
//
#define NS_E_UNSUPPORTED_ENCODER_DEVICE  _HRESULT_TYPEDEF_(0xC00D1B87L)

//
// MessageId: NS_E_UNEXPECTED_DISPLAY_SETTINGS
//
// MessageText:
//
// It is not possible to start encoding because the display size or color has changed since the current session was defined. Restore the previous settings or create a new session.%0
//
#define NS_E_UNEXPECTED_DISPLAY_SETTINGS _HRESULT_TYPEDEF_(0xC00D1B88L)

//
// MessageId: NS_E_NO_AUDIODATA
//
// MessageText:
//
// No audio data has been received for several seconds. Check the audio source and restart the encoder.%0
//
#define NS_E_NO_AUDIODATA                _HRESULT_TYPEDEF_(0xC00D1B89L)

//
// MessageId: NS_E_INPUTSOURCE_PROBLEM
//
// MessageText:
//
// One or all of the specified sources are not working properly. Check that the sources are configured correctly.%0
//
#define NS_E_INPUTSOURCE_PROBLEM         _HRESULT_TYPEDEF_(0xC00D1B8AL)

//
// MessageId: NS_E_WME_VERSION_MISMATCH
//
// MessageText:
//
// The supplied configuration file is not supported by this version of the encoder.%0
//
#define NS_E_WME_VERSION_MISMATCH        _HRESULT_TYPEDEF_(0xC00D1B8BL)

//
// MessageId: NS_E_NO_REALTIME_PREPROCESS
//
// MessageText:
//
// It is not possible to use image preprocessing with live encoding.%0
//
#define NS_E_NO_REALTIME_PREPROCESS      _HRESULT_TYPEDEF_(0xC00D1B8CL)

//
// MessageId: NS_E_NO_REPEAT_PREPROCESS
//
// MessageText:
//
// It is not possible to use two-pass encoding when the source is set to loop.%0
//
#define NS_E_NO_REPEAT_PREPROCESS        _HRESULT_TYPEDEF_(0xC00D1B8DL)

//
// MessageId: NS_E_CANNOT_PAUSE_LIVEBROADCAST
//
// MessageText:
//
// It is not possible to pause encoding during a broadcast.%0
//
#define NS_E_CANNOT_PAUSE_LIVEBROADCAST  _HRESULT_TYPEDEF_(0xC00D1B8EL)

//
// MessageId: NS_E_DRM_PROFILE_NOT_SET
//
// MessageText:
//
// A DRM profile has not been set for the current session.%0
//
#define NS_E_DRM_PROFILE_NOT_SET         _HRESULT_TYPEDEF_(0xC00D1B8FL)

//
// MessageId: NS_E_DUPLICATE_DRMPROFILE
//
// MessageText:
//
// The profile ID is already used by a DRM profile. Specify a different profile ID.%0
//
#define NS_E_DUPLICATE_DRMPROFILE        _HRESULT_TYPEDEF_(0xC00D1B90L)

//
// MessageId: NS_E_INVALID_DEVICE
//
// MessageText:
//
// The setting of the selected device does not support control for playing back tapes.%0
//
#define NS_E_INVALID_DEVICE              _HRESULT_TYPEDEF_(0xC00D1B91L)

//
// MessageId: NS_E_SPEECHEDL_ON_NON_MIXEDMODE
//
// MessageText:
//
// You must specify a mixed voice and audio mode in order to use an optimization definition file.%0
//
#define NS_E_SPEECHEDL_ON_NON_MIXEDMODE  _HRESULT_TYPEDEF_(0xC00D1B92L)

//
// MessageId: NS_E_DRM_PASSWORD_TOO_LONG
//
// MessageText:
//
// The specified password is too long. Type a password with fewer than 8 characters.%0
//
#define NS_E_DRM_PASSWORD_TOO_LONG       _HRESULT_TYPEDEF_(0xC00D1B93L)

//
// MessageId: NS_E_DEVCONTROL_FAILED_SEEK
//
// MessageText:
//
// It is not possible to seek to the specified mark-in point.%0
//
#define NS_E_DEVCONTROL_FAILED_SEEK      _HRESULT_TYPEDEF_(0xC00D1B94L)

//
// MessageId: NS_E_INTERLACE_REQUIRE_SAMESIZE
//
// MessageText:
//
// When you choose to maintain the interlacing in your video, the output video size must match the input video size.%0
//
#define NS_E_INTERLACE_REQUIRE_SAMESIZE  _HRESULT_TYPEDEF_(0xC00D1B95L)

//
// MessageId: NS_E_TOO_MANY_DEVICECONTROL
//
// MessageText:
//
// Only one device control plug-in can control a device.%0
//
#define NS_E_TOO_MANY_DEVICECONTROL      _HRESULT_TYPEDEF_(0xC00D1B96L)

//
// MessageId: NS_E_NO_MULTIPASS_FOR_LIVEDEVICE
//
// MessageText:
//
// You must also enable storing content to hard disk temporarily in order to use two-pass encoding with the input device.%0
//
#define NS_E_NO_MULTIPASS_FOR_LIVEDEVICE _HRESULT_TYPEDEF_(0xC00D1B97L)

//
// MessageId: NS_E_MISSING_AUDIENCE
//
// MessageText:
//
// An audience is missing from the output stream configuration.%0
//
#define NS_E_MISSING_AUDIENCE            _HRESULT_TYPEDEF_(0xC00D1B98L)

//
// MessageId: NS_E_AUDIENCE_CONTENTTYPE_MISMATCH
//
// MessageText:
//
// All audiences in the output tree must have the same content type.%0
//
#define NS_E_AUDIENCE_CONTENTTYPE_MISMATCH _HRESULT_TYPEDEF_(0xC00D1B99L)

//
// MessageId: NS_E_MISSING_SOURCE_INDEX
//
// MessageText:
//
// A source index is missing from the output stream configuration.%0
//
#define NS_E_MISSING_SOURCE_INDEX        _HRESULT_TYPEDEF_(0xC00D1B9AL)

//
// MessageId: NS_E_NUM_LANGUAGE_MISMATCH
//
// MessageText:
//
// The same source index in different audiences should have the same number of languages.%0
//
#define NS_E_NUM_LANGUAGE_MISMATCH       _HRESULT_TYPEDEF_(0xC00D1B9BL)

//
// MessageId: NS_E_LANGUAGE_MISMATCH
//
// MessageText:
//
// The same source index in different audiences should have the same languages.%0
//
#define NS_E_LANGUAGE_MISMATCH           _HRESULT_TYPEDEF_(0xC00D1B9CL)

//
// MessageId: NS_E_VBRMODE_MISMATCH
//
// MessageText:
//
// The same source index in different audiences should use the same VBR encoding mode.%0
//
#define NS_E_VBRMODE_MISMATCH            _HRESULT_TYPEDEF_(0xC00D1B9DL)

//
// MessageId: NS_E_INVALID_INPUT_AUDIENCE_INDEX
//
// MessageText:
//
// The bit rate index specified is not valid.%0
//
#define NS_E_INVALID_INPUT_AUDIENCE_INDEX _HRESULT_TYPEDEF_(0xC00D1B9EL)

//
// MessageId: NS_E_INVALID_INPUT_LANGUAGE
//
// MessageText:
//
// The specified language is not valid.%0
//
#define NS_E_INVALID_INPUT_LANGUAGE      _HRESULT_TYPEDEF_(0xC00D1B9FL)

//
// MessageId: NS_E_INVALID_INPUT_STREAM
//
// MessageText:
//
// The specified source type is not valid.%0
//
#define NS_E_INVALID_INPUT_STREAM        _HRESULT_TYPEDEF_(0xC00D1BA0L)

//
// MessageId: NS_E_EXPECT_MONO_WAV_INPUT
//
// MessageText:
//
// The source must be a mono channel .wav file.%0
//
#define NS_E_EXPECT_MONO_WAV_INPUT       _HRESULT_TYPEDEF_(0xC00D1BA1L)

//
// MessageId: NS_E_INPUT_WAVFORMAT_MISMATCH
//
// MessageText:
//
// All the source .wav files must have the same format.%0
//
#define NS_E_INPUT_WAVFORMAT_MISMATCH    _HRESULT_TYPEDEF_(0xC00D1BA2L)

//
// MessageId: NS_E_RECORDQ_DISK_FULL
//
// MessageText:
//
// The hard disk being used for temporary storage of content has reached the minimum allowed disk space. Create more space on the hard disk and restart encoding.%0
//
#define NS_E_RECORDQ_DISK_FULL           _HRESULT_TYPEDEF_(0xC00D1BA3L)

//
// MessageId: NS_E_NO_PAL_INVERSE_TELECINE
//
// MessageText:
//
// It is not possible to apply the inverse telecine feature to PAL content.%0
//
#define NS_E_NO_PAL_INVERSE_TELECINE     _HRESULT_TYPEDEF_(0xC00D1BA4L)

//
// MessageId: NS_E_ACTIVE_SG_DEVICE_DISCONNECTED
//
// MessageText:
//
// A capture device in the current active source is no longer available.%0
//
#define NS_E_ACTIVE_SG_DEVICE_DISCONNECTED _HRESULT_TYPEDEF_(0xC00D1BA5L)

//
// MessageId: NS_E_ACTIVE_SG_DEVICE_CONTROL_DISCONNECTED
//
// MessageText:
//
// A device used in the current active source for device control is no longer available.%0
//
#define NS_E_ACTIVE_SG_DEVICE_CONTROL_DISCONNECTED _HRESULT_TYPEDEF_(0xC00D1BA6L)

//
// MessageId: NS_E_NO_FRAMES_SUBMITTED_TO_ANALYZER
//
// MessageText:
//
// No frames have been submitted to the analyzer for analysis.%0
//
#define NS_E_NO_FRAMES_SUBMITTED_TO_ANALYZER _HRESULT_TYPEDEF_(0xC00D1BA7L)

//
// MessageId: NS_E_INPUT_DOESNOT_SUPPORT_SMPTE
//
// MessageText:
//
// The source video does not support time codes.%0
//
#define NS_E_INPUT_DOESNOT_SUPPORT_SMPTE _HRESULT_TYPEDEF_(0xC00D1BA8L)

//
// MessageId: NS_E_NO_SMPTE_WITH_MULTIPLE_SOURCEGROUPS
//
// MessageText:
//
// It is not possible to generate a time code when there are multiple sources in a session.%0
//
#define NS_E_NO_SMPTE_WITH_MULTIPLE_SOURCEGROUPS _HRESULT_TYPEDEF_(0xC00D1BA9L)

//
// MessageId: NS_E_BAD_CONTENTEDL
//
// MessageText:
//
// The voice codec optimization definition file can not be found or is corrupted.%0
//
#define NS_E_BAD_CONTENTEDL              _HRESULT_TYPEDEF_(0xC00D1BAAL)

//
// MessageId: NS_E_INTERLACEMODE_MISMATCH
//
// MessageText:
//
// The same source index in different audiences should have the same interlace mode.%0
//
#define NS_E_INTERLACEMODE_MISMATCH      _HRESULT_TYPEDEF_(0xC00D1BABL)

//
// MessageId: NS_E_NONSQUAREPIXELMODE_MISMATCH
//
// MessageText:
//
// The same source index in different audiences should have the same nonsquare pixel mode.%0
//
#define NS_E_NONSQUAREPIXELMODE_MISMATCH _HRESULT_TYPEDEF_(0xC00D1BACL)

//
// MessageId: NS_E_SMPTEMODE_MISMATCH
//
// MessageText:
//
// The same source index in different audiences should have the same time code mode.%0
//
#define NS_E_SMPTEMODE_MISMATCH          _HRESULT_TYPEDEF_(0xC00D1BADL)

//
// MessageId: NS_E_END_OF_TAPE
//
// MessageText:
//
// Either the end of the tape has been reached or there is no tape. Check the device and tape.%0
//
#define NS_E_END_OF_TAPE                 _HRESULT_TYPEDEF_(0xC00D1BAEL)

//
// MessageId: NS_E_NO_MEDIA_IN_AUDIENCE
//
// MessageText:
//
// No audio or video input has been specified.%0
//
#define NS_E_NO_MEDIA_IN_AUDIENCE        _HRESULT_TYPEDEF_(0xC00D1BAFL)

//
// MessageId: NS_E_NO_AUDIENCES
//
// MessageText:
//
// The profile must contain a bit rate.%0
//
#define NS_E_NO_AUDIENCES                _HRESULT_TYPEDEF_(0xC00D1BB0L)

//
// MessageId: NS_E_NO_AUDIO_COMPAT
//
// MessageText:
//
// You must specify at least one audio stream to be compatible with Windows Media Player 7.1.%0
//
#define NS_E_NO_AUDIO_COMPAT             _HRESULT_TYPEDEF_(0xC00D1BB1L)

//
// MessageId: NS_E_INVALID_VBR_COMPAT
//
// MessageText:
//
// Using a VBR encoding mode is not compatible with Windows Media Player 7.1.%0
//
#define NS_E_INVALID_VBR_COMPAT          _HRESULT_TYPEDEF_(0xC00D1BB2L)

//
// MessageId: NS_E_NO_PROFILE_NAME
//
// MessageText:
//
// You must specify a profile name.%0
//
#define NS_E_NO_PROFILE_NAME             _HRESULT_TYPEDEF_(0xC00D1BB3L)

//
// MessageId: NS_E_INVALID_VBR_WITH_UNCOMP
//
// MessageText:
//
// It is not possible to use a VBR encoding mode with uncompressed audio or video.%0
//
#define NS_E_INVALID_VBR_WITH_UNCOMP     _HRESULT_TYPEDEF_(0xC00D1BB4L)

//
// MessageId: NS_E_MULTIPLE_VBR_AUDIENCES
//
// MessageText:
//
// It is not possible to use MBR encoding with VBR encoding.%0
//
#define NS_E_MULTIPLE_VBR_AUDIENCES      _HRESULT_TYPEDEF_(0xC00D1BB5L)

//
// MessageId: NS_E_UNCOMP_COMP_COMBINATION
//
// MessageText:
//
// It is not possible to mix uncompressed and compressed content in a session.%0
//
#define NS_E_UNCOMP_COMP_COMBINATION     _HRESULT_TYPEDEF_(0xC00D1BB6L)

//
// MessageId: NS_E_MULTIPLE_AUDIO_CODECS
//
// MessageText:
//
// All audiences must use the same audio codec.%0
//
#define NS_E_MULTIPLE_AUDIO_CODECS       _HRESULT_TYPEDEF_(0xC00D1BB7L)

//
// MessageId: NS_E_MULTIPLE_AUDIO_FORMATS
//
// MessageText:
//
// All audiences should use the same audio format to be compatible with Windows Media Player 7.1.%0
//
#define NS_E_MULTIPLE_AUDIO_FORMATS      _HRESULT_TYPEDEF_(0xC00D1BB8L)

//
// MessageId: NS_E_AUDIO_BITRATE_STEPDOWN
//
// MessageText:
//
// The audio bit rate for an audience with a higher total bit rate must be greater than one with a lower total bit rate.%0
//
#define NS_E_AUDIO_BITRATE_STEPDOWN      _HRESULT_TYPEDEF_(0xC00D1BB9L)

//
// MessageId: NS_E_INVALID_AUDIO_PEAKRATE
//
// MessageText:
//
// The audio peak bit rate setting is not valid.%0
//
#define NS_E_INVALID_AUDIO_PEAKRATE      _HRESULT_TYPEDEF_(0xC00D1BBAL)

//
// MessageId: NS_E_INVALID_AUDIO_PEAKRATE_2
//
// MessageText:
//
// The audio peak bit rate setting must be greater than the audio bit rate setting.%0
//
#define NS_E_INVALID_AUDIO_PEAKRATE_2    _HRESULT_TYPEDEF_(0xC00D1BBBL)

//
// MessageId: NS_E_INVALID_AUDIO_BUFFERMAX
//
// MessageText:
//
// The setting for the maximum buffer size for audio is not valid.%0
//
#define NS_E_INVALID_AUDIO_BUFFERMAX     _HRESULT_TYPEDEF_(0xC00D1BBCL)

//
// MessageId: NS_E_MULTIPLE_VIDEO_CODECS
//
// MessageText:
//
// All audiences must use the same video codec.%0
//
#define NS_E_MULTIPLE_VIDEO_CODECS       _HRESULT_TYPEDEF_(0xC00D1BBDL)

//
// MessageId: NS_E_MULTIPLE_VIDEO_SIZES
//
// MessageText:
//
// All audiences should use the same video size to be compatible with Windows Media Player 7.1.%0
//
#define NS_E_MULTIPLE_VIDEO_SIZES        _HRESULT_TYPEDEF_(0xC00D1BBEL)

//
// MessageId: NS_E_INVALID_VIDEO_BITRATE
//
// MessageText:
//
// The video bit rate setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_BITRATE       _HRESULT_TYPEDEF_(0xC00D1BBFL)

//
// MessageId: NS_E_VIDEO_BITRATE_STEPDOWN
//
// MessageText:
//
// The video bit rate for an audience with a higher total bit rate must be greater than one with a lower total bit rate.%0
//
#define NS_E_VIDEO_BITRATE_STEPDOWN      _HRESULT_TYPEDEF_(0xC00D1BC0L)

//
// MessageId: NS_E_INVALID_VIDEO_PEAKRATE
//
// MessageText:
//
// The video peak bit rate setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_PEAKRATE      _HRESULT_TYPEDEF_(0xC00D1BC1L)

//
// MessageId: NS_E_INVALID_VIDEO_PEAKRATE_2
//
// MessageText:
//
// The video peak bit rate setting must be greater than the video bit rate setting.%0
//
#define NS_E_INVALID_VIDEO_PEAKRATE_2    _HRESULT_TYPEDEF_(0xC00D1BC2L)

//
// MessageId: NS_E_INVALID_VIDEO_WIDTH
//
// MessageText:
//
// The video width setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_WIDTH         _HRESULT_TYPEDEF_(0xC00D1BC3L)

//
// MessageId: NS_E_INVALID_VIDEO_HEIGHT
//
// MessageText:
//
// The video height setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_HEIGHT        _HRESULT_TYPEDEF_(0xC00D1BC4L)

//
// MessageId: NS_E_INVALID_VIDEO_FPS
//
// MessageText:
//
// The video frame rate setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_FPS           _HRESULT_TYPEDEF_(0xC00D1BC5L)

//
// MessageId: NS_E_INVALID_VIDEO_KEYFRAME
//
// MessageText:
//
// The video key frame setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_KEYFRAME      _HRESULT_TYPEDEF_(0xC00D1BC6L)

//
// MessageId: NS_E_INVALID_VIDEO_IQUALITY
//
// MessageText:
//
// The video image quality setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_IQUALITY      _HRESULT_TYPEDEF_(0xC00D1BC7L)

//
// MessageId: NS_E_INVALID_VIDEO_CQUALITY
//
// MessageText:
//
// The video codec quality setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_CQUALITY      _HRESULT_TYPEDEF_(0xC00D1BC8L)

//
// MessageId: NS_E_INVALID_VIDEO_BUFFER
//
// MessageText:
//
// The video buffer setting is not valid.%0
//
#define NS_E_INVALID_VIDEO_BUFFER        _HRESULT_TYPEDEF_(0xC00D1BC9L)

//
// MessageId: NS_E_INVALID_VIDEO_BUFFERMAX
//
// MessageText:
//
// The setting for the maximum buffer size for video is not valid.%0
//
#define NS_E_INVALID_VIDEO_BUFFERMAX     _HRESULT_TYPEDEF_(0xC00D1BCAL)

//
// MessageId: NS_E_INVALID_VIDEO_BUFFERMAX_2
//
// MessageText:
//
// The value of the video maximum buffer size setting must be greater than the video buffer size setting.%0
//
#define NS_E_INVALID_VIDEO_BUFFERMAX_2   _HRESULT_TYPEDEF_(0xC00D1BCBL)

//
// MessageId: NS_E_INVALID_VIDEO_WIDTH_ALIGN
//
// MessageText:
//
// The alignment of the video width is not valid.%0
//
#define NS_E_INVALID_VIDEO_WIDTH_ALIGN   _HRESULT_TYPEDEF_(0xC00D1BCCL)

//
// MessageId: NS_E_INVALID_VIDEO_HEIGHT_ALIGN
//
// MessageText:
//
// The alignment of the video height is not valid.%0
//
#define NS_E_INVALID_VIDEO_HEIGHT_ALIGN  _HRESULT_TYPEDEF_(0xC00D1BCDL)

//
// MessageId: NS_E_MULTIPLE_SCRIPT_BITRATES
//
// MessageText:
//
// All bit rates must have the same script bit rate.%0
//
#define NS_E_MULTIPLE_SCRIPT_BITRATES    _HRESULT_TYPEDEF_(0xC00D1BCEL)

//
// MessageId: NS_E_INVALID_SCRIPT_BITRATE
//
// MessageText:
//
// The script bit rate specified is not valid.%0
//
#define NS_E_INVALID_SCRIPT_BITRATE      _HRESULT_TYPEDEF_(0xC00D1BCFL)

//
// MessageId: NS_E_MULTIPLE_FILE_BITRATES
//
// MessageText:
//
// All bit rates must have the same file transfer bit rate.%0
//
#define NS_E_MULTIPLE_FILE_BITRATES      _HRESULT_TYPEDEF_(0xC00D1BD0L)

//
// MessageId: NS_E_INVALID_FILE_BITRATE
//
// MessageText:
//
// The file transfer bit rate is not valid.%0
//
#define NS_E_INVALID_FILE_BITRATE        _HRESULT_TYPEDEF_(0xC00D1BD1L)

//
// MessageId: NS_E_SAME_AS_INPUT_COMBINATION
//
// MessageText:
//
// All audiences in a profile should either be same as input or have video width and height specified.%0
//
#define NS_E_SAME_AS_INPUT_COMBINATION   _HRESULT_TYPEDEF_(0xC00D1BD2L)

//
// MessageId: NS_E_SOURCE_CANNOT_LOOP
//
// MessageText:
//
// This source type does not support looping.%0
//
#define NS_E_SOURCE_CANNOT_LOOP          _HRESULT_TYPEDEF_(0xC00D1BD3L)

//
// MessageId: NS_E_INVALID_FOLDDOWN_COEFFICIENTS
//
// MessageText:
//
// The fold-down value needs to be between -144 and 0.%0
//
#define NS_E_INVALID_FOLDDOWN_COEFFICIENTS _HRESULT_TYPEDEF_(0xC00D1BD4L)

//
// MessageId: NS_E_DRMPROFILE_NOTFOUND
//
// MessageText:
//
// The specified DRM profile does not exist in the system.%0
//
#define NS_E_DRMPROFILE_NOTFOUND         _HRESULT_TYPEDEF_(0xC00D1BD5L)

//
// MessageId: NS_E_INVALID_TIMECODE
//
// MessageText:
//
// The specified time code is not valid.%0
//
#define NS_E_INVALID_TIMECODE            _HRESULT_TYPEDEF_(0xC00D1BD6L)

//
// MessageId: NS_E_NO_AUDIO_TIMECOMPRESSION
//
// MessageText:
//
// It is not possible to apply time compression to a video-only session.%0
//
#define NS_E_NO_AUDIO_TIMECOMPRESSION    _HRESULT_TYPEDEF_(0xC00D1BD7L)

//
// MessageId: NS_E_NO_TWOPASS_TIMECOMPRESSION
//
// MessageText:
//
// It is not possible to apply time compression to a session that is using two-pass encoding.%0
//
#define NS_E_NO_TWOPASS_TIMECOMPRESSION  _HRESULT_TYPEDEF_(0xC00D1BD8L)

//
// MessageId: NS_E_TIMECODE_REQUIRES_VIDEOSTREAM
//
// MessageText:
//
// It is not possible to generate a time code for an audio-only session.%0
//
#define NS_E_TIMECODE_REQUIRES_VIDEOSTREAM _HRESULT_TYPEDEF_(0xC00D1BD9L)

//
// MessageId: NS_E_NO_MBR_WITH_TIMECODE
//
// MessageText:
//
// It is not possible to generate a time code when you are encoding content at multiple bit rates.%0
//
#define NS_E_NO_MBR_WITH_TIMECODE        _HRESULT_TYPEDEF_(0xC00D1BDAL)

//
// MessageId: NS_E_INVALID_INTERLACEMODE
//
// MessageText:
//
// The video codec selected does not support maintaining interlacing in video.%0
//
#define NS_E_INVALID_INTERLACEMODE       _HRESULT_TYPEDEF_(0xC00D1BDBL)

//
// MessageId: NS_E_INVALID_INTERLACE_COMPAT
//
// MessageText:
//
// Maintaining interlacing in video is not compatible with Windows Media Player 7.1.%0
//
#define NS_E_INVALID_INTERLACE_COMPAT    _HRESULT_TYPEDEF_(0xC00D1BDCL)

//
// MessageId: NS_E_INVALID_NONSQUAREPIXEL_COMPAT
//
// MessageText:
//
// Allowing nonsquare pixel output is not compatible with Windows Media Player 7.1.%0
//
#define NS_E_INVALID_NONSQUAREPIXEL_COMPAT _HRESULT_TYPEDEF_(0xC00D1BDDL)

//
// MessageId: NS_E_INVALID_SOURCE_WITH_DEVICE_CONTROL
//
// MessageText:
//
// Only capture devices can be used with device control.%0
//
#define NS_E_INVALID_SOURCE_WITH_DEVICE_CONTROL _HRESULT_TYPEDEF_(0xC00D1BDEL)

//
// MessageId: NS_E_CANNOT_GENERATE_BROADCAST_INFO_FOR_QUALITYVBR
//
// MessageText:
//
// It is not possible to generate the stream format file if you are using quality-based VBR encoding for the audio or video stream. Instead use the Windows Media file generated after encoding to create the announcement file.%0
//
#define NS_E_CANNOT_GENERATE_BROADCAST_INFO_FOR_QUALITYVBR _HRESULT_TYPEDEF_(0xC00D1BDFL)

//
// MessageId: NS_E_EXCEED_MAX_DRM_PROFILE_LIMIT
//
// MessageText:
//
// It is not possible to create a DRM profile because the maximum number of profiles has been reached. You must delete some DRM profiles before creating new ones.%0
//
#define NS_E_EXCEED_MAX_DRM_PROFILE_LIMIT _HRESULT_TYPEDEF_(0xC00D1BE0L)

//
// MessageId: NS_E_DEVICECONTROL_UNSTABLE
//
// MessageText:
//
// The device is in an unstable state. Check that the device is functioning properly and a tape is in place.
//
#define NS_E_DEVICECONTROL_UNSTABLE      _HRESULT_TYPEDEF_(0xC00D1BE1L)

//
// MessageId: NS_E_INVALID_PIXEL_ASPECT_RATIO
//
// MessageText:
//
// The pixel aspect ratio value must be between 1 and 255.
//
#define NS_E_INVALID_PIXEL_ASPECT_RATIO  _HRESULT_TYPEDEF_(0xC00D1BE2L)

//
// MessageId: NS_E_AUDIENCE__LANGUAGE_CONTENTTYPE_MISMATCH
//
// MessageText:
//
// All streams with different languages in the same audience must have same properties.%0
//
#define NS_E_AUDIENCE__LANGUAGE_CONTENTTYPE_MISMATCH _HRESULT_TYPEDEF_(0xC00D1BE3L)

//
// MessageId: NS_E_INVALID_PROFILE_CONTENTTYPE
//
// MessageText:
//
// The profile must contain at least one audio or video stream.%0
//
#define NS_E_INVALID_PROFILE_CONTENTTYPE _HRESULT_TYPEDEF_(0xC00D1BE4L)

//
// MessageId: NS_E_TRANSFORM_PLUGIN_NOT_FOUND
//
// MessageText:
//
// The transform plug-in could not be found.%0
//
#define NS_E_TRANSFORM_PLUGIN_NOT_FOUND  _HRESULT_TYPEDEF_(0xC00D1BE5L)

//
// MessageId: NS_E_TRANSFORM_PLUGIN_INVALID
//
// MessageText:
//
// The transform plug-in is not valid. It may be damaged or you may not have the required permissions to access the plug-in.%0
//
#define NS_E_TRANSFORM_PLUGIN_INVALID    _HRESULT_TYPEDEF_(0xC00D1BE6L)

//
// MessageId: NS_E_EDL_REQUIRED_FOR_DEVICE_MULTIPASS
//
// MessageText:
//
// To use two-pass encoding, you must enable device control and setup an edit decision list (EDL) that has at least one entry.%0
//
#define NS_E_EDL_REQUIRED_FOR_DEVICE_MULTIPASS _HRESULT_TYPEDEF_(0xC00D1BE7L)

//
// MessageId: NS_E_INVALID_VIDEO_WIDTH_FOR_INTERLACED_ENCODING
//
// MessageText:
//
// When you choose to maintain the interlacing in your video, the output video size must be a multiple of 4.%0
//
#define NS_E_INVALID_VIDEO_WIDTH_FOR_INTERLACED_ENCODING _HRESULT_TYPEDEF_(0xC00D1BE8L)

//
// MessageId: NS_E_MARKIN_UNSUPPORTED
//
// MessageText:
//
// Markin/Markout is unsupported with this source type.%0
//
#define NS_E_MARKIN_UNSUPPORTED          _HRESULT_TYPEDEF_(0xC00D1BE9L)


/////////////////////////////////////////////////////////////////////////
//
// DRM Specific Errors
//
// IdRange = 10000..10999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_DRM_INVALID_APPLICATION
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_INVALID_APPLICATION     _HRESULT_TYPEDEF_(0xC00D2711L)

//
// MessageId: NS_E_DRM_LICENSE_STORE_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_STORE_ERROR     _HRESULT_TYPEDEF_(0xC00D2712L)

//
// MessageId: NS_E_DRM_SECURE_STORE_ERROR
//
// MessageText:
//
// Secure storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_ERROR      _HRESULT_TYPEDEF_(0xC00D2713L)

//
// MessageId: NS_E_DRM_LICENSE_STORE_SAVE_ERROR
//
// MessageText:
//
// License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_STORE_SAVE_ERROR _HRESULT_TYPEDEF_(0xC00D2714L)

//
// MessageId: NS_E_DRM_SECURE_STORE_UNLOCK_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURE_STORE_UNLOCK_ERROR _HRESULT_TYPEDEF_(0xC00D2715L)

//
// MessageId: NS_E_DRM_INVALID_CONTENT
//
// MessageText:
//
// The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_CONTENT         _HRESULT_TYPEDEF_(0xC00D2716L)

//
// MessageId: NS_E_DRM_UNABLE_TO_OPEN_LICENSE
//
// MessageText:
//
// The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_UNABLE_TO_OPEN_LICENSE  _HRESULT_TYPEDEF_(0xC00D2717L)

//
// MessageId: NS_E_DRM_INVALID_LICENSE
//
// MessageText:
//
// The license is corrupted or invalid. Acquire a new license%0
//
#define NS_E_DRM_INVALID_LICENSE         _HRESULT_TYPEDEF_(0xC00D2718L)

//
// MessageId: NS_E_DRM_INVALID_MACHINE
//
// MessageText:
//
// Licenses cannot be copied from one computer to another. Use License Management to transfer licenses, or get a new license for the media file.%0
//
#define NS_E_DRM_INVALID_MACHINE         _HRESULT_TYPEDEF_(0xC00D2719L)

//
// MessageId: NS_E_DRM_ENUM_LICENSE_FAILED
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENUM_LICENSE_FAILED     _HRESULT_TYPEDEF_(0xC00D271BL)

//
// MessageId: NS_E_DRM_INVALID_LICENSE_REQUEST
//
// MessageText:
//
// The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_INVALID_LICENSE_REQUEST _HRESULT_TYPEDEF_(0xC00D271CL)

//
// MessageId: NS_E_DRM_UNABLE_TO_INITIALIZE
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_INITIALIZE    _HRESULT_TYPEDEF_(0xC00D271DL)

//
// MessageId: NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE
//
// MessageText:
//
// The license could not be acquired. Try again later.%0
//
#define NS_E_DRM_UNABLE_TO_ACQUIRE_LICENSE _HRESULT_TYPEDEF_(0xC00D271EL)

//
// MessageId: NS_E_DRM_INVALID_LICENSE_ACQUIRED
//
// MessageText:
//
// License acquisition did not work. Acquire a new license or contact the content provider for further assistance.%0
//
#define NS_E_DRM_INVALID_LICENSE_ACQUIRED _HRESULT_TYPEDEF_(0xC00D271FL)

//
// MessageId: NS_E_DRM_NO_RIGHTS
//
// MessageText:
//
// The requested operation cannot be performed on this file.%0
//
#define NS_E_DRM_NO_RIGHTS               _HRESULT_TYPEDEF_(0xC00D2720L)

//
// MessageId: NS_E_DRM_KEY_ERROR
//
// MessageText:
//
// The requested action cannot be performed because a problem occurred with the Windows Media Digital Rights Management (DRM) components on your computer.%0.
//
#define NS_E_DRM_KEY_ERROR               _HRESULT_TYPEDEF_(0xC00D2721L)

//
// MessageId: NS_E_DRM_ENCRYPT_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0
//
#define NS_E_DRM_ENCRYPT_ERROR           _HRESULT_TYPEDEF_(0xC00D2722L)

//
// MessageId: NS_E_DRM_DECRYPT_ERROR
//
// MessageText:
//
// The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_DECRYPT_ERROR           _HRESULT_TYPEDEF_(0xC00D2723L)

//
// MessageId: NS_E_DRM_LICENSE_INVALID_XML
//
// MessageText:
//
// The license is corrupted. Acquire a new license.%0
//
#define NS_E_DRM_LICENSE_INVALID_XML     _HRESULT_TYPEDEF_(0xC00D2725L)

//
// MessageId: NS_S_DRM_LICENSE_ACQUIRED
//
// MessageText:
//
// Status message: The license was acquired.%0
//
#define NS_S_DRM_LICENSE_ACQUIRED        _HRESULT_TYPEDEF_(0x000D2726L)

//
// MessageId: NS_S_DRM_INDIVIDUALIZED
//
// MessageText:
//
// Status message: The security upgrade has been completed.%0
//
#define NS_S_DRM_INDIVIDUALIZED          _HRESULT_TYPEDEF_(0x000D2727L)

//
// MessageId: NS_E_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
// A security upgrade is required to perform the operation on this media file.%0
//
#define NS_E_DRM_NEEDS_INDIVIDUALIZATION _HRESULT_TYPEDEF_(0xC00D2728L)

//
// MessageId: NS_E_DRM_ALREADY_INDIVIDUALIZED
//
// MessageText:
//
// You already have the latest security components. No upgrade is necessary at this time.%0
//
#define NS_E_DRM_ALREADY_INDIVIDUALIZED  _HRESULT_TYPEDEF_(0xC00D2729L)

//
// MessageId: NS_E_DRM_ACTION_NOT_QUERIED
//
// MessageText:
//
// The application cannot perform this action. Contact product support for this application.%0
//
#define NS_E_DRM_ACTION_NOT_QUERIED      _HRESULT_TYPEDEF_(0xC00D272AL)

//
// MessageId: NS_E_DRM_ACQUIRING_LICENSE
//
// MessageText:
//
// You cannot begin a new license acquisition process until the current one has been completed.%0
//
#define NS_E_DRM_ACQUIRING_LICENSE       _HRESULT_TYPEDEF_(0xC00D272BL)

//
// MessageId: NS_E_DRM_INDIVIDUALIZING
//
// MessageText:
//
// You cannot begin a new security upgrade until the current one has been completed.%0
//
#define NS_E_DRM_INDIVIDUALIZING         _HRESULT_TYPEDEF_(0xC00D272CL)

//
// MessageId: NS_E_BACKUP_RESTORE_FAILURE
//
// MessageText:
//
// Failure in Backup-Restore.%0
//
#define NS_E_BACKUP_RESTORE_FAILURE      _HRESULT_TYPEDEF_(0xC00D272DL)

//
// MessageId: NS_E_BACKUP_RESTORE_BAD_REQUEST_ID
//
// MessageText:
//
// Bad Request ID in Backup-Restore.%0
//
#define NS_E_BACKUP_RESTORE_BAD_REQUEST_ID _HRESULT_TYPEDEF_(0xC00D272EL)

//
// MessageId: NS_E_DRM_PARAMETERS_MISMATCHED
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_PARAMETERS_MISMATCHED   _HRESULT_TYPEDEF_(0xC00D272FL)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT
//
// MessageText:
//
// A license cannot be created for this media file. Reinstall the application.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_LICENSE_OBJECT _HRESULT_TYPEDEF_(0xC00D2730L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_INDI_OBJECT _HRESULT_TYPEDEF_(0xC00D2731L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_ENCRYPT_OBJECT _HRESULT_TYPEDEF_(0xC00D2732L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_DECRYPT_OBJECT _HRESULT_TYPEDEF_(0xC00D2733L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_PROPERTIES_OBJECT _HRESULT_TYPEDEF_(0xC00D2734L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_BACKUP_OBJECT _HRESULT_TYPEDEF_(0xC00D2735L)

//
// MessageId: NS_E_DRM_INDIVIDUALIZE_ERROR
//
// MessageText:
//
// The security upgrade failed. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZE_ERROR     _HRESULT_TYPEDEF_(0xC00D2736L)

//
// MessageId: NS_E_DRM_LICENSE_OPEN_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_OPEN_ERROR      _HRESULT_TYPEDEF_(0xC00D2737L)

//
// MessageId: NS_E_DRM_LICENSE_CLOSE_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_CLOSE_ERROR     _HRESULT_TYPEDEF_(0xC00D2738L)

//
// MessageId: NS_E_DRM_GET_LICENSE_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSE_ERROR       _HRESULT_TYPEDEF_(0xC00D2739L)

//
// MessageId: NS_E_DRM_QUERY_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_QUERY_ERROR             _HRESULT_TYPEDEF_(0xC00D273AL)

//
// MessageId: NS_E_DRM_REPORT_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_REPORT_ERROR            _HRESULT_TYPEDEF_(0xC00D273BL)

//
// MessageId: NS_E_DRM_GET_LICENSESTRING_ERROR
//
// MessageText:
//
// License storage is not working. Contact Microsoft product support.%0
//
#define NS_E_DRM_GET_LICENSESTRING_ERROR _HRESULT_TYPEDEF_(0xC00D273CL)

//
// MessageId: NS_E_DRM_GET_CONTENTSTRING_ERROR
//
// MessageText:
//
// The media file is corrupted. Contact the content provider to get a new file.%0
//
#define NS_E_DRM_GET_CONTENTSTRING_ERROR _HRESULT_TYPEDEF_(0xC00D273DL)

//
// MessageId: NS_E_DRM_MONITOR_ERROR
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Try again later.%0
//
#define NS_E_DRM_MONITOR_ERROR           _HRESULT_TYPEDEF_(0xC00D273EL)

//
// MessageId: NS_E_DRM_UNABLE_TO_SET_PARAMETER
//
// MessageText:
//
// The application has made an invalid call to the Digital Rights Management component. Contact product support for this application.%0
//
#define NS_E_DRM_UNABLE_TO_SET_PARAMETER _HRESULT_TYPEDEF_(0xC00D273FL)

//
// MessageId: NS_E_DRM_INVALID_APPDATA
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_APPDATA         _HRESULT_TYPEDEF_(0xC00D2740L)

//
// MessageId: NS_E_DRM_INVALID_APPDATA_VERSION
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_APPDATA_VERSION _HRESULT_TYPEDEF_(0xC00D2741L)

//
// MessageId: NS_E_DRM_BACKUP_EXISTS
//
// MessageText:
//
// Licenses are already backed up in this location.%0
//
#define NS_E_DRM_BACKUP_EXISTS           _HRESULT_TYPEDEF_(0xC00D2742L)

//
// MessageId: NS_E_DRM_BACKUP_CORRUPT
//
// MessageText:
//
// One or more backed-up licenses are missing or corrupt.%0
//
#define NS_E_DRM_BACKUP_CORRUPT          _HRESULT_TYPEDEF_(0xC00D2743L)

//
// MessageId: NS_E_DRM_BACKUPRESTORE_BUSY
//
// MessageText:
//
// You cannot begin a new backup process until the current process has been completed.%0
//
#define NS_E_DRM_BACKUPRESTORE_BUSY      _HRESULT_TYPEDEF_(0xC00D2744L)

//
// MessageId: NS_E_BACKUP_RESTORE_BAD_DATA
//
// MessageText:
//
// Bad Data sent to Backup-Restore.%0
//
#define NS_E_BACKUP_RESTORE_BAD_DATA     _HRESULT_TYPEDEF_(0xC00D2745L)

//
// MessageId: NS_S_DRM_MONITOR_CANCELLED
//
// MessageText:
//
// Status message: License monitoring has been cancelled.%0
//
#define NS_S_DRM_MONITOR_CANCELLED       _HRESULT_TYPEDEF_(0x000D2746L)

//
// MessageId: NS_S_DRM_ACQUIRE_CANCELLED
//
// MessageText:
//
// Status message: License acquisition has been cancelled.%0
//
#define NS_S_DRM_ACQUIRE_CANCELLED       _HRESULT_TYPEDEF_(0x000D2747L)

//
// MessageId: NS_E_DRM_LICENSE_UNUSABLE
//
// MessageText:
//
// The license is invalid. Contact the content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_UNUSABLE        _HRESULT_TYPEDEF_(0xC00D2748L)

//
// MessageId: NS_E_DRM_INVALID_PROPERTY
//
// MessageText:
//
// A required property was not set by the application. Contact product support for this application.%0.
//
#define NS_E_DRM_INVALID_PROPERTY        _HRESULT_TYPEDEF_(0xC00D2749L)

//
// MessageId: NS_E_DRM_SECURE_STORE_NOT_FOUND
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component of this application. Try to acquire a license again.%0
//
#define NS_E_DRM_SECURE_STORE_NOT_FOUND  _HRESULT_TYPEDEF_(0xC00D274AL)

//
// MessageId: NS_E_DRM_CACHED_CONTENT_ERROR
//
// MessageText:
//
// A license cannot be found for this media file. Use License Management to transfer a license for this file from the original computer, or acquire a new license.%0
//
#define NS_E_DRM_CACHED_CONTENT_ERROR    _HRESULT_TYPEDEF_(0xC00D274BL)

//
// MessageId: NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE
//
// MessageText:
//
// A problem occurred during the security upgrade. Try again later.%0
//
#define NS_E_DRM_INDIVIDUALIZATION_INCOMPLETE _HRESULT_TYPEDEF_(0xC00D274CL)

//
// MessageId: NS_E_DRM_DRIVER_AUTH_FAILURE
//
// MessageText:
//
// Certified driver components are required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_AUTH_FAILURE     _HRESULT_TYPEDEF_(0xC00D274DL)

//
// MessageId: NS_E_DRM_NEED_UPGRADE_MSSAP
//
// MessageText:
//
// One or more of the Secure Audio Path components were not found or an entry point in those components was not found.%0
//
#define NS_E_DRM_NEED_UPGRADE_MSSAP      _HRESULT_TYPEDEF_(0xC00D274EL)

//
// MessageId: NS_E_DRM_REOPEN_CONTENT
//
// MessageText:
//
// Status message: Reopen the file.%0
//
#define NS_E_DRM_REOPEN_CONTENT          _HRESULT_TYPEDEF_(0xC00D274FL)

//
// MessageId: NS_E_DRM_DRIVER_DIGIOUT_FAILURE
//
// MessageText:
//
// Certain driver functionality is required to play this media file. Contact Windows Update to see whether updated drivers are available for your hardware.%0
//
#define NS_E_DRM_DRIVER_DIGIOUT_FAILURE  _HRESULT_TYPEDEF_(0xC00D2750L)

//
// MessageId: NS_E_DRM_INVALID_SECURESTORE_PASSWORD
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_SECURESTORE_PASSWORD _HRESULT_TYPEDEF_(0xC00D2751L)

//
// MessageId: NS_E_DRM_APPCERT_REVOKED
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_APPCERT_REVOKED         _HRESULT_TYPEDEF_(0xC00D2752L)

//
// MessageId: NS_E_DRM_RESTORE_FRAUD
//
// MessageText:
//
// You cannot restore your license(s).%0
//
#define NS_E_DRM_RESTORE_FRAUD           _HRESULT_TYPEDEF_(0xC00D2753L)

//
// MessageId: NS_E_DRM_HARDWARE_INCONSISTENT
//
// MessageText:
//
// The licenses for your media files are corrupted. Contact Microsoft product support.%0
//
#define NS_E_DRM_HARDWARE_INCONSISTENT   _HRESULT_TYPEDEF_(0xC00D2754L)

//
// MessageId: NS_E_DRM_SDMI_TRIGGER
//
// MessageText:
//
// To transfer this media file, you must upgrade the application.%0
//
#define NS_E_DRM_SDMI_TRIGGER            _HRESULT_TYPEDEF_(0xC00D2755L)

//
// MessageId: NS_E_DRM_SDMI_NOMORECOPIES
//
// MessageText:
//
// You cannot make any more copies of this media file.%0
//
#define NS_E_DRM_SDMI_NOMORECOPIES       _HRESULT_TYPEDEF_(0xC00D2756L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_HEADER_OBJECT _HRESULT_TYPEDEF_(0xC00D2757L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_KEYS_OBJECT _HRESULT_TYPEDEF_(0xC00D2758L)

;// This error is never shown to user but needed for program logic.
//
// MessageId: NS_E_DRM_LICENSE_NOTACQUIRED
//
// MessageText:
//
// Unable to obtain license.%0
//
#define NS_E_DRM_LICENSE_NOTACQUIRED     _HRESULT_TYPEDEF_(0xC00D2759L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_CODING_OBJECT _HRESULT_TYPEDEF_(0xC00D275AL)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_STATE_DATA_OBJECT _HRESULT_TYPEDEF_(0xC00D275BL)

//
// MessageId: NS_E_DRM_BUFFER_TOO_SMALL
//
// MessageText:
//
// The buffer supplied is not sufficient.%0.
//
#define NS_E_DRM_BUFFER_TOO_SMALL        _HRESULT_TYPEDEF_(0xC00D275CL)

//
// MessageId: NS_E_DRM_UNSUPPORTED_PROPERTY
//
// MessageText:
//
// The property requested is not supported.%0.
//
#define NS_E_DRM_UNSUPPORTED_PROPERTY    _HRESULT_TYPEDEF_(0xC00D275DL)

//
// MessageId: NS_E_DRM_ERROR_BAD_NET_RESP
//
// MessageText:
//
// The specified server cannot perform the requested operation.%0.
//
#define NS_E_DRM_ERROR_BAD_NET_RESP      _HRESULT_TYPEDEF_(0xC00D275EL)

//
// MessageId: NS_E_DRM_STORE_NOTALLSTORED
//
// MessageText:
//
// Some of the licenses could not be stored.%0.
//
#define NS_E_DRM_STORE_NOTALLSTORED      _HRESULT_TYPEDEF_(0xC00D275FL)

//
// MessageId: NS_E_DRM_SECURITY_COMPONENT_SIGNATURE_INVALID
//
// MessageText:
//
// The Digital Rights Management security upgrade component could not be validated. Contact Microsoft product support.%0
//
#define NS_E_DRM_SECURITY_COMPONENT_SIGNATURE_INVALID _HRESULT_TYPEDEF_(0xC00D2760L)

//
// MessageId: NS_E_DRM_INVALID_DATA
//
// MessageText:
//
// Invalid or corrupt data was encountered.%0
//
#define NS_E_DRM_INVALID_DATA            _HRESULT_TYPEDEF_(0xC00D2761L)

//
// MessageId: NS_E_DRM_POLICY_DISABLE_ONLINE
//
// MessageText:
//
// The Windows Media Digital Rights Management system cannot perform the requested action because your computer or network administrator has enabled the group policy Prevent Windows Media DRM Internet Access. For assistance, contact your administrator.%0
//
#define NS_E_DRM_POLICY_DISABLE_ONLINE   _HRESULT_TYPEDEF_(0xC00D2762L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_AUTHENTICATION_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_AUTHENTICATION_OBJECT _HRESULT_TYPEDEF_(0xC00D2763L)

//
// MessageId: NS_E_DRM_NOT_CONFIGURED
//
// MessageText:
//
// Not all of the necessary properties for DRM have been set.%0
//
#define NS_E_DRM_NOT_CONFIGURED          _HRESULT_TYPEDEF_(0xC00D2764L)

//
// MessageId: NS_E_DRM_DEVICE_ACTIVATION_CANCELED
//
// MessageText:
//
// The portable device does not have the security required to copy protected files to it. To obtain the additional security, try to copy the file to your portable device again. When a message appears, click OK.%0
//
#define NS_E_DRM_DEVICE_ACTIVATION_CANCELED _HRESULT_TYPEDEF_(0xC00D2765L)

//
// MessageId: NS_E_BACKUP_RESTORE_TOO_MANY_RESETS
//
// MessageText:
//
// Too many resets in Backup-Restore.%0
//
#define NS_E_BACKUP_RESTORE_TOO_MANY_RESETS _HRESULT_TYPEDEF_(0xC00D2766L)

//
// MessageId: NS_E_DRM_DEBUGGING_NOT_ALLOWED
//
// MessageText:
//
// Running this process under a debugger while using DRM content is not allowed.%0
//
#define NS_E_DRM_DEBUGGING_NOT_ALLOWED   _HRESULT_TYPEDEF_(0xC00D2767L)

//
// MessageId: NS_E_DRM_OPERATION_CANCELED
//
// MessageText:
//
// The user canceled the DRM operation.%0
//
#define NS_E_DRM_OPERATION_CANCELED      _HRESULT_TYPEDEF_(0xC00D2768L)

//
// MessageId: NS_E_DRM_RESTRICTIONS_NOT_RETRIEVED
//
// MessageText:
//
// The license you are using has assocaited output restrictions.  This license is unusable until these restrictions are queried.%0
//
#define NS_E_DRM_RESTRICTIONS_NOT_RETRIEVED _HRESULT_TYPEDEF_(0xC00D2769L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_PLAYLIST_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_PLAYLIST_OBJECT _HRESULT_TYPEDEF_(0xC00D276AL)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_PLAYLIST_BURN_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_PLAYLIST_BURN_OBJECT _HRESULT_TYPEDEF_(0xC00D276BL)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_DEVICE_REGISTRATION_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_DEVICE_REGISTRATION_OBJECT _HRESULT_TYPEDEF_(0xC00D276CL)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_METERING_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_METERING_OBJECT _HRESULT_TYPEDEF_(0xC00D276DL)

//
// MessageId: NS_S_DRM_BURNABLE_TRACK
//
// MessageText:
//
// The track is burnable and had no playlist burn limit.%0.
//
#define NS_S_DRM_BURNABLE_TRACK          _HRESULT_TYPEDEF_(0x000D276EL)

//
// MessageId: NS_S_DRM_BURNABLE_TRACK_WITH_PLAYLIST_RESTRICTION
//
// MessageText:
//
// The track is burnable but has a playlist burn limit.%0.
//
#define NS_S_DRM_BURNABLE_TRACK_WITH_PLAYLIST_RESTRICTION _HRESULT_TYPEDEF_(0x000D276FL)

//
// MessageId: NS_E_DRM_TRACK_EXCEEDED_PLAYLIST_RESTICTION
//
// MessageText:
//
// The specified track has exceeded it's specified playlist burn limit in this playlist.%0.
//
#define NS_E_DRM_TRACK_EXCEEDED_PLAYLIST_RESTICTION _HRESULT_TYPEDEF_(0xC00D2770L)

//
// MessageId: NS_E_DRM_TRACK_EXCEEDED_TRACKBURN_RESTRICTION
//
// MessageText:
//
// The specified track has exceeded it's track burn limit.%0.
//
#define NS_E_DRM_TRACK_EXCEEDED_TRACKBURN_RESTRICTION _HRESULT_TYPEDEF_(0xC00D2771L)

//
// MessageId: NS_E_DRM_UNABLE_TO_GET_DEVICE_CERT
//
// MessageText:
//
// A problem has occurred in obtaining the device's certificate. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_GET_DEVICE_CERT _HRESULT_TYPEDEF_(0xC00D2772L)

//
// MessageId: NS_E_DRM_UNABLE_TO_GET_SECURE_CLOCK
//
// MessageText:
//
// A problem has occurred in obtaining the device's secure clock. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_GET_SECURE_CLOCK _HRESULT_TYPEDEF_(0xC00D2773L)

//
// MessageId: NS_E_DRM_UNABLE_TO_SET_SECURE_CLOCK
//
// MessageText:
//
// A problem has occurred in setting the device's secure clock. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_SET_SECURE_CLOCK _HRESULT_TYPEDEF_(0xC00D2774L)

//
// MessageId: NS_E_DRM_UNABLE_TO_GET_SECURE_CLOCK_FROM_SERVER
//
// MessageText:
//
// A problem has occurred in obtaining the secure clock from server. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_GET_SECURE_CLOCK_FROM_SERVER _HRESULT_TYPEDEF_(0xC00D2775L)

//
// MessageId: NS_E_DRM_POLICY_METERING_DISABLED
//
// MessageText:
//
// This content requires the metering policy to be enabled.%0.
//
#define NS_E_DRM_POLICY_METERING_DISABLED _HRESULT_TYPEDEF_(0xC00D2776L)

//
// MessageId: NS_E_DRM_TRANSFER_CHAINED_LICENSES_UNSUPPORTED
//
// MessageText:
//
// Transfer of chained licenses unsupported.%0.
//
#define NS_E_DRM_TRANSFER_CHAINED_LICENSES_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2777L)

//
// MessageId: NS_E_DRM_SDK_VERSIONMISMATCH
//
// MessageText:
//
// The Digital Rights Management component is not installed properly.  Reinstall the Player.%0.
//
#define NS_E_DRM_SDK_VERSIONMISMATCH     _HRESULT_TYPEDEF_(0xC00D2778L)

//
// MessageId: NS_E_DRM_LIC_NEEDS_DEVICE_CLOCK_SET
//
// MessageText:
//
// The file could not be transferred because the device clock is not set. %0.
//
#define NS_E_DRM_LIC_NEEDS_DEVICE_CLOCK_SET _HRESULT_TYPEDEF_(0xC00D2779L)

//
// MessageId: NS_E_LICENSE_HEADER_MISSING_URL
//
// MessageText:
//
// The content header is missing an acquisition URL.%0
//
#define NS_E_LICENSE_HEADER_MISSING_URL  _HRESULT_TYPEDEF_(0xC00D277AL)

//
// MessageId: NS_E_DEVICE_NOT_WMDRM_DEVICE
//
// MessageText:
//
// The current attached device does not support WMDRM.%0
//
#define NS_E_DEVICE_NOT_WMDRM_DEVICE     _HRESULT_TYPEDEF_(0xC00D277BL)

//
// MessageId: NS_E_DRM_INVALID_APPCERT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_APPCERT         _HRESULT_TYPEDEF_(0xC00D277CL)

//
// MessageId: NS_E_DRM_PROTOCOL_FORCEFUL_TERMINATION_ON_PETITION
//
// MessageText:
//
// The client application has been forcefully terminated during a DRM petition.%0.
//
#define NS_E_DRM_PROTOCOL_FORCEFUL_TERMINATION_ON_PETITION _HRESULT_TYPEDEF_(0xC00D277DL)

//
// MessageId: NS_E_DRM_PROTOCOL_FORCEFUL_TERMINATION_ON_CHALLENGE
//
// MessageText:
//
// The client application has been forcefully terminated during a DRM challenge.%0.
//
#define NS_E_DRM_PROTOCOL_FORCEFUL_TERMINATION_ON_CHALLENGE _HRESULT_TYPEDEF_(0xC00D277EL)

//
// MessageId: NS_E_DRM_CHECKPOINT_FAILED
//
// MessageText:
//
// Secure storage protection error.  Restore your licenses from a previous backup and try again.%0
//
#define NS_E_DRM_CHECKPOINT_FAILED       _HRESULT_TYPEDEF_(0xC00D277FL)

//
// MessageId: NS_E_DRM_BB_UNABLE_TO_INITIALIZE
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management root of trust. Contact Microsoft product support.%0
//
#define NS_E_DRM_BB_UNABLE_TO_INITIALIZE _HRESULT_TYPEDEF_(0xC00D2780L)

//
// MessageId: NS_E_DRM_UNABLE_TO_LOAD_HARDWARE_ID
//
// MessageText:
//
// A problem has occurred in retrieving the Digital Rights Management machine identification. Contact Microsoft product support.%0
//
#define NS_E_DRM_UNABLE_TO_LOAD_HARDWARE_ID _HRESULT_TYPEDEF_(0xC00D2781L)

//
// MessageId: NS_E_DRM_UNABLE_TO_OPEN_DATA_STORE
//
// MessageText:
//
// A problem has occurred in opening the Digital Rights Management data storage file. Contact Microsoft product.%0
//
#define NS_E_DRM_UNABLE_TO_OPEN_DATA_STORE _HRESULT_TYPEDEF_(0xC00D2782L)

//
// MessageId: NS_E_DRM_DATASTORE_CORRUPT
//
// MessageText:
//
// The Digital Rights Management data storage is not functioning properly.  Contact Microsoft product support.%0.
//
#define NS_E_DRM_DATASTORE_CORRUPT       _HRESULT_TYPEDEF_(0xC00D2783L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_INMEMORYSTORE_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_INMEMORYSTORE_OBJECT _HRESULT_TYPEDEF_(0xC00D2784L)

//
// MessageId: NS_E_DRM_STUBLIB_REQUIRED
//
// MessageText:
//
// A secured library is required to access the requested functionality.%0.
//
#define NS_E_DRM_STUBLIB_REQUIRED        _HRESULT_TYPEDEF_(0xC00D2785L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_CERTIFICATE_OBJECT
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_UNABLE_TO_CREATE_CERTIFICATE_OBJECT _HRESULT_TYPEDEF_(0xC00D2786L)

//
// MessageId: NS_E_DRM_MIGRATION_TARGET_NOT_ONLINE
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component during license migration. Contact Microsoft product support.%0.
//
#define NS_E_DRM_MIGRATION_TARGET_NOT_ONLINE _HRESULT_TYPEDEF_(0xC00D2787L)

//
// MessageId: NS_E_DRM_INVALID_MIGRATION_IMAGE
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component during license migration. Contact Microsoft product support.%0.
//
#define NS_E_DRM_INVALID_MIGRATION_IMAGE _HRESULT_TYPEDEF_(0xC00D2788L)

//
// MessageId: NS_E_DRM_MIGRATION_TARGET_STATES_CORRUPTED
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component during license migration. Contact Microsoft product support.%0.
//
#define NS_E_DRM_MIGRATION_TARGET_STATES_CORRUPTED _HRESULT_TYPEDEF_(0xC00D2789L)

//
// MessageId: NS_E_DRM_MIGRATION_IMPORTER_NOT_AVAILABLE
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component during license migration. Contact Microsoft product support.%0.
//
#define NS_E_DRM_MIGRATION_IMPORTER_NOT_AVAILABLE _HRESULT_TYPEDEF_(0xC00D278AL)

//
// MessageId: NS_DRM_E_MIGRATION_UPGRADE_WITH_DIFF_SID
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component during license migration. Contact Microsoft product support.%0.
//
#define NS_DRM_E_MIGRATION_UPGRADE_WITH_DIFF_SID _HRESULT_TYPEDEF_(0xC00D278BL)

//
// MessageId: NS_DRM_E_MIGRATION_SOURCE_MACHINE_IN_USE
//
// MessageText:
//
// The Digital Rights Management component is in use during license migration. Contact Microsoft product support.%0.
//
#define NS_DRM_E_MIGRATION_SOURCE_MACHINE_IN_USE _HRESULT_TYPEDEF_(0xC00D278CL)

//
// MessageId: NS_DRM_E_MIGRATION_TARGET_MACHINE_LESS_THAN_LH
//
// MessageText:
//
// Licenses are being migrated to a machine running XP or downlevel OS. This operation can only be performed on Windows Vista or a later OS. Contact Microsoft product support.%0.
//
#define NS_DRM_E_MIGRATION_TARGET_MACHINE_LESS_THAN_LH _HRESULT_TYPEDEF_(0xC00D278DL)

//
// MessageId: NS_DRM_E_MIGRATION_IMAGE_ALREADY_EXISTS
//
// MessageText:
//
// Migration Image already exists. Contact Microsoft product support.%0.
//
#define NS_DRM_E_MIGRATION_IMAGE_ALREADY_EXISTS _HRESULT_TYPEDEF_(0xC00D278EL)

//
// MessageId: NS_E_DRM_HARDWAREID_MISMATCH
//
// MessageText:
//
// The requested action cannot be performed because a hardware configuration change has been detected by the Windows Media Digital Rights Management (DRM) components on your computer.%0.
//
#define NS_E_DRM_HARDWAREID_MISMATCH     _HRESULT_TYPEDEF_(0xC00D278FL)

//
// MessageId: NS_E_INVALID_DRMV2CLT_STUBLIB
//
// MessageText:
//
// The wrong stublib has been linked to an application or DLL using drmv2clt.dll.%0
//
#define NS_E_INVALID_DRMV2CLT_STUBLIB    _HRESULT_TYPEDEF_(0xC00D2790L)

//
// MessageId: NS_E_DRM_MIGRATION_INVALID_LEGACYV2_DATA
//
// MessageText:
//
// The legacy V2 data being imported is invalid
//
#define NS_E_DRM_MIGRATION_INVALID_LEGACYV2_DATA _HRESULT_TYPEDEF_(0xC00D2791L)

//
// MessageId: NS_E_DRM_MIGRATION_LICENSE_ALREADY_EXISTS
//
// MessageText:
//
// The license being imported already exists
//
#define NS_E_DRM_MIGRATION_LICENSE_ALREADY_EXISTS _HRESULT_TYPEDEF_(0xC00D2792L)

//
// MessageId: NS_E_DRM_MIGRATION_INVALID_LEGACYV2_SST_PASSWORD
//
// MessageText:
//
// The password of the Legacy V2 SST entry being imported is incorrect
//
#define NS_E_DRM_MIGRATION_INVALID_LEGACYV2_SST_PASSWORD _HRESULT_TYPEDEF_(0xC00D2793L)

//
// MessageId: NS_E_DRM_MIGRATION_NOT_SUPPORTED
//
// MessageText:
//
// Migration is not supported by the plugin
//
#define NS_E_DRM_MIGRATION_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D2794L)

//
// MessageId: NS_E_DRM_UNABLE_TO_CREATE_MIGRATION_IMPORTER_OBJECT
//
// MessageText:
//
// A migration importer cannot be created for this media file. Reinstall the application.%0
//
#define NS_E_DRM_UNABLE_TO_CREATE_MIGRATION_IMPORTER_OBJECT _HRESULT_TYPEDEF_(0xC00D2795L)

//
// MessageId: NS_E_DRM_CHECKPOINT_MISMATCH
//
// MessageText:
//
// The requested action cannot be performed because a problem occurred with the Windows Media Digital Rights Management (DRM) components on your computer.%0.
//
#define NS_E_DRM_CHECKPOINT_MISMATCH     _HRESULT_TYPEDEF_(0xC00D2796L)

//
// MessageId: NS_E_DRM_CHECKPOINT_CORRUPT
//
// MessageText:
//
// The requested action cannot be performed because a problem occurred with the Windows Media Digital Rights Management (DRM) components on your computer.%0.
//
#define NS_E_DRM_CHECKPOINT_CORRUPT      _HRESULT_TYPEDEF_(0xC00D2797L)

//
// MessageId: NS_E_REG_FLUSH_FAILURE
//
// MessageText:
//
// The requested action cannot be performed because a problem occurred with the Windows Media Digital Rights Management (DRM) components on your computer.%0.
//
#define NS_E_REG_FLUSH_FAILURE           _HRESULT_TYPEDEF_(0xC00D2798L)

//
// MessageId: NS_E_HDS_KEY_MISMATCH
//
// MessageText:
//
// The requested action cannot be performed because a problem occurred with the Windows Media Digital Rights Management (DRM) components on your computer.%0.
//
#define NS_E_HDS_KEY_MISMATCH            _HRESULT_TYPEDEF_(0xC00D2799L)

//
// MessageId: NS_E_DRM_MIGRATION_OPERATION_CANCELLED
//
// MessageText:
//
// Migration was cancelled by the user.%0
//
#define NS_E_DRM_MIGRATION_OPERATION_CANCELLED _HRESULT_TYPEDEF_(0xC00D279AL)

//
// MessageId: NS_E_DRM_MIGRATION_OBJECT_IN_USE
//
// MessageText:
//
// Migration object is already in use and cannot be called until the current operation completes.%0
//
#define NS_E_DRM_MIGRATION_OBJECT_IN_USE _HRESULT_TYPEDEF_(0xC00D279BL)

//
// MessageId: NS_E_DRM_MALFORMED_CONTENT_HEADER
//
// MessageText:
//
// The content header does not comply with DRM requirements and cannot be used.%0
//
#define NS_E_DRM_MALFORMED_CONTENT_HEADER _HRESULT_TYPEDEF_(0xC00D279CL)


//
// License Reasons Section
// Error Codes why a license is not usable. Reserve 10200..10300 for this purpose.
// 10200..10249 is for license reported reasons. 10250..10300 is for client detected reasons.
//

//
// MessageId: NS_E_DRM_LICENSE_EXPIRED
//
// MessageText:
//
// The license for this file has expired and is no longer valid. Contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_EXPIRED         _HRESULT_TYPEDEF_(0xC00D27D8L)

//
// MessageId: NS_E_DRM_LICENSE_NOTENABLED
//
// MessageText:
//
// The license for this file is not valid yet, but will be at a future date.%0
//
#define NS_E_DRM_LICENSE_NOTENABLED      _HRESULT_TYPEDEF_(0xC00D27D9L)

//
// MessageId: NS_E_DRM_LICENSE_APPSECLOW
//
// MessageText:
//
// The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_APPSECLOW       _HRESULT_TYPEDEF_(0xC00D27DAL)

//
// MessageId: NS_E_DRM_STORE_NEEDINDI
//
// MessageText:
//
// The license cannot be stored as it requires security upgrade of Digital Rights Management component.%0.
//
#define NS_E_DRM_STORE_NEEDINDI          _HRESULT_TYPEDEF_(0xC00D27DBL)

//
// MessageId: NS_E_DRM_STORE_NOTALLOWED
//
// MessageText:
//
// Your machine does not meet the requirements for storing the license.%0.
//
#define NS_E_DRM_STORE_NOTALLOWED        _HRESULT_TYPEDEF_(0xC00D27DCL)

//
// MessageId: NS_E_DRM_LICENSE_APP_NOTALLOWED
//
// MessageText:
//
// The license for this file requires an upgraded version of your player or a different player.%0.
//
#define NS_E_DRM_LICENSE_APP_NOTALLOWED  _HRESULT_TYPEDEF_(0xC00D27DDL)

//
// MessageId: NS_S_DRM_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
// A security upgrade is required to perform the operation on this media file.%0
//
#define NS_S_DRM_NEEDS_INDIVIDUALIZATION _HRESULT_TYPEDEF_(0x000D27DEL)

//
// MessageId: NS_E_DRM_LICENSE_CERT_EXPIRED
//
// MessageText:
//
// The license server's certificate expired. Make sure your system clock is set correctly. Contact your content provider for further assistance. %0.
//
#define NS_E_DRM_LICENSE_CERT_EXPIRED    _HRESULT_TYPEDEF_(0xC00D27DFL)

//
// MessageId: NS_E_DRM_LICENSE_SECLOW
//
// MessageText:
//
// The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_SECLOW          _HRESULT_TYPEDEF_(0xC00D27E0L)

//
// MessageId: NS_E_DRM_LICENSE_CONTENT_REVOKED
//
// MessageText:
//
// The content owner for the license you just acquired is no longer supporting their content. Contact the content owner for a newer version of the content.%0
//
#define NS_E_DRM_LICENSE_CONTENT_REVOKED _HRESULT_TYPEDEF_(0xC00D27E1L)

//
// MessageId: NS_E_DRM_DEVICE_NOT_REGISTERED
//
// MessageText:
//
// The content owner for the license you just acquired requires your device to register to the current machine.%0
//
#define NS_E_DRM_DEVICE_NOT_REGISTERED   _HRESULT_TYPEDEF_(0xC00D27E2L)

//
// MessageId: NS_E_DRM_LICENSE_NOSAP
//
// MessageText:
//
// The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSAP           _HRESULT_TYPEDEF_(0xC00D280AL)

//
// MessageId: NS_E_DRM_LICENSE_NOSVP
//
// MessageText:
//
// The license for this file requires a feature that is not supported in your current player or operating system. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOSVP           _HRESULT_TYPEDEF_(0xC00D280BL)

//
// MessageId: NS_E_DRM_LICENSE_NOWDM
//
// MessageText:
//
// The license for this file requires Windows Driver Model (WDM) audio drivers. Contact your sound card manufacturer for further assistance.%0
//
#define NS_E_DRM_LICENSE_NOWDM           _HRESULT_TYPEDEF_(0xC00D280CL)

//
// MessageId: NS_E_DRM_LICENSE_NOTRUSTEDCODEC
//
// MessageText:
//
// The license for this file requires a higher level of security than the player you are currently using has. Try using a different player or download a newer version of your current player.%0
//
#define NS_E_DRM_LICENSE_NOTRUSTEDCODEC  _HRESULT_TYPEDEF_(0xC00D280DL)

//
// MessageId: NS_E_DRM_SOURCEID_NOT_SUPPORTED
//
// MessageText:
//
// The license for this file is not supported by your current player. You can try with newer version of your current player or contact your content provider for further assistance.%0
//
#define NS_E_DRM_SOURCEID_NOT_SUPPORTED  _HRESULT_TYPEDEF_(0xC00D280EL)


//
// End of License Reasons Section
//

//
// MessageId: NS_E_DRM_NEEDS_UPGRADE_TEMPFILE
//
// MessageText:
//
// An updated version of your media player is required to play the selected content.%0
//
#define NS_E_DRM_NEEDS_UPGRADE_TEMPFILE  _HRESULT_TYPEDEF_(0xC00D283DL)

//
// MessageId: NS_E_DRM_NEED_UPGRADE_PD
//
// MessageText:
//
// A new version of the Digital Rights Management component is required. Contact product support for this application to get the latest version.%0
//
#define NS_E_DRM_NEED_UPGRADE_PD         _HRESULT_TYPEDEF_(0xC00D283EL)

//
// MessageId: NS_E_DRM_SIGNATURE_FAILURE
//
// MessageText:
//
// Failed to either create or verify the content header.%0
//
#define NS_E_DRM_SIGNATURE_FAILURE       _HRESULT_TYPEDEF_(0xC00D283FL)

//
// MessageId: NS_E_DRM_LICENSE_SERVER_INFO_MISSING
//
// MessageText:
//
// Could not read the necessary information from the system registry.%0
//
#define NS_E_DRM_LICENSE_SERVER_INFO_MISSING _HRESULT_TYPEDEF_(0xC00D2840L)

//
// MessageId: NS_E_DRM_BUSY
//
// MessageText:
//
// The DRM subsystem is currently locked by another application or user.  Try again later.%0
//
#define NS_E_DRM_BUSY                    _HRESULT_TYPEDEF_(0xC00D2841L)

//
// MessageId: NS_E_DRM_PD_TOO_MANY_DEVICES
//
// MessageText:
//
// There are too many target devices registered on the portable media.%0
//
#define NS_E_DRM_PD_TOO_MANY_DEVICES     _HRESULT_TYPEDEF_(0xC00D2842L)

//
// MessageId: NS_E_DRM_INDIV_FRAUD
//
// MessageText:
//
// The security upgrade cannot be completed because the allowed number of daily upgrades has been exceeded. Try again tomorrow.%0
//
#define NS_E_DRM_INDIV_FRAUD             _HRESULT_TYPEDEF_(0xC00D2843L)

//
// MessageId: NS_E_DRM_INDIV_NO_CABS
//
// MessageText:
//
// The security upgrade cannot be completed because the server is unable to perform the operation. Try again later.%0
//
#define NS_E_DRM_INDIV_NO_CABS           _HRESULT_TYPEDEF_(0xC00D2844L)

//
// MessageId: NS_E_DRM_INDIV_SERVICE_UNAVAILABLE
//
// MessageText:
//
// The security upgrade cannot be performed because the server is not available. Try again later.%0
//
#define NS_E_DRM_INDIV_SERVICE_UNAVAILABLE _HRESULT_TYPEDEF_(0xC00D2845L)

//
// MessageId: NS_E_DRM_RESTORE_SERVICE_UNAVAILABLE
//
// MessageText:
//
// Windows Media Player cannot restore your licenses because the server is not available. Try again later.%0
//
#define NS_E_DRM_RESTORE_SERVICE_UNAVAILABLE _HRESULT_TYPEDEF_(0xC00D2846L)

//
// MessageId: NS_E_DRM_CLIENT_CODE_EXPIRED
//
// MessageText:
//
// Windows Media Player cannot play the protected file. Verify that your computer's date is set correctly. If it is correct, on the Help menu, click Check for Player Updates to install the latest version of the Player.%0
//
#define NS_E_DRM_CLIENT_CODE_EXPIRED     _HRESULT_TYPEDEF_(0xC00D2847L)

//
// MessageId: NS_E_DRM_NO_UPLINK_LICENSE
//
// MessageText:
//
// The chained license cannot be created because the referenced uplink license does not exist.
//
#define NS_E_DRM_NO_UPLINK_LICENSE       _HRESULT_TYPEDEF_(0xC00D2848L)

//
// MessageId: NS_E_DRM_INVALID_KID
//
// MessageText:
//
// The specified KID is invalid
//
#define NS_E_DRM_INVALID_KID             _HRESULT_TYPEDEF_(0xC00D2849L)

//
// MessageId: NS_E_DRM_LICENSE_INITIALIZATION_ERROR
//
// MessageText:
//
// License initialization did not work. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_INITIALIZATION_ERROR _HRESULT_TYPEDEF_(0xC00D284AL)

//
// MessageId: NS_E_DRM_CHAIN_TOO_LONG
//
// MessageText:
//
// The uplink license of a chained license cannot itself be a chained license.
//
#define NS_E_DRM_CHAIN_TOO_LONG          _HRESULT_TYPEDEF_(0xC00D284CL)

//
// MessageId: NS_E_DRM_UNSUPPORTED_ALGORITHM
//
// MessageText:
//
// The specified encryption algorithm is unsupported.
//
#define NS_E_DRM_UNSUPPORTED_ALGORITHM   _HRESULT_TYPEDEF_(0xC00D284DL)

//
// MessageId: NS_E_DRM_LICENSE_DELETION_ERROR
//
// MessageText:
//
// License deletion did not work. Contact Microsoft product support.%0
//
#define NS_E_DRM_LICENSE_DELETION_ERROR  _HRESULT_TYPEDEF_(0xC00D284EL)


//
// WMDRMNET Reasons Section
// Error Codes related to WMDRMNET (WMDRM-ND) or Device Registration.
// Reserved 10400..10500 for this purpose.
//

//
// MessageId: NS_E_DRM_INVALID_CERTIFICATE
//
// MessageText:
//
// The client's certificate is corrupted or the signature cannot be verified.%0
//
#define NS_E_DRM_INVALID_CERTIFICATE     _HRESULT_TYPEDEF_(0xC00D28A0L)

//
// MessageId: NS_E_DRM_CERTIFICATE_REVOKED
//
// MessageText:
//
// The client's certificate has been revoked.%0
//
#define NS_E_DRM_CERTIFICATE_REVOKED     _HRESULT_TYPEDEF_(0xC00D28A1L)

//
// MessageId: NS_E_DRM_LICENSE_UNAVAILABLE
//
// MessageText:
//
// There is no license available for the requested action.%0
//
#define NS_E_DRM_LICENSE_UNAVAILABLE     _HRESULT_TYPEDEF_(0xC00D28A2L)

//
// MessageId: NS_E_DRM_DEVICE_LIMIT_REACHED
//
// MessageText:
//
// The maximum number of devices in use has been reached. Unable to open additional devices.%0
//
#define NS_E_DRM_DEVICE_LIMIT_REACHED    _HRESULT_TYPEDEF_(0xC00D28A3L)

//
// MessageId: NS_E_DRM_UNABLE_TO_VERIFY_PROXIMITY
//
// MessageText:
//
// The proximity detection procedure could not confirm that the receiver is near the transmitter in the network.%0
//
#define NS_E_DRM_UNABLE_TO_VERIFY_PROXIMITY _HRESULT_TYPEDEF_(0xC00D28A4L)

//
// MessageId: NS_E_DRM_MUST_REGISTER
//
// MessageText:
//
// The client must be registered before executing the intended operation.%0
//
#define NS_E_DRM_MUST_REGISTER           _HRESULT_TYPEDEF_(0xC00D28A5L)

//
// MessageId: NS_E_DRM_MUST_APPROVE
//
// MessageText:
//
// The client must be approved before executing the intended operation.%0
//
#define NS_E_DRM_MUST_APPROVE            _HRESULT_TYPEDEF_(0xC00D28A6L)

//
// MessageId: NS_E_DRM_MUST_REVALIDATE
//
// MessageText:
//
// The client must be revalidated before executing the intended operation.%0
//
#define NS_E_DRM_MUST_REVALIDATE         _HRESULT_TYPEDEF_(0xC00D28A7L)

//
// MessageId: NS_E_DRM_INVALID_PROXIMITY_RESPONSE
//
// MessageText:
//
// The response to the proximity detection challenge is invalid.%0
//
#define NS_E_DRM_INVALID_PROXIMITY_RESPONSE _HRESULT_TYPEDEF_(0xC00D28A8L)

//
// MessageId: NS_E_DRM_INVALID_SESSION
//
// MessageText:
//
// The requested session is invalid.%0
//
#define NS_E_DRM_INVALID_SESSION         _HRESULT_TYPEDEF_(0xC00D28A9L)

//
// MessageId: NS_E_DRM_DEVICE_NOT_OPEN
//
// MessageText:
//
// The device must be opened before it can be used to receive content.%0
//
#define NS_E_DRM_DEVICE_NOT_OPEN         _HRESULT_TYPEDEF_(0xC00D28AAL)

//
// MessageId: NS_E_DRM_DEVICE_ALREADY_REGISTERED
//
// MessageText:
//
// Device registration failed because the device is already registered.%0
//
#define NS_E_DRM_DEVICE_ALREADY_REGISTERED _HRESULT_TYPEDEF_(0xC00D28ABL)

//
// MessageId: NS_E_DRM_UNSUPPORTED_PROTOCOL_VERSION
//
// MessageText:
//
// Unsupported WMDRM-ND protocol version.%0
//
#define NS_E_DRM_UNSUPPORTED_PROTOCOL_VERSION _HRESULT_TYPEDEF_(0xC00D28ACL)

//
// MessageId: NS_E_DRM_UNSUPPORTED_ACTION
//
// MessageText:
//
// The requested action is not supported.%0
//
#define NS_E_DRM_UNSUPPORTED_ACTION      _HRESULT_TYPEDEF_(0xC00D28ADL)

//
// MessageId: NS_E_DRM_CERTIFICATE_SECURITY_LEVEL_INADEQUATE
//
// MessageText:
//
// The certificate does not have an adequate security level for the requested action.%0
//
#define NS_E_DRM_CERTIFICATE_SECURITY_LEVEL_INADEQUATE _HRESULT_TYPEDEF_(0xC00D28AEL)

//
// MessageId: NS_E_DRM_UNABLE_TO_OPEN_PORT
//
// MessageText:
//
// Unable to open the specified port for receiving Proximity messages.%0
//
#define NS_E_DRM_UNABLE_TO_OPEN_PORT     _HRESULT_TYPEDEF_(0xC00D28AFL)

//
// MessageId: NS_E_DRM_BAD_REQUEST
//
// MessageText:
//
// The message format is invalid.%0
//
#define NS_E_DRM_BAD_REQUEST             _HRESULT_TYPEDEF_(0xC00D28B0L)

//
// MessageId: NS_E_DRM_INVALID_CRL
//
// MessageText:
//
// The Certificate Revocation List is invalid or corrupted.%0
//
#define NS_E_DRM_INVALID_CRL             _HRESULT_TYPEDEF_(0xC00D28B1L)

//
// MessageId: NS_E_DRM_ATTRIBUTE_TOO_LONG
//
// MessageText:
//
// The length of the attribute name or value is too long.%0
//
#define NS_E_DRM_ATTRIBUTE_TOO_LONG      _HRESULT_TYPEDEF_(0xC00D28B2L)

//
// MessageId: NS_E_DRM_EXPIRED_LICENSEBLOB
//
// MessageText:
//
// The license blob passed in the cardea request is expired.%0
//
#define NS_E_DRM_EXPIRED_LICENSEBLOB     _HRESULT_TYPEDEF_(0xC00D28B3L)

//
// MessageId: NS_E_DRM_INVALID_LICENSEBLOB
//
// MessageText:
//
// The license blob passed in the cardea request is invalid. Contact Microsoft product support.%0
//
#define NS_E_DRM_INVALID_LICENSEBLOB     _HRESULT_TYPEDEF_(0xC00D28B4L)

//
// MessageId: NS_E_DRM_INCLUSION_LIST_REQUIRED
//
// MessageText:
//
// The requested operation can not be performed because the license does not contain an inclusion list.%0
//
#define NS_E_DRM_INCLUSION_LIST_REQUIRED _HRESULT_TYPEDEF_(0xC00D28B5L)

//
// MessageId: NS_E_DRM_DRMV2CLT_REVOKED
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_DRMV2CLT_REVOKED        _HRESULT_TYPEDEF_(0xC00D28B6L)

//
// MessageId: NS_E_DRM_RIV_TOO_SMALL
//
// MessageText:
//
// A problem has occurred in the Digital Rights Management component. Contact Microsoft product support.%0.
//
#define NS_E_DRM_RIV_TOO_SMALL           _HRESULT_TYPEDEF_(0xC00D28B7L)


//
// Output link protection error codes
//

//
// MessageId: NS_E_OUTPUT_PROTECTION_LEVEL_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the level of output protection required by the content.%0
//
#define NS_E_OUTPUT_PROTECTION_LEVEL_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2904L)

//
// MessageId: NS_E_COMPRESSED_DIGITAL_VIDEO_PROTECTION_LEVEL_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the level of protection required for compressed digital video.%0
//
#define NS_E_COMPRESSED_DIGITAL_VIDEO_PROTECTION_LEVEL_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2905L)

//
// MessageId: NS_E_UNCOMPRESSED_DIGITAL_VIDEO_PROTECTION_LEVEL_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the level of protection required for uncompressed digital video.%0
//
#define NS_E_UNCOMPRESSED_DIGITAL_VIDEO_PROTECTION_LEVEL_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2906L)

//
// MessageId: NS_E_ANALOG_VIDEO_PROTECTION_LEVEL_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the level of protection required for analog video.%0
//
#define NS_E_ANALOG_VIDEO_PROTECTION_LEVEL_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2907L)

//
// MessageId: NS_E_COMPRESSED_DIGITAL_AUDIO_PROTECTION_LEVEL_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the level of protection required for compressed digital audio.%0
//
#define NS_E_COMPRESSED_DIGITAL_AUDIO_PROTECTION_LEVEL_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2908L)

//
// MessageId: NS_E_UNCOMPRESSED_DIGITAL_AUDIO_PROTECTION_LEVEL_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the level of protection required for uncompressed digital audio.%0
//
#define NS_E_UNCOMPRESSED_DIGITAL_AUDIO_PROTECTION_LEVEL_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D2909L)

//
// MessageId: NS_E_OUTPUT_PROTECTION_SCHEME_UNSUPPORTED
//
// MessageText:
//
// Windows Media Player does not support the scheme of output protection required by the content.%0
//
#define NS_E_OUTPUT_PROTECTION_SCHEME_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D290AL)



/////////////////////////////////////////////////////////////////////////
//
// Windows Media Setup Specific Errors
//
// IdRange = 11000..11999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_S_REBOOT_RECOMMENDED
//
// MessageText:
//
// Installation was successful; however, some file cleanup is not complete. For best results, restart your computer.%0
//
#define NS_S_REBOOT_RECOMMENDED          _HRESULT_TYPEDEF_(0x000D2AF8L)

//
// MessageId: NS_S_REBOOT_REQUIRED
//
// MessageText:
//
// Installation was successful; however, some file cleanup is not complete. To continue, you must restart your computer.%0
//
#define NS_S_REBOOT_REQUIRED             _HRESULT_TYPEDEF_(0x000D2AF9L)

//
// MessageId: NS_E_REBOOT_RECOMMENDED
//
// MessageText:
//
// Installation was not successful and some file cleanup is not complete. For best results, restart your computer.%0
//
#define NS_E_REBOOT_RECOMMENDED          _HRESULT_TYPEDEF_(0xC00D2AFAL)

//
// MessageId: NS_E_REBOOT_REQUIRED
//
// MessageText:
//
// Installation was not successful. To continue, you must restart your computer.%0
//
#define NS_E_REBOOT_REQUIRED             _HRESULT_TYPEDEF_(0xC00D2AFBL)

//
// MessageId: NS_E_SETUP_INCOMPLETE
//
// MessageText:
//
// Installation was not successful.%0.
//
#define NS_E_SETUP_INCOMPLETE            _HRESULT_TYPEDEF_(0xC00D2AFCL)

//
// MessageId: NS_E_SETUP_DRM_MIGRATION_FAILED
//
// MessageText:
//
// Setup cannot migrate the Windows Media Digital Rights Management (DRM) components.%0.
//
#define NS_E_SETUP_DRM_MIGRATION_FAILED  _HRESULT_TYPEDEF_(0xC00D2AFDL)

//
// MessageId: NS_E_SETUP_IGNORABLE_FAILURE
//
// MessageText:
//
// Some skin or playlist components cannot be installed.%0.
//
#define NS_E_SETUP_IGNORABLE_FAILURE     _HRESULT_TYPEDEF_(0xC00D2AFEL)

//
// MessageId: NS_E_SETUP_DRM_MIGRATION_FAILED_AND_IGNORABLE_FAILURE
//
// MessageText:
//
// Setup cannot migrate the Windows Media Digital Rights Management (DRM) components. In addition, some skin or playlist components cannot be installed.%0.
//
#define NS_E_SETUP_DRM_MIGRATION_FAILED_AND_IGNORABLE_FAILURE _HRESULT_TYPEDEF_(0xC00D2AFFL)

//
// MessageId: NS_E_SETUP_BLOCKED
//
// MessageText:
//
// Installation is blocked because your computer does not meet one or more of the setup requirements.%0.
//
#define NS_E_SETUP_BLOCKED               _HRESULT_TYPEDEF_(0xC00D2B00L)


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Networking Errors
//
// IdRange = 12000..12999
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_UNKNOWN_PROTOCOL
//
// MessageText:
//
// The specified protocol is not supported.%0
//
#define NS_E_UNKNOWN_PROTOCOL            _HRESULT_TYPEDEF_(0xC00D2EE0L)

//
// MessageId: NS_E_REDIRECT_TO_PROXY
//
// MessageText:
//
// The client is redirected to a proxy server.%0
//
#define NS_E_REDIRECT_TO_PROXY           _HRESULT_TYPEDEF_(0xC00D2EE1L)

//
// MessageId: NS_E_INTERNAL_SERVER_ERROR
//
// MessageText:
//
// The server encountered an unexpected condition which prevented it from fulfilling the request.%0
//
#define NS_E_INTERNAL_SERVER_ERROR       _HRESULT_TYPEDEF_(0xC00D2EE2L)

//
// MessageId: NS_E_BAD_REQUEST
//
// MessageText:
//
// The request could not be understood by the server.%0
//
#define NS_E_BAD_REQUEST                 _HRESULT_TYPEDEF_(0xC00D2EE3L)

//
// MessageId: NS_E_ERROR_FROM_PROXY
//
// MessageText:
//
// The proxy experienced an error while attempting to contact the media server.%0
//
#define NS_E_ERROR_FROM_PROXY            _HRESULT_TYPEDEF_(0xC00D2EE4L)

//
// MessageId: NS_E_PROXY_TIMEOUT
//
// MessageText:
//
// The proxy did not receive a timely response while attempting to contact the media server.%0
//
#define NS_E_PROXY_TIMEOUT               _HRESULT_TYPEDEF_(0xC00D2EE5L)

//
// MessageId: NS_E_SERVER_UNAVAILABLE
//
// MessageText:
//
// The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.%0
//
#define NS_E_SERVER_UNAVAILABLE          _HRESULT_TYPEDEF_(0xC00D2EE6L)

//
// MessageId: NS_E_REFUSED_BY_SERVER
//
// MessageText:
//
// The server is refusing to fulfill the requested operation.%0
//
#define NS_E_REFUSED_BY_SERVER           _HRESULT_TYPEDEF_(0xC00D2EE7L)

//
// MessageId: NS_E_INCOMPATIBLE_SERVER
//
// MessageText:
//
// The server is not a compatible streaming media server.%0
//
#define NS_E_INCOMPATIBLE_SERVER         _HRESULT_TYPEDEF_(0xC00D2EE8L)

//
// MessageId: NS_E_MULTICAST_DISABLED
//
// MessageText:
//
// The content cannot be streamed because the Multicast protocol has been disabled.%0
//
#define NS_E_MULTICAST_DISABLED          _HRESULT_TYPEDEF_(0xC00D2EE9L)

//
// MessageId: NS_E_INVALID_REDIRECT
//
// MessageText:
//
// The server redirected the player to an invalid location.%0
//
#define NS_E_INVALID_REDIRECT            _HRESULT_TYPEDEF_(0xC00D2EEAL)

//
// MessageId: NS_E_ALL_PROTOCOLS_DISABLED
//
// MessageText:
//
// The content cannot be streamed because all protocols have been disabled.%0
//
#define NS_E_ALL_PROTOCOLS_DISABLED      _HRESULT_TYPEDEF_(0xC00D2EEBL)

//
// MessageId: NS_E_MSBD_NO_LONGER_SUPPORTED
//
// MessageText:
//
// The MSBD protocol is no longer supported. Please use HTTP to connect to the Windows Media stream.%0
//
#define NS_E_MSBD_NO_LONGER_SUPPORTED    _HRESULT_TYPEDEF_(0xC00D2EECL)

//
// MessageId: NS_E_PROXY_NOT_FOUND
//
// MessageText:
//
// The proxy server could not be located. Please check your proxy server configuration.%0
//
#define NS_E_PROXY_NOT_FOUND             _HRESULT_TYPEDEF_(0xC00D2EEDL)

//
// MessageId: NS_E_CANNOT_CONNECT_TO_PROXY
//
// MessageText:
//
// Unable to establish a connection to the proxy server. Please check your proxy server configuration.%0
//
#define NS_E_CANNOT_CONNECT_TO_PROXY     _HRESULT_TYPEDEF_(0xC00D2EEEL)

//
// MessageId: NS_E_SERVER_DNS_TIMEOUT
//
// MessageText:
//
// Unable to locate the media server. The operation timed out.%0
//
#define NS_E_SERVER_DNS_TIMEOUT          _HRESULT_TYPEDEF_(0xC00D2EEFL)

//
// MessageId: NS_E_PROXY_DNS_TIMEOUT
//
// MessageText:
//
// Unable to locate the proxy server. The operation timed out.%0
//
#define NS_E_PROXY_DNS_TIMEOUT           _HRESULT_TYPEDEF_(0xC00D2EF0L)

//
// MessageId: NS_E_CLOSED_ON_SUSPEND
//
// MessageText:
//
// Media closed because Windows was shut down.%0
//
#define NS_E_CLOSED_ON_SUSPEND           _HRESULT_TYPEDEF_(0xC00D2EF1L)

//
// MessageId: NS_E_CANNOT_READ_PLAYLIST_FROM_MEDIASERVER
//
// MessageText:
//
// Unable to read the contents of a playlist file from a media server.%0
//
#define NS_E_CANNOT_READ_PLAYLIST_FROM_MEDIASERVER _HRESULT_TYPEDEF_(0xC00D2EF2L)

//
// MessageId: NS_E_SESSION_NOT_FOUND
//
// MessageText:
//
// Session not found.%0
//
#define NS_E_SESSION_NOT_FOUND           _HRESULT_TYPEDEF_(0xC00D2EF3L)

//
// MessageId: NS_E_REQUIRE_STREAMING_CLIENT
//
// MessageText:
//
// Content requires a streaming media client.%0
//
#define NS_E_REQUIRE_STREAMING_CLIENT    _HRESULT_TYPEDEF_(0xC00D2EF4L)

//
// MessageId: NS_E_PLAYLIST_ENTRY_HAS_CHANGED
//
// MessageText:
//
// A command applies to a previous playlist entry.%0
//
#define NS_E_PLAYLIST_ENTRY_HAS_CHANGED  _HRESULT_TYPEDEF_(0xC00D2EF5L)

//
// MessageId: NS_E_PROXY_ACCESSDENIED
//
// MessageText:
//
// The proxy server is denying access.  The username and/or password might be incorrect.%0
//
#define NS_E_PROXY_ACCESSDENIED          _HRESULT_TYPEDEF_(0xC00D2EF6L)

//
// MessageId: NS_E_PROXY_SOURCE_ACCESSDENIED
//
// MessageText:
//
// The proxy could not provide valid authentication credentials to the media server.%0
//
#define NS_E_PROXY_SOURCE_ACCESSDENIED   _HRESULT_TYPEDEF_(0xC00D2EF7L)

//
// MessageId: NS_E_NETWORK_SINK_WRITE
//
// MessageText:
//
// The network sink failed to write data to the network.%0
//
#define NS_E_NETWORK_SINK_WRITE          _HRESULT_TYPEDEF_(0xC00D2EF8L)

//
// MessageId: NS_E_FIREWALL
//
// MessageText:
//
// Packets are not being received from the server. The packets might be blocked by a filtering device, such as a network firewall.%0
//
#define NS_E_FIREWALL                    _HRESULT_TYPEDEF_(0xC00D2EF9L)

//
// MessageId: NS_E_MMS_NOT_SUPPORTED
//
// MessageText:
//
// The MMS protocol is not supported. Please use HTTP or RTSP to connect to the Windows Media stream.%0
//
#define NS_E_MMS_NOT_SUPPORTED           _HRESULT_TYPEDEF_(0xC00D2EFAL)

//
// MessageId: NS_E_SERVER_ACCESSDENIED
//
// MessageText:
//
// The Windows Media server is denying access.  The username and/or password might be incorrect.%0
//
#define NS_E_SERVER_ACCESSDENIED         _HRESULT_TYPEDEF_(0xC00D2EFBL)

//
// MessageId: NS_E_RESOURCE_GONE
//
// MessageText:
//
// The Publishing Point or file on the Windows Media Server is no longer available.%0
//
#define NS_E_RESOURCE_GONE               _HRESULT_TYPEDEF_(0xC00D2EFCL)

//
// MessageId: NS_E_NO_EXISTING_PACKETIZER
//
// MessageText:
//
// There is no existing packetizer plugin for a stream.%0
//
#define NS_E_NO_EXISTING_PACKETIZER      _HRESULT_TYPEDEF_(0xC00D2EFDL)

//
// MessageId: NS_E_BAD_SYNTAX_IN_SERVER_RESPONSE
//
// MessageText:
//
// The response from the media server could not be understood. This might be caused by an incompatible proxy server or media server.%0
//
#define NS_E_BAD_SYNTAX_IN_SERVER_RESPONSE _HRESULT_TYPEDEF_(0xC00D2EFEL)

//
// MessageId: NS_I_RECONNECTED
//
// MessageText:
//
// The client is reconnected.%0
//
#define NS_I_RECONNECTED                 _HRESULT_TYPEDEF_(0x400D2EFFL)

//
// MessageId: NS_E_RESET_SOCKET_CONNECTION
//
// MessageText:
//
// The Windows Media Server reset the network connection.%0
//
#define NS_E_RESET_SOCKET_CONNECTION     _HRESULT_TYPEDEF_(0xC00D2F00L)

//
// MessageId: NS_I_NOLOG_STOP
//
// MessageText:
//
// Forcing a switch to a pending header on start.%0
//
#define NS_I_NOLOG_STOP                  _HRESULT_TYPEDEF_(0x400D2F01L)

//
// MessageId: NS_E_TOO_MANY_HOPS
//
// MessageText:
//
// The request could not reach the media server (too many hops).%0
//
#define NS_E_TOO_MANY_HOPS               _HRESULT_TYPEDEF_(0xC00D2F02L)

//
// MessageId: NS_I_EXISTING_PACKETIZER
//
// MessageText:
//
// There is already an existing packetizer plugin for the stream.%0
//
#define NS_I_EXISTING_PACKETIZER         _HRESULT_TYPEDEF_(0x400D2F03L)

//
// MessageId: NS_I_MANUAL_PROXY
//
// MessageText:
//
// The proxy setting is manual.%0
//
#define NS_I_MANUAL_PROXY                _HRESULT_TYPEDEF_(0x400D2F04L)

//
// MessageId: NS_E_TOO_MUCH_DATA_FROM_SERVER
//
// MessageText:
//
// The server is sending too much data. The connection has been terminated.%0
//
#define NS_E_TOO_MUCH_DATA_FROM_SERVER   _HRESULT_TYPEDEF_(0xC00D2F05L)

//
// MessageId: NS_E_CONNECT_TIMEOUT
//
// MessageText:
//
// It was not possible to establish a connection to the media server in a timely manner. The media server may be down for maintenance, or it may be necessary to use a proxy server to access this media server.%0
//
#define NS_E_CONNECT_TIMEOUT             _HRESULT_TYPEDEF_(0xC00D2F06L)

//
// MessageId: NS_E_PROXY_CONNECT_TIMEOUT
//
// MessageText:
//
// It was not possible to establish a connection to the proxy server in a timely manner. Please check your proxy server configuration.%0
//
#define NS_E_PROXY_CONNECT_TIMEOUT       _HRESULT_TYPEDEF_(0xC00D2F07L)

//
// MessageId: NS_E_SESSION_INVALID
//
// MessageText:
//
// Session not found.%0
//
#define NS_E_SESSION_INVALID             _HRESULT_TYPEDEF_(0xC00D2F08L)

//
// MessageId: NS_S_EOSRECEDING
//
// MessageText:
//
// EOS hit during rewinding.%0
//
#define NS_S_EOSRECEDING                 _HRESULT_TYPEDEF_(0x000D2F09L)

//
// MessageId: NS_E_PACKETSINK_UNKNOWN_FEC_STREAM
//
// MessageText:
//
// Unknown packet sink stream.%0
//
#define NS_E_PACKETSINK_UNKNOWN_FEC_STREAM _HRESULT_TYPEDEF_(0xC00D2F0AL)

//
// MessageId: NS_E_PUSH_CANNOTCONNECT
//
// MessageText:
//
// Unable to establish a connection to the server. Ensure Windows Media Services is started and the HTTP Server control protocol is properly enabled.%0
//
#define NS_E_PUSH_CANNOTCONNECT          _HRESULT_TYPEDEF_(0xC00D2F0BL)

//
// MessageId: NS_E_INCOMPATIBLE_PUSH_SERVER
//
// MessageText:
//
// The Server service that received the HTTP push request is not a compatible version of Windows Media Services (WMS).  This error may indicate the push request was received by IIS instead of WMS.  Ensure WMS is started and has the HTTP Server control protocol properly enabled and try again.%0
//
#define NS_E_INCOMPATIBLE_PUSH_SERVER    _HRESULT_TYPEDEF_(0xC00D2F0CL)

//
// MessageId: NS_S_CHANGENOTICE
//
// MessageText:
//
// Internal.%0
//
#define NS_S_CHANGENOTICE                _HRESULT_TYPEDEF_(0x000D2F0DL)


/////////////////////////////////////////////////////////////////////////
//
// Windows Media Client Media Services
//
// IdRange = 13000..13999 (0x32C8-0x36AF)
/////////////////////////////////////////////////////////////////////////
//
// MessageId: NS_E_END_OF_PLAYLIST
//
// MessageText:
//
// The playlist has reached its end.%0
//
#define NS_E_END_OF_PLAYLIST             _HRESULT_TYPEDEF_(0xC00D32C8L)

//
// MessageId: NS_E_USE_FILE_SOURCE
//
// MessageText:
//
// Use file source.%0
//
#define NS_E_USE_FILE_SOURCE             _HRESULT_TYPEDEF_(0xC00D32C9L)

//
// MessageId: NS_E_PROPERTY_NOT_FOUND
//
// MessageText:
//
// The property was not found.%0
//
#define NS_E_PROPERTY_NOT_FOUND          _HRESULT_TYPEDEF_(0xC00D32CAL)

//
// MessageId: NS_E_PROPERTY_READ_ONLY
//
// MessageText:
//
// The property is read only.%0
//
#define NS_E_PROPERTY_READ_ONLY          _HRESULT_TYPEDEF_(0xC00D32CCL)

//
// MessageId: NS_E_TABLE_KEY_NOT_FOUND
//
// MessageText:
//
// The table key was not found.%0
//
#define NS_E_TABLE_KEY_NOT_FOUND         _HRESULT_TYPEDEF_(0xC00D32CDL)

//
// MessageId: NS_E_INVALID_QUERY_OPERATOR
//
// MessageText:
//
// Invalid query operator.%0
//
#define NS_E_INVALID_QUERY_OPERATOR      _HRESULT_TYPEDEF_(0xC00D32CFL)

//
// MessageId: NS_E_INVALID_QUERY_PROPERTY
//
// MessageText:
//
// Invalid query property.%0
//
#define NS_E_INVALID_QUERY_PROPERTY      _HRESULT_TYPEDEF_(0xC00D32D0L)

//
// MessageId: NS_E_PROPERTY_NOT_SUPPORTED
//
// MessageText:
//
// The property is not supported.%0
//
#define NS_E_PROPERTY_NOT_SUPPORTED      _HRESULT_TYPEDEF_(0xC00D32D2L)

//
// MessageId: NS_E_SCHEMA_CLASSIFY_FAILURE
//
// MessageText:
//
// Schema classification failure.%0
//
#define NS_E_SCHEMA_CLASSIFY_FAILURE     _HRESULT_TYPEDEF_(0xC00D32D4L)

//
// MessageId: NS_E_METADATA_FORMAT_NOT_SUPPORTED
//
// MessageText:
//
// The metadata format is not supported.%0
//
#define NS_E_METADATA_FORMAT_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D32D5L)

//
// MessageId: NS_E_METADATA_NO_EDITING_CAPABILITY
//
// MessageText:
//
// Cannot edit the metadata.%0
//
#define NS_E_METADATA_NO_EDITING_CAPABILITY _HRESULT_TYPEDEF_(0xC00D32D6L)

//
// MessageId: NS_E_METADATA_CANNOT_SET_LOCALE
//
// MessageText:
//
// Cannot set the locale id.%0
//
#define NS_E_METADATA_CANNOT_SET_LOCALE  _HRESULT_TYPEDEF_(0xC00D32D7L)

//
// MessageId: NS_E_METADATA_LANGUAGE_NOT_SUPORTED
//
// MessageText:
//
// The language is not supported in the format.%0
//
#define NS_E_METADATA_LANGUAGE_NOT_SUPORTED _HRESULT_TYPEDEF_(0xC00D32D8L)

//
// MessageId: NS_E_METADATA_NO_RFC1766_NAME_FOR_LOCALE
//
// MessageText:
//
// There is no RFC1766 name translation for the supplied locale id.%0
//
#define NS_E_METADATA_NO_RFC1766_NAME_FOR_LOCALE _HRESULT_TYPEDEF_(0xC00D32D9L)

//
// MessageId: NS_E_METADATA_NOT_AVAILABLE
//
// MessageText:
//
// The metadata (or metadata item) is not available.%0
//
#define NS_E_METADATA_NOT_AVAILABLE      _HRESULT_TYPEDEF_(0xC00D32DAL)

//
// MessageId: NS_E_METADATA_CACHE_DATA_NOT_AVAILABLE
//
// MessageText:
//
// The cached metadata (or metadata item) is not available.%0
//
#define NS_E_METADATA_CACHE_DATA_NOT_AVAILABLE _HRESULT_TYPEDEF_(0xC00D32DBL)

//
// MessageId: NS_E_METADATA_INVALID_DOCUMENT_TYPE
//
// MessageText:
//
// The metadata document is invalid.%0
//
#define NS_E_METADATA_INVALID_DOCUMENT_TYPE _HRESULT_TYPEDEF_(0xC00D32DCL)

//
// MessageId: NS_E_METADATA_IDENTIFIER_NOT_AVAILABLE
//
// MessageText:
//
// The metadata content identifier is not available.%0
//
#define NS_E_METADATA_IDENTIFIER_NOT_AVAILABLE _HRESULT_TYPEDEF_(0xC00D32DDL)

//
// MessageId: NS_E_METADATA_CANNOT_RETRIEVE_FROM_OFFLINE_CACHE
//
// MessageText:
//
// Cannot retrieve metadata from the offline metadata cache.%0
//
#define NS_E_METADATA_CANNOT_RETRIEVE_FROM_OFFLINE_CACHE _HRESULT_TYPEDEF_(0xC00D32DEL)


#endif // _NSERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\nspapip.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    nspapip.h

Abstract:

    Internel Name Space Provider API prototypes and manifests.  This
    header file should only be included by name space providers.  NSPAPI
    users should include only nspapi.h See the "Windows NT NameSpace
    Provider Specification" document for details.

Environment:

    User Mode -Win32

Notes:

--*/

#ifndef _NSPAPIP_INCLUDED
#define _NSPAPIP_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

//
// Standard priority values for the dwPriority field of NS_ROUTINE.
//
#define NS_STANDARD_FAST_PRIORITY   (500)
#define NS_MAX_FAST_PRIORITY        (999)
#define NS_STANDARD_PRIORITY        (2000)

//
// Indices for the alpfnFunctions array field of NS_ROUTINE.
//
#define NSPAPI_GET_ADDRESS_BY_NAME  (0x00000000)
#define NSPAPI_GET_SERVICE          (0x00000001)
#define NSPAPI_SET_SERVICE          (0x00000002)

//
// Structures used by the provider interface.
//

typedef
INT
(APIENTRY *LPGET_ADDR_BY_NAME_PROC) (
    IN     LPGUID          lpServiceType,
    IN     LPWSTR          lpServiceName,
    IN     LPDWORD         lpdwProtocols,
    IN     DWORD           dwResolution,
    IN     OUT LPVOID      lpCsaddrBuffer,
    IN     OUT LPDWORD     lpdwBufferLength,
    IN OUT LPWSTR          lpAliasBuffer,
    IN OUT LPDWORD         lpdwAliasBufferLength,
    IN     HANDLE          hCancellationEvent
    );

typedef struct _NS_ROUTINE {
    DWORD        dwFunctionCount;
    LPFN_NSPAPI *alpfnFunctions;
    DWORD        dwNameSpace;
    DWORD        dwPriority;
} NS_ROUTINE, *PNS_ROUTINE, * FAR LPNS_ROUTINE;

typedef
DWORD

(APIENTRY *LPLOAD_NAME_SPACE_PROC) (
    IN OUT LPDWORD         lpdwVersion,
    IN OUT LPNS_ROUTINE    nsrBuffer,
    IN OUT LPDWORD         lpdwBufferLength
    );

typedef
INT
(APIENTRY *LPGET_SERVICE_PROC) (
    IN     LPGUID          lpServiceType,
    IN     LPWSTR          lpServiceName,
    IN     DWORD           dwProperties,
    IN     BOOL            fUnicodeBlob,
    OUT    LPSERVICE_INFO  lpServiceInfo,
    IN OUT LPDWORD         lpdwBufferLen
    );

typedef
DWORD
(APIENTRY *LPSET_SERVICE_PROC) (
    IN     DWORD           dwOperation,
    IN     DWORD           dwFlags,
    IN     BOOL            fUnicodeBlob,
    IN     LPSERVICE_INFO  lpServiceInfo
    );

//
// Internal Functions
//
DWORD
APIENTRY
NPGetService (
    IN     LPGUID          lpServiceType,
    IN     LPWSTR          lpServiceName,
    IN     DWORD           dwProperties,
    IN     BOOL            fUnicodeBlob,
    OUT    LPSERVICE_INFO  lpServiceInfo,
    IN OUT LPDWORD         lpdwBufferLen
    );

DWORD
APIENTRY
NPSetService (
    IN     DWORD           dwOperation,
    IN     DWORD           dwFlags,
    IN     BOOL            fUnicodeBlob,
    IN     LPSERVICE_INFO  lpServiceInfo
    );

INT
APIENTRY
NPGetAddressByName (
    IN     LPGUID          lpServiceType,
    IN     LPWSTR          lpServiceName,
    IN     LPDWORD         lpdwProtocols,
    IN     DWORD           dwResolution,
    IN OUT LPVOID          lpCsaddrBuffer,
    IN OUT LPDWORD         lpdwBufferLength,
    IN OUT LPWSTR          lpAliasBuffer,
    IN OUT LPDWORD         lpdwAliasBufferLength,
    IN     HANDLE          hCancellationEvent
    );

INT
APIENTRY
NPLoadNameSpaces (
    IN OUT LPDWORD         lpdwVersion,
    IN OUT LPNS_ROUTINE    nsrBuffer,
    IN OUT LPDWORD         lpdwBufferLength
    );

#endif  // _NSPAPIP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddbeep.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddbeep.h

Abstract:

    This is the include file that defines all constants and types for
    the beep device.


--*/

#ifndef _NTDDBEEP_
#define _NTDDBEEP_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_BEEP_DEVICE_NAME    "\\Device\\Beep"
#define DD_BEEP_DEVICE_NAME_U L"\\Device\\Beep"

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_BEEP_SET CTL_CODE(FILE_DEVICE_BEEP, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// NtDeviceIoControlFile OutputBuffer record structures for
// IOCTL_BEEP_SET.
//

typedef struct _BEEP_SET_PARAMETERS {
    ULONG Frequency;
    ULONG Duration;
} BEEP_SET_PARAMETERS, *PBEEP_SET_PARAMETERS;

#define BEEP_FREQUENCY_MINIMUM 0x25
#define BEEP_FREQUENCY_MAXIMUM 0x7FFF

#ifdef __cplusplus
}
#endif

#endif // _NTDDBEEP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntdd1394.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntdd1394.h

Abstract:

    Definitions for the 1394 api

Environment:

    Kernel mode only

Revision History:


--*/

#ifndef _NTDD1394_H_
#define _NTDD1394_H_

#if (_MSC_VER >= 1020)
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// registry definitions
//

#define BUS1394_VIRTUAL_DEVICE_LIST_KEY     L"Virtual Device List"
#define BUS1394_LOCAL_HOST_INSTANCE_KEY     L"LOCAL HOST EUI64"


//
// Various definitions
//

#define IOCTL_IEEE1394_API_REQUEST                  CTL_CODE( \
                                                FILE_DEVICE_UNKNOWN, \
                                                0x100, \
                                                METHOD_BUFFERED, \
                                                FILE_ANY_ACCESS \
                                                )

//
// IEEE 1394 Sbp2 Request packet.  It is how other
// device drivers communicate with the 1sbp2 trasnport.
//

typedef struct _IEEE1394_VDEV_PNP_REQUEST{

    ULONG fulFlags;
    ULONG Reserved;
    ULARGE_INTEGER InstanceId;
    UCHAR DeviceId;

} IEEE1394_VDEV_PNP_REQUEST,*PIEEE1394_VDEV_PNP_REQUEST;


typedef struct _IEEE1394_API_REQUEST {

    //
    // Holds the zero based Function number that corresponds to the request
    // that device drivers are asking the sbp2 port driver to carry out.
    //

    ULONG RequestNumber;

    //
    // Holds Flags that may be unique to this particular operation
    //

    ULONG Flags;

    //
    // Holds the structures used in performing the various 1394 APIs
    //

    union {

        IEEE1394_VDEV_PNP_REQUEST AddVirtualDevice;
        IEEE1394_VDEV_PNP_REQUEST RemoveVirtualDevice;

#if(_WIN32_WINNT <= _WIN32_WINNT_WIN2K) // available in Win2K and below
        struct {

            ULONG fulFlags;
            ULONG fulDesiredAccess;
            ULARGE_INTEGER DeviceEUI;

        } DeviceAccessTransfer;
#endif

    } u;

} IEEE1394_API_REQUEST, *PIEEE1394_API_REQUEST;

//
// Request Number
//

#define IEEE1394_API_ADD_VIRTUAL_DEVICE             0x00000001
#define IEEE1394_API_REMOVE_VIRTUAL_DEVICE          0x00000002
#if(_WIN32_WINNT <= _WIN32_WINNT_WIN2K) // available in Win2K and below
#define IEEE1394_API_DEVICE_ACCESS_TRANSFER         0x00000003
#define IEEE1394_API_SET_LOCAL_NODE_PROPERTIES      0x00000004
#endif

//
// flags for the add/remove requests
//

#define IEEE1394_REQUEST_FLAG_UNICODE       0x00000001
//#if(_WIN32_WINNT >= _WIN32_WINNT_WINXP) // available in WinXP and above
#define IEEE1394_REQUEST_FLAG_PERSISTENT    0x00000002
#define IEEE1394_REQUEST_FLAG_USE_LOCAL_HOST_EUI        0x00000004
//#endif

//
// definitions for the access/ownership 1394 scheme
//
#if(_WIN32_WINNT <= _WIN32_WINNT_WIN2K) // available in Win2K and below
//
// GUID used to register for PnP notifications on access status changes
//
         
static const GUID IEEE1394_API_NOTIFICATION_EVENT = 
{ 0xA8E0BA12, 0x4ACF, 0x4278, { 0x87, 0x78, 0xED, 0x7F, 0x28, 0xF2, 0x73, 0xAA } };


typedef struct _IEEE1394_NOTIFICATION_DATA {

    ULONG Version;
    ULONG BusGeneration;
    ULONG Type;
    ULONG Flags;

    union {

        struct {

            ULONG fulFlags;
            ULONG AccessFlags;
            ULARGE_INTEGER RemoteNodeEUI;

        } AccessChange;

        struct {

            ULONG BusResetFlags;

        } BusReset;

    } u;

} IEEE1394_NOTIFICATION_DATA, *PIEEE1394_NOTIFICATION_DATA;

//
// Type definitions
//

#define IEEE1394API_NOTIFICATION_DEVICE_ACCESS    0x00000001
#define IEEE1394API_NOTIFICATION_BUS_RESET        0x00000002

//
// AccessChange.AccessFlags field
//

#define IEEE1394API_DEVICE_OWNERSHIP_LOCAL_NODE         0x00000001
#define IEEE1394API_RESOURCE_OWNERSHIP_LOCAL_NODE       0x00000002

#define IEEE1394API_DEVICE_OWNERSHIP_REMOTE_NODE        0x00000004
#define IEEE1394API_RESOURCE_OWNERSHIP_REMOTE_NODE      0x00000008

#define IEEE1394API_ACCESS_SHARED_READ                  0x00000010
#define IEEE1394API_ACCESS_SHARED_WRITE                 0x00000020
#define IEEE1394API_ACCESS_EXCLUSIVE                    0x00000040

//
// AccessChange.fulFlags field
//

#define IEEE1394API_REMOTE_ACCESS_TRANSFER_REQUEST      0x00000001

//
// BusReset.BusResetFlags
//

#define IEEE1394API_BUS_RESET_LOCAL_NODE_IS_ROOT       0x00000001
#define IEEE1394API_BUS_RESET_LOCAL_NODE_IS_IRM        0x00000002
#define IEEE1394API_BUS_RESET_LOCAL_NODE_INITIATED     0x00000004

#endif

#ifdef __cplusplus
}
#endif

#endif      // _NTDD1394_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddcdvd.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddcdvd.h

Abstract:

    This module contains structures and definitions
    associated with DVD ioctls.

    This module is used in conjunction with ntddcdrm.h which contains the
    cdrom specific ioctls which will work on CDVD drives


--*/

// begin_winioctl

#ifndef _NTDDCDVD_
#define _NTDDCDVD_
#pragma warning(push)
#pragma warning(disable:4200) // zero-sized array
#pragma warning(disable:4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable:4214) // bitfield other than int

#if _MSC_VER > 1000
#pragma once
#endif

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_DVD_BASE                 FILE_DEVICE_DVD

//
// CDVD Device Control Functions
//
// Warning: Ioctls from 200 through 300 are used for the old common class
// driver ioctls and should not be used for device specific functionality
//

//
// CSS-related IOCTLs
//

#define IOCTL_DVD_START_SESSION     CTL_CODE(IOCTL_DVD_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_READ_KEY          CTL_CODE(IOCTL_DVD_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY          CTL_CODE(IOCTL_DVD_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_END_SESSION       CTL_CODE(IOCTL_DVD_BASE, 0x0403, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SET_READ_AHEAD    CTL_CODE(IOCTL_DVD_BASE, 0x0404, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_GET_REGION        CTL_CODE(IOCTL_DVD_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DVD_SEND_KEY2         CTL_CODE(IOCTL_DVD_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// AACS-related IOCTLs
//
#define IOCTL_AACS_READ_MEDIA_KEY_BLOCK_SIZE  CTL_CODE(IOCTL_DVD_BASE, 0x430, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AACS_READ_MEDIA_KEY_BLOCK       CTL_CODE(IOCTL_DVD_BASE, 0x431, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AACS_START_SESSION              CTL_CODE(IOCTL_DVD_BASE, 0x432, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AACS_END_SESSION                CTL_CODE(IOCTL_DVD_BASE, 0x433, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AACS_SEND_CERTIFICATE           CTL_CODE(IOCTL_DVD_BASE, 0x434, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AACS_GET_CERTIFICATE            CTL_CODE(IOCTL_DVD_BASE, 0x435, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AACS_GET_CHALLENGE_KEY          CTL_CODE(IOCTL_DVD_BASE, 0x436, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AACS_SEND_CHALLENGE_KEY         CTL_CODE(IOCTL_DVD_BASE, 0x437, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AACS_READ_VOLUME_ID             CTL_CODE(IOCTL_DVD_BASE, 0x438, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AACS_READ_SERIAL_NUMBER         CTL_CODE(IOCTL_DVD_BASE, 0x439, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AACS_READ_MEDIA_ID              CTL_CODE(IOCTL_DVD_BASE, 0x43A, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AACS_READ_BINDING_NONCE         CTL_CODE(IOCTL_DVD_BASE, 0x43B, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_AACS_GENERATE_BINDING_NONCE     CTL_CODE(IOCTL_DVD_BASE, 0x43C, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// DVD Structure queries
//

#define IOCTL_DVD_READ_STRUCTURE    CTL_CODE(IOCTL_DVD_BASE, 0x0450, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// The following file contains the IOCTL_STORAGE class ioctl definitions
//

#define IOCTL_STORAGE_SET_READ_AHEAD        CTL_CODE(IOCTL_STORAGE_BASE, 0x0100, METHOD_BUFFERED, FILE_READ_ACCESS)

// end_winioctl

#include <ntddstor.h>

// begin_winioctl


#ifdef __cplusplus
extern "C" {
#endif


typedef enum {
    DvdChallengeKey = 0x01,
    DvdBusKey1,
    DvdBusKey2,
    DvdTitleKey,
    DvdAsf,
    DvdSetRpcKey = 0x6,
    DvdGetRpcKey = 0x8,
    DvdDiskKey = 0x80,
    DvdInvalidateAGID = 0x3f
} DVD_KEY_TYPE;

typedef __typefix(LONG) __range(-1,3) ULONG DVD_SESSION_ID, *PDVD_SESSION_ID;

#include <pshpack1.h>
typedef struct _DVD_COPY_PROTECT_KEY {
    ULONG KeyLength;
    DVD_SESSION_ID SessionId;
    DVD_KEY_TYPE KeyType;
    ULONG KeyFlags;
    union {
        HANDLE FileHandle;
        LARGE_INTEGER TitleOffset;
    } Parameters;
    UCHAR KeyData[0];
} DVD_COPY_PROTECT_KEY, *PDVD_COPY_PROTECT_KEY;
#include <poppack.h>

//
// Predefined (Mt. Fuji) key sizes
// Add sizeof(DVD_COPY_PROTECT_KEY) to get allocation size for
// the full key structure
//

#define DVD_CHALLENGE_KEY_LENGTH    (12 + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_BUS_KEY_LENGTH          (8 + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_TITLE_KEY_LENGTH        (8 + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_DISK_KEY_LENGTH         (2048 + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_RPC_KEY_LENGTH          (sizeof(DVD_RPC_KEY) + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_SET_RPC_KEY_LENGTH      (sizeof(DVD_SET_RPC_KEY) + sizeof(DVD_COPY_PROTECT_KEY))
#define DVD_ASF_LENGTH              (sizeof(DVD_ASF) + sizeof(DVD_COPY_PROTECT_KEY))

//
// Used with IOCTL_DVD_END_SESSION to end all DVD sessions at once
//

#define DVD_END_ALL_SESSIONS ((DVD_SESSION_ID) 0xffffffff)

//
// CGMS Copy Protection Flags
//

#define DVD_CGMS_RESERVED_MASK      0x00000078

#define DVD_CGMS_COPY_PROTECT_MASK  0x00000018
#define DVD_CGMS_COPY_PERMITTED     0x00000000
#define DVD_CGMS_COPY_ONCE          0x00000010
#define DVD_CGMS_NO_COPY            0x00000018

#define DVD_COPYRIGHT_MASK          0x00000040
#define DVD_NOT_COPYRIGHTED         0x00000000
#define DVD_COPYRIGHTED             0x00000040

#define DVD_SECTOR_PROTECT_MASK     0x00000020
#define DVD_SECTOR_NOT_PROTECTED    0x00000000
#define DVD_SECTOR_PROTECTED        0x00000020

/*++

IOCTL_STORAGE_SET_READ_AHEAD

Requests that the storage device skip to TargetAddress once it has run across
TriggerAddress during the course of it's read-ahead caching operations.

Input:

    a STORAGE_SET_READ_AHEAD structure which contains:
        * the trigger address
        * the target address

Output:

    none

--*/

#include <pshpack1.h>
typedef struct _STORAGE_SET_READ_AHEAD {
    LARGE_INTEGER TriggerAddress;
    LARGE_INTEGER TargetAddress;
} STORAGE_SET_READ_AHEAD, *PSTORAGE_SET_READ_AHEAD;
#include <poppack.h>

/*++

IOCTL_DVD_READ_STRUCTURE

Issues a READ_DVD_STRUCTURE command to the drive.

Input:

    a DVD_READ_STRUCTURE describing what information is requested

Output:

    a DVD Layer Descriptor as defined below

--*/

typedef enum DVD_STRUCTURE_FORMAT {
    DvdPhysicalDescriptor,     // 0x00
    DvdCopyrightDescriptor,    // 0x01
    DvdDiskKeyDescriptor,      // 0x02
    DvdBCADescriptor,          // 0x03
    DvdManufacturerDescriptor, // 0x04
    DvdMaxDescriptor           // 0x05
} DVD_STRUCTURE_FORMAT, *PDVD_STRUCTURE_FORMAT;

/////////////////////////////////////////////////////////////
// ALL THE FOLLOWING STRUCTURES ARE BYTE-PACKED:
#include <pshpack1.h>

typedef struct DVD_READ_STRUCTURE {
    LARGE_INTEGER BlockByteOffset;
    DVD_STRUCTURE_FORMAT Format;
    DVD_SESSION_ID SessionId;
    UCHAR LayerNumber;
} DVD_READ_STRUCTURE, *PDVD_READ_STRUCTURE;

typedef struct _DVD_DESCRIPTOR_HEADER {
    USHORT Length;
    UCHAR Reserved[2];
#if !defined(__midl)
    UCHAR Data[0];
#endif
} DVD_DESCRIPTOR_HEADER, *PDVD_DESCRIPTOR_HEADER;
C_ASSERT(sizeof(DVD_DESCRIPTOR_HEADER) == 4);

// format 0x00 - DvdPhysicalDescriptor
typedef struct _DVD_LAYER_DESCRIPTOR {
    UCHAR BookVersion : 4;      // in MMC 5 :   Part Version
    UCHAR BookType : 4;         //              Disk Category
    UCHAR MinimumRate : 4;      //              Maximum Rate
    UCHAR DiskSize : 4;
    UCHAR LayerType : 4;
    UCHAR TrackPath : 1;
    UCHAR NumberOfLayers : 2;
    UCHAR Reserved1 : 1;
    UCHAR TrackDensity : 4;
    UCHAR LinearDensity : 4;
    ULONG StartingDataSector;   //              3bytes + 1 zeroed byte
    ULONG EndDataSector;        //              3bytes + 1 zeroed byte
    ULONG EndLayerZeroSector;   //              3bytes + 1 zeroed byte
    UCHAR Reserved5 : 7;
    UCHAR BCAFlag : 1;
    // The large Media Specific field is not declared here to enable stack allocation
} DVD_LAYER_DESCRIPTOR, *PDVD_LAYER_DESCRIPTOR;
C_ASSERT(sizeof(DVD_LAYER_DESCRIPTOR) == 17);
typedef struct _DVD_FULL_LAYER_DESCRIPTOR {
    DVD_LAYER_DESCRIPTOR commonHeader;
    UCHAR MediaSpecific[2031];
} DVD_FULL_LAYER_DESCRIPTOR, *PDVD_FULL_LAYER_DESCRIPTOR;
C_ASSERT(sizeof(DVD_FULL_LAYER_DESCRIPTOR) == 2048);

// format 0x01 - DvdCopyrightDescriptor
typedef struct _DVD_COPYRIGHT_DESCRIPTOR {
    UCHAR CopyrightProtectionType;
    UCHAR RegionManagementInformation;
    USHORT Reserved;
} DVD_COPYRIGHT_DESCRIPTOR, *PDVD_COPYRIGHT_DESCRIPTOR;
C_ASSERT(sizeof(DVD_COPYRIGHT_DESCRIPTOR) == 4);

// format 0x02 - DvdDiskKeyDescriptor
typedef struct _DVD_DISK_KEY_DESCRIPTOR {
    UCHAR DiskKeyData[2048];
} DVD_DISK_KEY_DESCRIPTOR, *PDVD_DISK_KEY_DESCRIPTOR;
C_ASSERT(sizeof(DVD_DISK_KEY_DESCRIPTOR) == 2048);

// format 0x03 - DvdBCADescriptor
typedef struct _DVD_BCA_DESCRIPTOR {
    UCHAR BCAInformation[0];
} DVD_BCA_DESCRIPTOR, *PDVD_BCA_DESCRIPTOR;

// format 0x04 - DvdManufacturerDescriptor
typedef struct _DVD_MANUFACTURER_DESCRIPTOR {
    UCHAR ManufacturingInformation[2048];
} DVD_MANUFACTURER_DESCRIPTOR, *PDVD_MANUFACTURER_DESCRIPTOR;
C_ASSERT(sizeof(DVD_MANUFACTURER_DESCRIPTOR) == 2048);

// format 0x05 - not defined in enum
typedef struct _DVD_COPYRIGHT_MANAGEMENT_DESCRIPTOR {
    union {
        struct {
            UCHAR CopyProtectionMode : 4;
            UCHAR ContentGenerationManagementSystem : 2;
            UCHAR CopyProtectedSector : 1;
            UCHAR CopyProtectedMaterial : 1;
        } Dvdrom;
        struct {
            UCHAR Reserved0001 : 4;
            UCHAR ContentGenerationManagementSystem : 2;
            UCHAR Reserved0002 : 1;
            UCHAR CopyProtectedMaterial : 1;
        } DvdRecordable_Version1;
        struct {
            UCHAR Reserved0003;
        } Dvdram;
        struct {
            UCHAR Reserved0004 : 2;
            UCHAR ADP_TY : 2; // what is this mean?
            UCHAR Reserved0005 : 4;
        } DvdRecordable;
        UCHAR CPR_MAI;
    };
    UCHAR Reserved0[3];
} DVD_COPYRIGHT_MANAGEMENT_DESCRIPTOR, *PDVD_COPYRIGHT_MANAGEMENT_DESCRIPTOR;
C_ASSERT(FIELD_OFFSET(DVD_COPYRIGHT_MANAGEMENT_DESCRIPTOR, Reserved0) == 1);
C_ASSERT(sizeof(DVD_COPYRIGHT_MANAGEMENT_DESCRIPTOR) == 4);

// format 0x06 (media ID) is unstructured in public spec
// format 0x07 (media key block) is unstructured in public spec
// format 0x08 (DVD-RAM DDS) is unstructured in public spec

// format 0x09 - not defined in enum
// This is valid for DVD-RAM and also HD DVD-RAM
typedef struct _DVD_RAM_MEDIUM_STATUS {
    UCHAR Reserved0                 : 1;
    UCHAR PersistentWriteProtect    : 1;
    UCHAR CartridgeWriteProtect     : 1;
    UCHAR MediaSpecificWriteInhibit : 1;
    UCHAR Reserved1          : 2;
    UCHAR CartridgeNotSealed : 1;
    UCHAR MediaInCartridge   : 1;
    UCHAR DiscTypeIdentification;
    UCHAR Reserved2;
    UCHAR MediaSpecificWriteInhibitInformation;
} DVD_RAM_MEDIUM_STATUS, *PDVD_RAM_MEDIUM_STATUS;
C_ASSERT(sizeof(DVD_RAM_MEDIUM_STATUS) == 4);

// format 0x0A - not defined in enum
typedef struct _DVD_RAM_SPARE_AREA_INFORMATION {
    UCHAR FreePrimarySpareSectors[4];
    UCHAR FreeSupplementalSpareSectors[4];
    UCHAR AllocatedSupplementalSpareSectors[4];
} DVD_RAM_SPARE_AREA_INFORMATION, *PDVD_RAM_SPARE_AREA_INFORMATION;
C_ASSERT(sizeof(DVD_RAM_SPARE_AREA_INFORMATION) == 12);

// format 0x0B - not defined in enum
typedef struct _DVD_RAM_RECORDING_TYPE {
    UCHAR Reserved0 : 4;
    UCHAR RealTimeData : 1;
    UCHAR Reserved1 : 3;
    UCHAR Reserved2[3];
} DVD_RAM_RECORDING_TYPE, *PDVD_RAM_RECORDING_TYPE;
C_ASSERT(sizeof(DVD_RAM_RECORDING_TYPE) == 4);

// format 0x0C (RMD in last border-out) is unstructured in public spec
// format 0x0D - not defined in enum
typedef struct _DVD_RECORDING_MANAGEMENT_AREA_DATA {
    UCHAR LastRecordedRMASectorNumber[4];
#if !defined(__midl)
    UCHAR RMDBytes[0];
#endif
} DVD_RECORDING_MANAGEMENT_AREA_DATA, *PDVD_RECORDING_MANAGEMENT_AREA_DATA;
C_ASSERT(sizeof(DVD_RECORDING_MANAGEMENT_AREA_DATA) == 4);

// format 0x0E - not define in enum
typedef struct _DVD_PRERECORDED_INFORMATION {
    UCHAR FieldID_1;
    UCHAR DiscApplicationCode;
    UCHAR DiscPhysicalCode;
    UCHAR LastAddressOfDataRecordableArea[3];
    UCHAR ExtensionCode : 4; // -R for general/authoring v2.0
    UCHAR PartVers1on   : 4; // -R for general/authoring v2.0
    UCHAR Reserved0;
    UCHAR FieldID_2;
    UCHAR OpcSuggestedCode;
    UCHAR WavelengthCode;
    UCHAR WriteStrategyCode[4];
    UCHAR Reserved2;
    UCHAR FieldID_3;
    UCHAR ManufacturerId_3[6];
    UCHAR Reserved3;
    UCHAR FieldID_4;
    UCHAR ManufacturerId_4[6];
    UCHAR Reserved4;
    UCHAR FieldID_5;
    UCHAR ManufacturerId_5[6];
    UCHAR Reserved5;
    UCHAR Reserved99[24];
} DVD_PRERECORDED_INFORMATION, *PDVD_PRERECORDED_INFORMATION;
C_ASSERT(FIELD_OFFSET(DVD_PRERECORDED_INFORMATION, FieldID_2) ==  8);
C_ASSERT(FIELD_OFFSET(DVD_PRERECORDED_INFORMATION, FieldID_3) == 16);
C_ASSERT(FIELD_OFFSET(DVD_PRERECORDED_INFORMATION, FieldID_4) == 24);
C_ASSERT(FIELD_OFFSET(DVD_PRERECORDED_INFORMATION, FieldID_5) == 32);
C_ASSERT(sizeof(DVD_PRERECORDED_INFORMATION) == 64);

// format 0x0F - not defined in enum
typedef struct _DVD_UNIQUE_DISC_IDENTIFIER {
    UCHAR Reserved0[2];
    UCHAR RandomNumber[2];
    UCHAR Year[4];   // ASCII?
    UCHAR Month[2];  // ASCII?
    UCHAR Day[2];    // ASCII?
    UCHAR Hour[2];   // ASCII?
    UCHAR Minute[2]; // ASCII?
    UCHAR Second[2]; // ASCII?
} DVD_UNIQUE_DISC_IDENTIFIER, *PDVD_UNIQUE_DISC_IDENTIFIER;
C_ASSERT(sizeof(DVD_UNIQUE_DISC_IDENTIFIER) == 18);

// format 0x10 - not define in enum - use DVD_LAYER_DESCRIPTOR structure above
// format 0x11 (ADIP information) is unstructured in public spec
// formats 0x12, 0x15 are is unstructured in public spec
// formats 0x13, 0x14, 0x16 through 0x18 are not yet defined

// format 0x19 - not defined in enum
typedef struct _HD_DVD_R_MEDIUM_STATUS {
    UCHAR ExtendedTestZone : 1;
    UCHAR Reserved1 : 7;
    UCHAR NumberOfRemainingRMDsInRDZ;
    UCHAR NumberOfRemainingRMDsInCurrentRMZ[2];
} HD_DVD_R_MEDIUM_STATUS, *PHD_DVD_R_MEDIUM_STATUS;
C_ASSERT(sizeof(HD_DVD_R_MEDIUM_STATUS) == 4);

// format 0x1A (HD DVD-R - Last recorded RMD in the latest R) is unstructured in public spec
// formats 0x1B through 0x1F are not yet defined

// format 0x20 - not define in enum
typedef struct _DVD_DUAL_LAYER_RECORDING_INFORMATION {
    UCHAR Reserved0 : 7;
    UCHAR Layer0SectorsImmutable : 1;
    UCHAR Reserved1[3];
    UCHAR Layer0Sectors[4];
} DVD_DUAL_LAYER_RECORDING_INFORMATION, *PDVD_DUAL_LAYER_RECORDING_INFORMATION;

// format 0x21 - not define in enum
typedef struct _DVD_DUAL_LAYER_MIDDLE_ZONE_START_ADDRESS {
    UCHAR Reserved0 : 7;
    UCHAR InitStatus : 1;
    UCHAR Reserved1[3];
    UCHAR ShiftedMiddleAreaStartAddress[4];
} DVD_DUAL_LAYER_MIDDLE_ZONE_START_ADDRESS, *PDVD_DUAL_LAYER_MIDDLE_ZONE_START_ADDRESS;

// format 0x22 - not define in enum
typedef struct _DVD_DUAL_LAYER_JUMP_INTERVAL_SIZE {
    UCHAR Reserved1[4];
    UCHAR JumpIntervalSize[4];
} DVD_DUAL_LAYER_JUMP_INTERVAL_SIZE, *PDVD_DUAL_LAYER_JUMP_INTERVAL_SIZE;

// format 0x23 - not define in enum
typedef struct _DVD_DUAL_LAYER_MANUAL_LAYER_JUMP {
    UCHAR Reserved1[4];
    UCHAR ManualJumpLayerAddress[4];
} DVD_DUAL_LAYER_MANUAL_LAYER_JUMP, *PDVD_DUAL_LAYER_MANUAL_LAYER_JUMP;

// format 0x24 - not define in enum
typedef struct _DVD_DUAL_LAYER_REMAPPING_INFORMATION {
    UCHAR Reserved1[4];
    UCHAR RemappingAddress[4];
} DVD_DUAL_LAYER_REMAPPING_INFORMATION, *PDVD_DUAL_LAYER_REMAPPING_INFORMATION;

// formats 0x25 through 0x2F are not yet defined

// format 0x30 - not defined in enum (common header)
typedef struct _DVD_DISC_CONTROL_BLOCK_HEADER {
    UCHAR ContentDescriptor[4];
    union {
        struct {
            UCHAR ReservedDoNotUse_UseAsByteInstead_0[3];
            UCHAR RecordingWithinTheUserDataArea      : 1;
            UCHAR ReadingDiscControlBlocks            : 1;
            UCHAR FormattingTheMedium                 : 1;
            UCHAR ModificationOfThisDiscControlBlock  : 1;
            UCHAR ReservedDoNotUse_UseAsByteInstead_1 : 4;
        };
        UCHAR AsByte[4];
    } ProhibitedActions;
    UCHAR VendorId[32]; // actually "non-specified" data
    // UCHAR DCBData[32728];
} DVD_DISC_CONTROL_BLOCK_HEADER, *PDVD_DISC_CONTROL_BLOCK_HEADER;
C_ASSERT(sizeof(DVD_DISC_CONTROL_BLOCK_HEADER) == 40);

// publicly defined DCB types
typedef enum _DISC_CONTROL_BLOCK_TYPE {
    FormattingDiscControlBlock   = 0x46444300, // 'FDC\0'
    WriteInhibitDiscControlBlock = 0x57444300, // 'WDC\0'
    SessionInfoDiscControlBlock  = 0x53444300, // 'SDC\0'
    DiscControlBlockList         = 0xFFFFFFFF
} DISC_CONTROL_BLOCK_TYPE, *PDISC_CONTROL_BLOCK_TYPE;

// format 0x30 - not defined in enum -- Format DCB, not in MMC.

// format 0x30 - not defined in enum -- Write Inhibit DCB
typedef struct _DVD_DISC_CONTROL_BLOCK_WRITE_INHIBIT {
    DVD_DISC_CONTROL_BLOCK_HEADER header;
    UCHAR UpdateCount[4];
    union {
        struct {
            UCHAR ReservedDoNotUse_UseAsByteInstead_0[3];
            UCHAR WriteProtectStatus : 2;
            UCHAR ReservedDoNotUse_UseAsByteInstead_1 : 5;
            UCHAR UpdateRequiresPassword : 1;
        };
        UCHAR AsByte[4];
    } WriteProtectActions;
    UCHAR Reserved0[16];
    UCHAR UpdatePassword[32];
    UCHAR Reserved1[32672];
} DVD_DISC_CONTROL_BLOCK_WRITE_INHIBIT, *PDVD_DISC_CONTROL_BLOCK_WRITE_INHIBIT;
C_ASSERT(sizeof(DVD_DISC_CONTROL_BLOCK_WRITE_INHIBIT) == (16*2048));

// format 0x30 - not defined in enum - Session DCB
typedef struct _DVD_DISC_CONTROL_BLOCK_SESSION_ITEM {
    UCHAR AsByte[16]; // not publicly defined?
} DVD_DISC_CONTROL_BLOCK_SESSION_ITEM, *PDVD_DISC_CONTROL_BLOCK_SESSION_ITEM;
typedef struct _DVD_DISC_CONTROL_BLOCK_SESSION {
    DVD_DISC_CONTROL_BLOCK_HEADER header;
    UCHAR SessionNumber[2];
    UCHAR Reserved0[22];
    UCHAR DiscID[32];
    UCHAR Reserved1[32];
    DVD_DISC_CONTROL_BLOCK_SESSION_ITEM SessionItem[504];
    UCHAR Reserved2[24576]; // 3 Repetitions of bytes 0 through 8191
} DVD_DISC_CONTROL_BLOCK_SESSION, *PDVD_DISC_CONTROL_BLOCK_SESSION;
C_ASSERT(sizeof(DVD_DISC_CONTROL_BLOCK_SESSION) == ((8*1024) * 4));

// format 0x30 - not defined in enum - DCB list
typedef struct _DVD_DISC_CONTROL_BLOCK_LIST_DCB {
    UCHAR DcbIdentifier[4];
} DVD_DISC_CONTROL_BLOCK_LIST_DCB, *PDVD_DISC_CONTROL_BLOCK_LIST_DCB;
typedef struct _DVD_DISC_CONTROL_BLOCK_LIST {
    DVD_DISC_CONTROL_BLOCK_HEADER header;
    UCHAR Reserved0;
    UCHAR ReadabldDCBs;
    UCHAR Reserved1;
    UCHAR WritableDCBs;
#if !defined(__midl)
    DVD_DISC_CONTROL_BLOCK_LIST_DCB Dcbs[0];
#endif
} DVD_DISC_CONTROL_BLOCK_LIST, *PDVD_DISC_CONTROL_BLOCK_LIST;
C_ASSERT(sizeof(DVD_DISC_CONTROL_BLOCK_LIST) == 44);

// format 0x31 (MTA ECC Block) is unstructured in public spec
// formats 0x32 through 0xBF are not yet defined

// format 0xC0 - not defined in enum
typedef struct _DVD_WRITE_PROTECTION_STATUS {
    UCHAR SoftwareWriteProtectUntilPowerdown : 1;
    UCHAR MediaPersistentWriteProtect        : 1;
    UCHAR CartridgeWriteProtect              : 1;
    UCHAR MediaSpecificWriteProtect          : 1;
    UCHAR Reserved0                          : 4;
    UCHAR Reserved1[3];
} DVD_WRITE_PROTECTION_STATUS, *PDVD_WRITE_PROTECTION_STATUS;
C_ASSERT(sizeof(DVD_WRITE_PROTECTION_STATUS) == 4);

// formats 0xC1 through 0x7F are not yet defined
// format 0x80 (AACS volume identifier) is unstructured in public spec
// format 0x81 (Pre-Recorded AACS media serial number) is unstructured in public spec
// format 0x82 (AACS media identifier) is unstructured in public spec
// format 0x83 (AACS media key block) is unstructured in public spec
// formats 0x84 through 0x8F are not yet defined

// format 0x90 - not defined in enum
typedef struct _DVD_LIST_OF_RECOGNIZED_FORMAT_LAYERS_TYPE_CODE {
    UCHAR TypeCodeOfFormatLayer[2];
} DVD_LIST_OF_RECOGNIZED_FORMAT_LAYERS, *PDVD_LIST_OF_RECOGNIZED_FORMAT_LAYERS;
typedef struct _DVD_LIST_OF_RECOGNIZED_FORMAT_LAYERS {
    UCHAR NumberOfRecognizedFormatLayers;
    UCHAR OnlineFormatlayer     : 2;
    UCHAR Reserved1             : 2;
    UCHAR DefaultFormatLayer    : 2;
    UCHAR Reserved2             : 2;
    // DVD_LIST_OF_RECOGNIZED_FORMAT_LAYERS_TYPE_CODE TypeCodes[0];
} DVD_LIST_OF_RECOGNIZED_FORMAT_LAYERS_TYPE_CODE, *PDVD_LIST_OF_RECOGNIZED_FORMAT_LAYERS_TYPE_CODE;
C_ASSERT(sizeof(DVD_LIST_OF_RECOGNIZED_FORMAT_LAYERS_TYPE_CODE) == 2);

// formats 0x91 through 0xFE are not yet defined

// format 0xFF - not defined in enum
typedef struct _DVD_STRUCTURE_LIST_ENTRY {
    UCHAR FormatCode;
    UCHAR Reserved0 : 6;
    UCHAR Readable  : 1;
    UCHAR Sendable  : 1;
    UCHAR FormatLength[2];
} DVD_STRUCTURE_LIST_ENTRY, *PDVD_STRUCTURE_LIST_ENTRY;
C_ASSERT(sizeof(DVD_STRUCTURE_LIST_ENTRY) == 4);

// BD Disc Structures

// format 0x00 (BD Disc Information) is unstructured in public spec
// format 0x08 (BD Disc Definition Structure) is unstructured in public spec
// format 0x09 (BD Cartridge Status) is identical to DVD_RAM_MEDIUM_STATUS but
// only CartridgeWriteProtect, CartridgeNotSealed and MediaInCartridge are
// valid. Other fields are reserved.

// format 0x09 (BD Spare Area Information) - not defined in enum
typedef struct _DVD_BD_SPARE_AREA_INFORMATION {
    UCHAR Reserved1[4];
    UCHAR NumberOfFreeSpareBlocks[4];
    UCHAR NumberOfAllocatedSpareBlocks[4];
} DVD_BD_SPARE_AREA_INFORMATION, *PDVD_BD_SPARE_AREA_INFORMATION;
C_ASSERT(sizeof(DVD_BD_SPARE_AREA_INFORMATION) == 12);

// format 0x12 (BD Raw Defect List). DFL is not fully defined in public spec

// format 0x30 (BD Physical Access Control).
typedef struct _BD_PAC_HEADER {
    UCHAR PACId[3];
    UCHAR PACFormatNumber;
    UCHAR PACUpdateCount[4];
    UCHAR UnknownPACRules[4];
    UCHAR UnkownPACEntireDiscFlag;
    UCHAR Reserved1[2];
    UCHAR NumberOfSegments;
    UCHAR Segments[8][32];
    UCHAR Reserved2[112];
} BD_PAC_HEADER, *PBD_PAC_HEADER;
C_ASSERT(sizeof(BD_PAC_HEADER) == 384);

// Primary PAC is unstructured in public spec

// Disc Write Protect PAC
typedef struct _BD_DISC_WRITE_PROTECT_PAC {
    BD_PAC_HEADER Header;
    UCHAR KnownPACEntireDiscFlags;
    UCHAR Reserved1[3];
    UCHAR WriteProtectControlByte;
    UCHAR Reserved2[7];
    UCHAR WriteProtectPassword[32];
} BD_DISC_WRITE_PROTECT_PAC, *PBD_DISC_WRITE_PROTECT_PAC;
C_ASSERT(sizeof(BD_DISC_WRITE_PROTECT_PAC) == 428);


typedef struct _DVD_RPC_KEY {
    UCHAR UserResetsAvailable:3;
    UCHAR ManufacturerResetsAvailable:3;
    UCHAR TypeCode:2;
    UCHAR RegionMask;
    UCHAR RpcScheme;
    UCHAR Reserved02;
} DVD_RPC_KEY, * PDVD_RPC_KEY;
C_ASSERT(sizeof(DVD_RPC_KEY) == 4);

typedef struct _DVD_SET_RPC_KEY {
    UCHAR PreferredDriveRegionCode;
    UCHAR Reserved[3];
} DVD_SET_RPC_KEY, * PDVD_SET_RPC_KEY;
C_ASSERT(sizeof(DVD_SET_RPC_KEY) == 4);

typedef struct _DVD_ASF { // Authentication Success Flag
    UCHAR Reserved0[3];
    UCHAR SuccessFlag:1;
    UCHAR Reserved1:7;
} DVD_ASF, * PDVD_ASF;
C_ASSERT(sizeof(DVD_ASF) == 4);

typedef struct _DVD_REGION {
     UCHAR CopySystem;
     UCHAR RegionData;                      // current media region (not playable when set)
     UCHAR SystemRegion;                    // current drive region (playable when set)
     UCHAR ResetCount;                      // number of resets available
} DVD_REGION, *PDVD_REGION;
C_ASSERT(sizeof(DVD_REGION) == 4);

// ALL THE ABOVE STRUCTURES ARE BYTE-PACKED:
/////////////////////////////////////////////////////////////
#include <poppack.h>


#ifdef __cplusplus
}
#endif


/////////////////////////////////////////////////////////////
// AACS-related structures
// (mostly opaque data, but useful for allocation)

// The AACS layer number refers to the layer of the disc a structure
// is read from.  This can only be a single byte in the CDB, so limit
// the value to 0..255.
typedef __range(0,255)       ULONG  AACS_LAYER_NUMBER, *PAACS_LAYER_NUMBER;
typedef __range(0,255) const ULONG CAACS_LAYER_NUMBER, *PCAACS_LAYER_NUMBER;


// The AACS Certificate (opaque data structure) is used to validate
// the host to the logical unit, as well as to validate the logical
// unit to the host.
typedef struct _AACS_CERTIFICATE {
    UCHAR Nonce[20];
    UCHAR Certificate[92];
} AACS_CERTIFICATE, *PAACS_CERTIFICATE;
typedef const AACS_CERTIFICATE   CAACS_CERTIFICATE;
typedef const AACS_CERTIFICATE *PCAACS_CERTIFICATE;
C_ASSERT(sizeof(AACS_CERTIFICATE) == 112);

// The AACS challenge key (opaque data structure) is used to setup
// a shared bus key for AACS-protected structure transfer.
typedef struct _AACS_CHALLENGE_KEY {
    UCHAR EllipticCurvePoint[40];
    UCHAR Signature[40];
} AACS_CHALLENGE_KEY, *PAACS_CHALLENGE_KEY;
typedef const AACS_CHALLENGE_KEY   CAACS_CHALLENGE_KEY;
typedef const AACS_CHALLENGE_KEY *PCAACS_CHALLENGE_KEY;
C_ASSERT(sizeof(AACS_CHALLENGE_KEY) == 80);

// The VolumeID is one of the unique identifiers on AACS protected media
typedef struct _AACS_VOLUME_ID {
    UCHAR VolumeID[16];
    UCHAR MAC[16]; // MessageAuthenticationCode
} AACS_VOLUME_ID, *PAACS_VOLUME_ID;
typedef const AACS_VOLUME_ID   CAACS_VOLUME_ID;
typedef const AACS_VOLUME_ID *PCAACS_VOLUME_ID;
C_ASSERT(sizeof(AACS_VOLUME_ID) == 32);

// The prerecorded Serial Number is one of the unique identifiers on AACS protected media
typedef struct _AACS_SERIAL_NUMBER {
    UCHAR PrerecordedSerialNumber[16];
    UCHAR MAC[16]; // MessageAuthenticationCode
} AACS_SERIAL_NUMBER, *PAACS_SERIAL_NUMBER;
typedef const AACS_SERIAL_NUMBER   CAACS_SERIAL_NUMBER;
typedef const AACS_SERIAL_NUMBER *PCAACS_SERIAL_NUMBER;
C_ASSERT(sizeof(AACS_SERIAL_NUMBER) == 32);

// The MediaID is one of the unique identifiers on AACS protected media
typedef struct _AACS_MEDIA_ID {
    UCHAR MediaID[16];
    UCHAR MAC[16]; // MessageAuthenticationCode
} AACS_MEDIA_ID, *PAACS_MEDIA_ID;
typedef const AACS_MEDIA_ID   CAACS_MEDIA_ID;
typedef const AACS_MEDIA_ID *PCAACS_MEDIA_ID;
C_ASSERT(sizeof(AACS_MEDIA_ID) == 32);

// When sending a certificate or challenge key, need to wrap
// the data structure with a DVD_SESSION_ID.
typedef struct _AACS_SEND_CERTIFICATE {
    DVD_SESSION_ID SessionId;
    AACS_CERTIFICATE Certificate;
} AACS_SEND_CERTIFICATE, *PAACS_SEND_CERTIFICATE;
typedef const AACS_SEND_CERTIFICATE   CAACS_SEND_CERTIFICATE;
typedef const AACS_SEND_CERTIFICATE *PCAACS_SEND_CERTIFICATE;

// When sending a certificate or challenge key, need to wrap
// the data structure with a DVD_SESSION_ID.
typedef struct _AACS_SEND_CHALLENGE_KEY {
    DVD_SESSION_ID SessionId;
    AACS_CHALLENGE_KEY ChallengeKey;
} AACS_SEND_CHALLENGE_KEY, *PAACS_SEND_CHALLENGE_KEY;
typedef const AACS_SEND_CHALLENGE_KEY   CAACS_SEND_CHALLENGE_KEY;
typedef const AACS_SEND_CHALLENGE_KEY *PCAACS_SEND_CHALLENGE_KEY;


// The AACS binding nonce (opaque data structure) is used to
// protect individual content.
typedef struct _AACS_BINDING_NONCE {
    UCHAR BindingNonce[16];
    UCHAR MAC[16]; // MessageAuthenticationCode
} AACS_BINDING_NONCE, *PAACS_BINDING_NONCE;
typedef const AACS_BINDING_NONCE   CAACS_BINDING_NONCE;
typedef const AACS_BINDING_NONCE *PCAACS_BINDING_NONCE;
C_ASSERT(sizeof(AACS_BINDING_NONCE) == 32);


// This structure is sent when reading a binding nonce
// either from the medium or when having the logical unit
// generate a new binding nonce for a set of sectors
// NOTE: This structure must be identically aligned for 32/64 bit builds
//       
typedef struct _AACS_READ_BINDING_NONCE {
    DVD_SESSION_ID        SessionId;
    __range(0,255) ULONG  NumberOfSectors; // spec only provides one byte
    ULONGLONG             StartLba;

    // 32-bit HANDLE is 32 bits, 64-bit HANDLE is 64 bits
    union {
        HANDLE                Handle;
        ULONGLONG             ForceStructureLengthToMatch64bit;
    };
} AACS_READ_BINDING_NONCE, *PAACS_READ_BINDING_NONCE;

/////////////////////////////////////////////////////////////

#pragma warning(pop)
#endif  // _NTDDCDVD_

// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddcdrm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddcdrm.h

Abstract:

    This module contains structures and definitions
    associated with CDROM IOCTls.


--*/

// begin_winioctl

#ifndef _NTDDCDRM_
#define _NTDDCDRM_


#ifdef __cplusplus
extern "C" {
#endif


#if _MSC_VER >= 1200
#pragma warning(push)
#endif

#if _MSC_VER > 1000
#pragma once
#endif

//
// remove some level 4 warnings for this header file:
#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int

#ifdef __cplusplus
extern "C" {
#endif

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_CDROM_BASE                 FILE_DEVICE_CD_ROM

#define IOCTL_CDROM_UNLOAD_DRIVER        CTL_CODE(IOCTL_CDROM_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// CDROM Audio Device Control Functions
//

#define IOCTL_CDROM_READ_TOC              CTL_CODE(IOCTL_CDROM_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_SEEK_AUDIO_MSF        CTL_CODE(IOCTL_CDROM_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_STOP_AUDIO            CTL_CODE(IOCTL_CDROM_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_PAUSE_AUDIO           CTL_CODE(IOCTL_CDROM_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_RESUME_AUDIO          CTL_CODE(IOCTL_CDROM_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_GET_VOLUME            CTL_CODE(IOCTL_CDROM_BASE, 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_PLAY_AUDIO_MSF        CTL_CODE(IOCTL_CDROM_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_SET_VOLUME            CTL_CODE(IOCTL_CDROM_BASE, 0x000A, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_READ_Q_CHANNEL        CTL_CODE(IOCTL_CDROM_BASE, 0x000B, METHOD_BUFFERED, FILE_READ_ACCESS)
#if (NTDDI_VERSION < NTDDI_WS03)
#define IOCTL_CDROM_GET_CONTROL           CTL_CODE(IOCTL_CDROM_BASE, 0x000D, METHOD_BUFFERED, FILE_READ_ACCESS)
#else
#define OBSOLETE_IOCTL_CDROM_GET_CONTROL  CTL_CODE(IOCTL_CDROM_BASE, 0x000D, METHOD_BUFFERED, FILE_READ_ACCESS)
#endif
#define IOCTL_CDROM_GET_LAST_SESSION      CTL_CODE(IOCTL_CDROM_BASE, 0x000E, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_RAW_READ              CTL_CODE(IOCTL_CDROM_BASE, 0x000F, METHOD_OUT_DIRECT,  FILE_READ_ACCESS)
#define IOCTL_CDROM_DISK_TYPE             CTL_CODE(IOCTL_CDROM_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_CDROM_GET_DRIVE_GEOMETRY    CTL_CODE(IOCTL_CDROM_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX CTL_CODE(IOCTL_CDROM_BASE, 0x0014, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_CDROM_READ_TOC_EX           CTL_CODE(IOCTL_CDROM_BASE, 0x0015, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_GET_CONFIGURATION     CTL_CODE(IOCTL_CDROM_BASE, 0x0016, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_CDROM_EXCLUSIVE_ACCESS      CTL_CODE(IOCTL_CDROM_BASE, 0x0017, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_CDROM_SET_SPEED             CTL_CODE(IOCTL_CDROM_BASE, 0x0018, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_GET_INQUIRY_DATA      CTL_CODE(IOCTL_CDROM_BASE, 0x0019, METHOD_BUFFERED, FILE_READ_ACCESS)


// end_winioctl

//
// The following device control codes are common for all class drivers.  The
// functions codes defined here must match all of the other class drivers.
//
// Warning: these codes will be replaced in the future with the IOCTL_STORAGE
// codes included below
//

#define IOCTL_CDROM_CHECK_VERIFY    CTL_CODE(IOCTL_CDROM_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_MEDIA_REMOVAL   CTL_CODE(IOCTL_CDROM_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_EJECT_MEDIA     CTL_CODE(IOCTL_CDROM_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_LOAD_MEDIA      CTL_CODE(IOCTL_CDROM_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_RESERVE         CTL_CODE(IOCTL_CDROM_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_RELEASE         CTL_CODE(IOCTL_CDROM_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CDROM_FIND_NEW_DEVICES CTL_CODE(IOCTL_CDROM_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// The following file contains the IOCTL_STORAGE class ioctl definitions
//

#include <ntddstor.h>

// begin_winioctl


#define MINIMUM_CDROM_INQUIRY_SIZE  36 // RTL_SIZEOF_THROUGH_FIELD(INQUIRYDATA, ProductRevisionLevel)
#define MAXIMUM_CDROM_INQUIRY_SIZE 260 // MAXUCHAR + RTL_SIZEOF_THROUGH_FIELD(INQUIRYDATA, AdditionalLength)

//
// The following device control code is for the SIMBAD simulated bad
// sector facility. See SIMBAD.H in this directory for related structures.
//

#define IOCTL_CDROM_SIMBAD          CTL_CODE(IOCTL_CDROM_BASE, 0x1003, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Maximum CD Rom size
//

#define MAXIMUM_NUMBER_TRACKS 100
#define MAXIMUM_CDROM_SIZE 804
#define MINIMUM_CDROM_READ_TOC_EX_SIZE 2  // two bytes min transferred

//
// READ_TOC_EX structure
//
typedef struct _CDROM_READ_TOC_EX {
    UCHAR Format    : 4;
    UCHAR Reserved1 : 3; // future expansion
    UCHAR Msf       : 1;
    UCHAR SessionTrack;
    UCHAR Reserved2;     // future expansion
    UCHAR Reserved3;     // future expansion
} CDROM_READ_TOC_EX, *PCDROM_READ_TOC_EX;

#define CDROM_READ_TOC_EX_FORMAT_TOC      0x00
#define CDROM_READ_TOC_EX_FORMAT_SESSION  0x01
#define CDROM_READ_TOC_EX_FORMAT_FULL_TOC 0x02
#define CDROM_READ_TOC_EX_FORMAT_PMA      0x03
#define CDROM_READ_TOC_EX_FORMAT_ATIP     0x04
#define CDROM_READ_TOC_EX_FORMAT_CDTEXT   0x05

//
// CD ROM Table OF Contents (TOC)
// Format 0 - Get table of contents
//

typedef struct _TRACK_DATA {
    UCHAR Reserved;
    UCHAR Control : 4;
    UCHAR Adr : 4;
    UCHAR TrackNumber;
    UCHAR Reserved1;
    UCHAR Address[4];
} TRACK_DATA, *PTRACK_DATA;

typedef struct _CDROM_TOC {

    //
    // Header
    //

    UCHAR Length[2];  // add two bytes for this field
    UCHAR FirstTrack;
    UCHAR LastTrack;

    //
    // Track data
    //

    TRACK_DATA TrackData[MAXIMUM_NUMBER_TRACKS];
} CDROM_TOC, *PCDROM_TOC;

#define CDROM_TOC_SIZE sizeof(CDROM_TOC)

//
// CD ROM Table OF Contents
// Format 1 - Session Information
//

typedef struct _CDROM_TOC_SESSION_DATA {

    //
    // Header
    //

    UCHAR Length[2];  // add two bytes for this field
    UCHAR FirstCompleteSession;
    UCHAR LastCompleteSession;

    //
    // One track, representing the first track
    // of the last finished session
    //

    TRACK_DATA TrackData[1];

} CDROM_TOC_SESSION_DATA, *PCDROM_TOC_SESSION_DATA;


//
// CD ROM Table OF Contents
// Format 2 - Full TOC
//

typedef struct _CDROM_TOC_FULL_TOC_DATA_BLOCK {
    UCHAR SessionNumber;
    UCHAR Control      : 4;
    UCHAR Adr          : 4;
    UCHAR Reserved1;
    UCHAR Point;
    UCHAR MsfExtra[3];
    UCHAR Zero;
    UCHAR Msf[3];
} CDROM_TOC_FULL_TOC_DATA_BLOCK, *PCDROM_TOC_FULL_TOC_DATA_BLOCK;

typedef struct _CDROM_TOC_FULL_TOC_DATA {

    //
    // Header
    //

    UCHAR Length[2];  // add two bytes for this field
    UCHAR FirstCompleteSession;
    UCHAR LastCompleteSession;

    //
    // one to N descriptors included
    //

#if !defined(__midl)
    CDROM_TOC_FULL_TOC_DATA_BLOCK Descriptors[0];
#endif

} CDROM_TOC_FULL_TOC_DATA, *PCDROM_TOC_FULL_TOC_DATA;

//
// CD ROM Table OF Contents
// Format 3 - Program Memory Area
//
typedef struct _CDROM_TOC_PMA_DATA {

    //
    // Header
    //

    UCHAR Length[2];  // add two bytes for this field
    UCHAR Reserved1;
    UCHAR Reserved2;

    //
    // one to N descriptors included
    //

#if !defined(__midl)
    CDROM_TOC_FULL_TOC_DATA_BLOCK Descriptors[0];
#endif

} CDROM_TOC_PMA_DATA, *PCDROM_TOC_PMA_DATA;

//
// CD ROM Table OF Contents
// Format 4 - Absolute Time In Pregroove
//

typedef struct _CDROM_TOC_ATIP_DATA_BLOCK {

    UCHAR CdrwReferenceSpeed : 3;
    UCHAR Reserved3          : 1;
    UCHAR WritePower         : 3;
    UCHAR True1              : 1;
    UCHAR Reserved4       : 6;
    UCHAR UnrestrictedUse : 1;
    UCHAR Reserved5       : 1;
    UCHAR A3Valid     : 1;
    UCHAR A2Valid     : 1;
    UCHAR A1Valid     : 1;
    UCHAR DiscSubType : 3;
    UCHAR IsCdrw      : 1;
    UCHAR True2       : 1;
    UCHAR Reserved7;

    UCHAR LeadInMsf[3];
    UCHAR Reserved8;

    UCHAR LeadOutMsf[3];
    UCHAR Reserved9;

    UCHAR A1Values[3];
    UCHAR Reserved10;

    UCHAR A2Values[3];
    UCHAR Reserved11;

    UCHAR A3Values[3];
    UCHAR Reserved12;

} CDROM_TOC_ATIP_DATA_BLOCK, *PCDROM_TOC_ATIP_DATA_BLOCK;

typedef struct _CDROM_TOC_ATIP_DATA {

    //
    // Header
    //

    UCHAR Length[2];  // add two bytes for this field
    UCHAR Reserved1;
    UCHAR Reserved2;

    //
    // zero? to N descriptors included.
    //

#if !defined(__midl)
    CDROM_TOC_ATIP_DATA_BLOCK Descriptors[0];
#endif

} CDROM_TOC_ATIP_DATA, *PCDROM_TOC_ATIP_DATA;

//
// CD ROM Table OF Contents
// Format 5 - CD Text Info
//
typedef struct _CDROM_TOC_CD_TEXT_DATA_BLOCK {
    UCHAR PackType;
    UCHAR TrackNumber       : 7;
    UCHAR ExtensionFlag     : 1;  // should be zero!
    UCHAR SequenceNumber;
    UCHAR CharacterPosition : 4;
    UCHAR BlockNumber       : 3;
    UCHAR Unicode           : 1;
    union {
        UCHAR Text[12];
        WCHAR WText[6];
    };
    UCHAR CRC[2];
} CDROM_TOC_CD_TEXT_DATA_BLOCK, *PCDROM_TOC_CD_TEXT_DATA_BLOCK;

typedef struct _CDROM_TOC_CD_TEXT_DATA {

    //
    // Header
    //

    UCHAR Length[2];  // add two bytes for this field
    UCHAR Reserved1;
    UCHAR Reserved2;

    //
    // the text info comes in discrete blocks of
    // a heavily-overloaded structure
    //

#if !defined(__midl)
    CDROM_TOC_CD_TEXT_DATA_BLOCK Descriptors[0];
#endif

} CDROM_TOC_CD_TEXT_DATA, *PCDROM_TOC_CD_TEXT_DATA;

//
// These are the types used for PackType field in CDROM_TOC_CD_TEXT_DATA_BLOCK
// and also for requesting specific info from IOCTL_CDROM_READ_CD_TEXT
//
#define CDROM_CD_TEXT_PACK_ALBUM_NAME 0x80
#define CDROM_CD_TEXT_PACK_PERFORMER  0x81
#define CDROM_CD_TEXT_PACK_SONGWRITER 0x82
#define CDROM_CD_TEXT_PACK_COMPOSER   0x83
#define CDROM_CD_TEXT_PACK_ARRANGER   0x84
#define CDROM_CD_TEXT_PACK_MESSAGES   0x85
#define CDROM_CD_TEXT_PACK_DISC_ID    0x86
#define CDROM_CD_TEXT_PACK_GENRE      0x87
#define CDROM_CD_TEXT_PACK_TOC_INFO   0x88
#define CDROM_CD_TEXT_PACK_TOC_INFO2  0x89
// 0x8a - 0x8d are reserved....
#define CDROM_CD_TEXT_PACK_UPC_EAN    0x8e
#define CDROM_CD_TEXT_PACK_SIZE_INFO  0x8f

//
// Play audio starting at MSF and ending at MSF
//

typedef struct _CDROM_PLAY_AUDIO_MSF {
    UCHAR StartingM;
    UCHAR StartingS;
    UCHAR StartingF;
    UCHAR EndingM;
    UCHAR EndingS;
    UCHAR EndingF;
} CDROM_PLAY_AUDIO_MSF, *PCDROM_PLAY_AUDIO_MSF;

//
// Seek to MSF
//

typedef struct _CDROM_SEEK_AUDIO_MSF {
    UCHAR M;
    UCHAR S;
    UCHAR F;
} CDROM_SEEK_AUDIO_MSF, *PCDROM_SEEK_AUDIO_MSF;


//
//  Flags for the disk type
//

typedef struct _CDROM_DISK_DATA {

    ULONG DiskData;

} CDROM_DISK_DATA, *PCDROM_DISK_DATA;

#define CDROM_DISK_AUDIO_TRACK      (0x00000001)
#define CDROM_DISK_DATA_TRACK       (0x00000002)

//
// CD ROM Data Mode Codes, used with IOCTL_CDROM_READ_Q_CHANNEL
//

#define IOCTL_CDROM_SUB_Q_CHANNEL    0x00
#define IOCTL_CDROM_CURRENT_POSITION 0x01
#define IOCTL_CDROM_MEDIA_CATALOG    0x02
#define IOCTL_CDROM_TRACK_ISRC       0x03

typedef struct _CDROM_SUB_Q_DATA_FORMAT {
    UCHAR Format;
    UCHAR Track;
} CDROM_SUB_Q_DATA_FORMAT, *PCDROM_SUB_Q_DATA_FORMAT;


//
// CD ROM Sub-Q Channel Data Format
//

typedef struct _SUB_Q_HEADER {
    UCHAR Reserved;
    UCHAR AudioStatus;
    UCHAR DataLength[2];
} SUB_Q_HEADER, *PSUB_Q_HEADER;

typedef struct _SUB_Q_CURRENT_POSITION {
    SUB_Q_HEADER Header;
    UCHAR FormatCode;
    UCHAR Control : 4;
    UCHAR ADR : 4;
    UCHAR TrackNumber;
    UCHAR IndexNumber;
    UCHAR AbsoluteAddress[4];
    UCHAR TrackRelativeAddress[4];
} SUB_Q_CURRENT_POSITION, *PSUB_Q_CURRENT_POSITION;

typedef struct _SUB_Q_MEDIA_CATALOG_NUMBER {
    SUB_Q_HEADER Header;
    UCHAR FormatCode;
    UCHAR Reserved[3];
    UCHAR Reserved1 : 7;
    UCHAR Mcval : 1;
    UCHAR MediaCatalog[15];
} SUB_Q_MEDIA_CATALOG_NUMBER, *PSUB_Q_MEDIA_CATALOG_NUMBER;

typedef struct _SUB_Q_TRACK_ISRC {
    SUB_Q_HEADER Header;
    UCHAR FormatCode;
    UCHAR Reserved0;
    UCHAR Track;
    UCHAR Reserved1;
    UCHAR Reserved2 : 7;
    UCHAR Tcval : 1;
    UCHAR TrackIsrc[15];
} SUB_Q_TRACK_ISRC, *PSUB_Q_TRACK_ISRC;

typedef union _SUB_Q_CHANNEL_DATA {
    SUB_Q_CURRENT_POSITION CurrentPosition;
    SUB_Q_MEDIA_CATALOG_NUMBER MediaCatalog;
    SUB_Q_TRACK_ISRC TrackIsrc;
} SUB_Q_CHANNEL_DATA, *PSUB_Q_CHANNEL_DATA;

//
// Audio Status Codes
//

#define AUDIO_STATUS_NOT_SUPPORTED  0x00
#define AUDIO_STATUS_IN_PROGRESS    0x11
#define AUDIO_STATUS_PAUSED         0x12
#define AUDIO_STATUS_PLAY_COMPLETE  0x13
#define AUDIO_STATUS_PLAY_ERROR     0x14
#define AUDIO_STATUS_NO_STATUS      0x15

//
// ADR Sub-channel Q Field
//

#define ADR_NO_MODE_INFORMATION     0x0
#define ADR_ENCODES_CURRENT_POSITION 0x1
#define ADR_ENCODES_MEDIA_CATALOG   0x2
#define ADR_ENCODES_ISRC            0x3

//
// Sub-channel Q Control Bits
//

#define AUDIO_WITH_PREEMPHASIS      0x1
#define DIGITAL_COPY_PERMITTED      0x2
#define AUDIO_DATA_TRACK            0x4
#define TWO_FOUR_CHANNEL_AUDIO      0x8

#if (NTDDI_VERSION < NTDDI_WS03)
typedef struct _CDROM_AUDIO_CONTROL {
    UCHAR LbaFormat;
    USHORT LogicalBlocksPerSecond;
} CDROM_AUDIO_CONTROL, *PCDROM_AUDIO_CONTROL;
#else
#if PRAGMA_DEPRECATED_DDK
#define _CDROM_AUDIO_CONTROL _this_is_obsoleted__CDROM_AUDIO_CONTROL
#define CDROM_AUDIO_CONTROL  _this_is_obsoleted_CDROM_AUDIO_CONTROL
#define PCDROM_AUDIO_CONTROL _this_is_obsoleted_PCDROM_AUDIO_CONTROL
#endif // PRAGMA_DEPRECATED_DDK
#endif

//
// Volume control - Volume takes a value between 1 and 0xFF.
// SCSI-II CDROM audio suppports up to 4 audio ports with
// Independent volume control.
//

typedef struct _VOLUME_CONTROL {
    UCHAR PortVolume[4];
} VOLUME_CONTROL, *PVOLUME_CONTROL;

typedef enum _TRACK_MODE_TYPE {
    YellowMode2,
    XAForm2,
    CDDA,
    RawWithC2AndSubCode,   // CD_RAW_SECTOR_WITH_C2_AND_SUBCODE_SIZE per sector
    RawWithC2,             // CD_RAW_SECTOR_WITH_C2_SIZE per sector
    RawWithSubCode         // CD_RAW_SECTOR_WITH_SUBCODE_SIZE per sector
} TRACK_MODE_TYPE, *PTRACK_MODE_TYPE;

#define CD_RAW_READ_C2_SIZE                    (     296   )
#define CD_RAW_READ_SUBCODE_SIZE               (         96)
#define CD_RAW_SECTOR_WITH_C2_SIZE             (2352+296   )
#define CD_RAW_SECTOR_WITH_SUBCODE_SIZE        (2352    +96)
#define CD_RAW_SECTOR_WITH_C2_AND_SUBCODE_SIZE (2352+296+96)

//
// Passed to cdrom to describe the raw read, ie. Mode 2, Form 2, CDDA...
//

typedef struct __RAW_READ_INFO {
    LARGE_INTEGER DiskOffset;
    ULONG    SectorCount;
    TRACK_MODE_TYPE TrackMode;
} RAW_READ_INFO, *PRAW_READ_INFO;

typedef enum _MEDIA_BLANK_TYPE {
    MediaBlankTypeFull = 0,               // mandatory support
    MediaBlankTypeMinimal = 1,            // mandatory support
    MediaBlankTypeIncompleteTrack = 2,    // optional support
    MediaBlankTypeUnreserveLastTrack = 3, // optional support, hairy
    MediaBlankTypeTrackTail = 4,          // mandatory support
    MediaBlankTypeUncloseLastSession = 5, // optional support
    MediaBlankTypeEraseLastSession = 6,   // optional support
    // MediaBlankType7 is reserved
} MEDIA_BLANK_TYPE, *PMEDIA_BLANK_TYPE;

//
// IOCTL_CDROM_EXCLUSIVE_ACCESS can be used to get exclusive
// access to the CDROM device.
//

#define CDROM_EXCLUSIVE_CALLER_LENGTH   64

//
// Input values (Flags) for ExclusiveAccessLockDevice
// Set Flags to CDROM_LOCK_IGNORE_VOLUME to lock the device even if the
// file system is mounted. Setting this could cause data corruption!
//

#define CDROM_LOCK_IGNORE_VOLUME        1

//
// Output values (Flags) for ExclusiveAccessQueryState
//

#define CDROM_NOT_IN_EXCLUSIVE_MODE     0
#define CDROM_IN_EXCLUSIVE_MODE         1


typedef enum _EXCLUSIVE_ACCESS_REQUEST_TYPE {
    ExclusiveAccessQueryState,
    ExclusiveAccessLockDevice,
    ExclusiveAccessUnlockDevice
} EXCLUSIVE_ACCESS_REQUEST_TYPE, *PEXCLUSIVE_ACCESS_REQUEST_TYPE;


typedef struct _CDROM_EXCLUSIVE_ACCESS {

    //
    // Request type
    //
    EXCLUSIVE_ACCESS_REQUEST_TYPE RequestType;

    //
    // Additional parameters for each request type
    //
    ULONG Flags;

} CDROM_EXCLUSIVE_ACCESS, *PCDROM_EXCLUSIVE_ACCESS;


typedef struct _CDROM_EXCLUSIVE_LOCK {

    CDROM_EXCLUSIVE_ACCESS  Access;

    //
    // Caller name string
    //
    UCHAR CallerName[CDROM_EXCLUSIVE_CALLER_LENGTH];

} CDROM_EXCLUSIVE_LOCK, *PCDROM_EXCLUSIVE_LOCK;


typedef struct _CDROM_EXCLUSIVE_LOCK_STATE {

    BOOLEAN  LockState;

    //
    // Caller name string
    //
    UCHAR CallerName[CDROM_EXCLUSIVE_CALLER_LENGTH];

} CDROM_EXCLUSIVE_LOCK_STATE, *PCDROM_EXCLUSIVE_LOCK_STATE;

//
// Structure definitions for IOCTL_CDROM_SET_SPEED
//

typedef enum _CDROM_SPEED_REQUEST {
    CdromSetSpeed,
    CdromSetStreaming
} CDROM_SPEED_REQUEST, *PCDROM_SPEED_REQUEST;

typedef enum _WRITE_ROTATION {
    CdromDefaultRotation,
    CdromCAVRotation
} WRITE_ROTATION, *PWRITE_ROTATION;

typedef struct _CDROM_SET_SPEED {

    //
    // Request type for setting speed
    //
    CDROM_SPEED_REQUEST RequestType;

    //
    // Drive read speed in KB/sec.
    //
    USHORT ReadSpeed;

    //
    // Drive write speed in KB/sec.
    //
    USHORT WriteSpeed;

    //
    // Drive rotation control for write
    //
    WRITE_ROTATION RotationControl;

} CDROM_SET_SPEED, *PCDROM_SET_SPEED;

typedef struct _CDROM_SET_STREAMING {

    //
    // Request type for setting speed
    //
    CDROM_SPEED_REQUEST RequestType;

    //
    // Drive read size in KB per ReadTime
    //
    ULONG ReadSize;

    //
    // Read time in milliseconds
    //
    ULONG ReadTime;

    //
    // Drive write size in KB per WriteTime
    //
    ULONG WriteSize;

    //
    // Write time in milliseconds
    //
    ULONG WriteTime;

    //
    // First Logical Block Address of the request
    //
    ULONG StartLba;

    //
    // Last Logical Block Address of the request
    //
    ULONG EndLba;

    //
    // Drive rotation control for write
    //
    WRITE_ROTATION RotationControl;

    //
    // Restore drive defaults
    //
    BOOLEAN RestoreDefaults;

    //
    // Set drive to exact value given
    //
    BOOLEAN SetExact;

    //
    // Optimize performance for random changes
    //
    BOOLEAN RandomAccess;

    //
    // Restore default speed on media change
    //
    BOOLEAN Persistent;

} CDROM_SET_STREAMING, *PCDROM_SET_STREAMING;

#ifdef __cplusplus
}
#endif


#if _MSC_VER >= 1200
#pragma warning(pop)          // un-sets any local warning changes
#else
#pragma warning(default:4200) // array[0] is not a warning for this file
#pragma warning(default:4201) // nameless struct/unions
#pragma warning(default:4214) // bit fields other than int
#endif


#ifdef __cplusplus
}
#endif

#endif  // _NTDDCDRM_

// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntdd8042.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntdd8042.h

Abstract:

    This is the include file that defines all constants and types for hooking
    i8042 devices.

--*/

#ifndef _NTDD8042_
#define _NTDD8042_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Internal IOCTLs used to find who is in the chain of notification
//
#define IOCTL_INTERNAL_I8042_HOOK_KEYBOARD  CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0FF0, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_I8042_HOOK_MOUSE     CTL_CODE(FILE_DEVICE_MOUSE, 0x0FF0, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Internal IOCTLs used to write data to either device
//
// The IOCTL will be completed when the write has been completed.  If the write
// time out, the Cancel Routine of the Irp will be ignored and the Irp will still
// be completed successfully with a status of STATUS_IO_TIMEOUT instead of
// STATUS_SUCCESS
//
#define IOCTL_INTERNAL_I8042_KEYBOARD_WRITE_BUFFER   CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0FF1, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_I8042_MOUSE_WRITE_BUFFER      CTL_CODE(FILE_DEVICE_MOUSE, 0x0FF1, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Can only be sent down the keyboard stack
//
#define IOCTL_INTERNAL_I8042_CONTROLLER_WRITE_BUFFER CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0FF2, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// The keyboard / mouse will send this down the stack so that the upper device
// filter has a device object to synch against.  
//
#define IOCTL_INTERNAL_I8042_KEYBOARD_START_INFORMATION   CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0FF3, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_INTERNAL_I8042_MOUSE_START_INFORMATION      CTL_CODE(FILE_DEVICE_MOUSE, 0x0FF3, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Valid bits for the PowerCapabilities REG_DWORD that can be put in the devnode
// indicating the presence of their respecitve power keys on the device
//
#define I8042_POWER_SYS_BUTTON           0x0001
#define I8042_SLEEP_SYS_BUTTON           0x0002
#define I8042_WAKE_SYS_BUTTON            0x0004
#define I8042_SYS_BUTTONS  (I8042_POWER_SYS_BUTTON | \
                            I8042_SLEEP_SYS_BUTTON | \
                            I8042_WAKE_SYS_BUTTON) 

//
// Synchronous reads and writes during kb initialization
//
#if 0
typedef enum _I8042_PORT_TYPE {
    PortTypeData = 0,
    PortTypeCommand
} I8042_PORT_TYPE;
#endif

typedef
NTSTATUS
(*PI8042_SYNCH_READ_PORT) (
    IN PVOID    Context,
    PUCHAR      Value,
    BOOLEAN     WaitForACK
    );

/*++
Routine Description:

    This routine sends a command or data byte to the keyboard
    in polling mode.  It waits for acknowledgment and resends
    the command/data if WaitForACK is true.

Arguments:

    Context - Function specific context

    PortType - If PortTypeCommand, send the byte to the command register,
        otherwise send it to the data register.

    WaitForACK - If true, wait for an ACK back from the hardware.

    AckDeviceType - Indicates which device we expect to get the ACK back
        from.

    Value - The byte to send to the hardware.

Return Value:

    STATUS_IO_TIMEOUT - The hardware was not ready for input or did not
    respond.

    STATUS_SUCCESS - The byte was successfully sent to the hardware.
  --*/
typedef
NTSTATUS
(*PI8042_SYNCH_WRITE_PORT) (
    IN PVOID    Context,
    UCHAR       Value,
    BOOLEAN     WaitForACK
    );

//
// These functions (PI8042_ISR_WRITE_PORT, PI8042_QUEUE_PACKET) are only valid
// when called with the context of the ISR hook
//
typedef
VOID
(*PI8042_ISR_WRITE_PORT) (
    IN PVOID        Context,
    IN UCHAR        Value
    );

//
// Call this function when an input packet has been fully formed and is ready to
// be queued to the class driver above of us in the stack
//
typedef
VOID
(*PI8042_QUEUE_PACKET) (
    IN PVOID        Context
    );

//
// Current state of writing to a device
//
typedef enum _TRANSMIT_STATE {
    Idle = 0,
    SendingBytes
} TRANSMIT_STATE;

//
// Current state of writing to the device.  If State != Idle, then a write is in
// progress
//
typedef struct _OUTPUT_PACKET {
    PUCHAR         Bytes;
    ULONG          CurrentByte;
    ULONG          ByteCount;
    TRANSMIT_STATE State;
} OUTPUT_PACKET, *POUTPUT_PACKET;

typedef enum _MOUSE_STATE {
    MouseIdle,              // expecting byte 1
    XMovement,              // expecting byte 2
    YMovement,              // expecting byte 3
    ZMovement,              // expecting byte 4 (if a wheel mouse)
    MouseExpectingACK,      // expecting ACK from Enable Mouse cmd
    MouseResetting          // reset substate
} MOUSE_STATE, *PMOUSE_STATE;

/*--
Normal reset process

Step                                    Transition into
Send Reset to mouse                     ExpectingReset (ie, 0xAA)
Got reset                               ExpectingResetId
Got reset id, send get device id        ExpectingGetDeviceIdACK
Got get dev id ack,                     ExpectingGetDeviceIdValue
Got dev id                              ExpectingSetResolutionACK
Got ACK for set res                     ExpectingSetResolutionValueAck
Got ACK for value                       ExpectingSetScaling1to1ACK
Got ACK for set scaling                 ExpectingSetScaling1to1ACK2
Got ACK for set scaling                 ExpectingSetScaling1to1ACK3

                                        EnableWheelDetection (via registry) ==
                                        0 send set sampling rate,
                                            ExpectingSetSamplingRateDefaultACK
                                        1 StartPnPIdDetection
                                        2 EnableWheel
StartPnPIdDetection, send series        ExpectingPnpIdByte1 after setting complete
 of set sampling rate commands
ExpectingPnpIdByte7                     compare pnp id to list, if valid,
                                        EnableWheel, else set def sampling rate
EnableWheel, send series of             send get device id after done,
 set sampling rate commands              ExpectingSetSamplingRateDefaultACK
got set sampling ack                    send sampling value
got sampling value ack                  mouse idle
 ++*/
typedef enum _MOUSE_RESET_SUBSTATE {
    ExpectingReset = 0,
    ExpectingResetId,                           /*  1 */
    ExpectingGetDeviceIdACK,                    /*  2 */
    ExpectingGetDeviceIdValue,                  /*  3 */

    ExpectingSetResolutionDefaultACK,           /*  4 */
    ExpectingSetResolutionDefaultValueACK,      /*  5 */

    ExpectingSetResolutionACK,                  /*  6 */
    ExpectingSetResolutionValueACK,             /*  7 */
    ExpectingSetScaling1to1ACK,                 /*  8 */
    ExpectingSetScaling1to1ACK2,                /*  9 */
    ExpectingSetScaling1to1ACK3,                /* 10 */
    ExpectingReadMouseStatusACK,                /* 11 */
    ExpectingReadMouseStatusByte1,              /* 12 */
    ExpectingReadMouseStatusByte2,              /* 13 */
    ExpectingReadMouseStatusByte3,              /* 14 */

    StartPnPIdDetection,                        /* 15 */

    ExpectingLoopSetSamplingRateACK,            /* 16 */
    ExpectingLoopSetSamplingRateValueACK,       /* 17 */

    ExpectingPnpIdByte1,                        /* 18 */
    ExpectingPnpIdByte2,                        /* 19 */
    ExpectingPnpIdByte3,                        /* 20 */
    ExpectingPnpIdByte4,                        /* 21 */
    ExpectingPnpIdByte5,                        /* 22 */
    ExpectingPnpIdByte6,                        /* 23 */
    ExpectingPnpIdByte7,                        /* 24 */

    EnableWheel,                                /* 25 */
    Enable5Buttons,                             /* 26 */

    ExpectingGetDeviceId2ACK,                   /* 27 */
    ExpectingGetDeviceId2Value,                 /* 28 */

    ExpectingSetSamplingRateACK,                /* 29 */
    ExpectingSetSamplingRateValueACK,           /* 30 */

    ExpectingEnableACK,                         /* 31 */

    ExpectingFinalResolutionACK,                /* 32 */
    ExpectingFinalResolutionValueACK,           /* 33 */

    ExpectingGetDeviceIdDetectACK,              /* 34 */
    ExpectingGetDeviceIdDetectValue,            /* 35 */

    CustomHookStateMinimum = 100,
    CustomHookStateMaximum = 999,

    I8042ReservedMinimum = 1000

} MOUSE_RESET_SUBSTATE, *PMOUSE_RESET_SUBSTATE;

/*--
IsrContext      -- user provided context
CurrentInput    -- current packet to being assembled
StatusByte      -- byte reported by the command port
Byte            -- byte reported by the mouse (ie, the data port)
MouseState      -- current state of the i8042prt ISR
ResetSubState   -- current reset sub state, only valid when
                   MouseState == MouseResetting (otherwise null)
ContinueProcessing -- if TRUE, the i8042prt ISR will continue executing after
                      calling the hook
  ++*/
typedef
BOOLEAN
(*PI8042_MOUSE_ISR) (
    PVOID                   IsrContext,
    PMOUSE_INPUT_DATA       CurrentInput,
    POUTPUT_PACKET          CurrentOutput,
    UCHAR                   StatusByte,
    PUCHAR                  Byte,
    PBOOLEAN                ContinueProcessing,
    PMOUSE_STATE            MouseState,
    PMOUSE_RESET_SUBSTATE   ResetSubState
);

typedef struct _INTERNAL_I8042_HOOK_MOUSE {

    //
    // Context variable for IsrRoutine, CancelRoutine
    //
    OUT PVOID Context;

    //
    // Routine to call when a byte is received via the interrupt
    //
    OUT PI8042_MOUSE_ISR IsrRoutine;

    //
    // Write function, will automatically write to the command port saying the
    // next byte is directed towards the auxilliary device.
    //
    // NB:  May only called within the context of the IsrRoutine provided above
    //      The mouse's response to the write will passed to the IsrRoutine when
    //      it is received (ie, if 0xF4 (enable) was written using this function,
    //      an 0xFA (ACK) will be passed to IsrRoutine if the enable was
    //      successful)
    //
    IN PI8042_ISR_WRITE_PORT IsrWritePort;

    //
    // Queue the current packet (ie the one passed into the isr callback hook)
    // to be reported to the class driver
    //
    IN PI8042_QUEUE_PACKET QueueMousePacket;

    //
    // Context for IsrWritePort, QueueMousePacket
    //
    IN PVOID CallContext;

} INTERNAL_I8042_HOOK_MOUSE, *PINTERNAL_I8042_HOOK_MOUSE;

//
// Define the keyboard scan code input states.
//
typedef enum _KEYBOARD_SCAN_STATE {
    Normal,
    GotE0,
    GotE1
} KEYBOARD_SCAN_STATE, *PKEYBOARD_SCAN_STATE;

typedef
NTSTATUS
(*PI8042_KEYBOARD_INITIALIZATION_ROUTINE) (
    IN PVOID                           InitializationContext,
    IN PVOID                           SynchFuncContext,
    IN PI8042_SYNCH_READ_PORT          ReadPort,
    IN PI8042_SYNCH_WRITE_PORT         WritePort,
    OUT PBOOLEAN                       TurnTranslationOn
    );

typedef
BOOLEAN
(*PI8042_KEYBOARD_ISR) (
    PVOID                   IsrContext,
    PKEYBOARD_INPUT_DATA    CurrentInput,
    POUTPUT_PACKET          CurrentOutput,
    UCHAR                   StatusByte,
    PUCHAR                  Byte,
    PBOOLEAN                ContinueProcessing,
    PKEYBOARD_SCAN_STATE    ScanState
    );

typedef struct _INTERNAL_I8042_HOOK_KEYBOARD {

    //
    // Context variable for all callback routines
    //
    OUT PVOID Context;

    //
    // Routine to call after the mouse is reset
    //
    OUT PI8042_KEYBOARD_INITIALIZATION_ROUTINE InitializationRoutine;

    //
    // Routine to call when a byte is received via the interrupt
    //
    OUT PI8042_KEYBOARD_ISR IsrRoutine;

    //
    // Write function
    //
    IN PI8042_ISR_WRITE_PORT IsrWritePort;

    //
    // Queue the current packet (ie the one passed into the isr callback hook)
    // to be reported to the class driver
    //
    IN PI8042_QUEUE_PACKET QueueKeyboardPacket;

    //
    // Context for IsrWritePort, QueueKeyboardPacket
    //
    IN PVOID CallContext;

} INTERNAL_I8042_HOOK_KEYBOARD, *PINTERNAL_I8042_HOOK_KEYBOARD;

typedef struct _INTERNAL_I8042_START_INFORMATION {
    //
    // Size of this structure
    //
    ULONG Size;

    //
    // Interrupt object for the device.  Should only be used for calls to 
    // KeSynchronizeExecution
    //
    PKINTERRUPT InterruptObject;
    
    //
    // Future use
    //
    ULONG Reserved[8];

} INTERNAL_I8042_START_INFORMATION, *PINTERNAL_I8042_START_INFORMATION;

#ifdef __cplusplus
}
#endif

#endif // _NTDD8042_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntdddisk.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntdddisk.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Disk device.

Revision History:

--*/


// begin_winioctl

#ifndef _NTDDDISK_H_
#define _NTDDDISK_H_

// end_winioctl

#if _MSC_VER > 1000
#pragma once
#endif

#if (NTDDI_VERSION >= NTDDI_WINXP)
#include <diskguid.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(push)
#pragma warning(disable:4201) // nonstandard extension used : nameless struct/union
#pragma warning(disable:4214) // nonstandard extension used : bitfield other than int
#endif
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_DISK_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile

// begin_winioctl

//
// IoControlCode values for disk devices.
//

#define IOCTL_DISK_BASE                 FILE_DEVICE_DISK
#define IOCTL_DISK_GET_DRIVE_GEOMETRY   CTL_CODE(IOCTL_DISK_BASE, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_GET_PARTITION_INFO   CTL_CODE(IOCTL_DISK_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_PARTITION_INFO   CTL_CODE(IOCTL_DISK_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_DRIVE_LAYOUT     CTL_CODE(IOCTL_DISK_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_DRIVE_LAYOUT     CTL_CODE(IOCTL_DISK_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_VERIFY               CTL_CODE(IOCTL_DISK_BASE, 0x0005, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS        CTL_CODE(IOCTL_DISK_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_REASSIGN_BLOCKS      CTL_CODE(IOCTL_DISK_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_PERFORMANCE          CTL_CODE(IOCTL_DISK_BASE, 0x0008, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_IS_WRITABLE          CTL_CODE(IOCTL_DISK_BASE, 0x0009, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_LOGGING              CTL_CODE(IOCTL_DISK_BASE, 0x000a, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_FORMAT_TRACKS_EX     CTL_CODE(IOCTL_DISK_BASE, 0x000b, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_HISTOGRAM_STRUCTURE  CTL_CODE(IOCTL_DISK_BASE, 0x000c, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_HISTOGRAM_DATA       CTL_CODE(IOCTL_DISK_BASE, 0x000d, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_HISTOGRAM_RESET      CTL_CODE(IOCTL_DISK_BASE, 0x000e, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_REQUEST_STRUCTURE    CTL_CODE(IOCTL_DISK_BASE, 0x000f, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_REQUEST_DATA         CTL_CODE(IOCTL_DISK_BASE, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_PERFORMANCE_OFF      CTL_CODE(IOCTL_DISK_BASE, 0x0018, METHOD_BUFFERED, FILE_ANY_ACCESS)



#if(_WIN32_WINNT >= 0x0400)
#define IOCTL_DISK_CONTROLLER_NUMBER    CTL_CODE(IOCTL_DISK_BASE, 0x0011, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL support for SMART drive fault prediction.
//

#define SMART_GET_VERSION               CTL_CODE(IOCTL_DISK_BASE, 0x0020, METHOD_BUFFERED, FILE_READ_ACCESS)
#define SMART_SEND_DRIVE_COMMAND        CTL_CODE(IOCTL_DISK_BASE, 0x0021, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define SMART_RCV_DRIVE_DATA            CTL_CODE(IOCTL_DISK_BASE, 0x0022, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#endif /* _WIN32_WINNT >= 0x0400 */

#if (_WIN32_WINNT >= 0x500)

//
// New IOCTLs for GUID Partition tabled disks.
//

#define IOCTL_DISK_GET_PARTITION_INFO_EX    CTL_CODE(IOCTL_DISK_BASE, 0x0012, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_SET_PARTITION_INFO_EX    CTL_CODE(IOCTL_DISK_BASE, 0x0013, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_DRIVE_LAYOUT_EX      CTL_CODE(IOCTL_DISK_BASE, 0x0014, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_SET_DRIVE_LAYOUT_EX      CTL_CODE(IOCTL_DISK_BASE, 0x0015, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_CREATE_DISK              CTL_CODE(IOCTL_DISK_BASE, 0x0016, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GET_LENGTH_INFO          CTL_CODE(IOCTL_DISK_BASE, 0x0017, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_GET_DRIVE_GEOMETRY_EX    CTL_CODE(IOCTL_DISK_BASE, 0x0028, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif /* _WIN32_WINNT >= 0x0500 */

#if (_WIN32_WINNT >= 0x0502)

//
// New IOCTL for disk devices that support 8 byte LBA
//
#define IOCTL_DISK_REASSIGN_BLOCKS_EX       CTL_CODE(IOCTL_DISK_BASE, 0x0029, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#endif //_WIN32_WINNT >= 0x0502

#if(_WIN32_WINNT >= 0x0500)
#define IOCTL_DISK_UPDATE_DRIVE_SIZE        CTL_CODE(IOCTL_DISK_BASE, 0x0032, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_GROW_PARTITION           CTL_CODE(IOCTL_DISK_BASE, 0x0034, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_DISK_GET_CACHE_INFORMATION    CTL_CODE(IOCTL_DISK_BASE, 0x0035, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_CACHE_INFORMATION    CTL_CODE(IOCTL_DISK_BASE, 0x0036, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#if (NTDDI_VERSION < NTDDI_WIN2003)
#define IOCTL_DISK_GET_WRITE_CACHE_STATE    CTL_CODE(IOCTL_DISK_BASE, 0x0037, METHOD_BUFFERED, FILE_READ_ACCESS)
#else
#define OBSOLETE_DISK_GET_WRITE_CACHE_STATE CTL_CODE(IOCTL_DISK_BASE, 0x0037, METHOD_BUFFERED, FILE_READ_ACCESS)
#endif
#define IOCTL_DISK_DELETE_DRIVE_LAYOUT      CTL_CODE(IOCTL_DISK_BASE, 0x0040, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Called to flush cached information that the driver may have about this
// device's characteristics.  Not all drivers cache characteristics, and not
// cached properties can be flushed.  This simply serves as an update to the
// driver that it may want to do an expensive reexamination of the device's
// characteristics now (fixed media size, partition table, etc...)
//

#define IOCTL_DISK_UPDATE_PROPERTIES    CTL_CODE(IOCTL_DISK_BASE, 0x0050, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
//  Special IOCTLs needed to support PC-98 machines in Japan
//

#define IOCTL_DISK_FORMAT_DRIVE         CTL_CODE(IOCTL_DISK_BASE, 0x00f3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_DISK_SENSE_DEVICE         CTL_CODE(IOCTL_DISK_BASE, 0x00f8, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif /* _WIN32_WINNT >= 0x0500 */

// end_winioctl

//
// IOCTLs to report and modify our caching behavior
//

#define IOCTL_DISK_GET_CACHE_SETTING    CTL_CODE(IOCTL_DISK_BASE, 0x0038, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_CACHE_SETTING    CTL_CODE(IOCTL_DISK_BASE, 0x0039, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

typedef enum _DISK_CACHE_STATE {

    DiskCacheNormal,
    DiskCacheWriteThroughNotSupported,
    DiskCacheModifyUnsuccessful

} DISK_CACHE_STATE, *PDISK_CACHE_STATE;

typedef struct _DISK_CACHE_SETTING {

    //
    // The size of this structure is used for versioning
    //
    ULONG Version;

    //
    // Indicates whether there are any issues with the disk cache
    //
    DISK_CACHE_STATE State;

    //
    // Indicates whether the disk cache is power protected or not
    //
    BOOLEAN IsPowerProtected;

} DISK_CACHE_SETTING, *PDISK_CACHE_SETTING;


//
// IOCTL for moving copying a run of sectors from one location of the disk
// to another.  The caller of this IOCTL needs to be prepared for the call to
// fail and do the copy manually since this IOCTL will only rarely be
// implemented.
//

#define IOCTL_DISK_COPY_DATA            CTL_CODE(IOCTL_DISK_BASE, 0x0019, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// This structure is passed in for a IOCTL_DISK_COPY_DATA call.
//

typedef struct _DISK_COPY_DATA_PARAMETERS {
    LARGE_INTEGER   SourceOffset;
    LARGE_INTEGER   DestinationOffset;
    LARGE_INTEGER   CopyLength;
    ULONGLONG       Reserved;           // Must be 0.
} DISK_COPY_DATA_PARAMETERS, *PDISK_COPY_DATA_PARAMETERS;

//
// Internal disk driver device controls to maintain the verify status bit
// for the device object.
//

#define IOCTL_DISK_INTERNAL_SET_VERIFY   CTL_CODE(IOCTL_DISK_BASE, 0x0100, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_CLEAR_VERIFY CTL_CODE(IOCTL_DISK_BASE, 0x0101, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// Internal disk driver device control to set notification routine for
// the device object. Used in DiskPerf.
//

#define IOCTL_DISK_INTERNAL_SET_NOTIFY   CTL_CODE(IOCTL_DISK_BASE, 0x0102, METHOD_BUFFERED, FILE_ANY_ACCESS)

// begin_winioctl
//
// The following device control codes are common for all class drivers.  The
// functions codes defined here must match all of the other class drivers.
//
// Warning: these codes will be replaced in the future by equivalent
// IOCTL_STORAGE codes
//

#define IOCTL_DISK_CHECK_VERIFY     CTL_CODE(IOCTL_DISK_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_MEDIA_REMOVAL    CTL_CODE(IOCTL_DISK_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_EJECT_MEDIA      CTL_CODE(IOCTL_DISK_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_LOAD_MEDIA       CTL_CODE(IOCTL_DISK_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_RESERVE          CTL_CODE(IOCTL_DISK_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_RELEASE          CTL_CODE(IOCTL_DISK_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_FIND_NEW_DEVICES CTL_CODE(IOCTL_DISK_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_GET_MEDIA_TYPES  CTL_CODE(IOCTL_DISK_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)

// end_winioctl

//
// The following file contains the IOCTL_STORAGE class ioctls
//

#include <ntddstor.h>

// begin_winioctl
//
// Define the partition types returnable by known disk drivers.
//

#define PARTITION_ENTRY_UNUSED          0x00      // Entry unused
#define PARTITION_FAT_12                0x01      // 12-bit FAT entries
#define PARTITION_XENIX_1               0x02      // Xenix
#define PARTITION_XENIX_2               0x03      // Xenix
#define PARTITION_FAT_16                0x04      // 16-bit FAT entries
#define PARTITION_EXTENDED              0x05      // Extended partition entry
#define PARTITION_HUGE                  0x06      // Huge partition MS-DOS V4
#define PARTITION_IFS                   0x07      // IFS Partition
#define PARTITION_OS2BOOTMGR            0x0A      // OS/2 Boot Manager/OPUS/Coherent swap
#define PARTITION_FAT32                 0x0B      // FAT32
#define PARTITION_FAT32_XINT13          0x0C      // FAT32 using extended int13 services
#define PARTITION_XINT13                0x0E      // Win95 partition using extended int13 services
#define PARTITION_XINT13_EXTENDED       0x0F      // Same as type 5 but uses extended int13 services
#define PARTITION_PREP                  0x41      // PowerPC Reference Platform (PReP) Boot Partition
#define PARTITION_LDM                   0x42      // Logical Disk Manager partition
#define PARTITION_UNIX                  0x63      // Unix

#define VALID_NTFT                      0xC0      // NTFT uses high order bits

//
// The high bit of the partition type code indicates that a partition
// is part of an NTFT mirror or striped array.
//

#define PARTITION_NTFT                  0x80     // NTFT partition

//
// The following macro is used to determine which partitions should be
// assigned drive letters.
//

//++
//
// BOOLEAN
// IsRecognizedPartition(
//     IN ULONG PartitionType
//     )
//
// Routine Description:
//
//     This macro is used to determine to which partitions drive letters
//     should be assigned.
//
// Arguments:
//
//     PartitionType - Supplies the type of the partition being examined.
//
// Return Value:
//
//     The return value is TRUE if the partition type is recognized,
//     otherwise FALSE is returned.
//
//--
#if (NTDDK_VERSION < NTDDI_VISTA)
#define IsRecognizedPartition( PartitionType ) (    \
    ((PartitionType & PARTITION_NTFT) && (((PartitionType & ~0xC0) == PARTITION_HUGE)           ||  \
                                          ((PartitionType & ~0xC0) == PARTITION_IFS)            ||  \
                                          ((PartitionType & ~0xC0) == PARTITION_FAT32)          ||  \
                                          ((PartitionType & ~0xC0) == PARTITION_FAT32_XINT13))) ||  \
    ((PartitionType) == PARTITION_FAT_12)       ||  \
    ((PartitionType) == PARTITION_FAT_16)       ||  \
    ((PartitionType) == PARTITION_HUGE)         ||  \
    ((PartitionType) == PARTITION_IFS)          ||  \
    ((PartitionType) == PARTITION_FAT32)        ||  \
    ((PartitionType) == PARTITION_FAT32_XINT13) ||  \
    ((PartitionType) == PARTITION_XINT13) )
#else
#define IsRecognizedPartition( PartitionType ) (    \
    ((PartitionType) == PARTITION_FAT_12)       ||  \
    ((PartitionType) == PARTITION_FAT_16)       ||  \
    ((PartitionType) == PARTITION_HUGE)         ||  \
    ((PartitionType) == PARTITION_IFS)          ||  \
    ((PartitionType) == PARTITION_FAT32)        ||  \
    ((PartitionType) == PARTITION_FAT32_XINT13) ||  \
    ((PartitionType) == PARTITION_XINT13) )
#endif

//++
//
// BOOLEAN
// IsContainerPartition(
//     IN ULONG PartitionType
//     )
//
// Routine Description:
//
//     This macro is used to determine to which partition types are actually
//     containers for other partitions (ie, extended partitions).
//
// Arguments:
//
//     PartitionType - Supplies the type of the partition being examined.
//
// Return Value:
//
//     The return value is TRUE if the partition type is a container,
//     otherwise FALSE is returned.
//
//--

#define IsContainerPartition( PartitionType )       \
    ((PartitionType == PARTITION_EXTENDED) || (PartitionType == PARTITION_XINT13_EXTENDED))

//++
//
// BOOLEAN
// IsFTPartition(
//     IN ULONG PartitionType
//     )
//
// Routine Description:
//
//     This macro is used to determine if the given partition is an FT
//     partition.
//
// Arguments:
//
//     PartitionType - Supplies the type of the partition being examined.
//
// Return Value:
//
//     The return value is TRUE if the partition type is an FT partition,
//     otherwise FALSE is returned.
//
//--

#define IsFTPartition( PartitionType )              \
    ((PartitionType & PARTITION_NTFT) && (((PartitionType & ~0xC0) == PARTITION_HUGE)         ||  \
                                          ((PartitionType & ~0xC0) == PARTITION_IFS)          ||  \
                                          ((PartitionType & ~0xC0) == PARTITION_FAT32)        ||  \
                                          ((PartitionType & ~0xC0) == PARTITION_FAT32_XINT13)))

//
// Define the media types supported by the driver.
//

typedef enum _MEDIA_TYPE {
    Unknown,                // Format is unknown
    F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
    F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
    F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
    F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
    F3_720_512,             // 3.5",  720KB,  512 bytes/sector
    F5_360_512,             // 5.25", 360KB,  512 bytes/sector
    F5_320_512,             // 5.25", 320KB,  512 bytes/sector
    F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
    F5_180_512,             // 5.25", 180KB,  512 bytes/sector
    F5_160_512,             // 5.25", 160KB,  512 bytes/sector
    RemovableMedia,         // Removable media other than floppy
    FixedMedia,             // Fixed hard disk media
    F3_120M_512,            // 3.5", 120M Floppy
    F3_640_512,             // 3.5" ,  640KB,  512 bytes/sector
    F5_640_512,             // 5.25",  640KB,  512 bytes/sector
    F5_720_512,             // 5.25",  720KB,  512 bytes/sector
    F3_1Pt2_512,            // 3.5" ,  1.2Mb,  512 bytes/sector
    F3_1Pt23_1024,          // 3.5" ,  1.23Mb, 1024 bytes/sector
    F5_1Pt23_1024,          // 5.25",  1.23MB, 1024 bytes/sector
    F3_128Mb_512,           // 3.5" MO 128Mb   512 bytes/sector
    F3_230Mb_512,           // 3.5" MO 230Mb   512 bytes/sector
    F8_256_128,             // 8",     256KB,  128 bytes/sector
    F3_200Mb_512,           // 3.5",   200M Floppy (HiFD)
    F3_240M_512,            // 3.5",   240Mb Floppy (HiFD)
    F3_32M_512              // 3.5",   32Mb Floppy
} MEDIA_TYPE, *PMEDIA_TYPE;

//
// Define the input buffer structure for the driver, when
// it is called with IOCTL_DISK_FORMAT_TRACKS.
//

typedef struct _FORMAT_PARAMETERS {
   MEDIA_TYPE MediaType;
   ULONG StartCylinderNumber;
   ULONG EndCylinderNumber;
   ULONG StartHeadNumber;
   ULONG EndHeadNumber;
} FORMAT_PARAMETERS, *PFORMAT_PARAMETERS;

//
// Define the BAD_TRACK_NUMBER type. An array of elements of this type is
// returned by the driver on IOCTL_DISK_FORMAT_TRACKS requests, to indicate
// what tracks were bad during formatting. The length of that array is
// reported in the `Information' field of the I/O Status Block.
//

typedef USHORT BAD_TRACK_NUMBER;
typedef USHORT *PBAD_TRACK_NUMBER;

//
// Define the input buffer structure for the driver, when
// it is called with IOCTL_DISK_FORMAT_TRACKS_EX.
//

typedef struct _FORMAT_EX_PARAMETERS {
   MEDIA_TYPE MediaType;
   ULONG StartCylinderNumber;
   ULONG EndCylinderNumber;
   ULONG StartHeadNumber;
   ULONG EndHeadNumber;
   USHORT FormatGapLength;
   USHORT SectorsPerTrack;
   USHORT SectorNumber[1];
} FORMAT_EX_PARAMETERS, *PFORMAT_EX_PARAMETERS;

//
// The following structure is returned on an IOCTL_DISK_GET_DRIVE_GEOMETRY
// request and an array of them is returned on an IOCTL_DISK_GET_MEDIA_TYPES
// request.
//

typedef struct _DISK_GEOMETRY {
    LARGE_INTEGER Cylinders;
    MEDIA_TYPE MediaType;
    ULONG TracksPerCylinder;
    ULONG SectorsPerTrack;
    ULONG BytesPerSector;
} DISK_GEOMETRY, *PDISK_GEOMETRY;



//
// This wmi guid returns a DISK_GEOMETRY structure
//
#define WMI_DISK_GEOMETRY_GUID         { 0x25007f51, 0x57c2, 0x11d1, { 0xa5, 0x28, 0x0, 0xa0, 0xc9, 0x6, 0x29, 0x10 } }



//
// The following structure is returned on an IOCTL_DISK_GET_PARTITION_INFO
// and an IOCTL_DISK_GET_DRIVE_LAYOUT request.  It is also used in a request
// to change the drive layout, IOCTL_DISK_SET_DRIVE_LAYOUT.
//

typedef struct _PARTITION_INFORMATION {
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionLength;
    ULONG HiddenSectors;
    ULONG PartitionNumber;
    UCHAR PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    BOOLEAN RewritePartition;
} PARTITION_INFORMATION, *PPARTITION_INFORMATION;

//
// The following structure is used to change the partition type of a
// specified disk partition using an IOCTL_DISK_SET_PARTITION_INFO
// request.
//

typedef struct _SET_PARTITION_INFORMATION {
    UCHAR PartitionType;
} SET_PARTITION_INFORMATION, *PSET_PARTITION_INFORMATION;

//
// The following structures is returned on an IOCTL_DISK_GET_DRIVE_LAYOUT
// request and given as input to an IOCTL_DISK_SET_DRIVE_LAYOUT request.
//

typedef struct _DRIVE_LAYOUT_INFORMATION {
    ULONG PartitionCount;
    ULONG Signature;
    PARTITION_INFORMATION PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION, *PDRIVE_LAYOUT_INFORMATION;

//
// The following structure is passed in on an IOCTL_DISK_VERIFY request.
// The offset and length parameters are both given in bytes.
//

typedef struct _VERIFY_INFORMATION {
    LARGE_INTEGER StartingOffset;
    ULONG Length;
} VERIFY_INFORMATION, *PVERIFY_INFORMATION;

//
// The following structure is passed in on an IOCTL_DISK_REASSIGN_BLOCKS
// request.
//

typedef struct _REASSIGN_BLOCKS {
    USHORT Reserved;
    USHORT Count;
    ULONG BlockNumber[1];
} REASSIGN_BLOCKS, *PREASSIGN_BLOCKS;

//
// The following structure is passed in on an IOCTL_DISK_REASSIGN_BLOCKS_EX
// request.
//

#include <pshpack1.h>
typedef struct _REASSIGN_BLOCKS_EX {
    USHORT Reserved;
    USHORT Count;
    LARGE_INTEGER BlockNumber[1];
} REASSIGN_BLOCKS_EX, *PREASSIGN_BLOCKS_EX;
#include <poppack.h>


#if(_WIN32_WINNT >= 0x500)

//
// Support for GUID Partition Table (GPT) disks.
//

//
// There are currently two ways a disk can be partitioned. With a traditional
// AT-style master boot record (PARTITION_STYLE_MBR) and with a new, GPT
// partition table (PARTITION_STYLE_GPT). RAW is for an unrecognizable
// partition style. There are a very limited number of things you can
// do with a RAW partititon.
//

typedef enum _PARTITION_STYLE {
    PARTITION_STYLE_MBR,
    PARTITION_STYLE_GPT,
    PARTITION_STYLE_RAW
} PARTITION_STYLE;


//
// The following structure defines information in a GPT partition that is
// not common to both GPT and MBR partitions.
//

typedef struct _PARTITION_INFORMATION_GPT {
    GUID PartitionType;                 // Partition type. See table 16-3.
    GUID PartitionId;                   // Unique GUID for this partition.
    ULONG64 Attributes;                 // See table 16-4.
    WCHAR Name [36];                    // Partition Name in Unicode.
} PARTITION_INFORMATION_GPT, *PPARTITION_INFORMATION_GPT;

//
//  The following are GPT partition attributes applicable for any
//  partition type. These attributes are not OS-specific
//

#define GPT_ATTRIBUTE_PLATFORM_REQUIRED             (0x0000000000000001)

//
// The following are GPT partition attributes applicable when the
// PartitionType is PARTITION_BASIC_DATA_GUID.
//

#define GPT_BASIC_DATA_ATTRIBUTE_NO_DRIVE_LETTER    (0x8000000000000000)
#define GPT_BASIC_DATA_ATTRIBUTE_HIDDEN             (0x4000000000000000)
#define GPT_BASIC_DATA_ATTRIBUTE_SHADOW_COPY        (0x2000000000000000)
#define GPT_BASIC_DATA_ATTRIBUTE_READ_ONLY          (0x1000000000000000)

//
// The following structure defines information in an MBR partition that is not
// common to both GPT and MBR partitions.
//

typedef struct _PARTITION_INFORMATION_MBR {
    UCHAR PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    ULONG HiddenSectors;
} PARTITION_INFORMATION_MBR, *PPARTITION_INFORMATION_MBR;


//
// The structure SET_PARTITION_INFO_EX is used with the ioctl
// IOCTL_SET_PARTITION_INFO_EX to set information about a specific
// partition. Note that for MBR partitions, you can only set the partition
// signature, whereas GPT partitions allow setting of all fields that
// you can get.
//

typedef SET_PARTITION_INFORMATION SET_PARTITION_INFORMATION_MBR;
typedef PARTITION_INFORMATION_GPT SET_PARTITION_INFORMATION_GPT;


typedef struct _SET_PARTITION_INFORMATION_EX {
    PARTITION_STYLE PartitionStyle;
    union {
        SET_PARTITION_INFORMATION_MBR Mbr;
        SET_PARTITION_INFORMATION_GPT Gpt;
    } DUMMYUNIONNAME;
} SET_PARTITION_INFORMATION_EX, *PSET_PARTITION_INFORMATION_EX;


//
// The structure CREATE_DISK_GPT with the ioctl IOCTL_DISK_CREATE_DISK
// to initialize an virgin disk with an empty GPT partition table.
//

typedef struct _CREATE_DISK_GPT {
    GUID DiskId;                    // Unique disk id for the disk.
    ULONG MaxPartitionCount;        // Maximim number of partitions allowable.
} CREATE_DISK_GPT, *PCREATE_DISK_GPT;

//
// The structure CREATE_DISK_MBR with the ioctl IOCTL_DISK_CREATE_DISK
// to initialize an virgin disk with an empty MBR partition table.
//

typedef struct _CREATE_DISK_MBR {
    ULONG Signature;
} CREATE_DISK_MBR, *PCREATE_DISK_MBR;


typedef struct _CREATE_DISK {
    PARTITION_STYLE PartitionStyle;
    union {
        CREATE_DISK_MBR Mbr;
        CREATE_DISK_GPT Gpt;
    } DUMMYUNIONNAME;
} CREATE_DISK, *PCREATE_DISK;


//
// The structure GET_LENGTH_INFORMATION is used with the ioctl
// IOCTL_DISK_GET_LENGTH_INFO to obtain the length, in bytes, of the
// disk, partition, or volume.
//

typedef struct _GET_LENGTH_INFORMATION {
    LARGE_INTEGER   Length;
} GET_LENGTH_INFORMATION, *PGET_LENGTH_INFORMATION;

//
// The PARTITION_INFORMATION_EX structure is used with the
// IOCTL_DISK_GET_DRIVE_LAYOUT_EX, IOCTL_DISK_SET_DRIVE_LAYOUT_EX,
// IOCTL_DISK_GET_PARTITION_INFO_EX and IOCTL_DISK_GET_PARTITION_INFO_EX calls.
//

typedef struct _PARTITION_INFORMATION_EX {
    PARTITION_STYLE PartitionStyle;
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionLength;
    ULONG PartitionNumber;
    BOOLEAN RewritePartition;
    union {
        PARTITION_INFORMATION_MBR Mbr;
        PARTITION_INFORMATION_GPT Gpt;
    } DUMMYUNIONNAME;
} PARTITION_INFORMATION_EX, *PPARTITION_INFORMATION_EX;


//
// GPT specific drive layout information.
//

typedef struct _DRIVE_LAYOUT_INFORMATION_GPT {
    GUID DiskId;
    LARGE_INTEGER StartingUsableOffset;
    LARGE_INTEGER UsableLength;
    ULONG MaxPartitionCount;
} DRIVE_LAYOUT_INFORMATION_GPT, *PDRIVE_LAYOUT_INFORMATION_GPT;


//
// MBR specific drive layout information.
//

typedef struct _DRIVE_LAYOUT_INFORMATION_MBR {
    ULONG Signature;
} DRIVE_LAYOUT_INFORMATION_MBR, *PDRIVE_LAYOUT_INFORMATION_MBR;

//
// The structure DRIVE_LAYOUT_INFORMATION_EX is used with the
// IOCTL_SET_DRIVE_LAYOUT_EX and IOCTL_GET_DRIVE_LAYOUT_EX calls.
//

typedef struct _DRIVE_LAYOUT_INFORMATION_EX {
    ULONG PartitionStyle;
    ULONG PartitionCount;
    union {
        DRIVE_LAYOUT_INFORMATION_MBR Mbr;
        DRIVE_LAYOUT_INFORMATION_GPT Gpt;
    } DUMMYUNIONNAME;
    PARTITION_INFORMATION_EX PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION_EX, *PDRIVE_LAYOUT_INFORMATION_EX;


#endif // (_WIN32_WINNT >= 0x0500)


#if(_WIN32_WINNT >= 0x0500)

//
// The DISK_GEOMETRY_EX structure is returned on issuing an
// IOCTL_DISK_GET_DRIVE_GEOMETRY_EX ioctl.
//

typedef enum _DETECTION_TYPE {
        DetectNone,
        DetectInt13,
        DetectExInt13
} DETECTION_TYPE;

typedef struct _DISK_INT13_INFO {
        USHORT DriveSelect;
        ULONG MaxCylinders;
        USHORT SectorsPerTrack;
        USHORT MaxHeads;
        USHORT NumberDrives;
} DISK_INT13_INFO, *PDISK_INT13_INFO;

typedef struct _DISK_EX_INT13_INFO {
        USHORT ExBufferSize;
        USHORT ExFlags;
        ULONG ExCylinders;
        ULONG ExHeads;
        ULONG ExSectorsPerTrack;
        ULONG64 ExSectorsPerDrive;
        USHORT ExSectorSize;
        USHORT ExReserved;
} DISK_EX_INT13_INFO, *PDISK_EX_INT13_INFO;

typedef struct _DISK_DETECTION_INFO {
        ULONG SizeOfDetectInfo;
        DETECTION_TYPE DetectionType;
        union {
                struct {

                        //
                        // If DetectionType == DETECTION_INT13 then we have just the Int13
                        // information.
                        //

                        DISK_INT13_INFO Int13;

                        //
                        // If DetectionType == DETECTION_EX_INT13, then we have the
                        // extended int 13 information.
                        //

                        DISK_EX_INT13_INFO ExInt13;     // If DetectionType == DetectExInt13
                } DUMMYSTRUCTNAME;
        } DUMMYUNIONNAME;
} DISK_DETECTION_INFO, *PDISK_DETECTION_INFO;


typedef struct _DISK_PARTITION_INFO {
        ULONG SizeOfPartitionInfo;
        PARTITION_STYLE PartitionStyle;                 // PartitionStyle = RAW, GPT or MBR
        union {
                struct {                                                        // If PartitionStyle == MBR
                        ULONG Signature;                                // MBR Signature
                        ULONG CheckSum;                                 // MBR CheckSum
                } Mbr;
                struct {                                                        // If PartitionStyle == GPT
                        GUID DiskId;
                } Gpt;
        } DUMMYUNIONNAME;
} DISK_PARTITION_INFO, *PDISK_PARTITION_INFO;


//
// The Geometry structure is a variable length structure composed of a
// DISK_GEOMETRY_EX structure followed by a DISK_PARTITION_INFO structure
// followed by a DISK_DETECTION_DATA structure.
//

#if (NTDDI_VERSION < NTDDI_WIN2003)
#define DiskGeometryGetPartition(Geometry)\
                        ((PDISK_PARTITION_INFO)((Geometry)+1))

#define DiskGeometryGetDetect(Geometry)\
                        ((PDISK_DETECTION_INFO)(((PBYTE)DiskGeometryGetPartition(Geometry)+\
                                        DiskGeometryGetPartition(Geometry)->SizeOfPartitionInfo)))
#else
#define DiskGeometryGetPartition(Geometry)\
                        ((PDISK_PARTITION_INFO)((Geometry)->Data))

#define DiskGeometryGetDetect(Geometry)\
                        ((PDISK_DETECTION_INFO)(((ULONG_PTR)DiskGeometryGetPartition(Geometry)+\
                                        DiskGeometryGetPartition(Geometry)->SizeOfPartitionInfo)))
#endif
typedef struct _DISK_GEOMETRY_EX {
        DISK_GEOMETRY Geometry;                                 // Standard disk geometry: may be faked by driver.
        LARGE_INTEGER DiskSize;                                 // Must always be correct
        UCHAR Data[1];                                                  // Partition, Detect info
} DISK_GEOMETRY_EX, *PDISK_GEOMETRY_EX;

#endif // (_WIN32_WINNT > 0x0500)

#if(_WIN32_WINNT >= 0x0400)
//
// IOCTL_DISK_CONTROLLER_NUMBER returns the controller and disk
// number for the handle.  This is used to determine if a disk
// is attached to the primary or secondary IDE controller.
//

typedef struct _DISK_CONTROLLER_NUMBER {
    ULONG ControllerNumber;
    ULONG DiskNumber;
} DISK_CONTROLLER_NUMBER, *PDISK_CONTROLLER_NUMBER;
#endif /* _WIN32_WINNT >= 0x0400 */

#if(_WIN32_WINNT >= 0x0500)

//
// IOCTL_DISK_SET_CACHE_INFORMATION
//
// Input Buffer:
//      A DISK_CACHE_INFORMATION structure which describes how the disk
//      read/write caches should be configured.
//
// Output Buffer:
//      None
//

//
// IOCTL_DISK_GET_CACHE_INFORMATION
//
// Input Buffer:
//      None
//
// Output Buffer:
//      A DISK_CACHE_INFORMATION structure which contains the current state
//      of the disk read/write caches.
//

typedef enum {
    EqualPriority,
    KeepPrefetchedData,
    KeepReadData
} DISK_CACHE_RETENTION_PRIORITY;

#if (OSVER(NTDDI_VERSION) == NTDDI_WINXP)
typedef enum _DISK_WRITE_CACHE_STATE {
    DiskWriteCacheNormal,
    DiskWriteCacheForceDisable,
    DiskWriteCacheDisableNotSupported
} DISK_WRITE_CACHE_STATE, *PDISK_WRITE_CACHE_STATE;
#endif

typedef struct _DISK_CACHE_INFORMATION {

    //
    // on return indicates that the device is capable of saving any parameters
    // in non-volatile storage.  On send indicates that the device should
    // save the state in non-volatile storage.
    //

    BOOLEAN ParametersSavable;

    //
    // Indicates whether the write and read caches are enabled.
    //

    BOOLEAN ReadCacheEnabled;
    BOOLEAN WriteCacheEnabled;

    //
    // Controls the likelyhood of data remaining in the cache depending on how
    // it got there.  Data cached from a READ or WRITE operation may be given
    // higher, lower or equal priority to data entered into the cache for other
    // means (like prefetch)
    //

    DISK_CACHE_RETENTION_PRIORITY ReadRetentionPriority;
    DISK_CACHE_RETENTION_PRIORITY WriteRetentionPriority;

    //
    // Requests for a larger number of blocks than this may have prefetching
    // disabled.  If this value is set to 0 prefetch will be disabled.
    //

    USHORT DisablePrefetchTransferLength;

    //
    // If TRUE then ScalarPrefetch (below) will be valid.  If FALSE then
    // the minimum and maximum values should be treated as a block count
    // (BlockPrefetch)
    //

    BOOLEAN PrefetchScalar;

    //
    // Contains the minimum and maximum amount of data which will be
    // will be prefetched into the cache on a disk operation.  This value
    // may either be a scalar multiplier of the transfer length of the request,
    // or an abolute number of disk blocks.  PrefetchScalar (above) indicates
    // which interpretation is used.
    //

    union {
        struct {
            USHORT Minimum;
            USHORT Maximum;

            //
            // The maximum number of blocks which will be prefetched - useful
            // with the scalar limits to set definite upper limits.
            //

            USHORT MaximumBlocks;
        } ScalarPrefetch;

        struct {
            USHORT Minimum;
            USHORT Maximum;
        } BlockPrefetch;
    } DUMMYUNIONNAME;

} DISK_CACHE_INFORMATION, *PDISK_CACHE_INFORMATION;

//
// IOCTL_DISK_GROW_PARTITION will update the size of a partition
// by adding sectors to the length. The number of sectors must be
// predetermined by examining PARTITION_INFORMATION.
//

typedef struct _DISK_GROW_PARTITION {
    ULONG PartitionNumber;
    LARGE_INTEGER BytesToGrow;
} DISK_GROW_PARTITION, *PDISK_GROW_PARTITION;
#endif /* _WIN32_WINNT >= 0x0500 */

///////////////////////////////////////////////////////
//                                                   //
// The following structures define disk performance  //
// statistics: specifically the locations of all the //
// reads and writes which have occured on the disk.  //
//                                                   //
// To use these structures, you must issue an IOCTL_ //
// DISK_HIST_STRUCTURE (with a DISK_HISTOGRAM) to    //
// obtain the basic histogram information. The       //
// number of buckets which must allocated is part of //
// this structure. Allocate the required number of   //
// buckets and call an IOCTL_DISK_HIST_DATA to fill  //
// in the data                                       //
//                                                   //
///////////////////////////////////////////////////////

#define HIST_NO_OF_BUCKETS  24

typedef struct _HISTOGRAM_BUCKET {
    ULONG       Reads;
    ULONG       Writes;
} HISTOGRAM_BUCKET, *PHISTOGRAM_BUCKET;

#define HISTOGRAM_BUCKET_SIZE   sizeof(HISTOGRAM_BUCKET)

typedef struct _DISK_HISTOGRAM {
    LARGE_INTEGER   DiskSize;
    LARGE_INTEGER   Start;
    LARGE_INTEGER   End;
    LARGE_INTEGER   Average;
    LARGE_INTEGER   AverageRead;
    LARGE_INTEGER   AverageWrite;
    ULONG           Granularity;
    ULONG           Size;
    ULONG           ReadCount;
    ULONG           WriteCount;
    PHISTOGRAM_BUCKET  Histogram;
} DISK_HISTOGRAM, *PDISK_HISTOGRAM;

#define DISK_HISTOGRAM_SIZE sizeof(DISK_HISTOGRAM)

///////////////////////////////////////////////////////
//                                                   //
// The following structures define disk debugging    //
// capabilities. The IOCTLs are directed to one of   //
// the two disk filter drivers.                      //
//                                                   //
// DISKPERF is a utilty for collecting disk request  //
// statistics.                                       //
//                                                   //
// SIMBAD is a utility for injecting faults in       //
// IO requests to disks.                             //
//                                                   //
///////////////////////////////////////////////////////

//
// The following structure is exchanged on an IOCTL_DISK_GET_PERFORMANCE
// request. This ioctl collects summary disk request statistics used
// in measuring performance.
//

typedef struct _DISK_PERFORMANCE {
        LARGE_INTEGER BytesRead;
        LARGE_INTEGER BytesWritten;
        LARGE_INTEGER ReadTime;
        LARGE_INTEGER WriteTime;
        LARGE_INTEGER IdleTime;
        ULONG ReadCount;
        ULONG WriteCount;
        ULONG QueueDepth;
        ULONG SplitCount;
        LARGE_INTEGER QueryTime;
        ULONG   StorageDeviceNumber;
        WCHAR   StorageManagerName[8];
} DISK_PERFORMANCE, *PDISK_PERFORMANCE;

//
// This structure defines the disk logging record. When disk logging
// is enabled, one of these is written to an internal buffer for each
// disk request.
//

typedef struct _DISK_RECORD {
   LARGE_INTEGER ByteOffset;
   LARGE_INTEGER StartTime;
   LARGE_INTEGER EndTime;
   PVOID VirtualAddress;
   ULONG NumberOfBytes;
   UCHAR DeviceNumber;
   BOOLEAN ReadRequest;
} DISK_RECORD, *PDISK_RECORD;

//
// The following structure is exchanged on an IOCTL_DISK_LOG request.
// Not all fields are valid with each function type.
//

typedef struct _DISK_LOGGING {
    UCHAR Function;
    PVOID BufferAddress;
    ULONG BufferSize;
} DISK_LOGGING, *PDISK_LOGGING;

//
// Disk logging functions
//
// Start disk logging. Only the Function and BufferSize fields are valid.
//

#define DISK_LOGGING_START    0

//
// Stop disk logging. Only the Function field is valid.
//

#define DISK_LOGGING_STOP     1

//
// Return disk log. All fields are valid. Data will be copied from internal
// buffer to buffer specified for the number of bytes requested.
//

#define DISK_LOGGING_DUMP     2

//
// DISK BINNING
//
// DISKPERF will keep counters for IO that falls in each of these ranges.
// The application determines the number and size of the ranges.
// Joe Lin wanted me to keep it flexible as possible, for instance, IO
// sizes are interesting in ranges like 0-4096, 4097-16384, 16385-65536, 65537+.
//

#define DISK_BINNING          3

//
// Bin types
//

typedef enum _BIN_TYPES {
    RequestSize,
    RequestLocation
} BIN_TYPES;

//
// Bin ranges
//

typedef struct _BIN_RANGE {
    LARGE_INTEGER StartValue;
    LARGE_INTEGER Length;
} BIN_RANGE, *PBIN_RANGE;

//
// Bin definition
//

typedef struct _PERF_BIN {
    ULONG NumberOfBins;
    ULONG TypeOfBin;
    BIN_RANGE BinsRanges[1];
} PERF_BIN, *PPERF_BIN ;

//
// Bin count
//

typedef struct _BIN_COUNT {
    BIN_RANGE BinRange;
    ULONG BinCount;
} BIN_COUNT, *PBIN_COUNT;

//
// Bin results
//

typedef struct _BIN_RESULTS {
    ULONG NumberOfBins;
    BIN_COUNT BinCounts[1];
} BIN_RESULTS, *PBIN_RESULTS;

#if(_WIN32_WINNT >= 0x0400)
//
// Data structures for SMART drive fault prediction.
//
// GETVERSIONINPARAMS contains the data returned from the
// Get Driver Version function.
//

#include <pshpack1.h>
typedef struct _GETVERSIONINPARAMS {
        UCHAR    bVersion;               // Binary driver version.
        UCHAR    bRevision;              // Binary driver revision.
        UCHAR    bReserved;              // Not used.
        UCHAR    bIDEDeviceMap;          // Bit map of IDE devices.
        ULONG   fCapabilities;          // Bit mask of driver capabilities.
        ULONG   dwReserved[4];          // For future use.
} GETVERSIONINPARAMS, *PGETVERSIONINPARAMS, *LPGETVERSIONINPARAMS;
#include <poppack.h>

//
// Bits returned in the fCapabilities member of GETVERSIONINPARAMS
//

#define CAP_ATA_ID_CMD          1       // ATA ID command supported
#define CAP_ATAPI_ID_CMD        2       // ATAPI ID command supported
#define CAP_SMART_CMD           4       // SMART commannds supported

//
// IDE registers
//

#include <pshpack1.h>
typedef struct _IDEREGS {
        UCHAR    bFeaturesReg;           // Used for specifying SMART "commands".
        UCHAR    bSectorCountReg;        // IDE sector count register
        UCHAR    bSectorNumberReg;       // IDE sector number register
        UCHAR    bCylLowReg;             // IDE low order cylinder value
        UCHAR    bCylHighReg;            // IDE high order cylinder value
        UCHAR    bDriveHeadReg;          // IDE drive/head register
        UCHAR    bCommandReg;            // Actual IDE command.
        UCHAR    bReserved;                      // reserved for future use.  Must be zero.
} IDEREGS, *PIDEREGS, *LPIDEREGS;
#include <poppack.h>

//
// Valid values for the bCommandReg member of IDEREGS.
//

#define ATAPI_ID_CMD    0xA1            // Returns ID sector for ATAPI.
#define ID_CMD          0xEC            // Returns ID sector for ATA.
#define SMART_CMD       0xB0            // Performs SMART cmd.
                                        // Requires valid bFeaturesReg,
                                        // bCylLowReg, and bCylHighReg

//
// Cylinder register defines for SMART command
//

#define SMART_CYL_LOW   0x4F
#define SMART_CYL_HI    0xC2


//
// SENDCMDINPARAMS contains the input parameters for the
// Send Command to Drive function.
//

#include <pshpack1.h>
typedef struct _SENDCMDINPARAMS {
        ULONG   cBufferSize;            // Buffer size in bytes
        IDEREGS irDriveRegs;            // Structure with drive register values.
        UCHAR    bDriveNumber;           // Physical drive number to send
                                                                // command to (0,1,2,3).
        UCHAR    bReserved[3];           // Reserved for future expansion.
        ULONG   dwReserved[4];          // For future use.
        UCHAR    bBuffer[1];                     // Input buffer.
} SENDCMDINPARAMS, *PSENDCMDINPARAMS, *LPSENDCMDINPARAMS;
#include <poppack.h>

//
// Status returned from driver
//

#include <pshpack1.h>
typedef struct _DRIVERSTATUS {
        UCHAR    bDriverError;           // Error code from driver,
                                                                // or 0 if no error.
        UCHAR    bIDEError;                      // Contents of IDE Error register.
                                                                // Only valid when bDriverError
                                                                // is SMART_IDE_ERROR.
        UCHAR    bReserved[2];           // Reserved for future expansion.
        ULONG   dwReserved[2];          // Reserved for future expansion.
} DRIVERSTATUS, *PDRIVERSTATUS, *LPDRIVERSTATUS;
#include <poppack.h>

//
// bDriverError values
//

#define SMART_NO_ERROR          0       // No error
#define SMART_IDE_ERROR         1       // Error from IDE controller
#define SMART_INVALID_FLAG      2       // Invalid command flag
#define SMART_INVALID_COMMAND   3       // Invalid command byte
#define SMART_INVALID_BUFFER    4       // Bad buffer (null, invalid addr..)
#define SMART_INVALID_DRIVE     5       // Drive number not valid
#define SMART_INVALID_IOCTL     6       // Invalid IOCTL
#define SMART_ERROR_NO_MEM      7       // Could not lock user's buffer
#define SMART_INVALID_REGISTER  8       // Some IDE Register not valid
#define SMART_NOT_SUPPORTED     9       // Invalid cmd flag set
#define SMART_NO_IDE_DEVICE     10      // Cmd issued to device not present
                                        // although drive number is valid
//
// SMART sub commands for execute offline diags
//
#define SMART_OFFLINE_ROUTINE_OFFLINE       0
#define SMART_SHORT_SELFTEST_OFFLINE        1
#define SMART_EXTENDED_SELFTEST_OFFLINE     2
#define SMART_ABORT_OFFLINE_SELFTEST        127
#define SMART_SHORT_SELFTEST_CAPTIVE        129
#define SMART_EXTENDED_SELFTEST_CAPTIVE     130


#include <pshpack1.h>
typedef struct _SENDCMDOUTPARAMS {
        ULONG                   cBufferSize;            // Size of bBuffer in bytes
        DRIVERSTATUS            DriverStatus;           // Driver status structure.
        UCHAR                   bBuffer[1];             // Buffer of arbitrary length in which to store the data read from the                                                                                  // drive.
} SENDCMDOUTPARAMS, *PSENDCMDOUTPARAMS, *LPSENDCMDOUTPARAMS;
#include <poppack.h>


#define READ_ATTRIBUTE_BUFFER_SIZE  512
#define IDENTIFY_BUFFER_SIZE        512
#define READ_THRESHOLD_BUFFER_SIZE  512
#define SMART_LOG_SECTOR_SIZE       512

//
// Feature register defines for SMART "sub commands"
//

#define READ_ATTRIBUTES         0xD0
#define READ_THRESHOLDS         0xD1
#define ENABLE_DISABLE_AUTOSAVE 0xD2
#define SAVE_ATTRIBUTE_VALUES   0xD3
#define EXECUTE_OFFLINE_DIAGS   0xD4
#define SMART_READ_LOG          0xD5
#define SMART_WRITE_LOG         0xd6
#define ENABLE_SMART            0xD8
#define DISABLE_SMART           0xD9
#define RETURN_SMART_STATUS     0xDA
#define ENABLE_DISABLE_AUTO_OFFLINE 0xDB
#endif /* _WIN32_WINNT >= 0x0400 */

// end_winioctl


#if (NTDDI_VERSION >= NTDDI_VISTA)

//
// IOCTLs to query and modify attributes
// associated with partitions. These are
// persisted within the partition table.
//

#define IOCTL_DISK_GET_PARTITION_ATTRIBUTES CTL_CODE(IOCTL_DISK_BASE, 0x003a, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_SET_PARTITION_ATTRIBUTES CTL_CODE(IOCTL_DISK_BASE, 0x003b, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// IOCTL_DISK_GET_PARTITION_ATTRIBUTES
//
// Input Buffer:
//     None
//
// Output Buffer:
//     Structure of type GET_PARTITION_ATTRIBUTES
//

typedef struct _GET_PARTITION_ATTRIBUTES {

    //
    // Specifies the size of the
    // structure for versioning.
    //
    ULONG Version;

    //
    // For alignment purposes.
    //
    ULONG Reserved1;

    //
    // Specifies the partition
    // attributes.
    //
    ULONGLONG Attributes;

} GET_PARTITION_ATTRIBUTES, *PGET_PARTITION_ATTRIBUTES;

//
// IOCTL_DISK_SET_PARTITION_ATTRIBUTES
//
// Input Buffer:
//     Structure of type SET_PARTITION_ATTRIBUTES
//
// Output Buffer:
//     None
//

typedef struct _SET_PARTITION_ATTRIBUTES {

    //
    // Specifies the size of the
    // structure for versioning.
    //
    ULONG Version;

    //
    // Indicates whether to remember
    // these settings across reboots
    // or not.
    //
    BOOLEAN Persist;

    //
    // For alignment purposes.
    //
    BOOLEAN Reserved1[3];

    //
    // Specifies the new attributes.
    //
    ULONGLONG Attributes;

    //
    // Specifies the attributes
    // that are being modified.
    //
    ULONGLONG AttributesMask;

} SET_PARTITION_ATTRIBUTES, *PSET_PARTITION_ATTRIBUTES;


//
// IOCTLs to query and modify attributes
// associated with the given disk. These
// are persisted within the registry.
//

#define IOCTL_DISK_GET_DISK_ATTRIBUTES      CTL_CODE(IOCTL_DISK_BASE, 0x003c, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_DISK_SET_DISK_ATTRIBUTES      CTL_CODE(IOCTL_DISK_BASE, 0x003d, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define DISK_ATTRIBUTE_OFFLINE              0x0000000000000001
#define DISK_ATTRIBUTE_READ_ONLY            0x0000000000000002

//
// IOCTL_DISK_GET_DISK_ATTRIBUTES
//
// Input Buffer:
//     None
//
// Output Buffer:
//     Structure of type GET_DISK_ATTRIBUTES
//

typedef struct _GET_DISK_ATTRIBUTES {

    //
    // Specifies the size of the
    // structure for versioning.
    //
    ULONG Version;

    //
    // For alignment purposes.
    //
    ULONG Reserved1;

    //
    // Specifies the attributes
    // associated with the disk.
    //
    ULONGLONG Attributes;

} GET_DISK_ATTRIBUTES, *PGET_DISK_ATTRIBUTES;

//
// IOCTL_DISK_SET_DISK_ATTRIBUTES
//
// Input Buffer:
//     Structure of type SET_DISK_ATTRIBUTES
//
// Output Buffer:
//     None
//

typedef struct _SET_DISK_ATTRIBUTES {

    //
    // Specifies the size of the
    // structure for versioning.
    //
    ULONG Version;

    //
    // Indicates whether to remember
    // these settings across reboots
    // or not.
    //
    BOOLEAN Persist;

    //
    // Indicates whether the ownership
    // taken earlier is being released.
    //
    BOOLEAN RelinquishOwnership;

    //
    // For alignment purposes.
    //
    BOOLEAN Reserved1[2];

    //
    // Specifies the new attributes.
    //
    ULONGLONG Attributes;

    //
    // Specifies the attributes
    // that are being modified.
    //
    ULONGLONG AttributesMask;

    //
    // Specifies an identifier to be
    // associated  with  the caller.
    // This setting is not persisted
    // across reboots.
    //
    GUID Owner;

} SET_DISK_ATTRIBUTES, *PSET_DISK_ATTRIBUTES;


//
// IOCTL to determine if  the  disk is
// owned by the cluster service or not.
//

#define IOCTL_DISK_IS_CLUSTERED             CTL_CODE(IOCTL_DISK_BASE, 0x003e, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL_DISK_IS_CLUSTERED
//
// Input Buffer:
//     None
//
// Output Buffer:
//     Structure of type BOOLEAN
//


//
// IOCTLs to query and modify the current
// SAN settings. For instance, the policy
// associated with newly discovered disks.
//

#define IOCTL_DISK_GET_SAN_SETTINGS         CTL_CODE(IOCTL_DISK_BASE, 0x0080, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_SAN_SETTINGS         CTL_CODE(IOCTL_DISK_BASE, 0x0081, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// IOCTL_DISK_GET_SAN_SETTINGS
//
// Input Buffer:
//     None
//
// Output Buffer:
//     Structure of type DISK_SAN_SETTINGS
//

//
// IOCTL_DISK_SET_SAN_SETTINGS
//
// Input Buffer:
//     Structure of type DISK_SAN_SETTINGS
//
// Output Buffer:
//     None
//

typedef enum _DISK_SAN_POLICY {

    DiskSanPolicyUnknown,
    DiskSanPolicyOnline,
    DiskSanPolicyOfflineShared,
    DiskSanPolicyOffline

} DISK_SAN_POLICY, *PDISK_SAN_POLICY;

typedef struct _DISK_SAN_SETTINGS {

    //
    // Specifies the size of the
    // structure for versioning.
    //
    ULONG Version;

    //
    // Specifies the policy to be
    // applied to all new disks.
    //
    DISK_SAN_POLICY SanPolicy;

} DISK_SAN_SETTINGS, *PDISK_SAN_SETTINGS;


//
// IOCTLs to query and modify the context
// associated with snapshot disks created
// in hardware.
//

#define IOCTL_DISK_GET_SNAPSHOT_INFO        CTL_CODE(IOCTL_DISK_BASE, 0x0082, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_DISK_SET_SNAPSHOT_INFO        CTL_CODE(IOCTL_DISK_BASE, 0x0083, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// IOCTL_DISK_GET_SNAPSHOT_INFO
//
// Input Buffer:
//     None
//
// Output Buffer:
//     Structure of type DISK_SNAPSHOT_INFO
//

//
// IOCTL_DISK_SET_SNAPSHOT_INFO
//
// Input Buffer:
//     Structure of type DISK_SNAPSHOT_INFO
//
// Output Buffer:
//     None
//

typedef enum _DISK_SNAPSHOT_STATE {

    DiskSnapshotNormalDisk,
    DiskSnapshotSnapshotCheckRequired,
    DiskSnapshotPreSnapshot,
    DiskSnapshotSnapshotDisk

} DISK_SNAPSHOT_STATE, *PDISK_SNAPSHOT_STATE;

typedef struct _DISK_SNAPSHOT_INFO {

    //
    // Specifies the size of the
    // structure for versioning.
    //
    ULONG Version;

    //
    // Specifies the state that this
    // disk is in or the state to be
    // transitioned to.
    //
    DISK_SNAPSHOT_STATE State;

    //
    // Specifies a unique id  that
    // represents all of the disks
    // involved in this snapshot.
    //
    GUID SnapshotSetId;

    //
    // Specifies a unique id  that
    // represents this snapshot.
    //
    GUID SnapshotId;

    //
    // Specifies a unique id  that
    // represents the logical unit
    // whose snapshot was taken.
    //
    GUID LunId;

    //
    // Specifies the time when this
    // snapshot was taken.
    //
    LARGE_INTEGER CreationTimeStamp;

    //
    // Specifies the number of times
    // that  this  snapshot has been
    // imported.
    //
    ULONG ImportCount;

    //
    // Specifies attributes that are
    // associated with this snapshot.
    //
    ULONG Flags;

    //
    // Specifies the size in bytes of
    // the following field.
    //
    ULONG AdditionalDataSize;

    //
    // Specifies disk meta data that
    // needs to be  restored  in the
    // event of a fast recovery.
    //
    UCHAR AdditionalData[ANYSIZE_ARRAY];

} DISK_SNAPSHOT_INFO, *PDISK_SNAPSHOT_INFO;

#endif  // NTDDI_VERSION >= NTDDI_VISTA


//
// The following device control code is for the SIMBAD simulated bad
// sector facility. See SIMBAD.H in this directory for related structures.
//

#define IOCTL_DISK_SIMBAD               CTL_CODE(IOCTL_DISK_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Queue link for mapped addresses stored for unmapping.
//

typedef struct _MAPPED_ADDRESS {
    struct _MAPPED_ADDRESS *NextMappedAddress;
    PVOID MappedAddress;
    ULONG NumberOfBytes;
    LARGE_INTEGER IoAddress;
    ULONG BusNumber;
} MAPPED_ADDRESS, *PMAPPED_ADDRESS;

#if defined(_MSC_VER)
#if (_MSC_VER >= 1200)
#pragma warning(pop)
#endif
#endif

#ifdef __cplusplus
}
#endif

// begin_winioctl

#endif // _NTDDDISK_H_

// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddchgr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddchgr.h

Abstract:

    This is the include file that defines all constants and types for
    accessing medium changer devices.

--*/

#ifndef _NTDDCHGR_H_
#define _NTDDCHGR_H_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_CHANGER_DEVICE_NAME "\\Device\\Changer"

//
// NtDeviceIoControlFile IoControlCode values for changer devices.
//


// begin_winioctl

#define IOCTL_CHANGER_BASE                FILE_DEVICE_CHANGER

#define IOCTL_CHANGER_GET_PARAMETERS         CTL_CODE(IOCTL_CHANGER_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_GET_STATUS             CTL_CODE(IOCTL_CHANGER_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_GET_PRODUCT_DATA       CTL_CODE(IOCTL_CHANGER_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_SET_ACCESS             CTL_CODE(IOCTL_CHANGER_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_CHANGER_GET_ELEMENT_STATUS     CTL_CODE(IOCTL_CHANGER_BASE, 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS  CTL_CODE(IOCTL_CHANGER_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_SET_POSITION           CTL_CODE(IOCTL_CHANGER_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_EXCHANGE_MEDIUM        CTL_CODE(IOCTL_CHANGER_BASE, 0x0008, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_MOVE_MEDIUM            CTL_CODE(IOCTL_CHANGER_BASE, 0x0009, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_REINITIALIZE_TRANSPORT CTL_CODE(IOCTL_CHANGER_BASE, 0x000A, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_CHANGER_QUERY_VOLUME_TAGS      CTL_CODE(IOCTL_CHANGER_BASE, 0x000B, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)


// end_winioctl

//
// The following file contains the IOCTL_STORAGE class ioctls
//

#include <ntddstor.h>

#ifdef __cplusplus
extern "C" {
#endif

// begin_winioctl

#define MAX_VOLUME_ID_SIZE       36
#define MAX_VOLUME_TEMPLATE_SIZE 40

#define VENDOR_ID_LENGTH          8
#define PRODUCT_ID_LENGTH        16
#define REVISION_LENGTH           4
#define SERIAL_NUMBER_LENGTH     32

//
// Common structures describing elements.
//

typedef  enum _ELEMENT_TYPE {
    AllElements,        // As defined by SCSI
    ChangerTransport,   // As defined by SCSI
    ChangerSlot,        // As defined by SCSI
    ChangerIEPort,      // As defined by SCSI
    ChangerDrive,       // As defined by SCSI
    ChangerDoor,        // Front panel, used to access internal of cabinet.
    ChangerKeypad,      // Keypad/input on front panel.
    ChangerMaxElement   // Placeholder only. Not a valid type.
} ELEMENT_TYPE, *PELEMENT_TYPE;

typedef  struct _CHANGER_ELEMENT {
    ELEMENT_TYPE    ElementType;
    ULONG   ElementAddress;
} CHANGER_ELEMENT, *PCHANGER_ELEMENT;

typedef  struct _CHANGER_ELEMENT_LIST {
    CHANGER_ELEMENT Element;
    ULONG   NumberOfElements;
} CHANGER_ELEMENT_LIST , *PCHANGER_ELEMENT_LIST;


//
// Definitions for  IOCTL_CHANGER_GET_PARAMETERS
//

//
// Definitions for Features0 of GET_CHANGER_PARAMETERS
//

#define CHANGER_BAR_CODE_SCANNER_INSTALLED  0x00000001 // The medium-changer has a bar code scanner installed.
#define CHANGER_INIT_ELEM_STAT_WITH_RANGE   0x00000002 // The medium-changer has the ability to initialize elements within a specified range.
#define CHANGER_CLOSE_IEPORT                0x00000004 // The medium-changer has the ability to close the i/e port door.
#define CHANGER_OPEN_IEPORT                 0x00000008 // The medium-changer can open the i/e port door.

#define CHANGER_STATUS_NON_VOLATILE         0x00000010 // The medium-changer uses non-volatile memory for element status information.
#define CHANGER_EXCHANGE_MEDIA              0x00000020 // The medium-changer supports exchange operations.
#define CHANGER_CLEANER_SLOT                0x00000040 // The medium-changer has a fixed slot designated for cleaner cartridges.
#define CHANGER_LOCK_UNLOCK                 0x00000080 // The medium-changer can be (un)secured to (allow)prevent media removal.

#define CHANGER_CARTRIDGE_MAGAZINE          0x00000100 // The medium-changer uses cartridge magazines for some storage slots.
#define CHANGER_MEDIUM_FLIP                 0x00000200 // The medium-changer can flip medium.
#define CHANGER_POSITION_TO_ELEMENT         0x00000400 // The medium-changer can position the transport to a particular element.
#define CHANGER_REPORT_IEPORT_STATE         0x00000800 // The medium-changer can determine whether media is present
                                                       // in the IE Port.

#define CHANGER_STORAGE_DRIVE               0x00001000 // The medium-changer can use a drive as an independent storage element.
#define CHANGER_STORAGE_IEPORT              0x00002000 // The medium-changer can use a i/e port as an independent storage element.
#define CHANGER_STORAGE_SLOT                0x00004000 // The medium-changer can use a slot as an independent storage element.
#define CHANGER_STORAGE_TRANSPORT           0x00008000 // The medium-changer can use a transport as an independent storage element.

#define CHANGER_DRIVE_CLEANING_REQUIRED     0x00010000 // The drives controlled by the medium changer require periodic cleaning
                                                       // initiated by an application.
#define CHANGER_PREDISMOUNT_EJECT_REQUIRED  0x00020000 // The medium-changer requires a drive eject command to be issued, before a changer
                                                       // move / exchange command can be issued to the drive.

#define CHANGER_CLEANER_ACCESS_NOT_VALID    0x00040000 // The access bit in GES isn't valid for cleaner cartridges.
#define CHANGER_PREMOUNT_EJECT_REQUIRED     0x00080000 // The medium-changer requires a drive eject command to be issued
                                                       // before a move / exchange command can be issued with the drive as src/dst.

#define CHANGER_VOLUME_IDENTIFICATION       0x00100000 // The medium-changer supports volume identification.
#define CHANGER_VOLUME_SEARCH               0x00200000 // The medium-changer can search for volume information.
#define CHANGER_VOLUME_ASSERT               0x00400000 // The medium-changer can verify volume information.
#define CHANGER_VOLUME_REPLACE              0x00800000 // The medium-changer can replace volume information.
#define CHANGER_VOLUME_UNDEFINE             0x01000000 // The medium-changer can undefine volume information.

#define CHANGER_SERIAL_NUMBER_VALID         0x04000000 // The serial number reported in GetProductData is valid
                                                       // and unique.

#define CHANGER_DEVICE_REINITIALIZE_CAPABLE 0x08000000 // The medium-changer can be issued a ChangerReinitializeUnit.
#define CHANGER_KEYPAD_ENABLE_DISABLE       0x10000000 // Indicates that the keypad can be enabled/disabled.
#define CHANGER_DRIVE_EMPTY_ON_DOOR_ACCESS  0x20000000 // Drives must be empty before access via the door is possible.

#define CHANGER_RESERVED_BIT                0x80000000 // Will be used to indicate Features1 capability bits.


//
// Definitions for Features1 of GET_CHANGER_PARAMETERS
//

#define CHANGER_PREDISMOUNT_ALIGN_TO_SLOT   0x80000001 // The transport must be prepositioned to the slot prior to ejecting the media.
#define CHANGER_PREDISMOUNT_ALIGN_TO_DRIVE  0x80000002 // The transport must be prepositioned to the drive prior to ejecting the media.
#define CHANGER_CLEANER_AUTODISMOUNT        0x80000004 // The device will move the cleaner cartridge back into the slot when cleaning has completed.
#define CHANGER_TRUE_EXCHANGE_CAPABLE       0x80000008 // Device can do src -> dest2 exchanges.
#define CHANGER_SLOTS_USE_TRAYS             0x80000010 // Slots have removable trays, requiring multiple moves for inject/eject.
#define CHANGER_RTN_MEDIA_TO_ORIGINAL_ADDR  0x80000020 // Media must be returned to the slot from which it originated after a move to another element.
#define CHANGER_CLEANER_OPS_NOT_SUPPORTED   0x80000040 // Automated cleaning operations are not supported on this device.
#define CHANGER_IEPORT_USER_CONTROL_OPEN    0x80000080 // Indicates that user action is necessary to open a closed ieport.
#define CHANGER_IEPORT_USER_CONTROL_CLOSE   0x80000100 // Indicates that user action is necessary to close an opened ieport.
#define CHANGER_MOVE_EXTENDS_IEPORT         0x80000200 // Indicates that a move media to the ieport extends the tray.
#define CHANGER_MOVE_RETRACTS_IEPORT        0x80000400 // Indicates that a move media from the ieport retracts the tray.


//
// Definitions for MoveFrom, ExchangeFrom, and PositionCapabilities
//

#define CHANGER_TO_TRANSPORT    0x01 // The device can carry out the operation to a transport from the specified element.
#define CHANGER_TO_SLOT         0x02 // The device can carry out the operation to a slot from the specified element.
#define CHANGER_TO_IEPORT       0x04 // The device can carry out the operation to an IE Port from the specified element.
#define CHANGER_TO_DRIVE        0x08 // The device can carry out the operation to a drive from the specified element.

//
// Definitions for LockUnlockCapabilities
//

#define LOCK_UNLOCK_IEPORT      0x01 // The device can lock/unlock the ieport(s).
#define LOCK_UNLOCK_DOOR        0x02 // The device can lock/unlock the door(s).
#define LOCK_UNLOCK_KEYPAD      0x04 // The device can lock/unlock the keypad.

typedef  struct _GET_CHANGER_PARAMETERS {

    //
    // Size of the structure. Can be used for versioning.
    //

    ULONG Size;

    //
    // Number of N element(s) as defined by the Element Address Page (or equivalent...).
    //

    USHORT NumberTransportElements;
    USHORT NumberStorageElements;                // for data cartridges only
    USHORT NumberCleanerSlots;                   // for cleaner cartridges
    USHORT NumberIEElements;
    USHORT NumberDataTransferElements;

    //
    // Number of doors/front panels (allows user entry into the cabinet).
    //

    USHORT NumberOfDoors;

    //
    // The device-specific address (from user manual of the device) of the first N element. Used
    // by the UI to relate the various elements to the user.
    //

    USHORT FirstSlotNumber;
    USHORT FirstDriveNumber;
    USHORT FirstTransportNumber;
    USHORT FirstIEPortNumber;
    USHORT FirstCleanerSlotAddress;

    //
    // Indicates the capacity of each magazine, if they exist.
    //

    USHORT MagazineSize;

    //
    // Specifies the approximate number of seconds for when a cleaning should be completed.
    // Only applicable if drive cleaning is supported. See Features0.
    //

    ULONG DriveCleanTimeout;

    //
    // See features bits, above.
    //

    ULONG Features0;
    ULONG Features1;

    //
    // Bitmask defining Move from N element to element. Defined by Device Capabilities Page (or equivalent).
    // AND-masking with the TO_XXX values will indicate legal destinations.
    //

    UCHAR MoveFromTransport;
    UCHAR MoveFromSlot;
    UCHAR MoveFromIePort;
    UCHAR MoveFromDrive;

    //
    // Bitmask defining Exchange from N element to element. Defined by Device Capabilities Page (or equivalent).
    // AND-masking with the TO_XXX values will indicate legal destinations.
    //

    UCHAR ExchangeFromTransport;
    UCHAR ExchangeFromSlot;
    UCHAR ExchangeFromIePort;
    UCHAR ExchangeFromDrive;

    //
    // Bitmask defining which elements are capable of lock/unlock. Valid only if
    // CHANGER_LOCK_UNLOCK is set in Features0.
    //

    UCHAR LockUnlockCapabilities;

    //
    // Bitmask defining which elements valid for positioning operations. Valid only if
    // CHANGER_POSITION_TO_ELEMENT is set in Features0.
    //

    UCHAR PositionCapabilities;

    //
    // For future expansion.
    //

    UCHAR Reserved1[2];
    ULONG Reserved2[2];

} GET_CHANGER_PARAMETERS, * PGET_CHANGER_PARAMETERS;


//
// Definitions for IOCTL_CHANGER_GET_PRODUCT_DATA
//

typedef  struct _CHANGER_PRODUCT_DATA {

    //
    // Device manufacturer's name - based on inquiry data
    //

    UCHAR VendorId[VENDOR_ID_LENGTH];

    //
    // Product identification as defined by the vendor - based on Inquiry data
    //

    UCHAR ProductId[PRODUCT_ID_LENGTH];

    //
    // Product revision as defined by the vendor.
    //

    UCHAR Revision[REVISION_LENGTH];

    //
    // Vendor unique value used to globally identify this device. Can
    // be from Vital Product Data, for example.
    //

    UCHAR SerialNumber[SERIAL_NUMBER_LENGTH];

    //
    // Indicates device type of data transports, as defined by SCSI-2.
    //

    UCHAR DeviceType;

} CHANGER_PRODUCT_DATA, *PCHANGER_PRODUCT_DATA;


//
// Definitions for IOCTL_CHANGER_SET_ACCESS
//

#define LOCK_ELEMENT        0
#define UNLOCK_ELEMENT      1
#define EXTEND_IEPORT       2
#define RETRACT_IEPORT      3

typedef struct _CHANGER_SET_ACCESS {

    //
    // Element can be ChangerIEPort, ChangerDoor, ChangerKeypad
    //

    CHANGER_ELEMENT Element;

    //
    // See above for possible operations.
    //

    ULONG           Control;
} CHANGER_SET_ACCESS, *PCHANGER_SET_ACCESS;


//
// Definitions for IOCTL_CHANGER_GET_ELEMENT_STATUS
//

//
// Input buffer.
//

typedef struct _CHANGER_READ_ELEMENT_STATUS {

    //
    // List describing the elements and range on which to return information.
    //

    CHANGER_ELEMENT_LIST ElementList;

    //
    // Indicates whether volume tag information is to be returned.
    //

    BOOLEAN VolumeTagInfo;
} CHANGER_READ_ELEMENT_STATUS, *PCHANGER_READ_ELEMENT_STATUS;

//
// Output buffer.
//

typedef  struct _CHANGER_ELEMENT_STATUS {

    //
    // Element to which this structure refers.
    //

    CHANGER_ELEMENT Element;

    //
    // Address of the element from which the media was originally moved.
    // Valid if ELEMENT_STATUS_SVALID bit of Flags ULONG is set.
    // Needs to be converted to a zero-based offset from the device-unique value.
    //

    CHANGER_ELEMENT SrcElementAddress;

    //
    // See below.
    //

    ULONG Flags;

    //
    // See below for possible values.
    //

    ULONG ExceptionCode;

    //
    // Scsi Target Id of this element.
    // Valid only if ELEMENT_STATUS_ID_VALID is set in Flags.
    //

    UCHAR TargetId;

    //
    // LogicalUnitNumber of this element.
    // Valid only if ELEMENT_STATUS_LUN_VALID is set in Flags.
    //

    UCHAR Lun;
    USHORT Reserved;

    //
    // Primary volume identification for the media.
    // Valid only if ELEMENT_STATUS_PVOLTAG bit is set in Flags.
    //

    UCHAR PrimaryVolumeID[MAX_VOLUME_ID_SIZE];

    //
    // Alternate volume identification for the media.
    // Valid for two-sided media only, and pertains to the id. of the inverted side.
    // Valid only if ELEMENT_STATUS_AVOLTAG bit is set in Flags.
    //

    UCHAR AlternateVolumeID[MAX_VOLUME_ID_SIZE];

} CHANGER_ELEMENT_STATUS, *PCHANGER_ELEMENT_STATUS;

//
// Output buffer. This is same as CHANGER_ELEMENT_STATUS with
// the addition of product info fields. New applications should
// use this struct instead of the older CHANGER_ELEMENT_STATUS
//

typedef  struct _CHANGER_ELEMENT_STATUS_EX {

    //
    // Element to which this structure refers.
    //

    CHANGER_ELEMENT Element;

    //
    // Address of the element from which the media was originally moved.
    // Valid if ELEMENT_STATUS_SVALID bit of Flags ULONG is set.
    // Needs to be converted to a zero-based offset from the device-unique value.
    //

    CHANGER_ELEMENT SrcElementAddress;

    //
    // See below.
    //

    ULONG Flags;

    //
    // See below for possible values.
    //

    ULONG ExceptionCode;

    //
    // Scsi Target Id of this element.
    // Valid only if ELEMENT_STATUS_ID_VALID is set in Flags.
    //

    UCHAR TargetId;

    //
    // LogicalUnitNumber of this element.
    // Valid only if ELEMENT_STATUS_LUN_VALID is set in Flags.
    //

    UCHAR Lun;
    USHORT Reserved;

    //
    // Primary volume identification for the media.
    // Valid only if ELEMENT_STATUS_PVOLTAG bit is set in Flags.
    //

    UCHAR PrimaryVolumeID[MAX_VOLUME_ID_SIZE];

    //
    // Alternate volume identification for the media.
    // Valid for two-sided media only, and pertains to the id. of the inverted side.
    // Valid only if ELEMENT_STATUS_AVOLTAG bit is set in Flags.
    //

    UCHAR AlternateVolumeID[MAX_VOLUME_ID_SIZE];

    //
    // Vendor ID
    //
    UCHAR VendorIdentification[VENDOR_ID_LENGTH];

    //
    // Product ID
    //
    UCHAR ProductIdentification[PRODUCT_ID_LENGTH];

    //
    // Serial number
    //
    UCHAR SerialNumber[SERIAL_NUMBER_LENGTH];

} CHANGER_ELEMENT_STATUS_EX, *PCHANGER_ELEMENT_STATUS_EX;

//
// Possible flag values
//

#define ELEMENT_STATUS_FULL      0x00000001 // Element contains a unit of media.
#define ELEMENT_STATUS_IMPEXP    0x00000002 // Media in i/e port was placed there by an operator.
#define ELEMENT_STATUS_EXCEPT    0x00000004 // Element is in an abnormal state; check ExceptionCode field for more information.
#define ELEMENT_STATUS_ACCESS    0x00000008 // Access to the i/e port from the medium changer is allowed.
#define ELEMENT_STATUS_EXENAB    0x00000010 // Export of media is supported.
#define ELEMENT_STATUS_INENAB    0x00000020 // Import of media is supported.

#define ELEMENT_STATUS_PRODUCT_DATA 0x00000040 // Serial number valid for the drive

#define ELEMENT_STATUS_LUN_VALID 0x00001000 // Lun information is valid.
#define ELEMENT_STATUS_ID_VALID  0x00002000 // SCSI Id information is valid.
#define ELEMENT_STATUS_NOT_BUS   0x00008000 // Lun and SCSI Id fields are not on same bus as medium changer.
#define ELEMENT_STATUS_INVERT    0x00400000 // Media in element was inverted (valid only if ELEMENT_STATUS_SVALID bit is set)
#define ELEMENT_STATUS_SVALID    0x00800000 // SourceElementAddress field and ELEMENT_STATUS_INVERT bit are valid.

#define ELEMENT_STATUS_PVOLTAG   0x10000000 // Primary volume information is valid.
#define ELEMENT_STATUS_AVOLTAG   0x20000000 // Alternate volume information is valid.

//
// ExceptionCode values.
//

#define ERROR_LABEL_UNREADABLE    0x00000001 // Bar code scanner could not read bar code label.
#define ERROR_LABEL_QUESTIONABLE  0x00000002 // Label could be invalid due to unit attention condition.
#define ERROR_SLOT_NOT_PRESENT    0x00000004 // Slot is currently not addressable in the device.
#define ERROR_DRIVE_NOT_INSTALLED 0x00000008 // Drive is not installed.
#define ERROR_TRAY_MALFUNCTION    0x00000010 // Media tray is malfunctioning/broken.
#define ERROR_INIT_STATUS_NEEDED  0x00000011 // An Initialize Element Status command is needed.
#define ERROR_UNHANDLED_ERROR     0xFFFFFFFF // Unknown error condition


//
// Definitions for IOCTL_CHANGER_INITIALIZE_ELEMENT_STATUS
//

typedef struct _CHANGER_INITIALIZE_ELEMENT_STATUS {

    //
    // List describing the elements and range on which to initialize.
    //

    CHANGER_ELEMENT_LIST ElementList;

    //
    // Indicates whether a bar code scan should be used. Only applicable if
    // CHANGER_BAR_CODE_SCANNER_INSTALLED is set in Features0 of CHANGER_GET_PARAMETERS.
    //

    BOOLEAN BarCodeScan;
} CHANGER_INITIALIZE_ELEMENT_STATUS, *PCHANGER_INITIALIZE_ELEMENT_STATUS;


//
// Definitions for IOCTL_CHANGER_SET_POSITION
//

typedef struct _CHANGER_SET_POSITION {


    //
    // Indicates which transport to move.
    //

    CHANGER_ELEMENT Transport;

    //
    // Indicates the final destination of the transport.
    //

    CHANGER_ELEMENT Destination;

    //
    // Indicates whether the media currently carried by Transport, should be flipped.
    //

    BOOLEAN         Flip;
} CHANGER_SET_POSITION, *PCHANGER_SET_POSITION;


//
// Definitions for IOCTL_CHANGER_EXCHANGE_MEDIUM
//

typedef struct _CHANGER_EXCHANGE_MEDIUM {

    //
    // Indicates which transport to use for the exchange operation.
    //

    CHANGER_ELEMENT Transport;

    //
    // Indicates the source for the media that is to be moved.
    //

    CHANGER_ELEMENT Source;

    //
    // Indicates the final destination of the media originally at Source.
    //

    CHANGER_ELEMENT Destination1;

    //
    // Indicates the destination of the media moved from Destination1.
    //

    CHANGER_ELEMENT Destination2;

    //
    // Indicates whether the medium should be flipped.
    //

    BOOLEAN         Flip1;
    BOOLEAN         Flip2;
} CHANGER_EXCHANGE_MEDIUM, *PCHANGER_EXCHANGE_MEDIUM;


//
// Definitions for IOCTL_CHANGER_MOVE_MEDIUM
//

typedef struct _CHANGER_MOVE_MEDIUM {

    //
    // Indicates which transport to use for the move operation.
    //

    CHANGER_ELEMENT Transport;

    //
    // Indicates the source for the media that is to be moved.
    //

    CHANGER_ELEMENT Source;

    //
    // Indicates the destination of the media originally at Source.
    //

    CHANGER_ELEMENT Destination;

    //
    // Indicates whether the media should be flipped.
    //

    BOOLEAN         Flip;
} CHANGER_MOVE_MEDIUM, *PCHANGER_MOVE_MEDIUM;



//
// Definitions for IOCTL_QUERY_VOLUME_TAGS
//

//
// Input buffer.
//

typedef  struct _CHANGER_SEND_VOLUME_TAG_INFORMATION {

    //
    // Describes the starting element for which to return information.
    //

    CHANGER_ELEMENT StartingElement;

    //
    // Indicates the specific action to perform. See below.
    //

    ULONG ActionCode;

    //
    // Template used by the device to search for volume ids.
    //

    UCHAR VolumeIDTemplate[MAX_VOLUME_TEMPLATE_SIZE];
} CHANGER_SEND_VOLUME_TAG_INFORMATION, *PCHANGER_SEND_VOLUME_TAG_INFORMATION;


//
// Output buffer.
//

typedef struct _READ_ELEMENT_ADDRESS_INFO {

    //
    // Number of elements matching criteria set forth by ActionCode.
    //

    ULONG NumberOfElements;

    //
    // Array of CHANGER_ELEMENT_STATUS structures, one for each element that corresponded
    // with the information passed in with the CHANGER_SEND_VOLUME_TAG_INFORMATION structure.
    //

    CHANGER_ELEMENT_STATUS ElementStatus[1];
} READ_ELEMENT_ADDRESS_INFO, *PREAD_ELEMENT_ADDRESS_INFO;

//
// Possible ActionCode values. See Features0 of CHANGER_GET_PARAMETERS for compatibility with
// the current device.
//

#define SEARCH_ALL         0x0 // Translate - search all defined volume tags.
#define SEARCH_PRIMARY     0x1 // Translate - search only primary volume tags.
#define SEARCH_ALTERNATE   0x2 // Translate - search only alternate volume tags.
#define SEARCH_ALL_NO_SEQ  0x4 // Translate - search all defined volume tags but ignore sequence numbers.
#define SEARCH_PRI_NO_SEQ  0x5 // Translate - search only primary volume tags but ignore sequence numbers.
#define SEARCH_ALT_NO_SEQ  0x6 // Translate - search only alternate volume tags but ignore sequence numbers.

#define ASSERT_PRIMARY     0x8 // Assert - as the primary volume tag - if tag now undefined.
#define ASSERT_ALTERNATE   0x9 // Assert - as the alternate volume tag - if tag now undefined.

#define REPLACE_PRIMARY    0xA // Replace - the primary volume tag - current tag ignored.
#define REPLACE_ALTERNATE  0xB // Replace - the alternate volume tag - current tag ignored.

#define UNDEFINE_PRIMARY   0xC // Undefine - the primary volume tag - current tag ignored.
#define UNDEFINE_ALTERNATE 0xD // Undefine - the alternate volume tag - current tag ignored.


//
// Changer diagnostic test related definitions
//
typedef enum _CHANGER_DEVICE_PROBLEM_TYPE {
   DeviceProblemNone,
   DeviceProblemHardware,
   DeviceProblemCHMError,
   DeviceProblemDoorOpen,
   DeviceProblemCalibrationError,
   DeviceProblemTargetFailure,
   DeviceProblemCHMMoveError,
   DeviceProblemCHMZeroError,
   DeviceProblemCartridgeInsertError,
   DeviceProblemPositionError,
   DeviceProblemSensorError,
   DeviceProblemCartridgeEjectError,
   DeviceProblemGripperError,
   DeviceProblemDriveError
} CHANGER_DEVICE_PROBLEM_TYPE, *PCHANGER_DEVICE_PROBLEM_TYPE;

// end_winioctl

#ifdef __cplusplus
}
#endif

#endif // _NTDDCHGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddft.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddft.h

Abstract:

    This file contains NTFT definitions and prototypes.


--*/

#ifndef _NTDDFT_
#define _NTDDFT_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ntdskreg.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Control Codes
//

#define FTTYPE  ((ULONG)'f')

#define FT_SECONDARY_READ CTL_CODE(FTTYPE, 4, METHOD_OUT_DIRECT, FILE_READ_ACCESS)
#define FT_PRIMARY_READ   CTL_CODE(FTTYPE, 5, METHOD_OUT_DIRECT, FILE_READ_ACCESS)
#define FT_BALANCED_READ_MODE    CTL_CODE(FTTYPE, 6, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FT_SYNC_REDUNDANT_COPY   CTL_CODE(FTTYPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Used as input parameters to the SECONDARY and PRIMARY read device controls
//

typedef struct _FT_SPECIAL_READ {
    LARGE_INTEGER ByteOffset;
    ULONG         Length;
} FT_SPECIAL_READ, *PFT_SPECIAL_READ;

#if (NTDDI_VERSION < NTDDI_VISTA)

#define FT_INITIALIZE_SET CTL_CODE(FTTYPE, 0, METHOD_BUFFERED,   FILE_ANY_ACCESS)
#define FT_REGENERATE     CTL_CODE(FTTYPE, 1, METHOD_BUFFERED,   FILE_ANY_ACCESS)
#define FT_CONFIGURE      CTL_CODE(FTTYPE, 2, METHOD_NEITHER,    FILE_ANY_ACCESS)
#define FT_VERIFY         CTL_CODE(FTTYPE, 3, METHOD_BUFFERED,   FILE_ANY_ACCESS)
#define FT_SEQUENTIAL_WRITE_MODE CTL_CODE(FTTYPE, 8, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FT_PARALLEL_WRITE_MODE   CTL_CODE(FTTYPE, 9, METHOD_NEITHER,  FILE_ANY_ACCESS)
#define FT_QUERY_SET_STATE       CTL_CODE(FTTYPE,10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FT_CLUSTER_SET_MEMBER_STATE CTL_CODE(FTTYPE,11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define FT_CLUSTER_GET_MEMBER_STATE CTL_CODE(FTTYPE,12, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Used to find a partition in the system.
//

typedef struct _FT_CONTROL_BLOCK {
    USHORT     Type;
    USHORT     FtGroup;
} FT_CONTROL_BLOCK, *PFT_CONTROL_BLOCK;

#endif // NTDDI_VERSION < NTDDI_VISTA

//
// FT SYNC primary from secondary IOCTL
//

typedef struct _FT_SYNC_INFORMATION {
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER ByteCount;
} FT_SYNC_INFORMATION, *PFT_SYNC_INFORMATION;

//
// Define for registry information.
//

#define DISK_REGISTRY_KEY  "\\REGISTRY\\MACHINE\\SYSTEM\\DISK"

//
// Define for value name for registry information.
//

#define DISK_REGISTRY_VALUE "Information"

//
// Structures for config registry.
//

//
// The header for the registry information structure.
//

#include "pshpack4.h"
typedef struct _DISK_CONFIG_HEADER {

    ULONG Version;
    ULONG CheckSum;
    BOOLEAN DirtyShutdown;
    UCHAR Reserved[3];
    ULONG DiskInformationOffset;
    ULONG DiskInformationSize;
    ULONG FtInformationOffset;
    ULONG FtInformationSize;
    ULONG FtStripeWidth;
    ULONG FtPoolSize;
    ULONG NameOffset;  // Reserved for future.
    ULONG NameSize;    // Reserved for future.

} DISK_CONFIG_HEADER, *PDISK_CONFIG_HEADER;

#define DISK_INFORMATION_VERSION    0x03

//
// FT_STATE is an enumerated field that describes the state of the FT
// volume as a whole.
//

typedef enum _FT_STATE {

    FtStateOk,      // set is complete
    FtHasOrphan,    // set is running, but one member is turned off
    FtDisabled,     // set has been turned off - it cannot be used
    FtRegenerating, // member of set is being generated from check data
    FtInitializing, // set is being initialized
    FtCheckParity,  // check data is not in sync
    FtNoCheckData   // parity has not been initialized

} FT_STATE, *PFT_STATE;

//
// State information for an FT set.  The partition state enum is used to
// specify the state for the complete set.
//

typedef struct _FT_SET_INFORMATION {
    ULONG        NumberOfMembers;
    FT_TYPE      Type;
    FT_STATE     SetState;
} FT_SET_INFORMATION, *PFT_SET_INFORMATION;

//
// The description information for an FT component member.
//

typedef struct _FT_MEMBER_DESCRIPTION {

    USHORT        State;
    USHORT        ReservedShort;
    ULONG         Signature;
    ULONG         OffsetToPartitionInfo;
    ULONG         LogicalNumber;

} FT_MEMBER_DESCRIPTION, *PFT_MEMBER_DESCRIPTION;

//
// Definitions for FT volume state.
//

//
// When this state is set, FT assumes at boot time that the volume
// must be initialized and starts a system thread of execution to
// perform the initialization work.
//

#define FT_VOLUME_INITIALIZING 0x0001
#define FT_VOLUME_REGENERATING 0x0002

//
// The description information for an FT component.
//

typedef struct _FT_DESCRIPTION {

    USHORT   NumberOfMembers;
    USHORT   Type;
    ULONG    Reserved;

    //
    // The volume state will indicate which member is being regenerated
    //

    FT_STATE FtVolumeState;

    //
    // Array for NumberOfMembers
    //

    FT_MEMBER_DESCRIPTION FtMemberDescription[1];

} FT_DESCRIPTION, *PFT_DESCRIPTION;

//
// Header for all FT information.
//

typedef struct _FT_REGISTRY {

    USHORT NumberOfComponents;
    USHORT ReservedShort;

    //
    // An array of NumberOfComponents
    //

    FT_DESCRIPTION FtDescription[1];

} FT_REGISTRY, *PFT_REGISTRY;
#include "poppack.h"

#ifdef __cplusplus
}
#endif

#endif  // _NTDDFT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddft2.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddft2.h

Abstract:

    This header file defines new IOCTLs for the FTDISK driver to support
    the new FT API.


--*/

#ifndef _NTDDFT2_
#define _NTDDFT2_

#if _MSC_VER > 1000
#pragma once
#endif

#include <fttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// The name of the control device for the FT disk driver.
//

#define DD_FT_CONTROL_DEVICE_NAME   L"\\Device\\FtControl"
#define DD_DOS_FT_CONTROL_NAME      L"\\\\.\\FtControl"

//
// Control codes handled by the 'FtControl' device.
//

#define FTCONTROLTYPE   ((ULONG) 'g')
#define FT_ENUMERATE_LOGICAL_DISKS                  CTL_CODE(FTCONTROLTYPE, 2, METHOD_BUFFERED, FILE_READ_ACCESS)

//
// Output parameter for FT_ENUMERATE_LOGICAL_DISKS.
//

typedef struct _FT_ENUMERATE_LOGICAL_DISKS_OUTPUT {
    ULONG               NumberOfRootLogicalDisks;
    ULONG               Reserved;
    FT_LOGICAL_DISK_ID  RootLogicalDiskIds[1];
} FT_ENUMERATE_LOGICAL_DISKS_OUTPUT, *PFT_ENUMERATE_LOGICAL_DISKS_OUTPUT;

#if (NTDDI_VERSION < NTDDI_VISTA)

#define FT_CREATE_LOGICAL_DISK                      CTL_CODE(FTCONTROLTYPE, 0, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define FT_BREAK_LOGICAL_DISK                       CTL_CODE(FTCONTROLTYPE, 1, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define FT_QUERY_LOGICAL_DISK_INFORMATION           CTL_CODE(FTCONTROLTYPE, 3, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_ORPHAN_LOGICAL_DISK_MEMBER               CTL_CODE(FTCONTROLTYPE, 4, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define FT_REPLACE_LOGICAL_DISK_MEMBER              CTL_CODE(FTCONTROLTYPE, 5, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK    CTL_CODE(FTCONTROLTYPE, 6, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_INITIALIZE_LOGICAL_DISK                  CTL_CODE(FTCONTROLTYPE, 7, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK      CTL_CODE(FTCONTROLTYPE, 8, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_CHECK_IO                                 CTL_CODE(FTCONTROLTYPE, 9, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK        CTL_CODE(FTCONTROLTYPE, 10, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION       CTL_CODE(FTCONTROLTYPE, 12, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_CHANGE_NOTIFY                            CTL_CODE(FTCONTROLTYPE, 13, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_STOP_SYNC_OPERATIONS                     CTL_CODE(FTCONTROLTYPE, 14, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Control codes handles by FT logical disks.
//

#define FT_QUERY_LOGICAL_DISK_ID                    CTL_CODE(FTCONTROLTYPE, 100, METHOD_BUFFERED, FILE_READ_ACCESS)
#define FT_CREATE_PARTITION_LOGICAL_DISK            CTL_CODE(FTCONTROLTYPE, 101, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Input parameter for FT_CREATE_LOGICAL_DISK.
//

typedef struct _FT_CREATE_LOGICAL_DISK_INPUT {
    FT_LOGICAL_DISK_TYPE    LogicalDiskType;
    USHORT                  NumberOfMembers;
    USHORT                  ConfigurationInformationSize;
    FT_LOGICAL_DISK_ID      MemberArray[1];
} FT_CREATE_LOGICAL_DISK_INPUT, *PFT_CREATE_LOGICAL_DISK_INPUT;

//
// Output parameter for FT_CREATE_LOGICAL_DISK.
//

typedef struct _FT_CREATE_LOGICAL_DISK_OUTPUT {
    FT_LOGICAL_DISK_ID  NewLogicalDiskId;
} FT_CREATE_LOGICAL_DISK_OUTPUT, *PFT_CREATE_LOGICAL_DISK_OUTPUT;

//
// Input parameter for FT_BREAK_LOGICAL_DISK.
//

typedef struct _FT_BREAK_LOGICAL_DISK_INPUT {
    FT_LOGICAL_DISK_ID  RootLogicalDiskId;
} FT_BREAK_LOGICAL_DISK_INPUT, *PFT_BREAK_LOGICAL_DISK_INPUT;

//
// Input parameter for FT_QUERY_LOGICAL_DISK_INFORMATION.
//

typedef struct _FT_QUERY_LOGICAL_DISK_INFORMATION_INPUT {
    FT_LOGICAL_DISK_ID  LogicalDiskId;
} FT_QUERY_LOGICAL_DISK_INFORMATION_INPUT, *PFT_QUERY_LOGICAL_DISK_INFORMATION_INPUT;

//
// Output parameter for FT_QUERY_LOGICAL_DISK_INFORMATION.
//

typedef struct _FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT {
    FT_LOGICAL_DISK_TYPE    LogicalDiskType;
    LONGLONG                VolumeSize;
    USHORT                  NumberOfMembers;
    USHORT                  ConfigurationInformationSize;
    USHORT                  StateInformationSize;
    USHORT                  Reserved;
    FT_LOGICAL_DISK_ID      MemberArray[1];
} FT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT, *PFT_QUERY_LOGICAL_DISK_INFORMATION_OUTPUT;

//
// Input parameter for FT_ORPHAN_LOGICAL_DISK_MEMBER.
//

typedef struct _FT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT {
    FT_LOGICAL_DISK_ID  LogicalDiskId;
    USHORT              MemberNumberToOrphan;
    USHORT              Reserved[3];
} FT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT, *PFT_ORPHAN_LOGICAL_DISK_MEMBER_INPUT;

//
// Input parameter for FT_REPLACE_LOGICAL_DISK_MEMBER.
//

typedef struct _FT_REPLACE_LOGICAL_DISK_MEMBER_INPUT {
    FT_LOGICAL_DISK_ID  LogicalDiskId;
    USHORT              MemberNumberToReplace;
    USHORT              Reserved[3];
    FT_LOGICAL_DISK_ID  NewMemberLogicalDiskId;
} FT_REPLACE_LOGICAL_DISK_MEMBER_INPUT, *PFT_REPLACE_LOGICAL_DISK_MEMBER_INPUT;

//
// Output parameter for FT_REPLACE_LOGICAL_DISK_MEMBER.
//

typedef struct _FT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT {
    FT_LOGICAL_DISK_ID  NewLogicalDiskId;
} FT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT, *PFT_REPLACE_LOGICAL_DISK_MEMBER_OUTPUT;

//
// Input parameter for FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK.
//

typedef struct _FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT {
    FT_LOGICAL_DISK_ID  RootLogicalDiskId;
} FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT, *PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_INPUT;

//
// Output parameter for FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK.
//

typedef struct _FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT {
    USHORT  NumberOfCharactersInNtDeviceName;
    WCHAR   NtDeviceName[1];
} FT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT, *PFT_QUERY_NT_DEVICE_NAME_FOR_LOGICAL_DISK_OUTPUT;

//
// Input parameter for FT_INITIALIZE_LOGICAL_DISK.
//

typedef struct _FT_INITIALIZE_LOGICAL_DISK_INPUT {
    FT_LOGICAL_DISK_ID  RootLogicalDiskId;
    BOOLEAN             RegenerateOrphans;
} FT_INITIALIZE_LOGICAL_DISK_INPUT, *PFT_INITIALIZE_LOGICAL_DISK_INPUT;

//
// Input parameter for FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK.
//

typedef struct _FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT {
    FT_LOGICAL_DISK_ID  RootLogicalDiskId;
} FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT, *PFT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT;

//
// Output parameter for FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK.
//

typedef struct _FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT {
    UCHAR   DriveLetter;
} FT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT, *PFT_QUERY_DRIVE_LETTER_FOR_LOGICAL_DISK_OUTPUT;

//
// Input parameter for FT_CHECK_IO.
//

typedef struct _FT_CHECK_IO_INPUT {
    FT_LOGICAL_DISK_ID  LogicalDiskId;
} FT_CHECK_IO_INPUT, *PFT_CHECK_IO_INPUT;

//
// Output parameter for FT_CHECK_IO.
//

typedef struct _FT_CHECK_IO_OUTPUT {
    BOOLEAN IsIoOk;
} FT_CHECK_IO_OUTPUT, *PFT_CHECK_IO_OUTPUT;

//
// Input parameter for FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK.
//

typedef struct _FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT {
    FT_LOGICAL_DISK_ID  RootLogicalDiskId;
    UCHAR               DriveLetter;
} FT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT, *PFT_SET_DRIVE_LETTER_FOR_LOGICAL_DISK_INPUT;

//
// Input parameter for FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION.
//

typedef struct _FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT {
    ULONG       Signature;
    ULONG       Reserved;
    LONGLONG    Offset;
} FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT, *PFT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_INPUT;

//
// Output parameter for FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION.
//

typedef struct _FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT {
    USHORT  NumberOfCharactersInNtDeviceName;
    WCHAR   NtDeviceName[1];
} FT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT, *PFT_QUERY_NT_DEVICE_NAME_FOR_PARTITION_OUTPUT;

//
// Input parameter for FT_STOP_SYNC_OPERATIONS.
//

typedef struct _FT_STOP_SYNC_OPERATIONS_INPUT {
    FT_LOGICAL_DISK_ID RootLogicalDiskId;
} FT_STOP_SYNC_OPERATIONS_INPUT, *PFT_STOP_SYNC_OPERATIONS_INPUT;

//
// Output parameter for FT_QUERY_LOGICAL_DISK_ID.
//

typedef struct _FT_QUERY_LOGICAL_DISK_ID_OUTPUT {
    FT_LOGICAL_DISK_ID  RootLogicalDiskId;
} FT_QUERY_LOGICAL_DISK_ID_OUTPUT, *PFT_QUERY_LOGICAL_DISK_ID_OUTPUT;

//
// Output parameter for FT_CREATE_PARTITION_LOGICAL_DISK.
//

typedef struct _FT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT {
    FT_LOGICAL_DISK_ID  NewLogicalDiskId;
} FT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT, *PFT_CREATE_PARTITION_LOGICAL_DISK_OUTPUT;

#endif // < NTDDI_VISTA

#ifdef __cplusplus
}
#endif

#endif  // _NTDDFT2_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddmou.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddmou.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the mouse device.

--*/

#ifndef _NTDDMOU_
#define _NTDDMOU_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_MOUSE_DEVICE_NAME    "\\Device\\PointerClass"
#define DD_MOUSE_DEVICE_NAME_U L"\\Device\\PointerClass"

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_MOUSE_QUERY_ATTRIBUTES CTL_CODE(FILE_DEVICE_MOUSE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_MOUSE_INSERT_DATA      CTL_CODE(FILE_DEVICE_MOUSE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Declare the GUID that represents the device interface for mice.
//

#ifndef FAR
#define FAR
#endif

DEFINE_GUID( GUID_DEVINTERFACE_MOUSE, 0x378de44c, 0x56ef, 0x11d1,
             0xbc, 0x8c, 0x00, 0xa0, 0xc9, 0x14, 0x05, 0xdd );

//
// Obsolete device interface class GUID name.
// (use of above GUID_DEVINTERFACE_* name is recommended).
//

#define GUID_CLASS_MOUSE  GUID_DEVINTERFACE_MOUSE

//
// NtReadFile Output Buffer record structures for this device.
//

#if _MSC_VER >= 1200
#pragma warning(push)
#pragma warning(disable:4201) // nonstandard extension used : nameless struct/union
#endif

typedef struct _MOUSE_INPUT_DATA {

    //
    // Unit number.  E.g., for \Device\PointerPort0  the unit is '0',
    // for \Device\PointerPort1 the unit is '1', and so on.
    //

    USHORT UnitId;

    //
    // Indicator flags.
    //

    USHORT Flags;

    //
    // The transition state of the mouse buttons.
    //

    union {
        ULONG Buttons;
        struct  {
            USHORT  ButtonFlags;
            USHORT  ButtonData;
        };
    };


    //
    // The raw state of the mouse buttons.
    //

    ULONG RawButtons;

    //
    // The signed relative or absolute motion in the X direction.
    //

    LONG LastX;

    //
    // The signed relative or absolute motion in the Y direction.
    //

    LONG LastY;

    //
    // Device-specific additional information for the event.
    //

    ULONG ExtraInformation;

} MOUSE_INPUT_DATA, *PMOUSE_INPUT_DATA;

#if _MSC_VER >= 1200
#pragma warning(pop)
#endif

//
// Define the mouse button state indicators.
//

#define MOUSE_LEFT_BUTTON_DOWN   0x0001  // Left Button changed to down.
#define MOUSE_LEFT_BUTTON_UP     0x0002  // Left Button changed to up.
#define MOUSE_RIGHT_BUTTON_DOWN  0x0004  // Right Button changed to down.
#define MOUSE_RIGHT_BUTTON_UP    0x0008  // Right Button changed to up.
#define MOUSE_MIDDLE_BUTTON_DOWN 0x0010  // Middle Button changed to down.
#define MOUSE_MIDDLE_BUTTON_UP   0x0020  // Middle Button changed to up.

#define MOUSE_BUTTON_1_DOWN     MOUSE_LEFT_BUTTON_DOWN
#define MOUSE_BUTTON_1_UP       MOUSE_LEFT_BUTTON_UP
#define MOUSE_BUTTON_2_DOWN     MOUSE_RIGHT_BUTTON_DOWN
#define MOUSE_BUTTON_2_UP       MOUSE_RIGHT_BUTTON_UP
#define MOUSE_BUTTON_3_DOWN     MOUSE_MIDDLE_BUTTON_DOWN
#define MOUSE_BUTTON_3_UP       MOUSE_MIDDLE_BUTTON_UP

#define MOUSE_BUTTON_4_DOWN     0x0040
#define MOUSE_BUTTON_4_UP       0x0080
#define MOUSE_BUTTON_5_DOWN     0x0100
#define MOUSE_BUTTON_5_UP       0x0200

#define MOUSE_WHEEL             0x0400
#define MOUSE_HWHEEL		0x0800

//
// Define the mouse indicator flags.
//

#define MOUSE_MOVE_RELATIVE         0
#define MOUSE_MOVE_ABSOLUTE         1
#define MOUSE_VIRTUAL_DESKTOP    0x02  // the coordinates are mapped to the virtual desktop
#define MOUSE_ATTRIBUTES_CHANGED 0x04  // requery for mouse attributes
#if(_WIN32_WINNT >= 0x0600)
#define MOUSE_MOVE_NOCOALESCE    0x08  // do not coalesce WM_MOUSEMOVEs
#endif /* _WIN32_WINNT >= 0x0600 */

#define MOUSE_TERMSRV_SRC_SHADOW        0x100

//
// NtDeviceIoControlFile OutputBuffer record structures for
// IOCTL_MOUSE_QUERY_ATTRIBUTES.
//

typedef struct _MOUSE_ATTRIBUTES {

    //
    // Mouse ID value.  Used to distinguish between mouse types.
    //

    USHORT MouseIdentifier;

    //
    // Number of buttons located on the mouse.
    //

    USHORT NumberOfButtons;

    //
    // Specifies the rate at which the hardware reports mouse input
    // (reports per second).  This may not be applicable for every mouse device.
    //

    USHORT SampleRate;

    //
    // Length of the readahead buffer, in bytes.
    //

    ULONG  InputDataQueueLength;

} MOUSE_ATTRIBUTES, *PMOUSE_ATTRIBUTES;

//
// Define the mouse identifier types.
//

#define MOUSE_INPORT_HARDWARE       0x0001
#define MOUSE_I8042_HARDWARE        0x0002
#define MOUSE_SERIAL_HARDWARE       0x0004
#define BALLPOINT_I8042_HARDWARE    0x0008
#define BALLPOINT_SERIAL_HARDWARE   0x0010
#define WHEELMOUSE_I8042_HARDWARE   0x0020
#define WHEELMOUSE_SERIAL_HARDWARE  0x0040
#define MOUSE_HID_HARDWARE          0x0080
#define WHEELMOUSE_HID_HARDWARE     0x0100
#define HORIZONTAL_WHEEL_PRESENT    0x8000

//
// Generic NtDeviceIoControlFile Input Buffer record structure for
// various mouse IOCTLs.
//

typedef struct _MOUSE_UNIT_ID_PARAMETER {

    //
    // Unit identifier.  Specifies the device unit for which this
    // request is intended.
    //

    USHORT UnitId;

} MOUSE_UNIT_ID_PARAMETER, *PMOUSE_UNIT_ID_PARAMETER;

//
// Define the base values for the mouse error log packet's
// UniqueErrorValue field.
//

#define MOUSE_ERROR_VALUE_BASE        20000

#ifdef __cplusplus
}
#endif

#endif // _NTDDMOU_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddpar.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddpar.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Parallel device.


--*/

//
// Interface GUID
//
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntddpar.h>  in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntddpar.h>  in that source file a second time to instantiate the GUIDs
//
// #ifdef WANT_WDM
#ifndef FAR
#define FAR
#endif

#ifdef DEFINE_GUID

#if (NTDDI_VERSION >= NTDDI_WINXP) // Windows XP Version

DEFINE_GUID(GUID_DEVINTERFACE_PARALLEL, 0x97F76EF0, 0xF883, 0x11D0, 0xAF, 0x1F, 0x00, 0x00, 0xF8, 0x00, 0x84, 0x5C);
DEFINE_GUID(GUID_DEVINTERFACE_PARCLASS, 0x811FC6A5, 0xF728, 0x11D0, 0xA5, 0x37, 0x00, 0x00, 0xF8, 0x75, 0x3E, 0xD1);

//
// Obsolete device interface class GUID names.
// (use of above GUID_DEVINTERFACE_* names is recommended).
//

#define GUID_PARALLEL_DEVICE  GUID_DEVINTERFACE_PARALLEL
#define GUID_PARCLASS_DEVICE  GUID_DEVINTERFACE_PARCLASS

#else // if ( NTDDI_VERSION ... )

DEFINE_GUID(GUID_PARALLEL_DEVICE, 0x97F76EF0, 0xF883, 0x11D0, 0xAF, 0x1F, 0x00, 0x00, 0xF8, 0x00, 0x84, 0x5C);
DEFINE_GUID(GUID_PARCLASS_DEVICE, 0x811FC6A5, 0xF728, 0x11D0, 0xA5, 0x37, 0x00, 0x00, 0xF8, 0x75, 0x3E, 0xD1);

#endif // if ( NTDDI_VERSION ... )

#endif
// #endif

#ifndef _NTDDPAR_
#define _NTDDPAR_

#ifdef __cplusplus
extern "C" {
#endif

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_PAR_BASE                  FILE_DEVICE_PARALLEL_PORT
#define IOCTL_PAR_QUERY_INFORMATION     CTL_CODE(FILE_DEVICE_PARALLEL_PORT,1,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_PAR_SET_INFORMATION       CTL_CODE(FILE_DEVICE_PARALLEL_PORT,2,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Returns NULL terminated device ID string
//
#define IOCTL_PAR_QUERY_DEVICE_ID       CTL_CODE(FILE_DEVICE_PARALLEL_PORT,3,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Returns buffer size required for a call to IOCTL_PAR_QUERY_DEVICE_ID 
//   to succeed. This includes device ID size plus space for terminating NULL.
//
#define IOCTL_PAR_QUERY_DEVICE_ID_SIZE  CTL_CODE(FILE_DEVICE_PARALLEL_PORT,4,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_IEEE1284_GET_MODE         CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_IEEE1284_NEGOTIATE        CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_SET_WRITE_ADDRESS     CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_SET_READ_ADDRESS      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_GET_DEVICE_CAPS       CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_GET_DEFAULT_MODES     CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_PING                  CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Similar to IOCTL_PAR_QUERY_DEVICE_ID above, but includes (i.e., does 
//   not discard) the two byte size prefix returned by the device.
//
#define IOCTL_PAR_QUERY_RAW_DEVICE_ID   CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_ECP_HOST_RECOVERY     CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_GET_READ_ADDRESS      CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_GET_WRITE_ADDRESS     CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_PAR_TEST                  CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 20, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_PAR_IS_PORT_FREE          CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)

#if (NTDDI_VERSION >= NTDDI_WINXP) // Windows XP Version

// returns Location of the port - generally of the form: LPTx or LPTx.y or LPTx.y-z
#define IOCTL_PAR_QUERY_LOCATION        CTL_CODE(FILE_DEVICE_PARALLEL_PORT, 22, METHOD_BUFFERED, FILE_ANY_ACCESS)

#endif // if (NTDDI_VERSION ... )

//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

typedef struct _PAR_QUERY_INFORMATION{
       UCHAR Status;
} PAR_QUERY_INFORMATION, *PPAR_QUERY_INFORMATION;

typedef struct _PAR_SET_INFORMATION{
       UCHAR Init;
} PAR_SET_INFORMATION, *PPAR_SET_INFORMATION;

#define PARALLEL_INIT            0x1
#define PARALLEL_AUTOFEED        0x2
#define PARALLEL_PAPER_EMPTY     0x4
#define PARALLEL_OFF_LINE        0x8
#define PARALLEL_POWER_OFF       0x10
#define PARALLEL_NOT_CONNECTED   0x20
#define PARALLEL_BUSY            0x40
#define PARALLEL_SELECTED        0x80

//
// This is the structure returned by IOCTL_PAR_QUERY_DEVICE_ID_SIZE.
//

typedef struct _PAR_DEVICE_ID_SIZE_INFORMATION {
    ULONG   DeviceIdSize;
} PAR_DEVICE_ID_SIZE_INFORMATION, *PPAR_DEVICE_ID_SIZE_INFORMATION;


//
// These constants are used for usReadMask and usWriteMask components of the 
// PARCLASS_NEGOTIATION_MASK structure that is used for:
//
// IOCTL_IEEE1284_NEGOTIATE, 
// IOCTL_IEEE1284_GET_MODE, and 
// IOCTL_PAR_GET_DEFAULT_MODES.
//

typedef struct _PARCLASS_NEGOTIATION_MASK {
	USHORT      usReadMask;
	USHORT      usWriteMask;
} PARCLASS_NEGOTIATION_MASK, *PPARCLASS_NEGOTIATION_MASK;

#define NONE                0x0000
#define CENTRONICS          0x0001       /* Write Only */
#define IEEE_COMPATIBILITY  0x0002       /* Write Only */
#define NIBBLE              0x0004       /* Read Only */
#define CHANNEL_NIBBLE      0x0008       /* Read Only */
#define BYTE_BIDIR          0x0010       /* Read Only */
#define EPP_HW              0x0020
#define EPP_SW              0x0040
#define EPP_ANY             0x0060
#define BOUNDED_ECP         0x0080
#define ECP_HW_NOIRQ        0x0100      /* HWECP PIO */
#define ECP_HW_IRQ          0x0200      /* HWECP with IRQ */
#define ECP_SW              0x0400
#define ECP_ANY             0x0780

#ifdef __cplusplus
}
#endif

#endif  // _NTDDPAR_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddmodm.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddmodm.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the modem device.


--*/

#ifndef _NTDDMODM_
#define _NTDDMODM_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// NtDeviceIoControlFile IoControlCode values for this device.
//

#define IOCTL_MODEM_GET_PASSTHROUGH      CTL_CODE(FILE_DEVICE_MODEM, 1,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MODEM_SET_PASSTHROUGH      CTL_CODE(FILE_DEVICE_MODEM, 2,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_SET_DLE_MONITORING   CTL_CODE(FILE_DEVICE_MODEM, 3,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_GET_DLE              CTL_CODE(FILE_DEVICE_MODEM, 4,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_SET_DLE_SHIELDING    CTL_CODE(FILE_DEVICE_MODEM, 5,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_STOP_WAVE_RECEIVE    CTL_CODE(FILE_DEVICE_MODEM, 6,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_SEND_MESSAGE         CTL_CODE(FILE_DEVICE_MODEM, 7,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MODEM_GET_MESSAGE          CTL_CODE(FILE_DEVICE_MODEM, 8,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_MODEM_SEND_GET_MESSAGE     CTL_CODE(FILE_DEVICE_MODEM, 9,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_SEND_LOOPBACK_MESSAGE CTL_CODE(FILE_DEVICE_MODEM, 10,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_CHECK_FOR_MODEM      CTL_CODE(FILE_DEVICE_MODEM, 11,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_SET_MIN_POWER        CTL_CODE(FILE_DEVICE_MODEM, 12,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_MODEM_WATCH_FOR_RESUME     CTL_CODE(FILE_DEVICE_MODEM, 13,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_CANCEL_GET_SEND_MESSAGE    CTL_CODE(FILE_DEVICE_MODEM, 14,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_SET_SERVER_STATE           CTL_CODE(FILE_DEVICE_MODEM, 15,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define MODEM_NOPASSTHROUGH 0x00000000U
#define MODEM_PASSTHROUGH   0x00000001U
#define MODEM_DCDSNIFF      0x00000002U
#define MODEM_NOPASSTHROUGH_INC_SESSION_COUNT 0x00000003U

#define MODEM_DLE_MONITORING_OFF  0x00000000
#define MODEM_DLE_MONITORING_ON   0x00000001

#define MODEM_DLE_SHIELDING_OFF   0x00000000
#define MODEM_DLE_SHIELDING_ON    0x00000001

#define MODEM_OPEN_TYPE_TSP       0
#define MODEM_OPEN_TYPE_CLIENT    1
#define MODEM_OPEN_TYPE_WAVE      2

typedef struct _MODEM_MESSAGE {

    ULONG    TotalSize;
    ULONG    Flags;
    ULONG    SessionId;
    ULONG    RequestId;
    ULONG    Reserved[2];

} MODEM_MESSAGE, *PMODEM_MESSAGE;

#ifdef DEFINE_GUID

//
// Declare the GUID that represents the device interface for modems.
//

DEFINE_GUID(GUID_DEVINTERFACE_MODEM, 0x2c7089aa, 0x2e0e, 0x11d1, 0xb1, 0x14, 0x00, 0xc0, 0x4f, 0xc2, 0xaa, 0xe4);

//
// Obsolete device interface class GUID name.
// (use of above GUID_DEVINTERFACE_* name is recommended).
//

#define GUID_CLASS_MODEM  GUID_DEVINTERFACE_MODEM

#endif //DEFINE_GUID

#ifdef __cplusplus
}
#endif

#endif  // _NTDDMODM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddkbd.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddkbd.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the keyboard device.

--*/

#ifndef _NTDDKBD_
#define _NTDDKBD_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_KEYBOARD_DEVICE_NAME    "\\Device\\KeyboardClass"
#define DD_KEYBOARD_DEVICE_NAME_U L"\\Device\\KeyboardClass"

//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_KEYBOARD_QUERY_ATTRIBUTES      CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_SET_TYPEMATIC         CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0001, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_SET_INDICATORS        CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0002, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_QUERY_TYPEMATIC       CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0008, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_QUERY_INDICATORS      CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0010, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION   CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0020, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_INSERT_DATA           CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0040, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// These Device IO control query/set IME status to keyboard hardware.
//
#define IOCTL_KEYBOARD_QUERY_IME_STATUS      CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0400, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_KEYBOARD_SET_IME_STATUS        CTL_CODE(FILE_DEVICE_KEYBOARD, 0x0401, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Declare the GUID that represents the device interface for keyboards.
//
#ifndef FAR
#define FAR
#endif

DEFINE_GUID( GUID_DEVINTERFACE_KEYBOARD, 0x884b96c3, 0x56ef, 0x11d1, \
             0xbc, 0x8c, 0x00, 0xa0, 0xc9, 0x14, 0x05, 0xdd);

//
// Obsolete device interface class GUID name.
// (use of above GUID_DEVINTERFACE_* name is recommended).
//

#define GUID_CLASS_KEYBOARD  GUID_DEVINTERFACE_KEYBOARD


//
// NtReadFile Output Buffer record structures for this device.
//

typedef struct _KEYBOARD_INPUT_DATA {

    //
    // Unit number.  E.g., for \Device\KeyboardPort0 the unit is '0',
    // for \Device\KeyboardPort1 the unit is '1', and so on.
    //

    USHORT UnitId;

    //
    // The "make" scan code (key depression).
    //

    USHORT MakeCode;

    //
    // The flags field indicates a "break" (key release) and other
    // miscellaneous scan code information defined below.
    //

    USHORT Flags;

    USHORT Reserved;

    //
    // Device-specific additional information for the event.
    //

    ULONG ExtraInformation;

} KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA;

//
// Define the keyboard overrun MakeCode.
//

#define KEYBOARD_OVERRUN_MAKE_CODE    0xFF

//
// Define the keyboard input data Flags.
//

#define KEY_MAKE  0
#define KEY_BREAK 1
#define KEY_E0    2
#define KEY_E1    4
#define KEY_TERMSRV_SET_LED 8
#define KEY_TERMSRV_SHADOW  0x10
#define KEY_TERMSRV_VKPACKET 0x20


//
// NtDeviceIoControlFile Input/Output Buffer record structures for
// IOCTL_KEYBOARD_QUERY_TYPEMATIC/IOCTL_KEYBOARD_SET_TYPEMATIC.
//

typedef struct _KEYBOARD_TYPEMATIC_PARAMETERS {

    //
    // Unit identifier.  Specifies the device unit for which this
    // request is intended.
    //

    USHORT UnitId;

    //
    // Typematic rate, in repeats per second.
    //

    USHORT  Rate;

    //
    // Typematic delay, in milliseconds.
    //

    USHORT  Delay;

} KEYBOARD_TYPEMATIC_PARAMETERS, *PKEYBOARD_TYPEMATIC_PARAMETERS;

//
// NtDeviceIoControlFile OutputBuffer record structures for
// IOCTL_KEYBOARD_QUERY_ATTRIBUTES.
//

typedef struct _KEYBOARD_ID {
    UCHAR Type;       // Keyboard type
    UCHAR Subtype;    // Keyboard subtype (OEM-dependent value)
} KEYBOARD_ID, *PKEYBOARD_ID;

typedef struct _KEYBOARD_ATTRIBUTES {

    //
    // Keyboard ID value.  Used to distinguish between keyboard types.
    //

    KEYBOARD_ID KeyboardIdentifier;

    //
    // Scan code mode.
    //

    USHORT KeyboardMode;

    //
    // Number of function keys located on the keyboard.
    //

    USHORT NumberOfFunctionKeys;

    //
    // Number of LEDs located on the keyboard.
    //

    USHORT NumberOfIndicators;

    //
    // Total number of keys located on the keyboard.
    //

    USHORT NumberOfKeysTotal;

    //
    // Length of the typeahead buffer, in bytes.
    //

    ULONG  InputDataQueueLength;

    //
    // Minimum allowable values of keyboard typematic rate and delay.
    //

    KEYBOARD_TYPEMATIC_PARAMETERS KeyRepeatMinimum;

    //
    // Maximum allowable values of keyboard typematic rate and delay.
    //

    KEYBOARD_TYPEMATIC_PARAMETERS KeyRepeatMaximum;

} KEYBOARD_ATTRIBUTES, *PKEYBOARD_ATTRIBUTES;

//
// ENHANCED_KEYBOARD() is TRUE if the value for keyboard type indicates an
// Enhanced (101- or 102-key) or compatible keyboard.  The result is FALSE
// if the keyboard is an old-style AT keyboard (83- or 84- or 86-key keyboard).
//
#define ENHANCED_KEYBOARD(Id) ((Id).Type == 2 || (Id).Type == 4 || FAREAST_KEYBOARD(Id))
//
// Japanese keyboard(7) and Korean keyboard(8) are also Enhanced (101-)
// or compatible keyboard.
//
#define FAREAST_KEYBOARD(Id)  ((Id).Type == 7 || (Id).Type == 8)

//
// NtDeviceIoControlFile Input/Output Buffer record structures for
// IOCTL_KEYBOARD_QUERY_INDICATORS/IOCTL_KEYBOARD_SET_INDICATORS.
//

typedef struct _KEYBOARD_INDICATOR_PARAMETERS {

    //
    // Unit identifier.  Specifies the device unit for which this
    // request is intended.
    //

    USHORT UnitId;

    //
    // LED indicator state.
    //

    USHORT    LedFlags;

} KEYBOARD_INDICATOR_PARAMETERS, *PKEYBOARD_INDICATOR_PARAMETERS;

//
// NtDeviceIoControlFile Output Buffer record structures for
// IOCTL_KEYBOARD_QUERY_INDICATOR_TRANSLATION.
//

typedef struct _INDICATOR_LIST {

    //
    // The "make" scan code (key depression).
    //

    USHORT MakeCode;

    //
    // The associated LED indicators.
    //

    USHORT IndicatorFlags;

} INDICATOR_LIST, *PINDICATOR_LIST;

typedef struct _KEYBOARD_INDICATOR_TRANSLATION {

    //
    // Number of entries in IndicatorList.
    //

    USHORT NumberOfIndicatorKeys;

    //
    // List of the scancode-to-indicator mappings.
    //

    INDICATOR_LIST IndicatorList[1];

} KEYBOARD_INDICATOR_TRANSLATION, *PKEYBOARD_INDICATOR_TRANSLATION;

//
// Define the keyboard indicators.
//

#define KEYBOARD_LED_INJECTED     0x8000 //Used by Terminal Server
#define KEYBOARD_SHADOW           0x4000 //Used by Terminal Server
//#if defined(FE_SB) || defined(WINDOWS_FE) || defined(DBCS)
#define KEYBOARD_KANA_LOCK_ON     8 // Japanese keyboard
//#endif // defined(FE_SB) || defined(WINDOWS_FE) || defined(DBCS)
#define KEYBOARD_CAPS_LOCK_ON     4
#define KEYBOARD_NUM_LOCK_ON      2
#define KEYBOARD_SCROLL_LOCK_ON   1

//
// Generic NtDeviceIoControlFile Input Buffer record structure for
// various keyboard IOCTLs.
//

typedef struct _KEYBOARD_UNIT_ID_PARAMETER {

    //
    // Unit identifier.  Specifies the device unit for which this
    // request is intended.
    //

    USHORT UnitId;

} KEYBOARD_UNIT_ID_PARAMETER, *PKEYBOARD_UNIT_ID_PARAMETER;

//
// Define the base values for the keyboard error log packet's
// UniqueErrorValue field.
//

#define KEYBOARD_ERROR_VALUE_BASE        10000

//
// NtDeviceIoControlFile Input/Output Buffer record structures for
// IOCTL_KEYBOARD_QUERY_IME_STATUS/IOCTL_KEYBOARD_SET_IME_STATUS.
//

typedef struct _KEYBOARD_IME_STATUS {

    //
    // Unit identifier.  Specifies the device unit for which this
    // request is intended.
    //

    USHORT UnitId;

    //
    // Ime open or close status.
    //
    ULONG ImeOpen;

    //
    // Ime conversion status.
    //
    ULONG ImeConvMode;

} KEYBOARD_IME_STATUS, *PKEYBOARD_IME_STATUS;

#ifdef __cplusplus
}
#endif

#endif // _NTDDKBD_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NtDDNdis.h ===
/*++ BUILD Version: 0001        // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddndis.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Network driver interface device.

Author:

    NDIS/ATM Development Team

Revision History:

    added the correct values for NDIS 3.0.
    added Pnp IoCTLs and structures
    added general co ndis oids.
    added PnP and PM OIDs.

--*/

#ifndef _NTDDNDIS_
#define _NTDDNDIS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
#include <ifdef.h>
#include <devpkey.h>
#include <pciprop.h>
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//
// Something to identify new (LH Server and up) applications. 
// User-mode only. For drivers, NDIS_SUPPORT_NDIS61 is already
// defined in ndismain.w.
//
#if !defined(NDIS_SUPPORT_NDIS61)
#if  (defined (UM_NDIS61))
#define NDIS_SUPPORT_NDIS61      1
#else
#define NDIS_SUPPORT_NDIS61      0
#endif
#endif // !defined(NDIS_SUPPORT_NDIS61)

//
// Device Name - this string is the name of the device. It is the name
// that should be passed to NtOpenFile when accessing the device.

//
// Note: For devices that support multiple units, it should be suffixed
//       with the Ascii representation of the unit number.
//

#define DD_NDIS_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning: Remember that the low two bits of the code specify how the
//          buffers are passed to the driver!
//

#define _NDIS_CONTROL_CODE(request,method) \
            CTL_CODE(FILE_DEVICE_PHYSICAL_NETCARD, request, method, FILE_ANY_ACCESS)

#define IOCTL_NDIS_QUERY_GLOBAL_STATS   _NDIS_CONTROL_CODE(0, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_QUERY_ALL_STATS      _NDIS_CONTROL_CODE(1, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_DO_PNP_OPERATION     _NDIS_CONTROL_CODE(2, METHOD_BUFFERED)
#define IOCTL_NDIS_QUERY_SELECTED_STATS _NDIS_CONTROL_CODE(3, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_ENUMERATE_INTERFACES _NDIS_CONTROL_CODE(4, METHOD_BUFFERED)
#define IOCTL_NDIS_ADD_TDI_DEVICE       _NDIS_CONTROL_CODE(5, METHOD_BUFFERED)
#define IOCTL_NDIS_GET_LOG_DATA         _NDIS_CONTROL_CODE(7, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_GET_VERSION          _NDIS_CONTROL_CODE(8, METHOD_BUFFERED)

#define IOCTL_NDIS_RESERVED1            _NDIS_CONTROL_CODE(9, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED2            _NDIS_CONTROL_CODE(0xA, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED3            _NDIS_CONTROL_CODE(0xB, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED4            _NDIS_CONTROL_CODE(0xC, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED5    CTL_CODE(FILE_DEVICE_PHYSICAL_NETCARD, 0xD, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_NDIS_RESERVED6    CTL_CODE(FILE_DEVICE_PHYSICAL_NETCARD, 0xE, METHOD_BUFFERED, FILE_WRITE_ACCESS)
#define IOCTL_NDIS_RESERVED7            _NDIS_CONTROL_CODE(0xF, METHOD_OUT_DIRECT)
#define IOCTL_NDIS_RESERVED8            _NDIS_CONTROL_CODE(0x10, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED9            _NDIS_CONTROL_CODE(0x11, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED10           _NDIS_CONTROL_CODE(0x12, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED11           _NDIS_CONTROL_CODE(0x13, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED12           _NDIS_CONTROL_CODE(0x14, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED13           _NDIS_CONTROL_CODE(0x15, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED14           _NDIS_CONTROL_CODE(0x16, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED15           _NDIS_CONTROL_CODE(0x17, METHOD_BUFFERED)
#define IOCTL_NDIS_RESERVED16           _NDIS_CONTROL_CODE(0x18, METHOD_BUFFERED)


//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

//
// This is the type of an NDIS OID value.
//

typedef ULONG NDIS_OID, *PNDIS_OID;

//
// IOCTL_NDIS_QUERY_ALL_STATS returns a sequence of these, packed
// together.  This structure is unaligned because not all statistics
// have a length that is a ULONG multiple.
//

typedef struct _NDIS_STATISTICS_VALUE
{
    NDIS_OID    Oid;
    ULONG       DataLength;
    UCHAR       Data[1];            // variable length
} NDIS_STATISTICS_VALUE;

typedef NDIS_STATISTICS_VALUE UNALIGNED *PNDIS_STATISTICS_VALUE;

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
typedef struct _NDIS_STATISTICS_VALUE_EX
{
    NDIS_OID    Oid;
    ULONG       DataLength;         // the length of the OID data
    ULONG       Length;             // the length of this instance of NDIS_STATISTICS_VALUE_EX
    UCHAR       Data[1];            // variable length
} NDIS_STATISTICS_VALUE_EX;

typedef NDIS_STATISTICS_VALUE_EX UNALIGNED *PNDIS_STATISTICS_VALUE_EX;
#endif // (NTDDI_VERSION >= NTDDI_VISTA)


//
// Structure used to define a self-contained variable data structure
//
typedef struct _NDIS_VAR_DATA_DESC
{
    USHORT      Length;         // # of octects of data
    USHORT      MaximumLength;  // # of octects available
    ULONG_PTR   Offset;         // Offset of data relative to the descriptor
} NDIS_VAR_DATA_DESC, *PNDIS_VAR_DATA_DESC;

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif // !GUID_DEFINED

//
// NDIS Object Types used in NDIS_OBJECT_HEADER
//
#define NDIS_OBJECT_TYPE_DEFAULT                            0x80    // used when object type is implicit in the API call
#define NDIS_OBJECT_TYPE_MINIPORT_INIT_PARAMETERS           0x81    // used by NDIS in NDIS_MINIPORT_INIT_PARAMETERS
#define NDIS_OBJECT_TYPE_SG_DMA_DESCRIPTION                 0x83    // used by miniport drivers in NDIS_SG_DMA_DESCRIPTION
#define NDIS_OBJECT_TYPE_MINIPORT_INTERRUPT                 0x84    // used by miniport drivers in NDIS_MINIPORT_INTERRUPT_EX
#define NDIS_OBJECT_TYPE_DEVICE_OBJECT_ATTRIBUTES           0x85    // used by miniport or filter drivers in NDIS_DEVICE_OBJECT_ATTRIBUTES
#define NDIS_OBJECT_TYPE_BIND_PARAMETERS                    0x86    // used by NDIS in NDIS_BIND_PARAMETERS
#define NDIS_OBJECT_TYPE_OPEN_PARAMETERS                    0x87    // used by protocols in NDIS_OPEN_PARAMETERS
#define NDIS_OBJECT_TYPE_RSS_CAPABILITIES                   0x88    // used by miniport in NDIS_RECEIVE_SCALE_CAPABILITIES
#define NDIS_OBJECT_TYPE_RSS_PARAMETERS                     0x89    // used by miniport and protocol in NDIS_RECEIVE_SCALE_PARAMETERS
#define NDIS_OBJECT_TYPE_MINIPORT_DRIVER_CHARACTERISTICS    0x8A
#define NDIS_OBJECT_TYPE_FILTER_DRIVER_CHARACTERISTICS      0x8B
#define NDIS_OBJECT_TYPE_FILTER_PARTIAL_CHARACTERISTICS     0x8C
#define NDIS_OBJECT_TYPE_FILTER_ATTRIBUTES                  0x8D
#define NDIS_OBJECT_TYPE_CLIENT_CHIMNEY_OFFLOAD_GENERIC_CHARACTERISTICS     0x8E
#define NDIS_OBJECT_TYPE_PROVIDER_CHIMNEY_OFFLOAD_GENERIC_CHARACTERISTICS   0x8F
#define NDIS_OBJECT_TYPE_CO_PROTOCOL_CHARACTERISTICS        0x90
#define NDIS_OBJECT_TYPE_CO_MINIPORT_CHARACTERISTICS        0x91
#define NDIS_OBJECT_TYPE_MINIPORT_PNP_CHARACTERISTICS       0x92
#define NDIS_OBJECT_TYPE_CLIENT_CHIMNEY_OFFLOAD_CHARACTERISTICS     0x93
#define NDIS_OBJECT_TYPE_PROVIDER_CHIMNEY_OFFLOAD_CHARACTERISTICS   0x94
#define NDIS_OBJECT_TYPE_PROTOCOL_DRIVER_CHARACTERISTICS    0x95
#define NDIS_OBJECT_TYPE_REQUEST_EX                         0x96
#define NDIS_OBJECT_TYPE_OID_REQUEST                        0x96
#define NDIS_OBJECT_TYPE_TIMER_CHARACTERISTICS              0x97
#define NDIS_OBJECT_TYPE_STATUS_INDICATION                  0x98
#define NDIS_OBJECT_TYPE_FILTER_ATTACH_PARAMETERS           0x99
#define NDIS_OBJECT_TYPE_FILTER_PAUSE_PARAMETERS            0x9A
#define NDIS_OBJECT_TYPE_FILTER_RESTART_PARAMETERS          0x9B
#define NDIS_OBJECT_TYPE_PORT_CHARACTERISTICS               0x9C
#define NDIS_OBJECT_TYPE_PORT_STATE                         0x9D
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_REGISTRATION_ATTRIBUTES       0x9E
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_GENERAL_ATTRIBUTES            0x9F
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_OFFLOAD_ATTRIBUTES            0xA0
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_NATIVE_802_11_ATTRIBUTES      0xA1
#define NDIS_OBJECT_TYPE_RESTART_GENERAL_ATTRIBUTES                     0xA2
#define NDIS_OBJECT_TYPE_PROTOCOL_RESTART_PARAMETERS                    0xA3
#define NDIS_OBJECT_TYPE_MINIPORT_ADD_DEVICE_REGISTRATION_ATTRIBUTES    0xA4
#define NDIS_OBJECT_TYPE_CO_CALL_MANAGER_OPTIONAL_HANDLERS              0xA5
#define NDIS_OBJECT_TYPE_CO_CLIENT_OPTIONAL_HANDLERS                    0xA6
#define NDIS_OBJECT_TYPE_OFFLOAD                                        0xA7
#define NDIS_OBJECT_TYPE_OFFLOAD_ENCAPSULATION                          0xA8
#define NDIS_OBJECT_TYPE_CONFIGURATION_OBJECT                           0xA9
#define NDIS_OBJECT_TYPE_DRIVER_WRAPPER_OBJECT                          0xAA
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_OBJECT_TYPE_HD_SPLIT_ATTRIBUTES                            0xAB
#endif // (NDIS_SUPPORT_NDIS61)
#define NDIS_OBJECT_TYPE_NSI_NETWORK_RW_STRUCT                          0xAC
#define NDIS_OBJECT_TYPE_NSI_COMPARTMENT_RW_STRUCT                      0xAD
#define NDIS_OBJECT_TYPE_NSI_INTERFACE_PERSIST_RW_STRUCT                0xAE
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_OBJECT_TYPE_MINIPORT_ADAPTER_HARDWARE_ASSIST_ATTRIBUTES    0xAF
#endif // (NDIS_SUPPORT_NDIS61)

typedef struct _NDIS_OBJECT_HEADER
{
    UCHAR   Type;
    UCHAR   Revision;
    USHORT  Size;
} NDIS_OBJECT_HEADER, *PNDIS_OBJECT_HEADER;

#define NDIS_OBJECT_REVISION_1                  1

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)

//
// flags for NDIS_STATISTICS_INFO->SupportedStatistics structure
//
#define NDIS_STATISTICS_FLAGS_VALID_DIRECTED_FRAMES_RCV             0x00000001
#define NDIS_STATISTICS_FLAGS_VALID_MULTICAST_FRAMES_RCV            0x00000002
#define NDIS_STATISTICS_FLAGS_VALID_BROADCAST_FRAMES_RCV            0x00000004
#define NDIS_STATISTICS_FLAGS_VALID_BYTES_RCV                       0x00000008
#define NDIS_STATISTICS_FLAGS_VALID_RCV_DISCARDS                    0x00000010
#define NDIS_STATISTICS_FLAGS_VALID_RCV_ERROR                       0x00000020
#define NDIS_STATISTICS_FLAGS_VALID_DIRECTED_FRAMES_XMIT            0x00000040
#define NDIS_STATISTICS_FLAGS_VALID_MULTICAST_FRAMES_XMIT           0x00000080
#define NDIS_STATISTICS_FLAGS_VALID_BROADCAST_FRAMES_XMIT           0x00000100
#define NDIS_STATISTICS_FLAGS_VALID_BYTES_XMIT                      0x00000200
#define NDIS_STATISTICS_FLAGS_VALID_XMIT_ERROR                      0x00000400
#define NDIS_STATISTICS_FLAGS_VALID_XMIT_DISCARDS                   0x00008000
#define NDIS_STATISTICS_FLAGS_VALID_DIRECTED_BYTES_RCV              0x00010000
#define NDIS_STATISTICS_FLAGS_VALID_MULTICAST_BYTES_RCV             0x00020000
#define NDIS_STATISTICS_FLAGS_VALID_BROADCAST_BYTES_RCV             0x00040000
#define NDIS_STATISTICS_FLAGS_VALID_DIRECTED_BYTES_XMIT             0x00080000
#define NDIS_STATISTICS_FLAGS_VALID_MULTICAST_BYTES_XMIT            0x00100000
#define NDIS_STATISTICS_FLAGS_VALID_BROADCAST_BYTES_XMIT            0x00200000


#define NDIS_STATISTICS_INFO_REVISION_1  1
//
// structure used in OID_GEN_STATISTICS
//
typedef struct _NDIS_STATISTICS_INFO
{
    NDIS_OBJECT_HEADER          Header;
    ULONG                       SupportedStatistics;
    ULONG64                     ifInDiscards;           // OID_GEN_RCV_ERROR + OID_GEN_RCV_NO_BUFFER = OID_GEN_RCV_DISCARDS
    ULONG64                     ifInErrors;             // OID_GEN_RCV_ERROR
    ULONG64                     ifHCInOctets;           // OID_GEN_BYTES_RCV = OID_GEN_DIRECTED_BYTES_RCV + OID_GEN_MULTICAST_BYTES_RCV + OID_GEN_BROADCAST_BYTES_RCV
    ULONG64                     ifHCInUcastPkts;        // OID_GEN_DIRECTED_FRAMES_RCV
    ULONG64                     ifHCInMulticastPkts;    // OID_GEN_MULTICAST_FRAMES_RCV
    ULONG64                     ifHCInBroadcastPkts;    // OID_GEN_BROADCAST_FRAMES_RCV
    ULONG64                     ifHCOutOctets;          // OID_GEN_BYTES_XMIT = OID_GEN_DIRECTED_BYTES_XMIT + OID_GEN_MULTICAST_BYTES_XMIT + OID_GEN_BROADCAST_BYTES_XMIT
    ULONG64                     ifHCOutUcastPkts;       // OID_GEN_DIRECTED_FRAMES_XMIT
    ULONG64                     ifHCOutMulticastPkts;   // OID_GEN_MULTICAST_FRAMES_XMIT
    ULONG64                     ifHCOutBroadcastPkts;   // OID_GEN_BROADCAST_FRAMES_XMIT
    ULONG64                     ifOutErrors;            // OID_GEN_XMIT_ERROR
    ULONG64                     ifOutDiscards;          // OID_GEN_XMIT_DISCARDS
    ULONG64                     ifHCInUcastOctets;      // OID_GEN_DIRECTED_BYTES_RCV    
    ULONG64                     ifHCInMulticastOctets;  // OID_GEN_MULTICAST_BYTES_RCV
    ULONG64                     ifHCInBroadcastOctets;  // OID_GEN_BROADCAST_BYTES_RCV        
    ULONG64                     ifHCOutUcastOctets;     // OID_GEN_DIRECTED_BYTES_XMIT    
    ULONG64                     ifHCOutMulticastOctets; // OID_GEN_MULTICAST_BYTES_XMIT
    ULONG64                     ifHCOutBroadcastOctets; // OID_GEN_BROADCAST_BYTES_XMIT                
}NDIS_STATISTICS_INFO, *PNDIS_STATISTICS_INFO;

#define NDIS_SIZEOF_STATISTICS_INFO_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_STATISTICS_INFO, ifHCOutBroadcastOctets)
//
//  interrupt moderation structures and definitions
//

//
// enum value used in NDIS_INTERRUPT_MODERATION_PARAMETERS structure
//
typedef enum _NDIS_INTERRUPT_MODERATION
{
    NdisInterruptModerationUnknown,
    NdisInterruptModerationNotSupported,
    NdisInterruptModerationEnabled,
    NdisInterruptModerationDisabled
} NDIS_INTERRUPT_MODERATION, *PNDIS_INTERRUPT_MODERATION;

//
// Bits used in Flags parameter of NDIS_INTERRUPT_MODERATION_PARAMETERS structure:
//    
#define NDIS_INTERRUPT_MODERATION_CHANGE_NEEDS_RESET            0x00000001
#define NDIS_INTERRUPT_MODERATION_CHANGE_NEEDS_REINITIALIZE     0x00000002


//
// structure used in OID_GEN_INTERRUPT_MODERATION
//

#define NDIS_INTERRUPT_MODERATION_PARAMETERS_REVISION_1    1

typedef struct _NDIS_INTERRUPT_MODERATION_PARAMETERS
{
    NDIS_OBJECT_HEADER Header;
    ULONG Flags;
    NDIS_INTERRUPT_MODERATION InterruptModeration;
}NDIS_INTERRUPT_MODERATION_PARAMETERS, *PNDIS_INTERRUPT_MODERATION_PARAMETERS;

#define NDIS_SIZEOF_INTERRUPT_MODERATION_PARAMETERS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_INTERRUPT_MODERATION_PARAMETERS, InterruptModeration)

//
// structure used in OID_GEN_TIMEOUT_DPC_REQUEST_CAPABILITIES
//

#define NDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES_REVISION_1  1

typedef struct _NDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES
{
    NDIS_OBJECT_HEADER      Header;
    ULONG                   Flags;
    ULONG                   TimeoutArrayLength;
    ULONG                   TimeoutArray[1];
}NDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES, *PNDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES;

#define NDIS_SIZEOF_TIMEOUT_DPC_REQUEST_CAPABILITIES_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_TIMEOUT_DPC_REQUEST_CAPABILITIES, TimeoutArray)

//
// PCI custom properties. used in OID_GEN_PCI_DEVICE_CUSTOM_PROPERTIES
//

#define NDIS_OBJECT_TYPE_PCI_DEVICE_CUSTOM_PROPERTIES_REVISION_1  1

typedef struct _NDIS_PCI_DEVICE_CUSTOM_PROPERTIES
{
    NDIS_OBJECT_HEADER              Header;
    UINT32                          DeviceType;             // conventional, PCI-X, PCI-E, etc.
    UINT32                          CurrentSpeedAndMode;    // PCI_DEVICE_CONVENTIONAL_xx or PCIX_MODExxx. valid only for conventional and PCI-X devices
    UINT32                          CurrentPayloadSize;     // PCI_EXPRESS_MAX_PAYLOAD_SIZE, valid only for PCI-E devices
    UINT32                          MaxPayloadSize;         // PCI_EXPRESS_MAX_PAYLOAD_SIZE, valid only for PCI-E devices
    UINT32                          MaxReadRequestSize;     // PCI_EXPRESS_MAX_PAYLOAD_SIZE, valid only for PCI-E devices
    UINT32                          CurrentLinkSpeed;       // PCI_EXPRESS_LINK_SPEED_xxx. valid only for PCI-E devices 
    UINT32                          CurrentLinkWidth;       // PCI_EXPRESS_LINK_WIDTH_xx. valid only for PCI-E devices
    UINT32                          MaxLinkSpeed;           // PCI_EXPRESS_LINK_SPEED_xxx. valid only for PCI-E devices
    UINT32                          MaxLinkWidth;           // PCI_EXPRESS_LINK_WIDTH_xx. valid only for PCI-E devices
} NDIS_PCI_DEVICE_CUSTOM_PROPERTIES, *PNDIS_PCI_DEVICE_CUSTOM_PROPERTIES;

#define NDIS_SIZEOF_PCI_DEVICE_CUSTOM_PROPERTIES_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PCI_DEVICE_CUSTOM_PROPERTIES, MaxLinkWidth)

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//
// General Objects
//

//
//  Required OIDs
//
#define OID_GEN_SUPPORTED_LIST                  0x00010101
#define OID_GEN_HARDWARE_STATUS                 0x00010102
#define OID_GEN_MEDIA_SUPPORTED                 0x00010103
#define OID_GEN_MEDIA_IN_USE                    0x00010104
#define OID_GEN_MAXIMUM_LOOKAHEAD               0x00010105
#define OID_GEN_MAXIMUM_FRAME_SIZE              0x00010106
#define OID_GEN_LINK_SPEED                      0x00010107
#define OID_GEN_TRANSMIT_BUFFER_SPACE           0x00010108
#define OID_GEN_RECEIVE_BUFFER_SPACE            0x00010109
#define OID_GEN_TRANSMIT_BLOCK_SIZE             0x0001010A
#define OID_GEN_RECEIVE_BLOCK_SIZE              0x0001010B
#define OID_GEN_VENDOR_ID                       0x0001010C
#define OID_GEN_VENDOR_DESCRIPTION              0x0001010D
#define OID_GEN_CURRENT_PACKET_FILTER           0x0001010E
#define OID_GEN_CURRENT_LOOKAHEAD               0x0001010F
#define OID_GEN_DRIVER_VERSION                  0x00010110
#define OID_GEN_MAXIMUM_TOTAL_SIZE              0x00010111
#define OID_GEN_PROTOCOL_OPTIONS                0x00010112
#define OID_GEN_MAC_OPTIONS                     0x00010113
#define OID_GEN_MEDIA_CONNECT_STATUS            0x00010114
#define OID_GEN_MAXIMUM_SEND_PACKETS            0x00010115

//
//  Optional OIDs
//
#define OID_GEN_VENDOR_DRIVER_VERSION           0x00010116
#define OID_GEN_SUPPORTED_GUIDS                 0x00010117
#define OID_GEN_NETWORK_LAYER_ADDRESSES         0x00010118  // Set only
#define OID_GEN_TRANSPORT_HEADER_OFFSET         0x00010119  // Set only
#define OID_GEN_MEDIA_CAPABILITIES              0x00010201
#define OID_GEN_PHYSICAL_MEDIUM                 0x00010202

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
//
// new optional for NDIS 6.0
//
#define OID_GEN_RECEIVE_SCALE_CAPABILITIES      0x00010203  // query only
#define OID_GEN_RECEIVE_SCALE_PARAMETERS        0x00010204  // query and set

//
// new for NDIS 6.0. NDIS will handle on behalf of the miniports
//
#define OID_GEN_MAC_ADDRESS                     0x00010205  // query and set
#define OID_GEN_MAX_LINK_SPEED                  0x00010206  // query only
#define OID_GEN_LINK_STATE                      0x00010207  // query only

//
// new and required for NDIS 6 miniports
//
#define OID_GEN_LINK_PARAMETERS                 0x00010208  // set only
#define OID_GEN_INTERRUPT_MODERATION            0x00010209  // query and set
#define OID_GEN_NDIS_RESERVED_3                 0x0001020A
#define OID_GEN_NDIS_RESERVED_4                 0x0001020B
#define OID_GEN_NDIS_RESERVED_5                 0x0001020C


//
// Port related OIDs
//
#define OID_GEN_ENUMERATE_PORTS                 0x0001020D  // query only, handled by NDIS
#define OID_GEN_PORT_STATE                      0x0001020E  // query only, handled by NDIS
#define OID_GEN_PORT_AUTHENTICATION_PARAMETERS  0x0001020F  // Set only

//
// optional OID for NDIS 6 miniports
//
#define OID_GEN_TIMEOUT_DPC_REQUEST_CAPABILITIES 0x00010210 // query only

//
// this OID is handled by NDIS for PCI devices
//
#define OID_GEN_PCI_DEVICE_CUSTOM_PROPERTIES    0x00010211  // query only
#define OID_GEN_NDIS_RESERVED_6                 0x00010212


#endif // (NTDDI_VERSION >= NTDDI_VISTA)

#define OID_GEN_MACHINE_NAME                    0x0001021A  // set only
#define OID_GEN_RNDIS_CONFIG_PARAMETER          0x0001021B  // Set only
#define OID_GEN_VLAN_ID                         0x0001021C

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
#define OID_GEN_RECEIVE_HASH                    0x0001021F  // query and set
#define OID_GEN_MINIPORT_RESTART_ATTRIBUTES     0x0001021D

#if (NDIS_SUPPORT_NDIS61)
//
// Optional OID for header data/split
//
#define OID_GEN_HD_SPLIT_PARAMETERS             0x0001021E  // Set only
#define OID_GEN_HD_SPLIT_CURRENT_CONFIG         0x00010220  // Query only
#endif // (NDIS_SUPPORT_NDIS61)

//
// the following OIDs are used in querying interfaces
//
#define OID_GEN_PROMISCUOUS_MODE                0x00010280  // used in querying interfaces
#define OID_GEN_LAST_CHANGE                     0x00010281  // used in querying interfaces
#define OID_GEN_DISCONTINUITY_TIME              0x00010282  // used in querying interfaces
#define OID_GEN_OPERATIONAL_STATUS              0x00010283  // used in querying interfaces
#define OID_GEN_XMIT_LINK_SPEED                 0x00010284  // used in querying interfaces
#define OID_GEN_RCV_LINK_SPEED                  0x00010285  // used in querying interfaces
#define OID_GEN_UNKNOWN_PROTOS                  0x00010286  // used in querying interfaces
#define OID_GEN_INTERFACE_INFO                  0x00010287  // used in querying interfaces
#define OID_GEN_ADMIN_STATUS                    0x00010288  // used in querying interfaces
#define OID_GEN_ALIAS                           0x00010289  // used in querying interfaces
#define OID_GEN_MEDIA_CONNECT_STATUS_EX         0x0001028A  // used in querying interfaces
#define OID_GEN_LINK_SPEED_EX                   0x0001028B  // used in querying interfaces
#define OID_GEN_MEDIA_DUPLEX_STATE              0x0001028C  // used in querying interfaces

#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//
//  Required statistics
//
#define OID_GEN_XMIT_OK                         0x00020101
#define OID_GEN_RCV_OK                          0x00020102
#define OID_GEN_XMIT_ERROR                      0x00020103
#define OID_GEN_RCV_ERROR                       0x00020104
#define OID_GEN_RCV_NO_BUFFER                   0x00020105

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
//
// mandatory for NDIS 6.0 and higher miniports
//
#define OID_GEN_STATISTICS                      0x00020106
#endif // (NTDDI_VERSION >= NTDDI_VISTA)

//
//  Optional statistics
//
#define OID_GEN_DIRECTED_BYTES_XMIT             0x00020201
#define OID_GEN_DIRECTED_FRAMES_XMIT            0x00020202
#define OID_GEN_MULTICAST_BYTES_XMIT            0x00020203
#define OID_GEN_MULTICAST_FRAMES_XMIT           0x00020204
#define OID_GEN_BROADCAST_BYTES_XMIT            0x00020205
#define OID_GEN_BROADCAST_FRAMES_XMIT           0x00020206
#define OID_GEN_DIRECTED_BYTES_RCV              0x00020207
#define OID_GEN_DIRECTED_FRAMES_RCV             0x00020208
#define OID_GEN_MULTICAST_BYTES_RCV             0x00020209
#define OID_GEN_MULTICAST_FRAMES_RCV            0x0002020A
#define OID_GEN_BROADCAST_BYTES_RCV             0x0002020B
#define OID_GEN_BROADCAST_FRAMES_RCV            0x0002020C
#define OID_GEN_RCV_CRC_ERROR                   0x0002020D
#define OID_GEN_TRANSMIT_QUEUE_LENGTH           0x0002020E

#define OID_GEN_GET_TIME_CAPS                   0x0002020F
#define OID_GEN_GET_NETCARD_TIME                0x00020210
#define OID_GEN_NETCARD_LOAD                    0x00020211
#define OID_GEN_DEVICE_PROFILE                  0x00020212

//
// The following are exported by NDIS itself and are only queryable. 
//

//
// the time in milliseconds a driver took to initialize.
//
#define OID_GEN_INIT_TIME_MS                    0x00020213

//
// the number of times the miniport adapter was reset
//
#define OID_GEN_RESET_COUNTS                    0x00020214

//
// the number of timer the miniport reported a media state change
//
#define OID_GEN_MEDIA_SENSE_COUNTS              0x00020215

//
// the friendly name of the adapter
//
#define OID_GEN_FRIENDLY_NAME                   0x00020216

//
// returns miniport information such as whether the driver is serialized or not
// if it supports sending multiple packets, etc. refer to NDIS_MINIPORT_XXX flags
//
#define OID_GEN_NDIS_RESERVED_1                 0x00020217

//
// handled by NDIS to reset the test verification paramters on the
// miniport
//
#define OID_GEN_NDIS_RESERVED_2                 0x00020218
#define OID_GEN_NDIS_RESERVED_5                 0x0001020C

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
//
// more optional OIDs new for NDIS 6.0
//

#define OID_GEN_BYTES_RCV                       0x00020219
#define OID_GEN_BYTES_XMIT                      0x0002021A
#define OID_GEN_RCV_DISCARDS                    0x0002021B
#define OID_GEN_XMIT_DISCARDS                   0x0002021C
#endif // (NTDDI_VERSION >= NTDDI_VISTA)



//
//  These are connection-oriented general OIDs.
//  These replace the above OIDs for connection-oriented media.
//
#define OID_GEN_CO_SUPPORTED_LIST               OID_GEN_SUPPORTED_LIST
#define OID_GEN_CO_HARDWARE_STATUS              OID_GEN_HARDWARE_STATUS
#define OID_GEN_CO_MEDIA_SUPPORTED              OID_GEN_MEDIA_SUPPORTED
#define OID_GEN_CO_MEDIA_IN_USE                 OID_GEN_MEDIA_IN_USE
#define OID_GEN_CO_LINK_SPEED                   OID_GEN_LINK_SPEED
#define OID_GEN_CO_VENDOR_ID                    OID_GEN_VENDOR_ID
#define OID_GEN_CO_VENDOR_DESCRIPTION           OID_GEN_VENDOR_DESCRIPTION
#define OID_GEN_CO_DRIVER_VERSION               OID_GEN_DRIVER_VERSION
#define OID_GEN_CO_PROTOCOL_OPTIONS             OID_GEN_PROTOCOL_OPTIONS
#define OID_GEN_CO_MAC_OPTIONS                  OID_GEN_MAC_OPTIONS
#define OID_GEN_CO_MEDIA_CONNECT_STATUS         OID_GEN_MEDIA_CONNECT_STATUS
#define OID_GEN_CO_VENDOR_DRIVER_VERSION        OID_GEN_VENDOR_DRIVER_VERSION
#define OID_GEN_CO_SUPPORTED_GUIDS              OID_GEN_SUPPORTED_GUIDS
#define OID_GEN_CO_GET_TIME_CAPS                OID_GEN_GET_TIME_CAPS
#define OID_GEN_CO_GET_NETCARD_TIME             OID_GEN_GET_NETCARD_TIME
#define OID_GEN_CO_MINIMUM_LINK_SPEED           0x00020120

//
//  These are connection-oriented statistics OIDs.
//
#define OID_GEN_CO_XMIT_PDUS_OK                 OID_GEN_XMIT_OK
#define OID_GEN_CO_RCV_PDUS_OK                  OID_GEN_RCV_OK
#define OID_GEN_CO_XMIT_PDUS_ERROR              OID_GEN_XMIT_ERROR
#define OID_GEN_CO_RCV_PDUS_ERROR               OID_GEN_RCV_ERROR
#define OID_GEN_CO_RCV_PDUS_NO_BUFFER           OID_GEN_RCV_NO_BUFFER


#define OID_GEN_CO_RCV_CRC_ERROR                OID_GEN_RCV_CRC_ERROR
#define OID_GEN_CO_TRANSMIT_QUEUE_LENGTH        OID_GEN_TRANSMIT_QUEUE_LENGTH
#define OID_GEN_CO_BYTES_XMIT                   OID_GEN_DIRECTED_BYTES_XMIT
#define OID_GEN_CO_BYTES_RCV                    OID_GEN_DIRECTED_BYTES_RCV
#define OID_GEN_CO_NETCARD_LOAD                 OID_GEN_NETCARD_LOAD
#define OID_GEN_CO_DEVICE_PROFILE               OID_GEN_DEVICE_PROFILE
#define OID_GEN_CO_BYTES_XMIT_OUTSTANDING       0x00020221

//
// 802.3 Objects (Ethernet)
//
#define OID_802_3_PERMANENT_ADDRESS             0x01010101
#define OID_802_3_CURRENT_ADDRESS               0x01010102
#define OID_802_3_MULTICAST_LIST                0x01010103
#define OID_802_3_MAXIMUM_LIST_SIZE             0x01010104
//
// This OID has been deprecated for NDIS 6 drivers. 
//
#define OID_802_3_MAC_OPTIONS                   0x01010105  // deprecated


//
// This Flag has been deprecated for NDIS 6 drivers.
//
#define NDIS_802_3_MAC_OPTION_PRIORITY          0x00000001  // deprecated

#define OID_802_3_RCV_ERROR_ALIGNMENT           0x01020101
#define OID_802_3_XMIT_ONE_COLLISION            0x01020102
#define OID_802_3_XMIT_MORE_COLLISIONS          0x01020103

#define OID_802_3_XMIT_DEFERRED                 0x01020201
#define OID_802_3_XMIT_MAX_COLLISIONS           0x01020202
#define OID_802_3_RCV_OVERRUN                   0x01020203
#define OID_802_3_XMIT_UNDERRUN                 0x01020204
#define OID_802_3_XMIT_HEARTBEAT_FAILURE        0x01020205
#define OID_802_3_XMIT_TIMES_CRS_LOST           0x01020206
#define OID_802_3_XMIT_LATE_COLLISIONS          0x01020207

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
//
// new for NDIS 6
//
#define OID_802_3_ADD_MULTICAST_ADDRESS         0x01010208
#define OID_802_3_DELETE_MULTICAST_ADDRESS      0x01010209
#endif // (NTDDI_VERSION >= NTDDI_VISTA)


//
// 802.5 Objects (Token-Ring)
//
#define OID_802_5_PERMANENT_ADDRESS             0x02010101
#define OID_802_5_CURRENT_ADDRESS               0x02010102
#define OID_802_5_CURRENT_FUNCTIONAL            0x02010103
#define OID_802_5_CURRENT_GROUP                 0x02010104
#define OID_802_5_LAST_OPEN_STATUS              0x02010105
#define OID_802_5_CURRENT_RING_STATUS           0x02010106
#define OID_802_5_CURRENT_RING_STATE            0x02010107


#define OID_802_5_LINE_ERRORS                   0x02020101
#define OID_802_5_LOST_FRAMES                   0x02020102

#define OID_802_5_BURST_ERRORS                  0x02020201
#define OID_802_5_AC_ERRORS                     0x02020202
#define OID_802_5_ABORT_DELIMETERS              0x02020203
#define OID_802_5_FRAME_COPIED_ERRORS           0x02020204
#define OID_802_5_FREQUENCY_ERRORS              0x02020205
#define OID_802_5_TOKEN_ERRORS                  0x02020206
#define OID_802_5_INTERNAL_ERRORS               0x02020207


//
// FDDI Objects
//
#define OID_FDDI_LONG_PERMANENT_ADDR            0x03010101
#define OID_FDDI_LONG_CURRENT_ADDR              0x03010102
#define OID_FDDI_LONG_MULTICAST_LIST            0x03010103
#define OID_FDDI_LONG_MAX_LIST_SIZE             0x03010104
#define OID_FDDI_SHORT_PERMANENT_ADDR           0x03010105
#define OID_FDDI_SHORT_CURRENT_ADDR             0x03010106
#define OID_FDDI_SHORT_MULTICAST_LIST           0x03010107
#define OID_FDDI_SHORT_MAX_LIST_SIZE            0x03010108

#define OID_FDDI_ATTACHMENT_TYPE                0x03020101
#define OID_FDDI_UPSTREAM_NODE_LONG             0x03020102
#define OID_FDDI_DOWNSTREAM_NODE_LONG           0x03020103
#define OID_FDDI_FRAME_ERRORS                   0x03020104
#define OID_FDDI_FRAMES_LOST                    0x03020105
#define OID_FDDI_RING_MGT_STATE                 0x03020106
#define OID_FDDI_LCT_FAILURES                   0x03020107
#define OID_FDDI_LEM_REJECTS                    0x03020108
#define OID_FDDI_LCONNECTION_STATE              0x03020109

#define OID_FDDI_SMT_STATION_ID                 0x03030201
#define OID_FDDI_SMT_OP_VERSION_ID              0x03030202
#define OID_FDDI_SMT_HI_VERSION_ID              0x03030203
#define OID_FDDI_SMT_LO_VERSION_ID              0x03030204
#define OID_FDDI_SMT_MANUFACTURER_DATA          0x03030205
#define OID_FDDI_SMT_USER_DATA                  0x03030206
#define OID_FDDI_SMT_MIB_VERSION_ID             0x03030207
#define OID_FDDI_SMT_MAC_CT                     0x03030208
#define OID_FDDI_SMT_NON_MASTER_CT              0x03030209
#define OID_FDDI_SMT_MASTER_CT                  0x0303020A
#define OID_FDDI_SMT_AVAILABLE_PATHS            0x0303020B
#define OID_FDDI_SMT_CONFIG_CAPABILITIES        0x0303020C
#define OID_FDDI_SMT_CONFIG_POLICY              0x0303020D
#define OID_FDDI_SMT_CONNECTION_POLICY          0x0303020E
#define OID_FDDI_SMT_T_NOTIFY                   0x0303020F
#define OID_FDDI_SMT_STAT_RPT_POLICY            0x03030210
#define OID_FDDI_SMT_TRACE_MAX_EXPIRATION       0x03030211
#define OID_FDDI_SMT_PORT_INDEXES               0x03030212
#define OID_FDDI_SMT_MAC_INDEXES                0x03030213
#define OID_FDDI_SMT_BYPASS_PRESENT             0x03030214
#define OID_FDDI_SMT_ECM_STATE                  0x03030215
#define OID_FDDI_SMT_CF_STATE                   0x03030216
#define OID_FDDI_SMT_HOLD_STATE                 0x03030217
#define OID_FDDI_SMT_REMOTE_DISCONNECT_FLAG     0x03030218
#define OID_FDDI_SMT_STATION_STATUS             0x03030219
#define OID_FDDI_SMT_PEER_WRAP_FLAG             0x0303021A
#define OID_FDDI_SMT_MSG_TIME_STAMP             0x0303021B
#define OID_FDDI_SMT_TRANSITION_TIME_STAMP      0x0303021C
#define OID_FDDI_SMT_SET_COUNT                  0x0303021D
#define OID_FDDI_SMT_LAST_SET_STATION_ID        0x0303021E
#define OID_FDDI_MAC_FRAME_STATUS_FUNCTIONS     0x0303021F
#define OID_FDDI_MAC_BRIDGE_FUNCTIONS           0x03030220
#define OID_FDDI_MAC_T_MAX_CAPABILITY           0x03030221
#define OID_FDDI_MAC_TVX_CAPABILITY             0x03030222
#define OID_FDDI_MAC_AVAILABLE_PATHS            0x03030223
#define OID_FDDI_MAC_CURRENT_PATH               0x03030224
#define OID_FDDI_MAC_UPSTREAM_NBR               0x03030225
#define OID_FDDI_MAC_DOWNSTREAM_NBR             0x03030226
#define OID_FDDI_MAC_OLD_UPSTREAM_NBR           0x03030227
#define OID_FDDI_MAC_OLD_DOWNSTREAM_NBR         0x03030228
#define OID_FDDI_MAC_DUP_ADDRESS_TEST           0x03030229
#define OID_FDDI_MAC_REQUESTED_PATHS            0x0303022A
#define OID_FDDI_MAC_DOWNSTREAM_PORT_TYPE       0x0303022B
#define OID_FDDI_MAC_INDEX                      0x0303022C
#define OID_FDDI_MAC_SMT_ADDRESS                0x0303022D
#define OID_FDDI_MAC_LONG_GRP_ADDRESS           0x0303022E
#define OID_FDDI_MAC_SHORT_GRP_ADDRESS          0x0303022F
#define OID_FDDI_MAC_T_REQ                      0x03030230
#define OID_FDDI_MAC_T_NEG                      0x03030231
#define OID_FDDI_MAC_T_MAX                      0x03030232
#define OID_FDDI_MAC_TVX_VALUE                  0x03030233
#define OID_FDDI_MAC_T_PRI0                     0x03030234
#define OID_FDDI_MAC_T_PRI1                     0x03030235
#define OID_FDDI_MAC_T_PRI2                     0x03030236
#define OID_FDDI_MAC_T_PRI3                     0x03030237
#define OID_FDDI_MAC_T_PRI4                     0x03030238
#define OID_FDDI_MAC_T_PRI5                     0x03030239
#define OID_FDDI_MAC_T_PRI6                     0x0303023A
#define OID_FDDI_MAC_FRAME_CT                   0x0303023B
#define OID_FDDI_MAC_COPIED_CT                  0x0303023C
#define OID_FDDI_MAC_TRANSMIT_CT                0x0303023D
#define OID_FDDI_MAC_TOKEN_CT                   0x0303023E
#define OID_FDDI_MAC_ERROR_CT                   0x0303023F
#define OID_FDDI_MAC_LOST_CT                    0x03030240
#define OID_FDDI_MAC_TVX_EXPIRED_CT             0x03030241
#define OID_FDDI_MAC_NOT_COPIED_CT              0x03030242
#define OID_FDDI_MAC_LATE_CT                    0x03030243
#define OID_FDDI_MAC_RING_OP_CT                 0x03030244
#define OID_FDDI_MAC_FRAME_ERROR_THRESHOLD      0x03030245
#define OID_FDDI_MAC_FRAME_ERROR_RATIO          0x03030246
#define OID_FDDI_MAC_NOT_COPIED_THRESHOLD       0x03030247
#define OID_FDDI_MAC_NOT_COPIED_RATIO           0x03030248
#define OID_FDDI_MAC_RMT_STATE                  0x03030249
#define OID_FDDI_MAC_DA_FLAG                    0x0303024A
#define OID_FDDI_MAC_UNDA_FLAG                  0x0303024B
#define OID_FDDI_MAC_FRAME_ERROR_FLAG           0x0303024C
#define OID_FDDI_MAC_NOT_COPIED_FLAG            0x0303024D
#define OID_FDDI_MAC_MA_UNITDATA_AVAILABLE      0x0303024E
#define OID_FDDI_MAC_HARDWARE_PRESENT           0x0303024F
#define OID_FDDI_MAC_MA_UNITDATA_ENABLE         0x03030250
#define OID_FDDI_PATH_INDEX                     0x03030251
#define OID_FDDI_PATH_RING_LATENCY              0x03030252
#define OID_FDDI_PATH_TRACE_STATUS              0x03030253
#define OID_FDDI_PATH_SBA_PAYLOAD               0x03030254
#define OID_FDDI_PATH_SBA_OVERHEAD              0x03030255
#define OID_FDDI_PATH_CONFIGURATION             0x03030256
#define OID_FDDI_PATH_T_R_MODE                  0x03030257
#define OID_FDDI_PATH_SBA_AVAILABLE             0x03030258
#define OID_FDDI_PATH_TVX_LOWER_BOUND           0x03030259
#define OID_FDDI_PATH_T_MAX_LOWER_BOUND         0x0303025A
#define OID_FDDI_PATH_MAX_T_REQ                 0x0303025B
#define OID_FDDI_PORT_MY_TYPE                   0x0303025C
#define OID_FDDI_PORT_NEIGHBOR_TYPE             0x0303025D
#define OID_FDDI_PORT_CONNECTION_POLICIES       0x0303025E
#define OID_FDDI_PORT_MAC_INDICATED             0x0303025F
#define OID_FDDI_PORT_CURRENT_PATH              0x03030260
#define OID_FDDI_PORT_REQUESTED_PATHS           0x03030261
#define OID_FDDI_PORT_MAC_PLACEMENT             0x03030262
#define OID_FDDI_PORT_AVAILABLE_PATHS           0x03030263
#define OID_FDDI_PORT_MAC_LOOP_TIME             0x03030264
#define OID_FDDI_PORT_PMD_CLASS                 0x03030265
#define OID_FDDI_PORT_CONNECTION_CAPABILITIES   0x03030266
#define OID_FDDI_PORT_INDEX                     0x03030267
#define OID_FDDI_PORT_MAINT_LS                  0x03030268
#define OID_FDDI_PORT_BS_FLAG                   0x03030269
#define OID_FDDI_PORT_PC_LS                     0x0303026A
#define OID_FDDI_PORT_EB_ERROR_CT               0x0303026B
#define OID_FDDI_PORT_LCT_FAIL_CT               0x0303026C
#define OID_FDDI_PORT_LER_ESTIMATE              0x0303026D
#define OID_FDDI_PORT_LEM_REJECT_CT             0x0303026E
#define OID_FDDI_PORT_LEM_CT                    0x0303026F
#define OID_FDDI_PORT_LER_CUTOFF                0x03030270
#define OID_FDDI_PORT_LER_ALARM                 0x03030271
#define OID_FDDI_PORT_CONNNECT_STATE            0x03030272
#define OID_FDDI_PORT_PCM_STATE                 0x03030273
#define OID_FDDI_PORT_PC_WITHHOLD               0x03030274
#define OID_FDDI_PORT_LER_FLAG                  0x03030275
#define OID_FDDI_PORT_HARDWARE_PRESENT          0x03030276
#define OID_FDDI_SMT_STATION_ACTION             0x03030277
#define OID_FDDI_PORT_ACTION                    0x03030278
#define OID_FDDI_IF_DESCR                       0x03030279
#define OID_FDDI_IF_TYPE                        0x0303027A
#define OID_FDDI_IF_MTU                         0x0303027B
#define OID_FDDI_IF_SPEED                       0x0303027C
#define OID_FDDI_IF_PHYS_ADDRESS                0x0303027D
#define OID_FDDI_IF_ADMIN_STATUS                0x0303027E
#define OID_FDDI_IF_OPER_STATUS                 0x0303027F
#define OID_FDDI_IF_LAST_CHANGE                 0x03030280
#define OID_FDDI_IF_IN_OCTETS                   0x03030281
#define OID_FDDI_IF_IN_UCAST_PKTS               0x03030282
#define OID_FDDI_IF_IN_NUCAST_PKTS              0x03030283
#define OID_FDDI_IF_IN_DISCARDS                 0x03030284
#define OID_FDDI_IF_IN_ERRORS                   0x03030285
#define OID_FDDI_IF_IN_UNKNOWN_PROTOS           0x03030286
#define OID_FDDI_IF_OUT_OCTETS                  0x03030287
#define OID_FDDI_IF_OUT_UCAST_PKTS              0x03030288
#define OID_FDDI_IF_OUT_NUCAST_PKTS             0x03030289
#define OID_FDDI_IF_OUT_DISCARDS                0x0303028A
#define OID_FDDI_IF_OUT_ERRORS                  0x0303028B
#define OID_FDDI_IF_OUT_QLEN                    0x0303028C
#define OID_FDDI_IF_SPECIFIC                    0x0303028D

//
// WAN objects
//
#define OID_WAN_PERMANENT_ADDRESS               0x04010101
#define OID_WAN_CURRENT_ADDRESS                 0x04010102
#define OID_WAN_QUALITY_OF_SERVICE              0x04010103
#define OID_WAN_PROTOCOL_TYPE                   0x04010104
#define OID_WAN_MEDIUM_SUBTYPE                  0x04010105
#define OID_WAN_HEADER_FORMAT                   0x04010106

#define OID_WAN_GET_INFO                        0x04010107
#define OID_WAN_SET_LINK_INFO                   0x04010108
#define OID_WAN_GET_LINK_INFO                   0x04010109

#define OID_WAN_LINE_COUNT                      0x0401010A
#define OID_WAN_PROTOCOL_CAPS                   0x0401010B

#define OID_WAN_GET_BRIDGE_INFO                 0x0401020A
#define OID_WAN_SET_BRIDGE_INFO                 0x0401020B
#define OID_WAN_GET_COMP_INFO                   0x0401020C
#define OID_WAN_SET_COMP_INFO                   0x0401020D
#define OID_WAN_GET_STATS_INFO                  0x0401020E

//
//  These are connection-oriented WAN OIDs.
//  These replace the above OIDs for CoNDIS WAN Miniports
//
#define OID_WAN_CO_GET_INFO                     0x04010180
#define OID_WAN_CO_SET_LINK_INFO                0x04010181
#define OID_WAN_CO_GET_LINK_INFO                0x04010182
#define OID_WAN_CO_GET_COMP_INFO                0x04010280
#define OID_WAN_CO_SET_COMP_INFO                0x04010281
#define OID_WAN_CO_GET_STATS_INFO               0x04010282


//
// LocalTalk objects
//
#define OID_LTALK_CURRENT_NODE_ID               0x05010102

#define OID_LTALK_IN_BROADCASTS                 0x05020101
#define OID_LTALK_IN_LENGTH_ERRORS              0x05020102

#define OID_LTALK_OUT_NO_HANDLERS               0x05020201
#define OID_LTALK_COLLISIONS                    0x05020202
#define OID_LTALK_DEFERS                        0x05020203
#define OID_LTALK_NO_DATA_ERRORS                0x05020204
#define OID_LTALK_RANDOM_CTS_ERRORS             0x05020205
#define OID_LTALK_FCS_ERRORS                    0x05020206


//
// Arcnet objects
//
#define OID_ARCNET_PERMANENT_ADDRESS            0x06010101
#define OID_ARCNET_CURRENT_ADDRESS              0x06010102

#define OID_ARCNET_RECONFIGURATIONS             0x06020201

//
// TAPI objects
//
#define OID_TAPI_ACCEPT                         0x07030101
#define OID_TAPI_ANSWER                         0x07030102
#define OID_TAPI_CLOSE                          0x07030103
#define OID_TAPI_CLOSE_CALL                     0x07030104
#define OID_TAPI_CONDITIONAL_MEDIA_DETECTION    0x07030105
#define OID_TAPI_CONFIG_DIALOG                  0x07030106
#define OID_TAPI_DEV_SPECIFIC                   0x07030107
#define OID_TAPI_DIAL                           0x07030108
#define OID_TAPI_DROP                           0x07030109
#define OID_TAPI_GET_ADDRESS_CAPS               0x0703010A
#define OID_TAPI_GET_ADDRESS_ID                 0x0703010B
#define OID_TAPI_GET_ADDRESS_STATUS             0x0703010C
#define OID_TAPI_GET_CALL_ADDRESS_ID            0x0703010D
#define OID_TAPI_GET_CALL_INFO                  0x0703010E
#define OID_TAPI_GET_CALL_STATUS                0x0703010F
#define OID_TAPI_GET_DEV_CAPS                   0x07030110
#define OID_TAPI_GET_DEV_CONFIG                 0x07030111
#define OID_TAPI_GET_EXTENSION_ID               0x07030112
#define OID_TAPI_GET_ID                         0x07030113
#define OID_TAPI_GET_LINE_DEV_STATUS            0x07030114
#define OID_TAPI_MAKE_CALL                      0x07030115
#define OID_TAPI_NEGOTIATE_EXT_VERSION          0x07030116
#define OID_TAPI_OPEN                           0x07030117
#define OID_TAPI_PROVIDER_INITIALIZE            0x07030118
#define OID_TAPI_PROVIDER_SHUTDOWN              0x07030119
#define OID_TAPI_SECURE_CALL                    0x0703011A
#define OID_TAPI_SELECT_EXT_VERSION             0x0703011B
#define OID_TAPI_SEND_USER_USER_INFO            0x0703011C
#define OID_TAPI_SET_APP_SPECIFIC               0x0703011D
#define OID_TAPI_SET_CALL_PARAMS                0x0703011E
#define OID_TAPI_SET_DEFAULT_MEDIA_DETECTION    0x0703011F
#define OID_TAPI_SET_DEV_CONFIG                 0x07030120
#define OID_TAPI_SET_MEDIA_MODE                 0x07030121
#define OID_TAPI_SET_STATUS_MESSAGES            0x07030122
#define OID_TAPI_GATHER_DIGITS                  0x07030123
#define OID_TAPI_MONITOR_DIGITS                 0x07030124

//
// ATM Connection Oriented OIDs
//
#define OID_ATM_SUPPORTED_VC_RATES              0x08010101
#define OID_ATM_SUPPORTED_SERVICE_CATEGORY      0x08010102
#define OID_ATM_SUPPORTED_AAL_TYPES             0x08010103
#define OID_ATM_HW_CURRENT_ADDRESS              0x08010104
#define OID_ATM_MAX_ACTIVE_VCS                  0x08010105
#define OID_ATM_MAX_ACTIVE_VCI_BITS             0x08010106
#define OID_ATM_MAX_ACTIVE_VPI_BITS             0x08010107
#define OID_ATM_MAX_AAL0_PACKET_SIZE            0x08010108
#define OID_ATM_MAX_AAL1_PACKET_SIZE            0x08010109
#define OID_ATM_MAX_AAL34_PACKET_SIZE           0x0801010A
#define OID_ATM_MAX_AAL5_PACKET_SIZE            0x0801010B

#define OID_ATM_SIGNALING_VPIVCI                0x08010201
#define OID_ATM_ASSIGNED_VPI                    0x08010202
#define OID_ATM_ACQUIRE_ACCESS_NET_RESOURCES    0x08010203
#define OID_ATM_RELEASE_ACCESS_NET_RESOURCES    0x08010204
#define OID_ATM_ILMI_VPIVCI                     0x08010205
#define OID_ATM_DIGITAL_BROADCAST_VPIVCI        0x08010206
#define OID_ATM_GET_NEAREST_FLOW                0x08010207
#define OID_ATM_ALIGNMENT_REQUIRED              0x08010208
#define OID_ATM_LECS_ADDRESS                    0x08010209
#define OID_ATM_SERVICE_ADDRESS                 0x0801020A

#define OID_ATM_CALL_PROCEEDING                 0x0801020B  // UNI 4.0
#define OID_ATM_CALL_ALERTING                   0x0801020C  // UNI 4.0
#define OID_ATM_PARTY_ALERTING                  0x0801020D  // UNI 4.0
#define OID_ATM_CALL_NOTIFY                     0x0801020E  // UNI 4.0

#define OID_ATM_MY_IP_NM_ADDRESS                0x0801020F


//
//  ATM specific statistics OIDs.
//
#define OID_ATM_RCV_CELLS_OK                    0x08020101
#define OID_ATM_XMIT_CELLS_OK                   0x08020102
#define OID_ATM_RCV_CELLS_DROPPED               0x08020103

#define OID_ATM_RCV_INVALID_VPI_VCI             0x08020201
#define OID_ATM_CELLS_HEC_ERROR                 0x08020202
#define OID_ATM_RCV_REASSEMBLY_ERROR            0x08020203


//
// IEEE 802.11 OIDs
//
#define OID_802_11_BSSID                        0x0D010101
#define OID_802_11_SSID                         0x0D010102
#define OID_802_11_NETWORK_TYPES_SUPPORTED      0x0D010203
#define OID_802_11_NETWORK_TYPE_IN_USE          0x0D010204
#define OID_802_11_TX_POWER_LEVEL               0x0D010205
#define OID_802_11_RSSI                         0x0D010206
#define OID_802_11_RSSI_TRIGGER                 0x0D010207
#define OID_802_11_INFRASTRUCTURE_MODE          0x0D010108
#define OID_802_11_FRAGMENTATION_THRESHOLD      0x0D010209
#define OID_802_11_RTS_THRESHOLD                0x0D01020A
#define OID_802_11_NUMBER_OF_ANTENNAS           0x0D01020B
#define OID_802_11_RX_ANTENNA_SELECTED          0x0D01020C
#define OID_802_11_TX_ANTENNA_SELECTED          0x0D01020D
#define OID_802_11_SUPPORTED_RATES              0x0D01020E
#define OID_802_11_DESIRED_RATES                0x0D010210
#define OID_802_11_CONFIGURATION                0x0D010211
#define OID_802_11_STATISTICS                   0x0D020212
#define OID_802_11_ADD_WEP                      0x0D010113
#define OID_802_11_REMOVE_WEP                   0x0D010114
#define OID_802_11_DISASSOCIATE                 0x0D010115
#define OID_802_11_POWER_MODE                   0x0D010216
#define OID_802_11_BSSID_LIST                   0x0D010217
#define OID_802_11_AUTHENTICATION_MODE          0x0D010118
#define OID_802_11_PRIVACY_FILTER               0x0D010119
#define OID_802_11_BSSID_LIST_SCAN              0x0D01011A
#define OID_802_11_WEP_STATUS                   0x0D01011B
// Renamed to reflect better the extended set of encryption status
#define OID_802_11_ENCRYPTION_STATUS            OID_802_11_WEP_STATUS
#define OID_802_11_RELOAD_DEFAULTS              0x0D01011C
// Added to allow key mapping and default keys
#define OID_802_11_ADD_KEY                      0x0D01011D
#define OID_802_11_REMOVE_KEY                   0x0D01011E
#define OID_802_11_ASSOCIATION_INFORMATION      0x0D01011F
#define OID_802_11_TEST                         0x0D010120
#define OID_802_11_MEDIA_STREAM_MODE            0x0D010121
#define OID_802_11_CAPABILITY                   0x0D010122
#define OID_802_11_PMKID                        0x0D010123
#define OID_802_11_NON_BCAST_SSID_LIST          0x0D010124
#define OID_802_11_RADIO_STATUS                 0x0D010125


//
// some of well known Ethernet frame types (in big endian notation)
//
#define NDIS_ETH_TYPE_IPV4              0x0800  // IPV4
#define NDIS_ETH_TYPE_ARP               0x0806  // ARP
#define NDIS_ETH_TYPE_IPV6              0x86dd  // IPV6
#define NDIS_ETH_TYPE_802_1X            0x888e  // 802.1x
#define NDIS_ETH_TYPE_802_1Q            0x8100  // 802.1p
#define NDIS_ETH_TYPE_SLOW_PROTOCOL     0x8809  // Slow protocols (LACP, etc.)

#define NDIS_802_11_LENGTH_SSID         32
#define NDIS_802_11_LENGTH_RATES        8
#define NDIS_802_11_LENGTH_RATES_EX     16

//
// IEEE 802.11 Structures and definitions
//
// new types for Media Specific Indications
typedef enum _NDIS_802_11_STATUS_TYPE
{
    Ndis802_11StatusType_Authentication,
    Ndis802_11StatusType_MediaStreamMode,
    Ndis802_11StatusType_PMKID_CandidateList,
    Ndis802_11StatusTypeMax    // not a real type, defined as an upper bound
} NDIS_802_11_STATUS_TYPE, *PNDIS_802_11_STATUS_TYPE;

typedef UCHAR   NDIS_802_11_MAC_ADDRESS[6];

typedef struct _NDIS_802_11_STATUS_INDICATION
{
    NDIS_802_11_STATUS_TYPE StatusType;
} NDIS_802_11_STATUS_INDICATION, *PNDIS_802_11_STATUS_INDICATION;

// mask for authentication/integrity fields
#define NDIS_802_11_AUTH_REQUEST_AUTH_FIELDS		0x0f

#define NDIS_802_11_AUTH_REQUEST_REAUTH				0x01
#define NDIS_802_11_AUTH_REQUEST_KEYUPDATE			0x02
#define NDIS_802_11_AUTH_REQUEST_PAIRWISE_ERROR		0x06
#define NDIS_802_11_AUTH_REQUEST_GROUP_ERROR		0x0E

typedef struct _NDIS_802_11_AUTHENTICATION_REQUEST
{
    ULONG Length;            // Length of structure
    NDIS_802_11_MAC_ADDRESS Bssid;
    ULONG Flags;
} NDIS_802_11_AUTHENTICATION_REQUEST, *PNDIS_802_11_AUTHENTICATION_REQUEST;

//Added new types for PMKID Candidate lists.
typedef struct _PMKID_CANDIDATE {
    NDIS_802_11_MAC_ADDRESS BSSID;
    ULONG Flags;
} PMKID_CANDIDATE, *PPMKID_CANDIDATE;

typedef struct _NDIS_802_11_PMKID_CANDIDATE_LIST
{
    ULONG Version;       // Version of the structure
    ULONG NumCandidates; // No. of pmkid candidates
    PMKID_CANDIDATE CandidateList[1];
} NDIS_802_11_PMKID_CANDIDATE_LIST, *PNDIS_802_11_PMKID_CANDIDATE_LIST;

//Flags for PMKID Candidate list structure
#define NDIS_802_11_PMKID_CANDIDATE_PREAUTH_ENABLED	0x01

// Added new types for OFDM 5G and 2.4G
typedef enum _NDIS_802_11_NETWORK_TYPE
{
    Ndis802_11FH,
    Ndis802_11DS,
    Ndis802_11OFDM5,
    Ndis802_11OFDM24,
    Ndis802_11Automode,
    Ndis802_11NetworkTypeMax    // not a real type, defined as an upper bound
} NDIS_802_11_NETWORK_TYPE, *PNDIS_802_11_NETWORK_TYPE;

typedef struct _NDIS_802_11_NETWORK_TYPE_LIST
{
    ULONG                       NumberOfItems;  // in list below, at least 1
    NDIS_802_11_NETWORK_TYPE    NetworkType [1];
} NDIS_802_11_NETWORK_TYPE_LIST, *PNDIS_802_11_NETWORK_TYPE_LIST;

typedef enum _NDIS_802_11_POWER_MODE
{
    Ndis802_11PowerModeCAM,
    Ndis802_11PowerModeMAX_PSP,
    Ndis802_11PowerModeFast_PSP,
    Ndis802_11PowerModeMax      // not a real mode, defined as an upper bound
} NDIS_802_11_POWER_MODE, *PNDIS_802_11_POWER_MODE;

typedef ULONG   NDIS_802_11_TX_POWER_LEVEL; // in milliwatts

//
// Received Signal Strength Indication
//
typedef LONG   NDIS_802_11_RSSI;           // in dBm

typedef struct _NDIS_802_11_CONFIGURATION_FH
{
    ULONG           Length;             // Length of structure
    ULONG           HopPattern;         // As defined by 802.11, MSB set
    ULONG           HopSet;             // to one if non-802.11
    ULONG           DwellTime;          // units are Kusec
} NDIS_802_11_CONFIGURATION_FH, *PNDIS_802_11_CONFIGURATION_FH;

typedef struct _NDIS_802_11_CONFIGURATION
{
    ULONG           Length;             // Length of structure
    ULONG           BeaconPeriod;       // units are Kusec
    ULONG           ATIMWindow;         // units are Kusec
    ULONG           DSConfig;           // Frequency, units are kHz
    NDIS_802_11_CONFIGURATION_FH    FHConfig;
} NDIS_802_11_CONFIGURATION, *PNDIS_802_11_CONFIGURATION;

typedef struct _NDIS_802_11_STATISTICS
{
    ULONG           Length;             // Length of structure
    LARGE_INTEGER   TransmittedFragmentCount;
    LARGE_INTEGER   MulticastTransmittedFrameCount;
    LARGE_INTEGER   FailedCount;
    LARGE_INTEGER   RetryCount;
    LARGE_INTEGER   MultipleRetryCount;
    LARGE_INTEGER   RTSSuccessCount;
    LARGE_INTEGER   RTSFailureCount;
    LARGE_INTEGER   ACKFailureCount;
    LARGE_INTEGER   FrameDuplicateCount;
    LARGE_INTEGER   ReceivedFragmentCount;
    LARGE_INTEGER   MulticastReceivedFrameCount;
    LARGE_INTEGER   FCSErrorCount;
    LARGE_INTEGER   TKIPLocalMICFailures;
    LARGE_INTEGER   TKIPICVErrorCount;
    LARGE_INTEGER   TKIPCounterMeasuresInvoked;
    LARGE_INTEGER   TKIPReplays;
    LARGE_INTEGER   CCMPFormatErrors;
    LARGE_INTEGER   CCMPReplays;
    LARGE_INTEGER   CCMPDecryptErrors;
    LARGE_INTEGER   FourWayHandshakeFailures;
    LARGE_INTEGER   WEPUndecryptableCount;
    LARGE_INTEGER   WEPICVErrorCount;
    LARGE_INTEGER   DecryptSuccessCount;
    LARGE_INTEGER   DecryptFailureCount;
} NDIS_802_11_STATISTICS, *PNDIS_802_11_STATISTICS;

typedef  ULONG  NDIS_802_11_KEY_INDEX;
typedef ULONGLONG   NDIS_802_11_KEY_RSC;

// Key mapping keys require a BSSID
typedef struct _NDIS_802_11_KEY
{
    ULONG           Length;             // Length of this structure
    ULONG           KeyIndex;
    ULONG           KeyLength;          // length of key in bytes
    NDIS_802_11_MAC_ADDRESS BSSID;
    NDIS_802_11_KEY_RSC KeyRSC;
    UCHAR           KeyMaterial[1];     // variable length depending on above field
} NDIS_802_11_KEY, *PNDIS_802_11_KEY;

typedef struct _NDIS_802_11_REMOVE_KEY
{
    ULONG           Length;             // Length of this structure
    ULONG           KeyIndex;
    NDIS_802_11_MAC_ADDRESS BSSID;
} NDIS_802_11_REMOVE_KEY, *PNDIS_802_11_REMOVE_KEY;

typedef struct _NDIS_802_11_WEP
{
    ULONG           Length;             // Length of this structure
    ULONG           KeyIndex;           // 0 is the per-client key, 1-N are the
                                        // global keys
    ULONG           KeyLength;          // length of key in bytes
    UCHAR           KeyMaterial[1];     // variable length depending on above field
} NDIS_802_11_WEP, *PNDIS_802_11_WEP;


typedef enum _NDIS_802_11_NETWORK_INFRASTRUCTURE
{
    Ndis802_11IBSS,
    Ndis802_11Infrastructure,
    Ndis802_11AutoUnknown,
    Ndis802_11InfrastructureMax         // Not a real value, defined as upper bound
} NDIS_802_11_NETWORK_INFRASTRUCTURE, *PNDIS_802_11_NETWORK_INFRASTRUCTURE;

// Add new authentication modes
typedef enum _NDIS_802_11_AUTHENTICATION_MODE
{
    Ndis802_11AuthModeOpen,
    Ndis802_11AuthModeShared,
    Ndis802_11AuthModeAutoSwitch,
    Ndis802_11AuthModeWPA,
    Ndis802_11AuthModeWPAPSK,
    Ndis802_11AuthModeWPANone,
    Ndis802_11AuthModeWPA2,
    Ndis802_11AuthModeWPA2PSK,
    Ndis802_11AuthModeMax               // Not a real mode, defined as upper bound
} NDIS_802_11_AUTHENTICATION_MODE, *PNDIS_802_11_AUTHENTICATION_MODE;

typedef UCHAR   NDIS_802_11_RATES[NDIS_802_11_LENGTH_RATES];        // Set of 8 data rates
typedef UCHAR   NDIS_802_11_RATES_EX[NDIS_802_11_LENGTH_RATES_EX];  // Set of 16 data rates

typedef struct _NDIS_802_11_SSID
{
    ULONG   SsidLength;         // length of SSID field below, in bytes;
                                // this can be zero.
    UCHAR   Ssid[NDIS_802_11_LENGTH_SSID];           // SSID information field
} NDIS_802_11_SSID, *PNDIS_802_11_SSID;


typedef struct _NDIS_WLAN_BSSID
{
    ULONG                               Length;             // Length of this structure
    NDIS_802_11_MAC_ADDRESS             MacAddress;         // BSSID
    UCHAR                               Reserved[2];
    NDIS_802_11_SSID                    Ssid;               // SSID
    ULONG                               Privacy;            // WEP encryption requirement
    NDIS_802_11_RSSI                    Rssi;               // receive signal
                                                            // strength in dBm
    NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
    NDIS_802_11_CONFIGURATION           Configuration;
    NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
    NDIS_802_11_RATES                   SupportedRates;
} NDIS_WLAN_BSSID, *PNDIS_WLAN_BSSID;

typedef struct _NDIS_802_11_BSSID_LIST
{
    ULONG           NumberOfItems;      // in list below, at least 1
    NDIS_WLAN_BSSID Bssid[1];
} NDIS_802_11_BSSID_LIST, *PNDIS_802_11_BSSID_LIST;

// Added Capabilities, IELength and IEs for each BSSID
typedef struct _NDIS_WLAN_BSSID_EX
{
    ULONG                               Length;             // Length of this structure
    NDIS_802_11_MAC_ADDRESS             MacAddress;         // BSSID
    UCHAR                               Reserved[2];
    NDIS_802_11_SSID                    Ssid;               // SSID
    ULONG                               Privacy;            // WEP encryption requirement
    NDIS_802_11_RSSI                    Rssi;               // receive signal
                                                            // strength in dBm
    NDIS_802_11_NETWORK_TYPE            NetworkTypeInUse;
    NDIS_802_11_CONFIGURATION           Configuration;
    NDIS_802_11_NETWORK_INFRASTRUCTURE  InfrastructureMode;
    NDIS_802_11_RATES_EX                SupportedRates;
    ULONG                               IELength;
    UCHAR                               IEs[1];
} NDIS_WLAN_BSSID_EX, *PNDIS_WLAN_BSSID_EX;

typedef struct _NDIS_802_11_BSSID_LIST_EX
{
    ULONG           NumberOfItems;      // in list below, at least 1
    NDIS_WLAN_BSSID_EX Bssid[1];
} NDIS_802_11_BSSID_LIST_EX, *PNDIS_802_11_BSSID_LIST_EX;

typedef struct _NDIS_802_11_FIXED_IEs
{
	UCHAR Timestamp[8];
	USHORT BeaconInterval;
	USHORT Capabilities;
} NDIS_802_11_FIXED_IEs, *PNDIS_802_11_FIXED_IEs;

typedef struct _NDIS_802_11_VARIABLE_IEs
{
	UCHAR ElementID;
	UCHAR Length;	// Number of bytes in data field
	UCHAR data[1];
} NDIS_802_11_VARIABLE_IEs, *PNDIS_802_11_VARIABLE_IEs;

typedef  ULONG   NDIS_802_11_FRAGMENTATION_THRESHOLD;

typedef  ULONG   NDIS_802_11_RTS_THRESHOLD;

typedef  ULONG   NDIS_802_11_ANTENNA;

typedef enum _NDIS_802_11_PRIVACY_FILTER
{
    Ndis802_11PrivFilterAcceptAll,
    Ndis802_11PrivFilter8021xWEP
} NDIS_802_11_PRIVACY_FILTER, *PNDIS_802_11_PRIVACY_FILTER;

// Added new encryption types
// Also aliased typedef to new name
typedef enum _NDIS_802_11_WEP_STATUS
{
    Ndis802_11WEPEnabled,
    Ndis802_11Encryption1Enabled = Ndis802_11WEPEnabled,
    Ndis802_11WEPDisabled,
    Ndis802_11EncryptionDisabled = Ndis802_11WEPDisabled,
    Ndis802_11WEPKeyAbsent,
    Ndis802_11Encryption1KeyAbsent = Ndis802_11WEPKeyAbsent,
    Ndis802_11WEPNotSupported,
    Ndis802_11EncryptionNotSupported = Ndis802_11WEPNotSupported,
    Ndis802_11Encryption2Enabled,
    Ndis802_11Encryption2KeyAbsent,
    Ndis802_11Encryption3Enabled,
    Ndis802_11Encryption3KeyAbsent
} NDIS_802_11_WEP_STATUS, *PNDIS_802_11_WEP_STATUS,
  NDIS_802_11_ENCRYPTION_STATUS, *PNDIS_802_11_ENCRYPTION_STATUS;

typedef enum _NDIS_802_11_RELOAD_DEFAULTS
{
    Ndis802_11ReloadWEPKeys
} NDIS_802_11_RELOAD_DEFAULTS, *PNDIS_802_11_RELOAD_DEFAULTS;

#define NDIS_802_11_AI_REQFI_CAPABILITIES      1
#define NDIS_802_11_AI_REQFI_LISTENINTERVAL    2
#define NDIS_802_11_AI_REQFI_CURRENTAPADDRESS  4

#define NDIS_802_11_AI_RESFI_CAPABILITIES      1
#define NDIS_802_11_AI_RESFI_STATUSCODE        2
#define NDIS_802_11_AI_RESFI_ASSOCIATIONID     4

typedef struct _NDIS_802_11_AI_REQFI
{
    USHORT Capabilities;
    USHORT ListenInterval;
    NDIS_802_11_MAC_ADDRESS  CurrentAPAddress;
} NDIS_802_11_AI_REQFI, *PNDIS_802_11_AI_REQFI;

typedef struct _NDIS_802_11_AI_RESFI
{
    USHORT Capabilities;
    USHORT StatusCode;
    USHORT AssociationId;
} NDIS_802_11_AI_RESFI, *PNDIS_802_11_AI_RESFI;

typedef struct _NDIS_802_11_ASSOCIATION_INFORMATION
{
    ULONG Length;
    USHORT AvailableRequestFixedIEs;
    NDIS_802_11_AI_REQFI    RequestFixedIEs;
    ULONG RequestIELength;
    ULONG OffsetRequestIEs;
    USHORT AvailableResponseFixedIEs;
    NDIS_802_11_AI_RESFI    ResponseFixedIEs;
    ULONG ResponseIELength;
    ULONG OffsetResponseIEs;
} NDIS_802_11_ASSOCIATION_INFORMATION, *PNDIS_802_11_ASSOCIATION_INFORMATION;

typedef struct _NDIS_802_11_AUTHENTICATION_EVENT
{
    NDIS_802_11_STATUS_INDICATION       Status;
    NDIS_802_11_AUTHENTICATION_REQUEST  Request[1];
} NDIS_802_11_AUTHENTICATION_EVENT, *PNDIS_802_11_AUTHENTICATION_EVENT;

typedef struct _NDIS_802_11_TEST
{
    ULONG Length;
    ULONG Type;
    union
    {
        NDIS_802_11_AUTHENTICATION_EVENT AuthenticationEvent;
        NDIS_802_11_RSSI RssiTrigger;
    };
} NDIS_802_11_TEST, *PNDIS_802_11_TEST;

// 802.11 Media stream constraints, associated with OID_802_11_MEDIA_STREAM_MODE
typedef enum _NDIS_802_11_MEDIA_STREAM_MODE
{
    Ndis802_11MediaStreamOff,
    Ndis802_11MediaStreamOn,
} NDIS_802_11_MEDIA_STREAM_MODE, *PNDIS_802_11_MEDIA_STREAM_MODE;

// PMKID Structures
typedef UCHAR   NDIS_802_11_PMKID_VALUE[16];

typedef struct _BSSID_INFO
{
    NDIS_802_11_MAC_ADDRESS BSSID;
    NDIS_802_11_PMKID_VALUE PMKID;
} BSSID_INFO, *PBSSID_INFO;

typedef struct _NDIS_802_11_PMKID
{
    ULONG Length;
    ULONG BSSIDInfoCount;
    BSSID_INFO BSSIDInfo[1];
} NDIS_802_11_PMKID, *PNDIS_802_11_PMKID;

typedef struct _NDIS_802_11_AUTHENTICATION_ENCRYPTION
{
    NDIS_802_11_AUTHENTICATION_MODE AuthModeSupported;
    NDIS_802_11_ENCRYPTION_STATUS EncryptStatusSupported;
} NDIS_802_11_AUTHENTICATION_ENCRYPTION, *PNDIS_802_11_AUTHENTICATION_ENCRYPTION;

typedef struct _NDIS_802_11_CAPABILITY
{
    ULONG Length;
    ULONG Version;
    ULONG NoOfPMKIDs;
    ULONG NoOfAuthEncryptPairsSupported;
    NDIS_802_11_AUTHENTICATION_ENCRYPTION AuthenticationEncryptionSupported[1];
} NDIS_802_11_CAPABILITY, *PNDIS_802_11_CAPABILITY;

typedef struct _NDIS_802_11_NON_BCAST_SSID_LIST
{
    ULONG               NumberOfItems;
    NDIS_802_11_SSID    Non_Bcast_Ssid[1];
} NDIS_802_11_NON_BCAST_SSID_LIST, *PNDIS_802_11_NON_BCAST_SSID_LIST;

// for OID_802_11_RADIO_STATUS
typedef enum _NDIS_802_11_RADIO_STATUS
{
    Ndis802_11RadioStatusOn,
    Ndis802_11RadioStatusHardwareOff,
    Ndis802_11RadioStatusSoftwareOff,
    Ndis802_11RadioStatusHardwareSoftwareOff,
    Ndis802_11RadioStatusMax      // not a real mode, defined as an upper bound
}
NDIS_802_11_RADIO_STATUS, *PNDIS_802_11_RADIO_STATUS;

//
// IRDA objects
//
#define OID_IRDA_RECEIVING                      0x0A010100
#define OID_IRDA_TURNAROUND_TIME                0x0A010101
#define OID_IRDA_SUPPORTED_SPEEDS               0x0A010102
#define OID_IRDA_LINK_SPEED                     0x0A010103
#define OID_IRDA_MEDIA_BUSY                     0x0A010104

#define OID_IRDA_EXTRA_RCV_BOFS                 0x0A010200
#define OID_IRDA_RATE_SNIFF                     0x0A010201
#define OID_IRDA_UNICAST_LIST                   0x0A010202
#define OID_IRDA_MAX_UNICAST_LIST_SIZE          0x0A010203
#define OID_IRDA_MAX_RECEIVE_WINDOW_SIZE        0x0A010204
#define OID_IRDA_MAX_SEND_WINDOW_SIZE           0x0A010205
#define OID_IRDA_RESERVED1                      0x0A01020A  // The range between OID_IRDA_RESERVED1
#define OID_IRDA_RESERVED2                      0x0A01020F  // and OID_IRDA_RESERVED2 is reserved


//
// IEEE1394 mandatory general OIDs.
//
#define OID_1394_LOCAL_NODE_INFO                0x0C010101
#define OID_1394_VC_INFO                        0x0C010102

//
// The following OIDs are not specific to a media.
//

//
// These are objects for Connection-oriented media call-managers.
//
#define OID_CO_ADD_PVC                          0xFE000001
#define OID_CO_DELETE_PVC                       0xFE000002
#define OID_CO_GET_CALL_INFORMATION             0xFE000003
#define OID_CO_ADD_ADDRESS                      0xFE000004
#define OID_CO_DELETE_ADDRESS                   0xFE000005
#define OID_CO_GET_ADDRESSES                    0xFE000006
#define OID_CO_ADDRESS_CHANGE                   0xFE000007
#define OID_CO_SIGNALING_ENABLED                0xFE000008
#define OID_CO_SIGNALING_DISABLED               0xFE000009
#define OID_CO_AF_CLOSE                         0xFE00000A

//
// Objects for call-managers and MCMs that support TAPI access.
//
#define OID_CO_TAPI_CM_CAPS                     0xFE001001
#define OID_CO_TAPI_LINE_CAPS                   0xFE001002
#define OID_CO_TAPI_ADDRESS_CAPS                0xFE001003
#define OID_CO_TAPI_TRANSLATE_TAPI_CALLPARAMS   0xFE001004
#define OID_CO_TAPI_TRANSLATE_NDIS_CALLPARAMS   0xFE001005
#define OID_CO_TAPI_TRANSLATE_TAPI_SAP          0xFE001006
#define OID_CO_TAPI_GET_CALL_DIAGNOSTICS        0xFE001007
#define OID_CO_TAPI_REPORT_DIGITS               0xFE001008
#define OID_CO_TAPI_DONT_REPORT_DIGITS          0xFE001009

//
//  PnP and PM OIDs
//
#define OID_PNP_CAPABILITIES                    0xFD010100
#define OID_PNP_SET_POWER                       0xFD010101
#define OID_PNP_QUERY_POWER                     0xFD010102
#define OID_PNP_ADD_WAKE_UP_PATTERN             0xFD010103
#define OID_PNP_REMOVE_WAKE_UP_PATTERN          0xFD010104
#define OID_PNP_WAKE_UP_PATTERN_LIST            0xFD010105
#define OID_PNP_ENABLE_WAKE_UP                  0xFD010106

//
//  PnP/PM Statistics (Optional).
//
#define OID_PNP_WAKE_UP_OK                      0xFD020200
#define OID_PNP_WAKE_UP_ERROR                   0xFD020201

//
//  The following bits are defined for OID_PNP_ENABLE_WAKE_UP
//
#define NDIS_PNP_WAKE_UP_MAGIC_PACKET           0x00000001
#define NDIS_PNP_WAKE_UP_PATTERN_MATCH          0x00000002
#define NDIS_PNP_WAKE_UP_LINK_CHANGE            0x00000004

//
//  TCP/IP OIDs
//
#define OID_TCP_TASK_OFFLOAD                    0xFC010201
#define OID_TCP_TASK_IPSEC_ADD_SA               0xFC010202
#define OID_TCP_TASK_IPSEC_DELETE_SA            0xFC010203
#define OID_TCP_SAN_SUPPORT                     0xFC010204
#define OID_TCP_TASK_IPSEC_ADD_UDPESP_SA        0xFC010205
#define OID_TCP_TASK_IPSEC_DELETE_UDPESP_SA     0xFC010206
#define OID_TCP4_OFFLOAD_STATS                  0xFC010207
#define OID_TCP6_OFFLOAD_STATS                  0xFC010208
#define OID_IP4_OFFLOAD_STATS                   0xFC010209
#define OID_IP6_OFFLOAD_STATS                   0xFC01020A
//
// new offload OIDs for NDIS 6
//
#define OID_TCP_OFFLOAD_CURRENT_CONFIG          0xFC01020B          // query only, handled by NDIS
#define OID_TCP_OFFLOAD_PARAMETERS              0xFC01020C          // set only
#define OID_TCP_OFFLOAD_HARDWARE_CAPABILITIES   0xFC01020D          // query only
#define OID_TCP_CONNECTION_OFFLOAD_CURRENT_CONFIG 0xFC01020E        // query only
#define OID_TCP_CONNECTION_OFFLOAD_HARDWARE_CAPABILITIES 0xFC01020F // query only
#define OID_OFFLOAD_ENCAPSULATION               0x0101010A

#if (NDIS_SUPPORT_NDIS61)
//
// IPsec Task offload V2 OIDs
//
#define OID_TCP_TASK_IPSEC_OFFLOAD_V2_ADD_SA    0xFC030202
#define OID_TCP_TASK_IPSEC_OFFLOAD_V2_DELETE_SA 0xFC030203
#define OID_TCP_TASK_IPSEC_OFFLOAD_V2_UPDATE_SA 0xFC030204
#endif // (NDIS_SUPPORT_NDIS61)

//
//  Defines for FFP, obsolete
//
#define OID_FFP_SUPPORT                         0xFC010210
#define OID_FFP_FLUSH                           0xFC010211
#define OID_FFP_CONTROL                         0xFC010212
#define OID_FFP_PARAMS                          0xFC010213
#define OID_FFP_DATA                            0xFC010214

#define OID_FFP_DRIVER_STATS                    0xFC020210
#define OID_FFP_ADAPTER_STATS                   0xFC020211


//
// TCP Connection offload OID
//
#define OID_TCP_CONNECTION_OFFLOAD_PARAMETERS   0xFC030201

//
//  Defines for QOS
//
#define OID_QOS_RESERVED1                       0xFB010100
#define OID_QOS_RESERVED2                       0xFB010101
#define OID_QOS_RESERVED3                       0xFB010102
#define OID_QOS_RESERVED4                       0xFB010103
#define OID_QOS_RESERVED5                       0xFB010104
#define OID_QOS_RESERVED6                       0xFB010105
#define OID_QOS_RESERVED7                       0xFB010106
#define OID_QOS_RESERVED8                       0xFB010107
#define OID_QOS_RESERVED9                       0xFB010108
#define OID_QOS_RESERVED10                      0xFB010109
#define OID_QOS_RESERVED11                      0xFB01010A
#define OID_QOS_RESERVED12                      0xFB01010B
#define OID_QOS_RESERVED13                      0xFB01010C
#define OID_QOS_RESERVED14                      0xFB01010D
#define OID_QOS_RESERVED15                      0xFB01010E
#define OID_QOS_RESERVED16                      0xFB01010F
#define OID_QOS_RESERVED17                      0xFB010110
#define OID_QOS_RESERVED18                      0xFB010111
#define OID_QOS_RESERVED19                      0xFB010112
#define OID_QOS_RESERVED20                      0xFB010113


//
// NDIS Proxy OID_GEN_CO_DEVICE_PROFILE structure. The optional OID and
// this structure is a generic means of describing a CO device's
// capabilites, and is used by the NDIS Proxy to construct a TAPI device
// capabilities structure.
//
typedef struct NDIS_CO_DEVICE_PROFILE
{
    NDIS_VAR_DATA_DESC  DeviceDescription;  // e.g. 'GigabitATMNet'
    NDIS_VAR_DATA_DESC  DevSpecificInfo;    // special features

    ULONG   ulTAPISupplementaryPassThru;// reserved in NT5
    ULONG   ulAddressModes;
    ULONG   ulNumAddresses;
    ULONG   ulBearerModes;
    ULONG   ulMaxTxRate; // bytes per second
    ULONG   ulMinTxRate; // bytes per second
    ULONG   ulMaxRxRate; // bytes per second
    ULONG   ulMinRxRate; // bytes per second
    ULONG   ulMediaModes;

    //
    // Tone/digit generation and recognition capabilities
    //
    ULONG   ulGenerateToneModes;
    ULONG   ulGenerateToneMaxNumFreq;
    ULONG   ulGenerateDigitModes;
    ULONG   ulMonitorToneMaxNumFreq;
    ULONG   ulMonitorToneMaxNumEntries;
    ULONG   ulMonitorDigitModes;
    ULONG   ulGatherDigitsMinTimeout;// milliseconds
    ULONG   ulGatherDigitsMaxTimeout;// milliseconds

    ULONG   ulDevCapFlags;          // Misc. capabilities
    ULONG   ulMaxNumActiveCalls;    // (This * ulMinRate) = total bandwidth (which may equal ulMaxRate)
    ULONG   ulAnswerMode;           // Effect of answering a new call when an
                                    // existing call is non-idle
    //
    // User-User info sizes allowed to accompany each operation
    //
    ULONG   ulUUIAcceptSize;    // bytes
    ULONG   ulUUIAnswerSize;    // bytes
    ULONG   ulUUIMakeCallSize;  // bytes
    ULONG   ulUUIDropSize;      // bytes
    ULONG   ulUUISendUserUserInfoSize; // bytes
    ULONG   ulUUICallInfoSize;  // bytes

} NDIS_CO_DEVICE_PROFILE, *PNDIS_CO_DEVICE_PROFILE;

//
//  Structures for TCP IPsec.
//
#ifndef IP_EXPORT_INCLUDED
typedef ULONG   IPAddr, IPMask;
#endif
typedef ULONG   SPI_TYPE;

typedef enum    _OFFLOAD_OPERATION_E
{
    AUTHENTICATE = 1,
    ENCRYPT
}
    OFFLOAD_OPERATION_E;

typedef struct _OFFLOAD_ALGO_INFO
{
    ULONG   algoIdentifier;
    ULONG   algoKeylen;
    ULONG   algoRounds;
}
    OFFLOAD_ALGO_INFO,
    *POFFLOAD_ALGO_INFO;

typedef enum _OFFLOAD_CONF_ALGO
{
    OFFLOAD_IPSEC_CONF_NONE,
    OFFLOAD_IPSEC_CONF_DES,
    OFFLOAD_IPSEC_CONF_RESERVED,
    OFFLOAD_IPSEC_CONF_3_DES,
    OFFLOAD_IPSEC_CONF_MAX
}
    OFFLOAD_CONF_ALGO;

typedef enum _OFFLOAD_INTEGRITY_ALGO
{
    OFFLOAD_IPSEC_INTEGRITY_NONE,
    OFFLOAD_IPSEC_INTEGRITY_MD5,
    OFFLOAD_IPSEC_INTEGRITY_SHA,
    OFFLOAD_IPSEC_INTEGRITY_MAX
}
    OFFLOAD_INTEGRITY_ALGO;

typedef struct _OFFLOAD_SECURITY_ASSOCIATION
{
    OFFLOAD_OPERATION_E     Operation;
    SPI_TYPE                SPI;
    OFFLOAD_ALGO_INFO       IntegrityAlgo;
    OFFLOAD_ALGO_INFO       ConfAlgo;
    OFFLOAD_ALGO_INFO       Reserved;
}
    OFFLOAD_SECURITY_ASSOCIATION,
    *POFFLOAD_SECURITY_ASSOCIATION;

#define OFFLOAD_MAX_SAS             3

#define OFFLOAD_INBOUND_SA          0x0001
#define OFFLOAD_OUTBOUND_SA         0x0002

typedef struct _OFFLOAD_IPSEC_ADD_SA
{
    IPAddr                          SrcAddr;
    IPMask                          SrcMask;
    IPAddr                          DestAddr;
    IPMask                          DestMask;
    ULONG                           Protocol;
    USHORT                          SrcPort;
    USHORT                          DestPort;
    IPAddr                          SrcTunnelAddr;
    IPAddr                          DestTunnelAddr;
    USHORT                          Flags;
    SHORT                           NumSAs;
    OFFLOAD_SECURITY_ASSOCIATION    SecAssoc[OFFLOAD_MAX_SAS];
    HANDLE                          OffloadHandle;
    ULONG                           KeyLen;
    UCHAR                           KeyMat[1];
} OFFLOAD_IPSEC_ADD_SA, *POFFLOAD_IPSEC_ADD_SA;

typedef struct _OFFLOAD_IPSEC_DELETE_SA
{
    HANDLE                          OffloadHandle;
} OFFLOAD_IPSEC_DELETE_SA, *POFFLOAD_IPSEC_DELETE_SA;


typedef enum _UDP_ENCAP_TYPE
{
    OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_IKE,
    OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_OTHER
} UDP_ENCAP_TYPE, * PUDP_ENCAP_TYPE;


typedef struct _OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_ENTRY
{
    UDP_ENCAP_TYPE                  UdpEncapType;
    USHORT                          DstEncapPort;
} OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_ENTRY, * POFFLOAD_IPSEC_UDPESP_ENCAPTYPE_ENTRY;


typedef struct _OFFLOAD_IPSEC_ADD_UDPESP_SA
{
    IPAddr                                  SrcAddr;
    IPMask                                  SrcMask;
    IPAddr                                  DstAddr;
    IPMask                                  DstMask;
    ULONG                                   Protocol;
    USHORT                                  SrcPort;
    USHORT                                  DstPort;
    IPAddr                                  SrcTunnelAddr;
    IPAddr                                  DstTunnelAddr;
    USHORT                                  Flags;
    SHORT                                   NumSAs;
    OFFLOAD_SECURITY_ASSOCIATION            SecAssoc[OFFLOAD_MAX_SAS];
    HANDLE                                  OffloadHandle;
    OFFLOAD_IPSEC_UDPESP_ENCAPTYPE_ENTRY    EncapTypeEntry;
    HANDLE                                  EncapTypeEntryOffldHandle;
    ULONG                                   KeyLen;
    UCHAR                                   KeyMat[1];
} OFFLOAD_IPSEC_ADD_UDPESP_SA, * POFFLOAD_IPSEC_ADD_UDPESP_SA;


typedef struct _OFFLOAD_IPSEC_DELETE_UDPESP_SA
{
    HANDLE                                  OffloadHandle;
    HANDLE                                  EncapTypeEntryOffldHandle;
} OFFLOAD_IPSEC_DELETE_UDPESP_SA, * POFFLOAD_IPSEC_DELETE_UDPESP_SA;


//
// Type to go with OID_GEN_VLAN_ID: the least significant 12 bits are
// used as the VLAN ID (VID) per IEEE 802.1Q. Higher order bits are
// reserved and must be set to 0.
//
typedef ULONG NDIS_VLAN_ID;

//
// Medium the Ndis Driver is running on (OID_GEN_MEDIA_SUPPORTED/ OID_GEN_MEDIA_IN_USE).
//
typedef enum _NDIS_MEDIUM
{
    NdisMedium802_3,
    NdisMedium802_5,
    NdisMediumFddi,
    NdisMediumWan,
    NdisMediumLocalTalk,
    NdisMediumDix,              // defined for convenience, not a real medium
    NdisMediumArcnetRaw,
    NdisMediumArcnet878_2,
    NdisMediumAtm,
    NdisMediumWirelessWan,
    NdisMediumIrda,
    NdisMediumBpc,
    NdisMediumCoWan,
    NdisMedium1394,
    NdisMediumInfiniBand,
#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
    NdisMediumTunnel,
    NdisMediumNative802_11,
    NdisMediumLoopback,
#endif // (NTDDI_VERSION >= NTDDI_VISTA)
    NdisMediumMax               // Not a real medium, defined as an upper-bound
} NDIS_MEDIUM, *PNDIS_MEDIUM;


//
// Physical Medium Type definitions. Used with OID_GEN_PHYSICAL_MEDIUM.
//
typedef enum _NDIS_PHYSICAL_MEDIUM
{
    NdisPhysicalMediumUnspecified,
    NdisPhysicalMediumWirelessLan,
    NdisPhysicalMediumCableModem,
    NdisPhysicalMediumPhoneLine,
    NdisPhysicalMediumPowerLine,
    NdisPhysicalMediumDSL,      // includes ADSL and UADSL (G.Lite)
    NdisPhysicalMediumFibreChannel,
    NdisPhysicalMedium1394,
    NdisPhysicalMediumWirelessWan,
    NdisPhysicalMediumNative802_11,
    NdisPhysicalMediumBluetooth,
    NdisPhysicalMediumInfiniband,
    NdisPhysicalMediumWiMax,
    NdisPhysicalMediumUWB,
    NdisPhysicalMedium802_3,
    NdisPhysicalMedium802_5,
    NdisPhysicalMediumIrda,
    NdisPhysicalMediumWiredWAN,
    NdisPhysicalMediumWiredCoWan,
    NdisPhysicalMediumOther,
    NdisPhysicalMediumMax       // Not a real physical type, defined as an upper-bound
} NDIS_PHYSICAL_MEDIUM, *PNDIS_PHYSICAL_MEDIUM;


//
//  Protocol types supported by ndis. These values need to be consistent with ADDRESS_TYPE_XXX defined in TDI.H
//
#define NDIS_PROTOCOL_ID_DEFAULT        0x00
#define NDIS_PROTOCOL_ID_TCP_IP         0x02
#define NDIS_PROTOCOL_ID_IPX            0x06
#define NDIS_PROTOCOL_ID_NBF            0x07
#define NDIS_PROTOCOL_ID_MAX            0x0F
#define NDIS_PROTOCOL_ID_MASK           0x0F

//
// The following is used with OID_GEN_TRANSPORT_HEADER_OFFSET to indicate the length of the layer-2 header
// for packets sent by a particular protocol.
//
typedef struct _TRANSPORT_HEADER_OFFSET
{
    USHORT      ProtocolType;       // The protocol that is sending this OID (NDIS_PROTOCOL_ID_XXX above)
    USHORT      HeaderOffset;       // The header offset
} TRANSPORT_HEADER_OFFSET, *PTRANSPORT_HEADER_OFFSET;


//
// The structures below need to be consistent with TRANSPORT_ADDRESS structures in TDI.H
//
typedef struct _NETWORK_ADDRESS
{
    USHORT      AddressLength;      // length in bytes of Address[] in this
    USHORT      AddressType;        // type of this address (NDIS_PROTOCOL_ID_XXX above)
    UCHAR       Address[1];         // actually AddressLength bytes long
} NETWORK_ADDRESS, *PNETWORK_ADDRESS;

//
// The following is used with OID_GEN_NETWORK_LAYER_ADDRESSES to set network layer addresses on an interface
//
typedef struct _NETWORK_ADDRESS_LIST
{
    LONG        AddressCount;       // number of addresses following
    USHORT      AddressType;        // type of this address (NDIS_PROTOCOL_ID_XXX above)
    NETWORK_ADDRESS Address[1];     // actually AddressCount elements long
} NETWORK_ADDRESS_LIST, *PNETWORK_ADDRESS_LIST;

//
// IP address - This must remain consistent with TDI_ADDRESS_IP in tdi.h
//
typedef struct _NETWORK_ADDRESS_IP
{
    USHORT      sin_port;
    ULONG       in_addr;
    UCHAR       sin_zero[8];
} NETWORK_ADDRESS_IP, *PNETWORK_ADDRESS_IP;

#define NETWORK_ADDRESS_LENGTH_IP sizeof (NETWORK_ADDRESS_IP)

//
// IPX address - This must remain consistent with TDI_ADDRESS_IPX in tdi.h.
//
typedef struct _NETWORK_ADDRESS_IPX
{
    ULONG       NetworkAddress;
    UCHAR       NodeAddress[6];
    USHORT      Socket;
} NETWORK_ADDRESS_IPX, *PNETWORK_ADDRESS_IPX;

#define NETWORK_ADDRESS_LENGTH_IPX sizeof (NETWORK_ADDRESS_IPX)

//
// Hardware status codes (OID_GEN_HARDWARE_STATUS).
//

typedef enum _NDIS_HARDWARE_STATUS
{
    NdisHardwareStatusReady,
    NdisHardwareStatusInitializing,
    NdisHardwareStatusReset,
    NdisHardwareStatusClosing,
    NdisHardwareStatusNotReady
} NDIS_HARDWARE_STATUS, *PNDIS_HARDWARE_STATUS;


//
// this is the type passed in the OID_GEN_GET_TIME_CAPS request
//
typedef struct _GEN_GET_TIME_CAPS
{
    ULONG                       Flags;  // Bits defined below
    ULONG                       ClockPrecision;
} GEN_GET_TIME_CAPS, *PGEN_GET_TIME_CAPS;

#define READABLE_LOCAL_CLOCK                    0x00000001
#define CLOCK_NETWORK_DERIVED                   0x00000002
#define CLOCK_PRECISION                         0x00000004
#define RECEIVE_TIME_INDICATION_CAPABLE         0x00000008
#define TIMED_SEND_CAPABLE                      0x00000010
#define TIME_STAMP_CAPABLE                      0x00000020

//
// this is the type passed in the OID_GEN_GET_NETCARD_TIME request
//
typedef struct _GEN_GET_NETCARD_TIME
{
    ULONGLONG                   ReadTime;
} GEN_GET_NETCARD_TIME, *PGEN_GET_NETCARD_TIME;

//
//  NDIS PnP routines and definitions.
//
typedef struct _NDIS_PM_PACKET_PATTERN
{
    ULONG   Priority;                   // Importance of the given pattern.
    ULONG   Reserved;                   // Context information for transports.
    ULONG   MaskSize;                   // Size in bytes of the pattern mask.
    ULONG   PatternOffset;              // Offset from beginning of this
                                        // structure to the pattern bytes.
    ULONG   PatternSize;                // Size in bytes of the pattern.
    ULONG   PatternFlags;               // Flags (TBD).
} NDIS_PM_PACKET_PATTERN, *PNDIS_PM_PACKET_PATTERN;


//
//  The following structure defines the device power states.
//
typedef enum _NDIS_DEVICE_POWER_STATE
{
    NdisDeviceStateUnspecified = 0,
    NdisDeviceStateD0,
    NdisDeviceStateD1,
    NdisDeviceStateD2,
    NdisDeviceStateD3,
    NdisDeviceStateMaximum
} NDIS_DEVICE_POWER_STATE, *PNDIS_DEVICE_POWER_STATE;

//
//  The following structure defines the wake-up capabilities of the device.
//
typedef struct _NDIS_PM_WAKE_UP_CAPABILITIES
{
    NDIS_DEVICE_POWER_STATE MinMagicPacketWakeUp;
    NDIS_DEVICE_POWER_STATE MinPatternWakeUp;
    NDIS_DEVICE_POWER_STATE MinLinkChangeWakeUp;
} NDIS_PM_WAKE_UP_CAPABILITIES, *PNDIS_PM_WAKE_UP_CAPABILITIES;

//
// the following flags define the -enabled- wake-up capabilities of the device
// passed in the Flags field of NDIS_PNP_CAPABILITIES structure
//
#define NDIS_DEVICE_WAKE_UP_ENABLE                          0x00000001
#define NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE            0x00000002
#define NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE             0x00000004

//
//  This structure defines general PnP capabilities of the miniport driver.
//
typedef struct _NDIS_PNP_CAPABILITIES
{
    ULONG                           Flags;
    NDIS_PM_WAKE_UP_CAPABILITIES    WakeUpCapabilities;
} NDIS_PNP_CAPABILITIES, *PNDIS_PNP_CAPABILITIES;

//
// Defines the attachment types for FDDI (OID_FDDI_ATTACHMENT_TYPE).
//
typedef enum _NDIS_FDDI_ATTACHMENT_TYPE
{
    NdisFddiTypeIsolated = 1,
    NdisFddiTypeLocalA,
    NdisFddiTypeLocalB,
    NdisFddiTypeLocalAB,
    NdisFddiTypeLocalS,
    NdisFddiTypeWrapA,
    NdisFddiTypeWrapB,
    NdisFddiTypeWrapAB,
    NdisFddiTypeWrapS,
    NdisFddiTypeCWrapA,
    NdisFddiTypeCWrapB,
    NdisFddiTypeCWrapS,
    NdisFddiTypeThrough
} NDIS_FDDI_ATTACHMENT_TYPE, *PNDIS_FDDI_ATTACHMENT_TYPE;


//
// Defines the ring management states for FDDI (OID_FDDI_RING_MGT_STATE).
//
typedef enum _NDIS_FDDI_RING_MGT_STATE
{
    NdisFddiRingIsolated = 1,
    NdisFddiRingNonOperational,
    NdisFddiRingOperational,
    NdisFddiRingDetect,
    NdisFddiRingNonOperationalDup,
    NdisFddiRingOperationalDup,
    NdisFddiRingDirected,
    NdisFddiRingTrace
} NDIS_FDDI_RING_MGT_STATE, *PNDIS_FDDI_RING_MGT_STATE;


//
// Defines the Lconnection state for FDDI (OID_FDDI_LCONNECTION_STATE).
//
typedef enum _NDIS_FDDI_LCONNECTION_STATE
{
    NdisFddiStateOff = 1,
    NdisFddiStateBreak,
    NdisFddiStateTrace,
    NdisFddiStateConnect,
    NdisFddiStateNext,
    NdisFddiStateSignal,
    NdisFddiStateJoin,
    NdisFddiStateVerify,
    NdisFddiStateActive,
    NdisFddiStateMaintenance
} NDIS_FDDI_LCONNECTION_STATE, *PNDIS_FDDI_LCONNECTION_STATE;


//
// Defines the medium subtypes for WAN medium (OID_WAN_MEDIUM_SUBTYPE).
// Sub-medium used only by connection-oriented WAN devices
// i.e. NdisMediumWan, NdisMediumCoWan.
//
typedef enum _NDIS_WAN_MEDIUM_SUBTYPE
{
    NdisWanMediumHub,
    NdisWanMediumX_25,
    NdisWanMediumIsdn,
    NdisWanMediumSerial,
    NdisWanMediumFrameRelay,
    NdisWanMediumAtm,
    NdisWanMediumSonet,
    NdisWanMediumSW56K,
    NdisWanMediumPPTP,
    NdisWanMediumL2TP,
    NdisWanMediumIrda,
    NdisWanMediumParallel,
    NdisWanMediumPppoe
#if (NTDDI_VERSION >= NTDDI_VISTA)    
    ,
    NdisWanMediumSSTP
#endif //(NTDDI_VERSION >= NTDDI_VISTA)    
} NDIS_WAN_MEDIUM_SUBTYPE, *PNDIS_WAN_MEDIUM_SUBTYPE;


//
// Defines the header format for WAN medium (OID_WAN_HEADER_FORMAT).
//
typedef enum _NDIS_WAN_HEADER_FORMAT
{
    NdisWanHeaderNative,        // src/dest based on subtype, followed by NLPID
    NdisWanHeaderEthernet       // emulation of ethernet header
} NDIS_WAN_HEADER_FORMAT, *PNDIS_WAN_HEADER_FORMAT;


//
// Defines the line quality on a WAN line (OID_WAN_QUALITY_OF_SERVICE).
//
typedef enum _NDIS_WAN_QUALITY
{
    NdisWanRaw,
    NdisWanErrorControl,
    NdisWanReliable
} NDIS_WAN_QUALITY, *PNDIS_WAN_QUALITY;


//
// Defines a protocol's WAN specific capabilities (OID_WAN_PROTOCOL_CAPS).
//
typedef struct _NDIS_WAN_PROTOCOL_CAPS
{
    IN  ULONG   Flags;
    IN  ULONG   Reserved;
} NDIS_WAN_PROTOCOL_CAPS, *PNDIS_WAN_PROTOCOL_CAPS;


//
// Flags used in NDIS_WAN_PROTOCOL_CAPS
//
#define WAN_PROTOCOL_KEEPS_STATS    0x00000001


//
// Defines the state of a token-ring adapter (OID_802_5_CURRENT_RING_STATE).
//
typedef enum _NDIS_802_5_RING_STATE
{
    NdisRingStateOpened = 1,
    NdisRingStateClosed,
    NdisRingStateOpening,
    NdisRingStateClosing,
    NdisRingStateOpenFailure,
    NdisRingStateRingFailure
} NDIS_802_5_RING_STATE, *PNDIS_802_5_RING_STATE;

//
// Defines the state of the LAN media
//
typedef enum _NDIS_MEDIA_STATE
{
    NdisMediaStateConnected,
    NdisMediaStateDisconnected
} NDIS_MEDIA_STATE, *PNDIS_MEDIA_STATE;

//
// The following is set on a per-packet basis as OOB data with NdisClass802_3Priority
//
typedef ULONG   Priority_802_3;         // 0-7 priority levels

//
//  The following structure is used to query OID_GEN_CO_LINK_SPEED and
//  OID_GEN_CO_MINIMUM_LINK_SPEED. The first OID will return the current
//  link speed of the adapter. The second will return the minimum link speed
//  the adapter is capable of.
//
typedef struct _NDIS_CO_LINK_SPEED
{
    ULONG   Outbound;
    ULONG   Inbound;
} NDIS_CO_LINK_SPEED, *PNDIS_CO_LINK_SPEED;

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)

//
// The following structure is used in OID_GEN_LINK_SPEED_EX for interfaces
// and is expressed in bits per second.
//
typedef struct _NDIS_LINK_SPEED
{
    ULONG64     XmitLinkSpeed;
    ULONG64     RcvLinkSpeed;
} NDIS_LINK_SPEED, *PNDIS_LINK_SPEED;



// miniports or interfaces that do not know their current link speed
// can report NDIS_LINK_SPEED_UNKNOWN == ((ULONG64)-1)
#define NDIS_LINK_SPEED_UNKNOWN NET_IF_LINK_SPEED_UNKNOWN
#endif

#ifndef _NDIS_
typedef int NDIS_STATUS, *PNDIS_STATUS;
#endif

#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)
// Native 802.11 Definitions
#ifndef __WINDOT11_H__
#include <windot11.h>
#endif
#endif // (NTDDI_VERSION >= NTDDI_VISTA)


//
//  Structure to be used for OID_GEN_SUPPORTED_GUIDS.
//  This structure describes an OID to GUID mapping.
//  Or a Status to GUID mapping.
//  When ndis receives a request for a give GUID it will
//  query the miniport with the supplied OID.
//
typedef struct _NDIS_GUID
{
    GUID            Guid;
    union
    {
        NDIS_OID    Oid;
        NDIS_STATUS Status;
    };
    ULONG       Size;               //  Size of the data element. If the GUID
                                    //  represents an array then this is the
                                    //  size of an element in the array.
                                    //  This is -1 for strings.
    ULONG       Flags;
} NDIS_GUID, *PNDIS_GUID;

#define fNDIS_GUID_TO_OID                   0x00000001
#define fNDIS_GUID_TO_STATUS                0x00000002
#define fNDIS_GUID_ANSI_STRING              0x00000004
#define fNDIS_GUID_UNICODE_STRING           0x00000008
#define fNDIS_GUID_ARRAY                    0x00000010
#define fNDIS_GUID_ALLOW_READ               0x00000020
#define fNDIS_GUID_ALLOW_WRITE              0x00000040
#define fNDIS_GUID_METHOD                   0x00000080
#define fNDIS_GUID_NDIS_RESERVED            0x00000100 
#define fNDIS_GUID_SUPPORT_COMMON_HEADER    0x00000200

//
// Ndis Packet Filter Bits (OID_GEN_CURRENT_PACKET_FILTER).
//
#define NDIS_PACKET_TYPE_DIRECTED               0x00000001
#define NDIS_PACKET_TYPE_MULTICAST              0x00000002
#define NDIS_PACKET_TYPE_ALL_MULTICAST          0x00000004
#define NDIS_PACKET_TYPE_BROADCAST              0x00000008
#define NDIS_PACKET_TYPE_SOURCE_ROUTING         0x00000010
#define NDIS_PACKET_TYPE_PROMISCUOUS            0x00000020
#define NDIS_PACKET_TYPE_SMT                    0x00000040
#define NDIS_PACKET_TYPE_ALL_LOCAL              0x00000080
#define NDIS_PACKET_TYPE_GROUP                  0x00001000
#define NDIS_PACKET_TYPE_ALL_FUNCTIONAL         0x00002000
#define NDIS_PACKET_TYPE_FUNCTIONAL             0x00004000
#define NDIS_PACKET_TYPE_MAC_FRAME              0x00008000
#define NDIS_PACKET_TYPE_NO_LOCAL               0x00010000


//
// Ndis Token-Ring Ring Status Codes (OID_802_5_CURRENT_RING_STATUS).
//
#define NDIS_RING_SIGNAL_LOSS                   0x00008000
#define NDIS_RING_HARD_ERROR                    0x00004000
#define NDIS_RING_SOFT_ERROR                    0x00002000
#define NDIS_RING_TRANSMIT_BEACON               0x00001000
#define NDIS_RING_LOBE_WIRE_FAULT               0x00000800
#define NDIS_RING_AUTO_REMOVAL_ERROR            0x00000400
#define NDIS_RING_REMOVE_RECEIVED               0x00000200
#define NDIS_RING_COUNTER_OVERFLOW              0x00000100
#define NDIS_RING_SINGLE_STATION                0x00000080
#define NDIS_RING_RING_RECOVERY                 0x00000040


//
// Ndis protocol option bits (OID_GEN_PROTOCOL_OPTIONS).
//
#define NDIS_PROT_OPTION_ESTIMATED_LENGTH               0x00000001
#define NDIS_PROT_OPTION_NO_LOOPBACK                    0x00000002
#define NDIS_PROT_OPTION_NO_RSVD_ON_RCVPKT              0x00000004
#define NDIS_PROT_OPTION_SEND_RESTRICTED                0x00000008

//
// Ndis MAC option bits (OID_GEN_MAC_OPTIONS).
//
#define NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA             0x00000001
#define NDIS_MAC_OPTION_RECEIVE_SERIALIZED              0x00000002
#define NDIS_MAC_OPTION_TRANSFERS_NOT_PEND              0x00000004
#define NDIS_MAC_OPTION_NO_LOOPBACK                     0x00000008

//
// This flag has been deprecated. Deserialized drivers are
// full duplex drivers
//
#define NDIS_MAC_OPTION_FULL_DUPLEX                     0x00000010  // deprecated


#define NDIS_MAC_OPTION_EOTX_INDICATION                 0x00000020
#define NDIS_MAC_OPTION_8021P_PRIORITY                  0x00000040
#define NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE  0x00000080
#define NDIS_MAC_OPTION_RECEIVE_AT_DPC                  0x00000100
#define NDIS_MAC_OPTION_8021Q_VLAN                      0x00000200
#define NDIS_MAC_OPTION_RESERVED                        0x80000000

//
//  NDIS media capabilities bits (OID_GEN_MEDIA_CAPABILITIES).
//
#define NDIS_MEDIA_CAP_TRANSMIT                 0x00000001  // Supports sending data
#define NDIS_MEDIA_CAP_RECEIVE                  0x00000002  // Supports receiving data

//
//  NDIS MAC option bits for OID_GEN_CO_MAC_OPTIONS.
//
#define NDIS_CO_MAC_OPTION_DYNAMIC_LINK_SPEED   0x00000001

//
// The following is set on a per-packet basis as OOB data with NdisClassIrdaPacketInfo
// This is the per-packet info specified on a per-packet basis
//
typedef struct _NDIS_IRDA_PACKET_INFO
{
    ULONG                       ExtraBOFs;
    ULONG                       MinTurnAroundTime;
} NDIS_IRDA_PACKET_INFO, *PNDIS_IRDA_PACKET_INFO;



#if ((NTDDI_VERSION >= NTDDI_VISTA) || NDIS_SUPPORT_NDIS6)

//
// The following macro is used to build a NET_LUID
//

#define NDIS_MAKE_NET_LUID(_pNetLuid, _IfType, _NetLuidIndex)       \
{                                                                   \
    (_pNetLuid)->Info.IfType = _IfType;                             \
    (_pNetLuid)->Info.NetLuidIndex = _NetLuidIndex;                 \
    (_pNetLuid)->Info.Reserved = 0;                                 \
}

#define NDIS_IF_MAX_STRING_SIZE IF_MAX_STRING_SIZE
typedef IF_COUNTED_STRING NDIS_IF_COUNTED_STRING, *PNDIS_IF_COUNTED_STRING;

#define NDIS_MAX_PHYS_ADDRESS_LENGTH IF_MAX_PHYS_ADDRESS_LENGTH
typedef IF_PHYSICAL_ADDRESS NDIS_IF_PHYSICAL_ADDRESS, *PNDIS_IF_PHYSICAL_ADDRESS;

//
// NDIS_MEDIA_CONNECT_STATE enum type is used in OID_GEN_MEDIA_CONNECT_STATUS_EX
//
typedef NET_IF_MEDIA_CONNECT_STATE NDIS_MEDIA_CONNECT_STATE, *PNDIS_MEDIA_CONNECT_STATE;

//
// NET_IF_MEDIA_DUPLEX_STATE enum type is used in OID_GEN_MEDIA_DUPLEX_STATE
//
typedef NET_IF_MEDIA_DUPLEX_STATE NDIS_MEDIA_DUPLEX_STATE, *PNDIS_MEDIA_DUPLEX_STATE;

typedef enum _NDIS_SUPPORTED_PAUSE_FUNCTIONS
{
    NdisPauseFunctionsUnsupported,
    NdisPauseFunctionsSendOnly,
    NdisPauseFunctionsReceiveOnly,
    NdisPauseFunctionsSendAndReceive,
    NdisPauseFunctionsUnknown
} NDIS_SUPPORTED_PAUSE_FUNCTIONS, *PNDIS_SUPPORTED_PAUSE_FUNCTIONS;

#define NDIS_LINK_STATE_XMIT_LINK_SPEED_AUTO_NEGOTIATED         0x00000001
#define NDIS_LINK_STATE_RCV_LINK_SPEED_AUTO_NEGOTIATED          0x00000002
#define NDIS_LINK_STATE_DUPLEX_AUTO_NEGOTIATED                  0x00000004
#define NDIS_LINK_STATE_PAUSE_FUNCTIONS_AUTO_NEGOTIATED         0x00000008

    

//
// structure used in NDIS_STATUS_LINK_STATE and OID_GEN_LINK_STATE
//

#define NDIS_LINK_STATE_REVISION_1      1

typedef struct _NDIS_LINK_STATE
{
    NDIS_OBJECT_HEADER              Header;
    NDIS_MEDIA_CONNECT_STATE        MediaConnectState;
    NDIS_MEDIA_DUPLEX_STATE         MediaDuplexState;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NDIS_SUPPORTED_PAUSE_FUNCTIONS  PauseFunctions;
    ULONG                           AutoNegotiationFlags;
} NDIS_LINK_STATE, *PNDIS_LINK_STATE;

#define NDIS_SIZEOF_LINK_STATE_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_LINK_STATE, AutoNegotiationFlags)

//
// the following structure is used in OID_GEN_LINK_PARAMETERS
//

#define NDIS_LINK_PARAMETERS_REVISION_1      1

typedef struct _NDIS_LINK_PARAMETERS
{
    NDIS_OBJECT_HEADER              Header;
    NDIS_MEDIA_DUPLEX_STATE         MediaDuplexState;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NDIS_SUPPORTED_PAUSE_FUNCTIONS  PauseFunctions;
    ULONG                           AutoNegotiationFlags;    
} NDIS_LINK_PARAMETERS, *PNDIS_LINK_PARAMETERS;

#define NDIS_SIZEOF_LINK_PARAMETERS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_LINK_PARAMETERS, AutoNegotiationFlags)

//
// structure used in NDIS_STATUS_LINK_STATE and OID_GEN_LINK_STATE
//

#define NDIS_OPER_STATE_REVISION_1      1

typedef struct _NDIS_OPER_STATE
{
    NDIS_OBJECT_HEADER              Header;
    NET_IF_OPER_STATUS              OperationalStatus;
    ULONG                           OperationalStatusFlags;
} NDIS_OPER_STATE, *PNDIS_OPER_STATE;

#define NDIS_SIZEOF_OPER_STATE_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_OPER_STATE, OperationalStatusFlags)

//
// These defines and structures are used with 
// OID_TCP_OFFLOAD_PARAMETERS
//

#define NDIS_OFFLOAD_PARAMETERS_NO_CHANGE                  0

//
// values used in IPv4Checksum, TCPIPv4Checksum, UDPIPv4Checksum
// TCPIPv6Checksum and UDPIPv6Checksum
//
#define NDIS_OFFLOAD_PARAMETERS_TX_RX_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_TX_ENABLED_RX_DISABLED     2
#define NDIS_OFFLOAD_PARAMETERS_RX_ENABLED_TX_DISABLED     3
#define NDIS_OFFLOAD_PARAMETERS_TX_RX_ENABLED              4

//
// values used in LsoV1
//
#define NDIS_OFFLOAD_PARAMETERS_LSOV1_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_LSOV1_ENABLED              2

//
// values used in IPsecV1
//
#define NDIS_OFFLOAD_PARAMETERS_IPSECV1_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_IPSECV1_AH_ENABLED           2
#define NDIS_OFFLOAD_PARAMETERS_IPSECV1_ESP_ENABLED          3
#define NDIS_OFFLOAD_PARAMETERS_IPSECV1_AH_AND_ESP_ENABLED   4

//
// values used in LsoV2
//
#define NDIS_OFFLOAD_PARAMETERS_LSOV2_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_LSOV2_ENABLED              2

#if (NDIS_SUPPORT_NDIS61)
//
// values used in IPsecV2 and IPsecV2IPv4
//
#define NDIS_OFFLOAD_PARAMETERS_IPSECV2_DISABLED             1
#define NDIS_OFFLOAD_PARAMETERS_IPSECV2_AH_ENABLED           2
#define NDIS_OFFLOAD_PARAMETERS_IPSECV2_ESP_ENABLED          3
#define NDIS_OFFLOAD_PARAMETERS_IPSECV2_AH_AND_ESP_ENABLED   4
#endif // (NDIS_SUPPORT_NDIS61)

//
// values used in TcpConnectionIPv4 and TcpConnectionIPv6 fields
// of NDIS_OFFLOAD_PARAMETERS
//
#define NDIS_OFFLOAD_PARAMETERS_CONNECTION_OFFLOAD_DISABLED     1
#define NDIS_OFFLOAD_PARAMETERS_CONNECTION_OFFLOAD_ENABLED      2

//
// Used in OID_TCP_OFFLOAD_PARAMETERS for setting 
// the offload parameters of a NIC
//

#define NDIS_OFFLOAD_PARAMETERS_REVISION_1            1

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_OFFLOAD_PARAMETERS_REVISION_2            2
#endif // (NDIS_SUPPORT_NDIS61)

typedef struct _NDIS_OFFLOAD_PARAMETERS
{
    NDIS_OBJECT_HEADER      Header;

    UCHAR                   IPv4Checksum;
    UCHAR                   TCPIPv4Checksum;
    UCHAR                   UDPIPv4Checksum;
    
    UCHAR                   TCPIPv6Checksum;
    UCHAR                   UDPIPv6Checksum;

    UCHAR                   LsoV1;
    UCHAR                   IPsecV1;
    
    UCHAR                   LsoV2IPv4;
    UCHAR                   LsoV2IPv6;

    UCHAR                   TcpConnectionIPv4;
    UCHAR                   TcpConnectionIPv6;
    
    ULONG                   Flags;

#if (NDIS_SUPPORT_NDIS61)
    UCHAR                   IPsecV2;
    UCHAR                   IPsecV2IPv4;
    UCHAR                   Reserved1;
    UCHAR                   Reserved2;
#endif // (NDIS_SUPPORT_NDIS61)
} NDIS_OFFLOAD_PARAMETERS, *PNDIS_OFFLOAD_PARAMETERS;

#define NDIS_SIZEOF_OFFLOAD_PARAMETERS_REVISION_1 RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD_PARAMETERS, Flags)

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_OFFLOAD_PARAMETERS_REVISION_2 RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD_PARAMETERS, IPsecV2IPv4)
#endif // (NDIS_SUPPORT_NDIS61)

#define NDIS_OFFLOAD_NOT_SUPPORTED             0
#define NDIS_OFFLOAD_SUPPORTED                 1

#define NDIS_OFFLOAD_SET_NO_CHANGE             0
#define NDIS_OFFLOAD_SET_ON                    1
#define NDIS_OFFLOAD_SET_OFF                   2

//
// Encapsulation types that are used during offload in query and set
//
#define NDIS_ENCAPSULATION_NOT_SUPPORTED                0x00000000                         
#define NDIS_ENCAPSULATION_NULL                         0x00000001
#define NDIS_ENCAPSULATION_IEEE_802_3                   0x00000002
#define NDIS_ENCAPSULATION_IEEE_802_3_P_AND_Q           0x00000004
#define NDIS_ENCAPSULATION_IEEE_802_3_P_AND_Q_IN_OOB    0x00000008
#define NDIS_ENCAPSULATION_IEEE_LLC_SNAP_ROUTED         0x00000010

#pragma warning(push)
#pragma warning(disable:4214) //nonstandard extension used : bit field types other than int

//
// Describes the large send offload version 1 capabilities
// or configuration of the NIC. Used in NDIS_OFFLOAD structure
//
typedef struct _NDIS_TCP_LARGE_SEND_OFFLOAD_V1
{

    struct
    {
        ULONG     Encapsulation;
        ULONG     MaxOffLoadSize;
        ULONG     MinSegmentCount;
        ULONG     TcpOptions:2;
        ULONG     IpOptions:2;
    } IPv4;
   
} NDIS_TCP_LARGE_SEND_OFFLOAD_V1, *PNDIS_TCP_LARGE_SEND_OFFLOAD_V1;


//
// Describes the checksum task offload capabilities or configuration 
// of the NIC. used in NDIS_OFFLOAD structure
//
typedef struct _NDIS_TCP_IP_CHECKSUM_OFFLOAD
{

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpOptionsSupported:2;
        ULONG       TcpOptionsSupported:2;
        ULONG       TcpChecksum:2;
        ULONG       UdpChecksum:2;
        ULONG       IpChecksum:2;
    } IPv4Transmit;

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpOptionsSupported:2;
        ULONG       TcpOptionsSupported:2;
        ULONG       TcpChecksum:2;
        ULONG       UdpChecksum:2;
        ULONG       IpChecksum:2;
    } IPv4Receive;


    struct
    {
        ULONG       Encapsulation;
        ULONG       IpExtensionHeadersSupported:2;
        ULONG       TcpOptionsSupported:2;
        ULONG       TcpChecksum:2;
        ULONG       UdpChecksum:2;

    } IPv6Transmit;

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpExtensionHeadersSupported:2;
        ULONG       TcpOptionsSupported:2;
        ULONG       TcpChecksum:2;
        ULONG       UdpChecksum:2;

    } IPv6Receive;

} NDIS_TCP_IP_CHECKSUM_OFFLOAD, *PNDIS_TCP_IP_CHECKSUM_OFFLOAD;


//
// Describes the IPsec task offload version 1 capabilities 
// or configuration of the NIC. Used in NDIS_OFFLOAD structure
//
typedef struct _NDIS_IPSEC_OFFLOAD_V1
{
    struct
    {
        ULONG   Encapsulation;
        ULONG   AhEspCombined;
        ULONG   TransportTunnelCombined;
        ULONG   IPv4Options;
        ULONG   Flags;
    } Supported;

    struct
    {
        ULONG   Md5:2;
        ULONG   Sha_1:2;
        ULONG   Transport:2;
        ULONG   Tunnel:2;
        ULONG   Send:2;
        ULONG   Receive:2;
    } IPv4AH;

    struct
    {
        ULONG   Des:2;
        ULONG   Reserved:2;
        ULONG   TripleDes:2;
        ULONG   NullEsp:2;
        ULONG   Transport:2;
        ULONG   Tunnel:2;
        ULONG   Send:2;
        ULONG   Receive:2;
    } IPv4ESP;

} NDIS_IPSEC_OFFLOAD_V1, *PNDIS_IPSEC_OFFLOAD_V1;

//
// Describes the large send offload version 2 capabilities
// or configuration of the NIC. Used in NDIS_OFFLOAD structure
//
typedef struct _NDIS_TCP_LARGE_SEND_OFFLOAD_V2
{
    struct 
    {
         ULONG     Encapsulation;
         ULONG     MaxOffLoadSize;
         ULONG     MinSegmentCount;
    }IPv4;

    struct 
    {
         ULONG     Encapsulation;
         ULONG     MaxOffLoadSize;
         ULONG     MinSegmentCount;
         ULONG     IpExtensionHeadersSupported:2;
         ULONG     TcpOptionsSupported:2;
    }IPv6;

} NDIS_TCP_LARGE_SEND_OFFLOAD_V2, *PNDIS_TCP_LARGE_SEND_OFFLOAD_V2;

#if (NDIS_SUPPORT_NDIS61)
//
//  Structures for IPSec Task Offload V2.
//

//
// IPsec Algorithms for Authentication used in AuthenticationAlgorithms field
// of NDIS_IPSEC_OFFLOAD_V2 structure
//
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_MD5                      0x00000001
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_SHA_1                    0x00000002
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_SHA_256                  0x00000004
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_AES_GCM_128              0x00000008
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_AES_GCM_192              0x00000010
#define IPSEC_OFFLOAD_V2_AUTHENTICATION_AES_GCM_256              0x00000020

//
// IPsec Algorithms for Encryption used in EncryptionAlgorithms field of
// NDIS_IPSEC_OFFLOAD_V2 structure
//
#define IPSEC_OFFLOAD_V2_ENCRYPTION_NONE                          0x00000001
#define IPSEC_OFFLOAD_V2_ENCRYPTION_DES_CBC                       0x00000002
#define IPSEC_OFFLOAD_V2_ENCRYPTION_3_DES_CBC                     0x00000004
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_GCM_128                   0x00000008
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_GCM_192                   0x00000010
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_GCM_256                   0x00000020
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_CBC_128                   0x00000040
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_CBC_192                   0x00000080
#define IPSEC_OFFLOAD_V2_ENCRYPTION_AES_CBC_256                   0x00000100

//
// IPsec offload V2 capabilities used in  NDIS_OFFLOAD
//
typedef struct _NDIS_IPSEC_OFFLOAD_V2
{
    ULONG       Encapsulation;      // MAC encap types supported
    BOOLEAN     IPv6Supported;      // IPv6 Supported
    BOOLEAN     IPv4Options;                           // Supports offload of packets with IPv4 options
    BOOLEAN     IPv6NonIPsecExtensionHeaders;          // Supports offload of packets with non IPsec Extension headers
    BOOLEAN     Ah;
    BOOLEAN     Esp;
    BOOLEAN     AhEspCombined;
    BOOLEAN     Transport;
    BOOLEAN     Tunnel;
    BOOLEAN     TransportTunnelCombined;
    BOOLEAN     LsoSupported;
    BOOLEAN     ExtendedSequenceNumbers;
    ULONG       UdpEsp;
    ULONG       AuthenticationAlgorithms;     // Bit Mask of Authentication Algorithms
    ULONG       EncryptionAlgorithms;         // Bit Mask of Encryption Algorithms
    ULONG       SaOffloadCapacity;            // Number of SAs that can be offloaded
} NDIS_IPSEC_OFFLOAD_V2, *PNDIS_IPSEC_OFFLOAD_V2;

#endif // (NDIS_SUPPORT_NDIS61)

#pragma warning(pop)

//
// flags used in Flags field of NDIS_OFFLOAD structure
//
#define NDIS_OFFLOAD_FLAGS_GROUP_CHECKSUM_CAPABILITIES  0x00000001

//
// Describes TCP/IP task offload capabilities or configuration 
// of the NIC. Used in OID_TCP_OFFLOAD_CURRENT_CONFIG
// and OID_TCP_OFFLOAD_HARDWARE_CAPABILITIES
//
#define NDIS_OFFLOAD_REVISION_1    1
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_OFFLOAD_REVISION_2    2
#endif // (NDIS_SUPPORT_NDIS61)

typedef struct _NDIS_OFFLOAD
{
    NDIS_OBJECT_HEADER                  Header;

    //
    // Checksum Offload information
    //
    NDIS_TCP_IP_CHECKSUM_OFFLOAD        Checksum;

    //
    // Large Send Offload information
    //
    NDIS_TCP_LARGE_SEND_OFFLOAD_V1      LsoV1;

    //
    // IPsec Offload Information
    //
    NDIS_IPSEC_OFFLOAD_V1               IPsecV1;
    //
    // Large Send Offload version 2Information
    //
    NDIS_TCP_LARGE_SEND_OFFLOAD_V2      LsoV2;

    ULONG                               Flags;

#if (NDIS_SUPPORT_NDIS61)
    //
    //IPsec offload V2
    //
    NDIS_IPSEC_OFFLOAD_V2               IPsecV2;
#endif // (NDIS_SUPPORT_NDIS61)
}NDIS_OFFLOAD, *PNDIS_OFFLOAD;

#define NDIS_SIZEOF_NDIS_OFFLOAD_REVISION_1   RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD, Flags)

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_NDIS_OFFLOAD_REVISION_2   RTL_SIZEOF_THROUGH_FIELD(NDIS_OFFLOAD, IPsecV2) 
#endif // (NDIS_SUPPORT_NDIS61)

//
// The following data structures are used with offload related WMI
// guids. NDIS will trnaslate these data structures to those used 
// in OID and status indications
//
typedef struct _NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V1
{

    struct
    {
        ULONG     Encapsulation;
        ULONG     MaxOffLoadSize;
        ULONG     MinSegmentCount;
        ULONG     TcpOptions;
        ULONG     IpOptions;
    } IPv4;
   
} NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V1, *PNDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V1;

typedef struct _NDIS_WMI_TCP_IP_CHECKSUM_OFFLOAD
{

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpOptionsSupported;
        ULONG       TcpOptionsSupported;
        ULONG       TcpChecksum;
        ULONG       UdpChecksum;
        ULONG       IpChecksum;
    } IPv4Transmit;

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpOptionsSupported;
        ULONG       TcpOptionsSupported;
        ULONG       TcpChecksum;
        ULONG       UdpChecksum;
        ULONG       IpChecksum;
    } IPv4Receive;


    struct
    {
        ULONG       Encapsulation;
        ULONG       IpExtensionHeadersSupported;
        ULONG       TcpOptionsSupported;
        ULONG       TcpChecksum;
        ULONG       UdpChecksum;

    } IPv6Transmit;

    struct
    {
        ULONG       Encapsulation;
        ULONG       IpExtensionHeadersSupported;
        ULONG       TcpOptionsSupported;
        ULONG       TcpChecksum;
        ULONG       UdpChecksum;

    } IPv6Receive;

} NDIS_WMI_TCP_IP_CHECKSUM_OFFLOAD, *PNDIS_WMI_TCP_IP_CHECKSUM_OFFLOAD;

typedef struct _NDIS_WMI_IPSEC_OFFLOAD_V1
{
    struct
    {
        ULONG   Encapsulation;
        ULONG   AhEspCombined;
        ULONG   TransportTunnelCombined;
        ULONG   IPv4Options;
        ULONG   Flags;
    } Supported;

    struct
    {
        ULONG   Md5;
        ULONG   Sha_1;
        ULONG   Transport;
        ULONG   Tunnel;
        ULONG   Send;
        ULONG   Receive;
    } IPv4AH;

    struct
    {
        ULONG   Des;
        ULONG   Reserved;
        ULONG   TripleDes;
        ULONG   NullEsp;
        ULONG   Transport;
        ULONG   Tunnel;
        ULONG   Send;
        ULONG   Receive;
    } IPv4ESP;

} NDIS_WMI_IPSEC_OFFLOAD_V1, *PNDIS_WMI_IPSEC_OFFLOAD_V1;

typedef struct _NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V2
{
    struct 
    {
         ULONG     Encapsulation;
         ULONG     MaxOffLoadSize;
         ULONG     MinSegmentCount;
    }IPv4;

    struct 
    {
         ULONG     Encapsulation;
         ULONG     MaxOffLoadSize;
         ULONG     MinSegmentCount;
         ULONG     IpExtensionHeadersSupported;
         ULONG     TcpOptionsSupported;
    }IPv6;

} NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V2, *PNDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V2;


typedef struct _NDIS_WMI_OFFLOAD
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_OFFLOAD;
    // Header.Size = sizeof(NDIS_OFFLOAD);
    // Header.Revision  = NDIS_OFFLOAD_REVISION_1;
    //
    NDIS_OBJECT_HEADER                  Header;

    //
    // Checksum Offload information
    //
    NDIS_WMI_TCP_IP_CHECKSUM_OFFLOAD    Checksum;

    //
    // Large Send Offload information
    //
    NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V1   LsoV1;

    //
    // IPsec Offload Information
    //
    NDIS_WMI_IPSEC_OFFLOAD_V1           IPsecV1;
    //
    // Large Send Offload version 2 Information
    //
    NDIS_WMI_TCP_LARGE_SEND_OFFLOAD_V2  LsoV2;

    ULONG                               Flags;

#if (NDIS_SUPPORT_NDIS61)
    //
    // IPsec offload version 2 information
    //
    NDIS_IPSEC_OFFLOAD_V2               IPsecV2;
#endif // (NDIS_SUPPORT_NDIS61)
}NDIS_WMI_OFFLOAD, *PNDIS_WMI_OFFLOAD;

#define NDIS_SIZEOF_NDIS_WMI_OFFLOAD_REVISION_1   RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_OFFLOAD, Flags) 

#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_NDIS_WMI_OFFLOAD_REVISION_2   RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_OFFLOAD, IPsecV2) 
#endif // (NDIS_SUPPORT_NDIS61)
#pragma warning(push)
#pragma warning(disable:4214) //nonstandard extension used : bit field types other than int

//
// Describes TCP connection offload capabilities or configuration  
// of the NIC. Used in OID_TCP_CONNECTION_OFFLOAD_CURRENT_CONFIG,
// OID_TCP_CONNECTION_OFFLOAD_HARDWARE_CAPABILITIES and 
// NDIS_STATUS_OFFLOAD_RESUME
//
#define NDIS_TCP_CONNECTION_OFFLOAD_REVISION_1              1
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_TCP_CONNECTION_OFFLOAD_REVISION_2              2
#endif // (NDIS_SUPPORT_NDIS61)

typedef struct _NDIS_TCP_CONNECTION_OFFLOAD
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;         
    // Header.Revision = NDIS_TCP_CONNECTION_OFFLOAD_REVISION_1;
    // Header.Size = sizeof(NDIS_TCP_CONNECTION_OFFLOAD);
    //
    NDIS_OBJECT_HEADER Header;
    ULONG Encapsulation;
    ULONG SupportIPv4:2;
    ULONG SupportIPv6:2;
    ULONG SupportIPv6ExtensionHeaders:2;
    ULONG SupportSack:2;
#if (NDIS_SUPPORT_NDIS61)
    ULONG CongestionAlgorithm:4;
#endif // (NDIS_SUPPORT_NDIS61)
    ULONG TcpConnectionOffloadCapacity;
    ULONG Flags;
} NDIS_TCP_CONNECTION_OFFLOAD, *PNDIS_TCP_CONNECTION_OFFLOAD;

#define NDIS_SIZEOF_TCP_CONNECTION_OFFLOAD_REVISION_1 RTL_SIZEOF_THROUGH_FIELD(NDIS_TCP_CONNECTION_OFFLOAD, Flags)
#if (NDIS_SUPPORT_NDIS61)
#define NDIS_SIZEOF_TCP_CONNECTION_OFFLOAD_REVISION_2 RTL_SIZEOF_THROUGH_FIELD(NDIS_TCP_CONNECTION_OFFLOAD, Flags)
#endif // (NDIS_SUPPORT_NDIS61)

#pragma warning(pop)

typedef struct _NDIS_WMI_TCP_CONNECTION_OFFLOAD
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;         
    // Header.Revision = NDIS_TCP_CONNECTION_OFFLOAD_REVISION_1;
    // Header.Size = sizeof(NDIS_TCP_CONNECTION_OFFLOAD);
    //
    NDIS_OBJECT_HEADER Header;
    ULONG Encapsulation;
    ULONG SupportIPv4;
    ULONG SupportIPv6;
    ULONG SupportIPv6ExtensionHeaders;
    ULONG SupportSack;
    ULONG TcpConnectionOffloadCapacity;
    ULONG Flags;
} NDIS_WMI_TCP_CONNECTION_OFFLOAD, *PNDIS_WMI_TCP_CONNECTION_OFFLOAD;

#define NDIS_SIZEOF_WMI_TCP_CONNECTION_OFFLOAD_REVISION_1 RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_TCP_CONNECTION_OFFLOAD, Flags)

#define NDIS_MAXIMUM_PORTS 0x1000000

//
// definitions for NDIS PORTs
//

typedef ULONG NDIS_PORT_NUMBER, *PNDIS_PORT_NUMBER;

//
// port related data structures
//
#define NDIS_DEFAULT_PORT_NUMBER ((NDIS_PORT_NUMBER)0)
    
//
// NDIS_PORT_TYPE defines the application of a port 
//
typedef enum _NDIS_PORT_TYPE
{
    NdisPortTypeUndefined,
    NdisPortTypeBridge,
    NdisPortTypeRasConnection,
    NdisPortType8021xSupplicant,
    NdisPortTypeMax,
}NDIS_PORT_TYPE, *PNDIS_PORT_TYPE;
    
    
//
// NDIS_PORT_AUTHENTICATION_STATE defines the authentication state of a port
// on a particular data path
//
typedef enum _NDIS_PORT_AUTHORIZATION_STATE
{
    NdisPortAuthorizationUnknown,
    NdisPortAuthorized,
    NdisPortUnauthorized,
    NdisPortReauthorizing
} NDIS_PORT_AUTHORIZATION_STATE, *PNDIS_PORT_AUTHORIZATION_STATE;


//
// NDIS_PORT_CONTROLL_STATE specifies if a port is "controlled" 
// i.e. if it needs authentication, on a particular data path
//

typedef enum _NDIS_PORT_CONTROL_STATE
{
    NdisPortControlStateUnknown,
    NdisPortControlStateControlled,
    NdisPortControlStateUncontrolled
} NDIS_PORT_CONTROLL_STATE, *PNDIS_PORT_CONTROLL_STATE;
    
    
    
//
// NDIS_PORT_STATE is used in port state change status indications
// as well as OID_GEN_PORT_STATE query OID
//

#define NDIS_PORT_STATE_REVISION_1     1
typedef struct _NDIS_PORT_STATE
{
    NDIS_OBJECT_HEADER              Header;    
    NDIS_MEDIA_CONNECT_STATE        MediaConnectState;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NET_IF_DIRECTION_TYPE           Direction;
    NDIS_PORT_CONTROLL_STATE        SendControlState;
    NDIS_PORT_CONTROLL_STATE        RcvControlState;
    NDIS_PORT_AUTHORIZATION_STATE   SendAuthorizationState;
    NDIS_PORT_AUTHORIZATION_STATE   RcvAuthorizationState;
    ULONG                           Flags;
}NDIS_PORT_STATE, *PNDIS_PORT_STATE;

#define NDIS_SIZEOF_PORT_STATE_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PORT_STATE, Flags)

//
// NDIS_PORT_PARAMETERS is used in OID_GEN_PORT_PARAMETERS set OID
//
#define NDIS_PORT_AUTHENTICATION_PARAMETERS_REVISION_1     1

typedef struct _NDIS_PORT_AUTHENTICATION_PARAMETERS
{
    NDIS_OBJECT_HEADER              Header;    
    NDIS_PORT_CONTROLL_STATE        SendControlState;
    NDIS_PORT_CONTROLL_STATE        RcvControlState;
    NDIS_PORT_AUTHORIZATION_STATE   SendAuthorizationState;
    NDIS_PORT_AUTHORIZATION_STATE   RcvAuthorizationState;
}NDIS_PORT_AUTHENTICATION_PARAMETERS, *PNDIS_PORT_AUTHENTICATION_PARAMETERS;

#define NDIS_SIZEOF_PORT_AUTHENTICATION_PARAMETERS_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PORT_AUTHENTICATION_PARAMETERS, RcvAuthorizationState)


//
// Flags used in NDIS_PORT_CHARACTERISTICS Flags field.
//
#define  NDIS_PORT_CHAR_USE_DEFAULT_AUTH_SETTINGS             0x00000001

//
// NDIS_PORT_CHARACTERISTICS is used in port allocation and 
// arrival notification as part of NDIS_PORT structure
//
#define NDIS_PORT_CHARACTERISTICS_REVISION_1     1
typedef struct _NDIS_PORT_CHARACTERISTICS
{
    NDIS_OBJECT_HEADER              Header;
    NDIS_PORT_NUMBER                PortNumber;
    ULONG                           Flags;
    NDIS_PORT_TYPE                  Type;
    NDIS_MEDIA_CONNECT_STATE        MediaConnectState;
    ULONG64                         XmitLinkSpeed;
    ULONG64                         RcvLinkSpeed;
    NET_IF_DIRECTION_TYPE           Direction;
    NDIS_PORT_CONTROLL_STATE        SendControlState;
    NDIS_PORT_CONTROLL_STATE        RcvControlState;
    NDIS_PORT_AUTHORIZATION_STATE   SendAuthorizationState;
    NDIS_PORT_AUTHORIZATION_STATE   RcvAuthorizationState;
} NDIS_PORT_CHARACTERISTICS, *PNDIS_PORT_CHARACTERISTICS;
   
#define NDIS_SIZEOF_PORT_CHARACTERISTICS_REVISION_1    \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PORT_CHARACTERISTICS, RcvAuthorizationState)
    
//
// NDIS_PORT structure is used in port activation 
// PnP notification
//
typedef struct _NDIS_PORT NDIS_PORT, *PNDIS_PORT;

struct _NDIS_PORT
{
    PNDIS_PORT                  Next;
    PVOID                       NdisReserved;
    PVOID                       MiniportReserved;
    PVOID                       ProtocolReserved;
    NDIS_PORT_CHARACTERISTICS   PortCharacteristics;
};


#define NDIS_PORT_ARRAY_REVISION_1                1
//
// NDIS_PORT_ARRAY is used in enumerating the ports
//
typedef struct _NDIS_PORT_ARRAY
{
    NDIS_OBJECT_HEADER              Header;
    ULONG                           NumberOfPorts;
    ULONG                           OffsetFirstPort;
    ULONG                           ElementSize;
    NDIS_PORT_CHARACTERISTICS       Ports[1];
}NDIS_PORT_ARRAY, *PNDIS_PORT_ARRAY;

#define NDIS_SIZEOF_PORT_ARRAY_REVISION_1      \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_PORT_ARRAY, Ports);

typedef enum _NDIS_NETWORK_CHANGE_TYPE
{
    NdisPossibleNetworkChange = 1,
    NdisDefinitelyNetworkChange,
    NdisNetworkChangeFromMediaConnect,
    NdisNetworkChangeMax
} NDIS_NETWORK_CHANGE_TYPE, *PNDIS_NETWORK_CHANGE_TYPE;


#define  NDIS_WMI_DEFAULT_METHOD_ID             1

#define  NDIS_WMI_OBJECT_TYPE_SET               0x01
#define  NDIS_WMI_OBJECT_TYPE_METHOD            0x02
#define  NDIS_WMI_OBJECT_TYPE_EVENT             0x03
#define  NDIS_WMI_OBJECT_TYPE_ENUM_ADAPTER      0x04
#define  NDIS_WMI_OBJECT_TYPE_OUTPUT_INFO       0x05

#define NDIS_WMI_METHOD_HEADER_REVISION_1       1 

typedef struct _NDIS_WMI_METHOD_HEADER
{
    NDIS_OBJECT_HEADER   Header;
    NDIS_PORT_NUMBER     PortNumber;
    NET_LUID             NetLuid;
    ULONG64              RequestId;
    ULONG                Timeout;
    UCHAR                Padding[4];
} NDIS_WMI_METHOD_HEADER, *PNDIS_WMI_METHOD_HEADER;

#define NDIS_SIZEOF_WMI_METHOD_HEADER_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_METHOD_HEADER, Padding)
       
#define NDIS_WMI_SET_HEADER_REVISION_1         1

typedef struct _NDIS_WMI_SET_HEADER
{
    NDIS_OBJECT_HEADER   Header;
    NDIS_PORT_NUMBER     PortNumber;
    NET_LUID             NetLuid;
    ULONG64              RequestId;
    ULONG                Timeout;
    UCHAR                Padding[4];
} NDIS_WMI_SET_HEADER, *PNDIS_WMI_SET_HEADER;

#define NDIS_SIZEOF_WMI_SET_HEADER_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_SET_HEADER, Padding)

#define NDIS_WMI_EVENT_HEADER_REVISION_1      1

typedef struct _NDIS_WMI_EVENT_HEADER
{
    NDIS_OBJECT_HEADER   Header;
    NET_IFINDEX          IfIndex;
    NET_LUID             NetLuid;
    ULONG64              RequestId;    
    NDIS_PORT_NUMBER     PortNumber;
    ULONG                DeviceNameLength;
    ULONG                DeviceNameOffset;
    UCHAR                Padding[4];
} NDIS_WMI_EVENT_HEADER, *PNDIS_WMI_EVENT_HEADER;

#define NDIS_SIZEOF_WMI_EVENT_HEADER_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_EVENT_HEADER, Padding)

#define NDIS_WMI_ENUM_ADAPTER_REVISION_1       1

typedef struct _NDIS_WMI_ENUM_ADAPTER
{
    NDIS_OBJECT_HEADER   Header;
    NET_IFINDEX          IfIndex;
    NET_LUID             NetLuid;
    USHORT               DeviceNameLength;
    CHAR                 DeviceName[1];
}NDIS_WMI_ENUM_ADAPTER, *PNDIS_WMI_ENUM_ADAPTER;

#define NDIS_SIZEOF_WMI_ENUM_ADAPTER_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_ENUM_ADAPTER, DeviceName)
        
//
// Flags used in standardized keyword *NdisDeviceType
//
#define NDIS_DEVICE_TYPE_ENDPOINT           0x00000001


#if (NDIS_SUPPORT_NDIS61)

//
// Structure and defines for 
// OID_GEN_HD_SPLIT_PARAMETERS
//
#define NDIS_HD_SPLIT_PARAMETERS_REVISION_1      1

typedef struct _NDIS_HD_SPLIT_PARAMETERS
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
    // Header.Revision = NDIS_HD_SPLIT_PARAMETERS_REVISION_1;
    // Header.Size = sizeof(NDIS_HD_SPLIT_PARAMETERS);
    // 
    NDIS_OBJECT_HEADER      Header;
    ULONG                   HDSplitCombineFlags;
}NDIS_HD_SPLIT_PARAMETERS, *PNDIS_HD_SPLIT_PARAMETERS;

#define NDIS_SIZEOF_HD_SPLIT_PARAMETERS_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_HD_SPLIT_PARAMETERS, HDSplitCombineFlags)

//
// Flags used in NDIS_HD_SPLIT_PARAMETERS->HDSplitCombineFlags 
// and NDIS_HD_SPLIT_CURRENT_CONFIG->HDSplitCombineFlags
//
#define NDIS_HD_SPLIT_COMBINE_ALL_HEADERS          0x00000001

//
// Structure and defines for 
// OID_GEN_HD_SPLIT_CURRENT_CONFIG
//
#define NDIS_HD_SPLIT_CURRENT_CONFIG_REVISION_1      1

typedef struct _NDIS_HD_SPLIT_CURRENT_CONFIG
{
    //
    // Header.Type = NDIS_OBJECT_TYPE_DEFAULT;
    // Header.Revision = NDIS_HD_SPLIT_CURRENT_CONFIG_REVISION_1;
    // Header.Size = sizeof(NDIS_HD_SPLIT_CURRENT_CONFIG);
    // 
    NDIS_OBJECT_HEADER          Header;    
    ULONG                       HardwareCapabilities;
    ULONG                       CurrentCapabilities;
    ULONG                       HDSplitFlags;
    ULONG                       HDSplitCombineFlags;
    ULONG                       BackfillSize;
    ULONG                       MaxHeaderSize;
} NDIS_HD_SPLIT_CURRENT_CONFIG, *PNDIS_HD_SPLIT_CURRENT_CONFIG;

#define NDIS_SIZEOF_HD_SPLIT_CURRENT_CONFIG_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_HD_SPLIT_CURRENT_CONFIG, MaxHeaderSize)

//
// Flags used in NDIS_HD_SPLIT_ATTRIBUTES->HardwareCapabilities
// and NDIS_HD_SPLIT_ATTRIBUTES->CurrentCapabilities. They are also
// used in NDIS_HD_SPLIT_CURRENT_CONFIG->HardwareCapabilities
// and NDIS_HD_SPLIT_CURRENT_CONFIG->CurrentCapabilities. 
//
#define NDIS_HD_SPLIT_CAPS_SUPPORTS_HEADER_DATA_SPLIT         0x00000001
#define NDIS_HD_SPLIT_CAPS_SUPPORTS_IPV4_OPTIONS              0x00000002
#define NDIS_HD_SPLIT_CAPS_SUPPORTS_IPV6_EXTENSION_HEADERS    0x00000004
#define NDIS_HD_SPLIT_CAPS_SUPPORTS_TCP_OPTIONS               0x00000008

//
// Flags used in NDIS_HD_SPLIT_ATTRIBUTES->HDSplitFlags and
// NDIS_HD_SPLIT_CURRENT_CONFIG->HDSplitFlags
//
#define NDIS_HD_SPLIT_ENABLE_HEADER_DATA_SPLIT     0x00000001

#endif // (NDIS_SUPPORT_NDIS61)

#define NDIS_WMI_OUTPUT_INFO_REVISION_1    1;

typedef struct NDIS_WMI_OUTPUT_INFO
{
    NDIS_OBJECT_HEADER   Header;
    ULONG                Flags;
    UCHAR                SupportedRevision;
    ULONG                DataOffset;
    
} NDIS_WMI_OUTPUT_INFO, *PNDIS_WMI_OUTPUT_INFO;

#define NDIS_SIZEOF_WMI_OUTPUT_INFO_REVISION_1     \
        RTL_SIZEOF_THROUGH_FIELD(NDIS_WMI_OUTPUT_INFO, DataOffset)

#endif // NTDDI_VERSION >= NTDDI_VISTA

#ifdef __cplusplus
}
#endif

#endif // _NTDDNDIS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddmmc.h ===
/* Copyright (c) Microsoft Corporation. All rights reserved. */

#ifndef __NTDDMMC__
#define __NTDDMMC__

#ifdef __cplusplus
extern "C" {
#endif


#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4200) // array[0] is not a warning for this file
#pragma warning(disable:4214) // bitfield other than int


//
// NOTE: All FEATURE_* structures may be extended.  use of these structures
//       requires verification that the FeatureHeader->AdditionLength field
//       contains AT LEAST enough data to cover the data fields being accessed.
//       This is due to the design, which allows extending the size of the
//       various structures, which will result in these structures sizes
//       being changed over time.
//       A 0-element array is however not declared in the variable size
//       structures. Such array is declared on some structures to preserve
//       legacy, yet it is deprecated. To access variable size structures,
//       as they are always at the end of the fixed size structure, use a sizeof
//       of the declared fixed size structure as an offset.
//       *** Programmers beware! ***
//

//
// NOTE: This is based on MMC 3, extended to MMC 5 rev 3
//       Further revisions will maintain backward compatibility
//       with the non-reserved fields listed here.  If you need
//       to access a new field, please typecast to FEATURE_DATA_RESERVED
//       and access the appropriate bits there.
//

typedef struct _GET_CONFIGURATION_HEADER {
    UCHAR DataLength[4];      // [0] == MSB, [3] == LSB
    UCHAR Reserved[2];
    UCHAR CurrentProfile[2];  // [0] == MSB, [1] == LSB
#if !defined(__midl)
    UCHAR Data[0];            // extra data, typically FEATURE_HEADER
#endif
} GET_CONFIGURATION_HEADER, *PGET_CONFIGURATION_HEADER;

typedef struct _FEATURE_HEADER {
    UCHAR FeatureCode[2];     // [0] == MSB, [1] == LSB
    UCHAR Current    : 1;     // The feature is currently active
    UCHAR Persistent : 1;     // The feature is always current
    UCHAR Version    : 4;
    UCHAR Reserved0  : 2;
    UCHAR AdditionalLength;   // sizeof(Header) + AdditionalLength = size
} FEATURE_HEADER, *PFEATURE_HEADER;

typedef enum _FEATURE_PROFILE_TYPE {
    ProfileInvalid                  = 0x0000,
    ProfileNonRemovableDisk         = 0x0001,
    ProfileRemovableDisk            = 0x0002,
    ProfileMOErasable               = 0x0003,
    ProfileMOWriteOnce              = 0x0004,
    ProfileAS_MO                    = 0x0005,
    // Reserved                 0x0006 - 0x0007
    ProfileCdrom                    = 0x0008,
    ProfileCdRecordable             = 0x0009,
    ProfileCdRewritable             = 0x000a,
    // Reserved                 0x000b - 0x000f
    ProfileDvdRom                   = 0x0010,
    ProfileDvdRecordable            = 0x0011,
    ProfileDvdRam                   = 0x0012,
    ProfileDvdRewritable            = 0x0013,  // restricted overwrite
    ProfileDvdRWSequential          = 0x0014,
    ProfileDvdDashRDualLayer        = 0x0015,
    ProfileDvdDashRLayerJump        = 0x0016,
    // Reserved                 0x0017 - 0x0019
    ProfileDvdPlusRW                = 0x001A,
    ProfileDvdPlusR                 = 0x001B,
    // Reserved                 0x001C - 001F
    ProfileDDCdrom                  = 0x0020,  // obsolete
    ProfileDDCdRecordable           = 0x0021,  // obsolete
    ProfileDDCdRewritable           = 0x0022,  // obsolete
    // Reserved                 0x0023 - 0x0029
    ProfileDvdPlusRWDualLayer       = 0x002A,
    ProfileDvdPlusRDualLayer        = 0x002B,
    // Reserved                 0x002C - 0x003F
    ProfileBDRom                    = 0x0040,
    ProfileBDRSequentialWritable    = 0x0041,  // BD-R 'SRM'
    ProfileBDRRandomWritable        = 0x0042,  // BD-R 'RRM'
    ProfileBDRewritable             = 0x0043,
    //  Reserved                0x0044 - 0x004F
    ProfileHDDVDRom                 = 0x0050,
    ProfileHDDVDRecordable          = 0x0051,
    ProfileHDDVDRam                 = 0x0052,
    ProfileHDDVDRewritable          = 0x0053,
	// Reserved                 0x0054 - 0x0057
    ProfileHDDVDRDualLayer          = 0x0058,
    // Reserved                 0x0059 - 0x0059
    ProfileHDDVDRWDualLayer         = 0x005A,
    // Reserved                 0x005B - 0xfffe
    ProfileNonStandard              = 0xffff
} FEATURE_PROFILE_TYPE, *PFEATURE_PROFILE_TYPE;

typedef enum _FEATURE_NUMBER {
    FeatureProfileList              = 0x0000,
    FeatureCore                     = 0x0001,
    FeatureMorphing                 = 0x0002,
    FeatureRemovableMedium          = 0x0003,
    FeatureWriteProtect             = 0x0004,
    // Reserved                  0x0005 - 0x000f
    FeatureRandomReadable           = 0x0010,
    // Reserved                  0x0011 - 0x001c
    FeatureMultiRead                = 0x001D,
    FeatureCdRead                   = 0x001E,
    FeatureDvdRead                  = 0x001F,
    FeatureRandomWritable           = 0x0020,
    FeatureIncrementalStreamingWritable = 0x0021,
    FeatureSectorErasable           = 0x0022,
    FeatureFormattable              = 0x0023,
    FeatureDefectManagement         = 0x0024,
    FeatureWriteOnce                = 0x0025,
    FeatureRestrictedOverwrite      = 0x0026,
    FeatureCdrwCAVWrite             = 0x0027,
    FeatureMrw                      = 0x0028,
    FeatureEnhancedDefectReporting  = 0x0029,
    FeatureDvdPlusRW                = 0x002A,
    FeatureDvdPlusR                 = 0x002B,
    FeatureRigidRestrictedOverwrite = 0x002C,
    FeatureCdTrackAtOnce            = 0x002D,
    FeatureCdMastering              = 0x002E,
    FeatureDvdRecordableWrite       = 0x002F,   // both -R and -RW
    FeatureDDCDRead                 = 0x0030,   // obsolete
    FeatureDDCDRWrite               = 0x0031,   // obsolete
    FeatureDDCDRWWrite              = 0x0032,   // obsolete
    FeatureLayerJumpRecording       = 0x0033,
    // Reserved                  0x0034 - 0x0036
    FeatureCDRWMediaWriteSupport    = 0x0037,
    FeatureBDRPseudoOverwrite       = 0x0038,
    // Reserved                       0x0039
    FeatureDvdPlusRWDualLayer       = 0x003A,
    FeatureDvdPlusRDualLayer        = 0x003B,
    // Reserved                  0x003c - 0x003f
    FeatureBDRead                   = 0x0040,
    FeatureBDWrite                  = 0x0041,
    FeatureTSR                      = 0x0042,
    // Reserved                  0x0043 - 0x004f
    FeatureHDDVDRead                = 0x0050,
    FeatureHDDVDWrite               = 0x0051,
    // Reserved                  0x0052 - 0x007f
    FeatureHybridDisc               = 0x0080,
    // Reserved                  0x0081 - 0x00ff
    FeaturePowerManagement          = 0x0100,
    FeatureSMART                    = 0x0101,
    FeatureEmbeddedChanger          = 0x0102,
    FeatureCDAudioAnalogPlay        = 0x0103,  // obsolete
    FeatureMicrocodeUpgrade         = 0x0104,
    FeatureTimeout                  = 0x0105,
    FeatureDvdCSS                   = 0x0106,
    FeatureRealTimeStreaming        = 0x0107,
    FeatureLogicalUnitSerialNumber  = 0x0108,
    FeatureMediaSerialNumber        = 0x0109,
    FeatureDiscControlBlocks        = 0x010A,
    FeatureDvdCPRM                  = 0x010B,
    FeatureFirmwareDate             = 0x010C,
    FeatureAACS                     = 0x010D,
    // Reserved                  0x010e - 0x010f
    FeatureVCPS                     = 0x0110,
    // Reserved                  0x0111 - 0xfeff
    // Vendor Unique             0xff00 - 0xffff
} FEATURE_NUMBER, *PFEATURE_NUMBER;

// 0x0000 - FeatureProfileList
// an integral multiple of the _EX structures are returned for page 0000
typedef struct _FEATURE_DATA_PROFILE_LIST_EX {
    UCHAR ProfileNumber[2]; // [0] == MSB, [1] == LSB
    UCHAR Current                   : 1;
    UCHAR Reserved1                 : 7;
    UCHAR Reserved2;
} FEATURE_DATA_PROFILE_LIST_EX, *PFEATURE_DATA_PROFILE_LIST_EX;

typedef struct _FEATURE_DATA_PROFILE_LIST {
    FEATURE_HEADER Header;
#if !defined(__midl)
    FEATURE_DATA_PROFILE_LIST_EX Profiles[0];
#endif
} FEATURE_DATA_PROFILE_LIST, *PFEATURE_DATA_PROFILE_LIST;

// 0x0001 - FeatureCore
typedef struct _FEATURE_DATA_CORE {
    FEATURE_HEADER Header;
    UCHAR PhysicalInterface[4];  // [0] == MSB, [3] == LSB
    UCHAR DeviceBusyEvent           : 1;
    UCHAR INQUIRY2                  : 1;
    UCHAR Reserved1                 : 6;
    UCHAR Reserved2[3];
} FEATURE_DATA_CORE, *PFEATURE_DATA_CORE;

// 0x0002 - FeatureMorphing
typedef struct _FEATURE_DATA_MORPHING {
    FEATURE_HEADER Header;
    UCHAR Asynchronous              : 1;
    UCHAR OCEvent                   : 1;
    UCHAR Reserved01                : 6;
    UCHAR Reserved2[3];
} FEATURE_DATA_MORPHING, *PFEATURE_DATA_MORPHING;

// 0x0003 - FeatureRemovableMedium
typedef struct _FEATURE_DATA_REMOVABLE_MEDIUM {
    FEATURE_HEADER Header;
    UCHAR Lockable                  : 1;
    UCHAR Reserved1                 : 1;
    UCHAR DefaultToPrevent          : 1;
    UCHAR Eject                     : 1;
    UCHAR Reserved2                 : 1;
    UCHAR LoadingMechanism          : 3;
    UCHAR Reserved3[3];
} FEATURE_DATA_REMOVABLE_MEDIUM, *PFEATURE_DATA_REMOVABLE_MEDIUM;

// 0x0004 - FeatureWriteProtect
typedef struct _FEATURE_DATA_WRITE_PROTECT {
    FEATURE_HEADER Header;
    UCHAR SupportsSWPPBit                : 1;
    UCHAR SupportsPersistentWriteProtect : 1;
    UCHAR WriteInhibitDCB                : 1;
    UCHAR DiscWriteProtectPAC            : 1;
    UCHAR Reserved01                     : 4;
    UCHAR Reserved2[3];
} FEATURE_DATA_WRITE_PROTECT, *PFEATURE_DATA_WRITE_PROTECT;

// 0x0005 - 0x000f are Reserved

// 0x0010 - FeatureRandomReadable
typedef struct _FEATURE_DATA_RANDOM_READABLE {
    FEATURE_HEADER Header;
    UCHAR LogicalBlockSize[4];
    UCHAR Blocking[2];
    UCHAR ErrorRecoveryPagePresent : 1;
    UCHAR Reserved1                : 7;
    UCHAR Reserved2;
} FEATURE_DATA_RANDOM_READABLE, *PFEATURE_DATA_RANDOM_READABLE;

// 0x0011 - 0x001c are Reserved

// 0x001D - FeatureMultiRead
typedef struct _FEATURE_DATA_MULTI_READ {
    FEATURE_HEADER Header;
} FEATURE_DATA_MULTI_READ, *PFEATURE_DATA_MULTI_READ;

// 0x001E - FeatureCdRead
typedef struct _FEATURE_DATA_CD_READ {
    FEATURE_HEADER Header;
    UCHAR CDText                   : 1;
    UCHAR C2ErrorData              : 1;
    UCHAR Reserved01               : 5;
    UCHAR DigitalAudioPlay         : 1;
    UCHAR Reserved2[3];
} FEATURE_DATA_CD_READ, *PFEATURE_DATA_CD_READ;

// 0x001F - FeatureDvdRead
typedef struct _FEATURE_DATA_DVD_READ {
    FEATURE_HEADER Header;
    UCHAR Multi110                 : 1;
    UCHAR Reserved1                : 7;
    UCHAR Reserved2;
    UCHAR DualDashR                : 1;
    UCHAR Reserved3                : 7;
    UCHAR Reserved4;
} FEATURE_DATA_DVD_READ, *PFEATURE_DATA_DVD_READ;

// 0x0020 - FeatureRandomWritable
typedef struct _FEATURE_DATA_RANDOM_WRITABLE {
    FEATURE_HEADER Header;
    UCHAR LastLBA[4];
    UCHAR LogicalBlockSize[4];
    UCHAR Blocking[2];
    UCHAR ErrorRecoveryPagePresent : 1;
    UCHAR Reserved1                : 7;
    UCHAR Reserved2;
} FEATURE_DATA_RANDOM_WRITABLE, *PFEATURE_DATA_RANDOM_WRITABLE;

// 0x0021 - FeatureIncrementalStreamingWritable
typedef struct _FEATURE_DATA_INCREMENTAL_STREAMING_WRITABLE {
    FEATURE_HEADER Header;
    UCHAR DataTypeSupported[2];   // [0] == MSB, [1] == LSB // see also FeatureCdTrackAtOnce
    UCHAR BufferUnderrunFree            : 1;
    UCHAR AddressModeReservation        : 1;
    UCHAR TrackRessourceInformation     : 1;
    UCHAR Reserved01                    : 5;
    UCHAR NumberOfLinkSizes;
#if !defined(__midl)
    UCHAR LinkSize[0];
#endif
} FEATURE_DATA_INCREMENTAL_STREAMING_WRITABLE, *PFEATURE_DATA_INCREMENTAL_STREAMING_WRITABLE;

// 0x0022 - FeatureSectorErasable
typedef struct _FEATURE_DATA_SECTOR_ERASABLE {
    FEATURE_HEADER Header;
} FEATURE_DATA_SECTOR_ERASABLE, *PFEATURE_DATA_SECTOR_ERASABLE;

// 0x0023 - FeatureFormattable
typedef struct _FEATURE_DATA_FORMATTABLE {
    FEATURE_HEADER Header;
    UCHAR FullCertification     : 1;
    UCHAR QuickCertification    : 1;
    UCHAR SpareAreaExpansion    : 1;
    UCHAR RENoSpareAllocated    : 1;
    UCHAR Reserved1             : 4;
    UCHAR Reserved2[3];
    UCHAR RRandomWritable       : 1;
    UCHAR Reserved3             : 7;
    UCHAR Reserved4[3];
} FEATURE_DATA_FORMATTABLE, *PFEATURE_DATA_FORMATTABLE;

// 0x0024 - FeatureDefectManagement
typedef struct _FEATURE_DATA_DEFECT_MANAGEMENT {
    FEATURE_HEADER Header;
    UCHAR Reserved1             : 7;
    UCHAR SupplimentalSpareArea : 1;
    UCHAR Reserved2[3];
} FEATURE_DATA_DEFECT_MANAGEMENT, *PFEATURE_DATA_DEFECT_MANAGEMENT;

// 0x0025 - FeatureWriteOnce
typedef struct _FEATURE_DATA_WRITE_ONCE {
    FEATURE_HEADER Header;
    UCHAR LogicalBlockSize[4];
    UCHAR Blocking[2];
    UCHAR ErrorRecoveryPagePresent : 1;
    UCHAR Reserved1                : 7;
    UCHAR Reserved2;
} FEATURE_DATA_WRITE_ONCE, *PFEATURE_DATA_WRITE_ONCE;

// 0x0026 - FeatureRestrictedOverwrite
typedef struct _FEATURE_DATA_RESTRICTED_OVERWRITE {
    FEATURE_HEADER Header;
} FEATURE_DATA_RESTRICTED_OVERWRITE, *PFEATURE_DATA_RESTRICTED_OVERWRITE;

// 0x0027 - FeatureCdrwCAVWrite
typedef struct _FEATURE_DATA_CDRW_CAV_WRITE {
    FEATURE_HEADER Header;
    UCHAR Reserved1[4];
    /*
    UCHAR SupportsWritingCDRWSubType0 : 1; // 1x - 4x media
    UCHAR SupportsWritingCDRWSubType1 : 1; // 4x - 10x media ??
    UCHAR SupportsWritingCDRWSubType2 : 1; // ???
    UCHAR SupportsWritingCDRWSubType3 : 1; // ???
    UCHAR SupportsWritingCDRWSubType4 : 1; // ???
    UCHAR SupportsWritingCDRWSubType5 : 1; // ???
    UCHAR SupportsWritingCDRWSubType6 : 1; // ???
    UCHAR SupportsWritingCDRWSubType7 : 1; // ???
    UCHAR Reserved2[3];
    */
} FEATURE_DATA_CDRW_CAV_WRITE, *PFEATURE_DATA_CDRW_CAV_WRITE;

// 0x0028 - FeatureMrw
typedef struct _FEATURE_DATA_MRW {
    FEATURE_HEADER Header;
    UCHAR Write         : 1; // Cd Write
    UCHAR DvdPlusRead   : 1;
    UCHAR DvdPlusWrite  : 1;
    UCHAR Reserved01    : 5;
    UCHAR Reserved2[3];
} FEATURE_DATA_MRW, *PFEATURE_DATA_MRW;

// 0x0029 - Enhanced Defect Reporting
typedef struct _FEATURE_ENHANCED_DEFECT_REPORTING {
    FEATURE_HEADER Header;
    UCHAR DRTDMSupported : 1;
    UCHAR Reserved0      : 7;
    UCHAR NumberOfDBICacheZones;
    UCHAR NumberOfEntries[2];
} FEATURE_ENHANCED_DEFECT_REPORTING, *PFEATURE_ENHANCED_DEFECT_REPORTING;

// 0x002A - FeatureDvdPlusRW
typedef struct _FEATURE_DATA_DVD_PLUS_RW {
    FEATURE_HEADER Header;
    UCHAR Write         : 1;
    UCHAR Reserved1     : 7;
    UCHAR CloseOnly     : 1;
    UCHAR QuickStart    : 1;
    UCHAR Reserved02    : 6;
    UCHAR Reserved03[2];
} FEATURE_DATA_DVD_PLUS_RW, *PFEATURE_DATA_DVD_PLUS_RW;

// 0x002B - FeatureDvdPlusR
typedef struct _FEATURE_DATA_DVD_PLUS_R {
    FEATURE_HEADER Header;
    UCHAR Write     : 1;
    UCHAR Reserved1 : 7;
    UCHAR Reserved2[3];
} FEATURE_DATA_DVD_PLUS_R, *PFEATURE_DATA_DVD_PLUS_R;

// 0x002C - FeatureDvdRwRestrictedOverwrite
typedef struct _FEATURE_DATA_DVD_RW_RESTRICTED_OVERWRITE {
    FEATURE_HEADER Header;
    UCHAR Blank                    : 1;
    UCHAR Intermediate             : 1;
    UCHAR DefectStatusDataRead     : 1;
    UCHAR DefectStatusDataGenerate : 1;
    UCHAR Reserved0                : 4;
    UCHAR Reserved1[3];
} FEATURE_DATA_DVD_RW_RESTRICTED_OVERWRITE, *PFEATURE_DATA_DVD_RW_RESTRICTED_OVERWRITE;

// 0x002D - FeatureCdTrackAtOnce
typedef struct _FEATURE_DATA_CD_TRACK_AT_ONCE {
    FEATURE_HEADER Header;
    UCHAR RWSubchannelsRecordable  : 1;
    UCHAR CdRewritable             : 1;
    UCHAR TestWriteOk              : 1;
    UCHAR RWSubchannelPackedOk     : 1; // MMC 3 +
    UCHAR RWSubchannelRawOk        : 1; // MMC 3 +
    UCHAR Reserved1                : 1;
    UCHAR BufferUnderrunFree       : 1; // MMC 3 +
    UCHAR Reserved3                : 1;
    UCHAR Reserved2;
    UCHAR DataTypeSupported[2];   // [0] == MSB, [1] == LSB // see also FeatureIncrementalStreamingWritable
} FEATURE_DATA_CD_TRACK_AT_ONCE, *PFEATURE_DATA_CD_TRACK_AT_ONCE;

// 0x002E - FeatureCdMastering
typedef struct _FEATURE_DATA_CD_MASTERING {
    FEATURE_HEADER Header;
    UCHAR RWSubchannelsRecordable  : 1;
    UCHAR CdRewritable             : 1;
    UCHAR TestWriteOk              : 1;
    UCHAR RawRecordingOk           : 1;
    UCHAR RawMultiSessionOk        : 1;
    UCHAR SessionAtOnceOk          : 1;
    UCHAR BufferUnderrunFree       : 1;
    UCHAR Reserved1                : 1;
    UCHAR MaximumCueSheetLength[3]; // [0] == MSB, [2] == LSB
} FEATURE_DATA_CD_MASTERING, *PFEATURE_DATA_CD_MASTERING;

// 0x002F - FeatureDvdRecordableWrite
typedef struct _FEATURE_DATA_DVD_RECORDABLE_WRITE {
    FEATURE_HEADER Header;
    UCHAR Reserved1                : 1;
    UCHAR DVD_RW                   : 1;
    UCHAR TestWrite                : 1;
    UCHAR RDualLayer               : 1;
    UCHAR Reserved02               : 2;
    UCHAR BufferUnderrunFree       : 1;
    UCHAR Reserved3                : 1;
    UCHAR Reserved4[3];
} FEATURE_DATA_DVD_RECORDABLE_WRITE, *PFEATURE_DATA_DVD_RECORDABLE_WRITE;

// 0x0030 - FeatureDDCDRead
typedef struct _FEATURE_DATA_DDCD_READ {
    FEATURE_HEADER Header;
} FEATURE_DATA_DDCD_READ, *PFEATURE_DATA_DDCD_READ;

// 0x0031 - FeatureDDCDRWrite (obsolete)
typedef struct _FEATURE_DATA_DDCD_R_WRITE {
    FEATURE_HEADER Header;
    UCHAR Reserved1               : 2;
    UCHAR TestWrite               : 1;
    UCHAR Reserved2               : 5;
    UCHAR Reserved3[3];
} FEATURE_DATA_DDCD_R_WRITE, *PFEATURE_DATA_DDCD_R_WRITE;

// 0x0032 - FeatureDDCDRWWrite (obsolete)
typedef struct _FEATURE_DATA_DDCD_RW_WRITE {
    FEATURE_HEADER Header;
    UCHAR Blank                   : 1;
    UCHAR Intermediate            : 1;
    UCHAR Reserved1               : 6;
    UCHAR Reserved2[3];
} FEATURE_DATA_DDCD_RW_WRITE, *PFEATURE_DATA_DDCD_RW_WRITE;

// 0x0033 - FeatureLayerJumpRecording
typedef struct _FEATURE_DATA_LAYER_JUMP_RECORDING {
    FEATURE_HEADER Header;
    UCHAR Reserved0[3];
    UCHAR NumberOfLinkSizes;
#if !defined(__midl)
    UCHAR LinkSizes[0];
#endif
} FEATURE_DATA_LAYER_JUMP_RECORDING, *PFEATURE_DATA_LAYER_JUMP_RECORDING;

// 0x0034 - 0x0036 are Reserved

// 0x0037 - FeatureCDRWMediaWriteSupport
typedef struct _FEATURE_CD_RW_MEDIA_WRITE_SUPPORT {
    FEATURE_HEADER Header;
    UCHAR Reserved1;
    struct{
        UCHAR Subtype0 :1;
        UCHAR Subtype1 :1;
        UCHAR Subtype2 :1;
        UCHAR Subtype3 :1;
        UCHAR Subtype4 :1;
        UCHAR Subtype5 :1;
        UCHAR Subtype6 :1;
        UCHAR Subtype7 :1;
    } CDRWMediaSubtypeSupport;
    UCHAR Reserved2[2];
} FEATURE_CD_RW_MEDIA_WRITE_SUPPORT, *PFEATURE_CD_RW_MEDIA_WRITE_SUPPORT;

// 0x0038 - FeatureBDRPseudoOverwrite
typedef struct _FEATURE_BD_R_PSEUDO_OVERWRITE {
    FEATURE_HEADER Header;
    UCHAR Reserved[4];
} FEATURE_BD_R_PSEUDO_OVERWRITE, *PFEATURE_BD_R_PSEUDO_OVERWRITE;

// 0x0039 is Reserved

// 0x003A - FeatureDvdPlusRWDualLayer
typedef struct _FEATURE_DATA_DVD_PLUS_RW_DUAL_LAYER {
    FEATURE_HEADER Header;
    UCHAR Write         : 1;
    UCHAR Reserved1     : 7;
    UCHAR CloseOnly     : 1;
    UCHAR QuickStart    : 1;
    UCHAR Reserved2     : 6;
    UCHAR Reserved3[2];
} FEATURE_DATA_DVD_PLUS_RW_DUAL_LAYER, *PFEATURE_DATA_DVD_PLUS_RW_DUAL_LAYER;

// 0x003B - FeatureDvdPlusRDualLayer
typedef struct _FEATURE_DATA_DVD_PLUS_R_DUAL_LAYER {
    FEATURE_HEADER Header;
    UCHAR Write     : 1;
    UCHAR Reserved1 : 7;
    UCHAR Reserved2[3];
} FEATURE_DATA_DVD_PLUS_R_DUAL_LAYER, *PFEATURE_DATA_DVD_PLUS_R_DUAL_LAYER;

// 0x003C - 0x0039 are Reserved

// 0x0040 - FeatureBDRead

typedef struct _BD_CLASS_SUPPORT_BITMAP {
    UCHAR Version8  :1;
    UCHAR Version9  :1;
    UCHAR Version10 :1;
    UCHAR Version11 :1;
    UCHAR Version12 :1;
    UCHAR Version13 :1;
    UCHAR Version14 :1;
    UCHAR Version15 :1;
    UCHAR Version0  :1;
    UCHAR Version1  :1;
    UCHAR Version2  :1;
    UCHAR Version3  :1;
    UCHAR Version4  :1;
    UCHAR Version5  :1;
    UCHAR Version6  :1;
    UCHAR Version7  :1;
} BD_CLASS_SUPPORT_BITMAP, *PBD_CLASS_SUPPORT_BITMAP;

typedef struct _FEATURE_BD_READ {
    FEATURE_HEADER Header;
    UCHAR Reserved[4];
    BD_CLASS_SUPPORT_BITMAP Class0BitmapBDREReadSupport;
    BD_CLASS_SUPPORT_BITMAP Class1BitmapBDREReadSupport;
    BD_CLASS_SUPPORT_BITMAP Class2BitmapBDREReadSupport;
    BD_CLASS_SUPPORT_BITMAP Class3BitmapBDREReadSupport;
    BD_CLASS_SUPPORT_BITMAP Class0BitmapBDRReadSupport;
    BD_CLASS_SUPPORT_BITMAP Class1BitmapBDRReadSupport;
    BD_CLASS_SUPPORT_BITMAP Class2BitmapBDRReadSupport;
    BD_CLASS_SUPPORT_BITMAP Class3BitmapBDRReadSupport;
    BD_CLASS_SUPPORT_BITMAP Class0BitmapBDROMReadSupport;
    BD_CLASS_SUPPORT_BITMAP Class1BitmapBDROMReadSupport;
    BD_CLASS_SUPPORT_BITMAP Class2BitmapBDROMReadSupport;
    BD_CLASS_SUPPORT_BITMAP Class3BitmapBDROMReadSupport;
} FEATURE_BD_READ, *PFEATURE_BD_READ;

// 0x0041 - FeatureBDWrite
typedef struct _FEATURE_BD_WRITE {
    FEATURE_HEADER Header;
    UCHAR SupportsVerifyNotRequired :1;
    UCHAR Reserved1                 :7;
    UCHAR Reserved2[3];
    BD_CLASS_SUPPORT_BITMAP Class0BitmapBDREWriteSupport;
    BD_CLASS_SUPPORT_BITMAP Class1BitmapBDREWriteSupport;
    BD_CLASS_SUPPORT_BITMAP Class2BitmapBDREWriteSupport;
    BD_CLASS_SUPPORT_BITMAP Class3BitmapBDREWriteSupport;
    BD_CLASS_SUPPORT_BITMAP Class0BitmapBDRWriteSupport;
    BD_CLASS_SUPPORT_BITMAP Class1BitmapBDRWriteSupport;
    BD_CLASS_SUPPORT_BITMAP Class2BitmapBDRWriteSupport;
    BD_CLASS_SUPPORT_BITMAP Class3BitmapBDRWriteSupport;
} FEATURE_BD_WRITE, *PFEATURE_BD_WRITE;

// 0x0042 - FeatureTSR
typedef struct _FEATURE_TSR {
    FEATURE_HEADER Header;
} FEATURE_TSR, *PFEATURE_TSR;

// 0x0043 - 0x004F are Reserved

// 0x0050 - FeatureHDDVDRead
typedef struct _FEATURE_DATA_HDDVD_READ {
    FEATURE_HEADER Header;
    UCHAR Recordable : 1;
    UCHAR Reserved0  : 7;
    UCHAR Reserved1;
    UCHAR Rewritable : 1; // Stands for HD DVD-RAM
    UCHAR Reserved2  : 7;
    UCHAR Reserved3;
} FEATURE_DATA_HDDVD_READ, *PFEATURE_DATA_HDDVD_READ;

// 0x0051 - FeatureHDDVDWrite
typedef struct _FEATURE_DATA_HDDVD_WRITE {
    FEATURE_HEADER Header;
    UCHAR Recordable : 1;
    UCHAR Reserved0  : 7;
    UCHAR Reserved1;
    UCHAR Rewritable : 1; // Stands for HD DVD-RAM
    UCHAR Reserved2  : 7;
    UCHAR Reserved3;
} FEATURE_DATA_HDDVD_WRITE, *PFEATURE_DATA_HDDVD_WRITE;

// 0x0052 - 0x007F are Reserved

// 0x0080 - FeatureHybridDisc
typedef struct _FEATURE_HYBRID_DISC {
    FEATURE_HEADER Header;
    UCHAR ResetImmunity : 1;
    UCHAR Reserved1     : 7;
    UCHAR Reserved2[3];
} FEATURE_HYBRID_DISC, *PFEATURE_HYBRID_DISC;

// 0x0081 - 0x00FF are Reserved

// 0x0100 - FeaturePowerManagement
typedef struct _FEATURE_DATA_POWER_MANAGEMENT {
    FEATURE_HEADER Header;
} FEATURE_DATA_POWER_MANAGEMENT, *PFEATURE_DATA_POWER_MANAGEMENT;

// 0x0101 - FeatureSMART (not in MMC 2)
typedef struct _FEATURE_DATA_SMART {
    FEATURE_HEADER Header;
    UCHAR FaultFailureReportingPagePresent : 1;
    UCHAR Reserved1                        : 7;
    UCHAR Reserved02[3];
} FEATURE_DATA_SMART, *PFEATURE_DATA_SMART;

// 0x0102 - FeatureEmbeddedChanger
typedef struct _FEATURE_DATA_EMBEDDED_CHANGER {
    FEATURE_HEADER Header;
    UCHAR Reserved1                : 2;
    UCHAR SupportsDiscPresent      : 1;
    UCHAR Reserved2                : 1;
    UCHAR SideChangeCapable        : 1;
    UCHAR Reserved3                : 3;
    UCHAR Reserved4[2];
    UCHAR HighestSlotNumber        : 5;
    UCHAR Reserved                 : 3;
} FEATURE_DATA_EMBEDDED_CHANGER, *PFEATURE_DATA_EMBEDDED_CHANGER;

// 0x0103 - FeatureCDAudioAnalogPlay (obsolete)
typedef struct _FEATURE_DATA_CD_AUDIO_ANALOG_PLAY {
    FEATURE_HEADER Header;
    UCHAR SeperateVolume           : 1;
    UCHAR SeperateChannelMute      : 1;
    UCHAR ScanSupported            : 1;
    UCHAR Reserved1                : 5;
    UCHAR Reserved2;
    UCHAR NumerOfVolumeLevels[2];  // [0] == MSB, [1] == LSB
} FEATURE_DATA_CD_AUDIO_ANALOG_PLAY, *PFEATURE_DATA_CD_AUDIO_ANALOG_PLAY;

// 0x0104 - FeatureMicrocodeUpgrade
typedef struct _FEATURE_DATA_MICROCODE_UPDATE {
    FEATURE_HEADER Header;
    UCHAR M5        : 1;
    UCHAR Reserved1 : 7;
    UCHAR Reserved2[3];
} FEATURE_DATA_MICROCODE_UPDATE, *PFEATURE_DATA_MICROCODE_UPDATE;

// 0x0105 - FeatureTimeout
typedef struct _FEATURE_DATA_TIMEOUT {
    FEATURE_HEADER Header;
    UCHAR Group3    : 1;
    UCHAR Reserved1 : 7;
    UCHAR Reserved2;
    UCHAR UnitLength[2];
} FEATURE_DATA_TIMEOUT, *PFEATURE_DATA_TIMEOUT;

// 0x0106 - FeatureDvdCSS
typedef struct _FEATURE_DATA_DVD_CSS {
    FEATURE_HEADER Header;
    UCHAR Reserved1[3];
    UCHAR CssVersion;
} FEATURE_DATA_DVD_CSS, *PFEATURE_DATA_DVD_CSS;

// 0x0107 - FeatureRealTimeStreaming
typedef struct _FEATURE_DATA_REAL_TIME_STREAMING {
    FEATURE_HEADER Header;
    UCHAR StreamRecording         : 1;
    UCHAR WriteSpeedInGetPerf     : 1;
    UCHAR WriteSpeedInMP2A        : 1;
    UCHAR SetCDSpeed              : 1;
    UCHAR ReadBufferCapacityBlock : 1;
    UCHAR Reserved1               : 3;
    UCHAR Reserved2[3];
} FEATURE_DATA_REAL_TIME_STREAMING, *PFEATURE_DATA_REAL_TIME_STREAMING;

// 0x0108 - FeatureLogicalUnitSerialNumber
typedef struct _FEATURE_DATA_LOGICAL_UNIT_SERIAL_NUMBER {
    FEATURE_HEADER Header;
#if !defined(__midl)
    UCHAR SerialNumber[0];
#endif
} FEATURE_DATA_LOGICAL_UNIT_SERIAL_NUMBER, *PFEATURE_DATA_LOGICAL_UNIT_SERIAL_NUMBER;

// 0x0109 - FeatureMediaSerialNumber
typedef struct _FEATURE_MEDIA_SERIAL_NUMBER {
    FEATURE_HEADER Header;
} FEATURE_MEDIA_SERIAL_NUMBER, *PFEATURE_MEDIA_SERIAL_NUMBER;

// 0x010A - FeatureDiscControlBlocks
// an integral multiple of the _EX structures are returned for page 010A
typedef struct _FEATURE_DATA_DISC_CONTROL_BLOCKS_EX {
    UCHAR ContentDescriptor[4];
} FEATURE_DATA_DISC_CONTROL_BLOCKS_EX, *PFEATURE_DATA_DISC_CONTROL_BLOCKS_EX;
// use a zero-sized array for this....
typedef struct _FEATURE_DATA_DISC_CONTROL_BLOCKS {
    FEATURE_HEADER Header;
#if !defined(__midl)
    FEATURE_DATA_DISC_CONTROL_BLOCKS_EX Data[0];
#endif
} FEATURE_DATA_DISC_CONTROL_BLOCKS, *PFEATURE_DATA_DISC_CONTROL_BLOCKS;

// 0x010B - FeatureDvdCPRM
typedef struct _FEATURE_DATA_DVD_CPRM {
    FEATURE_HEADER Header;
    UCHAR Reserved0[3];
    UCHAR CPRMVersion;
} FEATURE_DATA_DVD_CPRM, *PFEATURE_DATA_DVD_CPRM;

// 0x010C - FeatureFirmwareDate
typedef struct _FEATURE_DATA_FIRMWARE_DATE {
    FEATURE_HEADER Header;
    UCHAR Year[4];
    UCHAR Month[2];
    UCHAR Day[2];
    UCHAR Hour[2];
    UCHAR Minute[2];
    UCHAR Seconds[2];
    UCHAR Reserved[2];
} FEATURE_DATA_FIRMWARE_DATE, *PFEATURE_DATA_FIRMWARE_DATE;

// 0x010D - FeatureAACS
typedef struct _FEATURE_DATA_AACS {
    FEATURE_HEADER Header;
    UCHAR BindingNonceGeneration : 1;
    UCHAR Reserved0              : 7;
    UCHAR BindingNonceBlockCount;
    UCHAR NumberOfAGIDs  : 4;
    UCHAR Reserved1      : 4;
    UCHAR AACSVersion;
} FEATURE_DATA_AACS, *PFEATURE_DATA_AACS;

// 0x010E - 0x010F are Reserved

// 0x0110 - FeatureVCPS
typedef struct _FEATURE_VCPS {
    FEATURE_HEADER Header;
    UCHAR Reserved[4];
} FEATURE_VCPS, *PFEATURE_VCPS;

// 0x0111 - 0xFEFF are Reserved
typedef struct _FEATURE_DATA_RESERVED {
    FEATURE_HEADER Header;
#if !defined(__midl)
    UCHAR Data[0];
#endif
} FEATURE_DATA_RESERVED, *PFEATURE_DATA_RESERVED;

// 0xff00 - 0xffff are Vendor Specific
typedef struct _FEATURE_DATA_VENDOR_SPECIFIC {
    FEATURE_HEADER Header;
#if !defined(__midl)
    UCHAR VendorSpecificData[0];
#endif
} FEATURE_DATA_VENDOR_SPECIFIC, *PFEATURE_DATA_VENDOR_SPECIFIC;


//
// NOTE: All FEATURE_* structures may be extended.  use of these structures
//       requires verification that the FeatureHeader->AdditionLength field
//       contains AT LEAST enough data to cover the data fields being accessed.
//       This is due to the design, which allows extending the size of the
//       various structures, which will result in these structures sizes
//       being changed over time.
//       A 0-element array is however not declared in the variable size
//       structures. Such array is declared on some structures to preserve
//       legacy, yet it is deprecated. To access variable size structures,
//       as they are always at the end of the fixed size structure, use a sizeof
//       of the declared fixed size structure as an offset.
//       *** Programmers beware! ***
//

//
// NOTE: This is based on MMC 3, extended to MMC 5 rev 3
//       Further revisions will maintain backward compatibility
//       with the non-reserved fields listed here.  If you need
//       to access a new field, please typecast to FEATURE_DATA_RESERVED
//       and access the appropriate bits there.
//

//
// IOCTL_CDROM_GET_CONFIGURATION returns a FEATURE_* struct, which always
//       starts with a FEATURE_HEADER structure.
//

//
// these are to be used for the request type
//

#define SCSI_GET_CONFIGURATION_REQUEST_TYPE_ALL     0x0
#define SCSI_GET_CONFIGURATION_REQUEST_TYPE_CURRENT 0x1
#define SCSI_GET_CONFIGURATION_REQUEST_TYPE_ONE     0x2


typedef struct _GET_CONFIGURATION_IOCTL_INPUT {
    FEATURE_NUMBER Feature;
    ULONG          RequestType; // SCSI_GET_CONFIGURATION_REQUEST_TYPE_*
    PVOID          Reserved[2];
} GET_CONFIGURATION_IOCTL_INPUT, *PGET_CONFIGURATION_IOCTL_INPUT;

#if defined(_WIN64)
typedef struct _GET_CONFIGURATION_IOCTL_INPUT32 {
    FEATURE_NUMBER   Feature;
    ULONG            RequestType; // SCSI_GET_CONFIGURATION_REQUEST_TYPE_*
    VOID* UPOINTER_32 Reserved[2];
} GET_CONFIGURATION_IOCTL_INPUT32, *PGET_CONFIGURATION_IOCTL_INPUT32;
#endif


#if _MSC_VER >= 1200
#pragma warning(pop)          // un-sets any local warning changes
#else
#pragma warning(default:4200) // array[0] is not a warning for this file
#endif

#ifdef __cplusplus
}
#endif

#endif // __NTDDMMC__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NtDDPSch.h ===
/*++

Copyright (c) 1996-1999  Microsoft Corporation

Module Name:

    ntddpsch.h

Abstract:

    defines that are exported to user mode

Author:

Revision History:

--*/

#ifndef _NTDDPSCH_
#define _NTDDPSCH_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// flow data returned in the Stats structure
//

#pragma pack(1)
typedef struct _PS_COMPONENT_STATS {

#define PS_COMPONENT_ADAPTER        1
#define PS_COMPONENT_FLOW           2
#define PS_COMPONENT_CONFORMER      3
#define PS_COMPONENT_SHAPER         4
#define PS_COMPONENT_DRRSEQ         5

    ULONG Type;
    ULONG Length;
    UCHAR Stats[1];
} PS_COMPONENT_STATS, *PPS_COMPONENT_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_CONFORMER_STATS {
    ULONG NonconformingPacketsScheduled;
} PS_CONFORMER_STATS, *PPS_CONFORMER_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_SHAPER_STATS {
    ULONG MaxPacketsInShaper;
    ULONG AveragePacketsInShaper;
} PS_SHAPER_STATS, *PPS_SHAPER_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_DRRSEQ_STATS {
    ULONG MaxPacketsInNetcard;
    ULONG AveragePacketsInNetcard;
    ULONG MaxPacketsInSequencer;
    ULONG AveragePacketsInSequencer;
    ULONG NonconformingPacketsTransmitted;
} PS_DRRSEQ_STATS, *PPS_DRRSEQ_STATS;
#pragma pack()


#pragma pack(1)
typedef struct _PS_FLOW_STATS {

    ULONG DroppedPackets;
    ULONG PacketsScheduled;
	ULONG PacketsTransmitted;
    LARGE_INTEGER BytesScheduled;
    LARGE_INTEGER BytesTransmitted;
} PS_FLOW_STATS, *PPS_FLOW_STATS;
#pragma pack()

#pragma pack(1)
typedef struct _PS_ADAPTER_STATS {

    //
    // OutOfPackets is incremented when no packets for sending/receive packet
    // indications are available.
    //

    ULONG OutOfPackets;

    //
    // general flow stats
    //

    ULONG FlowsOpened;
    ULONG FlowsClosed;
    ULONG FlowsRejected;
    ULONG FlowsModified;
    ULONG FlowModsRejected;
    ULONG MaxSimultaneousFlows;

} PS_ADAPTER_STATS, *PPS_ADAPTER_STATS;
#pragma pack()

//
// Defines that can be used for OID_QOS_FLOW_MODE
//
#define ADAPTER_FLOW_MODE_DIFFSERV           1
#define ADAPTER_FLOW_MODE_STANDARD           2


#ifdef __cplusplus
}
#endif

#endif /* _NTDDPSCH_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddser.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddser.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Serial device.

--*/


//
// Interface GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntddser.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntddser.h> in that source file a second time to instantiate the GUIDs
//
#ifdef DEFINE_GUID
//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

// begin_wioctlguids
DEFINE_GUID(GUID_DEVINTERFACE_COMPORT,                0x86e0d1e0L, 0x8089, 0x11d0, 0x9c, 0xe4, 0x08, 0x00, 0x3e, 0x30, 0x1f, 0x73);
DEFINE_GUID(GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR, 0x4D36E978L, 0xE325, 0x11CE, 0xBF, 0xC1, 0x08, 0x00, 0x2B, 0xE1, 0x03, 0x18);
// end_wioctlguids

// begin_wioctlobsoleteguids
#define GUID_CLASS_COMPORT          GUID_DEVINTERFACE_COMPORT
#define GUID_SERENUM_BUS_ENUMERATOR GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR
// end_wioctlobsoleteguids
#endif // DEFINE_GUID

#ifndef _NTDDSER_
#define _NTDDSER_

#ifdef __cplusplus
extern "C" {
#endif

//
// NtDeviceIoControlFile IoControlCode values for this device.
//

#define IOCTL_SERIAL_SET_BAUD_RATE      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 1,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_QUEUE_SIZE     CTL_CODE(FILE_DEVICE_SERIAL_PORT, 2,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_LINE_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT, 3,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_BREAK_ON       CTL_CODE(FILE_DEVICE_SERIAL_PORT, 4,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_BREAK_OFF      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 5,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_IMMEDIATE_CHAR     CTL_CODE(FILE_DEVICE_SERIAL_PORT, 6,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_TIMEOUTS       CTL_CODE(FILE_DEVICE_SERIAL_PORT, 7,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_TIMEOUTS       CTL_CODE(FILE_DEVICE_SERIAL_PORT, 8,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_DTR            CTL_CODE(FILE_DEVICE_SERIAL_PORT, 9,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_CLR_DTR            CTL_CODE(FILE_DEVICE_SERIAL_PORT,10,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_RESET_DEVICE       CTL_CODE(FILE_DEVICE_SERIAL_PORT,11,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_RTS            CTL_CODE(FILE_DEVICE_SERIAL_PORT,12,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_CLR_RTS            CTL_CODE(FILE_DEVICE_SERIAL_PORT,13,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_XOFF           CTL_CODE(FILE_DEVICE_SERIAL_PORT,14,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_XON            CTL_CODE(FILE_DEVICE_SERIAL_PORT,15,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_WAIT_MASK      CTL_CODE(FILE_DEVICE_SERIAL_PORT,16,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_WAIT_MASK      CTL_CODE(FILE_DEVICE_SERIAL_PORT,17,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_WAIT_ON_MASK       CTL_CODE(FILE_DEVICE_SERIAL_PORT,18,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_PURGE              CTL_CODE(FILE_DEVICE_SERIAL_PORT,19,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_BAUD_RATE      CTL_CODE(FILE_DEVICE_SERIAL_PORT,20,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_LINE_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT,21,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_CHARS          CTL_CODE(FILE_DEVICE_SERIAL_PORT,22,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_CHARS          CTL_CODE(FILE_DEVICE_SERIAL_PORT,23,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_HANDFLOW       CTL_CODE(FILE_DEVICE_SERIAL_PORT,24,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_HANDFLOW       CTL_CODE(FILE_DEVICE_SERIAL_PORT,25,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_MODEMSTATUS    CTL_CODE(FILE_DEVICE_SERIAL_PORT,26,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_COMMSTATUS     CTL_CODE(FILE_DEVICE_SERIAL_PORT,27,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_XOFF_COUNTER       CTL_CODE(FILE_DEVICE_SERIAL_PORT,28,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_PROPERTIES     CTL_CODE(FILE_DEVICE_SERIAL_PORT,29,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_DTRRTS         CTL_CODE(FILE_DEVICE_SERIAL_PORT,30,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Serenum reserves function codes between 128 and 255.  Do not use.
//

// begin_winioctl

#define IOCTL_SERIAL_LSRMST_INSERT      CTL_CODE(FILE_DEVICE_SERIAL_PORT,31,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_SERENUM_EXPOSE_HARDWARE   CTL_CODE(FILE_DEVICE_SERENUM,128,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_REMOVE_HARDWARE   CTL_CODE(FILE_DEVICE_SERENUM,129,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_PORT_DESC         CTL_CODE(FILE_DEVICE_SERENUM,130,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERENUM_GET_PORT_NAME     CTL_CODE(FILE_DEVICE_SERENUM,131,METHOD_BUFFERED,FILE_ANY_ACCESS)

// end_winioctl

#define IOCTL_SERIAL_CONFIG_SIZE        CTL_CODE(FILE_DEVICE_SERIAL_PORT,32,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_COMMCONFIG     CTL_CODE(FILE_DEVICE_SERIAL_PORT,33,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_COMMCONFIG     CTL_CODE(FILE_DEVICE_SERIAL_PORT,34,METHOD_BUFFERED,FILE_ANY_ACCESS)

#define IOCTL_SERIAL_GET_STATS          CTL_CODE(FILE_DEVICE_SERIAL_PORT,35,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_CLEAR_STATS        CTL_CODE(FILE_DEVICE_SERIAL_PORT,36,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_GET_MODEM_CONTROL  CTL_CODE(FILE_DEVICE_SERIAL_PORT,37,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_MODEM_CONTROL  CTL_CODE(FILE_DEVICE_SERIAL_PORT,38,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SERIAL_SET_FIFO_CONTROL   CTL_CODE(FILE_DEVICE_SERIAL_PORT,39,METHOD_BUFFERED,FILE_ANY_ACCESS)


//
// internal serial IOCTL's
//

#define IOCTL_SERIAL_INTERNAL_DO_WAIT_WAKE      CTL_CODE(FILE_DEVICE_SERIAL_PORT, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SERIAL_INTERNAL_CANCEL_WAIT_WAKE  CTL_CODE(FILE_DEVICE_SERIAL_PORT, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS    CTL_CODE(FILE_DEVICE_SERIAL_PORT, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS  CTL_CODE(FILE_DEVICE_SERIAL_PORT, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _SERIALPERF_STATS {
    ULONG ReceivedCount;
    ULONG TransmittedCount;
    ULONG FrameErrorCount;
    ULONG SerialOverrunErrorCount;
    ULONG BufferOverrunErrorCount;
    ULONG ParityErrorCount;
} SERIALPERF_STATS, *PSERIALPERF_STATS;

typedef struct _SERIALCONFIG {
    ULONG Size;
    USHORT Version;
    ULONG SubType;
    ULONG ProvOffset;
    ULONG ProviderSize;
    WCHAR ProviderData[1];
} SERIALCONFIG,*PSERIALCONFIG;

//
// NtDeviceIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

//
// This structure used to set line parameters.
//

typedef struct _SERIAL_LINE_CONTROL {
    UCHAR StopBits;
    UCHAR Parity;
    UCHAR WordLength;
    } SERIAL_LINE_CONTROL,*PSERIAL_LINE_CONTROL;

typedef struct _SERIAL_TIMEOUTS {
    ULONG ReadIntervalTimeout;
    ULONG ReadTotalTimeoutMultiplier;
    ULONG ReadTotalTimeoutConstant;
    ULONG WriteTotalTimeoutMultiplier;
    ULONG WriteTotalTimeoutConstant;
    } SERIAL_TIMEOUTS,*PSERIAL_TIMEOUTS;

//
// This structure used to resize the input/output buffers.
// An error code will be returned if the size exceeds the
// drivers capacity.  The driver reserves the right to
// allocate a larger buffer.
//

typedef struct _SERIAL_QUEUE_SIZE {
    ULONG InSize;
    ULONG OutSize;
    } SERIAL_QUEUE_SIZE,*PSERIAL_QUEUE_SIZE;


//
// This structure used by set baud rate
//

typedef struct _SERIAL_BAUD_RATE {
    ULONG BaudRate;
    } SERIAL_BAUD_RATE,*PSERIAL_BAUD_RATE;



//
// Defines the bitmask that the driver can used to notify
// app of various changes in the state of the UART.
//

#define SERIAL_EV_RXCHAR           0x0001  // Any Character received
#define SERIAL_EV_RXFLAG           0x0002  // Received certain character
#define SERIAL_EV_TXEMPTY          0x0004  // Transmitt Queue Empty
#define SERIAL_EV_CTS              0x0008  // CTS changed state
#define SERIAL_EV_DSR              0x0010  // DSR changed state
#define SERIAL_EV_RLSD             0x0020  // RLSD changed state
#define SERIAL_EV_BREAK            0x0040  // BREAK received
#define SERIAL_EV_ERR              0x0080  // Line status error occurred
#define SERIAL_EV_RING             0x0100  // Ring signal detected
#define SERIAL_EV_PERR             0x0200  // Printer error occured
#define SERIAL_EV_RX80FULL         0x0400  // Receive buffer is 80 percent full
#define SERIAL_EV_EVENT1           0x0800  // Provider specific event 1
#define SERIAL_EV_EVENT2           0x1000  // Provider specific event 2

//
// A longword is used to send down a mask that
// instructs the driver what to purge.
//
// SERIAL_PURGE_TXABORT - Implies the current and all pending writes.
// SERIAL_PURGE_RXABORT - Implies the current and all pending reads.
// SERIAL_PURGE_TXCLEAR - Implies the transmit buffer if exists
// SERIAL_PURGE_RXCLEAR - Implies the receive buffer if exists.
//

#define SERIAL_PURGE_TXABORT 0x00000001
#define SERIAL_PURGE_RXABORT 0x00000002
#define SERIAL_PURGE_TXCLEAR 0x00000004
#define SERIAL_PURGE_RXCLEAR 0x00000008

//
// Communication defines
//

#define STOP_BIT_1      0
#define STOP_BITS_1_5   1
#define STOP_BITS_2     2

#define NO_PARITY        0
#define ODD_PARITY       1
#define EVEN_PARITY      2
#define MARK_PARITY      3
#define SPACE_PARITY     4


//
// This structure is used to set and retrieve the special characters
// used by the nt serial driver.
//
// Note that the driver will return an error if xonchar == xoffchar.
//

typedef struct _SERIAL_CHARS {
    UCHAR EofChar;
    UCHAR ErrorChar;
    UCHAR BreakChar;
    UCHAR EventChar;
    UCHAR XonChar;
    UCHAR XoffChar;
    } SERIAL_CHARS,*PSERIAL_CHARS;

//
// This structure is used to contain the flow control
// and handshaking setup.
//
// A reasonably precise explaination of how they all
// work can be found in the OS/2 tech references.
//
// For Xon/Xofflimit:
//
// When there are more characters then
//
// (typeaheadbuffersize - xofflimit)
//
// in the typeahead buffer then the driver will perform all flow
// control that the app has enabled so that the sender will (hopefully)
// stop sending characters.
//
// When there are less than xonlimit number of characters in the
// typeahead buffer the driver will perform all flow control that
// the app has enabled so that the sender will hopefully start sending
// characters again.
//
// It should be noted that if Xoff character is sent then the
// driver will also stop transmitting any more characters.  This is to
// provide support for those systems that take any character that
// follows an Xoff as an implied Xon.
//

typedef struct _SERIAL_HANDFLOW {
    ULONG ControlHandShake;
    ULONG FlowReplace;
    LONG XonLimit;
    LONG XoffLimit;
    } SERIAL_HANDFLOW,*PSERIAL_HANDFLOW;

#define SERIAL_DTR_MASK           ((ULONG)0x03)
#define SERIAL_DTR_CONTROL        ((ULONG)0x01)
#define SERIAL_DTR_HANDSHAKE      ((ULONG)0x02)
#define SERIAL_CTS_HANDSHAKE      ((ULONG)0x08)
#define SERIAL_DSR_HANDSHAKE      ((ULONG)0x10)
#define SERIAL_DCD_HANDSHAKE      ((ULONG)0x20)
#define SERIAL_OUT_HANDSHAKEMASK  ((ULONG)0x38)
#define SERIAL_DSR_SENSITIVITY    ((ULONG)0x40)
#define SERIAL_ERROR_ABORT        ((ULONG)0x80000000)
#define SERIAL_CONTROL_INVALID    ((ULONG)0x7fffff84)
#define SERIAL_AUTO_TRANSMIT      ((ULONG)0x01)
#define SERIAL_AUTO_RECEIVE       ((ULONG)0x02)
#define SERIAL_ERROR_CHAR         ((ULONG)0x04)
#define SERIAL_NULL_STRIPPING     ((ULONG)0x08)
#define SERIAL_BREAK_CHAR         ((ULONG)0x10)
#define SERIAL_RTS_MASK           ((ULONG)0xc0)
#define SERIAL_RTS_CONTROL        ((ULONG)0x40)
#define SERIAL_RTS_HANDSHAKE      ((ULONG)0x80)
#define SERIAL_TRANSMIT_TOGGLE    ((ULONG)0xc0)
#define SERIAL_XOFF_CONTINUE      ((ULONG)0x80000000)
#define SERIAL_FLOW_INVALID       ((ULONG)0x7fffff20)

//
// These are the following reasons that the device could be holding.
//
#define SERIAL_TX_WAITING_FOR_CTS      ((ULONG)0x00000001)
#define SERIAL_TX_WAITING_FOR_DSR      ((ULONG)0x00000002)
#define SERIAL_TX_WAITING_FOR_DCD      ((ULONG)0x00000004)
#define SERIAL_TX_WAITING_FOR_XON      ((ULONG)0x00000008)
#define SERIAL_TX_WAITING_XOFF_SENT    ((ULONG)0x00000010)
#define SERIAL_TX_WAITING_ON_BREAK     ((ULONG)0x00000020)
#define SERIAL_RX_WAITING_FOR_DSR      ((ULONG)0x00000040)

//
// These are the error values that can be returned by the
// driver.
//
#define SERIAL_ERROR_BREAK             ((ULONG)0x00000001)
#define SERIAL_ERROR_FRAMING           ((ULONG)0x00000002)
#define SERIAL_ERROR_OVERRUN           ((ULONG)0x00000004)
#define SERIAL_ERROR_QUEUEOVERRUN      ((ULONG)0x00000008)
#define SERIAL_ERROR_PARITY            ((ULONG)0x00000010)


//
// This structure is used by IOCTL_SERIAL_INTERNAL_BASIC_SETTINGS
// and IOCTL_SERIAL_INTERNAL_RESTORE_SETTINGS
//

typedef struct _SERIAL_BASIC_SETTINGS {
   SERIAL_TIMEOUTS Timeouts;
   SERIAL_HANDFLOW HandFlow;
   ULONG RxFifo;
   ULONG TxFifo;
} SERIAL_BASIC_SETTINGS, *PSERIAL_BASIC_SETTINGS;


//
// This structure is used to get the current error and
// general status of the driver.
//

typedef struct _SERIAL_STATUS {
    ULONG Errors;
    ULONG HoldReasons;
    ULONG AmountInInQueue;
    ULONG AmountInOutQueue;
    BOOLEAN EofReceived;
    BOOLEAN WaitForImmediate;
    } SERIAL_STATUS,*PSERIAL_STATUS;

//
// This structure is used for XOFF counter ioctl.  The xoff ioctl
// is used to support those subsystems that feel the need to emulate
// the serial chip in software.
//
// It has the following semantics:
//
// This io request is placed into the normal device write
// queue.  That is, it will be queued behind any writes
// already given to the driver.
//
// When this request becomes the current request, the character
// specified in the field XoffChar will be sent, subject to
// all other flow control already defined.
//
// Immediately upon sending the character the driver will
// perform the following actions.
//
// A timer will be initiated that will expire after the
// number of milliseconds in the Timeout field of the
// SERIAL_XOFF_COUNTER structure.
//
// The driver will initialize a counter to the value specified
// in the Counter field of the SERIAL_XOFF_RECORD.  The driver
// will decrement this counter whenever a character is received.
//
// This request will then be held by the driver.  It will
// actually complete under the following circumstances:
//
// 1) If there is another "write" request behind it in the queue.
//    The "xoff" request will be completed with the informational status
//    STATUS_SERIAL_MORE_WRITES.  The Information field of the
//    IOSTATUS block will be set to 0.
//
//    Note: By write request we mean another SERIAL_XOFF_COUNTER
//    request, or a simple write request.  If the only subsequent
//    request is a flush request, the driver WILL NOT automatically
//    complete the SERIAL_XOFF_COUNTER request.  NOTE: Transmit
//    immediate requests DO NOT count as a normal write, and therefore
//    would not cause a counter request to complete.
//
// 2) The timer expires.  The driver will complete the request
//    with the informational status STATUS_SERIAL_COUNTER_TIMEOUT.
//    The Information field of the IOSTATUS of the request will be set to 0.
//
// 3) The driver maintained counter goes to zero.  (By implication,
//    at least "Counter" number of characters have been received.)
//    The request will be completed with a successful status
//    of STATUS_SUCCESS.  The Information field of the
//    IOSTATUS of the request will be set to 0.
//
// 4) This is really a degenerate case of "1" above.  The request
//    is started and no request follow it on the queue.  However
//    at some point, before "2" or "3" above occur, another "write"
//    request is started.  This will cause the completion actions
//    stated in "1" to occur.
//
// NOTE: This request being issued WILL NOT cause the normal flow
//       control code of the driver to be invoked.
//
// NOTE: This request has no interaction with the IOCTL_SERIAL_WAIT_ON_MASK
//       request.  An application CAN NOT wait via the above ^^^^^^ ioctl
//       on the counter going to zero.  The application must synchronize
//       with the particular IOCTL_SERIAL_XOFF_COUNTER request.
//
// NOTE: The Timeout value equal to zero would cause the counter
//       to NEVER timeout.  The only way that such a request could
//       be killed at that point would be issue another write, or
//       to purge the WRITE queue.
//

typedef struct _SERIAL_XOFF_COUNTER {
    ULONG Timeout; // Zero based.  In milliseconds
    LONG Counter; // Must be greater than zero.
    UCHAR XoffChar;
    } SERIAL_XOFF_COUNTER,*PSERIAL_XOFF_COUNTER;

//
// The following structure (and defines) are passed back by
// the serial driver in response to the get properties ioctl.
//

#define SERIAL_SP_SERIALCOMM         ((ULONG)0x00000001)

//
// Provider subtypes
//
#define SERIAL_SP_UNSPECIFIED       ((ULONG)0x00000000)
#define SERIAL_SP_RS232             ((ULONG)0x00000001)
#define SERIAL_SP_PARALLEL          ((ULONG)0x00000002)
#define SERIAL_SP_RS422             ((ULONG)0x00000003)
#define SERIAL_SP_RS423             ((ULONG)0x00000004)
#define SERIAL_SP_RS449             ((ULONG)0x00000005)
#define SERIAL_SP_MODEM             ((ULONG)0X00000006)
#define SERIAL_SP_FAX               ((ULONG)0x00000021)
#define SERIAL_SP_SCANNER           ((ULONG)0x00000022)
#define SERIAL_SP_BRIDGE            ((ULONG)0x00000100)
#define SERIAL_SP_LAT               ((ULONG)0x00000101)
#define SERIAL_SP_TELNET            ((ULONG)0x00000102)
#define SERIAL_SP_X25               ((ULONG)0x00000103)

//
// Provider capabilities flags.
//

#define SERIAL_PCF_DTRDSR        ((ULONG)0x0001)
#define SERIAL_PCF_RTSCTS        ((ULONG)0x0002)
#define SERIAL_PCF_CD            ((ULONG)0x0004)
#define SERIAL_PCF_PARITY_CHECK  ((ULONG)0x0008)
#define SERIAL_PCF_XONXOFF       ((ULONG)0x0010)
#define SERIAL_PCF_SETXCHAR      ((ULONG)0x0020)
#define SERIAL_PCF_TOTALTIMEOUTS ((ULONG)0x0040)
#define SERIAL_PCF_INTTIMEOUTS   ((ULONG)0x0080)
#define SERIAL_PCF_SPECIALCHARS  ((ULONG)0x0100)
#define SERIAL_PCF_16BITMODE     ((ULONG)0x0200)

//
// Comm provider settable parameters.
//

#define SERIAL_SP_PARITY         ((ULONG)0x0001)
#define SERIAL_SP_BAUD           ((ULONG)0x0002)
#define SERIAL_SP_DATABITS       ((ULONG)0x0004)
#define SERIAL_SP_STOPBITS       ((ULONG)0x0008)
#define SERIAL_SP_HANDSHAKING    ((ULONG)0x0010)
#define SERIAL_SP_PARITY_CHECK   ((ULONG)0x0020)
#define SERIAL_SP_CARRIER_DETECT ((ULONG)0x0040)

//
// Settable baud rates in the provider.
//

#define SERIAL_BAUD_075          ((ULONG)0x00000001)
#define SERIAL_BAUD_110          ((ULONG)0x00000002)
#define SERIAL_BAUD_134_5        ((ULONG)0x00000004)
#define SERIAL_BAUD_150          ((ULONG)0x00000008)
#define SERIAL_BAUD_300          ((ULONG)0x00000010)
#define SERIAL_BAUD_600          ((ULONG)0x00000020)
#define SERIAL_BAUD_1200         ((ULONG)0x00000040)
#define SERIAL_BAUD_1800         ((ULONG)0x00000080)
#define SERIAL_BAUD_2400         ((ULONG)0x00000100)
#define SERIAL_BAUD_4800         ((ULONG)0x00000200)
#define SERIAL_BAUD_7200         ((ULONG)0x00000400)
#define SERIAL_BAUD_9600         ((ULONG)0x00000800)
#define SERIAL_BAUD_14400        ((ULONG)0x00001000)
#define SERIAL_BAUD_19200        ((ULONG)0x00002000)
#define SERIAL_BAUD_38400        ((ULONG)0x00004000)
#define SERIAL_BAUD_56K          ((ULONG)0x00008000)
#define SERIAL_BAUD_128K         ((ULONG)0x00010000)
#define SERIAL_BAUD_115200       ((ULONG)0x00020000)
#define SERIAL_BAUD_57600        ((ULONG)0x00040000)
#define SERIAL_BAUD_USER         ((ULONG)0x10000000)

//
// Settable Data Bits
//

#define SERIAL_DATABITS_5        ((USHORT)0x0001)
#define SERIAL_DATABITS_6        ((USHORT)0x0002)
#define SERIAL_DATABITS_7        ((USHORT)0x0004)
#define SERIAL_DATABITS_8        ((USHORT)0x0008)
#define SERIAL_DATABITS_16       ((USHORT)0x0010)
#define SERIAL_DATABITS_16X      ((USHORT)0x0020)

//
// Settable Stop and Parity bits.
//

#define SERIAL_STOPBITS_10       ((USHORT)0x0001)
#define SERIAL_STOPBITS_15       ((USHORT)0x0002)
#define SERIAL_STOPBITS_20       ((USHORT)0x0004)
#define SERIAL_PARITY_NONE       ((USHORT)0x0100)
#define SERIAL_PARITY_ODD        ((USHORT)0x0200)
#define SERIAL_PARITY_EVEN       ((USHORT)0x0400)
#define SERIAL_PARITY_MARK       ((USHORT)0x0800)
#define SERIAL_PARITY_SPACE      ((USHORT)0x1000)

typedef struct _SERIAL_COMMPROP {
    USHORT PacketLength;
    USHORT PacketVersion;
    ULONG ServiceMask;
    ULONG Reserved1;
    ULONG MaxTxQueue;
    ULONG MaxRxQueue;
    ULONG MaxBaud;
    ULONG ProvSubType;
    ULONG ProvCapabilities;
    ULONG SettableParams;
    ULONG SettableBaud;
    USHORT SettableData;
    USHORT SettableStopParity;
    ULONG CurrentTxQueue;
    ULONG CurrentRxQueue;
    ULONG ProvSpec1;
    ULONG ProvSpec2;
    WCHAR ProvChar[1];
} SERIAL_COMMPROP,*PSERIAL_COMMPROP;

//
// Define masks for the rs-232 input and output.
//

#define SERIAL_DTR_STATE         ((ULONG)0x00000001)
#define SERIAL_RTS_STATE         ((ULONG)0x00000002)
#define SERIAL_CTS_STATE         ((ULONG)0x00000010)
#define SERIAL_DSR_STATE         ((ULONG)0x00000020)
#define SERIAL_RI_STATE          ((ULONG)0x00000040)
#define SERIAL_DCD_STATE         ((ULONG)0x00000080)


// begin_winioctl

//
// The following values follow the escape designator in the
// data stream if the LSRMST_INSERT mode has been turned on.
//
#define SERIAL_LSRMST_ESCAPE     ((UCHAR)0x00)

//
// Following this value is the contents of the line status
// register, and then the character in the RX hardware when
// the line status register was encountered.
//
#define SERIAL_LSRMST_LSR_DATA   ((UCHAR)0x01)

//
// Following this value is the contents of the line status
// register.  No error character follows
//
#define SERIAL_LSRMST_LSR_NODATA ((UCHAR)0x02)

//
// Following this value is the contents of the modem status
// register.
//
#define SERIAL_LSRMST_MST        ((UCHAR)0x03)

//
// Bit values for FIFO Control Register
//

#define SERIAL_IOC_FCR_FIFO_ENABLE      ((ULONG)0x00000001)
#define SERIAL_IOC_FCR_RCVR_RESET       ((ULONG)0x00000002)
#define SERIAL_IOC_FCR_XMIT_RESET       ((ULONG)0x00000004)
#define SERIAL_IOC_FCR_DMA_MODE         ((ULONG)0x00000008)
#define SERIAL_IOC_FCR_RES1             ((ULONG)0x00000010)
#define SERIAL_IOC_FCR_RES2             ((ULONG)0x00000020)
#define SERIAL_IOC_FCR_RCVR_TRIGGER_LSB ((ULONG)0x00000040)
#define SERIAL_IOC_FCR_RCVR_TRIGGER_MSB ((ULONG)0x00000080)

//
// Bit values for Modem Control Register
//

#define SERIAL_IOC_MCR_DTR              ((ULONG)0x00000001)
#define SERIAL_IOC_MCR_RTS              ((ULONG)0x00000002)
#define SERIAL_IOC_MCR_OUT1             ((ULONG)0x00000004)
#define SERIAL_IOC_MCR_OUT2             ((ULONG)0x00000008)
#define SERIAL_IOC_MCR_LOOP             ((ULONG)0x00000010)

// end_winioctl

//
// Serenum internal ioctl's
//

#undef PHYSICAL_ADDRESS
#define PHYSICAL_ADDRESS LARGE_INTEGER

typedef struct _SERENUM_PORT_DESC
{
    IN  ULONG               Size; // sizeof (struct _PORT_DESC)
    OUT PVOID               PortHandle;
    OUT PHYSICAL_ADDRESS    PortAddress;
        USHORT              Reserved[1];
} SERENUM_PORT_DESC, * PSERENUM_PORT_DESC;

// **************************************************************************
// Internal IOCTL interface for (pdo)
// The HID to legacy serial port minidriver uses this interface to
// find the address of the device.
// **************************************************************************

#define IOCTL_INTERNAL_SERENUM_REMOVE_SELF \
    CTL_CODE(FILE_DEVICE_SERENUM, 129, METHOD_NEITHER, FILE_ANY_ACCESS)


// of which IO_STACK_LOCATION->Parameters.Others.Argument1 is set to
// a pointer to struct _SERENUM_SER_PARAMETERS

typedef
UCHAR
(*PSERENUM_READPORT) (
    PVOID  SerPortAddress
    );

typedef
VOID
(*PSERENUM_WRITEPORT) (
    PVOID  SerPortAddress,
    UCHAR   Value
    );

typedef enum _SERENUM_PORTION {
    SerenumFirstHalf,
    SerenumSecondHalf,
    SerenumWhole
} SERENUM_PORTION;

typedef struct _SERENUM_PORT_PARAMETERS
{
    IN  ULONG               Size; // sizeof (SERENUM_GET_PORT_PARAMETERS)

    OUT PSERENUM_READPORT  ReadAccessor;  // read the serial port
    OUT PSERENUM_WRITEPORT WriteAccessor;  // write the serial port
    OUT PVOID               SerPortAddress; // token to read this serial port

    OUT PVOID               HardwareHandle; // a handle to this particular PDO.
    OUT SERENUM_PORTION    Portion;
    OUT USHORT              NumberAxis; // legacy joysticks only
        USHORT              Reserved [3];
} SERENUM_PORT_PARAMETERS, *PSERENUM_PORT_PARAMETERS;

#ifdef __cplusplus
}
#endif

#endif  // _NTDDSER_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddtdi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    ntddtdi.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Transport driver interface device.

--*/

#ifndef _NTDDTDI_
#define _NTDDTDI_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_TDI_DEVICE_NAME "\\Device\\UNKNOWN"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define _TDI_CONTROL_CODE(request,method) \
            CTL_CODE(FILE_DEVICE_TRANSPORT, request, method, FILE_ANY_ACCESS)

#define IOCTL_TDI_ACCEPT                _TDI_CONTROL_CODE( 0, METHOD_BUFFERED )
#define IOCTL_TDI_CONNECT               _TDI_CONTROL_CODE( 1, METHOD_BUFFERED )
#define IOCTL_TDI_DISCONNECT            _TDI_CONTROL_CODE( 2, METHOD_BUFFERED )
#define IOCTL_TDI_LISTEN                _TDI_CONTROL_CODE( 3, METHOD_BUFFERED )
#define IOCTL_TDI_QUERY_INFORMATION     _TDI_CONTROL_CODE( 4, METHOD_OUT_DIRECT )
#define IOCTL_TDI_RECEIVE               _TDI_CONTROL_CODE( 5, METHOD_OUT_DIRECT )
#define IOCTL_TDI_RECEIVE_DATAGRAM      _TDI_CONTROL_CODE( 6, METHOD_OUT_DIRECT )
#define IOCTL_TDI_SEND                  _TDI_CONTROL_CODE( 7, METHOD_IN_DIRECT )
#define IOCTL_TDI_SEND_DATAGRAM         _TDI_CONTROL_CODE( 8, METHOD_IN_DIRECT )
#define IOCTL_TDI_SET_EVENT_HANDLER     _TDI_CONTROL_CODE( 9, METHOD_BUFFERED )
#define IOCTL_TDI_SET_INFORMATION       _TDI_CONTROL_CODE( 10, METHOD_IN_DIRECT )
#define IOCTL_TDI_ASSOCIATE_ADDRESS     _TDI_CONTROL_CODE( 11, METHOD_BUFFERED )
#define IOCTL_TDI_DISASSOCIATE_ADDRESS  _TDI_CONTROL_CODE( 12, METHOD_BUFFERED )
#define IOCTL_TDI_ACTION                _TDI_CONTROL_CODE( 13, METHOD_OUT_DIRECT )

#ifdef __cplusplus
}
#endif

#endif // ndef _NTDDTDI_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddvdeo.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ddvdeo.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Video device.

--*/

#ifndef _NTDDVDEO_
#define _NTDDVDEO_

#if _MSC_VER > 1000
#pragma once
#endif


//
// Display output interfaces
//

// DEFINE_GUID(GUID_DISPLAY_OUTPUT_INTERFACE_STANDARD,  0x96304D9F, 0x54b5, 0x11d1, 0x8b, 0x0f, 0x00, 0xa0, 0xc9, 0x06, 0x8f, 0xf3);

//
// Display adapter device interface
// 5b45201d-f2f2-4f3b-85bb-30ff1f953599
//

DEFINE_GUID(GUID_DEVINTERFACE_DISPLAY_ADAPTER, 0x5b45201d, 0xf2f2, 0x4f3b, 0x85, 0xbb, 0x30, 0xff, 0x1f, 0x95, 0x35, 0x99);

//
// Monitor device interface
// {E6F07B5F-EE97-4a90-B076-33F57BF4EAA7}
DEFINE_GUID(GUID_DEVINTERFACE_MONITOR, 0xe6f07b5f, 0xee97, 0x4a90, 0xb0, 0x76, 0x33, 0xf5, 0x7b, 0xf4, 0xea, 0xa7);


//
// Brightness power policy GUID - for use with the Device Power Policy Manager
//

DEFINE_GUID(GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS, 0xaded5e82L, 0xb909, 0x4619, 0x99, 0x49, 0xf5, 0xd7, 0x1d, 0xac, 0x0b, 0xcb);

//
// Obsolete device interface class GUID names.
// (use of above GUID_DEVINTERFACE_* names is recommended).
//

#define GUID_DISPLAY_ADAPTER_INTERFACE  GUID_DEVINTERFACE_DISPLAY_ADAPTER

//
// Interface used by anyone listening for arrival of the display device
// {1CA05180-A699-450A-9A0C-DE4FBE3DDD89}
//

DEFINE_GUID(GUID_DISPLAY_DEVICE_ARRIVAL, 0x1CA05180, 0xA699, 0x450A, 0x9A, 0x0C, 0xDE, 0x4F, 0xBE, 0x3D, 0xDD, 0x89);

//
// Interface used by anyone listening for arrival of display children
// {1AD9E4F0-F88D-4360-BAB9-4C2D55E564CD}
//

DEFINE_GUID(GUID_DEVINTERFACE_VIDEO_OUTPUT_ARRIVAL, 0x1AD9E4F0, 0xF88D, 0x4360, 0xBA, 0xB9, 0x4C, 0x2D, 0x55, 0xE5, 0x64, 0xCD);


#ifndef GUID_DEFS_ONLY

#ifdef __cplusplus
extern "C" {
#endif

#include <tvout.h>

//
// VideoIoControlFile InputBuffer/OutputBuffer record structures for
// this device.
//

//
// Name used to create the miniport logical device names
//

#define VIDEO_DEVICE_NAME "DISPLAY%d"
#define WVIDEO_DEVICE_NAME L"DISPLAY%d"


//
// Set of deprecated IOCTLs
//

#define IOCTL_VIDEO_DISABLE_VDM \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x01, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_REGISTER_VDM \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x02, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_OUTPUT_DEVICE_POWER_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x03, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_OUTPUT_DEVICE_POWER_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x04, METHOD_BUFFERED, FILE_ANY_ACCESS)

// TODO: This IOCTL was defined but never supported and needs to be removed
#define IOCTL_VIDEO_MONITOR_DEVICE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x05, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENUM_MONITOR_PDO \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x06, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_INIT_WIN32K_CALLBACKS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x07, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_IS_VGA_DEVICE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x09, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_USE_DEVICE_IN_SESSION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x0a, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_PREPARE_FOR_EARECOVERY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x0b, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// All these IOCTL's must be both handled by the port and miniport since
// they require processing by both parties.
//

#define IOCTL_VIDEO_ENABLE_VDM \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x00, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SAVE_HARDWARE_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x80, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_RESTORE_HARDWARE_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x81, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// All these IOCTL's are public and must/can be handled by the miniport
// driver
//

#define IOCTL_VIDEO_HANDLE_VIDEOPARAMETERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x08, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_AVAIL_MODES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x100, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x101, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_CURRENT_MODE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x102, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_CURRENT_MODE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x103, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_RESET_DEVICE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x104, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_LOAD_AND_SET_FONT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x105, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_PALETTE_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x106, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_COLOR_REGISTERS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x107, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_CURSOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x108, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_DISABLE_CURSOR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x109, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_CURSOR_ATTR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10a, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_CURSOR_ATTR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10b, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_CURSOR_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10c, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_CURSOR_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10d, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_ENABLE_POINTER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10e, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_DISABLE_POINTER \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x10f, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_POINTER_ATTR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x110, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_POINTER_ATTR \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x111, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_SET_POINTER_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x112, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_POINTER_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x113, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x114, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_BANK_SELECT_CODE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x115, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_MAP_VIDEO_MEMORY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x116, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNMAP_VIDEO_MEMORY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x117, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x118, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x119, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11a, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// New IOCTLs defined for product 1.0A
//

#define IOCTL_VIDEO_SET_POWER_MANAGEMENT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11b, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_GET_POWER_MANAGEMENT \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11c, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SHARE_VIDEO_MEMORY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11d, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11e, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_COLOR_LUT_DATA \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x11f, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_GET_CHILD_STATE \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x120, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_VALIDATE_CHILD_STATE_CONFIGURATION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x121, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_CHILD_STATE_CONFIGURATION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x122, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SWITCH_DUALVIEW \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x123, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_BANK_POSITION \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x124, METHOD_BUFFERED, FILE_ANY_ACCESS)


//
// New monitor control IOCTLs defined for XPSP1, left for backwards compatibilty in Longhorn, and to be retired in Blackcomb
//

// WARNING: New code should use the new WMI interface, old code needs to be updated to use WMI interfaces by Blackcomb

#define IOCTL_VIDEO_QUERY_SUPPORTED_BRIGHTNESS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x125, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_QUERY_DISPLAY_BRIGHTNESS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x126, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_VIDEO_SET_DISPLAY_BRIGHTNESS \
    CTL_CODE(FILE_DEVICE_VIDEO, 0x127, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// All these IOCTL's are handled by the Far East Full Screen Video driver
//

#define IOCTL_FSVIDEO_COPY_FRAME_BUFFER \
    CTL_CODE(FILE_DEVICE_FULLSCREEN_VIDEO, 0x200, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_FSVIDEO_WRITE_TO_FRAME_BUFFER \
    CTL_CODE(FILE_DEVICE_FULLSCREEN_VIDEO, 0x201, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_FSVIDEO_REVERSE_MOUSE_POINTER \
    CTL_CODE(FILE_DEVICE_FULLSCREEN_VIDEO, 0x202, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_FSVIDEO_SET_CURRENT_MODE \
    CTL_CODE(FILE_DEVICE_FULLSCREEN_VIDEO, 0x203, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_FSVIDEO_SET_SCREEN_INFORMATION \
    CTL_CODE(FILE_DEVICE_FULLSCREEN_VIDEO, 0x204, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_FSVIDEO_SET_CURSOR_POSITION \
    CTL_CODE(FILE_DEVICE_FULLSCREEN_VIDEO, 0x205, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// Many of the video IOCTLs are modal. When ever the palette is set, or the
// cursor is set or queried, it is done for the current mode.
//
// Modal specifies that the operation is only valid within a mode. Once a
// set mode operation is performed, the state associated to the modal IOCTL
// has been destroyed or reinitialized.
// Non-modal IOCTLs have their state preserved across set-mode operations.
//
// Optional IOCTLs are IOCTLs the miniport can optionally support. If the
// miniport does not support the IOCTL, it should return the appropriate
// error status.
// Required IOCTLs must be implemented in a miniport in order for the system
// to system properly.
//
// IOCTL_VIDEO_ENABLE_VDM                       Non-Modal    Private(1)
// IOCTL_VIDEO_DISABLE_VDM                      Non-Modal    Private(1)
// IOCTL_VIDEO_REGISTER_VDM                     Non-Modal    Private(1)
//
// IOCTL_VIDEO_SAVE_HARDWARE_STATE              Non-Modal    Required(2)
// IOCTL_VIDEO_RESTORE_HARDWARE_STATE           Non-Modal    Required(2)
//
// IOCTL_VIDEO_QUERY_AVAIL_MODES                Non-Modal    Required
// IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES            Non-Modal    Required
// IOCTL_VIDEO_QUERY_CURRENT_MODE               Modal        Required
// IOCTL_VIDEO_SET_CURRENT_MODE                 Non-Modal    Required
// IOCTL_VIDEO_RESET_DEVICE                     Non-Modal    Required
//
// IOCTL_VIDEO_LOAD_AND_SET_FONT                Modal        Required(2)
//
// IOCTL_VIDEO_SET_PALETTE_REGISTERS            Modal        Required(2)
// IOCTL_VIDEO_SET_COLOR_REGISTERS              Modal        Required(3)
//
// IOCTL_VIDEO_ENABLE_CURSOR                    Modal        Required(2)
// IOCTL_VIDEO_DISABLE_CURSOR                   Modal        Required(2)
// IOCTL_VIDEO_SET_CURSOR_ATTR                  Modal        Required(2)
// IOCTL_VIDEO_QUERY_CURSOR_ATTR                Modal        Required(2)
// IOCTL_VIDEO_SET_CURSOR_POSITION              Modal        Required(2)
// IOCTL_VIDEO_QUERY_CURSOR_POSITION            Modal        Required(2)
//
// IOCTL_VIDEO_ENABLE_POINTER                   Modal        Optional
// IOCTL_VIDEO_DISABLE_POINTER                  Modal        Optional
// IOCTL_VIDEO_SET_POINTER_ATTR                 Modal        Optional
// IOCTL_VIDEO_QUERY_POINTER_ATTR               Modal        Optional
// IOCTL_VIDEO_SET_POINTER_POSITION             Modal        Optional
// IOCTL_VIDEO_QUERY_POINTER_POSITION           Modal        Optional
// IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES       Non-Modal    Optional
//
// IOCTL_VIDEO_GET_BANK_SELECT_CODE             Modal        Required(2)
//
// IOCTL_VIDEO_MAP_VIDEO_MEMORY                 Special(4)   Required
// IOCTL_VIDEO_UNMAP_VIDEO_MEMORY               Non-Modal    Required
// IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES       Non-Modal    Optional
// IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES        Non-Modal    Optional
//
// IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES         Non-Modal    Optional
//
// IOCTL_VIDEO_SET_POWER_MANAGEMENT             Non-Modal    Optional
// IOCTL_VIDEO_GET_POWER_MANAGEMENT             Non-Modal    Optional
//
// IOCTL_VIDEO_SET_COLOR_LUT_DATA               Modal        Optional

//
// (1) Private means the IOCTL is completely implemeted within the port driver
//     and the miniport does not need to support it.
//
// (2) These Required functions are for "Vga Compatible" miniports. They are
//     Optional for other, non vga-compatible (i.e frame buffers) drivers.
//     VGA compatible means here that the miniport implements all the VGA
//     functionality and that the VgaCompatible flag for the miniport in the
//     registry parameters is turned on.
//
// (3) This IOCTL is required if the device has a color lookup table (also
//     commonly called palette) the PALETTE IOCTL is used for VGA while the
//     COLOR IOCTL is the more general IOCTL that is called by the display
//     driver or application to set the colors in the devices internal
//     lookup table
//
// (4) This IOCTL is both modal and non-modal. It should map all of video
//     memory in the caller's address space. A set mode MUST NOT cause the
//     video memory to change location - in this sense it is non-modal.
//     However, this IOCTL returns the location size of the frame buffer within
//     video memory, and the frame buffer size and location may vary from mode
//     to mode - so that information is modal.
//


//
// Any IOCTL that returns information should return in the status block the
// size of the data returned.
// If the output buffer was too small, an error should be returned.
//
//
//
//



//
// IOCTL_VIDEO_ENABLE_VDM
// IOCTL_VIDEO_DISABLE_VDM
// IOCTL_VIDEO_REGISTER_VDM
//
// These IOCTLs are used to enable or disable a VDM's access to the video
// hardware. This call will cause the real video frame buffer to be mapped
// into the VDM's address space and get the video validator connected to the
// V86 emulator for direct video register access.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_VDM {
    HANDLE ProcessHandle;
} VIDEO_VDM, *PVIDEO_VDM;

//
//ProcessHandle - Handle to the process for which this request must be
//    performed. This is required because the console calls the miniport on
//    the behalf of the VDM process; we are not performing this request in
//    the context of the current caller.
//


typedef struct _VIDEO_REGISTER_VDM {
    ULONG MinimumStateSize;
} VIDEO_REGISTER_VDM, *PVIDEO_REGISTER_VDM;

//
//MinimumStateSize - Output value determining the minimum size required to
//    store the video hardware state when performing SAVE_HARDWARE_SATE or
//    RESTORE_HARDWARE_STATE Ioctls.
//


//
// IOCTL_VIDEO_ENUM_MONITOR_PDO
//
// Basic descriptor of monitor devices
//

typedef struct tagVIDEO_MONITOR_DEVICE {
    ULONG   flag;       // The monitor is ON/OFF
    HANDLE  pdo;        // Monitor device handle
    ULONG   HwID;
} VIDEO_MONITOR_DEVICE, *PVIDEO_MONITOR_DEVICE;


//
// IOCTL_VIDEO_GET_MONITOR_DESCRIPTOR
//
// Detailed descriptor of monitor devices
//

typedef struct tagVIDEO_MONITOR_DESCRIPTOR {
    ULONG   DescriptorSize;  // Size of the Descriptor
    UCHAR   Descriptor[1];   // Start of descriptor data (actual size is determined by DescriptorSize)
} VIDEO_MONITOR_DESCRIPTOR, *PVIDEO_MONITOR_DESCRIPTOR;


//

//
// IOCTL_VIDEO_INIT_WIN32K_CALLBACKS
//
// List of function pointers used to make callbacks to win32k
//

typedef enum _VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE {
    VideoPowerNotifyCallout = 1,
    VideoDisplaySwitchCallout,
    VideoEnumChildPdoNotifyCallout,
    VideoFindAdapterCallout,
    VideoWakeupCallout,
    VideoChangeDisplaySettingsCallout,
    VideoPnpNotifyCallout,
    VideoDxgkDisplaySwitchCallout
} VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE;

#define DXGK_WIN32K_PARAM_FLAG_UPDATEREGISTRY 1         // Saves the mode switch information into the registry.
#define DXGK_WIN32K_PARAM_FLAG_MODESWITCH 2             // Performs the mode switch.
#define DXGK_WIN32K_PARAM_FLAG_DISABLEVIEW 4            // Disables the view which we're interested in.

//
// Extra information for DxgkVideoPortCallout
// implementation
//
typedef struct _DXGK_WIN32K_PARAM_DATA
{
    PVOID  PhysicalDeviceObject;
    PVOID  DisplayMode;
    ULONG  Flags;
} DXGK_WIN32K_PARAM_DATA, *PDXGK_WIN32K_PARAM_DATA;

typedef struct _VIDEO_WIN32K_CALLBACKS_PARAMS {
    VIDEO_WIN32K_CALLBACKS_PARAMS_TYPE CalloutType;
    PVOID   PhysDisp;
    ULONG_PTR Param;
    LONG    Status;
} VIDEO_WIN32K_CALLBACKS_PARAMS, *PVIDEO_WIN32K_CALLBACKS_PARAMS;

typedef
VOID
(*PVIDEO_WIN32K_CALLOUT) (
    IN PVOID Params
    );


typedef struct _VIDEO_WIN32K_CALLBACKS {
    IN  PVOID                  PhysDisp;
    IN  PVIDEO_WIN32K_CALLOUT  Callout;
    OUT ULONG                  bACPI;
    OUT HANDLE                 pPhysDeviceObject;
    OUT ULONG                  DualviewFlags;
} VIDEO_WIN32K_CALLBACKS, *PVIDEO_WIN32K_CALLBACKS;

//
// defines for Dualview Flags
//

#define VIDEO_DUALVIEW_REMOVABLE           0x00000001
#define VIDEO_DUALVIEW_PRIMARY             0x80000000
#define VIDEO_DUALVIEW_SECONDARY           0x40000000

// Used by WDDM infrastructure to determine whether a device is the VGA one or not.
#define VIDEO_DUALVIEW_WDDM_VGA            0x20000000

//
// IOCTL_VIDEO_USE_DEVICE_IN_SESSION
//
// Parameters to request new enabled/disabled state for a device
//

typedef struct _VIDEO_DEVICE_SESSION_STATUS {
    ULONG   bEnable;    // Is device being enabled or disabled
    ULONG   bSuccess;   // Was request validated
} VIDEO_DEVICE_SESSION_STATUS, *PVIDEO_DEVICE_SESSION_STATUS;


//
// defines for child state flag
//

#define VIDEO_CHILD_ACTIVE                 0x00000001
#define VIDEO_CHILD_DETACHED               0x00000002
#define VIDEO_CHILD_NOPRUNE_FREQ           0x80000000
#define VIDEO_CHILD_NOPRUNE_RESOLUTION     0x40000000


//
// Second set of structures
//

//
// These IOCTLs are used by the VDM and the console to communicate state
// changes between the VDM and the kernel video driver.
//
// IOCTL_VIDEO_SAVE_HARDWARE_STATE -
// IOCTL_VIDEO_RESTORE_HARDWARE_STATE -
//
//
// This structure is at the start of the block used when saving or restoring
// the state of the video hardware using ConsoleHardwareState().
// the ULONG are offset to the location of the rest of the data. That data
// is stored within the same memory block pointed to by the
// VIDEO_HARDWARE_STATE structure, right after this header.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_HARDWARE_STATE_HEADER {
    ULONG Length;
    UCHAR PortValue[0x30];
    ULONG AttribIndexDataState;
    ULONG BasicSequencerOffset;
    ULONG BasicCrtContOffset;
    ULONG BasicGraphContOffset;
    ULONG BasicAttribContOffset;
    ULONG BasicDacOffset;
    ULONG BasicLatchesOffset;
    ULONG ExtendedSequencerOffset;
    ULONG ExtendedCrtContOffset;
    ULONG ExtendedGraphContOffset;
    ULONG ExtendedAttribContOffset;
    ULONG ExtendedDacOffset;
    ULONG ExtendedValidatorStateOffset;
    ULONG ExtendedMiscDataOffset;
    ULONG PlaneLength;
    ULONG Plane1Offset;
    ULONG Plane2Offset;
    ULONG Plane3Offset;
    ULONG Plane4Offset;
    ULONG VGAStateFlags;
    ULONG DIBOffset;
    ULONG DIBBitsPerPixel;
    ULONG DIBXResolution;
    ULONG DIBYResolution;
    ULONG DIBXlatOffset;
    ULONG DIBXlatLength;
    ULONG VesaInfoOffset;
    PVOID FrameBufferData;

} VIDEO_HARDWARE_STATE_HEADER, *PVIDEO_HARDWARE_STATE_HEADER;

//
// defines for VGAStateFlags
//

#define VIDEO_STATE_NON_STANDARD_VGA       0x00000001
#define VIDEO_STATE_UNEMULATED_VGA_STATE   0x00000002
#define VIDEO_STATE_PACKED_CHAIN4_MODE     0x00000004

typedef struct _VIDEO_HARDWARE_STATE {
    PVIDEO_HARDWARE_STATE_HEADER StateHeader;
    ULONG StateLength;
} VIDEO_HARDWARE_STATE, *PVIDEO_HARDWARE_STATE;

//
//Length - Length of the basic structure. Used for versioning purposes. The
//    length field should be initialized to be equal to
//    sizeof(VIDEO_HARDWARE_STATE_HEADER).
//
//PortValue - Array of entries containing the data values for port 3B0 through
//    3DF.
//
//AttribIndexDataState - State of the attribute index register.
//
//BasicSequencerOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    sequencer register set of the VGA.
//
//BasicCrtContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    CRT register set of the VGA.
//
//BasicGraphContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    graphics controller register set of the VGA.
//
//BasicAttribContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    attribute controller register set of the VGA.
//
//BasicDacOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    DAC registers of the VGA.
//
//BasicLatchesOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the register values for the basic
//    latches of the VGA.
//
//ExtendedSequencerOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    sequencer register set of the VGA.
//
//ExtendedCrtContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    CRT register set of the VGA.
//
//ExtendedGraphContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    graphics controller register set of the VGA.
//
//ExtendedAttribContOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    attribute controller register set of the VGA.
//
//ExtendedDacOffset - Offset, in bytes, from the beginning of the structure,
//    to an array of fields containing the registers values for the extended
//    DAC registers of the VGA.
//
//ExtendedValidatorStateOffset - Offset, in bytes, from the beginning of the
//    structure, to an area reserved for the miniport to put the unemulated
//    save state that the miniport uses to perform instruction validation for
//    DOS apps.
//
//ExtendedMiscDataOffset - Offset, in bytes, from the beginning of the structure,
//    to an area reserved for the use of the miniport.
//
//PlaneLength - Length of each of the following plane (if present)
//
//Plane1Offset - Offset, in bytes, from the beginning of the structure, to an
//    array of fields containing the data of the first plane of video memory.
//
//Plane2Offset - Offset, in bytes, from the beginning of the structure, to an
//    array of fields containing the data of the second plane of video memory.
//
//Plane3Offset - Offset, in bytes, from the beginning of the structure, to an
//    array of fields containing the data of the third plane of video memory.
//
//Plane4Offset - Offset, in bytes, from the beginning of the structure, to an
//    array of fields containing the data of the fourth plane of video memory.
//
//VGAStateFlags - Flags used for the interpretation of the VGA state.
//    VIDEO_STATE_NON_STANDARD_VGA is set when the set of registers the VGA
//        returns is not the basic set (all super vga's are not standard).
//        The VDM should not emulate the saved state unless a specific VDD
//        has been written for the device.
//    VIDEO_STATE_UNEMULATED_VGA_STATE specified the miniport has stored
//        informaiton in the ExtendedValidatorState field and the miniport
//        should treat this as a frozen state, whatever the registers say.
//    VIDEO_STATE_PACKED_CHAIN4_MODE indicates that in mode 13 (320x200x256).
//        the data is stored in a packed pixel format in the plane, as
//        opposed to the standard VGA format where the data is interleaved
//        at every four bytes, and on every 16K boundary, offset by one
//        extra byte.
//
//DIBOffset - Offset to the location of the DIB in the allocated data
//        structure. If NULL, no translation is available.
//
//DIBBitsPerPixel - Format of the DIB.
//
//DIBXResolution - Width of the DIB in pixels.
//
//DIBYResolution - Height of the DIB in pixels.
//
//DIBXlatOffset - Offset to the location of the translation vector
//    from DIB pixel values to 32-bit RGB (1 byte red, 1 byte green, 1 byte
//    blue, 1 byte empty). Maximum length 256. If NULL, the standard
//    VGA palette stored in this structure should be used.
//
//DIBXlatLength - Length of the RGB translation vector at DIBXlatOffset.
//
// For each of the offset fields, if an offset value is NULL, then there is
// no data for that offset.
// The length of a data area is:
//   1) the specific length given to it : plane length (planes) or XResolution *
//        Yresolution * BitsPerPel (DIB)
//   2) otherwise, the length = next_non-null_offset_value -
//                                   current_offset_value
//

//
//StateHeader - Pointer to the VIDEO_HARDWARE_STATE_HEADER structure.
//
//StateLength - Size of the VIDEO_HARDWARE_STATE_HEADER structure.
//

//
// IOCTL_VIDEO_QUERY_NUM_AVAIL_MODES - Returns number of different modes
//                                     available on the controller.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_NUM_MODES {
    ULONG NumModes;
    ULONG ModeInformationLength;
} VIDEO_NUM_MODES, *PVIDEO_NUM_MODES;

//
//NumModes - Returns the number of modes supported by the kernel driver.
//
//ModeInformationLength - Length of the VIDEO_MODE_INFORMATION structure
//    for the IOCTL_VIDEO QUERY_AVAILABLE_MODES IOCTL.


//
// IOCTL_VIDEO_SET_CURRENT_MODE - Is used to set the mode of the controller.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_MODE {
    ULONG RequestedMode;
} VIDEO_MODE, *PVIDEO_MODE;

#define VIDEO_MODE_NO_ZERO_MEMORY 0x80000000 // High order bit of the mode
                                             // determines if the set mode
                                             // should (0) or should not (1)
                                             // cause the video memory to be
                                             // zeroed out simultaneously to
                                             // the set mode operation.

#define VIDEO_MODE_MAP_MEM_LINEAR 0x40000000 // Miniports which support this
                                             // flag will set a linear mode
                                             // if possible when this flag
                                             // is set.  Note: Some miniports
                                             // may return a linear mode even
                                             // if this flag is not set.


//
//RequestedMode - Indicates in which mode the adapter should be initialized.
//


//
// IOCTL_VIDEO_RESET_DEVICE - Is used to reset the mode of the adapter when GDI
//                            gives up control of the device to allow a VDM to
//                            access the hardware. x86 only.
//                            The default mode should be whatever is the
//                            default mode when the machine is booted
//
// No information is needed fo this function.
//



//
// IOCTL_VIDEO_QUERY_AVAIL_MODES - Returns information about each available
//                                 mode on the controller.
//
// IOCTL_VIDEO_QUERY_CURRENT_MODE - Returns the information for the current
//                                  controller mode.
//
// Information used by this function is passed using the following structure:
//
// NOTE This structure is matched exactly with the DISP_MODE structure
// in winddi.h - every change to this structure MUST be made to the
// structure in winddi.h.
//

typedef struct _VIDEO_MODE_INFORMATION {
    ULONG Length;
    ULONG ModeIndex;
    ULONG VisScreenWidth;
    ULONG VisScreenHeight;
    ULONG ScreenStride;
    ULONG NumberOfPlanes;
    ULONG BitsPerPlane;
    ULONG Frequency;
    ULONG XMillimeter;
    ULONG YMillimeter;
    ULONG NumberRedBits;
    ULONG NumberGreenBits;
    ULONG NumberBlueBits;
    ULONG RedMask;
    ULONG GreenMask;
    ULONG BlueMask;
    ULONG AttributeFlags;
    ULONG VideoMemoryBitmapWidth;
    ULONG VideoMemoryBitmapHeight;
    ULONG DriverSpecificAttributeFlags;
} VIDEO_MODE_INFORMATION, *PVIDEO_MODE_INFORMATION;

//
// Bit definitions for Attribute Flags
//

#define VIDEO_MODE_COLOR            0x0001  // 0 = Mono-compatible, 1 = Color
#define VIDEO_MODE_GRAPHICS         0x0002  // 0 = Text mode, 1 = Graphics
#define VIDEO_MODE_PALETTE_DRIVEN   0x0004  // 0 = Colors are direct
                                            // 1 = Colors are index to a palette
#define VIDEO_MODE_MANAGED_PALETTE  0x0008  // 0 = Palette is fixed (must be
                                            //     queried from miniport
                                            // 1 = Palette is settable.
#define VIDEO_MODE_INTERLACED       0x0010  // 1 = Mode is interlaced
                                            // 0 = non-interlaced
#define VIDEO_MODE_NO_OFF_SCREEN    0x0020  // 1 = Offscreen memory CAN NOT be
                                            //     used to store information.
                                            // 0 = Offscreen memory is available
#define VIDEO_MODE_NO_64_BIT_ACCESS 0x0040  // 1 = 64 bit memory writes to frame
                                            //     buffer are not handled properly.
                                            // 0 = 64 bit memory writes to frame
                                            //     buffer are handled properly.
#define VIDEO_MODE_BANKED           0x0080  // 0 = undefined
                                            // 1 = this is a banked mode
#define VIDEO_MODE_LINEAR           0x0100  // 0 = undefined
                                            // 1 = this is a linear mode

//
//Length - Length of the structure in bytes. Also used to do verisioning.
//
//ModeIndex - Number used to set this mode when calling the miniport driver.
//
//VisScreenWidth - Number of visible horizontal pixels on a scan line
//
//VisScreenHeight - Number of visible lines (or scan lines)
//
//ScreenStride - Delta, in *BYTES*, between the start of two scan lines.
//
//    NOTE: the width and height are in pixels, but the stride is in bytes !!!
//
//NumberOfPlanes - Number of separate planes combined by the device.
//
//BitsPerPlane - Number of bits per pixel on a plane.
//
//Frequency - Screen Frequency, in Hertz.
//
//XMillimeter - Size of the horizontal active region on the output device,
//    in millimeters.
//
//YMillimeter - Size of the vertical active region on the output device,
//    in millimeters.
//
//NumberRedBits - Number of bits in the red DAC.
//
//NumberGreenBits - Number of bits in the green DAC.
//
//NumberBlueBits - Number of bits in the blue DAC.
//
//RedMask - Red color Mask for device with direct color modes. Bits turned
//    on indicate the bit is of color Red.
//
//GreenMask - Green color Mask for device with direct color modes. Bits
//    turned on indicate the bit is of color Green.
//
//BlueMask - Blue color Mask for device with direct color modes. Bits
//    turned on indicate the bit is of color Blue.
//
//AttributeFlags. Flags indicating certain behavior for the device.
//
//VideoMemoryBitmapWidth - Width of the video memory bitmap.
//    VisScreenWidth <= VideoMemoryBitmapWidth <= ScreenStride
//
//VideoMemoryBitmapHeight - Height of the video memory bitmap.
//   VisScreenHeight <= VideoMemoryBitmapHeight = VideoRamLength / ScreenStride
//
//DriverSpecificAttributeFlags - Flags indicating certain behavior for the
//   device that are private to the miniport\display driver.
//


//
// IOCTL_VIDEO_LOAD_AND_SET_FONT - Is used to load a user-defined font.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_LOAD_FONT_INFORMATION {
    USHORT WidthInPixels;
    USHORT HeightInPixels;
    ULONG FontSize;
    UCHAR Font[1];
} VIDEO_LOAD_FONT_INFORMATION, *PVIDEO_LOAD_FONT_INFORMATION;

//
//WidthInPixels - Width of the characters in the font, in pixels.
//
//HeigthInPixels - Heigth of the characters in the font, in pixels.
//
//FontSize - Size of the font buffer being passed in, in bytes.
//
//Font - Start of the font buffer.
//


//
// IOCTL_VIDEO_SET_PALETTE_REGISTERS - Takes buffer containing
//                                     VIDEO_PALETTE_DATA where Colors[]
//                                     specifies the array containing the
//                                     color values for the palette registers.
//
// Information used by this function is passed using the following structure:
//
// NOTE: This should only be used by the VGA type drivers
//

typedef struct _VIDEO_PALETTE_DATA {
    USHORT NumEntries;
    USHORT FirstEntry;
    USHORT Colors[1];
} VIDEO_PALETTE_DATA, *PVIDEO_PALETTE_DATA;

//
//NumEntries - Number of entries in the array of color values.
//
//FirstEntry - Location in the device palette to which the first entry in the
//    list of colors should be copied to. The other entries in the color list
//    should be copied sequentially, from this starting point into the device's
//    palette.
//
//Colors - Array of color entries to copy into the device's color palette.
//

//
// IOCTL_VIDEO_SET_COLOR_REGISTERS - Takes buffer containing VIDEO_CLUT.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_CLUTDATA {
    UCHAR Red;
    UCHAR Green;
    UCHAR Blue;
    UCHAR Unused;
} VIDEO_CLUTDATA, *PVIDEO_CLUTDATA;

//
//Red - Bits to be put in the Red portion of the color registers.
//
//Green - Bits to be put in the Green portion of the color registers.
//
//Blue - Bits to be put in the Blue portion of the color registers.
//

typedef struct {
    USHORT   NumEntries;
    USHORT   FirstEntry;
    union {
        VIDEO_CLUTDATA RgbArray;
        ULONG RgbLong;
    } LookupTable[1];
} VIDEO_CLUT, *PVIDEO_CLUT;

//
//NumEntries - Number of entries in the LookupTable of color values.
//
//FirstEntry - Location in the device palette to which the first entry in the
//    LookupTable of colors should be copied to. The other entries in the
//    LookupTable should be copied sequentially, from this starting point into
//    the device's palette.
//
//LookupTable - Array of color entries to copy into the device's color
//    registers/palette. The color entries can be accessed as a genric 32 bit
//    value or as Red/Green/Blue/Unused fields.
//

//
// NOTE: Cursor vs. Pointer:
//    A cursor is a rectangular set of pixels which are used to indicate the
//    location of input coming from the keyboard.
//
//    A pointer is the set of pixels that are used to paint the shape
//    associated with the mouse.
//

//
// IOCTL_VIDEO_QUERY_CURSOR_POSITION - Returns the location of the cursor on
//                                     the screen.
//
// IOCTL_VIDEO_SET_CURSOR_POSITION - Is used to set the location of the
//                                   cursor on the screen.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_CURSOR_POSITION {
    SHORT Column;
    SHORT Row;
} VIDEO_CURSOR_POSITION, *PVIDEO_CURSOR_POSITION;

//
//Column - Column on which the cursor is located from the top left, in pixels.
//
//Row - Row on which the cusor is located from the top left, in pixels.
//


//
// IOCTL_VIDEO_QUERY_CURSOR_ATTR - Returns all attributes of the cursor.
//
// IOCTL_VIDEO_SET_CURSOR_ATTR - Is used to set the attributes of the cursor.
//
// Information used by this function is passed using the following structure:
//

//
// For the VGA:
// TopScanLine will be stored in the height when an IOCTL is made
// BottomScanLine will be stored in the width when an IOCTL is made
//

typedef struct _VIDEO_CURSOR_ATTRIBUTES {
    USHORT Width;
    USHORT Height;
    SHORT Column;
    SHORT Row;
    UCHAR Rate;
    UCHAR Enable;
} VIDEO_CURSOR_ATTRIBUTES, *PVIDEO_CURSOR_ATTRIBUTES;

//
//Width - Width of the cursor, in pixels.
//
//Height - Height of the cursor, in scans.
//
//Column - Column on which the cursor is located from the top left, in pixels.
//
//Row - Row on which the cusor is located from the top left, in pixels.
//
//Rate - Rate at which the cursor whould flash.
//
//Enable - Non-zero to display cursor, 0 not to display.
//

//
// IOCTL_VIDEO_QUERY_POINTER_POSITION - Returns the location of the pointer
//                                      on the screen
//
// IOCTL_VIDEO_SET_POINTER_POSITION - Is used to set the location of the
//                                    pointer on the screen.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_POINTER_POSITION {
    SHORT Column;
    SHORT Row;
} VIDEO_POINTER_POSITION, *PVIDEO_POINTER_POSITION;

//
//Column - Column on which the cursor is located from the top left, in pixels.
//
//Row - Row on which the cusor is located from the top left, in pixels.
//


//
// IOCTL_VIDEO_QUERY_POINTER_ATTR - Returns all attributes of the pointer.
//
// IOCTL_VIDEO_SET_POINTER_ATTR - Is used to set the attributes of the
//                                pointer.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_POINTER_ATTRIBUTES {
    ULONG Flags;
    ULONG Width;
    ULONG Height;
    ULONG WidthInBytes;
    ULONG Enable;
    SHORT Column;
    SHORT Row;
    UCHAR Pixels[1];
} VIDEO_POINTER_ATTRIBUTES, *PVIDEO_POINTER_ATTRIBUTES;

//
//Flags - color or mono pointer, same as for query pointer capabilities.
//
//Width - Width of the pointer, in pixels.
//
//Height - Height of the pointer, in scans.
//
//WidthInBytes - Width of the pointer, in bytes.
//
//Enable - Non-zero to display pointer, 0 not to display.
//
//Column - Column on which the cursor is located from the top left, in pixels.
//
//Row - Row on which the cusor is located from the top left, in pixels.
//
//Pixels - Start of pointer data, in device-compatible DIB format.
//    (Mask data is always in 1-bpp DIB format.)
//


//
// IOCTL_VIDEO_QUERY_POINTER_CAPABILITIES - Returns capabilities of miniport
//                                          hardware cursor
//

typedef struct _VIDEO_POINTER_CAPABILITIES {
    ULONG Flags;
    ULONG MaxWidth;
    ULONG MaxHeight;
    ULONG HWPtrBitmapStart;
    ULONG HWPtrBitmapEnd;
} VIDEO_POINTER_CAPABILITIES, *PVIDEO_POINTER_CAPABILITIES;

//
// Flag bit definitions
//

#define VIDEO_MODE_ASYNC_POINTER  0x01 // 1 if the cursor can be updated
                                       // asynchronously to drawing operations.
#define VIDEO_MODE_MONO_POINTER   0x02 // 1 if a monochrome hardware pointer
                                       // is supported.
#define VIDEO_MODE_COLOR_POINTER  0x04 // 1 if a color hardware pointer is
                                       // supported.
#define VIDEO_MODE_ANIMATE_START  0x08 // The pointer being passed down has
#define VIDEO_MODE_ANIMATE_UPDATE 0x10 // the same hotspot as the previous
                                       // pointer
//
//MaxWidth - Widest pointer bitmap the miniport should be requested to load
//    for either monochrome or color pointer.
//
//MaxHeight - widest pointer bitmap the miniport should be requested to load
//    for either monochrome color pointer handled.
//
//HWPtrBitmapStart = first offset in bitmap of memory used to store hardware
//    pointer bitmap, in CPU-addressable units (-1 if not applicable). For
//    planar modes (like VGA mode 12h), this is a planar offset; for linear
//    modes (like VGA mode 13h), this is a linear offset. The CPU-addressable
//    translation in HC planar mode is assumed to be linearaddress/4,
//    because there are four planes at each address.
//
//HWPtrBitmapEnd = last offset in bitmap of memory used to store hardware
//    pointer bitmap (-1 if not applicable).
//
// Note: Miniport has options to reject any call to set a pointer.
//


//
// IOCTL_VIDEO_GET_BANK_SELECT_CODE - Called by the Windows display driver
//                                    to get a block of executable code used
//                                    to perform bank-switching in high
//                                    resolution SVGA drivers.
//
// Gets information needed to implement banking control for a selected mode.
//
// Information used by this function is passed using the following structures:
//

//
// The input from the caller in the input buffer is a VIDEO_MODE structure, as
// described under IOCTL_VIDEO_SET_CURRENT_MODE.
//
// RequestedMode - mode index for which banking information is desired.
//

//
// Returned in output buffer.
//

typedef struct _VIDEO_BANK_SELECT {
    ULONG Length;
    ULONG Size;
    ULONG BankingFlags;
    ULONG BankingType;
    ULONG PlanarHCBankingType;
    ULONG BitmapWidthInBytes;
    ULONG BitmapSize;
    ULONG Granularity;
    ULONG PlanarHCGranularity;
    ULONG CodeOffset;
    ULONG PlanarHCBankCodeOffset;
    ULONG PlanarHCEnableCodeOffset;
    ULONG PlanarHCDisableCodeOffset;
} VIDEO_BANK_SELECT, *PVIDEO_BANK_SELECT;

//
// Stored in the BankType and PlanarHCBankintType fields
//

typedef enum _VIDEO_BANK_TYPE {
    VideoNotBanked = 0,
    VideoBanked1RW,
    VideoBanked1R1W,
    VideoBanked2RW,
    NumVideoBankTypes
} VIDEO_BANK_TYPE, *PVIDEO_BANK_TYPE;

//
// Defines for BankingFlags.
//

#define PLANAR_HC               0x00000001

//
//Note: planar high-color ("planar HC") mode is a special 8-bpp-and-up
//    CPU addressing mode in which four bytes can be accessed at
//    once by using the VGA's planar hardware.  This mode is enabled
//    by turning off the Chain4 bit (bit 3 in Sequence Controller
//    register 4), so it is also known as non-Chain4 mode.  Planar HC
//    mode can greatly accelerate operations such as solid fills,
//    some pattern fills, and some blits.
//
//Note: the term "CPU-addressable bytes" means offsets measured
//    in bytes as accessed by the CPU.  In 16-color modes, this
//    merely means "measured in bytes" rather than "measured in
//    pixels," where each byte contains 8 pixels, as usual.
//    In normal high-color modes, "CPU-addressable bytes"
//    is exactly what you'd expect; it's the number of pixels in 256
//    color modes, pixels*2 in 16-bpp modes, and so on.  However, in
//    planar HC modes, there are four display memory bytes at every CPU-
//    addressable byte, because four planes are at each address, so
//    in 256 color modes the number of CPU-addressable bytes is
//    pixels/4, in 16-bpp modes CPU-addressable bytes = pixels/2, and
//    so on.  Basically, "CPU-addressable bytes" just means the
//    offsets the CPU needs to address banks properly in the
//    specified mode.
//
//Note: the start address must be set to 0 (displayed pixels must
//    start at offset 0 in display memory), and the banking windows
//    must fit within the 64K area starting at A000:0; no 128K
//    mappings, please, because there may be a monochrome adapter
//    in the system.
//
//Length - Length of the basic structure. Used for versioning by checking the
//    Length of the struct is at least as large as the value given by sizeof().
//
//Size - number of bytes required to hold all banking information for
//    this mode, including the VIDEO_BANK_SELECT structure and all
//    bank-switch code.  This is the size of the buffer that
//    VgaGetBankSelectCode requires in order properly to return info.
//
//BankingFlags - indicate the type of banking supported in this mode.
//    PLANAR_HC - if set, indicates that planar high-color (HC) mode
//          (non-Chain4 8-, 15-, 16-, 24-, and 32-bpp) is supported.
//          If this bit is set, the following fields must be filled in:
//              PlanarHCGranularity, pPlanarHCBankCode,
//              pPlanarHCEnableCode, pPlanarHCDisableCode.
//          This bit is ignored by the 16-color driver, as are the
//          associated fields.
//
//BankingType - These are the banking types supported by the adapter
//    when it is ina standard mode.
//
//    VideoNotBanked - this mode does not support or require banking.
//    VideoBanked1RW - this mode supports a single RW (readable and
//        writable) banking window.  The window is assumed to be
//        64K in size.
//    VideoBanked1R1W - this mode supports a single window, but the
//        window can be mapped to different areas of display memory
//        for reads and for writes.  The window is assumed to be
//        64K in size.
//    VideoBanked2RW - this mode supports two independently mappable
//        banking windows, each RW.  Each window is assumed to be
//        32K in size.  The second window is assumed
//        to start immediately after the end of the first, at
//        A000:8000.
//
//PlanarHCBankingType - These are the banking types supported by the
//    adapter when it is in a PLANAR HC mode.
//
//    See BankingType for defintions of each banking type.
//
//
//BitmapWidthInBytes - distance from start of one scan line to start
//    of next, counted in CPU-addressable bytes (not pixels).  The
//    CPU-addressable distance from one scan line to the next is
//    assumed to be BitmapWidthInBytes/4 in planar HC modes, because
//    there are four planes at each address.
//
//BitmapSize - size of display memory in CPU-addressable bytes (for
//    example, 256K on a 1 Mb SVGA in 16-color mode, because there
//    are four bytes at each address).  The CPU-addressable bitmap
//    size is assumed to be BitmapSize/4 in planar HC modes, because
//    there are four planes at each address.
//
//Granularity - granularity with which display memory may be mapped
//    into a banking window.  (That is, resolution with which the
//    display memory address mapped to the start of a window may be
//    set; anywhere from 1K to 64K, depending on the adapter.  If
//    Granularity < window size (either 64K or 32K), then adjacent
//    banks can overlap, and broken rasters can always be avoided.
//    If Granularity == window size, then banks are disjoint, and
//    display memory is basically segmented into banks.)  Granularity
//    is measured in CPU-addressable bytes.
//
//PlanarHCGranularity - granularity with which display memory may be
//    mapped into a banking window in planar HC mode.
//    PlanarHCGranularity is measured in CPU-addressable bytes, and
//    is typically but not always Granularity/4.  Ignored in
//    16-color modes.
//
//CodeOffset - base of the code section in the structure.
//
//PlanarHCBankCodeOffset - offset from Code of executable code
//    that performs planar HC mode bank switching.  Ignored in
//    16-color modes.
//
//PlanarHCEnableCodeOffset - offset from Code of executable code
//    that enables planar HC mode.  Ignored in 16-color modes.
//
//PlanarHCDisableCodeOffset - offset from Code of executable code
//    that disables planar HC mode.  Ignored in 16-color modes.
//
//Specification for bank switch code at Code:
//    Executes requested bank mappings.
//
//    Input:
//      EAX = bank number to which to map window #0
//      EDX = bank number to which to map window #1
//      interpreted according to BankingType as follows:
//        VideoBanked1RW - the single window is mapped to bank EAX,
//            EBX is ignored.
//        VideoBanked1RW - the read window is mapped to bank EAX,
//            the write window is mapped to bank EBX
//        VideoBanked1R1W - the window at A000:0 is mapped to bank EAX,
//            the window at A800:0 is mapped to bank EBX
//
//    Output: none
//
// Note: the definition of "bank n" is the bank that starts at
//    display memory offset Granularity*n.  In other words,
//    banks are assumed to start every Granularity CPU-addressable
//    bytes, and are numbered from 0 to number of banks-1.
//
//Specification for planar HC executable code:
//    ***To be filled in when we get to planar HC modes***
//


//
// IOCTL_VIDEO_MAP_VIDEO_MEMORY - Maps the frame buffer into the callers
//                                address space.
// IOCTL_VIDEO_UNMAP_VIDEO_MEMORY - Unmaps the frame buffer from the callers
//                                  address space.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_MEMORY {
    PVOID RequestedVirtualAddress;
} VIDEO_MEMORY, *PVIDEO_MEMORY;

//
//RequestedVirtualAddress - For MAP: Requested virtual address for the video
//    memory. This value is optional. If zero is specified, the operating
//    system will choose an appropriate location.  For UNMAP: Virtual Address
//    of the base of video memory. The size is implicit since it can not
//    change (you can not add video memory dynamically!).
//

// IOCTL_VIDEO_SHARE_VIDEO_MEMORY - Maps the frame buffer to another process'
//                                  address space.  This IOCTL is initally
//                                  defined to support DCI.
// IOCTL_VIDEO_UNSHARE_VIDEO_MEMORY - Unmaps a previously shared buffer.
//
// Note: for the MAP_VIDEO_MEMORY_IOCTL, the process handle is passed in
// the VirtualAddress filed, while for this IOCTL the handle is explicit.
//

typedef struct _VIDEO_SHARE_MEMORY {
    HANDLE ProcessHandle;
    ULONG ViewOffset;
    ULONG ViewSize;
    PVOID RequestedVirtualAddress;
} VIDEO_SHARE_MEMORY, *PVIDEO_SHARE_MEMORY;

typedef struct _VIDEO_SHARE_MEMORY_INFORMATION {
    ULONG SharedViewOffset;
    ULONG SharedViewSize;
    PVOID VirtualAddress;
} VIDEO_SHARE_MEMORY_INFORMATION, *PVIDEO_SHARE_MEMORY_INFORMATION;


//
// IOCTL_VIDEO_MAP_VIDEO_MEMORY - Returns the virtual address and size of
//                                the frame buffer and video memory in the
//                                caller's address space.
//                                This IOCTL must be called after a call
//                                to the MAP IOCTL has been made.
//

typedef struct _VIDEO_MEMORY_INFORMATION {
    PVOID VideoRamBase;
    ULONG VideoRamLength;
    PVOID FrameBufferBase;
    ULONG FrameBufferLength;
} VIDEO_MEMORY_INFORMATION, *PVIDEO_MEMORY_INFORMATION;

//
//VideoRamBase - Virtual address of the Video RAM in the callers address space
//    (only valid if the memory is mapped.
//
//VideoRamLength - Linear length of the Video RAM in the caller's virtual
//    address space (memory accessible through a bank switch mechanism is not
//    described by this value).
//    This value must be equal to VideoMemoryBitmapHeight * ScreenStride
//
//FrameBufferBase - Virtual address of the Frame Buffer in the caller's
//    address space. The Frame buffer is the actively displayed part of Video
//    Ram.
//
//FrameBufferLength - Linear length of the Frame Buffer in the caller's
//    virtual address space (memory accessible through a bank switch mechanism
//    is not described by this value).
//    This value must be equal to VisScreenWidth * ScreenStride
//


//
// IOCTL_VIDEO_QUERY_PUBLIC_ACCESS_RANGES - Returns the access range used to
//                                          program the hardware directly.
//                                          An array of these is returned if
//                                          multiple ranges exist.
//
// IOCTL_VIDEO_FREE_PUBLIC_ACCESS_RANGES - Frees up the access ranges that were
//                                         allocated by the QUERY_ACCESS_RANGES
//                                         call.
//
// Information used by this function is passed using the following structure:
//

typedef struct _VIDEO_PUBLIC_ACCESS_RANGES {
    ULONG InIoSpace;
    ULONG MappedInIoSpace;
    PVOID VirtualAddress;
} VIDEO_PUBLIC_ACCESS_RANGES, *PVIDEO_PUBLIC_ACCESS_RANGES;

//
//InIoSpace - Indicates if the hardware registers or ports are in IO space
//    or in memory space.
//
//MappedInIoSpace - Indicates if under the current platform the registers or
//    ports are mapped in IO Space or memory space.
//
//VirtualAddress - Location of the registers or IO ports as mapped under the
//    current architecture.
//


//
// IOCTL_VIDEO_QUERY_COLOR_CAPABILITIES - Returns the color information
//                                        found in the monitors VDDPs
//                                        description file.
//
// NOTE: This structure must be filled out completely. A subset of the
//         values can not be returned.
//

typedef struct _VIDEO_COLOR_CAPABILITIES {
    ULONG Length;
    ULONG AttributeFlags;
    LONG  RedPhosphoreDecay;
    LONG  GreenPhosphoreDecay;
    LONG  BluePhosphoreDecay;
    LONG  WhiteChromaticity_x;
    LONG  WhiteChromaticity_y;
    LONG  WhiteChromaticity_Y;
    LONG  RedChromaticity_x;
    LONG  RedChromaticity_y;
    LONG  GreenChromaticity_x;
    LONG  GreenChromaticity_y;
    LONG  BlueChromaticity_x;
    LONG  BlueChromaticity_y;
    LONG  WhiteGamma;
    LONG  RedGamma;
    LONG  GreenGamma;
    LONG  BlueGamma;
} VIDEO_COLOR_CAPABILITIES, *PVIDEO_COLOR_CAPABILITIES;

//
// Flag Bit definitions
//

#define VIDEO_DEVICE_COLOR          0x1   // Is this device support color (1)
                                          // or monochrome only
#define VIDEO_OPTIONAL_GAMMET_TABLE 0x2   // Indicates that a gammet table can
                                          // be queried/set for the device
                                          // use other IOCTLs for that purpose.
//
//Length - Length of the basic structure. Used for versioning by checking the
//    Length of the struct is at least as large as the value given by sizeof().
//
//AttributesFlag - List of falgs determining some of the properties of the
//    device.
//
//See the VDDP documentation for the details on the various fields
//
//RedPhosphoreDecay
//GreenPhosphoreDecay
//BluePhosphoreDecay -
//
//WhiteChromaticity_x
//WhiteChromaticity_y
//WhiteChromaticity_Y -
//
//RedChromaticity_x
//RedChromaticity_y
//GreenChromaticity_x
//GreenChromaticity_y
//BlueChromaticity_x
//BlueChromaticity_y -
//
//WhiteGamma -
//
//RedGamma
//GreenGamma
//BlueGamma -
//
//All values returned in this structure are integers.
//The values returned must be floating point values * 10,000; i.e:
//a gamma of 2.34 would be returned as 23400.
//



//
// IOCTL_VIDEO_SET_POWER_MANAGEMENT - Tells the device to change the power
//                                    consumption level of the device to the
//                                    new state.
// IOCTL_VIDEO_GET_POWER_MANAGEMENT - Return the current power consumption
//                                    level of the device.
//
// Private IOCTLs intercepted by the video port:
//
// IOCTL_VIDEO_SET_OUTPUT_DEVICE_POWER_STATE - Sets the power state on the
//                                             output device
//
// IOCTL_VIDEO_GET_OUTPUT_DEVICE_POWER_STATE - Returns if it is possible to set
//                                             this partcular power state on the
//                                             output device (monitor, TV).
//
// NOTE:
// This IOCTL is based on the VESA DPMS proposal.
// Changes to the DPMS standard will be refelcted in this IOCTL.
//

typedef enum _VIDEO_POWER_STATE {
    VideoPowerUnspecified = 0,
    VideoPowerOn = 1,
    VideoPowerStandBy,
    VideoPowerSuspend,
    VideoPowerOff,
    VideoPowerHibernate,
    VideoPowerShutdown,
    VideoPowerMaximum
} VIDEO_POWER_STATE, *PVIDEO_POWER_STATE;


typedef struct _VIDEO_POWER_MANAGEMENT {
    ULONG Length;
    ULONG DPMSVersion;
    ULONG PowerState;
} VIDEO_POWER_MANAGEMENT, *PVIDEO_POWER_MANAGEMENT;

//
//Length - Length of the structure in bytes. Also used to do verisioning.
//
//DPMSVersion - Version of the DPMS standard supported by the device.
//              Only used in the "GET" IOCTL.
//
//PowerState - One of the power states listed in VIDEO_POWER_STATE.
//

//
// Note:
// Once the power has been turned off to the device, all other IOCTLs made
// to the miniport will be intercepted by the port driver and will return
// failiure, until the power on the device has been turned back on.
//


//
// IOCTL_VIDEO_SET_COLOR_LUT_DATA - Confugure color look up table on video adaptor.
//

typedef struct _VIDEO_COLOR_LUT_DATA {
    ULONG Length;
    ULONG LutDataFormat;
    UCHAR LutData[1];
} VIDEO_COLOR_LUT_DATA, *PVIDEO_COLOR_LUT_DATA;

//
// Length - Length of the structure in bytes.
//
// LutDataFormat values - indicate data format in ColorLutTable.
//
// LutDataTable - color lut table data.
//

#define VIDEO_COLOR_LUT_DATA_FORMAT_RGB256WORDS     0x00000001

typedef struct _VIDEO_LUT_RGB256WORDS {
    USHORT Red[256];
    USHORT Green[256];
    USHORT Blue[256];
} VIDEO_LUT_RGB256WORDS, *PVIDEO_LUT_RGB256WORDS;

#define VIDEO_COLOR_LUT_DATA_FORMAT_PRIVATEFORMAT   0x80000000

//
// VIDEO_COLOR_LUT_DATA_FORMAT_RGB256WORDS -
//      Lut data has 3 array of 256 WORDs. 1st 256 WORDs array for Red, next
//     for Blue, then Green. And its value have to be packed in the most
//     significant bits of the WORDs (0 to 0xFF00 for 8 bit). This allows
//     for 8, 12 and 16 bit RAMDAC independance. Thus Driver can shifts them
//     right by 8, 4 or 0 places for 8, 12 and 16 bits RAMDAC.
//
// VIDEO_COLOR_LUT_DATA_FORMAT_PRIVATEFORMAT -
//      Driver defined format. This value should be OR-ed with other driver
//     internal identify index in 0 - 30 bits. Callee should know the detail
//     format.
//

//
// BANK_POSITION
//

typedef struct _BANK_POSITION
{
    ULONG ReadBankPosition;
    ULONG WriteBankPosition;
} BANK_POSITION, *PBANK_POSITION;


//-----------------------------------------------------------------------------
//
//  Monitor control support (LCD brightness)
//
//-----------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// WARNING: Supported only for backwards compatibility with XPSP1 and shall be retired in Blackcomb - new code should use the new WMI interface
//
// IOCTL_VIDEO_QUERY_SUPPORTED_BRIGHTNESS - Queries via _BCL the available backlight
//                                          levels.
// IOCTL_VIDEO_QUERY_DISPLAY_BRIGHTNESS   - Queries the current AC/DC backlight levels
//                                          and indicates the current power state per
//                                          ucDisplayPolicy.
// IOCTL_VIDEO_SET_DISPLAY_BRIGHTNESS     - Sets via _BCM the AC/DC brightness of the
//                                          backlight for the power states indicated
//                                          in ucDisplayPolicy.
//

typedef struct _DISPLAY_BRIGHTNESS {
    UCHAR ucDisplayPolicy;
    UCHAR ucACBrightness;
    UCHAR ucDCBrightness;
} DISPLAY_BRIGHTNESS, *PDISPLAY_BRIGHTNESS;

#define DISPLAYPOLICY_AC                0x00000001
#define DISPLAYPOLICY_DC                0x00000002
#define DISPLAYPOLICY_BOTH              (DISPLAYPOLICY_AC | DISPLAYPOLICY_DC)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


//
// Used for setting brightness policy through the Device Power Policy Manager.
//
// DefaultToBiosPolicy implies that the brightness values should be adjusted
// to reflect the suggestions made by the BIOS.
//
// LevelCount is the number of structs that follow.
//
// BatteryLevel is the level below which the following Brightness applies.
// Brightness is a percentage that expresses how bright the screen should be
// at or below this BatteryLevel.
//

typedef struct {
    BOOLEAN DefaultToBiosPolicy;
    UCHAR   LevelCount;
    struct {
        UCHAR BatteryLevel;
        UCHAR Brightness;
    } Level[1];
} VIDEO_BRIGHTNESS_POLICY, *PVIDEO_BRIGHTNESS_POLICY;


//-----------------------------------------------------------------------------
//
//  Far East fullscreen support
//
//-----------------------------------------------------------------------------


#ifndef _WINCON_

typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;

typedef struct _CHAR_INFO {
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } Char;
    USHORT Attributes;
} CHAR_INFO, *PCHAR_INFO;

//
// Attributes flags:
//

#define FOREGROUND_BLUE      0x0001 // text color contains blue.
#define FOREGROUND_GREEN     0x0002 // text color contains green.
#define FOREGROUND_RED       0x0004 // text color contains red.
#define FOREGROUND_INTENSITY 0x0008 // text color is intensified.
#define BACKGROUND_BLUE      0x0010 // background color contains blue.
#define BACKGROUND_GREEN     0x0020 // background color contains green.
#define BACKGROUND_RED       0x0040 // background color contains red.
#define BACKGROUND_INTENSITY 0x0080 // background color is intensified.
#define COMMON_LVB_LEADING_BYTE    0x0100 // Leading Byte of DBCS
#define COMMON_LVB_TRAILING_BYTE   0x0200 // Trailing Byte of DBCS
#define COMMON_LVB_GRID_HORIZONTAL 0x0400 // DBCS: Grid attribute: top horizontal.
#define COMMON_LVB_GRID_LVERTICAL  0x0800 // DBCS: Grid attribute: left vertical.
#define COMMON_LVB_GRID_RVERTICAL  0x1000 // DBCS: Grid attribute: right vertical.
#define COMMON_LVB_REVERSE_VIDEO   0x4000 // DBCS: Reverse fore/back ground attribute.
#define COMMON_LVB_UNDERSCORE      0x8000 // DBCS: Underscore.

#define COMMON_LVB_SBCSDBCS        0x0300 // SBCS or DBCS flag.



//
// Share of conapi.h
//
#define CHAR_TYPE_SBCS     0   // Displayed SBCS character
#define CHAR_TYPE_LEADING  2   // Displayed leading byte of DBCS
#define CHAR_TYPE_TRAILING 3   // Displayed trailing byte of DBCS


//
// Share of foncache.h
//
#define BITMAP_BITS_BYTE_ALIGN   8 // BYTE align is 8 bit
#define BITMAP_BITS_WORD_ALIGN  16 // WORD align is 16 bit
#define BITMAP_ARRAY_BYTE  3       // BYTE array is 8 bit  (shift count = 3)

#define BITMAP_PLANES      1
#define BITMAP_BITS_PIXEL  1


#define BYTE_ALIGN  sizeof(UCHAR)
#define WORD_ALIGN  sizeof(USHORT)


#endif // _WINCON_


typedef struct _FSCNTL_SCREEN_INFO {
    COORD Position;
    COORD ScreenSize;
    ULONG nNumberOfChars;
} FSCNTL_SCREEN_INFO, *PFSCNTL_SCREEN_INFO;


typedef struct _FONT_IMAGE_INFO {
    COORD  FontSize;
    PUCHAR ImageBits;                                 // WORD aligned.
} FONT_IMAGE_INFO, *PFONT_IMAGE_INFO;


typedef struct _CHAR_IMAGE_INFO {
    CHAR_INFO       CharInfo;
    FONT_IMAGE_INFO FontImageInfo;
} CHAR_IMAGE_INFO, *PCHAR_IMAGE_INFO;

//
// Share of consrv.h
//
#define SCREEN_BUFFER_POINTER(X,Y,XSIZE,CELLSIZE) (((XSIZE * (Y)) + (X)) * (ULONG)CELLSIZE)

typedef struct _VGA_CHAR {
    CHAR Char;
    CHAR Attributes;
} VGA_CHAR, *PVGA_CHAR;


//
// Define the Full Screen Video device name strings.
//

#define DD_FULLSCREEN_VIDEO_DEVICE_NAME L"\\Device\\FSVideo"


//
// IOCTL_FSVIDEO_COPY_FRAME_BUFFER - Copy in the frame buffer.
//
typedef struct _FSVIDEO_COPY_FRAME_BUFFER {
    FSCNTL_SCREEN_INFO SrcScreen;
    FSCNTL_SCREEN_INFO DestScreen;
} FSVIDEO_COPY_FRAME_BUFFER, *PFSVIDEO_COPY_FRAME_BUFFER;

//
// IOCTL_FSVIDEO_WRITE_TO_FRAME_BUFFER - Write to the frame buffer.
//
typedef struct _FSVIDEO_WRITE_TO_FRAME_BUFFER {
    PCHAR_IMAGE_INFO   SrcBuffer;
    FSCNTL_SCREEN_INFO DestScreen;
} FSVIDEO_WRITE_TO_FRAME_BUFFER, *PFSVIDEO_WRITE_TO_FRAME_BUFFER;

//
// IOCTL_FSVIDEO_REVERSE_MOUSE_POINTER - Reverse to the frame buffer for mouse pointer.
//
// dwType as follows:
//    CHAR_TYPE_SBCS     0   // Displayed SBCS character
//    CHAR_TYPE_LEADING  2   // Displayed leading byte of DBCS
//    CHAR_TYPE_TRAILING 3   // Displayed trailing byte of DBCS
//
typedef struct _FSVIDEO_REVERSE_MOUSE_POINTER {
    FSCNTL_SCREEN_INFO Screen;
    ULONG dwType;
} FSVIDEO_REVERSE_MOUSE_POINTER, *PFSVIDEO_REVERSE_MOUSE_POINTER;

//
// IOCTL_FSVIDEO_SET_CURRENT_MODE - Set the information for the current
//                                  video mode.
//
// Information used by this function is passed using the following structure:
//
typedef struct _FSVIDEO_MODE_INFORMATION {
    VIDEO_MODE_INFORMATION VideoMode;
    VIDEO_MEMORY_INFORMATION VideoMemory;
} FSVIDEO_MODE_INFORMATION, *PFSVIDEO_MODE_INFORMATION;

//
// IOCTL_FSVIDEO_SET_SCREEN_INFORMATION - Set the information for current console screen
//
typedef struct _FSVIDEO_SCREEN_INFORMATION {
    COORD ScreenSize;
    COORD FontSize;
} FSVIDEO_SCREEN_INFORMATION, *PFSVIDEO_SCREEN_INFORMATION;


//
// IOCTL_FSVIDEO_SET_CURSOR_POSITION - Set the information for cursor position
//
// dwType as follows:
//    CHAR_TYPE_SBCS     0   // Displayed SBCS character
//    CHAR_TYPE_LEADING  2   // Displayed leading byte of DBCS
//    CHAR_TYPE_TRAILING 3   // Displayed trailing byte of DBCS
//
typedef struct _FSVIDEO_CURSOR_POSITION {
    VIDEO_CURSOR_POSITION Coord;
    ULONG dwType;
} FSVIDEO_CURSOR_POSITION, *PFSVIDEO_CURSOR_POSITION;

//
//  Opaque type for event objects.
//

typedef struct _ENG_EVENT *PEVENT;

typedef struct _ENG_EVENT {
    PVOID pKEvent;
    ULONG fFlags;
    } ENG_EVENT, *PENG_EVENT;

//
// Performance counter query information.
//

#define VIDEO_REASON_NONE                 0
#define VIDEO_REASON_POLICY1              1
#define VIDEO_REASON_POLICY2              2
#define VIDEO_REASON_POLICY3              3
#define VIDEO_REASON_POLICY4              4
#define VIDEO_REASON_LOCK                 5
#define VIDEO_REASON_FAILED_ROTATION      5
#define VIDEO_REASON_ALLOCATION           6
#define VIDEO_REASON_SCRATCH              8
#define VIDEO_REASON_CONFIGURATION        9
#define VIDEO_MAX_REASON                  VIDEO_REASON_CONFIGURATION

typedef struct _VIDEO_PERFORMANCE_COUNTER
{
   UINT64 NbOfAllocationEvicted[VIDEO_MAX_REASON+1];
   UINT64 NbOfAllocationMarked[VIDEO_MAX_REASON+1];
   UINT64 NbOfAllocationRestored[VIDEO_MAX_REASON+1];
   UINT64 KBytesEvicted[VIDEO_MAX_REASON+1];
   UINT64 KBytesMarked[VIDEO_MAX_REASON+1];
   UINT64 KBytesRestored[VIDEO_MAX_REASON+1];
   UINT64 NbProcessCommited;
   UINT64 NbAllocationCommited;
   UINT64 NbAllocationMarked;
   UINT64 KBytesAllocated;
   UINT64 KBytesAvailable;
   UINT64 KBytesCurMarked;
   UINT64 Reference;
   UINT64 Unreference;
   UINT64 TrueReference;
   UINT64 NbOfPageIn;
   UINT64 KBytesPageIn;
   UINT64 NbOfPageOut;
   UINT64 KBytesPageOut;
   UINT64 NbOfRotateOut;
   UINT64 KBytesRotateOut;
} VIDEO_PERFORMANCE_COUNTER, *PVIDEO_PERFORMANCE_COUNTER;

typedef struct _VIDEO_QUERY_PERFORMANCE_COUNTER
{
   ULONG BufferSize;
   PVIDEO_PERFORMANCE_COUNTER Buffer;
} VIDEO_QUERY_PERFORMANCE_COUNTER, *PVIDEO_QUERY_PERFORMANCE_COUNTER;

#ifdef __cplusplus
}
#endif

#endif // !GUID_DEFS_ONLY

#endif  // _NTDDVDEO_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddtape.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddtape.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the Tape device.

--*/

#ifndef _NTDDTAPE_
#define _NTDDTAPE_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define DD_TAPE_DEVICE_NAME "\\Device\\Tape"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_TAPE_BASE                 FILE_DEVICE_TAPE

#define IOCTL_TAPE_ERASE                CTL_CODE(IOCTL_TAPE_BASE, 0x0000, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_TAPE_PREPARE              CTL_CODE(IOCTL_TAPE_BASE, 0x0001, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_WRITE_MARKS          CTL_CODE(IOCTL_TAPE_BASE, 0x0002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_TAPE_GET_POSITION         CTL_CODE(IOCTL_TAPE_BASE, 0x0003, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_SET_POSITION         CTL_CODE(IOCTL_TAPE_BASE, 0x0004, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_GET_DRIVE_PARAMS     CTL_CODE(IOCTL_TAPE_BASE, 0x0005, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_SET_DRIVE_PARAMS     CTL_CODE(IOCTL_TAPE_BASE, 0x0006, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_TAPE_GET_MEDIA_PARAMS     CTL_CODE(IOCTL_TAPE_BASE, 0x0007, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_SET_MEDIA_PARAMS     CTL_CODE(IOCTL_TAPE_BASE, 0x0008, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_GET_STATUS           CTL_CODE(IOCTL_TAPE_BASE, 0x0009, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOCTL_TAPE_CREATE_PARTITION     CTL_CODE(IOCTL_TAPE_BASE, 0x000a, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// The following device control codes are common for all class drivers.  The
// functions codes defined here must match all of the other class drivers.
//
// Warning: these codes will be replaced in the future with the IOCTL_STORAGE
// codes included below
//

#define IOCTL_TAPE_MEDIA_REMOVAL        CTL_CODE(IOCTL_TAPE_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_EJECT_MEDIA          CTL_CODE(IOCTL_TAPE_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_LOAD_MEDIA           CTL_CODE(IOCTL_TAPE_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_RESERVE              CTL_CODE(IOCTL_TAPE_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_RELEASE              CTL_CODE(IOCTL_TAPE_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)

#if (NTDDI_VERSION < NTDDI_WS03)
#define IOCTL_TAPE_CHECK_VERIFY         CTL_CODE(IOCTL_TAPE_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_TAPE_FIND_NEW_DEVICES     CTL_CODE(IOCTL_DISK_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)
#endif
//
// The following file contains the IOCTL_STORAGE class ioctls
//

#include <ntddstor.h>

// begin_winnt begin_ntminitape


//
// IOCTL_TAPE_ERASE definitions
//

#define TAPE_ERASE_SHORT            0L
#define TAPE_ERASE_LONG             1L

typedef struct _TAPE_ERASE {
    ULONG Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;

//
// IOCTL_TAPE_PREPARE definitions
//

#define TAPE_LOAD                   0L
#define TAPE_UNLOAD                 1L
#define TAPE_TENSION                2L
#define TAPE_LOCK                   3L
#define TAPE_UNLOCK                 4L
#define TAPE_FORMAT                 5L

typedef struct _TAPE_PREPARE {
    ULONG Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;

//
// IOCTL_TAPE_WRITE_MARKS definitions
//

#define TAPE_SETMARKS               0L
#define TAPE_FILEMARKS              1L
#define TAPE_SHORT_FILEMARKS        2L
#define TAPE_LONG_FILEMARKS         3L

typedef struct _TAPE_WRITE_MARKS {
    ULONG Type;
    ULONG Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;

//
// IOCTL_TAPE_GET_POSITION definitions
//

#define TAPE_ABSOLUTE_POSITION       0L
#define TAPE_LOGICAL_POSITION        1L
#define TAPE_PSEUDO_LOGICAL_POSITION 2L

typedef struct _TAPE_GET_POSITION {
    ULONG Type;
    ULONG Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;

//
// IOCTL_TAPE_SET_POSITION definitions
//

#define TAPE_REWIND                 0L
#define TAPE_ABSOLUTE_BLOCK         1L
#define TAPE_LOGICAL_BLOCK          2L
#define TAPE_PSEUDO_LOGICAL_BLOCK   3L
#define TAPE_SPACE_END_OF_DATA      4L
#define TAPE_SPACE_RELATIVE_BLOCKS  5L
#define TAPE_SPACE_FILEMARKS        6L
#define TAPE_SPACE_SEQUENTIAL_FMKS  7L
#define TAPE_SPACE_SETMARKS         8L
#define TAPE_SPACE_SEQUENTIAL_SMKS  9L

typedef struct _TAPE_SET_POSITION {
    ULONG Method;
    ULONG Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;

//
// IOCTL_TAPE_GET_DRIVE_PARAMS definitions
//

//
// Definitions for FeaturesLow parameter
//

#define TAPE_DRIVE_FIXED            0x00000001
#define TAPE_DRIVE_SELECT           0x00000002
#define TAPE_DRIVE_INITIATOR        0x00000004

#define TAPE_DRIVE_ERASE_SHORT      0x00000010
#define TAPE_DRIVE_ERASE_LONG       0x00000020
#define TAPE_DRIVE_ERASE_BOP_ONLY   0x00000040
#define TAPE_DRIVE_ERASE_IMMEDIATE  0x00000080

#define TAPE_DRIVE_TAPE_CAPACITY    0x00000100
#define TAPE_DRIVE_TAPE_REMAINING   0x00000200
#define TAPE_DRIVE_FIXED_BLOCK      0x00000400
#define TAPE_DRIVE_VARIABLE_BLOCK   0x00000800

#define TAPE_DRIVE_WRITE_PROTECT    0x00001000
#define TAPE_DRIVE_EOT_WZ_SIZE      0x00002000

#define TAPE_DRIVE_ECC              0x00010000
#define TAPE_DRIVE_COMPRESSION      0x00020000
#define TAPE_DRIVE_PADDING          0x00040000
#define TAPE_DRIVE_REPORT_SMKS      0x00080000

#define TAPE_DRIVE_GET_ABSOLUTE_BLK 0x00100000
#define TAPE_DRIVE_GET_LOGICAL_BLK  0x00200000
#define TAPE_DRIVE_SET_EOT_WZ_SIZE  0x00400000

#define TAPE_DRIVE_EJECT_MEDIA      0x01000000
#define TAPE_DRIVE_CLEAN_REQUESTS   0x02000000
#define TAPE_DRIVE_SET_CMP_BOP_ONLY 0x04000000

#define TAPE_DRIVE_RESERVED_BIT     0x80000000  //don't use this bit!
//                                              //can't be a low features bit!
//                                              //reserved; high features only

//
// Definitions for FeaturesHigh parameter
//

#define TAPE_DRIVE_LOAD_UNLOAD      0x80000001
#define TAPE_DRIVE_TENSION          0x80000002
#define TAPE_DRIVE_LOCK_UNLOCK      0x80000004
#define TAPE_DRIVE_REWIND_IMMEDIATE 0x80000008

#define TAPE_DRIVE_SET_BLOCK_SIZE   0x80000010
#define TAPE_DRIVE_LOAD_UNLD_IMMED  0x80000020
#define TAPE_DRIVE_TENSION_IMMED    0x80000040
#define TAPE_DRIVE_LOCK_UNLK_IMMED  0x80000080

#define TAPE_DRIVE_SET_ECC          0x80000100
#define TAPE_DRIVE_SET_COMPRESSION  0x80000200
#define TAPE_DRIVE_SET_PADDING      0x80000400
#define TAPE_DRIVE_SET_REPORT_SMKS  0x80000800

#define TAPE_DRIVE_ABSOLUTE_BLK     0x80001000
#define TAPE_DRIVE_ABS_BLK_IMMED    0x80002000
#define TAPE_DRIVE_LOGICAL_BLK      0x80004000
#define TAPE_DRIVE_LOG_BLK_IMMED    0x80008000

#define TAPE_DRIVE_END_OF_DATA      0x80010000
#define TAPE_DRIVE_RELATIVE_BLKS    0x80020000
#define TAPE_DRIVE_FILEMARKS        0x80040000
#define TAPE_DRIVE_SEQUENTIAL_FMKS  0x80080000

#define TAPE_DRIVE_SETMARKS         0x80100000
#define TAPE_DRIVE_SEQUENTIAL_SMKS  0x80200000
#define TAPE_DRIVE_REVERSE_POSITION 0x80400000
#define TAPE_DRIVE_SPACE_IMMEDIATE  0x80800000

#define TAPE_DRIVE_WRITE_SETMARKS   0x81000000
#define TAPE_DRIVE_WRITE_FILEMARKS  0x82000000
#define TAPE_DRIVE_WRITE_SHORT_FMKS 0x84000000
#define TAPE_DRIVE_WRITE_LONG_FMKS  0x88000000

#define TAPE_DRIVE_WRITE_MARK_IMMED 0x90000000
#define TAPE_DRIVE_FORMAT           0xA0000000
#define TAPE_DRIVE_FORMAT_IMMEDIATE 0xC0000000
#define TAPE_DRIVE_HIGH_FEATURES    0x80000000  //mask for high features flag

typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    ULONG DefaultBlockSize;
    ULONG MaximumBlockSize;
    ULONG MinimumBlockSize;
    ULONG MaximumPartitionCount;
    ULONG FeaturesLow;
    ULONG FeaturesHigh;
    ULONG EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_SET_DRIVE_PARAMETERS definitions
//

typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    ULONG EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;

//
// IOCTL_TAPE_GET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    ULONG BlockSize;
    ULONG PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_SET_MEDIA_PARAMETERS definitions
//

typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    ULONG BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;

//
// IOCTL_TAPE_CREATE_PARTITION definitions
//

#define TAPE_FIXED_PARTITIONS       0L
#define TAPE_SELECT_PARTITIONS      1L
#define TAPE_INITIATOR_PARTITIONS   2L

typedef struct _TAPE_CREATE_PARTITION {
    ULONG Method;
    ULONG Count;
    ULONG Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;


//
// WMI Methods
//
#define TAPE_QUERY_DRIVE_PARAMETERS       0L
#define TAPE_QUERY_MEDIA_CAPACITY         1L
#define TAPE_CHECK_FOR_DRIVE_PROBLEM      2L
#define TAPE_QUERY_IO_ERROR_DATA          3L
#define TAPE_QUERY_DEVICE_ERROR_DATA      4L

typedef struct _TAPE_WMI_OPERATIONS {
   ULONG Method;
   ULONG DataBufferSize;
   PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;

//
// Type of drive errors
//
typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
   TapeDriveProblemNone, TapeDriveReadWriteWarning,
   TapeDriveReadWriteError, TapeDriveReadWarning,
   TapeDriveWriteWarning, TapeDriveReadError,
   TapeDriveWriteError, TapeDriveHardwareError,
   TapeDriveUnsupportedMedia, TapeDriveScsiConnectionError,
   TapeDriveTimetoClean, TapeDriveCleanDriveNow,
   TapeDriveMediaLifeExpired, TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;

// end_winnt end_ntminitape

#ifdef __cplusplus
}
#endif

#endif  // _NTDDTAPE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddstor.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddstor.h

Abstract:

    This is the include file that defines all common constants and types
    accessing the storage class drivers

--*/


//
// Interface GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntddstor.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntddstor.h> in that source file a second time to instantiate the GUIDs
//
#ifdef DEFINE_GUID
//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

// begin_wioctlguids

DEFINE_GUID(GUID_DEVINTERFACE_DISK,                   0x53f56307L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_CDROM,                  0x53f56308L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_PARTITION,              0x53f5630aL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_TAPE,                   0x53f5630bL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_WRITEONCEDISK,          0x53f5630cL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_VOLUME,                 0x53f5630dL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_MEDIUMCHANGER,          0x53f56310L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_FLOPPY,                 0x53f56311L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_CDCHANGER,              0x53f56312L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(GUID_DEVINTERFACE_STORAGEPORT,            0x2accfe60L, 0xc130, 0x11d2, 0xb0, 0x82, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);

#define  WDI_STORAGE_PREDICT_FAILURE_DPS_GUID        {0xe9f2d03aL, 0x747c, 0x41c2, {0xbb, 0x9a, 0x02, 0xc6, 0x2b, 0x6d, 0x5f, 0xcb}};

//
// The interface used to discover volumes that are
// not reported by Win32 APIs. This includes those
// with an unrecognized partition type/id and ones
// with the hidden attribute.
//
DEFINE_GUID(GUID_DEVINTERFACE_HIDDEN_VOLUME,          0x7f108a28L, 0x9833, 0x4b3b, 0xb7, 0x80, 0x2c, 0x6b, 0x5f, 0xa5, 0xc0, 0x62);

// end_wioctlguids

// begin_wioctlobsoleteguids

#define DiskClassGuid               GUID_DEVINTERFACE_DISK
#define CdRomClassGuid              GUID_DEVINTERFACE_CDROM
#define PartitionClassGuid          GUID_DEVINTERFACE_PARTITION
#define TapeClassGuid               GUID_DEVINTERFACE_TAPE
#define WriteOnceDiskClassGuid      GUID_DEVINTERFACE_WRITEONCEDISK
#define VolumeClassGuid             GUID_DEVINTERFACE_VOLUME
#define MediumChangerClassGuid      GUID_DEVINTERFACE_MEDIUMCHANGER
#define FloppyClassGuid             GUID_DEVINTERFACE_FLOPPY
#define CdChangerClassGuid          GUID_DEVINTERFACE_CDCHANGER
#define StoragePortClassGuid        GUID_DEVINTERFACE_STORAGEPORT
#define HiddenVolumeClassGuid       GUID_DEVINTERFACE_HIDDEN_VOLUME

// end_wioctlobsoleteguids
#endif

// begin_winioctl

#ifndef _NTDDSTOR_H_
#define _NTDDSTOR_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// IoControlCode values for storage devices
//

#define IOCTL_STORAGE_BASE FILE_DEVICE_MASS_STORAGE

//
// The following device control codes are common for all class drivers.  They
// should be used in place of the older IOCTL_DISK, IOCTL_CDROM and IOCTL_TAPE
// common codes
//

#define IOCTL_STORAGE_CHECK_VERIFY            CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_CHECK_VERIFY2           CTL_CODE(IOCTL_STORAGE_BASE, 0x0200, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_MEDIA_REMOVAL           CTL_CODE(IOCTL_STORAGE_BASE, 0x0201, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_EJECT_MEDIA             CTL_CODE(IOCTL_STORAGE_BASE, 0x0202, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_LOAD_MEDIA              CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_LOAD_MEDIA2             CTL_CODE(IOCTL_STORAGE_BASE, 0x0203, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_RESERVE                 CTL_CODE(IOCTL_STORAGE_BASE, 0x0204, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_RELEASE                 CTL_CODE(IOCTL_STORAGE_BASE, 0x0205, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_FIND_NEW_DEVICES        CTL_CODE(IOCTL_STORAGE_BASE, 0x0206, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_STORAGE_EJECTION_CONTROL        CTL_CODE(IOCTL_STORAGE_BASE, 0x0250, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_MCN_CONTROL             CTL_CODE(IOCTL_STORAGE_BASE, 0x0251, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_STORAGE_GET_MEDIA_TYPES         CTL_CODE(IOCTL_STORAGE_BASE, 0x0300, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_MEDIA_TYPES_EX      CTL_CODE(IOCTL_STORAGE_BASE, 0x0301, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER CTL_CODE(IOCTL_STORAGE_BASE, 0x0304, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_GET_HOTPLUG_INFO        CTL_CODE(IOCTL_STORAGE_BASE, 0x0305, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_SET_HOTPLUG_INFO        CTL_CODE(IOCTL_STORAGE_BASE, 0x0306, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_STORAGE_RESET_BUS               CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_RESET_DEVICE            CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_BREAK_RESERVATION       CTL_CODE(IOCTL_STORAGE_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_PERSISTENT_RESERVE_IN   CTL_CODE(IOCTL_STORAGE_BASE, 0x0406, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_PERSISTENT_RESERVE_OUT  CTL_CODE(IOCTL_STORAGE_BASE, 0x0407, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_STORAGE_GET_DEVICE_NUMBER       CTL_CODE(IOCTL_STORAGE_BASE, 0x0420, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_PREDICT_FAILURE         CTL_CODE(IOCTL_STORAGE_BASE, 0x0440, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_STORAGE_READ_CAPACITY           CTL_CODE(IOCTL_STORAGE_BASE, 0x0450, METHOD_BUFFERED, FILE_READ_ACCESS)

#define IOCTL_STORAGE_QUERY_PROPERTY   CTL_CODE(IOCTL_STORAGE_BASE, 0x0500, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTLs for bandwidth contracts on storage devices
// (Move this to ntddsfio if we decide to use a new base)
//

#define IOCTL_STORAGE_GET_BC_PROPERTIES         CTL_CODE(IOCTL_STORAGE_BASE, 0x0600, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_STORAGE_ALLOCATE_BC_STREAM        CTL_CODE(IOCTL_STORAGE_BASE, 0x0601, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_STORAGE_FREE_BC_STREAM            CTL_CODE(IOCTL_STORAGE_BASE, 0x0602, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// IOCTL to check for priority support
//
#define IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT    CTL_CODE(IOCTL_STORAGE_BASE, 0x0620, METHOD_BUFFERED, FILE_ANY_ACCESS)

// begin_winioctl

//
// These ioctl codes are obsolete.  They are defined here to avoid resuing them
// and to allow class drivers to respond to them more easily.
//

#define OBSOLETE_IOCTL_STORAGE_RESET_BUS        CTL_CODE(IOCTL_STORAGE_BASE, 0x0400, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define OBSOLETE_IOCTL_STORAGE_RESET_DEVICE     CTL_CODE(IOCTL_STORAGE_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)


//
// IOCTL_STORAGE_GET_HOTPLUG_INFO
//

typedef struct _STORAGE_HOTPLUG_INFO {
    ULONG Size; // version
    BOOLEAN MediaRemovable; // ie. zip, jaz, cdrom, mo, etc. vs hdd
    BOOLEAN MediaHotplug;   // ie. does the device succeed a lock even though its not lockable media?
    BOOLEAN DeviceHotplug;  // ie. 1394, USB, etc.
    BOOLEAN WriteCacheEnableOverride; // This field should not be relied upon because it is no longer used
} STORAGE_HOTPLUG_INFO, *PSTORAGE_HOTPLUG_INFO;

//
// IOCTL_STORAGE_GET_DEVICE_NUMBER
//
// input - none
//
// output - STORAGE_DEVICE_NUMBER structure
//          The values in the STORAGE_DEVICE_NUMBER structure are guaranteed
//          to remain unchanged until the system is rebooted.  They are not
//          guaranteed to be persistant across boots.
//

typedef struct _STORAGE_DEVICE_NUMBER {

    //
    // The FILE_DEVICE_XXX type for this device.
    //

    DEVICE_TYPE DeviceType;

    //
    // The number of this device
    //

    ULONG       DeviceNumber;

    //
    // If the device is partitionable, the partition number of the device.
    // Otherwise -1
    //

    ULONG       PartitionNumber;
} STORAGE_DEVICE_NUMBER, *PSTORAGE_DEVICE_NUMBER;

//
// Define the structures for scsi resets
//

typedef struct _STORAGE_BUS_RESET_REQUEST {
    UCHAR PathId;
} STORAGE_BUS_RESET_REQUEST, *PSTORAGE_BUS_RESET_REQUEST;

//
// Break reservation is sent to the Adapter/FDO with the given lun information.
//

typedef struct STORAGE_BREAK_RESERVATION_REQUEST {
        ULONG Length;
        UCHAR _unused;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
} STORAGE_BREAK_RESERVATION_REQUEST, *PSTORAGE_BREAK_RESERVATION_REQUEST;


//
// IOCTL_STORAGE_MEDIA_REMOVAL disables the mechanism
// on a storage device that ejects media. This function
// may or may not be supported on storage devices that
// support removable media.
//
// TRUE means prevent media from being removed.
// FALSE means allow media removal.
//

typedef struct _PREVENT_MEDIA_REMOVAL {
    BOOLEAN PreventMediaRemoval;
} PREVENT_MEDIA_REMOVAL, *PPREVENT_MEDIA_REMOVAL;



//
//  This is the format of TARGET_DEVICE_CUSTOM_NOTIFICATION.CustomDataBuffer
//  passed to applications by the classpnp autorun code (via IoReportTargetDeviceChangeAsynchronous).
//
typedef struct _CLASS_MEDIA_CHANGE_CONTEXT {
        ULONG MediaChangeCount;
        ULONG NewState;         // see MEDIA_CHANGE_DETECTION_STATE enum in classpnp.h in DDK
} CLASS_MEDIA_CHANGE_CONTEXT, *PCLASS_MEDIA_CHANGE_CONTEXT;


// begin_ntminitape


typedef struct _TAPE_STATISTICS {
    ULONG Version;
    ULONG Flags;
    LARGE_INTEGER RecoveredWrites;
    LARGE_INTEGER UnrecoveredWrites;
    LARGE_INTEGER RecoveredReads;
    LARGE_INTEGER UnrecoveredReads;
    UCHAR         CompressionRatioReads;
    UCHAR         CompressionRatioWrites;
} TAPE_STATISTICS, *PTAPE_STATISTICS;

#define RECOVERED_WRITES_VALID   0x00000001
#define UNRECOVERED_WRITES_VALID 0x00000002
#define RECOVERED_READS_VALID    0x00000004
#define UNRECOVERED_READS_VALID  0x00000008
#define WRITE_COMPRESSION_INFO_VALID  0x00000010
#define READ_COMPRESSION_INFO_VALID   0x00000020

typedef struct _TAPE_GET_STATISTICS {
    ULONG Operation;
} TAPE_GET_STATISTICS, *PTAPE_GET_STATISTICS;

#define TAPE_RETURN_STATISTICS 0L
#define TAPE_RETURN_ENV_INFO   1L
#define TAPE_RESET_STATISTICS  2L

//
// IOCTL_STORAGE_GET_MEDIA_TYPES_EX will return an array of DEVICE_MEDIA_INFO
// structures, one per supported type, embedded in the GET_MEDIA_TYPES struct.
//

typedef enum _STORAGE_MEDIA_TYPE {
    //
    // Following are defined in ntdddisk.h in the MEDIA_TYPE enum
    //
    // Unknown,                // Format is unknown
    // F5_1Pt2_512,            // 5.25", 1.2MB,  512 bytes/sector
    // F3_1Pt44_512,           // 3.5",  1.44MB, 512 bytes/sector
    // F3_2Pt88_512,           // 3.5",  2.88MB, 512 bytes/sector
    // F3_20Pt8_512,           // 3.5",  20.8MB, 512 bytes/sector
    // F3_720_512,             // 3.5",  720KB,  512 bytes/sector
    // F5_360_512,             // 5.25", 360KB,  512 bytes/sector
    // F5_320_512,             // 5.25", 320KB,  512 bytes/sector
    // F5_320_1024,            // 5.25", 320KB,  1024 bytes/sector
    // F5_180_512,             // 5.25", 180KB,  512 bytes/sector
    // F5_160_512,             // 5.25", 160KB,  512 bytes/sector
    // RemovableMedia,         // Removable media other than floppy
    // FixedMedia,             // Fixed hard disk media
    // F3_120M_512,            // 3.5", 120M Floppy
    // F3_640_512,             // 3.5" ,  640KB,  512 bytes/sector
    // F5_640_512,             // 5.25",  640KB,  512 bytes/sector
    // F5_720_512,             // 5.25",  720KB,  512 bytes/sector
    // F3_1Pt2_512,            // 3.5" ,  1.2Mb,  512 bytes/sector
    // F3_1Pt23_1024,          // 3.5" ,  1.23Mb, 1024 bytes/sector
    // F5_1Pt23_1024,          // 5.25",  1.23MB, 1024 bytes/sector
    // F3_128Mb_512,           // 3.5" MO 128Mb   512 bytes/sector
    // F3_230Mb_512,           // 3.5" MO 230Mb   512 bytes/sector
    // F8_256_128,             // 8",     256KB,  128 bytes/sector
    // F3_200Mb_512,           // 3.5",   200M Floppy (HiFD)
    //

    DDS_4mm = 0x20,            // Tape - DAT DDS1,2,... (all vendors)
    MiniQic,                   // Tape - miniQIC Tape
    Travan,                    // Tape - Travan TR-1,2,3,...
    QIC,                       // Tape - QIC
    MP_8mm,                    // Tape - 8mm Exabyte Metal Particle
    AME_8mm,                   // Tape - 8mm Exabyte Advanced Metal Evap
    AIT1_8mm,                  // Tape - 8mm Sony AIT
    DLT,                       // Tape - DLT Compact IIIxt, IV
    NCTP,                      // Tape - Philips NCTP
    IBM_3480,                  // Tape - IBM 3480
    IBM_3490E,                 // Tape - IBM 3490E
    IBM_Magstar_3590,          // Tape - IBM Magstar 3590
    IBM_Magstar_MP,            // Tape - IBM Magstar MP
    STK_DATA_D3,               // Tape - STK Data D3
    SONY_DTF,                  // Tape - Sony DTF
    DV_6mm,                    // Tape - 6mm Digital Video
    DMI,                       // Tape - Exabyte DMI and compatibles
    SONY_D2,                   // Tape - Sony D2S and D2L
    CLEANER_CARTRIDGE,         // Cleaner - All Drive types that support Drive Cleaners
    CD_ROM,                    // Opt_Disk - CD
    CD_R,                      // Opt_Disk - CD-Recordable (Write Once)
    CD_RW,                     // Opt_Disk - CD-Rewriteable
    DVD_ROM,                   // Opt_Disk - DVD-ROM
    DVD_R,                     // Opt_Disk - DVD-Recordable (Write Once)
    DVD_RW,                    // Opt_Disk - DVD-Rewriteable
    MO_3_RW,                   // Opt_Disk - 3.5" Rewriteable MO Disk
    MO_5_WO,                   // Opt_Disk - MO 5.25" Write Once
    MO_5_RW,                   // Opt_Disk - MO 5.25" Rewriteable (not LIMDOW)
    MO_5_LIMDOW,               // Opt_Disk - MO 5.25" Rewriteable (LIMDOW)
    PC_5_WO,                   // Opt_Disk - Phase Change 5.25" Write Once Optical
    PC_5_RW,                   // Opt_Disk - Phase Change 5.25" Rewriteable
    PD_5_RW,                   // Opt_Disk - PhaseChange Dual Rewriteable
    ABL_5_WO,                  // Opt_Disk - Ablative 5.25" Write Once Optical
    PINNACLE_APEX_5_RW,        // Opt_Disk - Pinnacle Apex 4.6GB Rewriteable Optical
    SONY_12_WO,                // Opt_Disk - Sony 12" Write Once
    PHILIPS_12_WO,             // Opt_Disk - Philips/LMS 12" Write Once
    HITACHI_12_WO,             // Opt_Disk - Hitachi 12" Write Once
    CYGNET_12_WO,              // Opt_Disk - Cygnet/ATG 12" Write Once
    KODAK_14_WO,               // Opt_Disk - Kodak 14" Write Once
    MO_NFR_525,                // Opt_Disk - Near Field Recording (Terastor)
    NIKON_12_RW,               // Opt_Disk - Nikon 12" Rewriteable
    IOMEGA_ZIP,                // Mag_Disk - Iomega Zip
    IOMEGA_JAZ,                // Mag_Disk - Iomega Jaz
    SYQUEST_EZ135,             // Mag_Disk - Syquest EZ135
    SYQUEST_EZFLYER,           // Mag_Disk - Syquest EzFlyer
    SYQUEST_SYJET,             // Mag_Disk - Syquest SyJet
    AVATAR_F2,                 // Mag_Disk - 2.5" Floppy
    MP2_8mm,                   // Tape - 8mm Hitachi
    DST_S,                     // Ampex DST Small Tapes
    DST_M,                     // Ampex DST Medium Tapes
    DST_L,                     // Ampex DST Large Tapes
    VXATape_1,                 // Ecrix 8mm Tape
    VXATape_2,                 // Ecrix 8mm Tape
#if (NTDDI_VERSION < NTDDI_WINXP)
    STK_EAGLE,                 // STK Eagle
#else
    STK_9840,                  // STK 9840
#endif
    LTO_Ultrium,               // IBM, HP, Seagate LTO Ultrium
    LTO_Accelis,               // IBM, HP, Seagate LTO Accelis
    DVD_RAM,                   // Opt_Disk - DVD-RAM
    AIT_8mm,                   // AIT2 or higher
    ADR_1,                     // OnStream ADR Mediatypes
    ADR_2,
    STK_9940,                  // STK 9940
    SAIT,                      // SAIT Tapes    
    VXATape                    // VXA (Ecrix 8mm) Tape
}STORAGE_MEDIA_TYPE, *PSTORAGE_MEDIA_TYPE;

#define MEDIA_ERASEABLE         0x00000001
#define MEDIA_WRITE_ONCE        0x00000002
#define MEDIA_READ_ONLY         0x00000004
#define MEDIA_READ_WRITE        0x00000008

#define MEDIA_WRITE_PROTECTED   0x00000100
#define MEDIA_CURRENTLY_MOUNTED 0x80000000

//
// Define the different storage bus types
// Bus types below 128 (0x80) are reserved for Microsoft use
//

typedef enum _STORAGE_BUS_TYPE {
    BusTypeUnknown = 0x00,
    BusTypeScsi,
    BusTypeAtapi,
    BusTypeAta,
    BusType1394,
    BusTypeSsa,
    BusTypeFibre,
    BusTypeUsb,
    BusTypeRAID,
    BusTypeiScsi,
    BusTypeSas,
    BusTypeSata,
    BusTypeSd,
    BusTypeMmc,
    BusTypeMax,
    BusTypeMaxReserved = 0x7F
} STORAGE_BUS_TYPE, *PSTORAGE_BUS_TYPE;

typedef struct _DEVICE_MEDIA_INFO {
    union {
        struct {
            LARGE_INTEGER Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            ULONG TracksPerCylinder;
            ULONG SectorsPerTrack;
            ULONG BytesPerSector;
            ULONG NumberMediaSides;
            ULONG MediaCharacteristics; // Bitmask of MEDIA_XXX values.
        } DiskInfo;

        struct {
            LARGE_INTEGER Cylinders;
            STORAGE_MEDIA_TYPE MediaType;
            ULONG TracksPerCylinder;
            ULONG SectorsPerTrack;
            ULONG BytesPerSector;
            ULONG NumberMediaSides;
            ULONG MediaCharacteristics; // Bitmask of MEDIA_XXX values.
        } RemovableDiskInfo;

        struct {
            STORAGE_MEDIA_TYPE MediaType;
            ULONG   MediaCharacteristics; // Bitmask of MEDIA_XXX values.
            ULONG   CurrentBlockSize;
            STORAGE_BUS_TYPE BusType;

            //
            // Bus specific information describing the medium supported.
            //

            union {
                struct {
                    UCHAR MediumType;
                    UCHAR DensityCode;
                } ScsiInformation;
            } BusSpecificData;

        } TapeInfo;
    } DeviceSpecific;
} DEVICE_MEDIA_INFO, *PDEVICE_MEDIA_INFO;

typedef struct _GET_MEDIA_TYPES {
    ULONG DeviceType;              // FILE_DEVICE_XXX values
    ULONG MediaInfoCount;
    DEVICE_MEDIA_INFO MediaInfo[1];
} GET_MEDIA_TYPES, *PGET_MEDIA_TYPES;


//
// IOCTL_STORAGE_PREDICT_FAILURE
//
// input - none
//
// output - STORAGE_PREDICT_FAILURE structure
//          PredictFailure returns zero if no failure predicted and non zero
//                         if a failure is predicted.
//
//          VendorSpecific returns 512 bytes of vendor specific information
//                         if a failure is predicted
//
typedef struct _STORAGE_PREDICT_FAILURE
{
    ULONG PredictFailure;
    UCHAR VendorSpecific[512];
} STORAGE_PREDICT_FAILURE, *PSTORAGE_PREDICT_FAILURE;

// end_ntminitape

//
// Property Query Structures
//

//
// IOCTL_STORAGE_QUERY_PROPERTY
//
// Input Buffer:
//      a STORAGE_PROPERTY_QUERY structure which describes what type of query
//      is being done, what property is being queried for, and any additional
//      parameters which a particular property query requires.
//
//  Output Buffer:
//      Contains a buffer to place the results of the query into.  Since all
//      property descriptors can be cast into a STORAGE_DESCRIPTOR_HEADER,
//      the IOCTL can be called once with a small buffer then again using
//      a buffer as large as the header reports is necessary.
//


//
// Types of queries
//

typedef enum _STORAGE_QUERY_TYPE {
    PropertyStandardQuery = 0,          // Retrieves the descriptor
    PropertyExistsQuery,                // Used to test whether the descriptor is supported
    PropertyMaskQuery,                  // Used to retrieve a mask of writeable fields in the descriptor
    PropertyQueryMaxDefined     // use to validate the value
} STORAGE_QUERY_TYPE, *PSTORAGE_QUERY_TYPE;

//
// define some initial property id's
//

typedef enum _STORAGE_PROPERTY_ID {
    StorageDeviceProperty = 0,
    StorageAdapterProperty,
    StorageDeviceIdProperty,
    StorageDeviceUniqueIdProperty,              // See storduid.h for details
    StorageDeviceWriteCacheProperty,
    StorageMiniportProperty,
    StorageAccessAlignmentProperty
} STORAGE_PROPERTY_ID, *PSTORAGE_PROPERTY_ID;

//
// Query structure - additional parameters for specific queries can follow
// the header
//

typedef struct _STORAGE_PROPERTY_QUERY {

    //
    // ID of the property being retrieved
    //

    STORAGE_PROPERTY_ID PropertyId;

    //
    // Flags indicating the type of query being performed
    //

    STORAGE_QUERY_TYPE QueryType;

    //
    // Space for additional parameters if necessary
    //

    UCHAR AdditionalParameters[1];

} STORAGE_PROPERTY_QUERY, *PSTORAGE_PROPERTY_QUERY;

//
// Standard property descriptor header.  All property pages should use this
// as their first element or should contain these two elements
//

typedef __struct_bcount(Size) struct _STORAGE_DESCRIPTOR_HEADER {

    ULONG Version;

    ULONG Size;

} STORAGE_DESCRIPTOR_HEADER, *PSTORAGE_DESCRIPTOR_HEADER;

//
// Device property descriptor - this is really just a rehash of the inquiry
// data retrieved from a scsi device
//
// This may only be retrieved from a target device.  Sending this to the bus
// will result in an error
//

typedef __struct_bcount(Size) struct _STORAGE_DEVICE_DESCRIPTOR {

    //
    // Sizeof(STORAGE_DEVICE_DESCRIPTOR)
    //

    ULONG Version;

    //
    // Total size of the descriptor, including the space for additional
    // data and id strings
    //

    ULONG Size;

    //
    // The SCSI-2 device type
    //

    UCHAR DeviceType;

    //
    // The SCSI-2 device type modifier (if any) - this may be zero
    //

    UCHAR DeviceTypeModifier;

    //
    // Flag indicating whether the device's media (if any) is removable.  This
    // field should be ignored for media-less devices
    //

    BOOLEAN RemovableMedia;

    //
    // Flag indicating whether the device can support mulitple outstanding
    // commands.  The actual synchronization in this case is the responsibility
    // of the port driver.
    //

    BOOLEAN CommandQueueing;

    //
    // Byte offset to the zero-terminated ascii string containing the device's
    // vendor id string.  For devices with no such ID this will be zero
    //

    ULONG VendorIdOffset;

    //
    // Byte offset to the zero-terminated ascii string containing the device's
    // product id string.  For devices with no such ID this will be zero
    //

    ULONG ProductIdOffset;

    //
    // Byte offset to the zero-terminated ascii string containing the device's
    // product revision string.  For devices with no such string this will be
    // zero
    //

    ULONG ProductRevisionOffset;

    //
    // Byte offset to the zero-terminated ascii string containing the device's
    // serial number.  For devices with no serial number this will be zero
    //

    ULONG SerialNumberOffset;

    //
    // Contains the bus type (as defined above) of the device.  It should be
    // used to interpret the raw device properties at the end of this structure
    // (if any)
    //

    STORAGE_BUS_TYPE BusType;

    //
    // The number of bytes of bus-specific data which have been appended to
    // this descriptor
    //

    ULONG RawPropertiesLength;

    //
    // Place holder for the first byte of the bus specific property data
    //

    UCHAR RawDeviceProperties[1];

} STORAGE_DEVICE_DESCRIPTOR, *PSTORAGE_DEVICE_DESCRIPTOR;


//
// Adapter properties
//
// This descriptor can be retrieved from a target device object of from the
// device object for the bus.  Retrieving from the target device object will
// forward the request to the underlying bus
//

typedef __struct_bcount(Size) struct _STORAGE_ADAPTER_DESCRIPTOR {

    ULONG Version;

    ULONG Size;

    ULONG MaximumTransferLength;

    ULONG MaximumPhysicalPages;

    ULONG AlignmentMask;

    BOOLEAN AdapterUsesPio;

    BOOLEAN AdapterScansDown;

    BOOLEAN CommandQueueing;

    BOOLEAN AcceleratedTransfer;

#if (NTDDI_VERSION < NTDDI_WINXP)
    BOOLEAN BusType;
#else
    UCHAR BusType;
#endif

    USHORT BusMajorVersion;

    USHORT BusMinorVersion;

} STORAGE_ADAPTER_DESCRIPTOR, *PSTORAGE_ADAPTER_DESCRIPTOR;

typedef __struct_bcount(Size) struct _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR {

    //
    // Sizeof(STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR)
    //

    ULONG Version;

    //
    // Total size of the descriptor, including the space for additional
    // data and id strings
    //

    ULONG Size;

    //
    // The number of bytes in a cache line of the device
    //

    ULONG BytesPerCacheLine;

    //
    // The address offset neccessary for proper cache access alignment in bytes
    //

    ULONG BytesOffsetForCacheAlignment;

    //
    // The number of bytes in a physical sector of the device
    //

    ULONG BytesPerLogicalSector;

    //
    // The number of bytes in an addressable logical sector (LBA)of the device
    //

    ULONG BytesPerPhysicalSector;

    //
    // The address offset neccessary for proper sector access alignment in bytes
    //

    ULONG BytesOffsetForSectorAlignment;

} STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR, *PSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;



typedef enum _STORAGE_PORT_CODE_SET {
    StoragePortCodeSetReserved = 0,
    StoragePortCodeSetStorport = 1,
    StoragePortCodeSetSCSIport = 2
} STORAGE_PORT_CODE_SET, *PSTORAGE_PORT_CODE_SET;

typedef struct _STORAGE_MINIPORT_DESCRIPTOR {

    ULONG Version;

    ULONG Size;

    STORAGE_PORT_CODE_SET Portdriver;

    BOOLEAN LUNResetSupported;

    BOOLEAN TargetResetSupported;


} STORAGE_MINIPORT_DESCRIPTOR, *PSTORAGE_MINIPORT_DESCRIPTOR;

//
// Storage identification descriptor.
// The definitions here are based on the SCSI/SBP vital product data
// device identifier page.
//

typedef enum _STORAGE_IDENTIFIER_CODE_SET {
    StorageIdCodeSetReserved = 0,
    StorageIdCodeSetBinary = 1,
    StorageIdCodeSetAscii = 2,
    StorageIdCodeSetUtf8 = 3
} STORAGE_IDENTIFIER_CODE_SET, *PSTORAGE_IDENTIFIER_CODE_SET;

typedef enum _STORAGE_IDENTIFIER_TYPE {
    StorageIdTypeVendorSpecific = 0,
    StorageIdTypeVendorId = 1,
    StorageIdTypeEUI64 = 2,
    StorageIdTypeFCPHName = 3,
    StorageIdTypePortRelative = 4,
    StorageIdTypeTargetPortGroup = 5,
    StorageIdTypeLogicalUnitGroup = 6,
    StorageIdTypeMD5LogicalUnitIdentifier = 7,
    StorageIdTypeScsiNameString = 8
} STORAGE_IDENTIFIER_TYPE, *PSTORAGE_IDENTIFIER_TYPE;

// Mislabeled above but need to keep it for backwards compatibility
#define StorageIdTypeNAA StorageIdTypeFCPHName

// NAA formats (Used with StorageIdTypeNAA)
typedef enum _STORAGE_ID_NAA_FORMAT {
        StorageIdNAAFormatIEEEExtended = 2,
        StorageIdNAAFormatIEEERegistered = 3,
        StorageIdNAAFormatIEEEERegisteredExtended = 5
} STORAGE_ID_NAA_FORMAT, *PSTORAGE_ID_NAA_FORMAT;

typedef enum _STORAGE_ASSOCIATION_TYPE {
    StorageIdAssocDevice = 0,
    StorageIdAssocPort = 1,
    StorageIdAssocTarget = 2
} STORAGE_ASSOCIATION_TYPE, *PSTORAGE_ASSOCIATION_TYPE;

typedef struct _STORAGE_IDENTIFIER {
    STORAGE_IDENTIFIER_CODE_SET CodeSet;
    STORAGE_IDENTIFIER_TYPE Type;
    USHORT IdentifierSize;
    USHORT NextOffset;

    //
    // Add new fields here since existing code depends on
    // the above layout not changing.
    //

    STORAGE_ASSOCIATION_TYPE Association;

    //
    // The identifier is a variable length array of bytes.
    //

    UCHAR Identifier[1];
} STORAGE_IDENTIFIER, *PSTORAGE_IDENTIFIER;

typedef __struct_bcount(Size) struct _STORAGE_DEVICE_ID_DESCRIPTOR {

    ULONG Version;

    ULONG Size;

    //
    // The number of identifiers reported by the device.
    //

    ULONG NumberOfIdentifiers;

    //
    // The following field is actually a variable length array of identification
    // descriptors.  Unfortunately there's no C notation for an array of
    // variable length structures so we're forced to just pretend.
    //

    UCHAR Identifiers[1];
} STORAGE_DEVICE_ID_DESCRIPTOR, *PSTORAGE_DEVICE_ID_DESCRIPTOR;


//
// IOCTL_STORAGE_GET_BC_PROPERTIES
//
// Input Buffer:
//     None
//
// Output Buffer:
//     Structure of type STORAGE_GET_BC_PROPERTIES_OUTPUT
//

typedef struct _STORAGE_GET_BC_PROPERTIES_OUTPUT {

    //
    // Specifies the maximum number of requests
    // that can be scheduled per period of time
    //
    ULONG MaximumRequestsPerPeriod;

    //
    // Specifies the minimum period that the
    // device uses  when scheduling requests
    //
    ULONG MinimumPeriod;

    //
    // Specifies the maximum transfer size supported
    // for  bandwidth contracts  on this  device. To
    // achieve the highest level of performance, all
    // requests should be of this size
    //
    ULONGLONG MaximumRequestSize;

    //
    // Specifies the estimated time taken to
    // perform an  Io operstion. This  field
    // is  for  informational purposes  only
    //
    ULONG EstimatedTimePerRequest;

    //
    // Specifies the number of requests that should be
    // kept outstanding.  This helps  keep the  device
    // device busy and thus obtain maximum throughput.
    // This will only be filled in if the target  file
    // has an outstanding contract.
    //
    ULONG NumOutStandingRequests;
    
    //
    // Specifies the required size of requests in this 
    // stream.  This  will  only  be filled in  if the
    // target file has an outstanding contract.
    //
    ULONGLONG RequestSize;
    
} STORAGE_GET_BC_PROPERTIES_OUTPUT, *PSTORAGE_GET_BC_PROPERTIES_OUTPUT;


//
// IOCTL_STORAGE_ALLOCATE_BC_STREAM
//
// Input Buffer:
//     Structure of type STORAGE_ALLOCATE_BC_STREAM_INPUT
//
// Output Buffer:
//     Structure of type STORAGE_ALLOCATE_BC_STREAM_OUTPUT
//


//
// Current version
//
#define IOCTL_STORAGE_BC_VERSION                1

typedef struct _STORAGE_ALLOCATE_BC_STREAM_INPUT {

    //
    // Specifies the corresponding structure version
    //
    ULONG Version;

    //
    // Specifies the number of requests that
    // need to  complete  per period of time
    //
    ULONG RequestsPerPeriod;

    //
    // Specifies the period of time wherein the
    // above  number of requests  must complete
    //
    ULONG Period;

    //
    // Indicates whether failures
    // should  be retried  or not
    //
    BOOLEAN RetryFailures;

    //
    // Indicates whether reqests that  will miss
    // their deadline should be discarded or not
    //
    BOOLEAN Discardable;

    //
    // Helps align the following field
    //
    BOOLEAN Reserved1[2];

    //
    // Indicates whether the  Io  will be
    // comprised of reads, writes or both
    //
    ULONG AccessType;

    //
    // Indicates whether the  Io  to the
    // file will be sequential or random
    //
    ULONG AccessMode;

} STORAGE_ALLOCATE_BC_STREAM_INPUT, *PSTORAGE_ALLOCATE_BC_STREAM_INPUT;

typedef struct _STORAGE_ALLOCATE_BC_STREAM_OUTPUT {

    //
    // Specifies the required size
    // of  requests in this stream
    //
    ULONGLONG RequestSize;

    //
    // Specifies the number of requests that should be
    // kept outstanding.  This helps  keep the  device
    // device busy and thus obtain maximum  throughput
    //
    ULONG NumOutStandingRequests;

} STORAGE_ALLOCATE_BC_STREAM_OUTPUT, *PSTORAGE_ALLOCATE_BC_STREAM_OUTPUT;


//
// IOCTL_STORAGE_FREE_BC_STREAM
//
// Input Buffer:
//     None
//
// Output Buffer:
//     None
//

//
// IOCTL_STORAGE_CHECK_PRIORITY_HINT_SUPPORT
//
// Input Buffer :
//      None
// Output Buffer :
//      Structure of type STORAGE_PRIORITY_HINT_SUPPORT
//

#define STORAGE_PRIORITY_HINT_SUPPORTED     0x0001

typedef struct _STORAGE_PRIORITY_HINT_SUPPORT {
    ULONG SupportFlags;
} STORAGE_PRIORITY_HINT_SUPPORT, *PSTORAGE_PRIORITY_HINT_SUPPORT;

#pragma warning(push)
#pragma warning(disable:4200)

#if defined(_MSC_EXTENSIONS)

typedef struct _STORAGE_MEDIA_SERIAL_NUMBER_DATA {

    USHORT Reserved;

    //
    // the SerialNumberLength will be set to zero
    // if the command is supported and the media
    // does not have a valid serial number.
    //

    USHORT SerialNumberLength;

    //
    // the following data is binary, and is not guaranteed
    // to be NULL terminated.  this is an excercise for the
    // caller.
    //

#if !defined(__midl)
    UCHAR SerialNumber[0];
#endif

} STORAGE_MEDIA_SERIAL_NUMBER_DATA, *PSTORAGE_MEDIA_SERIAL_NUMBER_DATA;

#endif /* _MSC_EXTENSIONS */

typedef __struct_bcount(Size) struct _STORAGE_READ_CAPACITY {

    //
    // The version number, size of the STORAGE_READ_CAPACITY structure
    //
    ULONG Version;

    //
    // The size of the date returned, size of the STORAGE_READ_CAPACITY structure
    //
    ULONG Size;

    //
    // Number of bytes per block
    //

    ULONG BlockLength;

    //
    // Total number of blocks in the disk
    // This will have the last LBA + 1
    //

    LARGE_INTEGER NumberOfBlocks;

    //
    // Disk size in bytes
    //

    LARGE_INTEGER DiskLength;

} STORAGE_READ_CAPACITY, *PSTORAGE_READ_CAPACITY;

#pragma warning(pop)

//
// Device write cache property
//
// This property provides the write cache information
// about the target device.
//

typedef enum _WRITE_CACHE_TYPE {
    WriteCacheTypeUnknown,
    WriteCacheTypeNone,
    WriteCacheTypeWriteBack,
    WriteCacheTypeWriteThrough
} WRITE_CACHE_TYPE;

typedef enum _WRITE_CACHE_ENABLE {
    WriteCacheEnableUnknown,
    WriteCacheDisabled,
    WriteCacheEnabled
} WRITE_CACHE_ENABLE;

typedef enum _WRITE_CACHE_CHANGE {
    WriteCacheChangeUnknown,
    WriteCacheNotChangeable,
    WriteCacheChangeable
} WRITE_CACHE_CHANGE;

typedef enum _WRITE_THROUGH {
    WriteThroughUnknown,
    WriteThroughNotSupported,
    WriteThroughSupported
} WRITE_THROUGH;

typedef __struct_bcount(Size) struct _STORAGE_WRITE_CACHE_PROPERTY {

    //
    // The version number
    // Size of STORAGE_WRITE_CACHE_PROPERTY structure
    //
    ULONG Version;

    //
    // The size of the date returned
    // Size of STORAGE_WRITE_CACHE_PROPERTY structure
    //
    ULONG Size;

    //
    // Current write cache type
    //
    WRITE_CACHE_TYPE WriteCacheType;

    //
    // Current write cache value
    //
    WRITE_CACHE_ENABLE WriteCacheEnabled;

    //
    // Device write cache change capability
    //
    WRITE_CACHE_CHANGE WriteCacheChangeable;

    //
    // Device write through support capability
    //
    WRITE_THROUGH WriteThroughSupported;

    //
    // Device flush cache capability
    //
    BOOLEAN FlushCacheSupported;

    //
    // User selected power protection option through registry
    //
    BOOLEAN UserDefinedPowerProtection;

    //
    // Device has battery backup for write cache
    //
    BOOLEAN NVCacheEnabled;

} STORAGE_WRITE_CACHE_PROPERTY, *PSTORAGE_WRITE_CACHE_PROPERTY;


#pragma warning(push)
#pragma warning(disable:4200) // array[0]
#pragma warning(disable:4201) // nameless struct/unions
#pragma warning(disable:4214) // bit fields other than int

#if defined(_MSC_EXTENSIONS)

typedef struct _PERSISTENT_RESERVE_COMMAND {

    ULONG Version;
    ULONG Size;

    union {

        struct {

            //
            // Persistent Reserve service action.
            //

            UCHAR ServiceAction : 5;
            UCHAR Reserved1 : 3;

            //
            // Number of bytes allocated for returned parameter list.
            //

            USHORT AllocationLength;

        } PR_IN;

        struct {

            //
            // Persistent Reserve service action.
            //

            UCHAR ServiceAction : 5;
            UCHAR Reserved1 : 3;

            //
            // Persistent Reserve type and scope.
            //

            UCHAR Type : 4;
            UCHAR Scope : 4;

            //
            // Space for additional PR Out parameters.
            //

#if !defined(__midl)
            UCHAR ParameterList[0];
#endif

        } PR_OUT;
    };

} PERSISTENT_RESERVE_COMMAND, *PPERSISTENT_RESERVE_COMMAND;

#endif /* _MSC_EXTENSIONS */
#pragma warning(pop)


#ifdef __cplusplus
}
#endif

#endif // _NTDDSTOR_H_
// end_winioctl
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddvol.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddvol.h

Abstract:

    This module contains type and function definitions for NT volumes.

    This module may contain definitions that are exposed in public
    kit headers.

--*/


#ifndef _NTDDVOL_
#define _NTDDVOL_

#if _MSC_VER > 1000
#pragma once
#endif


#ifdef __cplusplus
extern "C" {
#endif

#ifndef IOCTL_VOLUME_BASE
// begin_winioctl

#define IOCTL_VOLUME_BASE                       0x00000056 // 'V'

#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// IOCTL to obtain the physical location of
// the specified volume on one or more disks.
//

#define IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS    CTL_CODE(IOCTL_VOLUME_BASE, 0, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS
//
// Input Buffer:
//     None
//
// Output Buffer:
//     Structure of type VOLUME_DISK_EXTENTS
//

typedef struct _DISK_EXTENT {

    //
    // Specifies the storage device number of
    // the disk on which this extent resides.
    //
    ULONG DiskNumber;

    //
    // Specifies the offset and length of this
    // extent relative to the beginning of the
    // disk.
    //    
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER ExtentLength;

} DISK_EXTENT, *PDISK_EXTENT;

typedef struct _VOLUME_DISK_EXTENTS {

    //
    // Specifies one or more contiguous range
    // of sectors that make up this volume.
    //
    ULONG NumberOfDiskExtents;
    DISK_EXTENT Extents[ANYSIZE_ARRAY];

} VOLUME_DISK_EXTENTS, *PVOLUME_DISK_EXTENTS;


//
// IOCTLs to transition the specified volume
// between r/w and non r/w modes.
//

#define IOCTL_VOLUME_ONLINE                     CTL_CODE(IOCTL_VOLUME_BASE, 2, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLUME_OFFLINE                    CTL_CODE(IOCTL_VOLUME_BASE, 3, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// IOCTL_VOLUME_ONLINE
// IOCTL_VOLUME_OFFLINE
//
// Input Buffer:
//     None
//
// Output Buffer:
//     None
//

#endif  // NTDDI_VERSION >= NTDDI_WIN2K


#if (NTDDI_VERSION >= NTDDI_WINXP)

//
// IOCTL to determine  whether  the specified
// volume resides on a disk that is an online
// cluster resource or not.
//

#define IOCTL_VOLUME_IS_CLUSTERED               CTL_CODE(IOCTL_VOLUME_BASE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL_VOLUME_IS_CLUSTERED
//
// Input Buffer:
//     None
//
// Output Buffer:
//     None
//

#endif  // NTDDI_VERSION >= NTDDI_WINXP

// end_winioctl
#endif  // IOCTL_VOLUME_BASE


#if (NTDDI_VERSION >= NTDDI_WIN2K)

//
// Legacy IOCTLs that were used to support
// clustering.
//

#define IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE    CTL_CODE(IOCTL_VOLUME_BASE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLUME_IS_OFFLINE                 CTL_CODE(IOCTL_VOLUME_BASE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLUME_IS_IO_CAPABLE              CTL_CODE(IOCTL_VOLUME_BASE, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLUME_QUERY_FAILOVER_SET         CTL_CODE(IOCTL_VOLUME_BASE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE
// IOCTL_VOLUME_IS_OFFLINE
// IOCTL_VOLUME_IS_IO_CAPABLE
//
// Input Buffer:
//     None
//
// Output Buffer:
//     None
//

//
// IOCTL_VOLUME_QUERY_FAILOVER_SET
//
// Input Buffer:
//     None
//
// Output Buffer:
//     Structure of type VOLUME_FAILOVER_SET
//

typedef struct _VOLUME_FAILOVER_SET {

    //
    // Specifies all of the  disks that are
    // part of the pack that this volume is
    // part of.
    //
    ULONG NumberOfDisks;
    ULONG DiskNumbers[ANYSIZE_ARRAY];
    
} VOLUME_FAILOVER_SET, *PVOLUME_FAILOVER_SET;


//
// IOCTL to obtain general information about
// the specified volume.
//

#define IOCTL_VOLUME_QUERY_VOLUME_NUMBER        CTL_CODE(IOCTL_VOLUME_BASE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLUME_LOGICAL_TO_PHYSICAL        CTL_CODE(IOCTL_VOLUME_BASE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLUME_PHYSICAL_TO_LOGICAL        CTL_CODE(IOCTL_VOLUME_BASE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL_VOLUME_QUERY_VOLUME_NUMBER
//
// Input Buffer:
//     None
//
// Output Buffer:
//     Structure of type VOLUME_NUMBER
//

typedef struct _VOLUME_NUMBER {

    //
    // Specifies the  number associated
    // with this volume for the current
    // session.
    //
    ULONG VolumeNumber;

    //
    // Specifies the name of the volume
    // manager driver.  If this is less
    // than 8, it is padded with blanks.
    //
    WCHAR VolumeManagerName[8];

} VOLUME_NUMBER, *PVOLUME_NUMBER;

//
// IOCTL_VOLUME_LOGICAL_TO_PHYSICAL
//
// Input Buffer:
//     Structure of type VOLUME_LOGICAL_OFFSET
//
// Output Buffer:
//     Structure of type VOLUME_PHYSICAL_OFFSETS
//

typedef struct _VOLUME_LOGICAL_OFFSET {

    //
    // Specifies the logical location
    // that needs to be translated to
    // a physical location.
    //
    LONGLONG LogicalOffset;

} VOLUME_LOGICAL_OFFSET, *PVOLUME_LOGICAL_OFFSET;

typedef struct _VOLUME_PHYSICAL_OFFSET {

    //
    // Specifies the physical location
    // that needs to be  translated to
    // a logical location.
    //
    ULONG DiskNumber;
    LONGLONG Offset;
    
} VOLUME_PHYSICAL_OFFSET, *PVOLUME_PHYSICAL_OFFSET;

typedef struct _VOLUME_PHYSICAL_OFFSETS {

    //
    // Specifies one or more physical
    // locations on which the logical
    // location resides.
    //
    ULONG NumberOfPhysicalOffsets;
    VOLUME_PHYSICAL_OFFSET PhysicalOffset[ANYSIZE_ARRAY];

} VOLUME_PHYSICAL_OFFSETS, *PVOLUME_PHYSICAL_OFFSETS;

//
// IOCTL_VOLUME_PHYSICAL_TO_LOGICAL
//
// Input Buffer:
//     Structure of type VOLUME_PHYSICAL_OFFSET
//
// Output Buffer:
//     Structure of type VOLUME_LOGICAL_OFFSET
//

#endif  // NTDDI_VERSION >= NTDDI_WIN2K


#if (NTDDI_VERSION >= NTDDI_WINXP)

//
// IOCTL to determine whether  the volume
// is suitable for OS installation or not.
//

#define IOCTL_VOLUME_IS_PARTITION               CTL_CODE(IOCTL_VOLUME_BASE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL_VOLUME_IS_PARTITION
//
// Input Buffer:
//     None
//
// Output Buffer:
//     None
//


//
// IOCTL to perform a  read operation from
// the specified plex of a mirrored volume.
//

#define IOCTL_VOLUME_READ_PLEX                  CTL_CODE(IOCTL_VOLUME_BASE, 11, METHOD_OUT_DIRECT, FILE_READ_ACCESS)

//
// IOCTL_VOLUME_READ_PLEX
//
// Input Buffer:
//     Structure of type VOLUME_READ_PLEX_INPUT
//
// Output Buffer:
//     None
//

typedef struct _VOLUME_READ_PLEX_INPUT {

    //
    // Specifies the offset within the
    // volume from where to read data.
    //
    LARGE_INTEGER ByteOffset;

    //
    // Specifies the amount of data in
    // bytes to be read in.
    //    
    ULONG Length;

    //
    // Specifies the plex from which the
    // data is to be read in.
    //    
    ULONG PlexNumber;

} VOLUME_READ_PLEX_INPUT, *PVOLUME_READ_PLEX_INPUT;


//
// IOCTLs to query and modify
// the attributes on volumes.
//

#define IOCTL_VOLUME_SET_GPT_ATTRIBUTES         CTL_CODE(IOCTL_VOLUME_BASE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_VOLUME_GET_GPT_ATTRIBUTES         CTL_CODE(IOCTL_VOLUME_BASE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL_VOLUME_SET_GPT_ATTRIBUTES
//
// Input Buffer:
//     Structure of type VOLUME_SET_GPT_ATTRIBUTES_INFORMATION
//
// Output Buffer:
//     None
//

typedef struct _VOLUME_SET_GPT_ATTRIBUTES_INFORMATION {

    //
    // Specifies  the  attributes that
    // are to be applied to the volume
    //
    ULONGLONG GptAttributes;

    //
    // Indicates whether  this is to be
    // undone when the handle is closed
    //
    BOOLEAN RevertOnClose;

    //
    // Indicates  whether the  attributes
    // apply  to all the  volumes  on the
    // disk that  this  volume resides on
    // Required if the disk layout is MBR
    //
    BOOLEAN ApplyToAllConnectedVolumes;

    //
    // For alignment purposes.
    //
    USHORT Reserved1;
    ULONG  Reserved2;

} VOLUME_SET_GPT_ATTRIBUTES_INFORMATION, *PVOLUME_SET_GPT_ATTRIBUTES_INFORMATION;

//
// IOCTL_VOLUME_GET_GPT_ATTRIBUTES
//
// Input Buffer:
//     None
//
// Output Buffer:
//     Structure of type VOLUME_GET_GPT_ATTRIBUTES_INFORMATION
//

typedef struct _VOLUME_GET_GPT_ATTRIBUTES_INFORMATION {

    //
    // Specifies all the attributes
    // associated with this volume.
    //
    ULONGLONG GptAttributes;
    
} VOLUME_GET_GPT_ATTRIBUTES_INFORMATION, *PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION;

#endif  // NTDDI_VERSION >= NTDDI_WINXP


#if (NTDDI_VERSION >= NTDDI_VISTA)

//
// IOCTLs for bandwidth contracts
// on volumes.
//

#define IOCTL_VOLUME_GET_BC_PROPERTIES          CTL_CODE(IOCTL_VOLUME_BASE, 15, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_VOLUME_ALLOCATE_BC_STREAM         CTL_CODE(IOCTL_VOLUME_BASE, 16, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_VOLUME_FREE_BC_STREAM             CTL_CODE(IOCTL_VOLUME_BASE, 17, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

#define IOCTL_VOLUME_BC_VERSION                 1

//
// IOCTL_VOLUME_GET_BC_PROPERTIES
//
// Input Buffer:
//     Structure of type VOLUME_GET_BC_PROPERTIES_INPUT
//
// Output Buffer:
//     Structure of type VOLUME_GET_BC_PROPERTIES_OUTPUT
//

typedef struct _VOLUME_GET_BC_PROPERTIES_INPUT {

    //
    // Specifies the corresponding structure
    // version.
    //
    ULONG Version;

    //
    // For alignment purposes.
    //
    ULONG Reserved1;

    //
    // Specifies the lowest byte offset of
    // the file that is to be streamed.
    //
    ULONGLONG LowestByteOffset;
    
    //
    // Specifies the highest byte offset of
    // the file that is to be streamed.
    //
    ULONGLONG HighestByteOffset;

    //
    // Indicates whether requests shall be
    // comprised of reads, writes or both.
    //
    ULONG AccessType;

    //
    // Indicates whether the Io requests to
    // the file will be sequential or not.
    //
    ULONG AccessMode;
    
} VOLUME_GET_BC_PROPERTIES_INPUT, *PVOLUME_GET_BC_PROPERTIES_INPUT;

typedef struct _VOLUME_GET_BC_PROPERTIES_OUTPUT {

    //
    // Specifies the maximum number of requests
    // that can be scheduled per period of time.
    //
    ULONG MaximumRequestsPerPeriod;
    
    //
    // Specifies the minimum period that the
    // device uses when scheduling requests.
    //
    ULONG MinimumPeriod;

    //
    // Specifies the maximum transfer size supported
    // for  bandwidth contracts  on this  device. To
    // achieve the highest level of performance, all
    // requests should be of this size.
    //
    ULONGLONG MaximumRequestSize;

    //
    // Specifies the estimated time taken to
    // perform an  Io operation. This  field
    // is for informational purposes only.
    //
    ULONG EstimatedTimePerRequest;

    //
    // Specifies the number of requests that should be
    // kept outstanding.  This helps  keep the  device
    // device busy  and thus obtain maximum throughput
    // This will only be filled in if the target  file
    // has an outstanding contract.
    //
    ULONG NumOutStandingRequests;

    //
    // Specifies the required size of requests in this 
    // stream.  This  will  only  be filled in  if the
    // target file has an outstanding contract.
    //
    ULONGLONG RequestSize;

} VOLUME_GET_BC_PROPERTIES_OUTPUT, *PVOLUME_GET_BC_PROPERTIES_OUTPUT;

//
// IOCTL_VOLUME_ALLOCATE_BC_STREAM
//
// Input Buffer:
//     Structure of type VOLUME_ALLOCATE_BC_STREAM_INPUT
//
// Output Buffer:
//     Structure of type VOLUME_ALLOCATE_BC_STREAM_OUTPUT
//

typedef struct _VOLUME_ALLOCATE_BC_STREAM_INPUT {

    //
    // Specifies the corresponding structure
    // version.
    //
    ULONG Version;

    //
    // Specifies the number of requests that
    // need to complete per period of time.
    //
    ULONG RequestsPerPeriod;
    
    //
    // Specifies the period of time wherein the
    // above number of requests must complete.
    //
    ULONG Period;

    //
    // Indicates whether failures should be
    // be retried or not.
    //
    BOOLEAN RetryFailures;

    //
    // Indicates whether reqests that miss
    // their deadline should  be discarded
    // or not.
    //
    BOOLEAN Discardable;

    //
    // For alignment purposes.
    //
    BOOLEAN Reserved1[2];

    //
    // Specifies the lowest byte offset of
    // the file that is to be streamed.
    //
    ULONGLONG LowestByteOffset;
    
    //
    // Specifies the highest byte offset of
    // the file that is to be streamed.
    //
    ULONGLONG HighestByteOffset;

    //
    // Indicates whether requests shall be
    // comprised of reads, writes or both.
    //
    ULONG AccessType;

    //
    // Indicates whether the Io requests to
    // the file will be sequential or not.
    //
    ULONG AccessMode;
    
} VOLUME_ALLOCATE_BC_STREAM_INPUT, *PVOLUME_ALLOCATE_BC_STREAM_INPUT;

typedef struct _VOLUME_ALLOCATE_BC_STREAM_OUTPUT {

    //
    // Specifies the required size
    // of requests in this stream.
    //
    ULONGLONG RequestSize;
    
    //
    // Specifies the number of requests that should be
    // kept outstanding.  This helps  keep the  device
    // device busy and thus obtain maximum throughput.
    //
    ULONG NumOutStandingRequests;
    
} VOLUME_ALLOCATE_BC_STREAM_OUTPUT, *PVOLUME_ALLOCATE_BC_STREAM_OUTPUT;

//
// IOCTL_VOLUME_FREE_BC_STREAM
//
// Input Buffer:
//     None
//
// Output Buffer:
//     None
//


//
// IOCTL to differentiate between basic and
// dynamic volumes.
//

#define IOCTL_VOLUME_IS_DYNAMIC                 CTL_CODE(IOCTL_VOLUME_BASE, 18, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL_VOLUME_IS_DYNAMIC
//
// Input Buffer:
//     None
//
// Output Buffer:
//     Structure of type BOOLEAN
//


//
// IOCTL to inform the storage stack of
// runs that contain a special file.
//

#define IOCTL_VOLUME_PREPARE_FOR_CRITICAL_IO    CTL_CODE(IOCTL_VOLUME_BASE, 19, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// IOCTL_VOLUME_PREPARE_FOR_CRITICAL_IO
//
// Input Buffer:
//     Structure of type VOLUME_CRITICAL_IO
//
// Output Buffer:
//     None
//

typedef struct _FILE_EXTENT {

    ULONGLONG VolumeOffset;
    ULONGLONG ExtentLength;

} FILE_EXTENT, *PFILE_EXTENT;

typedef struct _VOLUME_CRITICAL_IO {

    //
    // Indicates whether requests shall be
    // comprised of reads, writes or both.
    //
    ULONG AccessType;

    //
    // Count of the number of extents that
    // are contained within this structure.
    //
    ULONG ExtentsCount;

    //
    // Specifies the extents along which
    // the critical Io will be performed.
    //
    FILE_EXTENT Extents[ANYSIZE_ARRAY];

} VOLUME_CRITICAL_IO, *PVOLUME_CRITICAL_IO;


//
// IOCTL to provide hints to the file system
// as to where to place new file allocations.
//

#define IOCTL_VOLUME_QUERY_ALLOCATION_HINT      CTL_CODE(IOCTL_VOLUME_BASE, 20, METHOD_OUT_DIRECT, FILE_READ_ACCESS)

//
// IOCTL_VOLUME_QUERY_ALLOCATION_HINT
//
// Input Buffer:
//     Structure of type VOLUME_ALLOCATION_HINT_INPUT
//
// Output Buffer:
//     Structure of type VOLUME_ALLOCATION_HINT_OUTPUT
//

typedef struct _VOLUME_ALLOCATION_HINT_INPUT {

    //
    // Specifies the granularity of
    // the bitmap being requested.
    //
    ULONG ClusterSize;

    //
    // Specifies the count of bits
    // that are being requested.
    //
    ULONG NumberOfClusters;

    //
    // Specifies the first cluster
    // that is to be evaluated.
    //
    LONGLONG StartingClusterNumber;

} VOLUME_ALLOCATION_HINT_INPUT, *PVOLUME_ALLOCATION_HINT_INPUT;

typedef struct _VOLUME_ALLOCATION_HINT_OUTPUT {

    //
    // Specifies the bits, 1 per cluster
    // indicating all of the good places
    // where file data  may be allocated
    // These bits are represented by a 0.
    //
    ULONG Bitmap[ANYSIZE_ARRAY];

} VOLUME_ALLOCATION_HINT_OUTPUT, *PVOLUME_ALLOCATION_HINT_OUTPUT;


//
// IOCTL to inform  the storage stack to
// discard and  re-query any information
// about the specified volume that might
// have been cached.
//

#define IOCTL_VOLUME_UPDATE_PROPERTIES          CTL_CODE(IOCTL_VOLUME_BASE, 21, METHOD_BUFFERED, FILE_ANY_ACCESS)

//
// IOCTL_VOLUME_UPDATE_PROPERTIES
//
// Input Buffer:
//     None
//
// Output Buffer:
//     None
//


//
// IOCTLs to coordinate a shrink operation
// with the drivers in the storage stack.
//

#define IOCTL_VOLUME_QUERY_MINIMUM_SHRINK_SIZE  CTL_CODE(IOCTL_VOLUME_BASE, 22, METHOD_BUFFERED, FILE_READ_ACCESS)
#define IOCTL_VOLUME_PREPARE_FOR_SHRINK         CTL_CODE(IOCTL_VOLUME_BASE, 23, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// IOCTL_VOLUME_QUERY_MINIMUM_SHRINK_SIZE
//
// Input Buffer:
//     None
//
// Output Buffer:
//     Structure of type VOLUME_SHRINK_INFO
//

//
// IOCTL_VOLUME_PREPARE_FOR_SHRINK
//
// Input Buffer:
//     Structure of type VOLUME_SHRINK_INFO
//
// Output Buffer:
//     None
//

typedef struct _VOLUME_SHRINK_INFO {

    //
    // Specifies the size in bytes to
    // which the volume  can be or is
    // going to be reduced down to.
    //
    ULONGLONG VolumeSize;

} VOLUME_SHRINK_INFO, *PVOLUME_SHRINK_INFO;

#endif  // NTDDI_VERSION >= NTDDI_VISTA

#ifdef __cplusplus
}
#endif

#endif  // _NTDDVOL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntddscsi.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntddscsi.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the SCSI port adapters.

--*/


//
// Interface GUIDs
//
// need these GUIDs outside conditional includes so that user can
//   #include <ntddscsi.h> in precompiled header
//   #include <initguid.h> in a single source file
//   #include <ntddscsi.h> in that source file a second time to instantiate the GUIDs
//
#ifdef DEFINE_GUID
//
// Make sure FAR is defined...
//
#ifndef FAR
#ifdef _WIN32
#define FAR
#else
#define FAR _far
#endif
#endif

DEFINE_GUID(ScsiRawInterfaceGuid, 0x53f56309L, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
DEFINE_GUID(WmiScsiAddressGuid,   0x53f5630fL, 0xb6bf, 0x11d0, 0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b);
#endif

#ifndef _NTDDSCSIH_
#define _NTDDSCSIH_

#ifdef __cplusplus
extern "C" {
#endif

//
// Device Name - this string is the name of the device.  It is the name
// that should be passed to NtOpenFile when accessing the device.
//
// Note:  For devices that support multiple units, it should be suffixed
//        with the Ascii representation of the unit number.
//

#define IOCTL_SCSI_BASE                 FILE_DEVICE_CONTROLLER
#define FILE_DEVICE_SCSI                0x0000001b

#define DD_SCSI_DEVICE_NAME "\\Device\\ScsiPort"


//
// NtDeviceIoControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//

#define IOCTL_SCSI_PASS_THROUGH         CTL_CODE(IOCTL_SCSI_BASE, 0x0401, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SCSI_MINIPORT             CTL_CODE(IOCTL_SCSI_BASE, 0x0402, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SCSI_GET_INQUIRY_DATA     CTL_CODE(IOCTL_SCSI_BASE, 0x0403, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_GET_CAPABILITIES     CTL_CODE(IOCTL_SCSI_BASE, 0x0404, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_PASS_THROUGH_DIRECT  CTL_CODE(IOCTL_SCSI_BASE, 0x0405, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_SCSI_GET_ADDRESS          CTL_CODE(IOCTL_SCSI_BASE, 0x0406, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_RESCAN_BUS           CTL_CODE(IOCTL_SCSI_BASE, 0x0407, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_GET_DUMP_POINTERS    CTL_CODE(IOCTL_SCSI_BASE, 0x0408, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_SCSI_FREE_DUMP_POINTERS   CTL_CODE(IOCTL_SCSI_BASE, 0x0409, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_IDE_PASS_THROUGH          CTL_CODE(IOCTL_SCSI_BASE, 0x040a, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ATA_PASS_THROUGH          CTL_CODE(IOCTL_SCSI_BASE, 0x040b, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ATA_PASS_THROUGH_DIRECT   CTL_CODE(IOCTL_SCSI_BASE, 0x040c, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_ATA_MINIPORT              CTL_CODE(IOCTL_SCSI_BASE, 0x040d, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MINIPORT_PROCESS_SERVICE_IRP CTL_CODE(IOCTL_SCSI_BASE,  0x040e, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MPIO_PASS_THROUGH_PATH    CTL_CODE(IOCTL_SCSI_BASE, 0x040f, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)
#define IOCTL_MPIO_PASS_THROUGH_PATH_DIRECT CTL_CODE(IOCTL_SCSI_BASE, 0x0410, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS)

//
// Non Volatile Cache support
//

#define IOCTL_SCSI_MINIPORT_NVCACHE           ((FILE_DEVICE_SCSI << 16) + 0x0600)

//
// Define the SCSI pass through structure.
//

typedef struct _SCSI_PASS_THROUGH {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG_PTR DataBufferOffset;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH, *PSCSI_PASS_THROUGH;

//
// Define the SCSI pass through direct structure.
//

typedef struct _SCSI_PASS_THROUGH_DIRECT {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    PVOID DataBuffer;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH_DIRECT, *PSCSI_PASS_THROUGH_DIRECT;


//
// Define the SCSI pass through direct structure for Win64 (thunking).
//
#if defined(_WIN64)
typedef struct _SCSI_PASS_THROUGH32 {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG32 DataBufferOffset;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH32, *PSCSI_PASS_THROUGH32;

//
// Define the SCSI pass through direct structure.
//

typedef struct _SCSI_PASS_THROUGH_DIRECT32 {
    USHORT Length;
    UCHAR ScsiStatus;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR CdbLength;
    UCHAR SenseInfoLength;
    UCHAR DataIn;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    VOID * POINTER_32 DataBuffer;
    ULONG SenseInfoOffset;
    UCHAR Cdb[16];
}SCSI_PASS_THROUGH_DIRECT32, *PSCSI_PASS_THROUGH_DIRECT32;

#endif

//
// ATA pass through structure
//

typedef struct _ATA_PASS_THROUGH_EX {
    USHORT Length;
    USHORT AtaFlags;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR ReservedAsUchar;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG ReservedAsUlong;
    ULONG_PTR DataBufferOffset;
    UCHAR PreviousTaskFile[8];
    UCHAR CurrentTaskFile[8];
} ATA_PASS_THROUGH_EX, *PATA_PASS_THROUGH_EX;

//
// ATA pass through direct structure.
//

typedef struct _ATA_PASS_THROUGH_DIRECT {
    USHORT Length;
    USHORT AtaFlags;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR ReservedAsUchar;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG ReservedAsUlong;
    PVOID DataBuffer;
    UCHAR PreviousTaskFile[8];
    UCHAR CurrentTaskFile[8];
} ATA_PASS_THROUGH_DIRECT, *PATA_PASS_THROUGH_DIRECT;

//
// Define the ATA pass through direct structure for Win64 (thunking).
//
#if defined(_WIN64)

typedef struct _ATA_PASS_THROUGH_EX32 {
    USHORT Length;
    USHORT AtaFlags;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR ReservedAsUchar;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG ReservedAsUlong;
    ULONG32 DataBufferOffset;
    UCHAR PreviousTaskFile[8];
    UCHAR CurrentTaskFile[8];
} ATA_PASS_THROUGH_EX32, *PATA_PASS_THROUGH_EX32;

//
// ATA pass through direct structure.
//

typedef struct _ATA_PASS_THROUGH_DIRECT32 {
    USHORT Length;
    USHORT AtaFlags;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR ReservedAsUchar;
    ULONG DataTransferLength;
    ULONG TimeOutValue;
    ULONG ReservedAsUlong;
    VOID * POINTER_32 DataBuffer;
    UCHAR PreviousTaskFile[8];
    UCHAR CurrentTaskFile[8];
} ATA_PASS_THROUGH_DIRECT32, *PATA_PASS_THROUGH_DIRECT32;
#endif

//
// ATA Pass Through Flags
//
#define ATA_FLAGS_DRDY_REQUIRED         (1 << 0)
#define ATA_FLAGS_DATA_IN               (1 << 1)
#define ATA_FLAGS_DATA_OUT              (1 << 2)
#define ATA_FLAGS_48BIT_COMMAND         (1 << 3)
#define ATA_FLAGS_USE_DMA               (1 << 4)
#define ATA_FLAGS_NO_MULTIPLE           (1 << 5)

//
// Define header for IOCTL_ATA_MINIPORT
//

typedef struct _IDE_IO_CONTROL {
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnStatus;
        ULONG DataLength;
} IDE_IO_CONTROL, *PIDE_IO_CONTROL;

//
// Define the structure for IOCTL_MPIO_PASS_THROUGH_PATH.
//

typedef struct _MPIO_PASS_THROUGH_PATH {
        SCSI_PASS_THROUGH PassThrough;
        ULONG   Version;
        USHORT  Length;
        UCHAR   Flags;
        UCHAR   PortNumber;
        ULONGLONG MpioPathId;
} MPIO_PASS_THROUGH_PATH, *PMPIO_PASS_THROUGH_PATH;

//
// Define the structure for IOCTL_MPIO_PASS_THROUGH_PATH_DIRECT.
//

typedef struct _MPIO_PASS_THROUGH_PATH_DIRECT {
        SCSI_PASS_THROUGH_DIRECT PassThrough;
        ULONG   Version;
        USHORT  Length;
        UCHAR   Flags;
        UCHAR   PortNumber;
        ULONGLONG MpioPathId;
} MPIO_PASS_THROUGH_PATH_DIRECT, *PMPIO_PASS_THROUGH_PATH_DIRECT;


//
// Define the IOCTL_MPIO_PASS_THROUGH_PATH structure for Win64 (thunking).
//

#if defined(_WIN64)
typedef struct _MPIO_PASS_THROUGH_PATH32 {
        SCSI_PASS_THROUGH32 PassThrough;
        ULONG   Version;
        USHORT  Length;
        UCHAR   Flags;
        UCHAR   PortNumber;
        ULONGLONG MpioPathId;
} MPIO_PASS_THROUGH_PATH32, *PMPIO_PASS_THROUGH_PATH32;

//
// Define the IOCTL_MPIO_PASS_THROUGH_PATH_DIRECT structure for Win64 (thunking).
//

typedef struct _MPIO_PASS_THROUGH_PATH_DIRECT32 {
        SCSI_PASS_THROUGH_DIRECT32 PassThrough;
        ULONG   Version;
        USHORT  Length;
        UCHAR   Flags;
        UCHAR   PortNumber;
        ULONGLONG MpioPathId;
} MPIO_PASS_THROUGH_PATH_DIRECT32, *PMPIO_PASS_THROUGH_PATH_DIRECT32;

#endif

//
// Define SCSI information.
// Used with the IOCTL_SCSI_GET_INQUIRY_DATA IOCTL.
//

typedef struct _SCSI_BUS_DATA {
    UCHAR NumberOfLogicalUnits;
    UCHAR InitiatorBusId;
    ULONG InquiryDataOffset;
}SCSI_BUS_DATA, *PSCSI_BUS_DATA;

//
// Define SCSI adapter bus information structure..
// Used with the IOCTL_SCSI_GET_INQUIRY_DATA IOCTL.
//

typedef struct _SCSI_ADAPTER_BUS_INFO {
    UCHAR NumberOfBuses;
    SCSI_BUS_DATA BusData[1];
} SCSI_ADAPTER_BUS_INFO, *PSCSI_ADAPTER_BUS_INFO;

//
// Define SCSI adapter bus information.
// Used with the IOCTL_SCSI_GET_INQUIRY_DATA IOCTL.
//

typedef struct _SCSI_INQUIRY_DATA {
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    BOOLEAN DeviceClaimed;
    ULONG InquiryDataLength;
    ULONG NextInquiryDataOffset;
    UCHAR InquiryData[1];
}SCSI_INQUIRY_DATA, *PSCSI_INQUIRY_DATA;

//
// Define header for I/O control SRB.
//

typedef struct _SRB_IO_CONTROL {
        ULONG HeaderLength;
        UCHAR Signature[8];
        ULONG Timeout;
        ULONG ControlCode;
        ULONG ReturnCode;
        ULONG Length;
} SRB_IO_CONTROL, *PSRB_IO_CONTROL;

typedef struct _NVCACHE_REQUEST_BLOCK {
    ULONG           NRBSize;
    USHORT          Function;
    ULONG           NRBFlags;
    ULONG           NRBStatus;
    ULONG           Count;
    ULONGLONG       LBA;
    ULONG           DataBufSize;
    ULONG           NVCacheStatus;
    ULONG           NVCacheSubStatus;
} NVCACHE_REQUEST_BLOCK, *PNVCACHE_REQUEST_BLOCK;

#define NRB_FUNCTION_NVCACHE_INFO               0xEC
#define NRB_FUNCTION_SPINDLE_STATUS                 0xE5
#define NRB_FUNCTION_NVCACHE_POWER_MODE_SET         0x00
#define NRB_FUNCTION_NVCACHE_POWER_MODE_RETURN  0x01
#define NRB_FUNCTION_FLUSH_NVCACHE              0x14
#define NRB_FUNCTION_QUERY_PINNED_SET           0x12
#define NRB_FUNCTION_QUERY_CACHE_MISS           0x13
#define NRB_FUNCTION_ADD_LBAS_PINNED_SET        0x10
#define NRB_FUNCTION_REMOVE_LBAS_PINNED_SET     0x11
#define NRB_FUNCTION_QUERY_ASCENDER_STATUS      0xD0
#define NRB_FUNCTION_QUERY_HYBRID_DISK_STATUS   0xD1

#define NRB_SUCCESS                             0
#define NRB_ILLEGAL_REQUEST                     1
#define NRB_INVALID_PARAMETER                   2
#define NRB_INPUT_DATA_OVERRUN                  3
#define NRB_INPUT_DATA_UNDERRUN                 4
#define NRB_OUTPUT_DATA_OVERRUN                 5
#define NRB_OUTPUT_DATA_UNDERRUN                6

typedef struct _NV_FEATURE_PARAMETER{
        USHORT NVPowerModeEnabled;
        USHORT NVParameterReserv1;
        USHORT NVCmdEnabled;
        USHORT NVParameterReserv2;
        USHORT NVPowerModeVer;
        USHORT NVCmdVer;
        ULONG  NVSize;               // in number of LBA
        USHORT NVReadSpeed;          // in MB/s
        USHORT NVWrtSpeed;
        ULONG  DeviceSpinUpTime;             // in second
} NV_FEATURE_PARAMETER, *PNV_FEATURE_PARAMETER;

//
// SCSI port driver capabilities structure.
//

typedef struct _IO_SCSI_CAPABILITIES {

    //
    // Length of this structure
    //

    ULONG Length;

    //
    // Maximum transfer size in single SRB
    //

    ULONG MaximumTransferLength;

    //
    // Maximum number of physical pages per data buffer
    //

    ULONG MaximumPhysicalPages;

    //
    // Async calls from port to class
    //

    ULONG SupportedAsynchronousEvents;

    //
    // Alignment mask for data transfers.
    //

    ULONG AlignmentMask;

    //
    // Supports tagged queuing
    //

    BOOLEAN TaggedQueuing;

    //
    // Host adapter scans down for bios devices.
    //

    BOOLEAN AdapterScansDown;

    //
    // The host adapter uses programmed I/O.
    //

    BOOLEAN AdapterUsesPio;

} IO_SCSI_CAPABILITIES, *PIO_SCSI_CAPABILITIES;

typedef struct _SCSI_ADDRESS {
    ULONG Length;
    UCHAR PortNumber;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
}SCSI_ADDRESS, *PSCSI_ADDRESS;

//
// Define structure for returning crash dump pointers.
//

struct _ADAPTER_OBJECT;
#define DUMP_POINTERS_VERSION_1         1
#define DUMP_POINTERS_VERSION_2         2
#define DUMP_DRIVER_NAME_LENGTH         15

typedef struct _DUMP_POINTERS_VERSION {
    //
    // Dump pointers structure version
    //
    ULONG Version;

    //
    // Dump pointers structure size
    //
    ULONG Size;

} DUMP_POINTERS_VERSION, *PDUMP_POINTERS_VERSION;

typedef struct _DUMP_POINTERS {
    struct _ADAPTER_OBJECT *AdapterObject;
    PVOID MappedRegisterBase;
    PVOID DumpData;
    PVOID CommonBufferVa;
    LARGE_INTEGER CommonBufferPa;
    ULONG CommonBufferSize;
    BOOLEAN AllocateCommonBuffers;
#if (NTDDI_VERSION < NTDDI_WINXP)
    UCHAR Spare1[3];
#else
    BOOLEAN UseDiskDump;
    UCHAR Spare1[2];
#endif
    PVOID DeviceObject;
} DUMP_POINTERS, *PDUMP_POINTERS;

typedef struct _DUMP_POINTERS_EX {
    DUMP_POINTERS_VERSION Header;
    PVOID DumpData;
    PVOID CommonBufferVa;
    ULONG CommonBufferSize;
    BOOLEAN AllocateCommonBuffers;
    PVOID DeviceObject;
    PVOID DriverList;
} DUMP_POINTERS_EX, *PDUMP_POINTERS_EX;

typedef struct _DUMP_DRIVER {

    //
    // Dump driver list from port driver
    //
    PVOID DumpDriverList;

    //
    // Name of the driver to be loaded
    //
    WCHAR DriverName[DUMP_DRIVER_NAME_LENGTH];

    //
    // Driver base name
    //
    WCHAR BaseName[DUMP_DRIVER_NAME_LENGTH];

} DUMP_DRIVER, *PDUMP_DRIVER;


//
// Define values for pass-through DataIn field.
//

#define SCSI_IOCTL_DATA_OUT          0
#define SCSI_IOCTL_DATA_IN           1
#define SCSI_IOCTL_DATA_UNSPECIFIED  2

//
// Define values for MPIO-pass-through-path Flags field.
//

#define MPIO_IOCTL_FLAG_USE_PATHID      1
#define MPIO_IOCTL_FLAG_USE_SCSIADDRESS 2
#define MPIO_IOCTL_FLAG_INVOLVE_DSM     4

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntdef.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    ntdef.h

Abstract:

    Type definitions for the basic types.


--*/

#ifndef _NTDEF_
#define _NTDEF_

#if _MSC_VER > 1000
#pragma once
#endif

#include <ctype.h>  // winnt ntndis

// begin_ntminiport begin_ntndis begin_ntminitape

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef NOTHING
#define NOTHING
#endif

#ifndef CRITICAL
#define CRITICAL
#endif

#ifndef ANYSIZE_ARRAY
#define ANYSIZE_ARRAY 1       // winnt
#endif

// begin_winnt

//
// For compilers that don't support nameless unions/structs
//
#ifndef DUMMYUNIONNAME
#if defined(NONAMELESSUNION) || !defined(_MSC_EXTENSIONS)
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#define DUMMYUNIONNAME4  u4
#define DUMMYUNIONNAME5  u5
#define DUMMYUNIONNAME6  u6
#define DUMMYUNIONNAME7  u7
#define DUMMYUNIONNAME8  u8
#define DUMMYUNIONNAME9  u9
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#define DUMMYUNIONNAME4
#define DUMMYUNIONNAME5
#define DUMMYUNIONNAME6
#define DUMMYUNIONNAME7
#define DUMMYUNIONNAME8
#define DUMMYUNIONNAME9
#endif
#endif // DUMMYUNIONNAME

#ifndef DUMMYSTRUCTNAME
#if defined(NONAMELESSUNION) || !defined(_MSC_EXTENSIONS)
#define DUMMYSTRUCTNAME  s
#define DUMMYSTRUCTNAME2 s2
#define DUMMYSTRUCTNAME3 s3
#define DUMMYSTRUCTNAME4 s4
#define DUMMYSTRUCTNAME5 s5
#else
#define DUMMYSTRUCTNAME
#define DUMMYSTRUCTNAME2
#define DUMMYSTRUCTNAME3
#define DUMMYSTRUCTNAME4
#define DUMMYSTRUCTNAME5
#endif
#endif // DUMMYSTRUCTNAME

#include <specstrings.h>

#if defined(STRICT_GS_ENABLED)
#pragma strict_gs_check(push, on)
#endif

#if defined(_M_MRX000) && !(defined(MIDL_PASS) || defined(RC_INVOKED)) && defined(ENABLE_RESTRICTED)
#define RESTRICTED_POINTER __restrict
#else
#define RESTRICTED_POINTER
#endif

#if defined(_M_MRX000) || defined(_M_ALPHA) || defined(_M_PPC) || defined(_M_IA64) || defined(_M_AMD64)
#define ALIGNMENT_MACHINE
#define UNALIGNED __unaligned
#if defined(_WIN64)
#define UNALIGNED64 __unaligned
#else
#define UNALIGNED64
#endif
#else
#undef ALIGNMENT_MACHINE
#define UNALIGNED
#define UNALIGNED64
#endif


#if defined(_WIN64) || defined(_M_ALPHA)
#define MAX_NATURAL_ALIGNMENT sizeof(ULONGLONG)
#define MEMORY_ALLOCATION_ALIGNMENT 16
#else
#define MAX_NATURAL_ALIGNMENT sizeof(ULONG)
#define MEMORY_ALLOCATION_ALIGNMENT 8
#endif

//
// TYPE_ALIGNMENT will return the alignment requirements of a given type for
// the current platform.
//

#ifdef __cplusplus
#if _MSC_VER >= 1300
#define TYPE_ALIGNMENT( t ) __alignof(t)
#endif
#else
#define TYPE_ALIGNMENT( t ) \
    FIELD_OFFSET( struct { char x; t test; }, test )
#endif

#if defined(_WIN64)

#if defined(_AMD64_)
#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )
#elif defined(_IA64_)
#define PROBE_ALIGNMENT( _s ) (TYPE_ALIGNMENT( _s ) > TYPE_ALIGNMENT( ULONG ) ? \
                              TYPE_ALIGNMENT( _s ) : TYPE_ALIGNMENT( ULONG ))
#else
#error "No Target Architecture"
#endif

#define PROBE_ALIGNMENT32( _s ) TYPE_ALIGNMENT( ULONG )

#else

#define PROBE_ALIGNMENT( _s ) TYPE_ALIGNMENT( ULONG )

#endif

//
// C_ASSERT() can be used to perform many compile-time assertions:
//            type sizes, field offsets, etc.
//
// An assertion failure results in error C2118: negative subscript.
//

#ifndef SORTPP_PASS
#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]
#else
#define C_ASSERT(e) /* nothing */
#endif

#include <basetsd.h>

// end_winnt

#ifndef CONST
#define CONST               const
#endif

// begin_winnt

#if (defined(_M_IX86) || defined(_M_IA64) || defined(_M_AMD64)) && !defined(MIDL_PASS)
#define DECLSPEC_IMPORT __declspec(dllimport)
#else
#define DECLSPEC_IMPORT
#endif

#ifndef DECLSPEC_NORETURN
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NORETURN   __declspec(noreturn)
#else
#define DECLSPEC_NORETURN
#endif
#endif

#ifndef DECLSPEC_NOTHROW
#if (_MSC_VER >= 1200) && !defined(MIDL_PASS)
#define DECLSPEC_NOTHROW   __declspec(nothrow)
#else
#define DECLSPEC_NOTHROW
#endif
#endif

#ifndef DECLSPEC_ALIGN
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_ALIGN(x)   __declspec(align(x))
#else
#define DECLSPEC_ALIGN(x)
#endif
#endif

#ifndef SYSTEM_CACHE_ALIGNMENT_SIZE
#if defined(_AMD64_) || defined(_X86_)
#define SYSTEM_CACHE_ALIGNMENT_SIZE 64
#else
#define SYSTEM_CACHE_ALIGNMENT_SIZE 128
#endif
#endif

#ifndef DECLSPEC_CACHEALIGN
#define DECLSPEC_CACHEALIGN DECLSPEC_ALIGN(SYSTEM_CACHE_ALIGNMENT_SIZE)
#endif

#ifndef DECLSPEC_UUID
#if (_MSC_VER >= 1100) && defined (__cplusplus)
#define DECLSPEC_UUID(x)    __declspec(uuid(x))
#else
#define DECLSPEC_UUID(x)
#endif
#endif

#ifndef DECLSPEC_NOVTABLE
#if (_MSC_VER >= 1100) && defined(__cplusplus)
#define DECLSPEC_NOVTABLE   __declspec(novtable)
#else
#define DECLSPEC_NOVTABLE
#endif
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

#ifndef NOP_FUNCTION
#if (_MSC_VER >= 1210)
#define NOP_FUNCTION __noop
#else
#define NOP_FUNCTION (void)0
#endif
#endif

#ifndef DECLSPEC_ADDRSAFE
#if (_MSC_VER >= 1200) && (defined(_M_ALPHA) || defined(_M_AXP64))
#define DECLSPEC_ADDRSAFE  __declspec(address_safe)
#else
#define DECLSPEC_ADDRSAFE
#endif
#endif

#ifndef DECLSPEC_NOINLINE
#if (_MSC_VER >= 1300)
#define DECLSPEC_NOINLINE  __declspec(noinline)
#else
#define DECLSPEC_NOINLINE
#endif
#endif

#ifndef FORCEINLINE
#if (_MSC_VER >= 1200)
#define FORCEINLINE __forceinline
#else
#define FORCEINLINE __inline
#endif
#endif

#ifndef DECLSPEC_DEPRECATED
#if (_MSC_VER >= 1300) && !defined(MIDL_PASS)
#define DECLSPEC_DEPRECATED   __declspec(deprecated)
#define DEPRECATE_SUPPORTED
#else
#define DECLSPEC_DEPRECATED
#undef  DEPRECATE_SUPPORTED
#endif
#endif

#ifdef DEPRECATE_DDK_FUNCTIONS
#ifdef _NTDDK_
#define DECLSPEC_DEPRECATED_DDK DECLSPEC_DEPRECATED
#ifdef DEPRECATE_SUPPORTED
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 1
#endif
#else
#define DECLSPEC_DEPRECATED_DDK
#define PRAGMA_DEPRECATED_DDK 0
#endif

//
// Void
//

typedef void *PVOID;
typedef void * POINTER_64 PVOID64;

// end_winnt

#ifndef _MANAGED
#if defined(_M_IX86)
#define FASTCALL __fastcall
#else
#define FASTCALL
#endif
#else
#define FASTCALL NTAPI
#endif

// end_ntminiport end_ntndis end_ntminitape

// begin_winnt begin_ntndis

#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define NTAPI __stdcall
#else
#define _cdecl
#define __cdecl
#define NTAPI
#endif

#if !defined(_M_CEE_PURE)
#define NTAPI_INLINE    NTAPI
#else
#define NTAPI_INLINE
#endif

//
// Define API decoration for direct importing system DLL references.
//

#if !defined(_NTSYSTEM_)
#define NTSYSAPI     DECLSPEC_IMPORT
#define NTSYSCALLAPI DECLSPEC_IMPORT
#else
#define NTSYSAPI
#if defined(_NTDLLBUILD_)
#define NTSYSCALLAPI
#else
#define NTSYSCALLAPI DECLSPEC_ADDRSAFE
#endif

#endif

// end_winnt end_ntndis

// begin_winnt begin_ntminiport begin_ntndis begin_ntminitape

//
// Basics
//

#ifndef VOID
#define VOID void
typedef char CHAR;
typedef short SHORT;
typedef long LONG;
#if !defined(MIDL_PASS)
typedef int INT;
#endif
#endif

//
// UNICODE (Wide Character) types
//

#ifndef _MAC
typedef wchar_t WCHAR;    // wc,   16-bit UNICODE character
#else
// some Macintosh compilers don't define wchar_t in a convenient location, or define it as a char
typedef unsigned short WCHAR;    // wc,   16-bit UNICODE character
#endif

typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef CONST WCHAR *LPCWCH, *PCWCH;
typedef __nullterminated WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef __nullterminated PWSTR *PZPWSTR;
typedef __nullterminated CONST PWSTR *PCZPWSTR;
typedef __nullterminated WCHAR UNALIGNED *LPUWSTR, *PUWSTR;
typedef __nullterminated CONST WCHAR *LPCWSTR, *PCWSTR;
typedef __nullterminated PCWSTR *PZPCWSTR;
typedef __nullterminated CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;


#if _WIN32_WINNT >= 0x0600 || (defined(__cplusplus) && defined(WINDOWS_ENABLE_CPLUSPLUS))

typedef CONST WCHAR *LPCWCHAR, *PCWCHAR;
typedef CONST WCHAR UNALIGNED *LPCUWCHAR, *PCUWCHAR;

//
//  UCS (Universal Character Set) types
//

typedef unsigned long UCSCHAR;

//
//  Even pre-Unicode agreement, UCS values are always in the
//  range U+00000000 to U+7FFFFFFF, so we'll pick an obvious
//  value.

#define UCSCHAR_INVALID_CHARACTER (0xffffffff)

#define MIN_UCSCHAR (0)

//
//  We'll assume here that the ISO-10646 / Unicode agreement
//  not to assign code points after U+0010FFFF holds so that
//  we do not have to have separate "UCSCHAR" and "UNICODECHAR"
//  types.
//

#define MAX_UCSCHAR (0x0010FFFF)

typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;

typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR UNALIGNED *PUUCSSTR;

typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR UNALIGNED *PCUUCSSTR;

typedef UCSCHAR UNALIGNED *PUUCSCHAR;
typedef const UCSCHAR UNALIGNED *PCUUCSCHAR;

#endif // _WIN32_WINNT >= 0x0600


//
// ANSI (Multi-byte Character) types
//
typedef CHAR *PCHAR, *LPCH, *PCH;
typedef CONST CHAR *LPCCH, *PCCH;

typedef __nullterminated CHAR *NPSTR, *LPSTR, *PSTR;
typedef __nullterminated PSTR *PZPSTR;
typedef __nullterminated CONST PSTR *PCZPSTR;
typedef __nullterminated CONST CHAR *LPCSTR, *PCSTR;
typedef __nullterminated PCSTR *PZPCSTR;

//
// Neutral ANSI/UNICODE types and macros
//
#ifdef  UNICODE                     // r_winnt

#ifndef _TCHAR_DEFINED
typedef WCHAR TCHAR, *PTCHAR;
typedef WCHAR TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPWCH LPTCH, PTCH;
typedef LPWSTR PTSTR, LPTSTR;
typedef LPCWSTR PCTSTR, LPCTSTR;
typedef LPUWSTR PUTSTR, LPUTSTR;
typedef LPCUWSTR PCUTSTR, LPCUTSTR;
typedef LPWSTR LP;
#define __TEXT(quote) L##quote      // r_winnt

#else   /* UNICODE */               // r_winnt

#ifndef _TCHAR_DEFINED
typedef char TCHAR, *PTCHAR;
typedef unsigned char TUCHAR, *PTUCHAR;
#define _TCHAR_DEFINED
#endif /* !_TCHAR_DEFINED */

typedef LPCH LPTCH, PTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
#define __TEXT(quote) quote         // r_winnt

#endif /* UNICODE */                // r_winnt
#define TEXT(quote) __TEXT(quote)   // r_winnt


// end_winnt

//
// The type QUAD and UQUAD are intended to use when a 8 byte aligned structure
// is required, but it is not a floating point number.
//

typedef double DOUBLE;

typedef struct _QUAD {
    union {
        __int64 UseThisFieldToCopy;
        double  DoNotUseThisField;
    } DUMMYUNIONNAME;

} QUAD;

//
// Pointer to Basics
//

typedef SHORT *PSHORT;  // winnt
typedef LONG *PLONG;    // winnt
typedef QUAD *PQUAD;

//
// Unsigned Basics
//

// Tell windef.h that some types are already defined.
#define BASETYPES

typedef unsigned char UCHAR;
typedef unsigned short USHORT;
typedef unsigned long ULONG;
typedef QUAD UQUAD;

//
// Pointer to Unsigned Basics
//

typedef UCHAR *PUCHAR;
typedef USHORT *PUSHORT;
typedef ULONG *PULONG;
typedef UQUAD *PUQUAD;

#if _WIN32_WINNT >= 0x0600 || (defined(__cplusplus) && defined(WINDOWS_ENABLE_CPLUSPLUS))

//
// Pointer to Const Unsigned Basics
//

typedef CONST UCHAR *PCUCHAR;
typedef CONST USHORT *PCUSHORT;
typedef CONST ULONG *PCULONG;
typedef CONST UQUAD *PCUQUAD;

#endif // _WIN32_WINNT >= 0x0600

//
// Signed characters
//

typedef signed char SCHAR;
typedef SCHAR *PSCHAR;

#if _WIN32_WINNT >= 0x0600 || (defined(__cplusplus) && defined(WINDOWS_ENABLE_CPLUSPLUS))

typedef CONST SCHAR *PCSCHAR;

#endif // _WIN32_WINNT >= 0x0600

#ifndef NO_STRICT
#ifndef STRICT
#define STRICT 1
#endif
#endif

//
// Handle to an Object
//

// begin_winnt

#ifdef STRICT
typedef void *HANDLE;
#if 0 && (_MSC_VER > 1000)
#define DECLARE_HANDLE(name) struct name##__; typedef struct name##__ *name
#else
#define DECLARE_HANDLE(name) struct name##__{int unused;}; typedef struct name##__ *name
#endif
#else
typedef PVOID HANDLE;
#define DECLARE_HANDLE(name) typedef HANDLE name
#endif
typedef HANDLE *PHANDLE;

//
// Flag (bit) fields
//

typedef UCHAR  FCHAR;
typedef USHORT FSHORT;
typedef ULONG  FLONG;

// Component Object Model defines, and macros

#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
#ifdef __midl
typedef LONG HRESULT;
#else
typedef __success(return >= 0) long HRESULT;
#endif // __midl
#endif // !_HRESULT_DEFINED

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#if defined(_WIN32) || defined(_MPPC_)

// Win32 doesn't support __export

#ifdef _68K_
#define STDMETHODCALLTYPE       __cdecl
#else
#define STDMETHODCALLTYPE       __stdcall
#endif
#define STDMETHODVCALLTYPE      __cdecl

#define STDAPICALLTYPE          __stdcall
#define STDAPIVCALLTYPE         __cdecl

#else

#define STDMETHODCALLTYPE       __export __stdcall
#define STDMETHODVCALLTYPE      __export __cdecl

#define STDAPICALLTYPE          __export __stdcall
#define STDAPIVCALLTYPE         __export __cdecl

#endif


#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE

#define STDOVERRIDEMETHODIMP        __override STDMETHODIMP
#define STDOVERRIDEMETHODIMP_(type) __override STDMETHODIMP_(type)

#define IFACEMETHODIMP          __override STDMETHODIMP
#define IFACEMETHODIMP_(type)   __override STDMETHODIMP_(type)

// The 'V' versions allow Variable Argument lists.

#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE

#define STDMETHODIMPV           HRESULT STDMETHODVCALLTYPE
#define STDMETHODIMPV_(type)    type STDMETHODVCALLTYPE

#define STDOVERRIDEMETHODIMPV        __override STDMETHODIMPV
#define STDOVERRIDEMETHODIMPV_(type) __override STDMETHODIMPV_(type)

#define IFACEMETHODIMPV          __override STDMETHODIMPV
#define IFACEMETHODIMPV_(type)   __override STDMETHODIMPV_(type)

// end_winnt


//
// Low order two bits of a handle are ignored by the system and available
// for use by application code as tag bits.  The remaining bits are opaque
// and used to store a serial number and table index.
//

#define OBJ_HANDLE_TAGBITS  0x00000003L

//
// Cardinal Data Types [0 - 2**N-2)
//

typedef char CCHAR;          // winnt
typedef short CSHORT;
typedef ULONG CLONG;

typedef CCHAR *PCCHAR;
typedef CSHORT *PCSHORT;
typedef CLONG *PCLONG;

// end_ntminiport end_ntndis end_ntminitape

//
// NLS basics (Locale and Language Ids)
//

typedef ULONG LCID;         // winnt
typedef PULONG PLCID;       // winnt
typedef USHORT LANGID;      // winnt

//
// Compartment identifier
//

typedef enum {
    UNSPECIFIED_COMPARTMENT_ID = 0,
    DEFAULT_COMPARTMENT_ID
} COMPARTMENT_ID, *PCOMPARTMENT_ID;

//
// Logical Data Type - These are 32-bit logical values.
//

typedef ULONG LOGICAL;
typedef ULONG *PLOGICAL;

// begin_ntndis begin_windbgkd
//
// NTSTATUS
//

typedef __success(return >= 0) LONG NTSTATUS;
/*lint -save -e624 */  // Don't complain about different typedefs.
typedef NTSTATUS *PNTSTATUS;
/*lint -restore */  // Resume checking for different typedefs.

#if _WIN32_WINNT >= 0x0600
typedef CONST NTSTATUS *PCNTSTATUS;
#endif // _WIN32_WINNT >= 0x0600

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) (((NTSTATUS)(Status)) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((((ULONG)(Status)) >> 30) == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((((ULONG)(Status)) >> 30) == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((((ULONG)(Status)) >> 30) == 3)

// end_windbgkd
// begin_winnt
#define APPLICATION_ERROR_MASK       0x20000000
#define ERROR_SEVERITY_SUCCESS       0x00000000
#define ERROR_SEVERITY_INFORMATIONAL 0x40000000
#define ERROR_SEVERITY_WARNING       0x80000000
#define ERROR_SEVERITY_ERROR         0xC0000000
// end_winnt

#ifndef __SECSTATUS_DEFINED__
typedef long SECURITY_STATUS;
#define __SECSTATUS_DEFINED__
#endif


// end_ntndis
//
// Large (64-bit) integer types and operations
//

#define TIME LARGE_INTEGER
#define _TIME _LARGE_INTEGER
#define PTIME PLARGE_INTEGER
#define LowTime LowPart
#define HighTime HighPart

// begin_winnt

//
// _M_IX86 included so that EM CONTEXT structure compiles with
// x86 programs. *** TBD should this be for all architectures?
//

//
// 16 byte aligned type for 128 bit floats
//

//
// For we define a 128 bit structure and use __declspec(align(16)) pragma to
// align to 128 bits.
//

#if defined(_M_IA64) && !defined(MIDL_PASS)
__declspec(align(16))
#endif
typedef struct _FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} FLOAT128;

typedef FLOAT128 *PFLOAT128;

// end_winnt


// begin_winnt begin_ntminiport begin_ntndis begin_ntminitape

//
// __int64 is only supported by 2.0 and later midl.
// __midl is set by the 2.0 midl and not by 1.0 midl.
//

#define _ULONGLONG_
#if (!defined (_MAC) && (!defined(MIDL_PASS) || defined(__midl)) && (!defined(_M_IX86) || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 64)))
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                         (0x7fffffffffffffff)


#else

#if defined(_MAC) && defined(_MAC_INT_64)
typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;

#define MAXLONGLONG                      (0x7fffffffffffffff)


#else
typedef double LONGLONG;
typedef double ULONGLONG;
#endif //_MAC and int64

#endif

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;

// Update Sequence Number

typedef LONGLONG USN;

#if defined(MIDL_PASS)
typedef struct _LARGE_INTEGER {
#else // MIDL_PASS
typedef union _LARGE_INTEGER {
    struct {
        ULONG LowPart;
        LONG HighPart;
    } DUMMYSTRUCTNAME;
    struct {
        ULONG LowPart;
        LONG HighPart;
    } u;
#endif //MIDL_PASS
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;

#if defined(MIDL_PASS)
typedef struct _ULARGE_INTEGER {
#else // MIDL_PASS
typedef union _ULARGE_INTEGER {
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } DUMMYSTRUCTNAME;
    struct {
        ULONG LowPart;
        ULONG HighPart;
    } u;
#endif //MIDL_PASS
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;

// end_ntminiport end_ntndis end_ntminitape


//
// Locally Unique Identifier
//

typedef struct _LUID {
    ULONG LowPart;
    LONG HighPart;
} LUID, *PLUID;

#define _DWORDLONG_
typedef ULONGLONG  DWORDLONG;
typedef DWORDLONG *PDWORDLONG;

// end_winnt

// begin_ntminiport begin_ntndis

//
// Physical address.
//

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;

// end_ntminiport end_ntndis

// begin_winnt

//
// Define operations to logically shift an int64 by 0..31 bits and to multiply
// 32-bits by 32-bits to form a 64-bit product.
//

#if defined(MIDL_PASS) || defined(RC_INVOKED) || defined(_M_CEE_PURE) \
    || defined(_68K_) || defined(_MPPC_) \
    || defined(_M_IA64) || defined(_M_AMD64)

//
// Midl does not understand inline assembler. Therefore, the Rtl functions
// are used for shifts by 0..31 and multiplies of 32-bits times 32-bits to
// form a 64-bit product.
//
//
// IA64 and AMD64 have native 64-bit operations that are just as fast as their
// 32-bit counter parts. Therefore, the int64 data type is used directly to form
// shifts of 0..31 and multiplies of 32-bits times 32-bits to form a 64-bit
// product.
//

#define Int32x32To64(a, b)  (((__int64)((long)(a))) * ((__int64)((long)(b))))
#define UInt32x32To64(a, b) (((unsigned __int64)((unsigned int)(a))) * ((unsigned __int64)((unsigned int)(b))))

#define Int64ShllMod32(a, b) (((unsigned __int64)(a)) << (b))
#define Int64ShraMod32(a, b) (((__int64)(a)) >> (b))
#define Int64ShrlMod32(a, b) (((unsigned __int64)(a)) >> (b))


#elif defined(_M_IX86)

//
// The x86 C compiler understands inline assembler. Therefore, inline functions
// that employ inline assembler are used for shifts of 0..31.  The multiplies
// rely on the compiler recognizing the cast of the multiplicand to int64 to
// generate the optimal code inline.
//

#define Int32x32To64(a, b)  ((__int64)(((__int64)((long)(a))) * ((long)(b))))
#define UInt32x32To64(a, b) ((unsigned __int64)(((unsigned __int64)((unsigned int)(a))) * ((unsigned int)(b))))


ULONGLONG
NTAPI
Int64ShllMod32 (
    ULONGLONG Value,
    ULONG ShiftCount
    );

LONGLONG
NTAPI
Int64ShraMod32 (
    LONGLONG Value,
    ULONG ShiftCount
    );

ULONGLONG
NTAPI
Int64ShrlMod32 (
    ULONGLONG Value,
    ULONG ShiftCount
    );

#if _MSC_VER >= 1200
#pragma warning(push)
#endif
#pragma warning(disable:4035 4793)               // re-enable below

__inline ULONGLONG
NTAPI
Int64ShllMod32 (
    ULONGLONG Value,
    ULONG ShiftCount
    )
{
    __asm    {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    }
}

__inline LONGLONG
NTAPI
Int64ShraMod32 (
    LONGLONG Value,
    ULONG ShiftCount
    )
{
    __asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    }
}

__inline ULONGLONG
NTAPI
Int64ShrlMod32 (
    ULONGLONG Value,
    ULONG ShiftCount
    )
{
    __asm    {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    }
}

#if _MSC_VER >= 1200
#pragma warning(pop)
#else
#pragma warning(default:4035 4793)
#endif

#else

#error Must define a target architecture.

#endif

//
// Define rotate intrinsics.
//

#ifdef __cplusplus
extern "C" {
#endif

#if defined(_M_AMD64)

#define RotateLeft8 _rotl8
#define RotateLeft16 _rotl16
#define RotateRight8 _rotr8
#define RotateRight16 _rotr16

unsigned char
__cdecl
_rotl8 (
    __in unsigned char Value,
    __in unsigned char Shift
    );

unsigned short
__cdecl
_rotl16 (
    __in unsigned short Value,
    __in unsigned char Shift
    );

unsigned char
__cdecl
_rotr8 (
    __in unsigned char Value,
    __in unsigned char Shift
    );

unsigned short
__cdecl
_rotr16 (
    __in unsigned short Value,
    __in unsigned char Shift
    );

#pragma intrinsic(_rotl8)
#pragma intrinsic(_rotl16)
#pragma intrinsic(_rotr8)
#pragma intrinsic(_rotr16)

#endif /* _M_AMD64 */

#if _MSC_VER >= 1300

#define RotateLeft32 _rotl
#define RotateLeft64 _rotl64
#define RotateRight32 _rotr
#define RotateRight64 _rotr64

__checkReturn
unsigned int
__cdecl
_rotl (
    __in unsigned int Value,
    __in int Shift
    );

unsigned __int64
__cdecl
_rotl64 (
    __in unsigned __int64 Value,
    __in int Shift
    );

__checkReturn
unsigned int
__cdecl
_rotr (
    __in unsigned int Value,
    __in int Shift
    );

unsigned __int64
__cdecl
_rotr64 (
    __in unsigned __int64 Value,
    __in int Shift
    );

#pragma intrinsic(_rotl)
#pragma intrinsic(_rotl64)
#pragma intrinsic(_rotr)
#pragma intrinsic(_rotr64)

#endif  /* _MSC_VER >= 1300 */

#ifdef __cplusplus
}
#endif

// end_winnt

//
// Event type
//

typedef enum _EVENT_TYPE {
    NotificationEvent,
    SynchronizationEvent
    } EVENT_TYPE;

//
// Timer type
//

typedef enum _TIMER_TYPE {
    NotificationTimer,
    SynchronizationTimer
    } TIMER_TYPE;

//
// Wait type
//

typedef enum _WAIT_TYPE {
    WaitAll,
    WaitAny
    } WAIT_TYPE;

//
// Pointer to an Asciiz string
//

typedef CHAR *PSZ;
typedef CONST char *PCSZ;

// begin_ntndis
//
// Counted String
//

typedef USHORT RTL_STRING_LENGTH_TYPE;

typedef struct _STRING {
    __maybevalid USHORT Length;
    __maybevalid USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength), length_is(Length) ]
#endif // MIDL_PASS
    __field_bcount_part_opt(MaximumLength, Length) PCHAR Buffer;
} STRING;
typedef STRING *PSTRING;
typedef STRING ANSI_STRING;
typedef PSTRING PANSI_STRING;

typedef STRING OEM_STRING;
typedef PSTRING POEM_STRING;
typedef CONST STRING* PCOEM_STRING;

//
// CONSTCounted String
//

typedef struct _CSTRING {
    USHORT Length;
    USHORT MaximumLength;
    CONST char *Buffer;
} CSTRING;
typedef CSTRING *PCSTRING;
#define ANSI_NULL ((CHAR)0)     // winnt

typedef STRING CANSI_STRING;
typedef PSTRING PCANSI_STRING;

//
// Unicode strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength / 2), length_is((Length) / 2) ] USHORT * Buffer;
#else // MIDL_PASS
    __field_bcount_part(MaximumLength, Length) PWCH   Buffer;
#endif // MIDL_PASS
} UNICODE_STRING;
typedef UNICODE_STRING *PUNICODE_STRING;
typedef const UNICODE_STRING *PCUNICODE_STRING;
#define UNICODE_NULL ((WCHAR)0) // winnt

#if _WIN32_WINNT >= 0x0500

#define UNICODE_STRING_MAX_BYTES ((USHORT) 65534) // winnt
#define UNICODE_STRING_MAX_CHARS (32767) // winnt

#define DECLARE_CONST_UNICODE_STRING(_var, _string) \
const WCHAR _var ## _buffer[] = _string; \
__pragma(warning(push)) \
__pragma(warning(disable:4221)) __pragma(warning(disable:4204)) \
const UNICODE_STRING _var = { sizeof(_string) - sizeof(WCHAR), sizeof(_string), (PWCH) _var ## _buffer } \
__pragma(warning(pop))

#define DECLARE_GLOBAL_CONST_UNICODE_STRING(_var, _str) \
extern const __declspec(selectany) UNICODE_STRING _var = RTL_CONSTANT_STRING(_str)

#define DECLARE_UNICODE_STRING_SIZE(_var, _size) \
WCHAR _var ## _buffer[_size]; \
__pragma(warning(push)) \
__pragma(warning(disable:4221)) __pragma(warning(disable:4204)) \
UNICODE_STRING _var = { 0, _size * sizeof(WCHAR) , _var ## _buffer } \
__pragma(warning(pop))

#endif // _WIN32_WINNT >= 0x0500


// begin_ntminiport begin_ntminitape

//
// Boolean
//

typedef UCHAR BOOLEAN;           // winnt
typedef BOOLEAN *PBOOLEAN;       // winnt

// end_ntminiport end_ntminitape

// begin_winnt
//
//  Doubly linked list structure.  Can be used as either a list head, or
//  as link words.
//

typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY;

//
//  Singly linked list structure. Can be used as either a list head, or
//  as link words.
//

typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;
// end_winnt end_ntndis

// begin_winnt

//
// These are needed for portable debugger support.
//

typedef struct LIST_ENTRY32 {
    ULONG Flink;
    ULONG Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;

// end_winnt


#if !defined(MIDL_PASS)
__inline
void
ListEntry32To64(
    IN PLIST_ENTRY32 l32,
    OUT PLIST_ENTRY64 l64
    )
{
    l64->Flink = (ULONGLONG)(ULONG)l32->Flink;
    l64->Blink = (ULONGLONG)(ULONG)l32->Blink;
}

__inline
void
ListEntry64To32(
    IN PLIST_ENTRY64 l64,
    OUT PLIST_ENTRY32 l32
    )
{
    l32->Flink = (ULONG)l64->Flink;
    l32->Blink = (ULONG)l64->Blink;
}
#endif

typedef struct _STRING32 {
    USHORT   Length;
    USHORT   MaximumLength;
    ULONG  Buffer;
} STRING32;
typedef STRING32 *PSTRING32;

typedef STRING32 UNICODE_STRING32;
typedef UNICODE_STRING32 *PUNICODE_STRING32;

typedef STRING32 ANSI_STRING32;
typedef ANSI_STRING32 *PANSI_STRING32;


typedef struct _STRING64 {
    USHORT   Length;
    USHORT   MaximumLength;
    ULONGLONG  Buffer;
} STRING64;
typedef STRING64 *PSTRING64;

typedef STRING64 UNICODE_STRING64;
typedef UNICODE_STRING64 *PUNICODE_STRING64;

typedef STRING64 ANSI_STRING64;
typedef ANSI_STRING64 *PANSI_STRING64;



//
// Valid values for the Attributes field
//

#define OBJ_INHERIT             0x00000002L
#define OBJ_PERMANENT           0x00000010L
#define OBJ_EXCLUSIVE           0x00000020L
#define OBJ_CASE_INSENSITIVE    0x00000040L
#define OBJ_OPENIF              0x00000080L
#define OBJ_OPENLINK            0x00000100L
#define OBJ_KERNEL_HANDLE       0x00000200L
#define OBJ_FORCE_ACCESS_CHECK  0x00000400L
#define OBJ_VALID_ATTRIBUTES    0x000007F2L

//
// Object Attributes structure
//

typedef struct _OBJECT_ATTRIBUTES64 {
    ULONG Length;
    ULONG64 RootDirectory;
    ULONG64 ObjectName;
    ULONG Attributes;
    ULONG64 SecurityDescriptor;
    ULONG64 SecurityQualityOfService;
} OBJECT_ATTRIBUTES64;
typedef OBJECT_ATTRIBUTES64 *POBJECT_ATTRIBUTES64;
typedef CONST OBJECT_ATTRIBUTES64 *PCOBJECT_ATTRIBUTES64;

typedef struct _OBJECT_ATTRIBUTES32 {
    ULONG Length;
    ULONG RootDirectory;
    ULONG ObjectName;
    ULONG Attributes;
    ULONG SecurityDescriptor;
    ULONG SecurityQualityOfService;
} OBJECT_ATTRIBUTES32;
typedef OBJECT_ATTRIBUTES32 *POBJECT_ATTRIBUTES32;
typedef CONST OBJECT_ATTRIBUTES32 *PCOBJECT_ATTRIBUTES32;

typedef struct _OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PUNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} OBJECT_ATTRIBUTES;
typedef OBJECT_ATTRIBUTES *POBJECT_ATTRIBUTES;
typedef CONST OBJECT_ATTRIBUTES *PCOBJECT_ATTRIBUTES;

//++
//
// VOID
// InitializeObjectAttributes(
//     OUT POBJECT_ATTRIBUTES p,
//     IN PUNICODE_STRING n,
//     IN ULONG a,
//     IN HANDLE r,
//     IN PSECURITY_DESCRIPTOR s
//     )
//
//--

#define InitializeObjectAttributes( p, n, a, r, s ) { \
    (p)->Length = sizeof( OBJECT_ATTRIBUTES );          \
    (p)->RootDirectory = r;                             \
    (p)->Attributes = a;                                \
    (p)->ObjectName = n;                                \
    (p)->SecurityDescriptor = s;                        \
    (p)->SecurityQualityOfService = NULL;               \
    }

// RTL_ to avoid collisions in the global namespace.
// I don't believe there are possible/likely constant RootDirectory
// or SecurityDescriptor values other than NULL, so they are hardcoded.
// As well, the string will generally be const, so we cast that away.
#define RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a) \
    { sizeof(OBJECT_ATTRIBUTES), NULL, RTL_CONST_CAST(PUNICODE_STRING)(n), a, NULL, NULL }

// This synonym is more appropriate for initializing what isn't actually const.
#define RTL_INIT_OBJECT_ATTRIBUTES(n, a) RTL_CONSTANT_OBJECT_ATTRIBUTES(n, a)

// begin_ntminiport begin_ntndis begin_ntminitape

//
// Constants
//

#define FALSE   0
#define TRUE    1

#ifndef NULL
#ifdef __cplusplus
#define NULL    0
#define NULL64  0
#else
#define NULL    ((void *)0)
#define NULL64  ((void * POINTER_64)0)
#endif
#endif // NULL

// end_ntminiport end_ntndis end_ntminitape

// begin_winnt begin_ntndis

#include <guiddef.h>

#ifndef __OBJECTID_DEFINED
#define __OBJECTID_DEFINED

typedef struct  _OBJECTID {     // size is 20
    GUID Lineage;
    ULONG Uniquifier;
} OBJECTID;
#endif // !_OBJECTID_DEFINED

// end_winnt end_ntndis


#define MINCHAR     0x80        // winnt
#define MAXCHAR     0x7f        // winnt
#define MINSHORT    0x8000      // winnt
#define MAXSHORT    0x7fff      // winnt
#define MINLONG     0x80000000  // winnt
#define MAXLONG     0x7fffffff  // winnt
#define MAXUCHAR    0xff        // winnt
#define MAXUSHORT   0xffff      // winnt
#define MAXULONG    0xffffffff  // winnt

//
// Useful Helper Macros
//

// begin_ntndis
//
// Determine if an argument is present by testing the value of the pointer
// to the argument value.
//

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)((ULONG_PTR)(ArgumentPointer)) != (CHAR *)(NULL) )

// begin_winnt begin_ntminiport
//
// Calculate the byte offset of a field in a structure of type type.
//

#define FIELD_OFFSET(type, field)    ((LONG)(LONG_PTR)&(((type *)0)->field))

//
// Calculate the size of a field in a structure of type type, without
// knowing or stating the type of the field.
//
#define RTL_FIELD_SIZE(type, field) (sizeof(((type *)0)->field))

//
// Calculate the size of a structure of type type up through and
// including a field.
//
#define RTL_SIZEOF_THROUGH_FIELD(type, field) \
    (FIELD_OFFSET(type, field) + RTL_FIELD_SIZE(type, field))

//
//  RTL_CONTAINS_FIELD usage:
//
//      if (RTL_CONTAINS_FIELD(pBlock, pBlock->cbSize, dwMumble)) { // safe to use pBlock->dwMumble
//
#define RTL_CONTAINS_FIELD(Struct, Size, Field) \
    ( (((PCHAR)(&(Struct)->Field)) + sizeof((Struct)->Field)) <= (((PCHAR)(Struct))+(Size)) )

//
// Return the number of elements in a statically sized array.
//   ULONG Buffer[100];
//   RTL_NUMBER_OF(Buffer) == 100
// This is also popularly known as: NUMBER_OF, ARRSIZE, _countof, NELEM, etc.
//
#define RTL_NUMBER_OF_V1(A) (sizeof(A)/sizeof((A)[0]))

#if defined(__cplusplus) && \
    !defined(MIDL_PASS) && \
    !defined(RC_INVOKED) && \
    !defined(_PREFAST_) && \
    (_MSC_FULL_VER >= 13009466) && \
    !defined(SORTPP_PASS)
//
// RtlpNumberOf is a function that takes a reference to an array of N Ts.
//
// typedef T array_of_T[N];
// typedef array_of_T &reference_to_array_of_T;
//
// RtlpNumberOf returns a pointer to an array of N chars.
// We could return a reference instead of a pointer but older compilers do not accept that.
//
// typedef char array_of_char[N];
// typedef array_of_char *pointer_to_array_of_char;
//
// sizeof(array_of_char) == N
// sizeof(*pointer_to_array_of_char) == N
//
// pointer_to_array_of_char RtlpNumberOf(reference_to_array_of_T);
//
// We never even call RtlpNumberOf, we just take the size of dereferencing its return type.
// We do not even implement RtlpNumberOf, we just decare it.
//
// Attempts to pass pointers instead of arrays to this macro result in compile time errors.
// That is the point.
//
extern "C++" // templates cannot be declared to have 'C' linkage
template <typename T, size_t N>
char (*RtlpNumberOf( UNALIGNED T (&)[N] ))[N];

#define RTL_NUMBER_OF_V2(A) (sizeof(*RtlpNumberOf(A)))

//
// This does not work with:
//
// void Foo()
// {
//    struct { int x; } y[2];
//    RTL_NUMBER_OF_V2(y); // illegal use of anonymous local type in template instantiation
// }
//
// You must instead do:
//
// struct Foo1 { int x; };
//
// void Foo()
// {
//    Foo1 y[2];
//    RTL_NUMBER_OF_V2(y); // ok
// }
//
// OR
//
// void Foo()
// {
//    struct { int x; } y[2];
//    RTL_NUMBER_OF_V1(y); // ok
// }
//
// OR
//
// void Foo()
// {
//    struct { int x; } y[2];
//    _ARRAYSIZE(y); // ok
// }
//

#else
#define RTL_NUMBER_OF_V2(A) RTL_NUMBER_OF_V1(A)
#endif

#ifdef ENABLE_RTL_NUMBER_OF_V2
#define RTL_NUMBER_OF(A) RTL_NUMBER_OF_V2(A)
#else
#define RTL_NUMBER_OF(A) RTL_NUMBER_OF_V1(A)
#endif

//
// ARRAYSIZE is more readable version of RTL_NUMBER_OF_V2, and uses
// it regardless of ENABLE_RTL_NUMBER_OF_V2
//
// _ARRAYSIZE is a version useful for anonymous types
//
#define ARRAYSIZE(A)    RTL_NUMBER_OF_V2(A)
#define _ARRAYSIZE(A)   RTL_NUMBER_OF_V1(A)

//
// An expression that yields the type of a field in a struct.
//
#define RTL_FIELD_TYPE(type, field) (((type*)0)->field)

// RTL_ to avoid collisions in the global namespace.
//
// Given typedef struct _FOO { BYTE Bar[123]; } FOO;
// RTL_NUMBER_OF_FIELD(FOO, Bar) == 123
//
#define RTL_NUMBER_OF_FIELD(type, field) (RTL_NUMBER_OF(RTL_FIELD_TYPE(type, field)))

//
// eg:
// typedef struct FOO {
//   ULONG Integer;
//   PVOID Pointer;
// } FOO;
//
// RTL_PADDING_BETWEEN_FIELDS(FOO, Integer, Pointer) == 0 for Win32, 4 for Win64
//
#define RTL_PADDING_BETWEEN_FIELDS(T, F1, F2) \
    ((FIELD_OFFSET(T, F2) > FIELD_OFFSET(T, F1)) \
        ? (FIELD_OFFSET(T, F2) - FIELD_OFFSET(T, F1) - RTL_FIELD_SIZE(T, F1)) \
        : (FIELD_OFFSET(T, F1) - FIELD_OFFSET(T, F2) - RTL_FIELD_SIZE(T, F2)))

// RTL_ to avoid collisions in the global namespace.
#if defined(__cplusplus)
#define RTL_CONST_CAST(type) const_cast<type>
#else
#define RTL_CONST_CAST(type) (type)
#endif

// end_winnt
//
// This works "generically" for Unicode and Ansi/Oem strings.
// Usage:
//   const static UNICODE_STRING FooU = RTL_CONSTANT_STRING(L"Foo");
//   const static         STRING Foo  = RTL_CONSTANT_STRING( "Foo");
// instead of the slower:
//   UNICODE_STRING FooU;
//           STRING Foo;
//   RtlInitUnicodeString(&FooU, L"Foo");
//          RtlInitString(&Foo ,  "Foo");
//
// Or:
//   const static char szFoo[] = "Foo";
//   const static STRING sFoo = RTL_CONSTANT_STRING(szFoo);
//
// This will compile without error or warning in C++. C will get a warning.
//
#ifdef __cplusplus
extern "C++"
{
char _RTL_CONSTANT_STRING_type_check(const char *s);
char _RTL_CONSTANT_STRING_type_check(const WCHAR *s);
// __typeof would be desirable here instead of sizeof.
template <size_t N> class _RTL_CONSTANT_STRING_remove_const_template_class;
template <> class _RTL_CONSTANT_STRING_remove_const_template_class<sizeof(char)>  {public: typedef  char T; };
template <> class _RTL_CONSTANT_STRING_remove_const_template_class<sizeof(WCHAR)> {public: typedef WCHAR T; };
#define _RTL_CONSTANT_STRING_remove_const_macro(s) \
    (const_cast<_RTL_CONSTANT_STRING_remove_const_template_class<sizeof((s)[0])>::T*>(s))
}
#else
char _RTL_CONSTANT_STRING_type_check(const void *s);
#define _RTL_CONSTANT_STRING_remove_const_macro(s) (s)
#endif
#define RTL_CONSTANT_STRING(s) \
{ \
    sizeof( s ) - sizeof( (s)[0] ), \
    sizeof( s ) / sizeof(_RTL_CONSTANT_STRING_type_check(s)), \
    _RTL_CONSTANT_STRING_remove_const_macro(s) \
}
// begin_winnt

// like sizeof
// usually this would be * CHAR_BIT, but we don't necessarily have #include <limits.h>
#define RTL_BITS_OF(sizeOfArg) (sizeof(sizeOfArg) * 8)

#define RTL_BITS_OF_FIELD(type, field) (RTL_BITS_OF(RTL_FIELD_TYPE(type, field)))

//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (ULONG_PTR)(&((type *)0)->field)))

// end_ntminiport end_ntndis

//
// Exception handler routine definition.
//

#include <excpt.h>

typedef
EXCEPTION_DISPOSITION
(NTAPI *PEXCEPTION_ROUTINE) (
    IN struct _EXCEPTION_RECORD *ExceptionRecord,
    IN PVOID EstablisherFrame,
    IN OUT struct _CONTEXT *ContextRecord,
    IN OUT PVOID DispatcherContext
    );

// end_winnt
// begin_ntminiport begin_ntndis

//
// Interrupt Request Level (IRQL)
//

typedef UCHAR KIRQL;

typedef KIRQL *PKIRQL;

// end_ntminiport end_ntndis

//
// Product types
//

typedef enum _NT_PRODUCT_TYPE {
    NtProductWinNt = 1,
    NtProductLanManNt,
    NtProductServer
} NT_PRODUCT_TYPE, *PNT_PRODUCT_TYPE;


//
// the bit mask, SharedUserData->SuiteMask, is a ULONG
// so there can be a maximum of 32 entries
// in this enum.
//

typedef enum _SUITE_TYPE {
    SmallBusiness,
    Enterprise,
    BackOffice,
    CommunicationServer,
    TerminalServer,
    SmallBusinessRestricted,
    EmbeddedNT,
    DataCenter,
    SingleUserTS,
    Personal,
    Blade,
    EmbeddedRestricted,
    SecurityAppliance,
    StorageServer,
    ComputeServer,
    WHServer,
    MaxSuiteType
} SUITE_TYPE;

// begin_winnt

#define VER_SERVER_NT                       0x80000000
#define VER_WORKSTATION_NT                  0x40000000
#define VER_SUITE_SMALLBUSINESS             0x00000001
#define VER_SUITE_ENTERPRISE                0x00000002
#define VER_SUITE_BACKOFFICE                0x00000004
#define VER_SUITE_COMMUNICATIONS            0x00000008
#define VER_SUITE_TERMINAL                  0x00000010
#define VER_SUITE_SMALLBUSINESS_RESTRICTED  0x00000020
#define VER_SUITE_EMBEDDEDNT                0x00000040
#define VER_SUITE_DATACENTER                0x00000080
#define VER_SUITE_SINGLEUSERTS              0x00000100
#define VER_SUITE_PERSONAL                  0x00000200
#define VER_SUITE_BLADE                     0x00000400
#define VER_SUITE_EMBEDDED_RESTRICTED       0x00000800
#define VER_SUITE_SECURITY_APPLIANCE        0x00001000
#define VER_SUITE_STORAGE_SERVER            0x00002000
#define VER_SUITE_COMPUTE_SERVER            0x00004000
#define VER_SUITE_WH_SERVER                 0x00008000

// end_winnt

// begin_winnt

//
// Product types
// This list grows with each OS release.
//
// There is no ordering of values to ensure callers
// do an equality test i.e. greater-than and less-than
// comparisons are not useful.
//
// NOTE: Values in this list should never be deleted.
//       When a product-type 'X' gets dropped from a
//       OS release onwards, the value of 'X' continues
//       to be used in the mapping table of GetProductInfo.
//

#define PRODUCT_UNDEFINED                           0x00000000

#define PRODUCT_ULTIMATE                            0x00000001
#define PRODUCT_HOME_BASIC                          0x00000002
#define PRODUCT_HOME_PREMIUM                        0x00000003
#define PRODUCT_ENTERPRISE                          0x00000004
#define PRODUCT_HOME_BASIC_N                        0x00000005
#define PRODUCT_BUSINESS                            0x00000006
#define PRODUCT_STANDARD_SERVER                     0x00000007
#define PRODUCT_DATACENTER_SERVER                   0x00000008
#define PRODUCT_SMALLBUSINESS_SERVER                0x00000009
#define PRODUCT_ENTERPRISE_SERVER                   0x0000000A
#define PRODUCT_STARTER                             0x0000000B
#define PRODUCT_DATACENTER_SERVER_CORE              0x0000000C
#define PRODUCT_STANDARD_SERVER_CORE                0x0000000D
#define PRODUCT_ENTERPRISE_SERVER_CORE              0x0000000E
#define PRODUCT_ENTERPRISE_SERVER_IA64              0x0000000F
#define PRODUCT_BUSINESS_N                          0x00000010
#define PRODUCT_WEB_SERVER                          0x00000011
#define PRODUCT_CLUSTER_SERVER                      0x00000012
#define PRODUCT_HOME_SERVER                         0x00000013
#define PRODUCT_STORAGE_EXPRESS_SERVER              0x00000014
#define PRODUCT_STORAGE_STANDARD_SERVER             0x00000015
#define PRODUCT_STORAGE_WORKGROUP_SERVER            0x00000016
#define PRODUCT_STORAGE_ENTERPRISE_SERVER           0x00000017
#define PRODUCT_SERVER_FOR_SMALLBUSINESS            0x00000018
#define PRODUCT_SMALLBUSINESS_SERVER_PREMIUM        0x00000019
#define PRODUCT_HOME_PREMIUM_N                      0x0000001A
#define PRODUCT_ENTERPRISE_N                        0x0000001B
#define PRODUCT_ULTIMATE_N                          0x0000001C
#define PRODUCT_WEB_SERVER_CORE                     0x0000001D
#define PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT    0x0000001E
#define PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY      0x0000001F
#define PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING     0x00000020
#define PRODUCT_SMALLBUSINESS_SERVER_PRIME          0x00000021
#define PRODUCT_HOME_PREMIUM_SERVER                 0x00000022
#define PRODUCT_SERVER_FOR_SMALLBUSINESS_V          0x00000023
#define PRODUCT_STANDARD_SERVER_V                   0x00000024
#define PRODUCT_DATACENTER_SERVER_V                 0x00000025
#define PRODUCT_ENTERPRISE_SERVER_V                 0x00000026
#define PRODUCT_DATACENTER_SERVER_CORE_V            0x00000027
#define PRODUCT_STANDARD_SERVER_CORE_V              0x00000028
#define PRODUCT_ENTERPRISE_SERVER_CORE_V            0x00000029
#define PRODUCT_HYPERV                              0x0000002A


#define PRODUCT_UNLICENSED                          0xABCDABCD

// end_winnt

// begin_ntminiport begin_winnt begin_ntminitape
#include <sdkddkver.h>
// end_ntminiport end_winnt end_ntminitape

// begin_winnt begin_r_winnt

//
//  Language IDs.
//
//  The following two combinations of primary language ID and
//  sublanguage ID have special semantics:
//
//    Primary Language ID   Sublanguage ID      Result
//    -------------------   ---------------     ------------------------
//    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
//    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
//    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
//    LANG_INVARIANT        SUBLANG_NEUTRAL     Invariant locale
//

//
//  Primary language IDs.
//

#define LANG_NEUTRAL                     0x00
#define LANG_INVARIANT                   0x7f

#define LANG_AFRIKAANS                   0x36
#define LANG_ALBANIAN                    0x1c
#define LANG_ALSATIAN                    0x84
#define LANG_AMHARIC                     0x5e
#define LANG_ARABIC                      0x01
#define LANG_ARMENIAN                    0x2b
#define LANG_ASSAMESE                    0x4d
#define LANG_AZERI                       0x2c
#define LANG_BASHKIR                     0x6d
#define LANG_BASQUE                      0x2d
#define LANG_BELARUSIAN                  0x23
#define LANG_BENGALI                     0x45
#define LANG_BRETON                      0x7e
#define LANG_BOSNIAN                     0x1a   // Use with SUBLANG_BOSNIAN_* Sublanguage IDs
#define LANG_BOSNIAN_NEUTRAL           0x781a   // Use with the ConvertDefaultLocale function
#define LANG_BULGARIAN                   0x02
#define LANG_CATALAN                     0x03
#define LANG_CHINESE                     0x04   // Use with SUBLANG_CHINESE_* Sublanguage IDs
#define LANG_CHINESE_SIMPLIFIED          0x04   // Use with the ConvertDefaultLocale function
#define LANG_CHINESE_TRADITIONAL       0x7c04   // Use with the ConvertDefaultLocale function
#define LANG_CORSICAN                    0x83
#define LANG_CROATIAN                    0x1a
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DARI                        0x8c
#define LANG_DIVEHI                      0x65
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_ESTONIAN                    0x25
#define LANG_FAEROESE                    0x38
#define LANG_FARSI                       0x29   // Deprecated: use LANG_PERSIAN instead
#define LANG_FILIPINO                    0x64
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_FRISIAN                     0x62
#define LANG_GALICIAN                    0x56
#define LANG_GEORGIAN                    0x37
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_GREENLANDIC                 0x6f
#define LANG_GUJARATI                    0x47
#define LANG_HAUSA                       0x68
#define LANG_HEBREW                      0x0d
#define LANG_HINDI                       0x39
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_IGBO                        0x70
#define LANG_INDONESIAN                  0x21
#define LANG_INUKTITUT                   0x5d
#define LANG_IRISH                       0x3c   // Use with the SUBLANG_IRISH_IRELAND Sublanguage ID
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KANNADA                     0x4b
#define LANG_KASHMIRI                    0x60
#define LANG_KAZAK                       0x3f
#define LANG_KHMER                       0x53
#define LANG_KICHE                       0x86
#define LANG_KINYARWANDA                 0x87
#define LANG_KONKANI                     0x57
#define LANG_KOREAN                      0x12
#define LANG_KYRGYZ                      0x40
#define LANG_LAO                         0x54
#define LANG_LATVIAN                     0x26
#define LANG_LITHUANIAN                  0x27
#define LANG_LOWER_SORBIAN               0x2e
#define LANG_LUXEMBOURGISH               0x6e
#define LANG_MACEDONIAN                  0x2f   // the Former Yugoslav Republic of Macedonia
#define LANG_MALAY                       0x3e
#define LANG_MALAYALAM                   0x4c
#define LANG_MALTESE                     0x3a
#define LANG_MANIPURI                    0x58
#define LANG_MAORI                       0x81
#define LANG_MAPUDUNGUN                  0x7a
#define LANG_MARATHI                     0x4e
#define LANG_MOHAWK                      0x7c
#define LANG_MONGOLIAN                   0x50
#define LANG_NEPALI                      0x61
#define LANG_NORWEGIAN                   0x14
#define LANG_OCCITAN                     0x82
#define LANG_ORIYA                       0x48
#define LANG_PASHTO                      0x63
#define LANG_PERSIAN                     0x29
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_PUNJABI                     0x46
#define LANG_QUECHUA                     0x6b
#define LANG_ROMANIAN                    0x18
#define LANG_ROMANSH                     0x17
#define LANG_RUSSIAN                     0x19
#define LANG_SAMI                        0x3b
#define LANG_SANSKRIT                    0x4f
#define LANG_SERBIAN                     0x1a   // Use with the SUBLANG_SERBIAN_* Sublanguage IDs
#define LANG_SERBIAN_NEUTRAL           0x7c1a   // Use with the ConvertDefaultLocale function
#define LANG_SINDHI                      0x59
#define LANG_SINHALESE                   0x5b
#define LANG_SLOVAK                      0x1b
#define LANG_SLOVENIAN                   0x24
#define LANG_SOTHO                       0x6c
#define LANG_SPANISH                     0x0a
#define LANG_SWAHILI                     0x41
#define LANG_SWEDISH                     0x1d
#define LANG_SYRIAC                      0x5a
#define LANG_TAJIK                       0x28
#define LANG_TAMAZIGHT                   0x5f
#define LANG_TAMIL                       0x49
#define LANG_TATAR                       0x44
#define LANG_TELUGU                      0x4a
#define LANG_THAI                        0x1e
#define LANG_TIBETAN                     0x51
#define LANG_TIGRIGNA                    0x73
#define LANG_TSWANA                      0x32
#define LANG_TURKISH                     0x1f
#define LANG_TURKMEN                     0x42
#define LANG_UIGHUR                      0x80
#define LANG_UKRAINIAN                   0x22
#define LANG_UPPER_SORBIAN               0x2e
#define LANG_URDU                        0x20
#define LANG_UZBEK                       0x43
#define LANG_VIETNAMESE                  0x2a
#define LANG_WELSH                       0x52
#define LANG_WOLOF                       0x88
#define LANG_XHOSA                       0x34
#define LANG_YAKUT                       0x85
#define LANG_YI                          0x78
#define LANG_YORUBA                      0x6a
#define LANG_ZULU                        0x35

//
//  Sublanguage IDs.
//
//  The name immediately following SUBLANG_ dictates which primary
//  language ID that sublanguage ID can be combined with to form a
//  valid language ID.
//

#define SUBLANG_NEUTRAL                             0x00    // language neutral
#define SUBLANG_DEFAULT                             0x01    // user default
#define SUBLANG_SYS_DEFAULT                         0x02    // system default
#define SUBLANG_CUSTOM_DEFAULT                      0x03    // default custom language/locale
#define SUBLANG_CUSTOM_UNSPECIFIED                  0x04    // custom language/locale
#define SUBLANG_UI_CUSTOM_DEFAULT                   0x05    // Default custom MUI language/locale


#define SUBLANG_AFRIKAANS_SOUTH_AFRICA              0x01    // Afrikaans (South Africa) 0x0436 af-ZA
#define SUBLANG_ALBANIAN_ALBANIA                    0x01    // Albanian (Albania) 0x041c sq-AL
#define SUBLANG_ALSATIAN_FRANCE                     0x01    // Alsatian (France) 0x0484
#define SUBLANG_AMHARIC_ETHIOPIA                    0x01    // Amharic (Ethiopia) 0x045e
#define SUBLANG_ARABIC_SAUDI_ARABIA                 0x01    // Arabic (Saudi Arabia)
#define SUBLANG_ARABIC_IRAQ                         0x02    // Arabic (Iraq)
#define SUBLANG_ARABIC_EGYPT                        0x03    // Arabic (Egypt)
#define SUBLANG_ARABIC_LIBYA                        0x04    // Arabic (Libya)
#define SUBLANG_ARABIC_ALGERIA                      0x05    // Arabic (Algeria)
#define SUBLANG_ARABIC_MOROCCO                      0x06    // Arabic (Morocco)
#define SUBLANG_ARABIC_TUNISIA                      0x07    // Arabic (Tunisia)
#define SUBLANG_ARABIC_OMAN                         0x08    // Arabic (Oman)
#define SUBLANG_ARABIC_YEMEN                        0x09    // Arabic (Yemen)
#define SUBLANG_ARABIC_SYRIA                        0x0a    // Arabic (Syria)
#define SUBLANG_ARABIC_JORDAN                       0x0b    // Arabic (Jordan)
#define SUBLANG_ARABIC_LEBANON                      0x0c    // Arabic (Lebanon)
#define SUBLANG_ARABIC_KUWAIT                       0x0d    // Arabic (Kuwait)
#define SUBLANG_ARABIC_UAE                          0x0e    // Arabic (U.A.E)
#define SUBLANG_ARABIC_BAHRAIN                      0x0f    // Arabic (Bahrain)
#define SUBLANG_ARABIC_QATAR                        0x10    // Arabic (Qatar)
#define SUBLANG_ARMENIAN_ARMENIA                    0x01    // Armenian (Armenia) 0x042b hy-AM
#define SUBLANG_ASSAMESE_INDIA                      0x01    // Assamese (India) 0x044d
#define SUBLANG_AZERI_LATIN                         0x01    // Azeri (Latin)
#define SUBLANG_AZERI_CYRILLIC                      0x02    // Azeri (Cyrillic)
#define SUBLANG_BASHKIR_RUSSIA                      0x01    // Bashkir (Russia) 0x046d ba-RU
#define SUBLANG_BASQUE_BASQUE                       0x01    // Basque (Basque) 0x042d eu-ES
#define SUBLANG_BELARUSIAN_BELARUS                  0x01    // Belarusian (Belarus) 0x0423 be-BY
#define SUBLANG_BENGALI_INDIA                       0x01    // Bengali (India)
#define SUBLANG_BENGALI_BANGLADESH                  0x02    // Bengali (Bangladesh)
#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_LATIN    0x05    // Bosnian (Bosnia and Herzegovina - Latin) 0x141a bs-BA-Latn
#define SUBLANG_BOSNIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x08    // Bosnian (Bosnia and Herzegovina - Cyrillic) 0x201a bs-BA-Cyrl
#define SUBLANG_BRETON_FRANCE                       0x01    // Breton (France) 0x047e
#define SUBLANG_BULGARIAN_BULGARIA                  0x01    // Bulgarian (Bulgaria) 0x0402
#define SUBLANG_CATALAN_CATALAN                     0x01    // Catalan (Catalan) 0x0403
#define SUBLANG_CHINESE_TRADITIONAL                 0x01    // Chinese (Taiwan) 0x0404 zh-TW
#define SUBLANG_CHINESE_SIMPLIFIED                  0x02    // Chinese (PR China) 0x0804 zh-CN
#define SUBLANG_CHINESE_HONGKONG                    0x03    // Chinese (Hong Kong S.A.R., P.R.C.) 0x0c04 zh-HK
#define SUBLANG_CHINESE_SINGAPORE                   0x04    // Chinese (Singapore) 0x1004 zh-SG
#define SUBLANG_CHINESE_MACAU                       0x05    // Chinese (Macau S.A.R.) 0x1404 zh-MO
#define SUBLANG_CORSICAN_FRANCE                     0x01    // Corsican (France) 0x0483
#define SUBLANG_CZECH_CZECH_REPUBLIC                0x01    // Czech (Czech Republic) 0x0405
#define SUBLANG_CROATIAN_CROATIA                    0x01    // Croatian (Croatia)
#define SUBLANG_CROATIAN_BOSNIA_HERZEGOVINA_LATIN   0x04    // Croatian (Bosnia and Herzegovina - Latin) 0x101a hr-BA
#define SUBLANG_DANISH_DENMARK                      0x01    // Danish (Denmark) 0x0406
#define SUBLANG_DARI_AFGHANISTAN                    0x01    // Dari (Afghanistan)
#define SUBLANG_DIVEHI_MALDIVES                     0x01    // Divehi (Maldives) 0x0465 div-MV
#define SUBLANG_DUTCH                               0x01    // Dutch
#define SUBLANG_DUTCH_BELGIAN                       0x02    // Dutch (Belgian)
#define SUBLANG_ENGLISH_US                          0x01    // English (USA)
#define SUBLANG_ENGLISH_UK                          0x02    // English (UK)
#define SUBLANG_ENGLISH_AUS                         0x03    // English (Australian)
#define SUBLANG_ENGLISH_CAN                         0x04    // English (Canadian)
#define SUBLANG_ENGLISH_NZ                          0x05    // English (New Zealand)
#define SUBLANG_ENGLISH_EIRE                        0x06    // English (Irish)
#define SUBLANG_ENGLISH_SOUTH_AFRICA                0x07    // English (South Africa)
#define SUBLANG_ENGLISH_JAMAICA                     0x08    // English (Jamaica)
#define SUBLANG_ENGLISH_CARIBBEAN                   0x09    // English (Caribbean)
#define SUBLANG_ENGLISH_BELIZE                      0x0a    // English (Belize)
#define SUBLANG_ENGLISH_TRINIDAD                    0x0b    // English (Trinidad)
#define SUBLANG_ENGLISH_ZIMBABWE                    0x0c    // English (Zimbabwe)
#define SUBLANG_ENGLISH_PHILIPPINES                 0x0d    // English (Philippines)
#define SUBLANG_ENGLISH_INDIA                       0x10    // English (India)
#define SUBLANG_ENGLISH_MALAYSIA                    0x11    // English (Malaysia)
#define SUBLANG_ENGLISH_SINGAPORE                   0x12    // English (Singapore)
#define SUBLANG_ESTONIAN_ESTONIA                    0x01    // Estonian (Estonia) 0x0425 et-EE
#define SUBLANG_FAEROESE_FAROE_ISLANDS              0x01    // Faroese (Faroe Islands) 0x0438 fo-FO
#define SUBLANG_FILIPINO_PHILIPPINES                0x01    // Filipino (Philippines) 0x0464 fil-PH
#define SUBLANG_FINNISH_FINLAND                     0x01    // Finnish (Finland) 0x040b
#define SUBLANG_FRENCH                              0x01    // French
#define SUBLANG_FRENCH_BELGIAN                      0x02    // French (Belgian)
#define SUBLANG_FRENCH_CANADIAN                     0x03    // French (Canadian)
#define SUBLANG_FRENCH_SWISS                        0x04    // French (Swiss)
#define SUBLANG_FRENCH_LUXEMBOURG                   0x05    // French (Luxembourg)
#define SUBLANG_FRENCH_MONACO                       0x06    // French (Monaco)
#define SUBLANG_FRISIAN_NETHERLANDS                 0x01    // Frisian (Netherlands) 0x0462 fy-NL
#define SUBLANG_GALICIAN_GALICIAN                   0x01    // Galician (Galician) 0x0456 gl-ES
#define SUBLANG_GEORGIAN_GEORGIA                    0x01    // Georgian (Georgia) 0x0437 ka-GE
#define SUBLANG_GERMAN                              0x01    // German
#define SUBLANG_GERMAN_SWISS                        0x02    // German (Swiss)
#define SUBLANG_GERMAN_AUSTRIAN                     0x03    // German (Austrian)
#define SUBLANG_GERMAN_LUXEMBOURG                   0x04    // German (Luxembourg)
#define SUBLANG_GERMAN_LIECHTENSTEIN                0x05    // German (Liechtenstein)
#define SUBLANG_GREEK_GREECE                        0x01    // Greek (Greece)
#define SUBLANG_GREENLANDIC_GREENLAND               0x01    // Greenlandic (Greenland) 0x046f kl-GL
#define SUBLANG_GUJARATI_INDIA                      0x01    // Gujarati (India (Gujarati Script)) 0x0447 gu-IN
#define SUBLANG_HAUSA_NIGERIA_LATIN                 0x01    // Hausa (Latin, Nigeria) 0x0468 ha-NG-Latn
#define SUBLANG_HEBREW_ISRAEL                       0x01    // Hebrew (Israel) 0x040d
#define SUBLANG_HINDI_INDIA                         0x01    // Hindi (India) 0x0439 hi-IN
#define SUBLANG_HUNGARIAN_HUNGARY                   0x01    // Hungarian (Hungary) 0x040e
#define SUBLANG_ICELANDIC_ICELAND                   0x01    // Icelandic (Iceland) 0x040f
#define SUBLANG_IGBO_NIGERIA                        0x01    // Igbo (Nigeria) 0x0470 ig-NG
#define SUBLANG_INDONESIAN_INDONESIA                0x01    // Indonesian (Indonesia) 0x0421 id-ID
#define SUBLANG_INUKTITUT_CANADA                    0x01    // Inuktitut (Syllabics) (Canada) 0x045d iu-CA-Cans
#define SUBLANG_INUKTITUT_CANADA_LATIN              0x02    // Inuktitut (Canada - Latin)
#define SUBLANG_IRISH_IRELAND                       0x02    // Irish (Ireland)
#define SUBLANG_ITALIAN                             0x01    // Italian
#define SUBLANG_ITALIAN_SWISS                       0x02    // Italian (Swiss)
#define SUBLANG_JAPANESE_JAPAN                      0x01    // Japanese (Japan) 0x0411
#define SUBLANG_KANNADA_INDIA                       0x01    // Kannada (India (Kannada Script)) 0x044b kn-IN
#define SUBLANG_KASHMIRI_SASIA                      0x02    // Kashmiri (South Asia)
#define SUBLANG_KASHMIRI_INDIA                      0x02    // For app compatibility only
#define SUBLANG_KAZAK_KAZAKHSTAN                    0x01    // Kazakh (Kazakhstan) 0x043f kk-KZ
#define SUBLANG_KHMER_CAMBODIA                      0x01    // Khmer (Cambodia) 0x0453 kh-KH
#define SUBLANG_KICHE_GUATEMALA                     0x01    // K'iche (Guatemala)
#define SUBLANG_KINYARWANDA_RWANDA                  0x01    // Kinyarwanda (Rwanda) 0x0487 rw-RW
#define SUBLANG_KONKANI_INDIA                       0x01    // Konkani (India) 0x0457 kok-IN
#define SUBLANG_KOREAN                              0x01    // Korean (Extended Wansung)
#define SUBLANG_KYRGYZ_KYRGYZSTAN                   0x01    // Kyrgyz (Kyrgyzstan) 0x0440 ky-KG
#define SUBLANG_LAO_LAO                             0x01    // Lao (Lao PDR) 0x0454 lo-LA
#define SUBLANG_LATVIAN_LATVIA                      0x01    // Latvian (Latvia) 0x0426 lv-LV
#define SUBLANG_LITHUANIAN                          0x01    // Lithuanian
#define SUBLANG_LOWER_SORBIAN_GERMANY               0x02    // Lower Sorbian (Germany) 0x082e wee-DE
#define SUBLANG_LUXEMBOURGISH_LUXEMBOURG            0x01    // Luxembourgish (Luxembourg) 0x046e lb-LU
#define SUBLANG_MACEDONIAN_MACEDONIA                0x01    // Macedonian (Macedonia (FYROM)) 0x042f mk-MK
#define SUBLANG_MALAY_MALAYSIA                      0x01    // Malay (Malaysia)
#define SUBLANG_MALAY_BRUNEI_DARUSSALAM             0x02    // Malay (Brunei Darussalam)
#define SUBLANG_MALAYALAM_INDIA                     0x01    // Malayalam (India (Malayalam Script) ) 0x044c ml-IN
#define SUBLANG_MALTESE_MALTA                       0x01    // Maltese (Malta) 0x043a mt-MT
#define SUBLANG_MAORI_NEW_ZEALAND                   0x01    // Maori (New Zealand) 0x0481 mi-NZ
#define SUBLANG_MAPUDUNGUN_CHILE                    0x01    // Mapudungun (Chile) 0x047a arn-CL
#define SUBLANG_MARATHI_INDIA                       0x01    // Marathi (India) 0x044e mr-IN
#define SUBLANG_MOHAWK_MOHAWK                       0x01    // Mohawk (Mohawk) 0x047c moh-CA
#define SUBLANG_MONGOLIAN_CYRILLIC_MONGOLIA         0x01    // Mongolian (Cyrillic, Mongolia)
#define SUBLANG_MONGOLIAN_PRC                       0x02    // Mongolian (PRC)
#define SUBLANG_NEPALI_INDIA                        0x02    // Nepali (India)
#define SUBLANG_NEPALI_NEPAL                        0x01    // Nepali (Nepal) 0x0461 ne-NP
#define SUBLANG_NORWEGIAN_BOKMAL                    0x01    // Norwegian (Bokmal)
#define SUBLANG_NORWEGIAN_NYNORSK                   0x02    // Norwegian (Nynorsk)
#define SUBLANG_OCCITAN_FRANCE                      0x01    // Occitan (France) 0x0482 oc-FR
#define SUBLANG_ORIYA_INDIA                         0x01    // Oriya (India (Oriya Script)) 0x0448 or-IN
#define SUBLANG_PASHTO_AFGHANISTAN                  0x01    // Pashto (Afghanistan)
#define SUBLANG_PERSIAN_IRAN                        0x01    // Persian (Iran) 0x0429 fa-IR
#define SUBLANG_POLISH_POLAND                       0x01    // Polish (Poland) 0x0415
#define SUBLANG_PORTUGUESE                          0x02    // Portuguese
#define SUBLANG_PORTUGUESE_BRAZILIAN                0x01    // Portuguese (Brazilian)
#define SUBLANG_PUNJABI_INDIA                       0x01    // Punjabi (India (Gurmukhi Script)) 0x0446 pa-IN
#define SUBLANG_QUECHUA_BOLIVIA                     0x01    // Quechua (Bolivia)
#define SUBLANG_QUECHUA_ECUADOR                     0x02    // Quechua (Ecuador)
#define SUBLANG_QUECHUA_PERU                        0x03    // Quechua (Peru)
#define SUBLANG_ROMANIAN_ROMANIA                    0x01    // Romanian (Romania) 0x0418
#define SUBLANG_ROMANSH_SWITZERLAND                 0x01    // Romansh (Switzerland) 0x0417 rm-CH
#define SUBLANG_RUSSIAN_RUSSIA                      0x01    // Russian (Russia) 0x0419
#define SUBLANG_SAMI_NORTHERN_NORWAY                0x01    // Northern Sami (Norway)
#define SUBLANG_SAMI_NORTHERN_SWEDEN                0x02    // Northern Sami (Sweden)
#define SUBLANG_SAMI_NORTHERN_FINLAND               0x03    // Northern Sami (Finland)
#define SUBLANG_SAMI_LULE_NORWAY                    0x04    // Lule Sami (Norway)
#define SUBLANG_SAMI_LULE_SWEDEN                    0x05    // Lule Sami (Sweden)
#define SUBLANG_SAMI_SOUTHERN_NORWAY                0x06    // Southern Sami (Norway)
#define SUBLANG_SAMI_SOUTHERN_SWEDEN                0x07    // Southern Sami (Sweden)
#define SUBLANG_SAMI_SKOLT_FINLAND                  0x08    // Skolt Sami (Finland)
#define SUBLANG_SAMI_INARI_FINLAND                  0x09    // Inari Sami (Finland)
#define SUBLANG_SANSKRIT_INDIA                      0x01    // Sanskrit (India) 0x044f sa-IN
#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_LATIN    0x06    // Serbian (Bosnia and Herzegovina - Latin)
#define SUBLANG_SERBIAN_BOSNIA_HERZEGOVINA_CYRILLIC 0x07    // Serbian (Bosnia and Herzegovina - Cyrillic)
#define SUBLANG_SERBIAN_CROATIA                     0x01    // Croatian (Croatia) 0x041a hr-HR
#define SUBLANG_SERBIAN_LATIN                       0x02    // Serbian (Latin)
#define SUBLANG_SERBIAN_CYRILLIC                    0x03    // Serbian (Cyrillic)
#define SUBLANG_SINDHI_INDIA                        0x01    // Sindhi (India) reserved 0x0459
#define SUBLANG_SINDHI_PAKISTAN                     0x02    // Sindhi (Pakistan) reserved 0x0859
#define SUBLANG_SINDHI_AFGHANISTAN                  0x02    // For app compatibility only
#define SUBLANG_SINHALESE_SRI_LANKA                 0x01    // Sinhalese (Sri Lanka)
#define SUBLANG_SOTHO_NORTHERN_SOUTH_AFRICA         0x01    // Northern Sotho (South Africa)
#define SUBLANG_SLOVAK_SLOVAKIA                     0x01    // Slovak (Slovakia) 0x041b sk-SK
#define SUBLANG_SLOVENIAN_SLOVENIA                  0x01    // Slovenian (Slovenia) 0x0424 sl-SI
#define SUBLANG_SPANISH                             0x01    // Spanish (Castilian)
#define SUBLANG_SPANISH_MEXICAN                     0x02    // Spanish (Mexican)
#define SUBLANG_SPANISH_MODERN                      0x03    // Spanish (Modern)
#define SUBLANG_SPANISH_GUATEMALA                   0x04    // Spanish (Guatemala)
#define SUBLANG_SPANISH_COSTA_RICA                  0x05    // Spanish (Costa Rica)
#define SUBLANG_SPANISH_PANAMA                      0x06    // Spanish (Panama)
#define SUBLANG_SPANISH_DOMINICAN_REPUBLIC          0x07    // Spanish (Dominican Republic)
#define SUBLANG_SPANISH_VENEZUELA                   0x08    // Spanish (Venezuela)
#define SUBLANG_SPANISH_COLOMBIA                    0x09    // Spanish (Colombia)
#define SUBLANG_SPANISH_PERU                        0x0a    // Spanish (Peru)
#define SUBLANG_SPANISH_ARGENTINA                   0x0b    // Spanish (Argentina)
#define SUBLANG_SPANISH_ECUADOR                     0x0c    // Spanish (Ecuador)
#define SUBLANG_SPANISH_CHILE                       0x0d    // Spanish (Chile)
#define SUBLANG_SPANISH_URUGUAY                     0x0e    // Spanish (Uruguay)
#define SUBLANG_SPANISH_PARAGUAY                    0x0f    // Spanish (Paraguay)
#define SUBLANG_SPANISH_BOLIVIA                     0x10    // Spanish (Bolivia)
#define SUBLANG_SPANISH_EL_SALVADOR                 0x11    // Spanish (El Salvador)
#define SUBLANG_SPANISH_HONDURAS                    0x12    // Spanish (Honduras)
#define SUBLANG_SPANISH_NICARAGUA                   0x13    // Spanish (Nicaragua)
#define SUBLANG_SPANISH_PUERTO_RICO                 0x14    // Spanish (Puerto Rico)
#define SUBLANG_SPANISH_US                          0x15    // Spanish (United States)
#define SUBLANG_SWAHILI_KENYA                       0x01    // Swahili (Kenya) 0x0441 sw-KE
#define SUBLANG_SWEDISH                             0x01    // Swedish
#define SUBLANG_SWEDISH_FINLAND                     0x02    // Swedish (Finland)
#define SUBLANG_SYRIAC_SYRIA                        0x01    // Syriac (Syria) 0x045a syr-SY
#define SUBLANG_TAJIK_TAJIKISTAN                    0x01    // Tajik (Tajikistan) 0x0428 tg-TJ-Cyrl
#define SUBLANG_TAMAZIGHT_ALGERIA_LATIN             0x02    // Tamazight (Latin, Algeria) 0x085f tmz-DZ-Latn
#define SUBLANG_TAMIL_INDIA                         0x01    // Tamil (India)
#define SUBLANG_TATAR_RUSSIA                        0x01    // Tatar (Russia) 0x0444 tt-RU
#define SUBLANG_TELUGU_INDIA                        0x01    // Telugu (India (Telugu Script)) 0x044a te-IN
#define SUBLANG_THAI_THAILAND                       0x01    // Thai (Thailand) 0x041e th-TH
#define SUBLANG_TIBETAN_PRC                         0x01    // Tibetan (PRC)
#define SUBLANG_TIGRIGNA_ERITREA                    0x02    // Tigrigna (Eritrea)
#define SUBLANG_TSWANA_SOUTH_AFRICA                 0x01    // Setswana / Tswana (South Africa) 0x0432 tn-ZA
#define SUBLANG_TURKISH_TURKEY                      0x01    // Turkish (Turkey) 0x041f tr-TR
#define SUBLANG_TURKMEN_TURKMENISTAN                0x01    // Turkmen (Turkmenistan) 0x0442 tk-TM
#define SUBLANG_UIGHUR_PRC                          0x01    // Uighur (PRC) 0x0480 ug-CN
#define SUBLANG_UKRAINIAN_UKRAINE                   0x01    // Ukrainian (Ukraine) 0x0422 uk-UA
#define SUBLANG_UPPER_SORBIAN_GERMANY               0x01    // Upper Sorbian (Germany) 0x042e wen-DE
#define SUBLANG_URDU_PAKISTAN                       0x01    // Urdu (Pakistan)
#define SUBLANG_URDU_INDIA                          0x02    // Urdu (India)
#define SUBLANG_UZBEK_LATIN                         0x01    // Uzbek (Latin)
#define SUBLANG_UZBEK_CYRILLIC                      0x02    // Uzbek (Cyrillic)
#define SUBLANG_VIETNAMESE_VIETNAM                  0x01    // Vietnamese (Vietnam) 0x042a vi-VN
#define SUBLANG_WELSH_UNITED_KINGDOM                0x01    // Welsh (United Kingdom) 0x0452 cy-GB
#define SUBLANG_WOLOF_SENEGAL                       0x01    // Wolof (Senegal)
#define SUBLANG_XHOSA_SOUTH_AFRICA                  0x01    // isiXhosa / Xhosa (South Africa) 0x0434 xh-ZA
#define SUBLANG_YAKUT_RUSSIA                        0x01    // Yakut (Russia) 0x0485 sah-RU
#define SUBLANG_YI_PRC                              0x01    // Yi (PRC)) 0x0478
#define SUBLANG_YORUBA_NIGERIA                      0x01    // Yoruba (Nigeria) 046a yo-NG
#define SUBLANG_ZULU_SOUTH_AFRICA                   0x01    // isiZulu / Zulu (South Africa) 0x0435 zu-ZA




//
//  Sorting IDs.
//

#define SORT_DEFAULT                     0x0     // sorting default

#define SORT_INVARIANT_MATH              0x1     // Invariant (Mathematical Symbols)

#define SORT_JAPANESE_XJIS               0x0     // Japanese XJIS order
#define SORT_JAPANESE_UNICODE            0x1     // Japanese Unicode order (no longer supported)
#define SORT_JAPANESE_RADICALSTROKE      0x4     // Japanese radical/stroke order

#define SORT_CHINESE_BIG5                0x0     // Chinese BIG5 order
#define SORT_CHINESE_PRCP                0x0     // PRC Chinese Phonetic order
#define SORT_CHINESE_UNICODE             0x1     // Chinese Unicode order (no longer supported)
#define SORT_CHINESE_PRC                 0x2     // PRC Chinese Stroke Count order
#define SORT_CHINESE_BOPOMOFO            0x3     // Traditional Chinese Bopomofo order

#define SORT_KOREAN_KSC                  0x0     // Korean KSC order
#define SORT_KOREAN_UNICODE              0x1     // Korean Unicode order (no longer supported)

#define SORT_GERMAN_PHONE_BOOK           0x1     // German Phone Book order

#define SORT_HUNGARIAN_DEFAULT           0x0     // Hungarian Default order
#define SORT_HUNGARIAN_TECHNICAL         0x1     // Hungarian Technical order

#define SORT_GEORGIAN_TRADITIONAL        0x0     // Georgian Traditional order
#define SORT_GEORGIAN_MODERN             0x1     // Georgian Modern order

// end_r_winnt

//
//  A language ID is a 16 bit value which is the combination of a
//  primary language ID and a secondary language ID.  The bits are
//  allocated as follows:
//
//       +-----------------------+-------------------------+
//       |     Sublanguage ID    |   Primary Language ID   |
//       +-----------------------+-------------------------+
//        15                   10 9                       0   bit
//
//
//  Language ID creation/extraction macros:
//
//    MAKELANGID    - construct language id from a primary language id and
//                    a sublanguage id.
//    PRIMARYLANGID - extract primary language id from a language id.
//    SUBLANGID     - extract sublanguage id from a language id.
//

#define MAKELANGID(p, s)       ((((USHORT)(s)) << 10) | (USHORT)(p))
#define PRIMARYLANGID(lgid)    ((USHORT)(lgid) & 0x3ff)
#define SUBLANGID(lgid)        ((USHORT)(lgid) >> 10)


//
//  A locale ID is a 32 bit value which is the combination of a
//  language ID, a sort ID, and a reserved area.  The bits are
//  allocated as follows:
//
//       +-------------+---------+-------------------------+
//       |   Reserved  | Sort ID |      Language ID        |
//       +-------------+---------+-------------------------+
//        31         20 19     16 15                      0   bit
//
//
//  Locale ID creation/extraction macros:
//
//    MAKELCID            - construct the locale id from a language id and a sort id.
//    MAKESORTLCID        - construct the locale id from a language id, sort id, and sort version.
//    LANGIDFROMLCID      - extract the language id from a locale id.
//    SORTIDFROMLCID      - extract the sort id from a locale id.
//    SORTVERSIONFROMLCID - extract the sort version from a locale id.
//

#define NLS_VALID_LOCALE_MASK  0x000fffff

#define MAKELCID(lgid, srtid)  ((ULONG)((((ULONG)((USHORT)(srtid))) << 16) |  \
                                         ((ULONG)((USHORT)(lgid)))))
#define MAKESORTLCID(lgid, srtid, ver)                                            \
                               ((ULONG)((MAKELCID(lgid, srtid)) |             \
                                    (((ULONG)((USHORT)(ver))) << 20)))
#define LANGIDFROMLCID(lcid)   ((USHORT)(lcid))
#define SORTIDFROMLCID(lcid)   ((USHORT)((((ULONG)(lcid)) >> 16) & 0xf))
#define SORTVERSIONFROMLCID(lcid)  ((USHORT)((((ULONG)(lcid)) >> 20) & 0xf))

// 8 characters for language
// 8 characters for region
// 64 characters for suffix (script)
// 2 characters for '-' separators
// 2 characters for prefix like "i-" or "x-"
// 1 null termination
#define LOCALE_NAME_MAX_LENGTH   85

//
//  Default System and User IDs for language and locale.
//

#define LANG_SYSTEM_DEFAULT    (MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT))
#define LANG_USER_DEFAULT      (MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT))

#define LOCALE_SYSTEM_DEFAULT  (MAKELCID(LANG_SYSTEM_DEFAULT, SORT_DEFAULT))
#define LOCALE_USER_DEFAULT    (MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT))

//
//  Other special IDs for language and locale.
//
#define LOCALE_CUSTOM_DEFAULT                                                 \
          (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_CUSTOM_DEFAULT), SORT_DEFAULT))

#define LOCALE_CUSTOM_UNSPECIFIED                                             \
          (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_CUSTOM_UNSPECIFIED), SORT_DEFAULT))

#define LOCALE_CUSTOM_UI_DEFAULT                                              \
          (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_UI_CUSTOM_DEFAULT), SORT_DEFAULT))

#define LOCALE_NEUTRAL                                                        \
          (MAKELCID(MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), SORT_DEFAULT))

#define LOCALE_INVARIANT                                                      \
          (MAKELCID(MAKELANGID(LANG_INVARIANT, SUBLANG_NEUTRAL), SORT_DEFAULT))

// begin_ntminiport begin_ntndis begin_ntminitape

//
// Macros used to eliminate compiler warning generated when formal
// parameters or local variables are not declared.
//
// Use DBG_UNREFERENCED_PARAMETER() when a parameter is not yet
// referenced but will be once the module is completely developed.
//
// Use DBG_UNREFERENCED_LOCAL_VARIABLE() when a local variable is not yet
// referenced but will be once the module is completely developed.
//
// Use UNREFERENCED_PARAMETER() if a parameter will never be referenced.
//
// DBG_UNREFERENCED_PARAMETER and DBG_UNREFERENCED_LOCAL_VARIABLE will
// eventually be made into a null macro to help determine whether there
// is unfinished work.
//

#if ! defined(lint)
#define UNREFERENCED_PARAMETER(P)          (P)
#define DBG_UNREFERENCED_PARAMETER(P)      (P)
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) (V)

#else // lint

// Note: lint -e530 says don't complain about uninitialized variables for
// this varible.  Error 527 has to do with unreachable code.
// -restore restores checking to the -save state

#define UNREFERENCED_PARAMETER(P)          \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_PARAMETER(P)      \
    /*lint -save -e527 -e530 */ \
    { \
        (P) = (P); \
    } \
    /*lint -restore */
#define DBG_UNREFERENCED_LOCAL_VARIABLE(V) \
    /*lint -save -e527 -e530 */ \
    { \
        (V) = (V); \
    } \
    /*lint -restore */

#endif // lint

//
// Macro used to eliminate compiler warning 4715 within a switch statement
// when all possible cases have already been accounted for.
//
// switch (a & 3) {
//     case 0: return 1;
//     case 1: return Foo();
//     case 2: return Bar();
//     case 3: return 1;
//     DEFAULT_UNREACHABLE;
//

#if (_MSC_VER > 1200)
#define DEFAULT_UNREACHABLE default: __assume(0)
#else

//
// Older compilers do not support __assume(), and there is no other free
// method of eliminating the warning.
//

#define DEFAULT_UNREACHABLE

#endif

// end_winnt

//
//  Define standard min and max macros
//

#ifndef NOMINMAX

#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

#endif  // NOMINMAX

// end_ntminiport end_ntndis end_ntminitape

#endif // _NTDEF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NtDsBMsg.h ===
/*
 *	NTDSBMSG.H
 *
 *	Windows NT Directory Service Backup/Restore API error codes
 *	Copyright (C) 1996-1998, Microsoft Corporation
 *	
 */

#ifndef _NTDSBMSG_
#define _NTDSBMSG_

//
//	SUCCESS
//
//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_SYSTEM                  0x0
#define FACILITY_NTDSB                   0x800
#define FACILITY_BACKUP                  0x7FF


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: hrNone
//
// MessageText:
//
// The operation was successful
//
#define hrNone                           ((HRESULT)0x00000000L)

//
//	ERRORS
//
//
// MessageId: hrNyi
//
// MessageText:
//
// The function is not yet implemented
//
#define hrNyi                            ((HRESULT)0xC0000001L)

//
//	Backup errors
//
//
// MessageId: hrInvalidParam
//
// MessageText:
//
// The parameter is not valid.
//
#define hrInvalidParam                   ((HRESULT)0xC7FF0001L)

//
// MessageId: hrError
//
// MessageText:
//
// An internal error has occurred.
//
#define hrError                          ((HRESULT)0xC7FF0002L)

//
// MessageId: hrInvalidHandle
//
// MessageText:
//
// The handle is not valid.
//
#define hrInvalidHandle                  ((HRESULT)0xC7FF0003L)

//
// MessageId: hrRestoreInProgress
//
// MessageText:
//
// The Restore process is already in progress.
//
#define hrRestoreInProgress              ((HRESULT)0xC7FF0004L)

//
// MessageId: hrAlreadyOpen
//
// MessageText:
//
// The file specified is already open.
//
#define hrAlreadyOpen                    ((HRESULT)0xC7FF0005L)

//
// MessageId: hrInvalidRecips
//
// MessageText:
//
// The recipients are invalid.
//
#define hrInvalidRecips                  ((HRESULT)0xC7FF0006L)

//
// MessageId: hrCouldNotConnect
//
// MessageText:
//
// Unable to perform the backup. Either you are not connected to the specified backup server
// or the service you are trying to backup is not running.
//
#define hrCouldNotConnect                ((HRESULT)0xC7FF0007L)

//
// MessageId: hrRestoreMapExists
//
// MessageText:
//
// A restore map already exists for the specified component.  You can only specify
// a restore map when performing a full restore.
//
#define hrRestoreMapExists               ((HRESULT)0xC7FF0008L)

//
// MessageId: hrIncrementalBackupDisabled
//
// MessageText:
//
// Another application has modified the specified Windows NT Directory Service database such that any
// subsequent backups will fail. You must perform a full backup to fix this problem.
//
#define hrIncrementalBackupDisabled      ((HRESULT)0xC7FF0009L)

//
// MessageId: hrLogFileNotFound
//
// MessageText:
//
// Unable to perform an incremental backup because a required Windows NT Directory Service database log file could not be found.
//
#define hrLogFileNotFound                ((HRESULT)0xC7FF000AL)

//
// MessageId: hrCircularLogging
//
// MessageText:
//
// The Windows NT Directory Service component specified is configured to use circular database logs.
// It cannot be backed up without a full backup.
//
#define hrCircularLogging                ((HRESULT)0xC7FF000BL)

//
// MessageId: hrNoFullRestore
//
// MessageText:
//
// The databases have not been restored to this machine. You cannot restore an incremental backup
// until a full backup has been restored.
//
#define hrNoFullRestore                  ((HRESULT)0xC7FF000CL)

//
// MessageId: hrCommunicationError
//
// MessageText:
//
// A communications error occurred while attempting to perform a local backup.
//
#define hrCommunicationError             ((HRESULT)0xC7FF000DL)

//
// MessageId: hrFullBackupNotTaken
//
// MessageText:
//
// You must perform a full backup before you can perform an incremental backup.
//
#define hrFullBackupNotTaken             ((HRESULT)0xC7FF000EL)

//
// MessageId: hrMissingExpiryToken
//
// MessageText:
//
// Expiry token is missing. Cannot restore without knowing the expiry information.
//
#define hrMissingExpiryToken             ((HRESULT)0xC7FF000FL)

//
// MessageId: hrUnknownExpiryTokenFormat
//
// MessageText:
//
// Expiry token is in unrecognizable format.
//
#define hrUnknownExpiryTokenFormat       ((HRESULT)0xC7FF0010L)

//
// MessageId: hrContentsExpired
//
// MessageText:
//
// DS Contents in the backup copy are out of date. Try restoring with a more recent copy.
//
#define hrContentsExpired                ((HRESULT)0xC7FF0011L)

#define	hrAlreadyListening	((HRESULT)RPC_S_ALREADY_LISTENING)
//
//	ERRORS
//
//
// SYSTEM errors
//
//
// MessageId: hrFileClose
//
// MessageText:
//
// Unable to close the DOS file
//
#define hrFileClose                      ((HRESULT)0xC8000066L)

//
// MessageId: hrOutOfThreads
//
// MessageText:
//
// Unable to start a thread because there are none available.
//
#define hrOutOfThreads                   ((HRESULT)0xC8000067L)

//
// MessageId: hrTooManyIO
//
// MessageText:
//
// The system is busy because there are too many I/Os.
//
#define hrTooManyIO                      ((HRESULT)0xC8000069L)

//
//	BUFFER MANAGER errors
//
//
// MessageId: hrBFNotSynchronous
//
// MessageText:
//
// The buffer page has been evicted.
//
#define hrBFNotSynchronous               ((HRESULT)0x880000C8L)

//
// MessageId: hrBFPageNotFound
//
// MessageText:
//
// Unable to find the page.
//
#define hrBFPageNotFound                 ((HRESULT)0x880000C9L)

//
// MessageId: hrBFInUse
//
// MessageText:
//
// Unable to abandon the buffer.
//
#define hrBFInUse                        ((HRESULT)0xC80000CAL)

//
//	DIRECTORY MANAGER errors
//
//
// MessageId: hrPMRecDeleted
//
// MessageText:
//
// The record has been deleted.
//
#define hrPMRecDeleted                   ((HRESULT)0xC800012EL)

//
// MessageId: hrRemainingVersions
//
// MessageText:
//
// There is idle work remaining.
//
#define hrRemainingVersions              ((HRESULT)0x88000141L)

//
//	RECORD MANAGER errors
//
//
// MessageId: hrFLDKeyTooBig
//
// MessageText:
//
// The key was truncated because it exceeded the maximum length.
//
#define hrFLDKeyTooBig                   ((HRESULT)0x88000190L)

//
// MessageId: hrFLDTooManySegments
//
// MessageText:
//
// There are too many key segments.
//
#define hrFLDTooManySegments             ((HRESULT)0xC8000191L)

//
// MessageId: hrFLDNullKey
//
// MessageText:
//
// The key is NULL.
//
#define hrFLDNullKey                     ((HRESULT)0x88000192L)

//
//	LOGGING/RECOVERY errors
//
//
// MessageId: hrLogFileCorrupt
//
// MessageText:
//
// The log file is damaged.
//
#define hrLogFileCorrupt                 ((HRESULT)0xC80001F5L)

//
// MessageId: hrNoBackupDirectory
//
// MessageText:
//
// No backup directory was given.
//
#define hrNoBackupDirectory              ((HRESULT)0xC80001F7L)

//
// MessageId: hrBackupDirectoryNotEmpty
//
// MessageText:
//
// The backup directory is not empty.
//
#define hrBackupDirectoryNotEmpty        ((HRESULT)0xC80001F8L)

//
// MessageId: hrBackupInProgress
//
// MessageText:
//
// Backup is already active.
//
#define hrBackupInProgress               ((HRESULT)0xC80001F9L)

//
// MessageId: hrMissingPreviousLogFile
//
// MessageText:
//
// A log file for the checkpoint is missing.
//
#define hrMissingPreviousLogFile         ((HRESULT)0xC80001FDL)

//
// MessageId: hrLogWriteFail
//
// MessageText:
//
// Unable to write to the log file.
//
#define hrLogWriteFail                   ((HRESULT)0xC80001FEL)

//
// MessageId: hrBadLogVersion
//
// MessageText:
//
// The version of the log file is not compatible with the version of the Windows NT Directory Service database (NTDS).
//
#define hrBadLogVersion                  ((HRESULT)0xC8000202L)

//
// MessageId: hrInvalidLogSequence
//
// MessageText:
//
// The time stamp in the next log does not match what was expected.
//
#define hrInvalidLogSequence             ((HRESULT)0xC8000203L)

//
// MessageId: hrLoggingDisabled
//
// MessageText:
//
// The log is not active.
//
#define hrLoggingDisabled                ((HRESULT)0xC8000204L)

//
// MessageId: hrLogBufferTooSmall
//
// MessageText:
//
// The log buffer is too small to be recovered.
//
#define hrLogBufferTooSmall              ((HRESULT)0xC8000205L)

//
// MessageId: hrLogSequenceEnd
//
// MessageText:
//
// The maximum number of log files has been exceeded.
//
#define hrLogSequenceEnd                 ((HRESULT)0xC8000207L)

//
// MessageId: hrNoBackup
//
// MessageText:
//
// There is no backup in progress.
//
#define hrNoBackup                       ((HRESULT)0xC8000208L)

//
// MessageId: hrInvalidBackupSequence
//
// MessageText:
//
// The backup call is out of sequence.
//
#define hrInvalidBackupSequence          ((HRESULT)0xC8000209L)

//
// MessageId: hrBackupNotAllowedYet
//
// MessageText:
//
// Unable to perform a backup now.
//
#define hrBackupNotAllowedYet            ((HRESULT)0xC800020BL)

//
// MessageId: hrDeleteBackupFileFail
//
// MessageText:
//
// Unable to delete the backup file.
//
#define hrDeleteBackupFileFail           ((HRESULT)0xC800020CL)

//
// MessageId: hrMakeBackupDirectoryFail
//
// MessageText:
//
// Unable to make a backup temporary directory.
//
#define hrMakeBackupDirectoryFail        ((HRESULT)0xC800020DL)

//
// MessageId: hrInvalidBackup
//
// MessageText:
//
// An incremental backup cannot be performed when circular logging is enabled.
//
#define hrInvalidBackup                  ((HRESULT)0xC800020EL)

//
// MessageId: hrRecoveredWithErrors
//
// MessageText:
//
// Errors were encountered during the repair process.
//
#define hrRecoveredWithErrors            ((HRESULT)0xC800020FL)

//
// MessageId: hrMissingLogFile
//
// MessageText:
//
// The current log file is missing.
//
#define hrMissingLogFile                 ((HRESULT)0xC8000210L)

//
// MessageId: hrLogDiskFull
//
// MessageText:
//
// The log disk is full.
//
#define hrLogDiskFull                    ((HRESULT)0xC8000211L)

//
// MessageId: hrBadLogSignature
//
// MessageText:
//
// A log file is damaged.
//
#define hrBadLogSignature                ((HRESULT)0xC8000212L)

//
// MessageId: hrBadDbSignature
//
// MessageText:
//
// A database file is damaged.
//
#define hrBadDbSignature                 ((HRESULT)0xC8000213L)

//
// MessageId: hrBadCheckpointSignature
//
// MessageText:
//
// A checkpoint file is damaged.
//
#define hrBadCheckpointSignature         ((HRESULT)0xC8000214L)

//
// MessageId: hrCheckpointCorrupt
//
// MessageText:
//
// A checkpoint file either could not be found or is damaged.
//
#define hrCheckpointCorrupt              ((HRESULT)0xC8000215L)

//
// MessageId: hrDatabaseInconsistent
//
// MessageText:
//
// The database is damaged.
//
#define hrDatabaseInconsistent           ((HRESULT)0xC8000226L)

//
// MessageId: hrConsistentTimeMismatch
//
// MessageText:
//
// There is a mismatch in the database's last consistent time.
//
#define hrConsistentTimeMismatch         ((HRESULT)0xC8000227L)

//
// MessageId: hrPatchFileMismatch
//
// MessageText:
//
// The patch file is not generated from this backup.
//
#define hrPatchFileMismatch              ((HRESULT)0xC8000228L)

//
// MessageId: hrRestoreLogTooLow
//
// MessageText:
//
// The starting log number is too low for the restore.
//
#define hrRestoreLogTooLow               ((HRESULT)0xC8000229L)

//
// MessageId: hrRestoreLogTooHigh
//
// MessageText:
//
// The starting log number is too high for the restore.
//
#define hrRestoreLogTooHigh              ((HRESULT)0xC800022AL)

//
// MessageId: hrGivenLogFileHasBadSignature
//
// MessageText:
//
// The log file downloaded from the tape is damaged.
//
#define hrGivenLogFileHasBadSignature    ((HRESULT)0xC800022BL)

//
// MessageId: hrGivenLogFileIsNotContiguous
//
// MessageText:
//
// Unable to find a mandatory log file after the tape was downloaded.
//
#define hrGivenLogFileIsNotContiguous    ((HRESULT)0xC800022CL)

//
// MessageId: hrMissingRestoreLogFiles
//
// MessageText:
//
// The data is not fully restored because some log files are missing.
//
#define hrMissingRestoreLogFiles         ((HRESULT)0xC800022DL)

//
// MessageId: hrExistingLogFileHasBadSignature
//
// MessageText:
//
// The log file in the log file path is damaged.
//
#define hrExistingLogFileHasBadSignature ((HRESULT)0x8800022EL)

//
// MessageId: hrExistingLogFileIsNotContiguous
//
// MessageText:
//
// Unable to find a mandatory log file in the log file path.
//
#define hrExistingLogFileIsNotContiguous ((HRESULT)0x8800022FL)

//
// MessageId: hrMissingFullBackup
//
// MessageText:
//
// The database missed a previous full backup before the incremental backup.
//
#define hrMissingFullBackup              ((HRESULT)0xC8000230L)

//
// MessageId: hrBadBackupDatabaseSize
//
// MessageText:
//
// The backup database size must be a multiple of 4K (4096 bytes).
//
#define hrBadBackupDatabaseSize          ((HRESULT)0xC8000231L)

//
// MessageId: hrTermInProgress
//
// MessageText:
//
// The database is being shut down.
//
#define hrTermInProgress                 ((HRESULT)0xC80003E8L)

//
// MessageId: hrFeatureNotAvailable
//
// MessageText:
//
// The feature is not available.
//
#define hrFeatureNotAvailable            ((HRESULT)0xC80003E9L)

//
// MessageId: hrInvalidName
//
// MessageText:
//
// The name is not valid.
//
#define hrInvalidName                    ((HRESULT)0xC80003EAL)

//
// MessageId: hrInvalidParameter
//
// MessageText:
//
// The parameter is not valid.
//
#define hrInvalidParameter               ((HRESULT)0xC80003EBL)

//
// MessageId: hrColumnNull
//
// MessageText:
//
// The value of the column is null.
//
#define hrColumnNull                     ((HRESULT)0x880003ECL)

//
// MessageId: hrBufferTruncated
//
// MessageText:
//
// The buffer is too small for data.
//
#define hrBufferTruncated                ((HRESULT)0x880003EEL)

//
// MessageId: hrDatabaseAttached
//
// MessageText:
//
// The database is already attached.
//
#define hrDatabaseAttached               ((HRESULT)0x880003EFL)

//
// MessageId: hrInvalidDatabaseId
//
// MessageText:
//
// The database ID is not valid.
//
#define hrInvalidDatabaseId              ((HRESULT)0xC80003F2L)

//
// MessageId: hrOutOfMemory
//
// MessageText:
//
// The computer is out of memory.
//
#define hrOutOfMemory                    ((HRESULT)0xC80003F3L)

//
// MessageId: hrOutOfDatabaseSpace
//
// MessageText:
//
// The database has reached the maximum size of 16 GB.
//
#define hrOutOfDatabaseSpace             ((HRESULT)0xC80003F4L)

//
// MessageId: hrOutOfCursors
//
// MessageText:
//
// Out of table cursors.
//
#define hrOutOfCursors                   ((HRESULT)0xC80003F5L)

//
// MessageId: hrOutOfBuffers
//
// MessageText:
//
// Out of database page buffers.
//
#define hrOutOfBuffers                   ((HRESULT)0xC80003F6L)

//
// MessageId: hrTooManyIndexes
//
// MessageText:
//
// There are too many indexes.
//
#define hrTooManyIndexes                 ((HRESULT)0xC80003F7L)

//
// MessageId: hrTooManyKeys
//
// MessageText:
//
// There are too many columns in an index.
//
#define hrTooManyKeys                    ((HRESULT)0xC80003F8L)

//
// MessageId: hrRecordDeleted
//
// MessageText:
//
// The record has been deleted.
//
#define hrRecordDeleted                  ((HRESULT)0xC80003F9L)

//
// MessageId: hrReadVerifyFailure
//
// MessageText:
//
// A read verification error occurred.
//
#define hrReadVerifyFailure              ((HRESULT)0xC80003FAL)

//
// MessageId: hrOutOfFileHandles
//
// MessageText:
//
// Out of file handles.
//
#define hrOutOfFileHandles               ((HRESULT)0xC80003FCL)

//
// MessageId: hrDiskIO
//
// MessageText:
//
// A disk I/O error occurred.
//
#define hrDiskIO                         ((HRESULT)0xC80003FEL)

//
// MessageId: hrInvalidPath
//
// MessageText:
//
// The path to the file is not valid.
//
#define hrInvalidPath                    ((HRESULT)0xC80003FFL)

//
// MessageId: hrRecordTooBig
//
// MessageText:
//
// The record has exceeded the maximum size.
//
#define hrRecordTooBig                   ((HRESULT)0xC8000402L)

//
// MessageId: hrTooManyOpenDatabases
//
// MessageText:
//
// There are too many open databases.
//
#define hrTooManyOpenDatabases           ((HRESULT)0xC8000403L)

//
// MessageId: hrInvalidDatabase
//
// MessageText:
//
// The file is not a database file.
//
#define hrInvalidDatabase                ((HRESULT)0xC8000404L)

//
// MessageId: hrNotInitialized
//
// MessageText:
//
// The database was not yet called.
//
#define hrNotInitialized                 ((HRESULT)0xC8000405L)

//
// MessageId: hrAlreadyInitialized
//
// MessageText:
//
// The database was already called.
//
#define hrAlreadyInitialized             ((HRESULT)0xC8000406L)

//
// MessageId: hrFileAccessDenied
//
// MessageText:
//
// Unable to access the file.
//
#define hrFileAccessDenied               ((HRESULT)0xC8000408L)

//
// MessageId: hrBufferTooSmall
//
// MessageText:
//
// The buffer is too small.
//
#define hrBufferTooSmall                 ((HRESULT)0xC800040EL)

//
// MessageId: hrSeekNotEqual
//
// MessageText:
//
// Either SeekLE or SeekGE did not find an exact match.
//
#define hrSeekNotEqual                   ((HRESULT)0x8800040FL)

//
// MessageId: hrTooManyColumns
//
// MessageText:
//
// There are too many columns defined.
//
#define hrTooManyColumns                 ((HRESULT)0xC8000410L)

//
// MessageId: hrContainerNotEmpty
//
// MessageText:
//
// The container is not empty.
//
#define hrContainerNotEmpty              ((HRESULT)0xC8000413L)

//
// MessageId: hrInvalidFilename
//
// MessageText:
//
// The filename is not valid.
//
#define hrInvalidFilename                ((HRESULT)0xC8000414L)

//
// MessageId: hrInvalidBookmark
//
// MessageText:
//
// The bookmark is not valid.
//
#define hrInvalidBookmark                ((HRESULT)0xC8000415L)

//
// MessageId: hrColumnInUse
//
// MessageText:
//
// The column is used in an index.
//
#define hrColumnInUse                    ((HRESULT)0xC8000416L)

//
// MessageId: hrInvalidBufferSize
//
// MessageText:
//
// The data buffer does not match the column size.
//
#define hrInvalidBufferSize              ((HRESULT)0xC8000417L)

//
// MessageId: hrColumnNotUpdatable
//
// MessageText:
//
// Unable to set the column value.
//
#define hrColumnNotUpdatable             ((HRESULT)0xC8000418L)

//
// MessageId: hrIndexInUse
//
// MessageText:
//
// The index is in use.
//
#define hrIndexInUse                     ((HRESULT)0xC800041BL)

//
// MessageId: hrNullKeyDisallowed
//
// MessageText:
//
// Null keys are not allowed on an index.
//
#define hrNullKeyDisallowed              ((HRESULT)0xC800041DL)

//
// MessageId: hrNotInTransaction
//
// MessageText:
//
// The operation must be within a transaction.
//
#define hrNotInTransaction               ((HRESULT)0xC800041EL)

//
// MessageId: hrNoIdleActivity
//
// MessageText:
//
// No idle activity occurred.
//
#define hrNoIdleActivity                 ((HRESULT)0x88000422L)

//
// MessageId: hrTooManyActiveUsers
//
// MessageText:
//
// There are too many active database users.
//
#define hrTooManyActiveUsers             ((HRESULT)0xC8000423L)

//
// MessageId: hrInvalidCountry
//
// MessageText:
//
// The country code is either not known or is not valid.
//
#define hrInvalidCountry                 ((HRESULT)0xC8000425L)

//
// MessageId: hrInvalidLanguageId
//
// MessageText:
//
// The language ID is either not known or is not valid.
//
#define hrInvalidLanguageId              ((HRESULT)0xC8000426L)

//
// MessageId: hrInvalidCodePage
//
// MessageText:
//
// The code page is either not known or is not valid.
//
#define hrInvalidCodePage                ((HRESULT)0xC8000427L)

//
// MessageId: hrNoWriteLock
//
// MessageText:
//
// There is no write lock at transaction level 0.
//
#define hrNoWriteLock                    ((HRESULT)0x8800042BL)

//
// MessageId: hrColumnSetNull
//
// MessageText:
//
// The column value is set to null.
//
#define hrColumnSetNull                  ((HRESULT)0x8800042CL)

//
// MessageId: hrVersionStoreOutOfMemory
//
// MessageText:
//
//  lMaxVerPages exceeded (XJET only)
//
#define hrVersionStoreOutOfMemory        ((HRESULT)0xC800042DL)

//
// MessageId: hrCurrencyStackOutOfMemory
//
// MessageText:
//
// Out of cursors.
//
#define hrCurrencyStackOutOfMemory       ((HRESULT)0xC800042EL)

//
// MessageId: hrOutOfSessions
//
// MessageText:
//
// Out of sessions.
//
#define hrOutOfSessions                  ((HRESULT)0xC800044DL)

//
// MessageId: hrWriteConflict
//
// MessageText:
//
// The write lock failed due to an outstanding write lock.
//
#define hrWriteConflict                  ((HRESULT)0xC800044EL)

//
// MessageId: hrTransTooDeep
//
// MessageText:
//
// The transactions are nested too deeply.
//
#define hrTransTooDeep                   ((HRESULT)0xC800044FL)

//
// MessageId: hrInvalidSesid
//
// MessageText:
//
// The session handle is not valid.
//
#define hrInvalidSesid                   ((HRESULT)0xC8000450L)

//
// MessageId: hrSessionWriteConflict
//
// MessageText:
//
// Another session has a private version of the page.
//
#define hrSessionWriteConflict           ((HRESULT)0xC8000453L)

//
// MessageId: hrInTransaction
//
// MessageText:
//
// The operation is not allowed within a transaction.
//
#define hrInTransaction                  ((HRESULT)0xC8000454L)

//
// MessageId: hrDatabaseDuplicate
//
// MessageText:
//
// The database already exists.
//
#define hrDatabaseDuplicate              ((HRESULT)0xC80004B1L)

//
// MessageId: hrDatabaseInUse
//
// MessageText:
//
// The database is in use.
//
#define hrDatabaseInUse                  ((HRESULT)0xC80004B2L)

//
// MessageId: hrDatabaseNotFound
//
// MessageText:
//
// The database does not exist.
//
#define hrDatabaseNotFound               ((HRESULT)0xC80004B3L)

//
// MessageId: hrDatabaseInvalidName
//
// MessageText:
//
// The database name is not valid.
//
#define hrDatabaseInvalidName            ((HRESULT)0xC80004B4L)

//
// MessageId: hrDatabaseInvalidPages
//
// MessageText:
//
// The number of pages is not valid.
//
#define hrDatabaseInvalidPages           ((HRESULT)0xC80004B5L)

//
// MessageId: hrDatabaseCorrupted
//
// MessageText:
//
// The database file is either damaged or cannot be found.
//
#define hrDatabaseCorrupted              ((HRESULT)0xC80004B6L)

//
// MessageId: hrDatabaseLocked
//
// MessageText:
//
// The database is locked.
//
#define hrDatabaseLocked                 ((HRESULT)0xC80004B7L)

//
// MessageId: hrTableEmpty
//
// MessageText:
//
// An empty table was opened.
//
#define hrTableEmpty                     ((HRESULT)0x88000515L)

//
// MessageId: hrTableLocked
//
// MessageText:
//
// The table is locked.
//
#define hrTableLocked                    ((HRESULT)0xC8000516L)

//
// MessageId: hrTableDuplicate
//
// MessageText:
//
// The table already exists.
//
#define hrTableDuplicate                 ((HRESULT)0xC8000517L)

//
// MessageId: hrTableInUse
//
// MessageText:
//
// Unable to lock the table because it is already in use.
//
#define hrTableInUse                     ((HRESULT)0xC8000518L)

//
// MessageId: hrObjectNotFound
//
// MessageText:
//
// The table or object does not exist.
//
#define hrObjectNotFound                 ((HRESULT)0xC8000519L)

//
// MessageId: hrCannotRename
//
// MessageText:
//
// Unable to rename the temporary file.
//
#define hrCannotRename                   ((HRESULT)0xC800051AL)

//
// MessageId: hrDensityInvalid
//
// MessageText:
//
// The file/index density is not valid.
//
#define hrDensityInvalid                 ((HRESULT)0xC800051BL)

//
// MessageId: hrTableNotEmpty
//
// MessageText:
//
// Unable to define the clustered index.
//
#define hrTableNotEmpty                  ((HRESULT)0xC800051CL)

//
// MessageId: hrInvalidTableId
//
// MessageText:
//
// The table ID is not valid.
//
#define hrInvalidTableId                 ((HRESULT)0xC800051EL)

//
// MessageId: hrTooManyOpenTables
//
// MessageText:
//
// Unable to open any more tables.
//
#define hrTooManyOpenTables              ((HRESULT)0xC800051FL)

//
// MessageId: hrIllegalOperation
//
// MessageText:
//
// The operation is not supported on tables.
//
#define hrIllegalOperation               ((HRESULT)0xC8000520L)

//
// MessageId: hrObjectDuplicate
//
// MessageText:
//
// The table or object name is already being used.
//
#define hrObjectDuplicate                ((HRESULT)0xC8000522L)

//
// MessageId: hrInvalidObject
//
// MessageText:
//
// The object is not valid for operation.
//
#define hrInvalidObject                  ((HRESULT)0xC8000524L)

//
// MessageId: hrIndexCantBuild
//
// MessageText:
//
// Unable to build a clustered index.
//
#define hrIndexCantBuild                 ((HRESULT)0xC8000579L)

//
// MessageId: hrIndexHasPrimary
//
// MessageText:
//
// The primary index is already defined.
//
#define hrIndexHasPrimary                ((HRESULT)0xC800057AL)

//
// MessageId: hrIndexDuplicate
//
// MessageText:
//
// The index is already defined.
//
#define hrIndexDuplicate                 ((HRESULT)0xC800057BL)

//
// MessageId: hrIndexNotFound
//
// MessageText:
//
// The index does not exist.
//
#define hrIndexNotFound                  ((HRESULT)0xC800057CL)

//
// MessageId: hrIndexMustStay
//
// MessageText:
//
// Unable to delete a clustered index.
//
#define hrIndexMustStay                  ((HRESULT)0xC800057DL)

//
// MessageId: hrIndexInvalidDef
//
// MessageText:
//
// The index definition is illegal.
//
#define hrIndexInvalidDef                ((HRESULT)0xC800057EL)

//
// MessageId: hrIndexHasClustered
//
// MessageText:
//
// The clustered index is already defined.
//
#define hrIndexHasClustered              ((HRESULT)0xC8000580L)

//
// MessageId: hrCreateIndexFailed
//
// MessageText:
//
// Unable to create the index because an error occurred while creating a table.
//
#define hrCreateIndexFailed              ((HRESULT)0x88000581L)

//
// MessageId: hrTooManyOpenIndexes
//
// MessageText:
//
// Out of index description blocks.
//
#define hrTooManyOpenIndexes             ((HRESULT)0xC8000582L)

//
// MessageId: hrColumnLong
//
// MessageText:
//
// The column value is too long.
//
#define hrColumnLong                     ((HRESULT)0xC80005DDL)

//
// MessageId: hrColumnDoesNotFit
//
// MessageText:
//
// The field will not fit in the record.
//
#define hrColumnDoesNotFit               ((HRESULT)0xC80005DFL)

//
// MessageId: hrNullInvalid
//
// MessageText:
//
// The value cannot be null.
//
#define hrNullInvalid                    ((HRESULT)0xC80005E0L)

//
// MessageId: hrColumnIndexed
//
// MessageText:
//
// Unable to delete because the column is indexed.
//
#define hrColumnIndexed                  ((HRESULT)0xC80005E1L)

//
// MessageId: hrColumnTooBig
//
// MessageText:
//
// The length of the field exceeds the maximum length.
//
#define hrColumnTooBig                   ((HRESULT)0xC80005E2L)

//
// MessageId: hrColumnNotFound
//
// MessageText:
//
// Unable to find the column.
//
#define hrColumnNotFound                 ((HRESULT)0xC80005E3L)

//
// MessageId: hrColumnDuplicate
//
// MessageText:
//
// The field is already defined.
//
#define hrColumnDuplicate                ((HRESULT)0xC80005E4L)

//
// MessageId: hrColumn2ndSysMaint
//
// MessageText:
//
// Only one auto-increment or version column is allowed per table.
//
#define hrColumn2ndSysMaint              ((HRESULT)0xC80005E6L)

//
// MessageId: hrInvalidColumnType
//
// MessageText:
//
// The column data type is not valid.
//
#define hrInvalidColumnType              ((HRESULT)0xC80005E7L)

//
// MessageId: hrColumnMaxTruncated
//
// MessageText:
//
// The column was truncated because it exceeded the maximum length.
//
#define hrColumnMaxTruncated             ((HRESULT)0x880005E8L)

//
// MessageId: hrColumnCannotIndex
//
// MessageText:
//
// Unable to index a long value column.
//
#define hrColumnCannotIndex              ((HRESULT)0xC80005E9L)

//
// MessageId: hrTaggedNotNULL
//
// MessageText:
//
// Tagged columns cannot be null.
//
#define hrTaggedNotNULL                  ((HRESULT)0xC80005EAL)

//
// MessageId: hrNoCurrentIndex
//
// MessageText:
//
// The entry is not valid without a current index.
//
#define hrNoCurrentIndex                 ((HRESULT)0xC80005EBL)

//
// MessageId: hrKeyIsMade
//
// MessageText:
//
// The key is completely made.
//
#define hrKeyIsMade                      ((HRESULT)0xC80005ECL)

//
// MessageId: hrBadColumnId
//
// MessageText:
//
// The column ID is not correct.
//
#define hrBadColumnId                    ((HRESULT)0xC80005EDL)

//
// MessageId: hrBadItagSequence
//
// MessageText:
//
// There is a bad instance identifier for a multivalued column.
//
#define hrBadItagSequence                ((HRESULT)0xC80005EEL)

//
// MessageId: hrCannotBeTagged
//
// MessageText:
//
// AutoIncrement and Version cannot be multivalued.
//
#define hrCannotBeTagged                 ((HRESULT)0xC80005F1L)

//
// MessageId: hrRecordNotFound
//
// MessageText:
//
// Unable to find the key.
//
#define hrRecordNotFound                 ((HRESULT)0xC8000641L)

//
// MessageId: hrNoCurrentRecord
//
// MessageText:
//
// The currency is not on a record.
//
#define hrNoCurrentRecord                ((HRESULT)0xC8000643L)

//
// MessageId: hrRecordClusteredChanged
//
// MessageText:
//
// A clustered key cannot be changed.
//
#define hrRecordClusteredChanged         ((HRESULT)0xC8000644L)

//
// MessageId: hrKeyDuplicate
//
// MessageText:
//
// The key already exists.
//
#define hrKeyDuplicate                   ((HRESULT)0xC8000645L)

//
// MessageId: hrAlreadyPrepared
//
// MessageText:
//
// The current entry has already been copied or cleared.
//
#define hrAlreadyPrepared                ((HRESULT)0xC8000647L)

//
// MessageId: hrKeyNotMade
//
// MessageText:
//
// No key was made.
//
#define hrKeyNotMade                     ((HRESULT)0xC8000648L)

//
// MessageId: hrUpdateNotPrepared
//
// MessageText:
//
// Update was not prepared.
//
#define hrUpdateNotPrepared              ((HRESULT)0xC8000649L)

//
// MessageId: hrwrnDataHasChanged
//
// MessageText:
//
// Data has changed.
//
#define hrwrnDataHasChanged              ((HRESULT)0x8800064AL)

//
// MessageId: hrerrDataHasChanged
//
// MessageText:
//
// The operation was abandoned because data has changed.
//
#define hrerrDataHasChanged              ((HRESULT)0xC800064BL)

//
// MessageId: hrKeyChanged
//
// MessageText:
//
// Moved to a new key.
//
#define hrKeyChanged                     ((HRESULT)0x88000652L)

//
// MessageId: hrTooManySorts
//
// MessageText:
//
// There are too many sort processes.
//
#define hrTooManySorts                   ((HRESULT)0xC80006A5L)

//
// MessageId: hrInvalidOnSort
//
// MessageText:
//
// An operation that is not valid occurred in the sort.
//
#define hrInvalidOnSort                  ((HRESULT)0xC80006A6L)

//
// MessageId: hrTempFileOpenError
//
// MessageText:
//
// Unable to open the temporary file.
//
#define hrTempFileOpenError              ((HRESULT)0xC800070BL)

//
// MessageId: hrTooManyAttachedDatabases
//
// MessageText:
//
// There are too many databases open.
//
#define hrTooManyAttachedDatabases       ((HRESULT)0xC800070DL)

//
// MessageId: hrDiskFull
//
// MessageText:
//
// The disk is full.
//
#define hrDiskFull                       ((HRESULT)0xC8000710L)

//
// MessageId: hrPermissionDenied
//
// MessageText:
//
// Permission is denied.
//
#define hrPermissionDenied               ((HRESULT)0xC8000711L)

//
// MessageId: hrFileNotFound
//
// MessageText:
//
// Unable to find the file.
//
#define hrFileNotFound                   ((HRESULT)0xC8000713L)

//
// MessageId: hrFileOpenReadOnly
//
// MessageText:
//
// The database file is read only.
//
#define hrFileOpenReadOnly               ((HRESULT)0x88000715L)

//
// MessageId: hrAfterInitialization
//
// MessageText:
//
// Unable to restore after initialization.
//
#define hrAfterInitialization            ((HRESULT)0xC800073AL)

//
// MessageId: hrLogCorrupted
//
// MessageText:
//
// The database log files are damaged.
//
#define hrLogCorrupted                   ((HRESULT)0xC800073CL)

//
// MessageId: hrInvalidOperation
//
// MessageText:
//
// The operation is not valid.
//
#define hrInvalidOperation               ((HRESULT)0xC8000772L)

//
// MessageId: hrAccessDenied
//
// MessageText:
//
// Access is denied.
//
#define hrAccessDenied                   ((HRESULT)0xC8000773L)

#endif	// _NTDSBMSG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NtDsBCli.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    ntdsbcli.h

Abstract:

    This header contains the interface definition for the NT Directory Service
    Backup Client APIs.

Environment:

      User Mode - Win32

Notes:

--*/

#ifndef _NTDSBCLI_H_
#define _NTDSBCLI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifdef	MIDL_PASS
#define	xRPC_STRING [string]
#else
#define	xRPC_STRING
#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#else
typedef wchar_t WCHAR;
#endif
#endif

#ifndef _NTDSBCLI_DEFINED
#define NTDSBCLI_API __declspec(dllimport) _stdcall
#else
#define NTDSBCLI_API
#endif

// HRESULT should be defined if the user included ntdef.h or winnt.h or wtypes.h
// Define it anyways just in case it is not defined yet
#ifndef _HRESULT_DEFINED
#define _HRESULT_DEFINED
    typedef LONG HRESULT;
#endif // _HRESULT_DEFINED

#define g_wszBackupAnnotation  L"NTDS Backup Interface"
#define g_aszBackupAnnotation   "NTDS Backup Interface"

#define g_wszRestoreAnnotation L"NTDS Restore Interface"
#define g_aszRestoreAnnotation  "NTDS Restore Interface"

#ifdef UNICODE
#define g_szBackupAnnotation  g_wszBackupAnnotation
#define g_szRestoreAnnotation g_wszRestoreAnnotation
#else
#define g_szBackupAnnotation  g_aszBackupAnnotation
#define g_szRestoreAnnotation g_aszRestoreAnnotation
#endif // UNICODE

// Type of Backup passed to DsBackupPrepare()
// BACKUP_TYPE_FULL: Requesting backup of the complete DS (DIT, Log files, and Patch files)
// BACKUP_TYPE_LOGS_ONLY: Requesting backup of only the log files
// BACKUP_TYPE_INCREMENTAL: Requesting incremental backup i.e. backing up only changes that happened since last backup
#define	BACKUP_TYPE_FULL			0x01
#define	BACKUP_TYPE_LOGS_ONLY		0x02
#define BACKUP_TYPE_INCREMENTAL     0x04        // not supported in product1

// Type of Restore passed to DsRestorePrepare()
// RESTORE_TYPE_AUTHORATATIVE: The restored version wins throughout the enterprise
// RESTORE_TYPE_ONLINE: Restoration is done when NTDS is online.
// RESTORE_TYPE_CATCHUP: The restored version is reconciled through the standard reconciliation logic so that the
//                          restored DIT can catchup with the rest of the enterprise.
#define RESTORE_TYPE_AUTHORATATIVE  0x01
#define RESTORE_TYPE_ONLINE         0x02        // not supported in product1
#define RESTORE_TYPE_CATCHUP        0x04        // this is the default restore mode

// Setting the current log # to this value would disable incremental/differential backup
#define BACKUP_DISABLE_INCREMENTAL  0xffffffff

// BFT is the bit flag used to represent file types (directory/dit/logfile/etc.)
// We keep them as a character so that we can append/prepend them to the actual file
// path. The code in the Backup API's rely on the fact that values 0-256 in 8 bit ascii
// map to the values 0-256 in unicode.
#ifdef UNICODE
    typedef WCHAR BFT;
#else
    typedef CHAR BFT;
#endif

// Bit flags:
//  BFT_DIRECTORY               - indicates path specified is a directory
//  BFT_DATABASE_DIRECTORY      - indicates that file goes into database directory
//  BFT_LOG_DIRECTORY           - indicates that the file goes into log directory
#define	BFT_DIRECTORY			    0x80
#define BFT_DATABASE_DIRECTORY	    0x40
#define	BFT_LOG_DIRECTORY		    0x20

// Following combinations are defined for easy use of the filetype and the directory into
// into which it goes
#define	BFT_LOG						(BFT)(TEXT('\x01') | BFT_LOG_DIRECTORY)
#define	BFT_LOG_DIR					(BFT)(TEXT('\x02') | BFT_DIRECTORY)
#define	BFT_CHECKPOINT_DIR			(BFT)(TEXT('\x03') | BFT_DIRECTORY)
#define	BFT_NTDS_DATABASE	        (BFT)(TEXT('\x04') | BFT_DATABASE_DIRECTORY)
#define	BFT_PATCH_FILE				(BFT)(TEXT('\x05') | BFT_LOG_DIRECTORY)
#define	BFT_UNKNOWN					(BFT)(TEXT('\x0f'))

#include <ntdsbmsg.h>

// Backup Context Handle
typedef void    *HBC;

typedef struct tagEDB_RSTMAPA
{
	xRPC_STRING char		*szDatabaseName;
	xRPC_STRING char		*szNewDatabaseName;
} EDB_RSTMAPA, *PEDB_RSTMAPA;			/* restore map */

//	required for NTDS unicode support.
//	UNDONE: NYI
#define	UNICODE_RSTMAP

typedef struct tagEDB_RSTMAPW {
	xRPC_STRING WCHAR *wszDatabaseName;
	xRPC_STRING WCHAR *wszNewDatabaseName;
} EDB_RSTMAPW, *PEDB_RSTMAPW;

#ifdef UNICODE
#define EDB_RSTMAP EDB_RSTMAPW
#define PEDB_RSTMAP PEDB_RSTMAPW
#else
#define EDB_RSTMAP EDB_RSTMAPA
#define PEDB_RSTMAP PEDB_RSTMAPA
#endif

// For all the functions in this interface that have atleast one string
// parameter provide macros to invoke the appropriate version of the
// corresponding function.
#ifdef UNICODE

#define DsIsNTDSOnline                      DsIsNTDSOnlineW
#define DsBackupPrepare                     DsBackupPrepareW
#define DsBackupGetDatabaseNames            DsBackupGetDatabaseNamesW
#define DsBackupOpenFile                    DsBackupOpenFileW
#define DsBackupGetBackupLogs               DsBackupGetBackupLogsW
#define DsRestoreGetDatabaseLocations       DsRestoreGetDatabaseLocationsW
#define DsRestorePrepare                    DsRestorePrepareW
#define DsRestoreRegister                   DsRestoreRegisterW
#define DsSetCurrentBackupLog               DsSetCurrentBackupLogW
#define DsSetAuthIdentity                   DsSetAuthIdentityW

#else

#define DsIsNTDSOnline                      DsIsNTDSOnlineA
#define DsBackupPrepare                     DsBackupPrepareA
#define DsBackupGetDatabaseNames            DsBackupGetDatabaseNamesA
#define DsBackupOpenFile                    DsBackupOpenFileA
#define DsBackupGetBackupLogs               DsBackupGetBackupLogsA
#define DsRestoreGetDatabaseLocations       DsRestoreGetDatabaseLocationsA
#define DsRestorePrepare                    DsRestorePrepareA
#define DsRestoreRegister                   DsRestoreRegisterA
#define DsSetCurrentBackupLog               DsSetCurrentBackupLogA
#define DsSetAuthIdentity                   DsSetAuthIdentityA

#endif // #ifdef UNICODE


/*************************************************************************************
Routine Description:

      DsIsNTDSOnline
        Checks to see if the NTDS is Online on the given server. This call is
        guaranteed to return quickly.

  Arguments:
    [in] szServerName - UNC name of the server to check
    [out] pfNTDSOnline - pointer to receive the bool result (TRUE if NTDS is
                            online; FALSE, otherwise)

Return Value:

    ERROR_SUCCESS if the call executed successfully;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsIsNTDSOnlineA(
    LPCSTR szServerName,
    BOOL *pfNTDSOnline
    );

HRESULT
NTDSBCLI_API
DsIsNTDSOnlineW(
    LPCWSTR szServerName,
    BOOL *pfNTDSOnline
    );


/*************************************************************************************
Routine Description:

      DsBackupPrepare
        Prepares the DS for the online backup and returns a Backup Context Handle
        which should be used in the subsequent calls to other backup functions.

  Arguments:
    [in]    szBackupServer - UNC name of the server to be prepared for online backup
    [in]    grbit - flag to be passed to jet while backing up dbs
    [in]    btFlag - BACKUP_TYPE_FULL or BACKUP_TYPE_LOGS_ONLY
    [out]   ppvExpiryToken - pointer that will receive the pointer to the
                Expiry Token associated with this backup; Client should save
                this token and send it back through DsRestorePrepare() when
                attempting a restore; allocated memory should be freed using
                DsBackupFree() API by the caller when it is no longer needed.
    [out]   pcbExpiryTokenSize - pointer to receive the size of the expiry token
                returned.
    [out]   phbc - pointer that will receive the backup context handle

Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsBackupPrepareA(
    LPCSTR szBackupServer,
    ULONG grbit,
    ULONG btFlag,
    PVOID *ppvExpiryToken,
    LPDWORD pcbExpiryTokenSize,
    HBC *phbc
    );

HRESULT
NTDSBCLI_API
DsBackupPrepareW(
    LPCWSTR szBackupServer,
    ULONG grbit,
    ULONG btFlag,
    PVOID *ppvExpiryToken,
    LPDWORD pcbExpiryTokenSize,
    HBC *phbc
    );


/*************************************************************************************
Routine Description:

      DsBackupGetDatabaseNames
        Gives the list of data bases that need to be backed up for the given
        backup context

  Arguments:
    [in]    hbc - backup context handle
    [out]   pszAttachmentInfo - pointer that will receive the pointer to the attachment
                info; allocated memory should be freed using DsBackupFree() API by the
                caller when it is no longer needed; Attachment info is an array of
                null-terminated filenames and and the list is terminated by two-nulls.
    [out]   pcbSize - will receive the number of bytes returned
Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsBackupGetDatabaseNamesA(
    HBC hbc,
    LPSTR *pszAttachmentInfo,
    LPDWORD pcbSize
    );

HRESULT
NTDSBCLI_API
DsBackupGetDatabaseNamesW(
    HBC hbc,
    LPWSTR *pszAttachmentInfo,
    LPDWORD pcbSize
    );



/*************************************************************************************
Routine Description:

      DsBackupOpenFile
        Opens the given attachment for read.

  Arguments:
    [in]    hbc - backup context handle
    [in]    szAttachmentName - name of the attachment to be opened for read
    [in]    cbReadHintSize - suggested size in bytes that might be used during the
                subsequent reads on this attachement
    [out]   pliFileSize - pointer to a large integer that would receive the size in
                bytes of the given attachment
Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsBackupOpenFileA(
    HBC hbc,
    LPCSTR szAttachmentName,
    DWORD cbReadHintSize,
    LARGE_INTEGER *pliFileSize
    );

HRESULT
NTDSBCLI_API
DsBackupOpenFileW(
    HBC hbc,
    LPCWSTR szAttachmentName,
    DWORD cbReadHintSize,
    LARGE_INTEGER *pliFileSize
    );



/*************************************************************************************
Routine Description:

      DsBackupRead
        Reads the currently open attachment bytes into the given buffer. The client
        application is expected to call this function repeatedly until it gets the
        entire file (the application would have received the file size through the
        DsBackupOpenFile() call before.

  Arguments:
    [in]    hbc - backup context handle
    [in]    pvBuffer - pointer to the buffer that would receive the read data.
    [in]    cbBuffer - specifies the size of the above buffer
    [out]   pcbRead - pointer to receive the actual number of bytes read.
Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsBackupRead(
    HBC hbc,
    PVOID pvBuffer,
    DWORD cbBuffer,
    PDWORD pcbRead
    );



/*************************************************************************************
Routine Description:

      DsBackupClose
        To be called by the application after it completes reading all the data in
        the currently opened attachement.

  Arguments:
    [in]    hbc - backup context handle
Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsBackupClose(
    HBC hbc
    );


/*************************************************************************************
Routine Description:

      DsBackupGetBackupLogs
        Gives the list of log files that need to be backed up for the given
        backup context

  Arguments:
    [in]    hbc - backup context handle
    [out]   pszBackupLogFiles - pointer that will receive the pointer to the list of
                log files; allocated memory should be freed using DsBackupFree() API by the
                caller when it is no longer needed; Log files are returned in an array of
                null-terminated filenames and and the list is terminated by two-nulls.
    [out]   pcbSize - will receive the number of bytes returned
Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsBackupGetBackupLogsA(
    HBC hbc,
    LPSTR *pszBackupLogFiles,
    LPDWORD pcbSize
    );

HRESULT
NTDSBCLI_API
DsBackupGetBackupLogsW(
    HBC hbc,
    LPWSTR *pszBackupLogFiles,
    LPDWORD pcbSize
    );


/*************************************************************************************
Routine Description:

      DsBackupTruncateLogs
        Called to truncate the already read backup logs.

  Arguments:
    [in]    hbc - backup context handle
Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsBackupTruncateLogs(
    HBC hbc
    );


/*************************************************************************************
Routine Description:

      DsBackupEnd
        Called to end the current backup session.

  Arguments:
    [in]    hbc - backup context handle of the backup session
Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsBackupEnd(
    HBC hbc
    );


/*************************************************************************************
Routine Description:

      DsBackupFree
        Should be used by the application to free any buffer allocated by the
        NTDSBCLI dll.

  Arguments:
    [in]    pvBuffer - pointer to the buffer that is to be freed.

  Return Value:
    None.
**************************************************************************************/
VOID
NTDSBCLI_API
DsBackupFree(
    PVOID pvBuffer
    );


/*************************************************************************************
Routine Description:

      DsRestoreGetDatabaseLocations
        Called both at backup time as well at restoration time to get the data base
        locations for different types of files.

  Arguments:
    [in]    hbc - backup context handle which would have been obtained through
                    DsBackupPrepare() in the backup case and through DsRestorePrepare()
                    in the restore case.
    [out]   pszDatabaseLocationList - pointer that will receive the pointer to the list of
                database locations; allocated memory should be freed using DsBackupFree() API by the
                caller when it is no longer needed; locations are returned in an array of
                null-terminated names and and the list is terminated by two-nulls.
                The first character of each name is the BFT character that indicates the type
                of the file and the rest of the name tells gives the path into which that
                particular type of file should be restored.
    [out]   pcbSize - will receive the number of bytes returned
Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsRestoreGetDatabaseLocationsA(
    HBC hbc,
    LPSTR *pszDatabaseLocationList,
    LPDWORD pcbSize
    );

HRESULT
NTDSBCLI_API
DsRestoreGetDatabaseLocationsW(
    HBC hbc,
    LPWSTR *pszDatabaseLocationList,
    LPDWORD pcbSize
    );


/*************************************************************************************
Routine Description:

      DsRestorePrepare
        Called to indicate beginning of a restore session.

  Arguments:
    [in]    szServerName - UNC name of the server into which the restore operation is
                            going to be performed.
    [in]    rtFlag -  Or'ed combination of RESTORE_TYPE_* flags; 0 if no special flags
                            are to be specified
    [in]    pvExpiryToken - pointer to the expiry token associated with this
                            backup. The client would have received this when they backed up the DS.
    [in]    cbExpiryTokenSize - size of the expiry token.
    [out]   phbc - pointer to receive the backup context handle which is to be passed
                            to the subsequent restore APIs

Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsRestorePrepareA(
    LPCSTR szServerName,
    ULONG rtFlag,
    PVOID pvExpiryToken,
    DWORD cbExpiryTokenSize,
    HBC *phbc
    );

HRESULT
NTDSBCLI_API
DsRestorePrepareW(
    LPCWSTR szServerName,
    ULONG rtFlag,
    PVOID pvExpiryToken,
    DWORD cbExpiryTokenSize,
    HBC *phbc
    );


/*************************************************************************************
Routine Description:

      DsRestoreRegister
        This will register a restore operation. It will interlock all sbsequent restore
        operations, and will prevent the restore target from starting until the call
        to DsRestoreRegisterComplete() is made.

  Arguments:
    [in]    hbc - backup context handle for the restore session.
    [in]    szCheckPointFilePath - path where the check point files are restored
    [in]    szLogPath - path where the log files are restored
    [in]    rgrstmap - restore map
    [in]    crstmap - tells if ther is a new restore map
    [in]    szBackupLogPath - path where the backup logs are located
    [in]    genLow - Lowest log# that was restored in this restore session
    [in]    genHigh - Highest log# that was restored in this restore session

  Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsRestoreRegisterA(
    HBC hbc,
    LPCSTR szCheckPointFilePath,
    LPCSTR szLogPath,
	EDB_RSTMAPA rgrstmap[],
	LONG crstmap,
    LPCSTR szBackupLogPath,
    ULONG genLow,
    ULONG genHigh
    );

HRESULT
NTDSBCLI_API
DsRestoreRegisterW(
    HBC hbc,
    LPCWSTR szCheckPointFilePath,
    LPCWSTR szLogPath,
	EDB_RSTMAPW rgrstmap[],
	LONG crstmap,
    LPCWSTR szBackupLogPath,
    ULONG genLow,
    ULONG genHigh
    );



/*************************************************************************************
Routine Description:

      DsRestoreRegisterComplete
        Called to indicate that a previously registered restore is complete.

  Arguments:
    [in]    hbc - backup context handle
    [in]    hrRestoreState - success code if the restore was successful
Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsRestoreRegisterComplete(
    HBC hbc,
    HRESULT hrRestoreState
    );


/*************************************************************************************
Routine Description:

      DsRestoreEnd
        Called to end a restore session

  Arguments:
    [in]    hbc - backup context handle
Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsRestoreEnd(
    HBC hbc
    );


/*************************************************************************************
Routine Description:

      DsSetCurrentBackupLog
        Called to set the current backup log number after a successful restore

  Arguments:
    [in]    szServerName - UNC name of the server for which the current backup log has
                                to be set
    [in]    dwCurrentLog -  current log number
Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsSetCurrentBackupLogA(
    LPCSTR szServerName,
    DWORD dwCurrentLog
    );

HRESULT
NTDSBCLI_API
DsSetCurrentBackupLogW(
    LPCWSTR szServerName,
    DWORD dwCurrentLog
    );


/*************************************************************************************
Routine Description:

      DsSetAuthIdentity
        Used to set the security context under which the client APIs are to be
        called. If this function is not called, security context of the current
        process is assumed.

  Arguments:
    [in]    szUserName - name of the user
    [in]    szDomainName -  name of the domain the user belongs to
    [in]    szPassword - password of the user in the specified domain

Return Value:

    One of the standard HRESULT success codes;
    Failure code otherwise.
**************************************************************************************/
HRESULT
NTDSBCLI_API
DsSetAuthIdentityA(
    LPCSTR szUserName,
    LPCSTR szDomainName,
    LPCSTR szPassword
    );

HRESULT
NTDSBCLI_API
DsSetAuthIdentityW(
    LPCWSTR szUserName,
    LPCWSTR szDomainName,
    LPCWSTR szPassword
    );



#ifdef __cplusplus
}
#endif

#endif // _NTDSBCLI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntdskreg.h ===
/*++

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    ntdskreg.h

Abstract:

    This file contains disk registry data structures.


--*/

#ifndef _NTDSKREG_
#define _NTDSKREG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Component types for FT members.  If a disk partition
// is not a part of an FT component then it is stamped
// as "NotAnFtMember".
//

typedef enum {
    Mirror,
    Stripe,
    StripeWithParity,
    VolumeSet,
    NotAnFtMember,
    WholeDisk
} FT_TYPE;

//
// FT_PARTITION_STATE is an enumerated type that describes the state of an
// NTFT member.
// Up to one member can be 'orphaned', that is missing or out of sync with
// the other members.  The orphaned member will remain orphaned until recovery
// action is commenced in DISKMAN.EXE.
// When READs are directed at an orphaned member, the data is returned from
// the redundant copy.  WRITEs go to the secondary members only.
//
// Note that SyncRedundantCopy should NEVER be seen by anything other
// than ft itself.
//

typedef enum _FT_PARTITION_STATE {
    Healthy,
    Orphaned,
    Regenerating,
    Initializing,
    SyncRedundantCopy
} FT_PARTITION_STATE, *PFT_PARTITION_STATE;

//
// The description of a partition on a disk.
//

#include "pshpack4.h"
typedef struct _DISK_PARTITION {

    FT_TYPE            FtType;
    FT_PARTITION_STATE FtState;
    LARGE_INTEGER      StartingOffset;
    LARGE_INTEGER      Length;
    LARGE_INTEGER      FtLength;
    ULONG              ReservedTwoLongs[2];
    UCHAR              DriveLetter;
    BOOLEAN            AssignDriveLetter;
    USHORT             LogicalNumber;
    USHORT             FtGroup;
    USHORT             FtMember;
    BOOLEAN            Modified;
    UCHAR              ReservedChars[3];

} DISK_PARTITION, *PDISK_PARTITION;

//
// The description of a disk.
//

typedef struct _DISK_DESCRIPTION {

    USHORT NumberOfPartitions;
    USHORT ReservedShort;
    ULONG  Signature;

    //
    // An array for NumberOfPartitions
    //

    DISK_PARTITION Partitions[1];

} DISK_DESCRIPTION, *PDISK_DESCRIPTION;

//
// Header for all disk descriptions.
//

typedef struct _DISK_REGISTRY {

    USHORT NumberOfDisks;
    USHORT ReservedShort;

    //
    // An array for NumberOfDisks.
    //

    DISK_DESCRIPTION Disks[1];

} DISK_REGISTRY, *PDISK_REGISTRY;
#include "poppack.h"

//
// Function prototypes.
//


#if (NTDDI_VERSION < NTDDI_VISTA)

//
// Set the current registry information.
//

NTSTATUS
DiskRegistrySet(
    IN PDISK_REGISTRY Buffer
    );


//
// Add a single disk to the registry.  This disk is not a part of
// a Fault Tolerance volume.
//

NTSTATUS
DiskRegistryAddNewDisk(
    IN PDISK_DESCRIPTION Buffer
    );

//
// Get the current registry information.
// A Buffer address == NULL indicates that the caller only wants.
// to know the size of the registry information.
//

NTSTATUS
DiskRegistryGet(
    OUT PDISK_REGISTRY Buffer,
    OUT PULONG        LengthReturned
    );

//
// Determine if FT is installed and currently active in the system.
//

BOOLEAN
FtInstalled(
    );

//
// Cause an FT set to be initialized at the earliest possible moment.
//

VOID
DiskRegistryInitializeSet(
    IN USHORT  FtType,
    IN USHORT  FtGroup
    );

//
// Cause an FT set member to be regenerated at the earliest possible moment.
//

VOID
DiskRegistryRegenerateSet(
    IN USHORT  FtType,
    IN USHORT  FtGroup,
    IN USHORT  FtMember
    );

//
// Enable the FT driver.
//

BOOLEAN
DiskRegistryEnableFt();

//
// Disable the FT driver.
//

VOID
DiskRegistryDisableFt();

//
// Determine if the existing FT registry information requires the FT driver.
//

BOOLEAN
DiskRegistryRequiresFt();

//
// Update drive letter assignment.
//

BOOLEAN
DiskRegistryAssignDriveLetter(
    ULONG         Signature,
    LARGE_INTEGER StartingOffset,
    LARGE_INTEGER Length,
    UCHAR         DriveLetter
    );

//
// Determine if DoubleSpace support is set to automount double space
// volumes on removable media.
//

BOOLEAN
DiskRegistryAutomountCurrentState(
    );

//
// Set the automount state for double space volumes on removable media.
//

NTSTATUS
DiskRegistryDblSpaceRemovable(
    IN BOOLEAN Automount
    );

//
// Set the drive letter for space mount information in the registry.
//

NTSTATUS
DiskRegistryAssignDblSpaceLetter(
    IN PWSTR CvfName,
    IN WCHAR DriveLetter
    );

//
// Set up the registry information for CdRom drive letters.
//

NTSTATUS
DiskRegistryAssignCdRomLetter(
    IN PWSTR CdromName,
    IN WCHAR DriveLetter
    );

#endif // < NTDDI_VISTA

#ifdef __cplusplus
}
#endif

#endif // _NTDSKREG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntgdi.h ===
/******************************Module*Header*******************************\
* Module Name: ntgdi.h
*
* Structures defining kernel-mode entry points for GDI.
*
* Copyright (c) 1994-1999 Microsoft Corporation
\**************************************************************************/

#ifndef W32KAPI
#define W32KAPI  DECLSPEC_ADDRSAFE
#endif

// A few GDI API's fill buffers but have no input parameter saying how big
// the buffers are.  The idiom is that you call it once with a NULL buffer
// pointer to find out how big the buffer should be, allocate that much,
// then call again.  This sounds like a job for __out_bcount_opt(size), but
// this annotation requires (size) to be known beforehand (i.e. it is a 
// precondition).  The best we can do is to specify the size as a 
// postcondition.

#define __out_post_bcount_opt(size) __post __valid __refparam __post __byte_writableTo(size) __exceptthat __maybenull
#define __out_post_ecount_opt(size) __post __valid __refparam __post __elem_writableTo(size) __exceptthat __maybenull

// Trace creation of all GDI SURFACE objects
#define TRACE_SURFACE_ALLOCS    (DBG || 0)

// enable directX API to change surface pointer
#ifdef  COMBOX_SANDBOX
#define DX_LONGHORN_PRESERVEDC
#endif

// PRIVATE

__kernel_entry W32KAPI BOOL APIENTRY NtGdiInit();
__kernel_entry W32KAPI int APIENTRY
NtGdiSetDIBitsToDeviceInternal(
    __in HDC hdcDest,
    __in int xDst,
    __in int yDst,
    __in DWORD cx,
    __in DWORD cy,
    __in int xSrc,
    __in int ySrc,
    __in DWORD iStartScan,
    __in DWORD cNumScan,
    __in_bcount(cjMaxBits) LPBYTE pInitBits,
    __in LPBITMAPINFO pbmi,
    __in DWORD iUsage,
    __in UINT cjMaxBits,
    __in UINT cjMaxInfo,
    __in BOOL bTransformCoordinates,
    __in_opt HANDLE hcmXform
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetFontResourceInfoInternalW(
    __in_ecount(cwc) LPWSTR pwszFiles,
    __in ULONG cwc,
    __in ULONG cFiles,
    __in UINT cjIn,
    __out LPDWORD pdwBytes,
    __out_bcount(cjIn) LPVOID pvBuf,
    __in DWORD iType
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiGetGlyphIndicesW(
    __in HDC hdc,
    __in_ecount_opt(cwc) LPWSTR pwc,
    __in int cwc,
    __out_opt LPWORD pgi,
    __in DWORD iMode
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiGetGlyphIndicesWInternal(
    __in HDC hdc,
    __in_ecount_opt(cwc) LPWSTR pwc,
    __in int cwc,
    __out_opt LPWORD pgi,
    __in DWORD iMode,
    __in BOOL bSubset
    );

//
// pLogPal is annotated as __in_bcount(cEntries * 4  + 4) because the
// current SAL doesn't support sizeof operator. The size of related buffer is
// sizeof(LOGPALETTE) - sizeof(PALETTEENTRY) + sizeof(PALETTEENTRY) * cEntries.
//

__kernel_entry W32KAPI HPALETTE APIENTRY
NtGdiCreatePaletteInternal(
    __in_bcount(cEntries * 4  + 4) LPLOGPALETTE pLogPal,
    __in UINT cEntries
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiArcInternal(
    __in ARCTYPE arctype,
    __in HDC hdc,
    __in int x1,
    __in int y1,
    __in int x2,
    __in int y2,
    __in int x3,
    __in int y3,
    __in int x4,
    __in int y4
    );

__kernel_entry W32KAPI int
APIENTRY
NtGdiStretchDIBitsInternal(
    __in HDC hdc,
    __in int xDst,
    __in int yDst,
    __in int cxDst,
    __in int cyDst,
    __in int xSrc,
    __in int ySrc,
    __in int cxSrc,
    __in int cySrc,
    __in_bcount_opt(cjMaxBits) LPBYTE pjInit,
    __in LPBITMAPINFO pbmi,
    __in DWORD dwUsage,
    __in DWORD dwRop4,
    __in UINT cjMaxInfo,
    __in UINT cjMaxBits,
    __in HANDLE hcmXform
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiGetOutlineTextMetricsInternalW(
    __in HDC hdc,
    __in ULONG cjotm,
    __out_bcount_opt(cjotm) OUTLINETEXTMETRICW *potmw,
    __out TMDIFF *ptmd
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetAndSetDCDword(
    __in HDC hdc,
    __in UINT u,
    __in DWORD dwIn,
    __out DWORD *pdwResult
    );

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiGetDCObject(
    __in  HDC hdc,
    __in  int itype
    );

__kernel_entry W32KAPI HDC APIENTRY
NtGdiGetDCforBitmap(
    __in HBITMAP hsurf
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetMonitorID(
    __in  HDC hdc,
    __in  DWORD dwSize,
    __out_bcount(dwSize) LPWSTR pszMonitorID
    );

// flags returned from GetUFI and passed to GetUFIBits
#define FL_UFI_PRIVATEFONT      1
#define FL_UFI_DESIGNVECTOR_PFF 2
#define FL_UFI_MEMORYFONT       4

__kernel_entry W32KAPI INT APIENTRY
NtGdiGetLinkedUFIs(
    __in HDC hdc,
    __out_ecount_opt(BufferSize) PUNIVERSAL_FONT_ID pufiLinkedUFIs,
    __in INT BufferSize
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetLinkedUFIs(
    __in HDC hdc,
    __in_ecount(uNumUFIs) PUNIVERSAL_FONT_ID pufiLinks,
    __in ULONG uNumUFIs
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetUFI(
    __in  HDC hdc,
    __out PUNIVERSAL_FONT_ID pufi,
    __out_opt DESIGNVECTOR *pdv,
    __out ULONG *pcjDV,
    __out ULONG *pulBaseCheckSum,
    __out FLONG *pfl
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiForceUFIMapping(
    __in HDC hdc,
    __in PUNIVERSAL_FONT_ID pufi
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetUFIPathname(
    __in PUNIVERSAL_FONT_ID pufi,
    __deref_out_range(0, MAX_PATH * 3) ULONG* pcwc,
    __out_ecount_part_opt(MAX_PATH * 3, *pcwc) LPWSTR pwszPathname,
    __out_opt ULONG* pcNumFiles,
    __in FLONG fl,
    __out_opt BOOL *pbMemFont,
    __out_opt ULONG *pcjView,
    __out_opt PVOID pvView,
    __out_opt BOOL *pbTTC,
    __out_opt ULONG *piTTC
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiAddRemoteFontToDC(
    __in HDC hdc,
    __in_bcount(cjBuffer) PVOID pvBuffer,
    __in ULONG cjBuffer,
    __in_opt PUNIVERSAL_FONT_ID pufi
    );

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiAddFontMemResourceEx(
    __in_bcount(cjBuffer) PVOID pvBuffer,
    __in DWORD cjBuffer,
    __in_bcount_opt(cjDV) DESIGNVECTOR *pdv,
    __in ULONG cjDV,
    __out DWORD *pNumFonts
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiRemoveFontMemResourceEx(
    __in HANDLE hMMFont
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiUnmapMemFont(
    __in PVOID pvView
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiRemoveMergeFont(
    __in HDC hdc,
    __in UNIVERSAL_FONT_ID *pufi
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiAnyLinkedFonts();

// local printing with embedded fonts

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetEmbUFI(
    __in HDC hdc,
    __out PUNIVERSAL_FONT_ID pufi,
    __out_opt DESIGNVECTOR *pdv,
    __out ULONG *pcjDV,
    __out ULONG *pulBaseCheckSum,
    __out FLONG  *pfl,
    __out KERNEL_PVOID *embFontID
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiGetEmbedFonts(
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiChangeGhostFont(
    __in  KERNEL_PVOID *pfontID,
    __in  BOOL bLoad
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiAddEmbFontToDC(
    __in HDC hdc,
    __in VOID **pFontID
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiFontIsLinked(
    __in HDC hdc
    );

__kernel_entry W32KAPI ULONG_PTR APIENTRY
NtGdiPolyPolyDraw(
    __in HDC hdc,
    __in PPOINT ppt,
    __in_ecount(ccpt) PULONG pcpt,
    __in ULONG ccpt,
    __in int iFunc
    );

__kernel_entry W32KAPI LONG APIENTRY
NtGdiDoPalette(
    __in HPALETTE hpal,
    __in WORD iStart,
    __in WORD cEntries,
    __in_ecount_opt(cEntries) PALETTEENTRY *pPalEntries,
    __in DWORD iFunc,
    __in BOOL bInbound
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiComputeXformCoefficients(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetWidthTable(
    __in HDC hdc,
    __in ULONG cSpecial,
    __in_ecount(cwc) WCHAR *pwc,
    __in ULONG cwc,
    __out_ecount(cwc) USHORT *psWidth,
    __out_opt WIDTHDATA *pwd,
    __out FLONG *pflInfo
    );

__kernel_entry W32KAPI __success(return > 0) int APIENTRY 
NtGdiDescribePixelFormat(
    __in HDC hdc,
    __in int ipfd,
    __in UINT cjpfd,
    __out_bcount(cjpfd) PPIXELFORMATDESCRIPTOR ppfd
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetPixelFormat(
    __in HDC hdc,
    __in int ipfd
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSwapBuffers(
    __in HDC hdc
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiSetupPublicCFONT(
    __in HDC hdc,
    __in_opt HFONT hf,
    __in ULONG ulAve
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDxgGenericThunk(
    __in ULONG_PTR ulIndex,
    __in ULONG_PTR ulHandle,
    __inout SIZE_T *pdwSizeOfPtr1,
    __inout  PVOID pvPtr1,
    __inout SIZE_T *pdwSizeOfPtr2,
    __inout  PVOID pvPtr2
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdAddAttachedSurface(
    __in HANDLE hSurface,
    __in HANDLE hSurfaceAttached,
    __inout PDD_ADDATTACHEDSURFACEDATA puAddAttachedSurfaceData
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDdAttachSurface(
    __in HANDLE  hSurfaceFrom,
    __in HANDLE  hSurfaceTo
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdBlt(
    __in HANDLE hSurfaceDest,
    __in HANDLE hSurfaceSrc,
    __inout PDD_BLTDATA puBltData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdCanCreateSurface(
    __in HANDLE hDirectDraw,
    __inout PDD_CANCREATESURFACEDATA puCanCreateSurfaceData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdColorControl(
    __in HANDLE hSurface,
    __inout PDD_COLORCONTROLDATA puColorControlData
    );

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiDdCreateDirectDrawObject(
    __in HDC hdc
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdCreateSurface(
    __in HANDLE hDirectDraw,
    __in HANDLE* hSurface,
    __inout DDSURFACEDESC* puSurfaceDescription,
    __inout DD_SURFACE_GLOBAL* puSurfaceGlobalData,
    __inout DD_SURFACE_LOCAL* puSurfaceLocalData,
    __inout DD_SURFACE_MORE* puSurfaceMoreData,
    __inout DD_CREATESURFACEDATA* puCreateSurfaceData,
    __out HANDLE* puhSurface
    );

#ifdef DX_LONGHORN_PRESERVEDC

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdChangeSurfacePointer(
    __in HANDLE hSurface,
    __in PVOID pSurfacePointer
    );

#endif // DX_LONGHORN_PRESERVEDC

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiDdCreateSurfaceObject(
    __in HANDLE hDirectDrawLocal,
    __in HANDLE hSurface,
    __in PDD_SURFACE_LOCAL puSurfaceLocal,
    __in PDD_SURFACE_MORE puSurfaceMore,
    __in PDD_SURFACE_GLOBAL puSurfaceGlobal,
    __in BOOL bComplete
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDdDeleteSurfaceObject(
    __in HANDLE hSurface
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDdDeleteDirectDrawObject(
    __in HANDLE hDirectDrawLocal
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdDestroySurface(
    __in HANDLE hSurface,
    __in BOOL bRealDestroy
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdFlip(
    __in HANDLE hSurfaceCurrent,
    __in HANDLE hSurfaceTarget,
    __in HANDLE hSurfaceCurrentLeft,
    __in HANDLE hSurfaceTargetLeft,
    __inout PDD_FLIPDATA puFlipData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdGetAvailDriverMemory(
    __in HANDLE hDirectDraw,
    __inout PDD_GETAVAILDRIVERMEMORYDATA puGetAvailDriverMemoryData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdGetBltStatus(
    __in HANDLE hSurface,
    __inout PDD_GETBLTSTATUSDATA puGetBltStatusData
    );

__kernel_entry W32KAPI HDC APIENTRY
NtGdiDdGetDC(
    __in HANDLE hSurface,
    __in PALETTEENTRY* puColorTable
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdGetDriverInfo(
    __in HANDLE hDirectDraw,
    __inout PDD_GETDRIVERINFODATA puGetDriverInfoData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdGetFlipStatus(
    __in HANDLE hSurface,
    __inout PDD_GETFLIPSTATUSDATA puGetFlipStatusData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdGetScanLine(
    __in HANDLE hDirectDraw,
    __inout PDD_GETSCANLINEDATA puGetScanLineData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdSetExclusiveMode(
    __in HANDLE hDirectDraw,
    __inout PDD_SETEXCLUSIVEMODEDATA puSetExclusiveModeData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdFlipToGDISurface(
    __in HANDLE hDirectDraw,
    __inout PDD_FLIPTOGDISURFACEDATA puFlipToGDISurfaceData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdLock(
    __in HANDLE hSurface,
    __inout PDD_LOCKDATA puLockData,
    __in HDC hdcClip
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDdQueryDirectDrawObject(
    __in HANDLE hDirectDrawLocal,
    __out PDD_HALINFO pHalInfo,
    __out_ecount(3) DWORD* pCallBackFlags,
    __out_opt LPD3DNTHAL_CALLBACKS puD3dCallbacks,
    __out_opt LPD3DNTHAL_GLOBALDRIVERDATA puD3dDriverData,
    __out_opt PDD_D3DBUFCALLBACKS puD3dBufferCallbacks,
    __out_opt LPDDSURFACEDESC puD3dTextureFormats,
    __out DWORD* puNumHeaps,
    __out_opt VIDEOMEMORY* puvmList,
    __out DWORD* puNumFourCC,
    __out_opt DWORD* puFourCC
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDdReenableDirectDrawObject(
    __in HANDLE hDirectDrawLocal,
    __inout BOOL* pubNewMode
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDdReleaseDC(
    __in HANDLE hSurface
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDdResetVisrgn(
    __in HANDLE hSurface,
    __in HWND hwnd
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdSetColorKey(
    __in HANDLE hSurface,
    __inout PDD_SETCOLORKEYDATA puSetColorKeyData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdSetOverlayPosition(
    __in HANDLE hSurfaceSource,
    __in HANDLE hSurfaceDestination,
    __inout PDD_SETOVERLAYPOSITIONDATA puSetOverlayPositionData
    );

__kernel_entry W32KAPI VOID APIENTRY
NtGdiDdUnattachSurface(
    __in HANDLE hSurface,
    __in HANDLE hSurfaceAttached
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdUnlock(
    __in HANDLE hSurface,
    __inout PDD_UNLOCKDATA puUnlockData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdUpdateOverlay(
    __in HANDLE hSurfaceDestination,
    __in HANDLE hSurfaceSource,
    __inout PDD_UPDATEOVERLAYDATA puUpdateOverlayData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdWaitForVerticalBlank(
    __in HANDLE hDirectDraw,
    __inout PDD_WAITFORVERTICALBLANKDATA puWaitForVerticalBlankData
    );

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiDdGetDxHandle(
    __in_opt HANDLE hDirectDraw,
    __in_opt HANDLE hSurface,
    __in BOOL bRelease
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDdSetGammaRamp(
    __in HANDLE hDirectDraw,
    __in HDC hdc,
    __in_bcount(256*3*2) LPVOID lpGammaRamp
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdLockD3D(
    __in HANDLE hSurface,
    __inout PDD_LOCKDATA puLockData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdUnlockD3D(
    __in HANDLE hSurface,
    __inout PDD_UNLOCKDATA puUnlockData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdCreateD3DBuffer(
    __in HANDLE hDirectDraw,
    __inout HANDLE* hSurface,
    __inout DDSURFACEDESC* puSurfaceDescription,
    __inout DD_SURFACE_GLOBAL* puSurfaceGlobalData,
    __inout DD_SURFACE_LOCAL* puSurfaceLocalData,
    __inout DD_SURFACE_MORE* puSurfaceMoreData,
    __inout DD_CREATESURFACEDATA* puCreateSurfaceData,
    __inout HANDLE* puhSurface
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdCanCreateD3DBuffer(
    __in HANDLE hDirectDraw,
    __inout PDD_CANCREATESURFACEDATA puCanCreateSurfaceData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdDestroyD3DBuffer(
    __in HANDLE hSurface
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiD3dContextCreate(
    __in HANDLE hDirectDrawLocal,
    __in HANDLE hSurfColor,
    __in HANDLE hSurfZ,
    __inout D3DNTHAL_CONTEXTCREATEI *pdcci
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiD3dContextDestroy(
    __in LPD3DNTHAL_CONTEXTDESTROYDATA
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiD3dContextDestroyAll(
    __out LPD3DNTHAL_CONTEXTDESTROYALLDATA pdcdad
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiD3dValidateTextureStageState(
    __inout LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA pData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiD3dDrawPrimitives2(
    __in HANDLE hCmdBuf,
    __in HANDLE hVBuf,
    __inout LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
    __inout FLATPTR* pfpVidMemCmd,
    __inout DWORD* pdwSizeCmd,
    __inout FLATPTR* pfpVidMemVtx,
    __inout DWORD* pdwSizeVtx
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdGetDriverState(
    __inout PDD_GETDRIVERSTATEDATA pdata
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdCreateSurfaceEx(
    __in HANDLE hDirectDraw,
    __in HANDLE hSurface,
    __in DWORD dwSurfaceHandle
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpCanCreateVideoPort(
    __in HANDLE hDirectDraw,
    __inout PDD_CANCREATEVPORTDATA puCanCreateVPortData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpColorControl(
    __in HANDLE hVideoPort,
    __inout PDD_VPORTCOLORDATA puVPortColorData
    );

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiDvpCreateVideoPort(
    __in HANDLE hDirectDraw,
    __inout PDD_CREATEVPORTDATA puCreateVPortData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpDestroyVideoPort(
    __in HANDLE hVideoPort,
    __inout PDD_DESTROYVPORTDATA puDestroyVPortData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpFlipVideoPort(
    __in HANDLE hVideoPort,
    __in HANDLE hDDSurfaceCurrent,
    __in HANDLE hDDSurfaceTarget,
    __inout PDD_FLIPVPORTDATA puFlipVPortData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpGetVideoPortBandwidth(
    __in HANDLE hVideoPort,
    __inout PDD_GETVPORTBANDWIDTHDATA puGetVPortBandwidthData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpGetVideoPortField(
    __in HANDLE hVideoPort,
    __inout PDD_GETVPORTFIELDDATA puGetVPortFieldData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpGetVideoPortFlipStatus(
    __in HANDLE hDirectDraw,
    __inout PDD_GETVPORTFLIPSTATUSDATA puGetVPortFlipStatusData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpGetVideoPortInputFormats(
    __in HANDLE hVideoPort,
    __inout PDD_GETVPORTINPUTFORMATDATA puGetVPortInputFormatData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpGetVideoPortLine(
    __in HANDLE hVideoPort,
    __inout PDD_GETVPORTLINEDATA puGetVPortLineData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpGetVideoPortOutputFormats(
    __in HANDLE hVideoPort,
    __inout PDD_GETVPORTOUTPUTFORMATDATA puGetVPortOutputFormatData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpGetVideoPortConnectInfo(
    __in HANDLE hDirectDraw,
    __inout PDD_GETVPORTCONNECTDATA puGetVPortConnectData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpGetVideoSignalStatus(
    __in HANDLE hVideoPort,
    __inout PDD_GETVPORTSIGNALDATA puGetVPortSignalData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpUpdateVideoPort(
    __in HANDLE hVideoPort,
    __in HANDLE* phSurfaceVideo,
    __in HANDLE* phSurfaceVbi,
    __inout PDD_UPDATEVPORTDATA puUpdateVPortData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpWaitForVideoPortSync(
    __in HANDLE hVideoPort,
    __inout PDD_WAITFORVPORTSYNCDATA puWaitForVPortSyncData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpAcquireNotification(
    __in HANDLE hVideoPort,
    __inout HANDLE* hEvent,
    __in LPDDVIDEOPORTNOTIFY pNotify
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDvpReleaseNotification(
    __in HANDLE hVideoPort,
    __in HANDLE hEvent
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdGetMoCompGuids(
    __in HANDLE hDirectDraw,
    __inout PDD_GETMOCOMPGUIDSDATA puGetMoCompGuidsData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdGetMoCompFormats(
    __in HANDLE hDirectDraw,
    __inout PDD_GETMOCOMPFORMATSDATA puGetMoCompFormatsData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdGetMoCompBuffInfo(
    __in HANDLE hDirectDraw,
    __inout PDD_GETMOCOMPCOMPBUFFDATA puGetBuffData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdGetInternalMoCompInfo(
    __in HANDLE hDirectDraw,
    __inout PDD_GETINTERNALMOCOMPDATA puGetInternalData
    );

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiDdCreateMoComp(
    __in HANDLE hDirectDraw,
    __inout PDD_CREATEMOCOMPDATA puCreateMoCompData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdDestroyMoComp(
    __in HANDLE hMoComp,
    __inout PDD_DESTROYMOCOMPDATA puDestroyMoCompData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdBeginMoCompFrame(
    __in HANDLE hMoComp,
    __inout PDD_BEGINMOCOMPFRAMEDATA puBeginFrameData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdEndMoCompFrame(
    __in HANDLE hMoComp,
    __inout PDD_ENDMOCOMPFRAMEDATA puEndFrameData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdRenderMoComp(
    __in HANDLE hMoComp,
    __inout PDD_RENDERMOCOMPDATA puRenderMoCompData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdQueryMoCompStatus(
    __in HANDLE hMoComp,
    __inout PDD_QUERYMOCOMPSTATUSDATA puQueryMoCompStatusData
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiDdAlphaBlt(
    __in HANDLE hSurfaceDest,
    __in_opt HANDLE hSurfaceSrc,
    __inout PDD_BLTDATA puBltData
    );


// Image32

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiAlphaBlend(
    __in HDC hdcDst,
    __in LONG DstX,
    __in LONG DstY,
    __in LONG DstCx,
    __in LONG DstCy,
    __in HDC hdcSrc,
    __in LONG SrcX,
    __in LONG SrcY,
    __in LONG SrcCx,
    __in LONG SrcCy,
    __in BLENDFUNCTION BlendFunction,
    __in HANDLE hcmXform
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGradientFill(
    __in HDC hdc,
    __in_ecount(nVertex) PTRIVERTEX pVertex,
    __in ULONG nVertex,
    __in PVOID pMesh,
    __in ULONG nMesh,
    __in ULONG ulMode
    );


// icm (Image Color Matching)
__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetIcmMode(
    __in HDC hdc,
    __in ULONG nCommand,
    __in ULONG ulMode
    );


#define ICM_SET_MODE             1
#define ICM_SET_CALIBRATE_MODE   2
#define ICM_SET_COLOR_MODE       3
#define ICM_CHECK_COLOR_MODE     4

typedef struct _LOGCOLORSPACEEXW
{
    LOGCOLORSPACEW lcsColorSpace;
    DWORD          dwFlags;
} LOGCOLORSPACEEXW, *PLOGCOLORSPACEEXW;

#define LCSEX_ANSICREATED    0x0001 // Created by CreateColorSpaceA()
#define LCSEX_TEMPPROFILE    0x0002 // Color profile is temporary file

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiCreateColorSpace(
    __in PLOGCOLORSPACEEXW pLogColorSpace
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDeleteColorSpace(
    __in HANDLE hColorSpace
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetColorSpace(
    __in HDC hdc,
    __in HCOLORSPACE hColorSpace
    );

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiCreateColorTransform(
    __in HDC hdc,
    __in LPLOGCOLORSPACEW pLogColorSpaceW,
    __in_bcount_opt(cjSrcProfile) PVOID pvSrcProfile,
    __in ULONG cjSrcProfile,
    __in_bcount_opt(cjDestProfile) PVOID pvDestProfile,
    __in ULONG cjDestProfile,
    __in_bcount_opt(cjTargetProfile) PVOID pvTargetProfile,
    __in ULONG cjTargetProfile
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDeleteColorTransform(
    __in HDC hdc,
    __in HANDLE hColorTransform
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiCheckBitmapBits(
    __in HDC hdc,
    __in HANDLE hColorTransform,
    __in PVOID pvBits,
    __in ULONG bmFormat,
    __in DWORD dwWidth,
    __in DWORD dwHeight,
    __in DWORD dwStride,
    __out_bcount(dwWidth * dwHeight) PBYTE paResults
    );


__kernel_entry W32KAPI ULONG APIENTRY
NtGdiColorCorrectPalette(
    __in HDC hdc,
    __in HPALETTE hpal,
    __in ULONG FirstEntry,
    __in ULONG NumberOfEntries,
    __inout_ecount(NumberOfEntries) PALETTEENTRY *ppalEntry,
    __in ULONG Command
    );

__kernel_entry W32KAPI ULONG_PTR APIENTRY
NtGdiGetColorSpaceforBitmap(
    __in HBITMAP hsurf
    );

typedef enum _COLORPALETTEINFO
{
    ColorPaletteQuery,
    ColorPaletteSet
} COLORPALETTEINFO, *PCOLORPALETTEINFO;

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetDeviceGammaRamp(
    __in HDC hdc,
    __out_bcount(256*2*3) LPVOID lpGammaRamp
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetDeviceGammaRamp(
    __in HDC hdc,
    __in_bcount(256*2*3) LPVOID lpGammaRamp
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiIcmBrushInfo(
    __in HDC hdc,
    __in HBRUSH hbrush,
    __inout_bcount(sizeof(BITMAPINFO) + ((/*MAX_COLORTABLE*/256 - 1) * sizeof(RGBQUAD))) PBITMAPINFO pbmiDIB,
    __inout_bcount(*pulBits) PVOID pvBits,
    __inout ULONG *pulBits,
    __out_opt DWORD *piUsage,
    __out_opt BOOL *pbAlreadyTran,
    __in ULONG Command
    );


typedef enum _ICM_DIB_INFO_CMD
{
    IcmQueryBrush,
    IcmSetBrush
} ICM_DIB_INFO, *PICM_DIB_INFO;

// PUBLIC

__kernel_entry W32KAPI VOID APIENTRY
NtGdiFlush();

__kernel_entry W32KAPI HDC APIENTRY
NtGdiCreateMetafileDC(
    __in HDC hdc
    );


__kernel_entry W32KAPI BOOL APIENTRY
NtGdiMakeInfoDC(
    __in HDC hdc,
    __in BOOL bSet
    );

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiCreateClientObj(
    __in ULONG ulType
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDeleteClientObj(
    __in HANDLE h
    );

__kernel_entry W32KAPI LONG APIENTRY
NtGdiGetBitmapBits(
    __in HBITMAP hbm,
    __in ULONG cjMax,
    __out_bcount_opt(cjMax) PBYTE pjOut
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDeleteObjectApp(
    __in HANDLE hobj
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiGetPath(
    __in HDC hdc,
    __out_ecount_opt(cptBuf) LPPOINT pptlBuf,
    __out_ecount_opt(cptBuf) LPBYTE pjTypes,
    __in int cptBuf
    );

__kernel_entry W32KAPI HDC APIENTRY
NtGdiCreateCompatibleDC(
    __in_opt HDC hdc
    );

__kernel_entry W32KAPI HBITMAP APIENTRY
NtGdiCreateDIBitmapInternal(
    __in HDC hdc,
    __in INT cx,
    __in INT cy,
    __in DWORD fInit,
    __in_bcount_opt(cjMaxBits) LPBYTE pjInit,
    __in_bcount_opt(cjMaxInitInfo) LPBITMAPINFO pbmi,
    __in DWORD iUsage,
    __in UINT cjMaxInitInfo,
    __in UINT cjMaxBits,
    __in FLONG f,
    __in HANDLE hcmXform
    );

__kernel_entry W32KAPI HBITMAP APIENTRY
NtGdiCreateDIBSection(
    __in_opt HDC hdc,
    __in_opt HANDLE hSectionApp,
    __in DWORD dwOffset,
    __in_bcount_opt(cjHeader) LPBITMAPINFO pbmi,
    __in DWORD iUsage,
    __in UINT cjHeader,
    __in FLONG fl,
    __in ULONG_PTR dwColorSpace,
    __deref_out PVOID *ppvBits
    );

__kernel_entry W32KAPI HBRUSH APIENTRY
NtGdiCreateSolidBrush(
    __in COLORREF cr,
    __in_opt HBRUSH hbr
    );

__kernel_entry W32KAPI HBRUSH APIENTRY
NtGdiCreateDIBBrush(
    __in_bcount(cj) PVOID pv,
    __in FLONG fl,
    __in UINT  cj,
    __in BOOL  b8X8,
    __in BOOL bPen,
    __in PVOID pClient
    );

__kernel_entry W32KAPI HBRUSH APIENTRY
NtGdiCreatePatternBrushInternal(
    __in HBITMAP hbm,
    __in BOOL bPen,
    __in BOOL b8X8
    );

__kernel_entry W32KAPI HBRUSH APIENTRY
NtGdiCreateHatchBrushInternal(
    __in ULONG ulStyle,
    __in COLORREF clrr,
    __in BOOL bPen
    );

__kernel_entry W32KAPI HPEN APIENTRY
NtGdiExtCreatePen(
    __in ULONG flPenStyle,
    __in ULONG ulWidth,
    __in ULONG iBrushStyle,
    __in ULONG ulColor,
    __in ULONG_PTR lClientHatch,
    __in ULONG_PTR lHatch,
    __in ULONG cstyle,
    __in_ecount_opt(cstyle) PULONG pulStyle,
    __in ULONG cjDIB,
    __in BOOL bOldStylePen,
    __in_opt HBRUSH hbrush
    );

__kernel_entry W32KAPI HRGN APIENTRY
NtGdiCreateEllipticRgn(
    __in int xLeft,
    __in int yTop,
    __in int xRight,
    __in int yBottom
    );

__kernel_entry W32KAPI HRGN APIENTRY
NtGdiCreateRoundRectRgn(
    __in int xLeft,
    __in int yTop,
    __in int xRight,
    __in int yBottom,
    __in int xWidth,
    __in int yHeight
    );

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiCreateServerMetaFile(
    __in DWORD iType,
    __in ULONG cjData,
    __in_bcount(cjData) LPBYTE pjData,
    __in DWORD mm,
    __in DWORD xExt,
    __in DWORD yExt
    );

__kernel_entry W32KAPI HRGN APIENTRY
NtGdiExtCreateRegion(
    __in_opt LPXFORM px,
    __in DWORD cj,
    __in_bcount(cj) LPRGNDATA prgn
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiMakeFontDir(
    __in FLONG flEmbed,
    __out_bcount(cjFontDir) PBYTE pjFontDir,
    __in unsigned cjFontDir,
    __in_bcount(cjPathname) LPWSTR pwszPathname,
    __in unsigned cjPathname
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiPolyDraw(
    __in HDC hdc,
    __in_ecount(cpt) LPPOINT ppt,
    __in_ecount(cpt) LPBYTE pjAttr,
    __in ULONG cpt
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiPolyTextOutW(
    __in HDC hdc,
    __in_ecount(cStr) POLYTEXTW *pptw,
    __in UINT cStr,
    __in DWORD dwCodePage
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiGetServerMetaFileBits(
    __in HANDLE hmo,
    __in ULONG cjData,
    __out_bcount_opt(cjData) LPBYTE pjData,
    __out PDWORD piType,
    __out PDWORD pmm,
    __out PDWORD pxExt,
    __out PDWORD pyExt
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEqualRgn(
    __in HRGN hrgn1,
    __in HRGN hrgn2
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetBitmapDimension(
    __in HBITMAP hbm,
    __out LPSIZE psize
    );

__kernel_entry W32KAPI UINT APIENTRY
NtGdiGetNearestPaletteIndex(
    __in HPALETTE hpal,
    __in COLORREF crColor
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiPtVisible(
    __in HDC hdc,
    __in int x,
    __in int y
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiRectVisible(
    __in HDC hdc,
    __in LPRECT prc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiRemoveFontResourceW(
    __in_ecount(cwc) WCHAR *pwszFiles,
    __in ULONG cwc,
    __in ULONG cFiles,
    __in ULONG fl,
    __in DWORD dwPidTid,
    __in_opt DESIGNVECTOR *pdv
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiResizePalette(
    __in HPALETTE hpal,
    __in UINT cEntry
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetBitmapDimension(
    __in HBITMAP hbm,
    __in int cx,
    __in int cy,
    __out_opt LPSIZE psizeOut
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiOffsetClipRgn(
    __in HDC hdc,
    __in int x,
    __in int y
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiSetMetaRgn(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetTextJustification(
    __in HDC hdc,
    __in int lBreakExtra,
    __in int cBreak
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiGetAppClipBox(
    __in HDC hdc,
    __out LPRECT prc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetTextExtentExW(
    __in HDC hdc,
    __in_ecount_opt(cwc) LPWSTR lpwsz,
    __in ULONG cwc,
    __in ULONG dxMax,
    __out_opt ULONG *pcCh,   // range(0, cwc)
    __out_ecount_part_opt(cwc, *pcCh) PULONG pdxOut,
    __out LPSIZE psize,
    __in FLONG fl
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetCharABCWidthsW(
    __in HDC hdc,
    __in UINT wchFirst,
    __in ULONG cwch,
    __in_ecount_opt(cwch) PWCHAR pwch,
    __in FLONG fl,
    __out_bcount(cwch * sizeof(ABC)) __typefix(ABC *) PVOID pvBuf
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiGetCharacterPlacementW(
    __in HDC hdc,
    __in_ecount(nCount) LPWSTR pwsz,
    __in int nCount,
    __in int nMaxExtent,
    __inout LPGCP_RESULTSW pgcpw,
    __in DWORD dwFlags
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiAngleArc(
    __in HDC hdc,
    __in int x,
    __in int y,
    __in DWORD dwRadius,
    __in DWORD dwStartAngle,
    __in DWORD dwSweepAngle
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiBeginPath(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSelectClipPath(
    __in HDC hdc,
    __in int iMode
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiCloseFigure(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEndPath(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiAbortPath(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiFillPath(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiStrokeAndFillPath(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiStrokePath(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiWidenPath(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiFlattenPath(
    __in HDC hdc
    );

__kernel_entry W32KAPI HRGN APIENTRY
NtGdiPathToRegion(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetMiterLimit(
    __in HDC hdc,
    __in DWORD dwNew,
    __inout_opt PDWORD pdwOut
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetFontXform(
    __in HDC hdc,
    __in DWORD dwxScale,
    __in DWORD dwyScale
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetMiterLimit(
    __in HDC hdc,
    __out PDWORD pdwOut
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEllipse(
    __in HDC hdc,
    __in int xLeft,
    __in int yTop,
    __in int xRight,
    __in int yBottom
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiRectangle(
    __in HDC hdc,
    __in int xLeft,
    __in int yTop,
    __in int xRight,
    __in int yBottom
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiRoundRect(
    __in HDC hdc,
    __in int x1,
    __in int y1,
    __in int x2,
    __in int y2,
    __in int x3,
    __in int y3
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiPlgBlt(
    __in HDC hdcTrg,
    __in_ecount(3) LPPOINT pptlTrg,
    __in HDC hdcSrc,
    __in int xSrc,
    __in int ySrc,
    __in int cxSrc,
    __in int cySrc,
    __in_opt HBITMAP hbmMask,
    __in int xMask,
    __in int yMask,
    __in DWORD crBackColor
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiMaskBlt(
    __in HDC hdc,
    __in int xDst,
    __in int yDst,
    __in int cx,
    __in int cy,
    __in HDC hdcSrc,
    __in int xSrc,
    __in int ySrc,
    __in HBITMAP hbmMask,
    __in int xMask,
    __in int yMask,
    __in DWORD dwRop4,
    __in DWORD crBackColor
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiExtFloodFill(
    __in HDC hdc,
    __in INT x,
    __in INT y,
    __in COLORREF crColor,
    __in UINT iFillType
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiFillRgn(
    __in HDC hdc,
    __in HRGN hrgn,
    __in HBRUSH hbrush
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiFrameRgn(
    __in HDC hdc,
    __in HRGN hrgn,
    __in HBRUSH hbrush,
    __in int xWidth,
    __in int yHeight
    );

__kernel_entry W32KAPI COLORREF APIENTRY
NtGdiSetPixel(
    __in HDC hdcDst,
    __in int x,
    __in int y,
    __in COLORREF crColor
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiGetPixel(
    __in HDC hdc,
    __in int x,
    __in int y
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiStartPage(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEndPage(
    __in HDC hdc
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiStartDoc(
    __in HDC hdc,
    __in DOCINFOW *pdi,
    __out BOOL *pbBanding,
    __in INT iJob
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEndDoc(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiAbortDoc(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiUpdateColors(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetCharWidthW(
    __in HDC hdc,
    __in UINT wcFirst,
    __in UINT cwc,
    __in_ecount_opt(cwc) PWCHAR pwc,
    __in FLONG fl,
    __out_bcount(cwc * sizeof(ULONG)) __typefix(PULONG) PVOID pvBuf
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetCharWidthInfo(
    __in HDC hdc,
    __out PCHWIDTHINFO pChWidthInfo
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiDrawEscape(
    __in HDC hdc,
    __in int iEsc,
    __in int cjIn,
    __in_bcount_opt(cjIn) LPSTR pjIn
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiExtEscape(
    __in_opt HDC hdc,
    __in_ecount_opt(nDriver) PWCHAR pDriver,
    __in int nDriver,
    __in int iEsc,
    __in int cjIn,
    __in_bcount_opt(cjIn) LPSTR pjIn,
    __in int cjOut,
    __out_bcount_opt(cjOut) LPSTR pjOut
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiGetFontData(
    __in HDC hdc,
    __in DWORD dwTable,
    __in DWORD dwOffset,
    __out_bcount_part_opt(cjBuf, return) PVOID pvBuf,
    __in ULONG cjBuf
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiGetGlyphOutline(
    __in HDC hdc,
    __in WCHAR wch,
    __in UINT iFormat,
    __out LPGLYPHMETRICS pgm,
    __in ULONG cjBuf,
    __out_bcount_opt(cjBuf) PVOID pvBuf,
    __in LPMAT2 pmat2,
    __in BOOL bIgnoreRotation
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetETM(
    __in HDC hdc,
    __out_opt EXTTEXTMETRIC *petm
    );

__kernel_entry W32KAPI __success(return == 1) BOOL APIENTRY
NtGdiGetRasterizerCaps(
    __out_bcount(cjBytes) LPRASTERIZER_STATUS praststat,
    __in ULONG cjBytes
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiGetKerningPairs(
    __in HDC hdc,
    __in ULONG cPairs,
    __out_ecount_part_opt(cPairs, return) KERNINGPAIR *pkpDst
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiMonoBitmap(
    __in HBITMAP hbm
    );

__kernel_entry W32KAPI HBITMAP APIENTRY
NtGdiGetObjectBitmapHandle(
    __in HBRUSH hbr,
    __out UINT *piUsage
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiEnumObjects(
    __in HDC hdc,
    __in int iObjectType,
    __in ULONG cjBuf,
    __out_bcount_opt(cjBuf) PVOID pvBuf
    );

//
// NtGdiResetDC
//
// The actual size of the buffer at pdm is pdm->dmSize + pdm->dmDriverExtra.
// But this can not be specified with current annotation language.
//

typedef struct _DRIVER_INFO_2W DRIVER_INFO_2W;

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiResetDC(
    __in HDC hdc,
    __in LPDEVMODEW pdm,
    __out PBOOL pbBanding,
    __in_opt DRIVER_INFO_2W *pDriverInfo2,
    __out __typefix(PUMDHPDEV *) VOID *ppUMdhpdev
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiSetBoundsRect(
    __in HDC hdc,
    __in LPRECT prc,
    __in DWORD f
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetColorAdjustment(
    __in HDC hdc,
    __out PCOLORADJUSTMENT pcaOut
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetColorAdjustment(
    __in HDC hdc,
    __in PCOLORADJUSTMENT pca
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiCancelDC(
    __in HDC hdc
    );

//
// See comment on NtGdiResetDC
//

__kernel_entry W32KAPI HDC APIENTRY
NtGdiOpenDCW(
    __in_opt PUNICODE_STRING pustrDevice,
    __in DEVMODEW *pdm,
    __in PUNICODE_STRING pustrLogAddr,
    __in ULONG iType,
    __in BOOL bDisplay,
    __in_opt HANDLE hspool,
    __in_opt DRIVER_INFO_2W *pDriverInfo2,
    __out __typefix(PUMDHPDEV *) VOID *pUMdhpdev
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetDCDword(
    __in HDC hdc,
    __in UINT u,
    __out DWORD *Result
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetDCPoint(
    __in HDC hdc,
    __in UINT iPoint,
    __out PPOINTL pptOut
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiScaleViewportExtEx(
    __in HDC hdc,
    __in int xNum,
    __in int xDenom,
    __in int yNum,
    __in int yDenom,
    __out_opt LPSIZE pszOut
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiScaleWindowExtEx(
    __in HDC hdc,
    __in int xNum,
    __in int xDenom,
    __in int yNum,
    __in int yDenom,
    __out_opt LPSIZE pszOut
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetVirtualResolution(
    __in HDC hdc,
    __in int cxVirtualDevicePixel,
    __in int cyVirtualDevicePixel,
    __in int cxVirtualDeviceMm,
    __in int cyVirtualDeviceMm
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetSizeDevice(
    __in HDC hdc,
    __in int cxVirtualDevice,
    __in int cyVirtualDevice
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetTransform(
    __in HDC hdc,
    __in DWORD iXform,
    __out LPXFORM pxf
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiModifyWorldTransform(
    __in HDC hdc,
    __in_opt LPXFORM pxf,
    __in DWORD iXform
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiCombineTransform(
    __out LPXFORM pxfDst,
    __in LPXFORM pxfSrc1,
    __in LPXFORM pxfSrc2
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiTransformPoints(
    __in HDC hdc,
    __in_ecount(c) PPOINT pptIn,
    __out_ecount(c) PPOINT pptOut,
    __in int c,
    __in int iMode
    );

__kernel_entry W32KAPI LONG APIENTRY
NtGdiConvertMetafileRect(
    __in HDC hdc,
    __inout PRECTL prect
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiGetTextCharsetInfo(
    __in HDC hdc,
    __out_opt LPFONTSIGNATURE lpSig,
    __in DWORD dwFlags
    );


__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDoBanding(
    __in HDC hdc,
    __in BOOL bStart,
    __out POINTL *pptl,
    __out PSIZE pSize
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiGetPerBandInfo(
    __in HDC hdc,
    __inout PERBANDINFO *ppbi
    );

#define GS_NUM_OBJS_ALL    0
#define GS_HANDOBJ_CURRENT 1
#define GS_HANDOBJ_MAX     2
#define GS_HANDOBJ_ALLOC   3
#define GS_LOOKASIDE_INFO  4

__kernel_entry W32KAPI NTSTATUS APIENTRY
NtGdiGetStats(
    __in HANDLE hProcess,
    __in int iIndex,
    __in int iPidType,
    __out_bcount(cjResultSize) PVOID pResults,
    __in UINT cjResultSize
    );

//API's used by USER
__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetMagicColors(
    __in HDC hdc,
    __in PALETTEENTRY peMagic,
    __in ULONG Index
    );

__kernel_entry W32KAPI HBRUSH APIENTRY
NtGdiSelectBrush(
    __in HDC hdc,
    __in HBRUSH hbrush
    );

__kernel_entry W32KAPI HPEN APIENTRY
NtGdiSelectPen(
    __in HDC hdc,
    __in HPEN hpen
    );

__kernel_entry W32KAPI HBITMAP APIENTRY
NtGdiSelectBitmap(
    __in HDC hdc,
    __in HBITMAP hbm
    );

__kernel_entry W32KAPI HFONT APIENTRY
NtGdiSelectFont(
    __in HDC hdc,
    __in HFONT hf
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiExtSelectClipRgn(
    __in     HDC hdc,
    __in_opt HRGN hrgn,
    __in     int iMode
    );

__kernel_entry W32KAPI HPEN APIENTRY
NtGdiCreatePen(
    __in int iPenStyle,
    __in int iPenWidth,
    __in COLORREF cr,
    __in_opt HBRUSH hbr
    );


//
// Define _WINDOWBLT_NOTIFICATION_ to turn on Window BLT notification.
// This notification will set a special flag in the SURFOBJ passed to
// drivers when the DrvCopyBits operation is called to move a window.
//
// See also:
//      ntgdi\gre\maskblt.cxx
//
#ifndef _WINDOWBLT_NOTIFICATION_
#define _WINDOWBLT_NOTIFICATION_
#endif
#ifdef _WINDOWBLT_NOTIFICATION_
__kernel_entry W32KAPI BOOL APIENTRY
NtGdiBitBlt(
    __in HDC hdcDst,
    __in int x,
    __in int y,
    __in int cx,
    __in int cy,
    __in_opt HDC hdcSrc,
    __in int xSrc,
    __in int ySrc,
    __in DWORD rop4,
    __in DWORD crBackColor,
    __in FLONG fl
    );

#else
__kernel_entry W32KAPI BOOL APIENTRY
NtGdiBitBlt(
    __in HDC hdcDst,
    __in int x,
    __in int y,
    __in int cx,
    __in int cy,
    __in HDC hdcSrc,
    __in int xSrc,
    __in int ySrc,
    __in DWORD rop4,
    __in DWORD crBackColor
    );

#endif
__kernel_entry W32KAPI BOOL APIENTRY
NtGdiTileBitBlt(
    __in HDC hdcDst,
    __in RECTL * prectDst,
    __in HDC hdcSrc,
    __in RECTL * prectSrc,
    __in POINTL * pptlOrigin,
    __in DWORD rop4,
    __in DWORD crBackColor
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiTransparentBlt(
    __in HDC hdcDst,
    __in int xDst,
    __in int yDst,
    __in int cxDst,
    __in int cyDst,
    __in HDC hdcSrc,
    __in int xSrc,
    __in int ySrc,
    __in int cxSrc,
    __in int cySrc,
    __in COLORREF TransColor
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetTextExtent(
    __in HDC hdc,
    __in_ecount(cwc) LPWSTR lpwsz,
    __in int cwc,
    __out LPSIZE psize,
    __in UINT flOpts
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetTextMetricsW(
    __in HDC hdc,
    __out_bcount(cj) TMW_INTERNAL * ptm,
    __in ULONG cj
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiGetTextFaceW(
    __in HDC hdc,
    __in int cChar,
    __out_ecount_part_opt(cChar, return) LPWSTR pszOut,
    __in BOOL bAliasName
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiGetRandomRgn(
    __in HDC hdc,
    __in HRGN hrgn,
    __in int iRgn
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiExtTextOutW(
    __in HDC hdc,
    __in int x,
    __in int y,
    __in UINT flOpts,
    __in_opt LPRECT prcl,
    __in_ecount_opt(cwc) LPWSTR pwsz,
    __in_range(0, 0xffff) int cwc,
    __in_xcount_opt(cwc) LPINT pdx,
    __in DWORD dwCodePage
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiIntersectClipRect(
    __in HDC hdc,
    __in int xLeft,
    __in int yTop,
    __in int xRight,
    __in int yBottom
    );

__kernel_entry W32KAPI HRGN APIENTRY
NtGdiCreateRectRgn(
    __in int xLeft,
    __in int yTop,
    __in int xRight,
    __in int yBottom
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiPatBlt(
    __in HDC hdcDst,
    __in int x,
    __in int y,
    __in int cx,
    __in int cy,
    __in DWORD rop4
    );

typedef struct _POLYPATBLT POLYPATBLT,*PPOLYPATBLT;
__kernel_entry W32KAPI BOOL APIENTRY
NtGdiPolyPatBlt(
    __in HDC hdc,
    __in DWORD rop4,
    __in_ecount(Count) PPOLYPATBLT pPoly,
    __in DWORD Count,
    __in DWORD Mode
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiUnrealizeObject(
    __in HANDLE h
    );

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiGetStockObject(
    __in int iObject
    );

__kernel_entry W32KAPI HBITMAP APIENTRY
NtGdiCreateCompatibleBitmap(
    __in HDC hdc,
    __in int cx,
    __in int cy
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiLineTo(
    __in HDC hdc,
    __in int x,
    __in int y
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiMoveTo(
    __in HDC hdc,
    __in int x,
    __in int y,
    __out_opt LPPOINT pptOut
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiExtGetObjectW(
    __in HANDLE h,
    __in int cj,
    __out_bcount_opt(cj) LPVOID pvOut
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiGetDeviceCaps(
    __in HDC hdc,
    __in int i
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiGetDeviceCapsAll (
    __in_opt HDC hdc,
    __out PDEVCAPS pDevCaps
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiStretchBlt(
    __in HDC hdcDst,
    __in int xDst,
    __in int yDst,
    __in int cxDst,
    __in int cyDst,
    __in_opt HDC hdcSrc,
    __in int xSrc,
    __in int ySrc,
    __in int cxSrc,
    __in int cySrc,
    __in DWORD dwRop,
    __in DWORD dwBackColor
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetBrushOrg(
    __in HDC hdc,
    __in int x,
    __in int y,
    __out LPPOINT pptOut
    );

__kernel_entry W32KAPI HBITMAP APIENTRY
NtGdiCreateBitmap(
    __in int cx,
    __in int cy,
    __in UINT cPlanes,
    __in UINT cBPP,
    __in_opt LPBYTE pjInit
    );

__kernel_entry W32KAPI HPALETTE APIENTRY
NtGdiCreateHalftonePalette(
    __in HDC hdc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiRestoreDC(
    __in HDC hdc,
    __in int iLevel
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiExcludeClipRect(
    __in HDC hdc,
    __in int xLeft,
    __in int yTop,
    __in int xRight,
    __in int yBottom
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiSaveDC(
    __in HDC hdc
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiCombineRgn(
    __in HRGN hrgnDst,
    __in HRGN hrgnSrc1,
    __in HRGN hrgnSrc2,
    __in int iMode
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSetRectRgn(
    __in HRGN hrgn,
    __in int xLeft,
    __in int yTop,
    __in int xRight,
    __in int yBottom
    );

__kernel_entry W32KAPI LONG APIENTRY
NtGdiSetBitmapBits(
    __in HBITMAP hbm,
    __in ULONG cj,
    __in_bcount(cj) PBYTE pjInit
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiGetDIBitsInternal(
    __in HDC hdc,
    __in HBITMAP hbm,
    __in UINT iStartScan,
    __in UINT cScans,
    __out_bcount_opt(cjMaxBits) LPBYTE pBits,
    __inout LPBITMAPINFO pbmi,
    __in UINT iUsage,
    __in UINT cjMaxBits,
    __in UINT cjMaxInfo
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiOffsetRgn(
    __in HRGN hrgn,
    __in int cx,
    __in int cy
    );

__kernel_entry W32KAPI int APIENTRY
NtGdiGetRgnBox(
    __in HRGN hrgn,
    __out LPRECT prcOut
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiRectInRegion(
    __in HRGN hrgn,
    __inout LPRECT prcl
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiGetBoundsRect(
    __in HDC hdc,
    __out LPRECT prc,
    __in DWORD f
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiPtInRegion(
    __in HRGN hrgn,
    __in int x,
    __in int y
    );

__kernel_entry W32KAPI COLORREF APIENTRY
NtGdiGetNearestColor(
    __in HDC hdc,
    __in COLORREF cr
    );

__kernel_entry W32KAPI UINT APIENTRY
NtGdiGetSystemPaletteUse(
    __in HDC hdc
    );

__kernel_entry W32KAPI UINT APIENTRY
NtGdiSetSystemPaletteUse(
    __in HDC hdc,
    __in UINT ui
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiGetRegionData(
    __in HRGN hrgn,
    __in DWORD nCount,
    __out_bcount_part_opt(nCount, return) LPRGNDATA lpRgnData
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiInvertRgn(
    __in HDC hdc,
    __in HRGN hrgn
    );


// MISC FONT API's

__kernel_entry int W32KAPI APIENTRY
NtGdiAddFontResourceW(
    __in_ecount(cwc) WCHAR *pwszFiles,
    __in ULONG cwc,
    __in ULONG cFiles,
    __in FLONG f,
    __in DWORD dwPidTid,
    __in_opt DESIGNVECTOR *pdv
    );

#if (_WIN32_WINNT >= 0x0500)
__kernel_entry W32KAPI HFONT APIENTRY
NtGdiHfontCreate(
    __in_bcount(cjElfw) ENUMLOGFONTEXDVW *pelfw,
    __in ULONG cjElfw,
    __in LFTYPE lft,
    __in FLONG  fl,
    __in PVOID pvCliData
    );

#else
__kernel_entry W32KAPI HFONT APIENTRY
NtGdiHfontCreate(
    __in LPEXTLOGFONTW pelfw,
    __in ULONG cjElfw,
    __in LFTYPE lft,
    __in FLONG fl,
    __in PVOID pvCliData
    );

#endif

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiSetFontEnumeration(
    __in ULONG ulType
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEnumFontClose(
    __in ULONG_PTR idEnum
    );

#if (_WIN32_WINNT >= 0x0500)
__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEnumFontChunk(
    __in HDC hdc,
    __in ULONG_PTR idEnum,
    __in ULONG cjEfdw,
    __out ULONG *pcjEfdw,
    __out_bcount_part(cjEfdw, *pcjEfdw) PENUMFONTDATAW pefdw
    );

#endif
__kernel_entry W32KAPI ULONG_PTR APIENTRY
NtGdiEnumFontOpen(
    __in HDC hdc,
    __in ULONG iEnumType,
    __in FLONG flWin31Compat,
    __in ULONG cwchMax,
    __in_ecount_opt(cwchMax) LPWSTR pwszFaceName,
    __in ULONG lfCharSet,
    __out ULONG *pulCount
    );

#define TYPE_ENUMFONTS          1
#define TYPE_ENUMFONTFAMILIES   2
#define TYPE_ENUMFONTFAMILIESEX 3

__kernel_entry W32KAPI INT APIENTRY
NtGdiQueryFonts(
    __out_ecount(nBufferSize) PUNIVERSAL_FONT_ID pufiFontList,
    __in ULONG nBufferSize,
    __out PLARGE_INTEGER pTimeStamp
    );


// Console API

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiConsoleTextOut(
    __in HDC hdc,
    __in_ecount(nStrings) POLYTEXTW *lpto,
    __in UINT nStrings,
    __in RECTL *prclBounds
    );

__kernel_entry W32KAPI NTSTATUS APIENTRY
NtGdiFullscreenControl(
    IN FULLSCREENCONTROL FullscreenCommand,
    IN PVOID FullscreenInput,
    IN DWORD FullscreenInputLength,
    OUT PVOID FullscreenOutput,
    IN OUT PULONG FullscreenOutputLength
    );


// needed for win95 functionality

__kernel_entry W32KAPI DWORD
NtGdiGetCharSet(
    __in HDC hdc
    );


// needed for fontlinking

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEnableEudc(
    __in BOOL
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEudcLoadUnloadLink(
    __in_ecount_opt(cwcBaseFaceName) LPCWSTR pBaseFaceName,
    __in UINT cwcBaseFaceName,
    __in_ecount(cwcEudcFontPath) LPCWSTR pEudcFontPath,
    __in UINT cwcEudcFontPath,
    __in INT iPriority,
    __in INT iFontLinkType,
    __in BOOL bLoadLin
    );

__kernel_entry W32KAPI UINT APIENTRY
NtGdiGetStringBitmapW(
    __in HDC hdc,
    __in_ecount(1) LPWSTR pwsz,
    __in UINT cwc,
    __in UINT cj,
    __out_bcount(cj) BYTE *lpSB
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiGetEudcTimeStampEx(
    __in_ecount_opt(cwcBaseFaceName) LPWSTR lpBaseFaceName,
    __in ULONG cwcBaseFaceName,
    __in BOOL bSystemTimeStamp
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiQueryFontAssocInfo(
    __in HDC hdc
    );


#if (_WIN32_WINNT >= 0x0500)
__kernel_entry W32KAPI DWORD
NtGdiGetFontUnicodeRanges(
    __in HDC hdc,
    __out_post_bcount_opt(return) LPGLYPHSET pgs
    );

#endif

#ifdef LANGPACK
__kernel_entry W32KAPI BOOL
NtGdiGetRealizationInfo(
    __in HDC hdc,
    __out PREALIZATION_INFO pri,
    __in_opt HFONT hf
    );

#endif

typedef struct tagDOWNLOADDESIGNVECTOR {
    UNIVERSAL_FONT_ID ufiBase;
    DESIGNVECTOR      dv;
} DOWNLOADDESIGNVECTOR;

__kernel_entry W32KAPI BOOL
NtGdiAddRemoteMMInstanceToDC(
    __in HDC hdc,
    __in_bcount(cjDDV) DOWNLOADDESIGNVECTOR *pddv,
    __in ULONG cjDDV
    );


// user-mode printer support

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiUnloadPrinterDriver(
    __in_bcount(cbDriverName) LPWSTR pDriverName,
    __in ULONG cbDriverName
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngAssociateSurface(
    __in HSURF hsurf,
    __in HDEV hdev,
    __in FLONG flHooks
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngEraseSurface(
    __in SURFOBJ *pso,
    __in RECTL *prcl,
    __in ULONG iColor
    );

__kernel_entry W32KAPI HBITMAP APIENTRY
NtGdiEngCreateBitmap(
    __in SIZEL sizl,
    __in LONG lWidth,
    __in ULONG iFormat,
    __in FLONG fl,
    __in_opt PVOID pvBits
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngDeleteSurface(
    __in HSURF hsurf
    );

__kernel_entry W32KAPI SURFOBJ* APIENTRY
NtGdiEngLockSurface(
    __in HSURF hsurf
    );

__kernel_entry W32KAPI VOID APIENTRY
NtGdiEngUnlockSurface(
    __in SURFOBJ *
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngMarkBandingSurface(
    __in HSURF hsurf
    );

__kernel_entry W32KAPI HSURF APIENTRY
NtGdiEngCreateDeviceSurface(
    __in DHSURF dhsurf,
    __in SIZEL sizl,
    __in ULONG iFormatCompat
    );

__kernel_entry W32KAPI HBITMAP APIENTRY
NtGdiEngCreateDeviceBitmap(
    __in DHSURF dhsurf,
    __in SIZEL sizl,
    __in ULONG iFormatCompat
    );


__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngCopyBits(
    __in SURFOBJ *psoDst,
    __in SURFOBJ *psoSrc,
    __in_opt CLIPOBJ *pco,
    __in XLATEOBJ *pxlo,
    __in RECTL *prclDst,
    __in POINTL *pptlSrc
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngStretchBlt(
    __in SURFOBJ *psoDest,
    __in SURFOBJ *psoSrc,
    __in SURFOBJ *psoMask,
    __in CLIPOBJ *pco,
    __in XLATEOBJ *pxlo,
    __in COLORADJUSTMENT *pca,
    __in POINTL *pptlHTOrg,
    __in RECTL *prclDest,
    __in RECTL *prclSrc,
    __in POINTL *pptlMask,
    __in ULONG iMode
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngBitBlt(
    __in SURFOBJ *psoDst,
    __in SURFOBJ *psoSrc,
    __in SURFOBJ *psoMask,
    __in CLIPOBJ *pco,
    __in XLATEOBJ *pxlo,
    __in RECTL *prclDst,
    __in POINTL *pptlSrc,
    __in POINTL *pptlMask,
    __in BRUSHOBJ *pbo,
    __in POINTL *pptlBrush,
    __in ROP4 rop4
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngPlgBlt(
    __in SURFOBJ *psoTrg,
    __in SURFOBJ *psoSrc,
    __in_opt SURFOBJ *psoMsk,
    __in CLIPOBJ *pco,
    __in XLATEOBJ *pxlo,
    __in COLORADJUSTMENT *pca,
    __in POINTL *pptlBrushOrg,
    __in POINTFIX *pptfxDest,
    __in RECTL *prclSrc,
    __in_opt POINTL *pptlMask,
    __in ULONG iMode
    );

__kernel_entry W32KAPI HPALETTE APIENTRY
NtGdiEngCreatePalette(
    __in ULONG iMode,
    __in ULONG cColors,
    __in ULONG *pulColors,
    __in FLONG flRed,
    __in FLONG flGreen,
    __in FLONG flBlue
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngDeletePalette(
    __in HPALETTE hPal
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngStrokePath(
    __in SURFOBJ *pso,
    __in PATHOBJ *ppo,
    __in CLIPOBJ *pco,
    __in XFORMOBJ *pxo,
    __in BRUSHOBJ *pbo,
    __in POINTL *pptlBrushOrg,
    __in LINEATTRS *plineattrs,
    __in MIX mix
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngFillPath(
    __in SURFOBJ *pso,
    __in PATHOBJ *ppo,
    __in CLIPOBJ *pco,
    __in BRUSHOBJ *pbo,
    __in POINTL *pptlBrushOrg,
    __in MIX mix,
    __in FLONG flOptions
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngStrokeAndFillPath(
    __in SURFOBJ *pso,
    __in PATHOBJ *ppo,
    __in CLIPOBJ *pco,
    __in XFORMOBJ *pxo,
    __in BRUSHOBJ *pboStroke,
    __in LINEATTRS *plineattrs,
    __in BRUSHOBJ *pboFill,
    __in POINTL *pptlBrushOrg,
    __in MIX mix,
    __in FLONG flOptions
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngPaint(
    __in SURFOBJ *pso,
    __in CLIPOBJ *pco,
    __in BRUSHOBJ *pbo,
    __in POINTL *pptlBrushOrg,
    __in MIX mix
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngLineTo(
    __in SURFOBJ *pso,
    __in CLIPOBJ *pco,
    __in BRUSHOBJ *pbo,
    __in LONG x1,
    __in LONG y1,
    __in LONG x2,
    __in LONG y2,
    __in RECTL *prclBounds,
    __in MIX mix
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngAlphaBlend(
    __in SURFOBJ *psoDest,
    __in SURFOBJ *psoSrc,
    __in CLIPOBJ *pco,
    __in XLATEOBJ *pxlo,
    __in RECTL *prclDest,
    __in RECTL *prclSrc,
    __in BLENDOBJ *pBlendObj
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngGradientFill(
    __in SURFOBJ *psoDest,
    __in CLIPOBJ *pco,
    __in XLATEOBJ *pxlo,
    __in_ecount(nVertex) TRIVERTEX *pVertex,
    __in ULONG nVertex,
    __in_ecount(nMesh) PVOID pMesh,
    __in ULONG nMesh,
    __in RECTL *prclExtents,
    __in POINTL *pptlDitherOrg,
    __in ULONG ulMode
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngTransparentBlt(
    __in SURFOBJ *psoDst,
    __in SURFOBJ *psoSrc,
    __in CLIPOBJ *pco,
    __in XLATEOBJ *pxlo,
    __in RECTL *prclDst,
    __in RECTL *prclSrc,
    __in ULONG iTransColor,
    __in ULONG ulReserved
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngTextOut(
    __in SURFOBJ *pso,
    __in STROBJ *pstro,
    __in FONTOBJ *pfo,
    __in CLIPOBJ *pco,
    __in RECTL *prclExtra,
    __in RECTL *prclOpaque,
    __in BRUSHOBJ *pboFore,
    __in BRUSHOBJ *pboOpaque,
    __in POINTL *pptlOrg,
    __in MIX mix
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngStretchBltROP(
    __in SURFOBJ *psoTrg,
    __in SURFOBJ *psoSrc,
    __in SURFOBJ *psoMask,
    __in CLIPOBJ *pco,
    __in XLATEOBJ *pxlo,
    __in COLORADJUSTMENT *pca,
    __in POINTL *pptlBrushOrg,
    __in RECTL *prclTrg,
    __in RECTL *prclSrc,
    __in POINTL *pptlMask,
    __in ULONG iMode,
    __in BRUSHOBJ *pbo,
    __in ROP4 rop4
    );


__kernel_entry W32KAPI ULONG APIENTRY
NtGdiXLATEOBJ_cGetPalette(
    __in XLATEOBJ *pxlo,
    __in ULONG iPal,
    __in ULONG cPal,
    __out_ecount(cPal) ULONG *pPal
    );


__kernel_entry W32KAPI ULONG APIENTRY
NtGdiCLIPOBJ_cEnumStart(
    __in CLIPOBJ *pco,
    __in BOOL bAll,
    __in ULONG iType,
    __in ULONG iDirection,
    __in ULONG cLimit
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiCLIPOBJ_bEnum(
    __in CLIPOBJ *pco,
    __in ULONG cj,
    __out_bcount(cj) ULONG *pul
    );

__kernel_entry W32KAPI PATHOBJ* APIENTRY
NtGdiCLIPOBJ_ppoGetPath(
    __in CLIPOBJ *pco
    );

__kernel_entry W32KAPI CLIPOBJ* APIENTRY
NtGdiEngCreateClip();

__kernel_entry W32KAPI VOID APIENTRY
NtGdiEngDeleteClip(
    __in CLIPOBJ*pco
    );

__kernel_entry W32KAPI PVOID APIENTRY
NtGdiBRUSHOBJ_pvAllocRbrush(
    __in BRUSHOBJ *pbo,
    __in ULONG cj
    );

__kernel_entry W32KAPI PVOID APIENTRY
NtGdiBRUSHOBJ_pvGetRbrush(
    __in BRUSHOBJ *pbo
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiBRUSHOBJ_ulGetBrushColor(
    __in BRUSHOBJ *pbo
    );

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiBRUSHOBJ_hGetColorTransform(
    __in BRUSHOBJ *pbo
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiXFORMOBJ_bApplyXform(
    __in XFORMOBJ *pxo,
    __in ULONG iMode,
    __in ULONG cPoints,
    __in_ecount(cPoints) POINTL *pvIn,
    __out_ecount(cPoints) POINTL *pvOut
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiXFORMOBJ_iGetXform(
    __in XFORMOBJ *pxo,
    __out_opt XFORML *pxform
    );

__kernel_entry W32KAPI VOID APIENTRY
NtGdiFONTOBJ_vGetInfo(
    __in FONTOBJ *pfo,
    __in ULONG cjSize,
    __out_bcount(cjSize) FONTINFO *pfi
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiFONTOBJ_cGetGlyphs(
    __in FONTOBJ *pfo,
    __in ULONG iMode,
    __in ULONG cGlyph,
    __in_ecount(1) HGLYPH *phg,
    __deref_out __typefix(PGLYPHDATA *) PVOID *ppvGlyph
    );

__kernel_entry W32KAPI XFORMOBJ* APIENTRY
NtGdiFONTOBJ_pxoGetXform(
    __in FONTOBJ *pfo
    );

__kernel_entry W32KAPI IFIMETRICS* APIENTRY
NtGdiFONTOBJ_pifi(
    __in FONTOBJ *pfo
    );

__kernel_entry W32KAPI FD_GLYPHSET* APIENTRY
NtGdiFONTOBJ_pfdg(
    __in FONTOBJ *pfo
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiFONTOBJ_cGetAllGlyphHandles(
    __in FONTOBJ *pfo,
    __out_post_ecount_opt(return) HGLYPH *phg
    );

__kernel_entry W32KAPI PVOID APIENTRY
NtGdiFONTOBJ_pvTrueTypeFontFile(
    __in FONTOBJ *pfo,
    __out ULONG *pcjFile
    );

__kernel_entry W32KAPI PFD_GLYPHATTR APIENTRY
NtGdiFONTOBJ_pQueryGlyphAttrs(
    __in FONTOBJ *pfo,
    __in ULONG iMode
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSTROBJ_bEnum(
    __in STROBJ *pstro,
    __out ULONG *pc,
    __deref_out_ecount(*pc) PGLYPHPOS *ppgpos
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSTROBJ_bEnumPositionsOnly(
    __in STROBJ *pstro,
    __out ULONG *pc,
    __deref_out_ecount(*pc) PGLYPHPOS *ppgpos
    );

__kernel_entry W32KAPI VOID APIENTRY
NtGdiSTROBJ_vEnumStart(
    __in STROBJ *pstro
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiSTROBJ_dwGetCodePage(
    __in STROBJ *pstro
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiSTROBJ_bGetAdvanceWidths(
    __in STROBJ*pstro,
    __in ULONG iFirst,
    __in ULONG c,
    __out_ecount(c) POINTQF*pptqD
    );

__kernel_entry W32KAPI FD_GLYPHSET* APIENTRY
NtGdiEngComputeGlyphSet(
    __in INT nCodePage,
    __in INT nFirstChar,
    __in INT cChars
    );

__kernel_entry W32KAPI ULONG APIENTRY
NtGdiXLATEOBJ_iXlate(
    __in XLATEOBJ *pxlo,
    __in ULONG iColor
    );

__kernel_entry W32KAPI HANDLE APIENTRY
NtGdiXLATEOBJ_hGetColorTransform(
    __in XLATEOBJ *pxlo
    );

__kernel_entry W32KAPI VOID APIENTRY
NtGdiPATHOBJ_vGetBounds(
    __in PATHOBJ *ppo,
    __out PRECTFX prectfx
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiPATHOBJ_bEnum(
    __in PATHOBJ *ppo,
    __out PATHDATA *ppd
    );

__kernel_entry W32KAPI VOID APIENTRY
NtGdiPATHOBJ_vEnumStart(
    __in PATHOBJ *ppo
    );

__kernel_entry W32KAPI VOID APIENTRY
NtGdiEngDeletePath(
    __in PATHOBJ *ppo
    );

__kernel_entry W32KAPI VOID APIENTRY
NtGdiPATHOBJ_vEnumStartClipLines(
    __in PATHOBJ *ppo,
    __in CLIPOBJ *pco,
    __in SURFOBJ *pso,
    __in LINEATTRS *pla
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiPATHOBJ_bEnumClipLines(
    __in PATHOBJ *ppo,
    __in ULONG cb,
    __out_bcount(cb) CLIPLINE *pcl
    );


__kernel_entry W32KAPI BOOL APIENTRY
NtGdiEngCheckAbort(
    __in SURFOBJ *pso
    );

__kernel_entry W32KAPI DHPDEV
NtGdiGetDhpdev(
    __in HDEV hdev
    );


__kernel_entry W32KAPI LONG APIENTRY
NtGdiHT_Get8BPPFormatPalette(
    __out_post_ecount_opt(return) LPPALETTEENTRY pPaletteEntry,
    __in USHORT RedGamma,
    __in USHORT GreenGamma,
    __in USHORT BlueGamma
    );

__kernel_entry W32KAPI LONG APIENTRY
NtGdiHT_Get8BPPMaskPalette(
    __out_post_ecount_opt(return) LPPALETTEENTRY pPaletteEntry,
    __in BOOL Use8BPPMaskPal,
    __in BYTE CMYMask,
    __in USHORT RedGamma,
    __in USHORT GreenGamma,
    __in USHORT BlueGamma
    );

__kernel_entry W32KAPI BOOL
NtGdiUpdateTransform(
    __in HDC hdc
    );

__kernel_entry W32KAPI DWORD APIENTRY
NtGdiSetLayout(
    __in HDC hdc,
    __in LONG wox,
    __in DWORD dwLayout
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiMirrorWindowOrg(
    __in HDC hdc
    );

__kernel_entry W32KAPI LONG APIENTRY
NtGdiGetDeviceWidth(
    __in HDC hdc
    );


__kernel_entry W32KAPI BOOL
NtGdiSetPUMPDOBJ(
    __in_opt HUMPD humpd,
    __in BOOL bStoreID,
    __inout_opt HUMPD *phumpd,
    __out_opt BOOL *pbWOW64
    );

__kernel_entry W32KAPI BOOL
NtGdiBRUSHOBJ_DeleteRbrush(
    __in_opt BRUSHOBJ *pbo,
    __in_opt BRUSHOBJ *pboB
    );

__kernel_entry W32KAPI BOOL
NtGdiUMPDEngFreeUserMem(
    __in KERNEL_PVOID *ppv
    );

__kernel_entry W32KAPI HBITMAP APIENTRY
NtGdiSetBitmapAttributes(
    __in HBITMAP hbm,
    __in DWORD dwFlags
    );

__kernel_entry W32KAPI HBITMAP APIENTRY
NtGdiClearBitmapAttributes(
    __in HBITMAP hbm,
    __in DWORD dwFlags
    );

__kernel_entry W32KAPI HBRUSH APIENTRY
NtGdiSetBrushAttributes(
    __in HBRUSH hbm,
    __in DWORD dwFlags
    );

__kernel_entry W32KAPI HBRUSH APIENTRY
NtGdiClearBrushAttributes(
    __in HBRUSH hbr,
    __in DWORD dwFlags
    );


// Private draw stream interface

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDrawStream(
    __in HDC hdcDst,
    __in ULONG cjIn,
    __in_bcount(cjIn) VOID *pvIn
    );

// Private Xfer interfaces

__kernel_entry W32KAPI BOOL APIENTRY NtGdiMakeObjectXferable(IN HANDLE h, IN DWORD dwProcessId);
__kernel_entry W32KAPI BOOL APIENTRY NtGdiMakeObjectUnXferable(IN HANDLE h);

// Private DWM interfaces

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDwmGetDirtyRgn(
    __in HSPRITE hSprite,
    __in UINT_PTR uiCookie,
    __out HRGN* phrgn,
    __out HRGN* phrgnAccum,
    __out BOOL* pbComposeOnce
    );

__kernel_entry W32KAPI BOOL APIENTRY
NtGdiDwmGetSurfaceData(
    __in HSPRITE hsprite,
    __inout_ecount(1) DWMSURFACEDATA *psurf
    );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NtDsAPI.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    ntdsapi.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for public NTDS APIs other than directory interfaces like LDAP.

Environment:

    User Mode - Win32

Notes:

--*/


#ifndef _NTDSAPI_H_
#define _NTDSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#include <schedule.h>

#if !defined(_NTDSAPI_)
#define NTDSAPI DECLSPEC_IMPORT
#if !defined(_NTDSAPI_POSTXP_ASLIB_)
#define NTDSAPI_POSTXP DECLSPEC_IMPORT
#else
#define NTDSAPI_POSTXP
#endif
#else
#define NTDSAPI
#define NTDSAPI_POSTXP
#endif

#ifdef __cplusplus
extern "C" {
#endif

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Data definitions                                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#ifdef MIDL_PASS
typedef GUID UUID;
typedef void * RPC_AUTH_IDENTITY_HANDLE;
typedef void VOID;
#endif


// Following constants define the Active Directory Behavior
// Version numbers.
#define DS_BEHAVIOR_WIN2000                            0
#define DS_BEHAVIOR_WIN2003_WITH_MIXED_DOMAINS         1
#define DS_BEHAVIOR_WIN2003                            2
#define DS_BEHAVIOR_WIN2008                            3

// Deprecated constants
#define DS_BEHAVIOR_LONGHORN 		DS_BEHAVIOR_WIN2008

#define DS_DEFAULT_LOCALE                                           \
           (MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),  \
                     SORT_DEFAULT))

#define DS_DEFAULT_LOCALE_COMPARE_FLAGS    (NORM_IGNORECASE     |   \
                                            NORM_IGNOREKANATYPE |   \
                                            NORM_IGNORENONSPACE |   \
                                            NORM_IGNOREWIDTH    |   \
                                            SORT_STRINGSORT )

// When booted to DS mode, this event is signalled when the DS has completed
// its initial sync attempts.  The period of time between system startup and
// this event's state being set is indeterminate from the local service's
// standpoint.  In the meantime the contents of the DS should be considered
// incomplete / out-dated, and the machine will not be advertised as a domain
// controller to off-machine clients.  Other local services that rely on
// information published in the DS should avoid accessing (or at least
// relying on) the contents of the DS until this event is set.
#define DS_SYNCED_EVENT_NAME    "NTDSInitialSyncsCompleted"
#define DS_SYNCED_EVENT_NAME_W L"NTDSInitialSyncsCompleted"

// Permissions bits used in security descriptors in the directory.
#ifndef _DS_CONTROL_BITS_DEFINED_
#define _DS_CONTROL_BITS_DEFINED_
#define ACTRL_DS_OPEN                           0x00000000
#define ACTRL_DS_CREATE_CHILD                   0x00000001
#define ACTRL_DS_DELETE_CHILD                   0x00000002
#define ACTRL_DS_LIST                           0x00000004
#define ACTRL_DS_SELF                           0x00000008
#define ACTRL_DS_READ_PROP                      0x00000010
#define ACTRL_DS_WRITE_PROP                     0x00000020
#define ACTRL_DS_DELETE_TREE                    0x00000040
#define ACTRL_DS_LIST_OBJECT                    0x00000080
#define ACTRL_DS_CONTROL_ACCESS                 0x00000100

// generic read
#define DS_GENERIC_READ          ((STANDARD_RIGHTS_READ)     | \
                                  (ACTRL_DS_LIST)            | \
                                  (ACTRL_DS_READ_PROP)       | \
                                  (ACTRL_DS_LIST_OBJECT))

// generic execute
#define DS_GENERIC_EXECUTE       ((STANDARD_RIGHTS_EXECUTE)  | \
                                  (ACTRL_DS_LIST))
// generic right
#define DS_GENERIC_WRITE         ((STANDARD_RIGHTS_WRITE)    | \
                                  (ACTRL_DS_SELF)            | \
                                  (ACTRL_DS_WRITE_PROP))
// generic all

#define DS_GENERIC_ALL           ((STANDARD_RIGHTS_REQUIRED) | \
                                  (ACTRL_DS_CREATE_CHILD)    | \
                                  (ACTRL_DS_DELETE_CHILD)    | \
                                  (ACTRL_DS_DELETE_TREE)     | \
                                  (ACTRL_DS_READ_PROP)       | \
                                  (ACTRL_DS_WRITE_PROP)      | \
                                  (ACTRL_DS_LIST)            | \
                                  (ACTRL_DS_LIST_OBJECT)     | \
                                  (ACTRL_DS_CONTROL_ACCESS)  | \
                                  (ACTRL_DS_SELF))
#endif

typedef enum
{
    // unknown name type
    DS_UNKNOWN_NAME = 0,

    // eg: CN=User Name,OU=Users,DC=Example,DC=Microsoft,DC=Com
    DS_FQDN_1779_NAME = 1,

    // eg: Example\UserN
    // Domain-only version includes trailing '\\'.
    DS_NT4_ACCOUNT_NAME = 2,

    // Probably "User Name" but could be something else.  I.e. The
    // display name is not necessarily the defining RDN.
    DS_DISPLAY_NAME = 3,

    // obsolete - see #define later
    // DS_DOMAIN_SIMPLE_NAME = 4,

    // obsolete - see #define later
    // DS_ENTERPRISE_SIMPLE_NAME = 5,

    // String-ized GUID as returned by IIDFromString().
    // eg: {4fa050f0-f561-11cf-bdd9-00aa003a77b6}
    DS_UNIQUE_ID_NAME = 6,

    // eg: example.microsoft.com/software/user name
    // Domain-only version includes trailing '/'.
    DS_CANONICAL_NAME = 7,

    // eg: usern@example.microsoft.com
    DS_USER_PRINCIPAL_NAME = 8,

    // Same as DS_CANONICAL_NAME except that rightmost '/' is
    // replaced with '\n' - even in domain-only case.
    // eg: example.microsoft.com/software\nuser name
    DS_CANONICAL_NAME_EX = 9,

    // eg: www/www.microsoft.com@example.com - generalized service principal
    // names.
    DS_SERVICE_PRINCIPAL_NAME = 10,

    // This is the string representation of a SID.  Invalid for formatDesired.
    // See sddl.h for SID binary <--> text conversion routines.
    // eg: S-1-5-21-397955417-626881126-188441444-501
    DS_SID_OR_SID_HISTORY_NAME = 11,

    // Pseudo-name format so GetUserNameEx can return the DNS domain name to
    // a caller.  This level is not supported by the DS APIs.
    DS_DNS_DOMAIN_NAME = 12

} DS_NAME_FORMAT;

// Map old name formats to closest new format so that old code builds
// against new headers w/o errors and still gets (almost) correct result.

#define DS_DOMAIN_SIMPLE_NAME       DS_USER_PRINCIPAL_NAME
#define DS_ENTERPRISE_SIMPLE_NAME   DS_USER_PRINCIPAL_NAME

typedef enum
{
    DS_NAME_NO_FLAGS = 0x0,

    // Perform a syntactical mapping at the client (if possible) without
    // going out on the wire.  Returns DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING
    // if a purely syntactical mapping is not possible.
    DS_NAME_FLAG_SYNTACTICAL_ONLY = 0x1,

    // Force a trip to the DC for evaluation, even if this could be
    // locally cracked syntactically.
    DS_NAME_FLAG_EVAL_AT_DC = 0x2,

    // The call fails if the DC is not a GC
    DS_NAME_FLAG_GCVERIFY = 0x4,

    // Enable cross forest trust referral
    DS_NAME_FLAG_TRUST_REFERRAL = 0x8

} DS_NAME_FLAGS;

typedef enum
{
    DS_NAME_NO_ERROR = 0,

    // Generic processing error.
    DS_NAME_ERROR_RESOLVING = 1,

    // Couldn't find the name at all - or perhaps caller doesn't have
    // rights to see it.
    DS_NAME_ERROR_NOT_FOUND = 2,

    // Input name mapped to more than one output name.
    DS_NAME_ERROR_NOT_UNIQUE = 3,

    // Input name found, but not the associated output format.
    // Can happen if object doesn't have all the required attributes.
    DS_NAME_ERROR_NO_MAPPING = 4,

    // Unable to resolve entire name, but was able to determine which
    // domain object resides in.  Thus DS_NAME_RESULT_ITEM?.pDomain
    // is valid on return.
    DS_NAME_ERROR_DOMAIN_ONLY = 5,

    // Unable to perform a purely syntactical mapping at the client
    // without going out on the wire.
    DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING = 6,

    // The name is from an external trusted forest.
    DS_NAME_ERROR_TRUST_REFERRAL = 7

} DS_NAME_ERROR;

#define DS_NAME_LEGAL_FLAGS (DS_NAME_FLAG_SYNTACTICAL_ONLY)

typedef enum {

    // "paulle-nec.ntwksta.ms.com"
    DS_SPN_DNS_HOST = 0,

    // "cn=paulle-nec,ou=computers,dc=ntwksta,dc=ms,dc=com"
    DS_SPN_DN_HOST = 1,

    // "paulle-nec"
    DS_SPN_NB_HOST = 2,

    // "ntdev.ms.com"
    DS_SPN_DOMAIN = 3,

    // "ntdev"
    DS_SPN_NB_DOMAIN = 4,

    // "cn=anRpcService,cn=RPC Services,cn=system,dc=ms,dc=com"
    // "cn=aWsService,cn=Winsock Services,cn=system,dc=ms,dc=com"
    // "cn=aService,dc=itg,dc=ms,dc=com"
    // "www.ms.com", "ftp.ms.com", "ldap.ms.com"
    // "products.ms.com"
    DS_SPN_SERVICE = 5

} DS_SPN_NAME_TYPE;

typedef enum {                          // example:
        DS_SPN_ADD_SPN_OP = 0,          // add SPNs
        DS_SPN_REPLACE_SPN_OP = 1,      // set all SPNs
        DS_SPN_DELETE_SPN_OP = 2        // Delete SPNs
} DS_SPN_WRITE_OP;

typedef struct
{
    DWORD                   status;     // DS_NAME_ERROR
#ifdef MIDL_PASS
    [string,unique] CHAR    *pDomain;   // DNS domain
    [string,unique] CHAR    *pName;     // name in requested format
#else
    LPSTR                   pDomain;    // DNS domain
    LPSTR                   pName;      // name in requested format
#endif

} DS_NAME_RESULT_ITEMA, *PDS_NAME_RESULT_ITEMA;

typedef struct
{
    DWORD                   cItems;     // item count
#ifdef MIDL_PASS
    [size_is(cItems)] PDS_NAME_RESULT_ITEMA rItems;
#else
    PDS_NAME_RESULT_ITEMA    rItems;    // item array
#endif

} DS_NAME_RESULTA, *PDS_NAME_RESULTA;

typedef struct
{
    DWORD                   status;     // DS_NAME_ERROR
#ifdef MIDL_PASS
    [string,unique] WCHAR   *pDomain;   // DNS domain
    [string,unique] WCHAR   *pName;     // name in requested format
#else
    LPWSTR                  pDomain;    // DNS domain
    LPWSTR                  pName;      // name in requested format
#endif

} DS_NAME_RESULT_ITEMW, *PDS_NAME_RESULT_ITEMW;

typedef struct
{
    DWORD                   cItems;     // item count
#ifdef MIDL_PASS
    [size_is(cItems)] PDS_NAME_RESULT_ITEMW rItems;
#else
    PDS_NAME_RESULT_ITEMW    rItems;    // item array
#endif

} DS_NAME_RESULTW, *PDS_NAME_RESULTW;

#ifdef UNICODE
#define DS_NAME_RESULT DS_NAME_RESULTW
#define PDS_NAME_RESULT PDS_NAME_RESULTW
#define DS_NAME_RESULT_ITEM DS_NAME_RESULT_ITEMW
#define PDS_NAME_RESULT_ITEM PDS_NAME_RESULT_ITEMW
#else
#define DS_NAME_RESULT DS_NAME_RESULTA
#define PDS_NAME_RESULT PDS_NAME_RESULTA
#define DS_NAME_RESULT_ITEM DS_NAME_RESULT_ITEMA
#define PDS_NAME_RESULT_ITEM PDS_NAME_RESULT_ITEMA
#endif

// Public replication option flags

// ********************
// DsBindWithSpnEx flags
// ********************
// Allow the Bind to use delegate service level, so that you can
// do ntdsapi operations that require delegation, such as
// DsAddSidHistory, and DsReplicaSyncAll().  Most operations do
// not require DELEGATE so this flag should only be specified
// if you need it, because if you bind to a rogue server with
// the DELEGATE flag, you'll allow the rogue server to use your
// credentials to connect back to a non-rogue server and perform
// operations other than you intended.
#define  NTDSAPI_BIND_ALLOW_DELEGATION		(0x00000001)
// With AD/AM, a single machine, could have multiple "AD's" on a
// single server.  Since DsBindXxxx() will not pick an AD/AM
// instance without an instance specifier ( ":389" ), it can be
// difficult (well impossible) to determine from just a server
// name, what the instance annotation or instance guid is.  This
// option will take a server name and find the first available
// AD or AD/AM instance.  WARNING: The results could be non-
// deterministic on a server w/ multiple instances.
#define  NTDSAPI_BIND_FIND_BINDING          (0x00000002)
// We have a family of API's for binding called DsBindWithSpn.
// Would anyone who called these and passed in a non-NULL SPN
// ever want to negotiate down to something that doesn't use that
// SPN?  No, this is a security hole.  So, for backwards compatibility
// if you call without an SPN, we'll create one for you, and attempt
// to use it, and allow negotiation to do it's thing if it doesn't
// work.
#define  NTDSAPI_BIND_FORCE_KERBEROS     (0x00000004)



// ********************
// Replica Sync flags
// These flag values are used both as input to DsReplicaSync and
// as output from DsReplicaGetInfo, PENDING_OPS, DS_REPL_OPW.ulOptions
// ********************

// Perform this operation asynchronously.
// Required when using DS_REPSYNC_ALL_SOURCES
#define DS_REPSYNC_ASYNCHRONOUS_OPERATION 0x00000001

// Writeable replica.  Otherwise, read-only.
#define DS_REPSYNC_WRITEABLE              0x00000002

// This is a periodic sync request as scheduled by the admin.
#define DS_REPSYNC_PERIODIC               0x00000004

// Use inter-site messaging
#define DS_REPSYNC_INTERSITE_MESSAGING    0x00000008

// Sync from all sources.
#define DS_REPSYNC_ALL_SOURCES            0x00000010

// Sync starting from scratch (i.e., at the first USN).
#define DS_REPSYNC_FULL                   0x00000020

// This is a notification of an update that was marked urgent.
#define DS_REPSYNC_URGENT                 0x00000040

// Don't discard this synchronization request, even if a similar
// sync is pending.
#define DS_REPSYNC_NO_DISCARD             0x00000080

// Sync even if link is currently disabled.
#define DS_REPSYNC_FORCE                  0x00000100

// Causes the source DSA to check if a reps-to is present for the local DSA
// (aka the destination). If not, one is added.  This ensures that
// source sends change notifications.
#define DS_REPSYNC_ADD_REFERENCE          0x00000200

// A sync from this source has never completed (e.g., a new source).
#define DS_REPSYNC_NEVER_COMPLETED        0x00000400

// When this sync is complete, requests a sync in the opposite direction.
#define DS_REPSYNC_TWO_WAY                0x00000800

// Do not request change notifications from this source.
#define DS_REPSYNC_NEVER_NOTIFY           0x00001000

// Sync the NC from this source when the DSA is started.
#define DS_REPSYNC_INITIAL                0x00002000

// Use compression when replicating.  Saves message size (e.g., network
// bandwidth) at the expense of extra CPU overhead at both the source and
// destination servers.
#define DS_REPSYNC_USE_COMPRESSION        0x00004000

// Sync was abandoned for lack of updates (W2K, W2K3)
#define DS_REPSYNC_ABANDONED              0x00008000

// Special secret processing
#define DS_REPSYNC_SELECT_SECRETS         0x00008000

// Initial sync in progress
#define DS_REPSYNC_INITIAL_IN_PROGRESS    0x00010000

// Partial Attribute Set sync in progress
#define DS_REPSYNC_PARTIAL_ATTRIBUTE_SET  0x00020000

// Sync is being retried
#define DS_REPSYNC_REQUEUE                0x00040000

// Sync is a notification request from a source
#define DS_REPSYNC_NOTIFICATION           0x00080000

// Sync is a special form which requests to establish contact
// now and do the rest of the sync later
#define DS_REPSYNC_ASYNCHRONOUS_REPLICA   0x00100000

// Request critical objects only
#define DS_REPSYNC_CRITICAL               0x00200000

// A full synchronization is in progress
#define DS_REPSYNC_FULL_IN_PROGRESS       0x00400000

// Synchronization request was previously preempted
#define DS_REPSYNC_PREEMPTED              0x00800000

// Non GC readonly replica
#define DS_REPSYNC_NONGC_RO_REPLICA       0x01000000

// ********************
// Replica Add flags
// ********************

// Perform this operation asynchronously.
#define DS_REPADD_ASYNCHRONOUS_OPERATION  0x00000001

// Create a writeable replica.  Otherwise, read-only.
#define DS_REPADD_WRITEABLE               0x00000002

// Sync the NC from this source when the DSA is started.
#define DS_REPADD_INITIAL                 0x00000004

// Sync the NC from this source periodically, as defined by the
// schedule passed in the preptimesSync argument.
#define DS_REPADD_PERIODIC                0x00000008

// Sync from the source DSA via an Intersite Messaging Service (ISM) transport
// (e.g., SMTP) rather than native DS RPC.
#define DS_REPADD_INTERSITE_MESSAGING     0x00000010

// Don't replicate the NC now -- just save enough state such that we
// know to replicate it later.
#define DS_REPADD_ASYNCHRONOUS_REPLICA     0x00000020

// Disable notification-based synchronization for the NC from this source.
// This is expected to be a temporary state; the similar flag
// DS_REPADD_NEVER_NOTIFY should be used if the disable is to be more permanent.
#define DS_REPADD_DISABLE_NOTIFICATION     0x00000040

// Disable periodic synchronization for the NC from this source
#define DS_REPADD_DISABLE_PERIODIC         0x00000080

// Use compression when replicating.  Saves message size (e.g., network
// bandwidth) at the expense of extra CPU overhead at both the source and
// destination servers.
#define DS_REPADD_USE_COMPRESSION          0x00000100

// Do not request change notifications from this source.  When this flag is
// set, the source will not notify the destination when changes occur.
// Recommended for all intersite replication, which may occur over WAN links.
// This is expected to be a more or less permanent state; the similar flag
// DS_REPADD_DISABLE_NOTIFICATION should be used if notifications are to be
// disabled only temporarily.
#define DS_REPADD_NEVER_NOTIFY             0x00000200

// When this sync is complete, requests a sync in the opposite direction.
#define DS_REPADD_TWO_WAY                  0x00000400

// Request critical objects only
// Critical only is only allowed while installing
// A critical only sync does not bring all objects in the partition. It
// replicates just the ones necessary for minimal directory operation.
// A normal, non-critical sync must be performed before the partition
// can be considered fully synchronized.
#define DS_REPADD_CRITICAL                 0x00000800

// Special secret processing
#define DS_REPADD_SELECT_SECRETS           0x00001000

// Non GC RO Replica
#define DS_REPADD_NONGC_RO_REPLICA         0x01000000



// ********************
// Replica Delete flags
// ********************

// Perform this operation asynchronously.
#define DS_REPDEL_ASYNCHRONOUS_OPERATION 0x00000001

// The replica being deleted is writeable.
#define DS_REPDEL_WRITEABLE               0x00000002

// Replica is a mail-based replica
#define DS_REPDEL_INTERSITE_MESSAGING     0x00000004

// Ignore any error generated by contacting the source to tell it to scratch
// this server from its Reps-To for this NC.
#define DS_REPDEL_IGNORE_ERRORS           0x00000008

// Do not contact the source telling it to scratch this server from its
// Rep-To for this NC.  Otherwise, if the link is RPC-based, the source will
// be contacted.
#define DS_REPDEL_LOCAL_ONLY              0x00000010

// Delete all the objects in the NC
// "No source" is incompatible with (and rejected for) writeable NCs.  This is
// valid only for read-only NCs, and then only if the NC has no source.  This
// can occur when the NC has been partially deleted (in which case the KCC
// periodically calls the delete API with the "no source" flag set).
#define DS_REPDEL_NO_SOURCE               0x00000020

// Allow deletion of read-only replica even if it sources
// other read-only replicas.
#define DS_REPDEL_REF_OK                  0x00000040


// ********************
// Replica Modify flags
// ********************

// Perform this operation asynchronously.
#define DS_REPMOD_ASYNCHRONOUS_OPERATION  0x00000001

// The replica is writeable.
#define DS_REPMOD_WRITEABLE               0x00000002


// ********************
// Replica Modify fields
// ********************

#define DS_REPMOD_UPDATE_FLAGS             0x00000001
#define DS_REPMOD_UPDATE_INSTANCE          0x00000002
#define DS_REPMOD_UPDATE_ADDRESS           DS_REPMOD_UPDATE_INSTANCE
#define DS_REPMOD_UPDATE_SCHEDULE          0x00000004
#define DS_REPMOD_UPDATE_RESULT            0x00000008
#define DS_REPMOD_UPDATE_TRANSPORT         0x00000010

// ********************
// Update Refs fields
// ********************

// Perform this operation asynchronously.
#define DS_REPUPD_ASYNCHRONOUS_OPERATION  0x00000001

// The replica being deleted is writeable.
#define DS_REPUPD_WRITEABLE               0x00000002

// Add a reference
#define DS_REPUPD_ADD_REFERENCE           0x00000004

// Remove a reference
#define DS_REPUPD_DELETE_REFERENCE        0x00000008

// Use GCSPN while notifying replica partner
#define DS_REPUPD_REFERENCE_GCSPN         0x00000010


// ********************
//  NC Related Flags
// ********************
//
// Instance Type bits, specifies flags for NC head creation.
//
#define DS_INSTANCETYPE_IS_NC_HEAD        0x00000001 // This if what to specify on an object to indicate it's an NC Head.
#define DS_INSTANCETYPE_NC_IS_WRITEABLE   0x00000004 // This is to indicate that the NC Head is writeable.
#define DS_INSTANCETYPE_NC_COMING         0x00000010 // This is to indicate that this NC is still replicating in objects to this DC, and may not be a complete NC.
#define DS_INSTANCETYPE_NC_GOING          0x00000020 // This is to indicate that this NC is in the process of being removed from this DC, and may not be a complete NC.

// ********************
//  xxx_OPT_xxx Flags
// ********************

// These macros define bit flags which can be set in the "options" attribute
// of objects of the specified object class.

// Bit flags valid for options attribute on NTDS-DSA objects.
//
#define NTDSDSA_OPT_IS_GC                     ( 1 << 0 ) /* DSA is a global catalog */
#define NTDSDSA_OPT_DISABLE_INBOUND_REPL      ( 1 << 1 ) /* disable inbound replication */
#define NTDSDSA_OPT_DISABLE_OUTBOUND_REPL     ( 1 << 2 ) /* disable outbound replication */
#define NTDSDSA_OPT_DISABLE_NTDSCONN_XLATE    ( 1 << 3 ) /* disable logical conn xlation */
#define NTDSDSA_OPT_DISABLE_SPN_REGISTRATION  ( 1 << 4 ) /* disable SPN registration for ADAM */
#define NTDSDSA_OPT_GENERATE_OWN_TOPO         ( 1 << 5 ) /* create own site topology */

// Bit flags for options attribute on NTDS-Connection objects.
//
// The reasons that two bits are required to control notification are as follows.
// We must support existing connections with the old behavior and the UI does not
// create manual connections with the new bit set.
// The default for existing and manually created connections with bits 2 and 3
// clear must be the standard prior behavior: notification for intra-site and
// no notification for inter-site.
// We need a way to distinguish a old connection which desires the default
// notification rules, and a new connection for which we desire to explicitly
// control the notification state as passed down from a site link.  Thus we
// have a new bit to say we are overriding the default, and a new bit to indicate
// what the overridden default shall be.
//
#define NTDSCONN_OPT_IS_GENERATED ( 1 << 0 )  /* object generated by DS, not admin */
#define NTDSCONN_OPT_TWOWAY_SYNC  ( 1 << 1 )  /* force sync in opposite direction at end of sync */
#define NTDSCONN_OPT_OVERRIDE_NOTIFY_DEFAULT (1 << 2 )  // Do not use defaults to determine notification
#define NTDSCONN_OPT_USE_NOTIFY   (1 << 3) // Does source notify destination

// For intra-site connections, this bit has no meaning.
// For inter-site connections, this bit means:
//  0 - Compression of replication data enabled
//  1 - Compression of replication data disabled
#define NTDSCONN_OPT_DISABLE_INTERSITE_COMPRESSION    (1 << 4)

// For connections whose IS_GENERATED bit is 0, this bit has no effect.
// For KCC-generated connections, this bit indicates that the schedule attribute
// is owned by the user and should not be touched by the KCC.
#define NTDSCONN_OPT_USER_OWNED_SCHEDULE    (1 << 5)

// This is the default rodc connection - 1 per rodc for FRS's uses
#define NTDSCONN_OPT_RODC_TOPOLOGY            (1 << 6)          

// Connection reasons
//
// Values for "reason for connection".  A connection can be needed for
// more than one reason.
//
#define NTDSCONN_KCC_NO_REASON                ( 0 )               // 000
#define NTDSCONN_KCC_GC_TOPOLOGY              ( 1 << 0 )          // 001
#define NTDSCONN_KCC_RING_TOPOLOGY            ( 1 << 1 )          // 002
#define NTDSCONN_KCC_MINIMIZE_HOPS_TOPOLOGY   ( 1 << 2 )          // 004
#define NTDSCONN_KCC_STALE_SERVERS_TOPOLOGY   ( 1 << 3 )          // 008
#define NTDSCONN_KCC_OSCILLATING_CONNECTION_TOPOLOGY   ( 1 << 4 ) // 010
#define NTDSCONN_KCC_INTERSITE_GC_TOPOLOGY    (1 << 5)            // 020
#define NTDSCONN_KCC_INTERSITE_TOPOLOGY       (1 << 6)            // 040
#define NTDSCONN_KCC_SERVER_FAILOVER_TOPOLOGY (1 << 7)            // 080
#define NTDSCONN_KCC_SITE_FAILOVER_TOPOLOGY   (1 << 8)            // 100
#define NTDSCONN_KCC_REDUNDANT_SERVER_TOPOLOGY (1 << 9)           // 200

//
// The high 4 bits of the options attribute are used by NTFRS to assign priority
// for inbound connections. Bit 31 is used to force FRS to ignore schedule during
// the initial sync. Bits 30 - 28 are used to specify a priority between 0-7.
//

#define FRSCONN_PRIORITY_MASK		      0x70000000
#define FRSCONN_MAX_PRIORITY		      0x8

#define NTDSCONN_OPT_IGNORE_SCHEDULE_MASK 0x80000000

#define	NTDSCONN_IGNORE_SCHEDULE(_options_)\
        (((_options_) & NTDSCONN_OPT_IGNORE_SCHEDULE_MASK) >> 31)

#define	FRSCONN_GET_PRIORITY(_options_)    \
        (((((_options_) & FRSCONN_PRIORITY_MASK) >> 28) != 0 ) ? \
         (((_options_) & FRSCONN_PRIORITY_MASK) >> 28) :        \
         FRSCONN_MAX_PRIORITY                                   \
        )

// Bit flags for options attribute on NTDS-Site-Settings objects.
//
#define NTDSSETTINGS_OPT_IS_AUTO_TOPOLOGY_DISABLED     ( 1 << 0 ) /* automatic topology gen disabled */
#define NTDSSETTINGS_OPT_IS_TOPL_CLEANUP_DISABLED      ( 1 << 1 ) /* automatic topology cleanup disabled */
#define NTDSSETTINGS_OPT_IS_TOPL_MIN_HOPS_DISABLED     ( 1 << 2 ) /* automatic minimum hops topology disabled */
#define NTDSSETTINGS_OPT_IS_TOPL_DETECT_STALE_DISABLED ( 1 << 3 ) /* automatic stale server detection disabled */
#define NTDSSETTINGS_OPT_IS_INTER_SITE_AUTO_TOPOLOGY_DISABLED ( 1 << 4 ) /* automatic inter-site topology gen disabled */
#define NTDSSETTINGS_OPT_IS_GROUP_CACHING_ENABLED      ( 1 << 5 ) /* group memberships for users enabled */
#define NTDSSETTINGS_OPT_FORCE_KCC_WHISTLER_BEHAVIOR   ( 1 << 6 ) /* force KCC to operate in Whistler behavior mode */
#define NTDSSETTINGS_OPT_FORCE_KCC_W2K_ELECTION        ( 1 << 7 ) /* force KCC to use the Windows 2000 ISTG election algorithm */
#define NTDSSETTINGS_OPT_IS_RAND_BH_SELECTION_DISABLED ( 1 << 8 ) /* prevent the KCC from randomly picking a bridgehead when creating a connection */
#define NTDSSETTINGS_OPT_IS_SCHEDULE_HASHING_ENABLED   ( 1 << 9 ) /* allow the KCC to use hashing when creating a replication schedule */
#define NTDSSETTINGS_OPT_IS_REDUNDANT_SERVER_TOPOLOGY_ENABLED     ( 1 << 10 ) /* create static failover connections */

// The following two options allow the new kcc spanning tree algorithm, which replaces the ISM,
// to override the ISM policy settings. These two flags are analogous to those found on the
// transport object.

// default without flag: schedules are significant
// This flag causes the KCC in W2K3 mode to ignore schedules
#define NTDSSETTINGS_OPT_W2K3_IGNORE_SCHEDULES ( 1 << 11 ) // Schedules disabled

// default without flag: links transitive (bridges not required) auto site link bridging enabled
// This flag causes the KCC in W2K3 mode to require bridges
#define NTDSSETTINGS_OPT_W2K3_BRIDGES_REQUIRED (1 << 12 ) // siteLink bridges are required

// How many redundant connections will be generated
#define NTDSSETTINGS_DEFAULT_SERVER_REDUNDANCY 2

// Bit flags for options attribute on Inter-Site-Transport objects
//
// Note, the sense of the flag should be such that the default state or
// behavior corresponds to the flag NOT being present. Put another way, the
// flag should state the OPPOSITE of the default
//
// default: schedules are significant
#define NTDSTRANSPORT_OPT_IGNORE_SCHEDULES ( 1 << 0 ) // Schedules disabled

// default: links transitive (bridges not required)
#define NTDSTRANSPORT_OPT_BRIDGES_REQUIRED (1 << 1 ) // siteLink bridges are required

// Bit flags for options attribute on site-Connection objects
//
// These are not realized in the DS, but are built up in the KCC
#define NTDSSITECONN_OPT_USE_NOTIFY ( 1 << 0 ) // Use notification on this link
#define NTDSSITECONN_OPT_TWOWAY_SYNC ( 1 << 1 )  /* force sync in opposite direction at end of sync */

// This bit means:
//  0 - Compression of replication data across this site connection enabled
//  1 - Compression of replication data across this site connection disabled
#define NTDSSITECONN_OPT_DISABLE_COMPRESSION ( 1 << 2 )

// Bit flags for options attribute on site-Link objects
// Note that these options are AND-ed along a site-link path
//
#define NTDSSITELINK_OPT_USE_NOTIFY ( 1 << 0 ) // Use notification on this link
#define NTDSSITELINK_OPT_TWOWAY_SYNC ( 1 << 1 )  /* force sync in opposite direction at end of sync */

// This bit means:
//  0 - Compression of replication data across this site link enabled
//  1 - Compression of replication data across this site link disabled
#define NTDSSITELINK_OPT_DISABLE_COMPRESSION ( 1 << 2 )


// ***********************
// Well Known Object Guids
// ***********************

#define GUID_USERS_CONTAINER_A              "a9d1ca15768811d1aded00c04fd8d5cd"
#define GUID_COMPUTRS_CONTAINER_A           "aa312825768811d1aded00c04fd8d5cd"
#define GUID_SYSTEMS_CONTAINER_A            "ab1d30f3768811d1aded00c04fd8d5cd"
#define GUID_DOMAIN_CONTROLLERS_CONTAINER_A "a361b2ffffd211d1aa4b00c04fd7d83a"
#define GUID_INFRASTRUCTURE_CONTAINER_A     "2fbac1870ade11d297c400c04fd8d5cd"
#define GUID_DELETED_OBJECTS_CONTAINER_A    "18e2ea80684f11d2b9aa00c04f79f805"
#define GUID_LOSTANDFOUND_CONTAINER_A       "ab8153b7768811d1aded00c04fd8d5cd"
#define GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_A "22b70c67d56e4efb91e9300fca3dc1aa"
#define GUID_PROGRAM_DATA_CONTAINER_A       "09460c08ae1e4a4ea0f64aee7daa1e5a"
#define GUID_MICROSOFT_PROGRAM_DATA_CONTAINER_A "f4be92a4c777485e878e9421d53087db"
#define GUID_NTDS_QUOTAS_CONTAINER_A        "6227f0af1fc2410d8e3bb10615bb5b0f"

#define GUID_USERS_CONTAINER_W              L"a9d1ca15768811d1aded00c04fd8d5cd"
#define GUID_COMPUTRS_CONTAINER_W           L"aa312825768811d1aded00c04fd8d5cd"
#define GUID_SYSTEMS_CONTAINER_W            L"ab1d30f3768811d1aded00c04fd8d5cd"
#define GUID_DOMAIN_CONTROLLERS_CONTAINER_W L"a361b2ffffd211d1aa4b00c04fd7d83a"
#define GUID_INFRASTRUCTURE_CONTAINER_W     L"2fbac1870ade11d297c400c04fd8d5cd"
#define GUID_DELETED_OBJECTS_CONTAINER_W    L"18e2ea80684f11d2b9aa00c04f79f805"
#define GUID_LOSTANDFOUND_CONTAINER_W       L"ab8153b7768811d1aded00c04fd8d5cd"
#define GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_W L"22b70c67d56e4efb91e9300fca3dc1aa"
#define GUID_PROGRAM_DATA_CONTAINER_W       L"09460c08ae1e4a4ea0f64aee7daa1e5a"
#define GUID_MICROSOFT_PROGRAM_DATA_CONTAINER_W L"f4be92a4c777485e878e9421d53087db"
#define GUID_NTDS_QUOTAS_CONTAINER_W        L"6227f0af1fc2410d8e3bb10615bb5b0f"

#define GUID_USERS_CONTAINER_BYTE              "\xa9\xd1\xca\x15\x76\x88\x11\xd1\xad\xed\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_COMPUTRS_CONTAINER_BYTE           "\xaa\x31\x28\x25\x76\x88\x11\xd1\xad\xed\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_SYSTEMS_CONTAINER_BYTE            "\xab\x1d\x30\xf3\x76\x88\x11\xd1\xad\xed\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_DOMAIN_CONTROLLERS_CONTAINER_BYTE "\xa3\x61\xb2\xff\xff\xd2\x11\xd1\xaa\x4b\x00\xc0\x4f\xd7\xd8\x3a"
#define GUID_INFRASTRUCTURE_CONTAINER_BYTE     "\x2f\xba\xc1\x87\x0a\xde\x11\xd2\x97\xc4\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_DELETED_OBJECTS_CONTAINER_BYTE    "\x18\xe2\xea\x80\x68\x4f\x11\xd2\xb9\xaa\x00\xc0\x4f\x79\xf8\x05"
#define GUID_LOSTANDFOUND_CONTAINER_BYTE       "\xab\x81\x53\xb7\x76\x88\x11\xd1\xad\xed\x00\xc0\x4f\xd8\xd5\xcd"
#define GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_BYTE "\x22\xb7\x0c\x67\xd5\x6e\x4e\xfb\x91\xe9\x30\x0f\xca\x3d\xc1\xaa"
#define GUID_PROGRAM_DATA_CONTAINER_BYTE       "\x09\x46\x0c\x08\xae\x1e\x4a\x4e\xa0\xf6\x4a\xee\x7d\xaa\x1e\x5a"
#define GUID_MICROSOFT_PROGRAM_DATA_CONTAINER_BYTE "\xf4\xbe\x92\xa4\xc7\x77\x48\x5e\x87\x8e\x94\x21\xd5\x30\x87\xdb"
#define GUID_NTDS_QUOTAS_CONTAINER_BYTE        "\x62\x27\xf0\xaf\x1f\xc2\x41\x0d\x8e\x3b\xb1\x06\x15\xbb\x5b\x0f"


typedef enum _DS_MANGLE_FOR {
        DS_MANGLE_UNKNOWN = 0,
        DS_MANGLE_OBJECT_RDN_FOR_DELETION,
        DS_MANGLE_OBJECT_RDN_FOR_NAME_CONFLICT,
        } DS_MANGLE_FOR;

//////////////////////////////////////////////////////////////////////////
//                                                                      //
// Prototypes                                                           //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// DSBind takes two optional input parameters which identify whether the
// caller found a domain controller themselves via DsGetDcName or whether
// a domain controller should be found using default parameters.
// Behavior of the possible combinations are outlined below.
//
// DomainControllerName(value), DnsDomainName(NULL)
//
//      The value for DomainControllerName is assumed to have been
//      obtained via DsGetDcName (i.e. Field with the same name in a
//      DOMAIN_CONTROLLER_INFO struct on return from DsGetDcName call.)
//      The client is bound to the domain controller at this name.
//
//      Mutual authentication will be performed using an SPN of
//      LDAP/DomainControllerName provided DomainControllerName
//      is not a NETBIOS name or IP address - i.e. it must be a
//      DNS host name.
//
//      For AD/AM, the DomainControllerName is treated as a Binding String,
//      where the first part is the ServerName (some sort of Network
//      identifier - such as DNS, IP address, NetBios Name, etc), and the
//      2nd part is the public LDAP port.  The AD/AM RPC interface uses
//      the LDAP port as our public annotation for RPC.  Ex:
//
//          MyNetBiosName:3030
//          192.0.0.1:2020
//          server1.microsoft.com:389
//
//      Alternatively, clients can use DsBindByInstance() to specify a
//      a specific RPC Annotation, and an even more specific InstanceGuid,
//      (or "objectGuid" in RPC) which is the "objectGuid" off the servers'
//      DSA (aka "NTDS Settings") object.
//
// DomainControllerName(value), DnsDomainName(value)
//
//      DsBind will connect to the server identified by DomainControllerName.
//
//      Mutual authentication will be performed using an SPN of
//      LDAP/DomainControllerName/DnsDomainName provided neither value
//      is a NETBIOS names or IP address - i.e. they must be
//      valid DNS names.
//
// DomainControllerName(NULL), DnsDomainName(NULL)
//
//      DsBind will attempt to find to a global catalog and fail if one
//      can not be found.
//
//      Mutual authentication will be performed using an SPN of
//      GC/DnsHostName/ForestName where DnsHostName and ForestName
//      represent the DomainControllerName and DnsForestName fields
//      respectively of the DOMAIN_CONTROLLER_INFO returned by the
//      DsGetDcName call used to find a global catalog.
//
// DomainControllerName(NULL), DnsDomainName(value)
//
//      DsBind will attempt to find a domain controller for the domain
//      identified by DnsDomainName and fail if one can not be found.
//
//      Mutual authentication will be performed using an SPN of
//      LDAP/DnsHostName/DnsDomainName where DnsDomainName is that
//      provided by the caller and DnsHostName is that returned by
//      DsGetDcName for the domain specified - provided DnsDomainName
//      is a valid DNS domain name - i.e. not a NETBIOS domain name.

NTDSAPI
DWORD
WINAPI
DsBindW(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    HANDLE          *phDS);

NTDSAPI
DWORD
WINAPI
DsBindA(
    LPCSTR          DomainControllerName,      // in, optional
    LPCSTR          DnsDomainName,             // in, optional
    HANDLE          *phDS);

#ifdef UNICODE
#define DsBind DsBindW
#else
#define DsBind DsBindA
#endif

NTDSAPI
DWORD
WINAPI
DsBindWithCredW(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    HANDLE          *phDS);

NTDSAPI
DWORD
WINAPI
DsBindWithCredA(
    LPCSTR          DomainControllerName,      // in, optional
    LPCSTR          DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    HANDLE          *phDS);

#ifdef UNICODE
#define DsBindWithCred DsBindWithCredW
#else
#define DsBindWithCred DsBindWithCredA
#endif

//
// DsBindWithSpn{A|W} allows the caller to specify the service principal
// name (SPN) which will be used for mutual authentication against
// the destination server.  Do not provide an SPN if you are expecting
// DsBind to find a server for you as SPNs are machine specific and its
// unlikely the SPN you provide matches the server DsBind finds for you.
// Providing a NULL ServicePrincipalName argument results in behavior
// identical to DsBindWithCred{A|W}.
//

NTDSAPI
DWORD
WINAPI
DsBindWithSpnW(
    LPCWSTR         DomainControllerName,      // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    LPCWSTR         ServicePrincipalName,      // in, optional
    HANDLE          *phDS);

NTDSAPI
DWORD
WINAPI
DsBindWithSpnA(
    LPCSTR          DomainControllerName,      // in, optional
    LPCSTR          DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    LPCSTR          ServicePrincipalName,      // in, optional
    HANDLE          *phDS);

#ifdef UNICODE
#define DsBindWithSpn DsBindWithSpnW
#else
#define DsBindWithSpn DsBindWithSpnA
#endif

//
// DsBindWithSpnEx{A|W} allows you all the options of the previous
// DsBindWithSpn(), plus the added benefit of specifying some optional
// Binding flags.  Currently if you pass NTDSAPI_BIND_ALLOW_DELEGATION,
// you will get the exact old behaviour.  If you can avoid it, you
// should not specify this flag, see flag above for details.
//

NTDSAPI_POSTXP
DWORD
WINAPI
DsBindWithSpnExW(
    __in LPCWSTR         DomainControllerName,      // in, optional
    __in LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    __in LPCWSTR         ServicePrincipalName,      // in, optional
    DWORD           BindFlags,                 // in, optional
    HANDLE          *phDS);

NTDSAPI_POSTXP
DWORD
WINAPI
DsBindWithSpnExA(
    __in LPCSTR          DomainControllerName,      // in, optional
    __in LPCSTR          DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    __in LPCSTR          ServicePrincipalName,      // in, optional
    DWORD           BindFlags,                 // in, optional
    HANDLE          *phDS);

#ifdef UNICODE
#define DsBindWithSpnEx DsBindWithSpnExW
#else
#define DsBindWithSpnEx DsBindWithSpnExA
#endif

//
// DsBindByInstance{A|W} Allows the explicit binding to any AD/AM
// or AD instance by Annotation or InstanceGuid.  For binding to
// an AD instance the Annotation and InstanceGuid can be left NULL.
// To Bind to an AD/AM instance one or the other must be specified
// to specify the AD/AM instance desired.
//

NTDSAPI_POSTXP
DWORD
WINAPI
DsBindByInstanceW(
    LPCWSTR         ServerName,                // in, optional
    LPCWSTR         Annotation,                // in, optional
    GUID *          InstanceGuid,              // in, optional
    LPCWSTR         DnsDomainName,             // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    LPCWSTR         ServicePrincipalName,      // in, optional
    DWORD           BindFlags,                 // in, optional
    HANDLE          *phDS);

NTDSAPI_POSTXP
DWORD
WINAPI
DsBindByInstanceA(
    LPCSTR         ServerName,                 // in, optional
    LPCSTR         Annotation,                 // in, optional
    GUID *         InstanceGuid,               // in, optional
    LPCSTR         DnsDomainName,              // in, optional
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,     // in, optional
    LPCSTR         ServicePrincipalName,       // in, optional
    DWORD          BindFlags,                  // in, optional
    HANDLE         *phDS);

#ifdef UNICODE
#define DsBindByInstance DsBindByInstanceW
#else
#define DsBindByInstance DsBindByInstanceA
#endif

//
// DsBindToISTG{A|W} allows the caller to bind to the server which
// holds the Inter-Site Topology Generator role in the specified site.
// The site name should be the RDN of a site.  If no site is specified,
// the function will try to bind to the ISTG in a nearby site.
//

NTDSAPI_POSTXP
DWORD
WINAPI
DsBindToISTGW(
    LPCWSTR         SiteName,                  // in, optional
    HANDLE          *phDS);

NTDSAPI_POSTXP
DWORD
WINAPI
DsBindToISTGA(
    LPCSTR          SiteName,                  // in, optional
    HANDLE          *phDS);

#ifdef UNICODE
#define DsBindToISTG DsBindToISTGW
#else
#define DsBindToISTG DsBindToISTGA
#endif

//
// DsBindingSetTimeout allows the caller to specify a timeout value
// which will be honored by all RPC calls using the specified binding
// handle. RPC calls which take longer the timeout value are canceled.
//

NTDSAPI_POSTXP
DWORD
WINAPI
DsBindingSetTimeout(
    HANDLE          hDS,                        // in
    ULONG           cTimeoutSecs                // in
    );

//
// DsUnBind
//

NTDSAPI
DWORD
WINAPI
DsUnBindW(
    HANDLE          *phDS);             // in

NTDSAPI
DWORD
WINAPI
DsUnBindA(
    HANDLE          *phDS);             // in

#ifdef UNICODE
#define DsUnBind DsUnBindW
#else
#define DsUnBind DsUnBindA
#endif

//
// DsMakePasswordCredentials
//
// This function constructs a credential structure which is suitable for input
// to the DsBindWithCredentials function, or the ldap_open function (winldap.h)
// The credential must be freed using DsFreeCredential.
//
// None of the input parameters may be present indicating a null, default
// credential.  Otherwise the username must be present.  If the domain or
// password are null, they default to empty strings.  The domain name may be
// null when the username is fully qualified, for example UPN format.
//

NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsW(
    LPCWSTR User,
    LPCWSTR Domain,
    LPCWSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    );

NTDSAPI
DWORD
WINAPI
DsMakePasswordCredentialsA(
    LPCSTR User,
    LPCSTR Domain,
    LPCSTR Password,
    RPC_AUTH_IDENTITY_HANDLE *pAuthIdentity
    );

#ifdef UNICODE
#define DsMakePasswordCredentials DsMakePasswordCredentialsW
#else
#define DsMakePasswordCredentials DsMakePasswordCredentialsA
#endif

NTDSAPI
VOID
WINAPI
DsFreePasswordCredentials(
    RPC_AUTH_IDENTITY_HANDLE AuthIdentity
    );

#define DsFreePasswordCredentialsW DsFreePasswordCredentials
#define DsFreePasswordCredentialsA DsFreePasswordCredentials

//
// DsCrackNames
//

NTDSAPI
DWORD
WINAPI
DsCrackNamesW(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCWSTR       *rpNames,           // in
    PDS_NAME_RESULTW    *ppResult);         // out

NTDSAPI
DWORD
WINAPI
DsCrackNamesA(
    HANDLE              hDS,                // in
    DS_NAME_FLAGS       flags,              // in
    DS_NAME_FORMAT      formatOffered,      // in
    DS_NAME_FORMAT      formatDesired,      // in
    DWORD               cNames,             // in
    const LPCSTR        *rpNames,           // in
    PDS_NAME_RESULTA    *ppResult);         // out

#ifdef UNICODE
#define DsCrackNames DsCrackNamesW
#else
#define DsCrackNames DsCrackNamesA
#endif

//
// DsFreeNameResult
//

NTDSAPI
void
WINAPI
DsFreeNameResultW(
    DS_NAME_RESULTW *pResult);          // in

NTDSAPI
void
WINAPI
DsFreeNameResultA(
    DS_NAME_RESULTA *pResult);          // in

#ifdef UNICODE
#define DsFreeNameResult DsFreeNameResultW
#else
#define DsFreeNameResult DsFreeNameResultA
#endif

// ==========================================================
// DSMakeSpn -- client call to create SPN for a service to which it wants to
// authenticate.
// This name is then passed to "pszTargetName" of InitializeSecurityContext().
//
// Notes:
// If the service name is a DNS host name, or canonical DNS service name
// e.g. "www.ms.com", i.e., caller resolved with gethostbyname, then instance
// name should be NULL.
// Realm is host name minus first component, unless it is in the exception list
//
// If the service name is NetBIOS machine name, then instance name should be
// NULL
// Form must be <domain>\<machine>
// Realm will be <domain>
//
// If the service name is that of a replicated service, where each replica has
// its own account (e.g., with SRV records) then the caller must supply the
// instance name then realm name is same as ServiceName
//
// If the service name is a DN, then must also supply instance name
// (DN could be name of service object (incl RPC or Winsock), name of machine
// account, name of domain object)
// then realm name is domain part of the DN
//
// If the service name is NetBIOS domain name, then must also supply instance
// name; realm name is domain name
//
// If the service is named by an IP address -- then use referring service name
// as service name
//
//  ServiceClass - e.g. "http", "ftp", "ldap", GUID
//  ServiceName - DNS or DN; assumes we can compute domain from service name
//  InstanceName OPTIONAL- DNS name of host for instance of service
//  InstancePort - port number for instance (0 if default)
//  Referrer OPTIONAL- DNS name of host that gave this referral
//  pcSpnLength - in -- max length IN CHARACTERS of principal name;
//                out -- actual
//                Length includes terminator
//  pszSPN - server principal name
//
// If buffer is not large enough, ERROR_BUFFER_OVERFLOW is returned and the
// needed length is returned in pcSpnLength.
//
//

NTDSAPI
DWORD
WINAPI
DsMakeSpnW(
    __in IN LPCWSTR ServiceClass,
    __in IN LPCWSTR ServiceName,
    __in_opt IN LPCWSTR InstanceName,
    IN USHORT InstancePort,
    __in_opt IN LPCWSTR Referrer,
    IN OUT DWORD *pcSpnLength,
    __out_ecount_part (*pcSpnLength, *pcSpnLength) OUT LPWSTR pszSpn
);

NTDSAPI
DWORD
WINAPI
DsMakeSpnA(
    __in IN LPCSTR ServiceClass,
    __in IN LPCSTR ServiceName,
    __in_opt IN LPCSTR InstanceName,
    IN USHORT InstancePort,
    __in_opt IN LPCSTR Referrer,
    IN OUT DWORD *pcSpnLength,
    __out_ecount_part (*pcSpnLength, *pcSpnLength) OUT LPSTR pszSpn
);

#ifdef UNICODE
#define DsMakeSpn DsMakeSpnW
#else
#define DsMakeSpn DsMakeSpnA
#endif

// ==========================================================
// DsGetSPN -- server's call to gets SPNs for a service name by which it is
// known to clients. N.B.: there may be more than one name by which clients
// know it the SPNs are then passed to DsAddAccountSpn to register them in
// the DS
//
//      IN SpnNameType eType,
//      IN LPCTSTR ServiceClass,
// kind of service -- "http", "ldap", "ftp", etc.
//      IN LPCTSTR ServiceName OPTIONAL,
// name of service -- DN or DNS; not needed for host-based
//      IN USHORT InstancePort,
// port number (0 => default) for instances
//      IN USHORT cInstanceNames,
// count of extra instance names and ports (0=>use gethostbyname)
//      IN LPCTSTR InstanceNames[] OPTIONAL,
// extra instance names (not used for host names)
//      IN USHORT InstancePorts[] OPTIONAL,
// extra instance ports (0 => default)
//      IN OUT PULONG pcSpn,    // count of SPNs
//      IN OUT LPTSTR * prpszSPN[]
// a bunch of SPNs for this service; free with DsFreeSpnArray

NTDSAPI
DWORD
WINAPI
DsGetSpnA(
    IN DS_SPN_NAME_TYPE ServiceType,
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN USHORT InstancePort,
    IN USHORT cInstanceNames,
    IN LPCSTR *pInstanceNames,
    IN const USHORT *pInstancePorts,
    OUT DWORD *pcSpn,
    __deref_out_ecount (*pcSpn) OUT LPSTR **prpszSpn
    );

NTDSAPI
DWORD
WINAPI
DsGetSpnW(
    IN DS_SPN_NAME_TYPE ServiceType,
    IN LPCWSTR ServiceClass,
    IN LPCWSTR ServiceName,
    IN USHORT InstancePort,
    IN USHORT cInstanceNames,
    IN LPCWSTR *pInstanceNames,
    IN const USHORT *pInstancePorts,
    OUT DWORD *pcSpn,
    __deref_out_ecount(*pcSpn) OUT LPWSTR **prpszSpn
    );

#ifdef UNICODE
#define DsGetSpn DsGetSpnW
#else
#define DsGetSpn DsGetSpnA
#endif

// ==========================================================
// DsFreeSpnArray() -- Free array returned by DsGetSpn{A,W}

NTDSAPI
void
WINAPI
DsFreeSpnArrayA(
    __in IN DWORD cSpn,
    __deref_out_ecount(cSpn) IN OUT LPSTR *rpszSpn
    );

NTDSAPI
void
WINAPI
DsFreeSpnArrayW(
    __in DWORD cSpn,
    __deref_out_ecount_part(cSpn,0) LPWSTR *rpszSpn
    );

#ifdef UNICODE
#define DsFreeSpnArray DsFreeSpnArrayW
#else
#define DsFreeSpnArray DsFreeSpnArrayA
#endif

// ==========================================================
// DsCrackSpn() -- parse an SPN into the ServiceClass,
// ServiceName, and InstanceName (and InstancePort) pieces.
// An SPN is passed in, along with a pointer to the maximum length
// for each piece and a pointer to a buffer where each piece should go.
// On exit, the maximum lengths are updated to the actual length for each piece
// and the buffer contain the appropriate piece. The InstancePort is 0 if not
// present.
//
// DWORD DsCrackSpn(
//      IN LPTSTR pszSPN,               // the SPN to parse
//      IN OUT PUSHORT pcServiceClass,  // input -- max length of ServiceClass;
//                                         output -- actual length
//      OUT LPCTSTR ServiceClass,       // the ServiceClass part of the SPN
//      IN OUT PUSHORT pcServiceName,   // input -- max length of ServiceName;
//                                         output -- actual length
//      OUT LPCTSTR ServiceName,        // the ServiceName part of the SPN
//      IN OUT PUSHORT pcInstance,      // input -- max length of ServiceClass;
//                                         output -- actual length
//      OUT LPCTSTR InstanceName,  // the InstanceName part of the SPN
//      OUT PUSHORT InstancePort          // instance port
//
// Note: lengths are in characters; all string lengths include terminators
// All arguments except pszSpn are optional.
//

NTDSAPI
DWORD
WINAPI
DsCrackSpnA(
    __in IN LPCSTR pszSpn,
    IN OUT LPDWORD pcServiceClass,
    __out_ecount_part (*pcServiceClass, *pcServiceClass) OUT LPSTR ServiceClass,
    IN OUT LPDWORD pcServiceName,
    __out_ecount_part_opt (*pcServiceName, *pcServiceName) OUT LPSTR ServiceName,
    IN OUT LPDWORD pcInstanceName,
    __out_ecount_part_opt (*pcInstanceName, *pcInstanceName) OUT LPSTR InstanceName,
    OUT USHORT *pInstancePort
    );

NTDSAPI
DWORD
WINAPI
DsCrackSpnW(
    __in IN LPCWSTR pszSpn,
    IN OUT DWORD *pcServiceClass,
    __out_ecount_part (*pcServiceClass, *pcServiceClass) OUT LPWSTR ServiceClass,
    IN OUT DWORD *pcServiceName,
    __out_ecount_part_opt (*pcServiceName, *pcServiceName) OUT LPWSTR ServiceName,
    IN OUT DWORD *pcInstanceName,
    __out_ecount_part_opt (*pcInstanceName, *pcInstanceName) OUT LPWSTR InstanceName,
    OUT USHORT *pInstancePort
    );

#ifdef UNICODE
#define DsCrackSpn DsCrackSpnW
#else
#define DsCrackSpn DsCrackSpnA
#endif


// ==========================================================
// DsWriteAccountSpn -- set or add SPNs for an account object
// Usually done by service itself, or perhaps by an admin.
//
// This call is RPC'd to the DC where the account object is stored, so it can
// securely enforce policy on what SPNs are allowed on the account. Direct LDAP
// writes to the SPN property are not allowed -- all writes must come through
// this RPC call. (Reads via // LDAP are OK.)
//
// The account object can be a machine accout, or a service (user) account.
//
// If called by the service to register itself, it can most easily get
// the names by calling DsGetSpn with each of the names that
// clients can use to find the service.
//
// IN SpnWriteOp eOp,                   // set, add
// IN LPCTSTR   pszAccount,             // DN of account to which to add SPN
// IN int       cSPN,                   // count of SPNs to add to account
// IN LPCTSTR   rpszSPN[]               // SPNs to add to altSecID property

NTDSAPI
DWORD
WINAPI
DsWriteAccountSpnA(
    IN HANDLE hDS,
    IN DS_SPN_WRITE_OP Operation,
    IN LPCSTR pszAccount,
    IN DWORD cSpn,
    IN LPCSTR *rpszSpn
    );

NTDSAPI
DWORD
WINAPI
DsWriteAccountSpnW(
    IN HANDLE hDS,
    IN DS_SPN_WRITE_OP Operation,
    IN LPCWSTR pszAccount,
    IN DWORD cSpn,
    IN LPCWSTR *rpszSpn
    );

#ifdef UNICODE
#define DsWriteAccountSpn DsWriteAccountSpnW
#else
#define DsWriteAccountSpn DsWriteAccountSpnA
#endif

/*++

Routine Description:

Constructs a Service Principal Name suitable to identify the desired server.
The service class and part of a dns hostname must be supplied.

This routine is a simplified wrapper to DsMakeSpn.
The ServiceName is made canonical by resolving through DNS.
Guid-based dns names are not supported.

NOTE:
This routine is no longer recommended for use. In order to be secure, an SPN
should be constructed purely on the client without reliance on other services,
such as DNS, which may be spoofed.

The simplified SPN constructed looks like this:

ServiceClass / ServiceName / ServiceName

The instance name portion (2nd position) is always defaulted.  The port and
referrer fields are not used.

Arguments:

    ServiceClass - Class of service, defined by the service, can be any
        string unique to the service

    ServiceName - dns hostname, fully qualified or not
       Stringized IP address is also resolved if necessary

    pcSpnLength - IN, maximum length of buffer, in chars
                  OUT, space utilized, in chars, including terminator

    pszSpn - Buffer, atleast of length *pcSpnLength

Return Value:

    WINAPI - Win32 error code

--*/

NTDSAPI
DWORD
WINAPI
DsClientMakeSpnForTargetServerW(
    __in IN LPCWSTR ServiceClass,
    __in IN LPCWSTR ServiceName,
    IN OUT DWORD *pcSpnLength,
    __out_ecount_part (*pcSpnLength, *pcSpnLength) OUT LPWSTR pszSpn
    );

NTDSAPI
DWORD
WINAPI
DsClientMakeSpnForTargetServerA(
    IN LPCSTR ServiceClass,
    IN LPCSTR ServiceName,
    IN OUT DWORD *pcSpnLength,
    __out_ecount_part(*pcSpnLength, *pcSpnLength) OUT LPSTR pszSpn
    );

#ifdef UNICODE
#define DsClientMakeSpnForTargetServer DsClientMakeSpnForTargetServerW
#else
#define DsClientMakeSpnForTargetServer DsClientMakeSpnForTargetServerA
#endif

/*++

Routine Description:

Register Service Principal Names for a server application.

This routine does the following:
1. Enumerates a list of server SPNs using DsGetSpn and the provided class
2. Determines the domain of the current user context
3. Determines the DN of the current user context if not supplied
4. Locates a domain controller
5. Binds to the domain controller
6. Uses DsWriteAccountSpn to write the SPNs on the named object DN
7. Unbinds

Construct server SPNs for this service, and write them to the right object.

If the userObjectDn is specified, the SPN is written to that object.

Otherwise the Dn is defaulted, to the user object, then computer.

Now, bind to the DS, and register the name on the object for the
user this service is running as.  So, if we're running as local
system, we'll register it on the computer object itself.  If we're
running as a domain user, we'll add the SPN to the user's object.

Arguments:

    Operation - What should be done with the values: add, replace or delete
    ServiceClass - Unique string identifying service
    UserObjectDN - Optional, dn of object to write SPN to

Return Value:

    WINAPI - Win32 error code

--*/

NTDSAPI
DWORD
WINAPI
DsServerRegisterSpnA(
    IN DS_SPN_WRITE_OP Operation,
    IN LPCSTR ServiceClass,
    IN LPCSTR UserObjectDN
    );

NTDSAPI
DWORD
WINAPI
DsServerRegisterSpnW(
    IN DS_SPN_WRITE_OP Operation,
    IN LPCWSTR ServiceClass,
    IN LPCWSTR UserObjectDN
    );

#ifdef UNICODE
#define DsServerRegisterSpn DsServerRegisterSpnW
#else
#define DsServerRegisterSpn DsServerRegisterSpnA
#endif

// DsReplicaSync.  The server that this call is executing on is called the
// destination.  The destination's naming context will be brought up to date
// with respect to a source system.  The source system is identified by the
// uuid.  The uuid is that of the source system's "NTDS Settings" object.
// The destination system must already be configured such that the source
// system is one of the systems from which it recieves replication data
// ("replication from"). This is usually done automatically by the KCC.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC to synchronize.
//      puuidSourceDRA (SZ)
//          objectGuid of DSA with which to synchronize the replica.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more flags
//   RETURNS: WIN32 STATUS

NTDSAPI
DWORD
WINAPI
DsReplicaSyncA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG Options
    );

NTDSAPI
DWORD
WINAPI
DsReplicaSyncW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN const UUID *pUuidDsaSrc,
    IN ULONG Options
    );

#ifdef UNICODE
#define DsReplicaSync DsReplicaSyncW
#else
#define DsReplicaSync DsReplicaSyncA
#endif

// DsReplicaAdd
//
/*
Description:
   This call is executed on the destination.  It causes the destination to
   add a "replication from" reference to the indicated source system.

The source server is identified by string name, not uuid as with Sync.
The DsaSrcAddress parameter is the transport specific address of the source
DSA, usually its guid-based dns name.  The guid in the guid-based dns name is
the object-guid of that server's ntds-dsa (settings) object.

Arguments:

    pNC (IN) - NC for which to add the replica.
    pSourceDsaDN (IN) - DN of the source DSA's ntdsDsa object.  Required if
        ulOptions includes DS_REPADD_ASYNCHRONOUS_REPLICA; ignored otherwise.

    pTransportDN (IN) - DN of the interSiteTransport object representing the
        transport by which to communicate with the source server.  Required if
        ulOptions includes INTERSITE_MESSAGING; ignored otherwise.

    pszSourceDsaAddress (IN) - Transport-specific address of the source DSA.

    pSchedule (IN) - Schedule by which to replicate the NC from this
        source in the future.

    ulOptions (IN) - flags
    RETURNS: WIN32 STATUS
*/

NTDSAPI
DWORD
WINAPI
DsReplicaAddA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR SourceDsaDn,
    IN LPCSTR TransportDn,
    IN LPCSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD Options
    );

NTDSAPI
DWORD
WINAPI
DsReplicaAddW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR SourceDsaDn,
    IN LPCWSTR TransportDn,
    IN LPCWSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD Options
    );

#ifdef UNICODE
#define DsReplicaAdd DsReplicaAddW
#else
#define DsReplicaAdd DsReplicaAddA
#endif

// DsReplicaDel
//
// The server that this call is executing on is the destination.  The call
// causes the destination to remove a "replication from" reference to the
// indicated source server.
// The source server is identified by string name, not uuid as with Sync.
// The DsaSrc parameter is the transport specific address of the source DSA,
// usually its guid-based dns name.  The guid in the guid-based dns name is
// the object-guid of that server's ntds-dsa (settings) object.
// If you remove an NC from a given destination and specify the "no source"
// flag, then the entire replica will be removed from the DC.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC for which to delete a source.
//      pszSourceDRA (SZ)
//          DSA for which to delete the source.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more flags
//
//
//   RETURNS: WIN32 STATUS

NTDSAPI
DWORD
WINAPI
DsReplicaDelA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR DsaSrc,
    IN ULONG Options
    );

NTDSAPI
DWORD
WINAPI
DsReplicaDelW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR DsaSrc,
    IN ULONG Options
    );

#ifdef UNICODE
#define DsReplicaDel DsReplicaDelW
#else
#define DsReplicaDel DsReplicaDelA
#endif

// DsReplicaModify
//
//
//  Modify a source for a given naming context
//
//  The value must already exist.
//
//  Either the UUID or the address may be used to identify the current value.
//  If a UUID is specified, the UUID will be used for comparison.  Otherwise,
//  the address will be used for comparison.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC for which the Reps-From should be modified.
//      puuidSourceDRA (UUID *)
//          Guid of the DSA object for the source server. May be NULL if:
//            . ulModifyFields does not include DS_REPMOD_UPDATE_INSTANCE and
//            . pmtxSourceDRA is non-NULL.
//      puuidTransportObj (UUID *)
//          objectGuid of the transport by which replication is to be performed
//          Ignored if ulModifyFields does not include
//          DS_REPMOD_UPDATE_TRANSPORT.
//      pszSourceDRA (SZ)
//          DSA for which the reference should be added or deleted.  Ignored if
//          puuidSourceDRA is non-NULL and ulModifyFields does not include
//          DS_REPMOD_UPDATE_INSTANCE.
//      prtSchedule (REPLTIMES *)
//          Periodic replication schedule for this replica.  Ignored if
//          ulModifyFields does not include DS_REPMOD_UPDATE_SCHEDULE.
//      ulReplicaFlags (ULONG)
//          Flags to set for this replica.  Ignored if ulModifyFields does not
//          include DS_REPMOD_UPDATE_FLAGS.
//      ulModifyFields (ULONG)
//          Fields to update.  One or more of the following bit flags:
//              UPDATE_ADDRESS
//                  Update the MTX_ADDR associated with the referenced server.
//              UPDATE_SCHEDULE
//                  Update the periodic replication schedule associated with
//                  the replica.
//              UPDATE_FLAGS
//                  Update the flags associated with the replica.
//              UPDATE_TRANSPORT
//                  Update the transport associated with the replica.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more of the following:
//              DS_REPMOD_ASYNCHRONOUS_OPERATION
//                  Perform this operation asynchronously.
//   RETURNS: WIN32 STATUS

NTDSAPI
DWORD
WINAPI
DsReplicaModifyA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN const UUID *pUuidSourceDsa,
    IN LPCSTR TransportDn,
    IN LPCSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD ReplicaFlags,
    IN DWORD ModifyFields,
    IN DWORD Options
    );

NTDSAPI
DWORD
WINAPI
DsReplicaModifyW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN const UUID *pUuidSourceDsa,
    IN LPCWSTR TransportDn,
    IN LPCWSTR SourceDsaAddress,
    IN const PSCHEDULE pSchedule,
    IN DWORD ReplicaFlags,
    IN DWORD ModifyFields,
    IN DWORD Options
    );

#ifdef UNICODE
#define DsReplicaModify DsReplicaModifyW
#else
#define DsReplicaModify DsReplicaModifyA
#endif

// DsReplicaUpdateRefs
//
// In this case, the RPC is being executed on the "source" of destination-sourc
// replication relationship.  This function tells the source that it no longer
// supplies replication information to the indicated destination system.
// Add or remove a target server from the Reps-To property on the given NC.
// Add/remove a reference given the DSNAME of the corresponding NTDS-DSA
// object.
//
//  PARAMETERS:
//      pNC (DSNAME *)
//          Name of the NC for which the Reps-To should be modified.
//      DsaDest (SZ)
//          Network address of DSA for which the reference should be added
//          or deleted.
//      pUuidDsaDest (UUID *)
//          objectGuid of the DSA object for which the reference should be
//          added or deleted.
//      ulOptions (ULONG)
//          Bitwise OR of zero or more of the following:
//              DS_REPUPD_ASYNC_OP
//                  Perform this operation asynchronously.
//              DS_REPUPD_ADD_REFERENCE
//                  Add the given server to the Reps-To property.
//              DS_REPUPD_DEL_REFERENCE
//                  Remove the given server from the Reps-To property.
//          Note that ADD_REF and DEL_REF may be paired to perform
//          "add or update".
//
//   RETURNS: WIN32 STATUS

NTDSAPI
DWORD
WINAPI
DsReplicaUpdateRefsA(
    IN HANDLE hDS,
    IN LPCSTR NameContext,
    IN LPCSTR DsaDest,
    IN const UUID *pUuidDsaDest,
    IN ULONG Options
    );

NTDSAPI
DWORD
WINAPI
DsReplicaUpdateRefsW(
    IN HANDLE hDS,
    IN LPCWSTR NameContext,
    IN LPCWSTR DsaDest,
    IN const UUID *pUuidDsaDest,
    IN ULONG Options
    );

#ifdef UNICODE
#define DsReplicaUpdateRefs DsReplicaUpdateRefsW
#else
#define DsReplicaUpdateRefs DsReplicaUpdateRefsA
#endif

// Friends of DsReplicaSyncAll

typedef enum {

	DS_REPSYNCALL_WIN32_ERROR_CONTACTING_SERVER	= 0,
	DS_REPSYNCALL_WIN32_ERROR_REPLICATING		= 1,
	DS_REPSYNCALL_SERVER_UNREACHABLE		= 2

} DS_REPSYNCALL_ERROR;

typedef enum {

	DS_REPSYNCALL_EVENT_ERROR			= 0,
	DS_REPSYNCALL_EVENT_SYNC_STARTED		= 1,
	DS_REPSYNCALL_EVENT_SYNC_COMPLETED		= 2,
	DS_REPSYNCALL_EVENT_FINISHED			= 3

} DS_REPSYNCALL_EVENT;

// Friends of DsReplicaSyncAll

typedef struct {
    LPSTR			pszSrcId;
    LPSTR			pszDstId;
    LPSTR                       pszNC;
    GUID *                      pguidSrc;
    GUID *                      pguidDst;
} DS_REPSYNCALL_SYNCA, * PDS_REPSYNCALL_SYNCA;

typedef struct {
    LPWSTR			pszSrcId;
    LPWSTR			pszDstId;
    LPWSTR                      pszNC;
    GUID *                      pguidSrc;
    GUID *                      pguidDst;
} DS_REPSYNCALL_SYNCW, * PDS_REPSYNCALL_SYNCW;

typedef struct {
    LPSTR			pszSvrId;
    DS_REPSYNCALL_ERROR		error;
    DWORD			dwWin32Err;
    LPSTR			pszSrcId;
} DS_REPSYNCALL_ERRINFOA, * PDS_REPSYNCALL_ERRINFOA;

typedef struct {
    LPWSTR			pszSvrId;
    DS_REPSYNCALL_ERROR		error;
    DWORD			dwWin32Err;
    LPWSTR			pszSrcId;
} DS_REPSYNCALL_ERRINFOW, * PDS_REPSYNCALL_ERRINFOW;

typedef struct {
    DS_REPSYNCALL_EVENT		event;
    DS_REPSYNCALL_ERRINFOA *	pErrInfo;
    DS_REPSYNCALL_SYNCA *	pSync;
} DS_REPSYNCALL_UPDATEA, * PDS_REPSYNCALL_UPDATEA;

typedef struct {
    DS_REPSYNCALL_EVENT		event;
    DS_REPSYNCALL_ERRINFOW *	pErrInfo;
    DS_REPSYNCALL_SYNCW *	pSync;
} DS_REPSYNCALL_UPDATEW, * PDS_REPSYNCALL_UPDATEW;

#ifdef UNICODE
#define DS_REPSYNCALL_SYNC DS_REPSYNCALL_SYNCW
#define DS_REPSYNCALL_ERRINFO DS_REPSYNCALL_ERRINFOW
#define DS_REPSYNCALL_UPDATE DS_REPSYNCALL_UPDATEW
#define PDS_REPSYNCALL_SYNC PDS_REPSYNCALL_SYNCW
#define PDS_REPSYNCALL_ERRINFO PDS_REPSYNCALL_ERRINFOW
#define PDS_REPSYNCALL_UPDATE PDS_REPSYNCALL_UPDATEW
#else
#define DS_REPSYNCALL_SYNC DS_REPSYNCALL_SYNCA
#define DS_REPSYNCALL_ERRINFO DS_REPSYNCALL_ERRINFOA
#define DS_REPSYNCALL_UPDATE DS_REPSYNCALL_UPDATEA
#define PDS_REPSYNCALL_SYNC PDS_REPSYNCALL_SYNCA
#define PDS_REPSYNCALL_ERRINFO PDS_REPSYNCALL_ERRINFOA
#define PDS_REPSYNCALL_UPDATE PDS_REPSYNCALL_UPDATEA
#endif

// **********************
// Replica SyncAll flags
// **********************

// This option has no effect.
#define DS_REPSYNCALL_NO_OPTIONS			0x00000000

// Ordinarily, if a server cannot be contacted, DsReplicaSyncAll tries to
// route around it and replicate from as many servers as possible.  Enabling
// this option will cause DsReplicaSyncAll to generate a fatal error if any
// server cannot be contacted, or if any server is unreachable (due to a
// disconnected or broken topology.)
#define	DS_REPSYNCALL_ABORT_IF_SERVER_UNAVAILABLE	0x00000001

// This option disables transitive replication; syncs will only be performed
// with adjacent servers and no DsBind calls will be made.
#define DS_REPSYNCALL_SYNC_ADJACENT_SERVERS_ONLY	0x00000002

// Ordinarily, when DsReplicaSyncAll encounters a non-fatal error, it returns
// the GUID DNS of the relevant server(s).  Enabling this option causes
// DsReplicaSyncAll to return the servers' DNs instead.
#define DS_REPSYNCALL_ID_SERVERS_BY_DN			0x00000004

// This option disables all syncing.  The topology will still be analyzed and
// unavailable / unreachable servers will still be identified.
#define DS_REPSYNCALL_DO_NOT_SYNC			0x00000008

// Ordinarily, DsReplicaSyncAll attempts to bind to all servers before
// generating the topology.  If a server cannot be contacted, DsReplicaSyncAll
// excludes that server from the topology and tries to route around it.  If
// this option is enabled, checking will be bypassed and DsReplicaSyncAll will
// assume all servers are responding.  This will speed operation of
// DsReplicaSyncAll, but if some servers are not responding, some transitive
// replications may be blocked.
#define DS_REPSYNCALL_SKIP_INITIAL_CHECK		0x00000010

// Push mode. Push changes from the home server out to all partners using
// transitive replication.  This reverses the direction of replication, and
// the order of execution of the replication sets from the usual "pulling"
// mode of execution.
#define DS_REPSYNCALL_PUSH_CHANGES_OUTWARD              0x00000020

// Cross site boundaries.  By default, the only servers that are considered are
// those in the same site as the home system.  With this option, all servers in
// the enterprise, across all sites, are eligible.  They must be connected by
// a synchronous (RPC) transport, however.
#define DS_REPSYNCALL_CROSS_SITE_BOUNDARIES             0x00000040

// DsReplicaSyncAll.  Syncs the destination server with all other servers
// in the site.
//
//  PARAMETERS:
//	hDS		(IN) - A DS connection bound to the destination server.
//	pszNameContext	(IN) - The naming context to synchronize
//	ulFlags		(IN) - Bitwise OR of zero or more flags
//	pFnCallBack	(IN, OPTIONAL) - Callback function for message-passing.
//	pCallbackData	(IN, OPTIONAL) - A pointer that will be passed to the
//				first argument of the callback function.
//	pErrors		(OUT, OPTIONAL) - Pointer to a (PDS_REPSYNCALL_ERRINFO *)
//				object that will hold an array of error structures.

NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllA (
    HANDLE				hDS,
    __in LPCSTR				pszNameContext,
    ULONG				ulFlags,
    BOOL (__stdcall *			pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEA),
    LPVOID				pCallbackData,
    PDS_REPSYNCALL_ERRINFOA **		pErrors
    );

NTDSAPI
DWORD
WINAPI
DsReplicaSyncAllW (
    HANDLE				hDS,
    __in LPCWSTR				pszNameContext,
    ULONG				ulFlags,
    BOOL (__stdcall *			pFnCallBack) (LPVOID, PDS_REPSYNCALL_UPDATEW),
    LPVOID				pCallbackData,
    PDS_REPSYNCALL_ERRINFOW **		pErrors
    );

#ifdef UNICODE
#define DsReplicaSyncAll DsReplicaSyncAllW
#else
#define DsReplicaSyncAll DsReplicaSyncAllA
#endif

NTDSAPI
DWORD
WINAPI
DsRemoveDsServerW(
    HANDLE  hDs,             // in
    __in LPWSTR  ServerDN,        // in
    __in_opt LPWSTR  DomainDN,        // in,  optional
    BOOL   *fLastDcInDomain, // out, optional
    BOOL    fCommit          // in
    );

NTDSAPI
DWORD
WINAPI
DsRemoveDsServerA(
    HANDLE  hDs,              // in
    __in LPSTR   ServerDN,         // in
    __in_opt LPSTR   DomainDN,         // in,  optional
    BOOL   *fLastDcInDomain,  // out, optional
    BOOL    fCommit           // in
    );

#ifdef UNICODE
#define DsRemoveDsServer DsRemoveDsServerW
#else
#define DsRemoveDsServer DsRemoveDsServerA
#endif

NTDSAPI
DWORD
WINAPI
DsRemoveDsDomainW(
    HANDLE  hDs,               // in
    __in LPWSTR  DomainDN           // in
    );

NTDSAPI
DWORD
WINAPI
DsRemoveDsDomainA(
    HANDLE  hDs,               // in
    __in LPSTR   DomainDN           // in
    );

#ifdef UNICODE
#define DsRemoveDsDomain DsRemoveDsDomainW
#else
#define DsRemoveDsDomain DsRemoveDsDomainA
#endif

NTDSAPI
DWORD
WINAPI
DsListSitesA(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTA    *ppSites);      // out

NTDSAPI
DWORD
WINAPI
DsListSitesW(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTW    *ppSites);      // out

#ifdef UNICODE
#define DsListSites DsListSitesW
#else
#define DsListSites DsListSitesA
#endif

NTDSAPI
DWORD
WINAPI
DsListServersInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppServers);    // out

NTDSAPI
DWORD
WINAPI
DsListServersInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppServers);    // out

#ifdef UNICODE
#define DsListServersInSite DsListServersInSiteW
#else
#define DsListServersInSite DsListServersInSiteA
#endif

NTDSAPI
DWORD
WINAPI
DsListDomainsInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppDomains);    // out

NTDSAPI
DWORD
WINAPI
DsListDomainsInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppDomains);    // out

#ifdef UNICODE
#define DsListDomainsInSite DsListDomainsInSiteW
#else
#define DsListDomainsInSite DsListDomainsInSiteA
#endif

NTDSAPI
DWORD
WINAPI
DsListServersForDomainInSiteA(
    HANDLE              hDs,            // in
    LPCSTR              domain,         // in
    LPCSTR              site,           // in
    PDS_NAME_RESULTA    *ppServers);    // out

NTDSAPI
DWORD
WINAPI
DsListServersForDomainInSiteW(
    HANDLE              hDs,            // in
    LPCWSTR             domain,         // in
    LPCWSTR             site,           // in
    PDS_NAME_RESULTW    *ppServers);    // out

#ifdef UNICODE
#define DsListServersForDomainInSite DsListServersForDomainInSiteW
#else
#define DsListServersForDomainInSite DsListServersForDomainInSiteA
#endif

// Define indices for DsListInfoForServer return data.  Check status
// for each field as a given value may not be present.

#define DS_LIST_DSA_OBJECT_FOR_SERVER       0
#define DS_LIST_DNS_HOST_NAME_FOR_SERVER    1
#define DS_LIST_ACCOUNT_OBJECT_FOR_SERVER   2

NTDSAPI
DWORD
WINAPI
DsListInfoForServerA(
    HANDLE              hDs,            // in
    LPCSTR              server,         // in
    PDS_NAME_RESULTA    *ppInfo);       // out

NTDSAPI
DWORD
WINAPI
DsListInfoForServerW(
    HANDLE              hDs,            // in
    LPCWSTR             server,         // in
    PDS_NAME_RESULTW    *ppInfo);       // out

#ifdef UNICODE
#define DsListInfoForServer DsListInfoForServerW
#else
#define DsListInfoForServer DsListInfoForServerA
#endif

// Define indices for DsListRoles return data.  Check status for
// each field as a given value may not be present.

#define DS_ROLE_SCHEMA_OWNER                0
#define DS_ROLE_DOMAIN_OWNER                1
#define DS_ROLE_PDC_OWNER                   2
#define DS_ROLE_RID_OWNER                   3
#define DS_ROLE_INFRASTRUCTURE_OWNER        4

NTDSAPI
DWORD
WINAPI
DsListRolesA(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTA    *ppRoles);      // out

NTDSAPI
DWORD
WINAPI
DsListRolesW(
    HANDLE              hDs,            // in
    PDS_NAME_RESULTW    *ppRoles);      // out

#ifdef UNICODE
#define DsListRoles DsListRolesW
#else
#define DsListRoles DsListRolesA
#endif

//
// DsQuerySitesByCost{A|W} allows the caller to determine the
// communication cost between the From Site and each of the sites
// in the list of To Sites. The costs are returned in the rgSiteInfo
// structure which must be freed with DsQuerySitesFree.
//
// The Site Names should all be passed as RDNs. For example, if the
// site's DN is "CN=Foo,CN=Sites,CN=Configuration,...", the RDN is
// simply "Foo".
//

typedef struct {
    DWORD               errorCode;
    DWORD               cost;
} DS_SITE_COST_INFO, *PDS_SITE_COST_INFO;

NTDSAPI_POSTXP
DWORD
WINAPI
DsQuerySitesByCostW(
    HANDLE              hDS,            // in
    __in LPWSTR          pwszFromSite,   // in
    __deref_in_ecount (cToSites) LPWSTR          *rgwszToSites,   // in
    DWORD               cToSites,       // in
    DWORD               dwFlags,        // in
    PDS_SITE_COST_INFO *prgSiteInfo     // out
    );

NTDSAPI_POSTXP
DWORD
WINAPI
DsQuerySitesByCostA(
    HANDLE              hDS,            // in
    __in LPSTR           pszFromSite,    // in
    __deref_in_ecount (cToSites) LPSTR   *rgszToSites,    // in
    DWORD               cToSites,       // in
    DWORD               dwFlags,        // in
    PDS_SITE_COST_INFO *prgSiteInfo     // out
    );

#ifdef UNICODE
#define DsQuerySitesByCost DsQuerySitesByCostW
#else
#define DsQuerySitesByCost DsQuerySitesByCostA
#endif

//
// DsQuerySitesByCost will free the site info array returned
// from DsQuerySitesByCost{A|W}.
//
VOID
WINAPI
DsQuerySitesFree(
    PDS_SITE_COST_INFO  rgSiteInfo
    );

// Definitions required for DsMapSchemaGuid routines.

#define DS_SCHEMA_GUID_NOT_FOUND            0
#define DS_SCHEMA_GUID_ATTR                 1
#define DS_SCHEMA_GUID_ATTR_SET             2
#define DS_SCHEMA_GUID_CLASS                3
#define DS_SCHEMA_GUID_CONTROL_RIGHT        4

typedef struct
{
    GUID                    guid;       // mapped GUID
    DWORD                   guidType;   // DS_SCHEMA_GUID_* value
#ifdef MIDL_PASS
    [string,unique] CHAR    *pName;     // might be NULL
#else
    LPSTR                   pName;      // might be NULL
#endif

} DS_SCHEMA_GUID_MAPA, *PDS_SCHEMA_GUID_MAPA;

typedef struct
{
    GUID                    guid;       // mapped GUID
    DWORD                   guidType;   // DS_SCHEMA_GUID_* value
#ifdef MIDL_PASS
    [string,unique] WCHAR   *pName;     // might be NULL
#else
    LPWSTR                  pName;      // might be NULL
#endif

} DS_SCHEMA_GUID_MAPW, *PDS_SCHEMA_GUID_MAPW;

NTDSAPI
DWORD
WINAPI
DsMapSchemaGuidsA(
    HANDLE                  hDs,            // in
    DWORD                   cGuids,         // in
    GUID                    *rGuids,        // in
    DS_SCHEMA_GUID_MAPA     **ppGuidMap);   // out

NTDSAPI
VOID
WINAPI
DsFreeSchemaGuidMapA(
    PDS_SCHEMA_GUID_MAPA    pGuidMap);      // in

NTDSAPI
DWORD
WINAPI
DsMapSchemaGuidsW(
    HANDLE                  hDs,            // in
    DWORD                   cGuids,         // in
    GUID                    *rGuids,        // in
    DS_SCHEMA_GUID_MAPW     **ppGuidMap);   // out

NTDSAPI
VOID
WINAPI
DsFreeSchemaGuidMapW(
    PDS_SCHEMA_GUID_MAPW    pGuidMap);      // in

#ifdef UNICODE
#define DS_SCHEMA_GUID_MAP DS_SCHEMA_GUID_MAPW
#define PDS_SCHEMA_GUID_MAP PDS_SCHEMA_GUID_MAPW
#define DsMapSchemaGuids DsMapSchemaGuidsW
#define DsFreeSchemaGuidMap DsFreeSchemaGuidMapW
#else
#define DS_SCHEMA_GUID_MAP DS_SCHEMA_GUID_MAPA
#define PDS_SCHEMA_GUID_MAP PDS_SCHEMA_GUID_MAPA
#define DsMapSchemaGuids DsMapSchemaGuidsA
#define DsFreeSchemaGuidMap DsFreeSchemaGuidMapA
#endif

typedef struct
{
#ifdef MIDL_PASS
    [string,unique] CHAR    *NetbiosName;           // might be NULL
    [string,unique] CHAR    *DnsHostName;           // might be NULL
    [string,unique] CHAR    *SiteName;              // might be NULL
    [string,unique] CHAR    *ComputerObjectName;    // might be NULL
    [string,unique] CHAR    *ServerObjectName;      // might be NULL
#else
    LPSTR                   NetbiosName;            // might be NULL
    LPSTR                   DnsHostName;            // might be NULL
    LPSTR                   SiteName;               // might be NULL
    LPSTR                   ComputerObjectName;     // might be NULL
    LPSTR                   ServerObjectName;       // might be NULL
#endif
    BOOL                    fIsPdc;
    BOOL                    fDsEnabled;

} DS_DOMAIN_CONTROLLER_INFO_1A, *PDS_DOMAIN_CONTROLLER_INFO_1A;

typedef struct
{
#ifdef MIDL_PASS
    [string,unique] WCHAR   *NetbiosName;           // might be NULL
    [string,unique] WCHAR   *DnsHostName;           // might be NULL
    [string,unique] WCHAR   *SiteName;              // might be NULL
    [string,unique] WCHAR   *ComputerObjectName;    // might be NULL
    [string,unique] WCHAR   *ServerObjectName;      // might be NULL
#else
    LPWSTR                  NetbiosName;            // might be NULL
    LPWSTR                  DnsHostName;            // might be NULL
    LPWSTR                  SiteName;               // might be NULL
    LPWSTR                  ComputerObjectName;     // might be NULL
    LPWSTR                  ServerObjectName;       // might be NULL
#endif
    BOOL                    fIsPdc;
    BOOL                    fDsEnabled;

} DS_DOMAIN_CONTROLLER_INFO_1W, *PDS_DOMAIN_CONTROLLER_INFO_1W;

typedef struct
{
#ifdef MIDL_PASS
    [string,unique] CHAR    *NetbiosName;           // might be NULL
    [string,unique] CHAR    *DnsHostName;           // might be NULL
    [string,unique] CHAR    *SiteName;              // might be NULL
    [string,unique] CHAR    *SiteObjectName;        // might be NULL
    [string,unique] CHAR    *ComputerObjectName;    // might be NULL
    [string,unique] CHAR    *ServerObjectName;      // might be NULL
    [string,unique] CHAR    *NtdsDsaObjectName;     // might be NULL
#else
    LPSTR                   NetbiosName;            // might be NULL
    LPSTR                   DnsHostName;            // might be NULL
    LPSTR                   SiteName;               // might be NULL
    LPSTR                   SiteObjectName;         // might be NULL
    LPSTR                   ComputerObjectName;     // might be NULL
    LPSTR                   ServerObjectName;       // might be NULL
    LPSTR                   NtdsDsaObjectName;      // might be NULL
#endif
    BOOL                    fIsPdc;
    BOOL                    fDsEnabled;
    BOOL                    fIsGc;

    // Valid iff SiteObjectName non-NULL.
    GUID                    SiteObjectGuid;
    // Valid iff ComputerObjectName non-NULL.
    GUID                    ComputerObjectGuid;
    // Valid iff ServerObjectName non-NULL;
    GUID                    ServerObjectGuid;
    // Valid iff fDsEnabled is TRUE.
    GUID                    NtdsDsaObjectGuid;

} DS_DOMAIN_CONTROLLER_INFO_2A, *PDS_DOMAIN_CONTROLLER_INFO_2A;

typedef struct
{
#ifdef MIDL_PASS
    [string,unique] WCHAR   *NetbiosName;           // might be NULL
    [string,unique] WCHAR   *DnsHostName;           // might be NULL
    [string,unique] WCHAR   *SiteName;              // might be NULL
    [string,unique] WCHAR   *SiteObjectName;        // might be NULL
    [string,unique] WCHAR   *ComputerObjectName;    // might be NULL
    [string,unique] WCHAR   *ServerObjectName;      // might be NULL
    [string,unique] WCHAR   *NtdsDsaObjectName;     // might be NULL
#else
    LPWSTR                  NetbiosName;            // might be NULL
    LPWSTR                  DnsHostName;            // might be NULL
    LPWSTR                  SiteName;               // might be NULL
    LPWSTR                  SiteObjectName;         // might be NULL
    LPWSTR                  ComputerObjectName;     // might be NULL
    LPWSTR                  ServerObjectName;       // might be NULL
    LPWSTR                  NtdsDsaObjectName;      // might be NULL
#endif
    BOOL                    fIsPdc;
    BOOL                    fDsEnabled;
    BOOL                    fIsGc;

    // Valid iff SiteObjectName non-NULL.
    GUID                    SiteObjectGuid;
    // Valid iff ComputerObjectName non-NULL.
    GUID                    ComputerObjectGuid;
    // Valid iff ServerObjectName non-NULL;
    GUID                    ServerObjectGuid;
    // Valid iff fDsEnabled is TRUE.
    GUID                    NtdsDsaObjectGuid;

} DS_DOMAIN_CONTROLLER_INFO_2W, *PDS_DOMAIN_CONTROLLER_INFO_2W;

typedef struct
{
#ifdef MIDL_PASS
    [string,unique] CHAR    *NetbiosName;           // might be NULL
    [string,unique] CHAR    *DnsHostName;           // might be NULL
    [string,unique] CHAR    *SiteName;              // might be NULL
    [string,unique] CHAR    *SiteObjectName;        // might be NULL
    [string,unique] CHAR    *ComputerObjectName;    // might be NULL
    [string,unique] CHAR    *ServerObjectName;      // might be NULL
    [string,unique] CHAR    *NtdsDsaObjectName;     // might be NULL
#else
    LPSTR                   NetbiosName;            // might be NULL
    LPSTR                   DnsHostName;            // might be NULL
    LPSTR                   SiteName;               // might be NULL
    LPSTR                   SiteObjectName;         // might be NULL
    LPSTR                   ComputerObjectName;     // might be NULL
    LPSTR                   ServerObjectName;       // might be NULL
    LPSTR                   NtdsDsaObjectName;      // might be NULL
#endif
    BOOL                    fIsPdc;
    BOOL                    fDsEnabled;
    BOOL                    fIsGc;
    BOOL                    fIsRodc;

    // Valid iff SiteObjectName non-NULL.
    GUID                    SiteObjectGuid;
    // Valid iff ComputerObjectName non-NULL.
    GUID                    ComputerObjectGuid;
    // Valid iff ServerObjectName non-NULL;
    GUID                    ServerObjectGuid;
    // Valid iff fDsEnabled is TRUE.
    GUID                    NtdsDsaObjectGuid;

} DS_DOMAIN_CONTROLLER_INFO_3A, *PDS_DOMAIN_CONTROLLER_INFO_3A;

typedef struct
{
#ifdef MIDL_PASS
    [string,unique] WCHAR   *NetbiosName;           // might be NULL
    [string,unique] WCHAR   *DnsHostName;           // might be NULL
    [string,unique] WCHAR   *SiteName;              // might be NULL
    [string,unique] WCHAR   *SiteObjectName;        // might be NULL
    [string,unique] WCHAR   *ComputerObjectName;    // might be NULL
    [string,unique] WCHAR   *ServerObjectName;      // might be NULL
    [string,unique] WCHAR   *NtdsDsaObjectName;     // might be NULL
#else
    LPWSTR                  NetbiosName;            // might be NULL
    LPWSTR                  DnsHostName;            // might be NULL
    LPWSTR                  SiteName;               // might be NULL
    LPWSTR                  SiteObjectName;         // might be NULL
    LPWSTR                  ComputerObjectName;     // might be NULL
    LPWSTR                  ServerObjectName;       // might be NULL
    LPWSTR                  NtdsDsaObjectName;      // might be NULL
#endif
    BOOL                    fIsPdc;
    BOOL                    fDsEnabled;
    BOOL                    fIsGc;
    BOOL                    fIsRodc;

    // Valid iff SiteObjectName non-NULL.
    GUID                    SiteObjectGuid;
    // Valid iff ComputerObjectName non-NULL.
    GUID                    ComputerObjectGuid;
    // Valid iff ServerObjectName non-NULL;
    GUID                    ServerObjectGuid;
    // Valid iff fDsEnabled is TRUE.
    GUID                    NtdsDsaObjectGuid;

} DS_DOMAIN_CONTROLLER_INFO_3W, *PDS_DOMAIN_CONTROLLER_INFO_3W;

// The following APIs strictly find domain controller account objects
// in the DS and return information associated with them.  As such, they
// may return entries which correspond to domain controllers long since
// decommissioned, etc. and there is no guarantee that there exists a
// physical domain controller at all.  Use DsGetDcName (dsgetdc.h) to find
// live domain controllers for a domain.

NTDSAPI
DWORD
WINAPI
DsGetDomainControllerInfoA(
    HANDLE                          hDs,            // in
    LPCSTR                          DomainName,     // in
    DWORD                           InfoLevel,      // in
    DWORD                           *pcOut,         // out
    VOID                            **ppInfo);      // out

NTDSAPI
DWORD
WINAPI
DsGetDomainControllerInfoW(
    HANDLE                          hDs,            // in
    LPCWSTR                         DomainName,     // in
    DWORD                           InfoLevel,      // in
    DWORD                           *pcOut,         // out
    VOID                            **ppInfo);      // out

NTDSAPI
VOID
WINAPI
DsFreeDomainControllerInfoA(
    DWORD                           InfoLevel,      // in
    DWORD                           cInfo,          // in
    VOID                            *pInfo);        // in

NTDSAPI
VOID
WINAPI
DsFreeDomainControllerInfoW(
    DWORD                           InfoLevel,      // in
    DWORD                           cInfo,          // in
    VOID                            *pInfo);        // in

#ifdef UNICODE
#define DS_DOMAIN_CONTROLLER_INFO_1 DS_DOMAIN_CONTROLLER_INFO_1W
#define DS_DOMAIN_CONTROLLER_INFO_2 DS_DOMAIN_CONTROLLER_INFO_2W
#define DS_DOMAIN_CONTROLLER_INFO_3 DS_DOMAIN_CONTROLLER_INFO_3W
#define PDS_DOMAIN_CONTROLLER_INFO_1 PDS_DOMAIN_CONTROLLER_INFO_1W
#define PDS_DOMAIN_CONTROLLER_INFO_2 PDS_DOMAIN_CONTROLLER_INFO_2W
#define PDS_DOMAIN_CONTROLLER_INFO_3 PDS_DOMAIN_CONTROLLER_INFO_3W
#define DsGetDomainControllerInfo DsGetDomainControllerInfoW
#define DsFreeDomainControllerInfo DsFreeDomainControllerInfoW
#else
#define DS_DOMAIN_CONTROLLER_INFO_1 DS_DOMAIN_CONTROLLER_INFO_1A
#define DS_DOMAIN_CONTROLLER_INFO_2 DS_DOMAIN_CONTROLLER_INFO_2A
#define DS_DOMAIN_CONTROLLER_INFO_3 DS_DOMAIN_CONTROLLER_INFO_3A
#define PDS_DOMAIN_CONTROLLER_INFO_1 PDS_DOMAIN_CONTROLLER_INFO_1A
#define PDS_DOMAIN_CONTROLLER_INFO_2 PDS_DOMAIN_CONTROLLER_INFO_2A
#define PDS_DOMAIN_CONTROLLER_INFO_3 PDS_DOMAIN_CONTROLLER_INFO_3A
#define DsGetDomainControllerInfo DsGetDomainControllerInfoA
#define DsFreeDomainControllerInfo DsFreeDomainControllerInfoA
#endif

// Which task should be run?
typedef enum {
    DS_KCC_TASKID_UPDATE_TOPOLOGY = 0
} DS_KCC_TASKID;

// Don't wait for completion of the task; queue it and return.
#define DS_KCC_FLAG_ASYNC_OP    (1 << 0)

// Don't enqueue the task if another queued task will run soon.
#define DS_KCC_FLAG_DAMPED      (1 << 1)

NTDSAPI
DWORD
WINAPI
DsReplicaConsistencyCheck(
    HANDLE          hDS,        // in
    DS_KCC_TASKID   TaskID,     // in
    DWORD           dwFlags);   // in

NTDSAPI
DWORD
WINAPI
DsReplicaVerifyObjectsW(
    HANDLE          hDS,        // in
    LPCWSTR         NameContext,// in
    const UUID *    pUuidDsaSrc,// in
    ULONG           ulOptions);   // in

NTDSAPI
DWORD
WINAPI
DsReplicaVerifyObjectsA(
    HANDLE          hDS,        // in
    LPCSTR          NameContext,// in
    const UUID *    pUuidDsaSrc,// in
    ULONG           ulOptions);   // in

#ifdef UNICODE
#define DsReplicaVerifyObjects DsReplicaVerifyObjectsW
#else
#define DsReplicaVerifyObjects DsReplicaVerifyObjectsA
#endif

// Do not delete objects on DsReplicaVerifyObjects call
#define DS_EXIST_ADVISORY_MODE (0x1)

typedef enum _DS_REPL_INFO_TYPE {
    DS_REPL_INFO_NEIGHBORS        = 0,          // returns DS_REPL_NEIGHBORS *
    DS_REPL_INFO_CURSORS_FOR_NC   = 1,          // returns DS_REPL_CURSORS *
    DS_REPL_INFO_METADATA_FOR_OBJ = 2,          // returns DS_REPL_OBJECT_META_DATA *
    DS_REPL_INFO_KCC_DSA_CONNECT_FAILURES = 3,  // both return
    DS_REPL_INFO_KCC_DSA_LINK_FAILURES = 4,     //    DS_REPL_KCC_DSA_FAILURES *
    DS_REPL_INFO_PENDING_OPS      = 5,          // returns DS_REPL_PENDING_OPS *

    ////////////////////////////////////////////////////////////////////////////
    //
    //  The following info types are not supported by Windows 2000.  Calling
    //  DsReplicaGetInfo() with one of the types on a Windows 2000 client or
    //  where hDS is bound to a Windows 2000 DC will fail with
    //  ERROR_NOT_SUPPORTED.
    //

    DS_REPL_INFO_METADATA_FOR_ATTR_VALUE = 6,   // returns DS_REPL_ATTR_VALUE_META_DATA *
    DS_REPL_INFO_CURSORS_2_FOR_NC = 7,          // returns DS_REPL_CURSORS_2 *
    DS_REPL_INFO_CURSORS_3_FOR_NC = 8,          // returns DS_REPL_CURSORS_3 *
    DS_REPL_INFO_METADATA_2_FOR_OBJ = 9,        // returns DS_REPL_OBJECT_META_DATA_2 *
    DS_REPL_INFO_METADATA_2_FOR_ATTR_VALUE = 10,// returns DS_REPL_ATTR_VALUE_META_DATA_2 *

    // <- insert new DS_REPL_INFO_* types here.
    DS_REPL_INFO_TYPE_MAX
} DS_REPL_INFO_TYPE;

// Bit values for flags argument to DsReplicaGetInfo2
#define DS_REPL_INFO_FLAG_IMPROVE_LINKED_ATTRS      (0x00000001)

// Bit values for the dwReplicaFlags field of the DS_REPL_NEIGHBOR structure.
// Also used for the ulReplicaFlags argument to DsReplicaModify
#define DS_REPL_NBR_WRITEABLE                       (0x00000010)
#define DS_REPL_NBR_SYNC_ON_STARTUP                 (0x00000020)
#define DS_REPL_NBR_DO_SCHEDULED_SYNCS              (0x00000040)
#define DS_REPL_NBR_USE_ASYNC_INTERSITE_TRANSPORT   (0x00000080)
#define DS_REPL_NBR_TWO_WAY_SYNC                    (0x00000200)
#define DS_REPL_NBR_NONGC_RO_REPLICA                (0x00000400)
#define DS_REPL_NBR_RETURN_OBJECT_PARENTS           (0x00000800)
#define DS_REPL_NBR_SELECT_SECRETS                  (0x00001000)
#define DS_REPL_NBR_FULL_SYNC_IN_PROGRESS           (0x00010000)
#define DS_REPL_NBR_FULL_SYNC_NEXT_PACKET           (0x00020000)
#define DS_REPL_NBR_GCSPN                           (0x00100000)
#define DS_REPL_NBR_NEVER_SYNCED                    (0x00200000)
#define DS_REPL_NBR_PREEMPTED                       (0x01000000)
#define DS_REPL_NBR_IGNORE_CHANGE_NOTIFICATIONS     (0x04000000)
#define DS_REPL_NBR_DISABLE_SCHEDULED_SYNC          (0x08000000)
#define DS_REPL_NBR_COMPRESS_CHANGES                (0x10000000)
#define DS_REPL_NBR_NO_CHANGE_NOTIFICATIONS         (0x20000000)
#define DS_REPL_NBR_PARTIAL_ATTRIBUTE_SET           (0x40000000)

// This is the mask of replica flags that may be changed on the DsReplicaModify
// call using the ulReplicaFlags parameter. The other flags are protected
// system flags.  The previous values of the system flags must be read in
// advance and merged into the ulReplicaFlags parameter unchanged.
#define DS_REPL_NBR_MODIFIABLE_MASK \
        ( \
        DS_REPL_NBR_SYNC_ON_STARTUP | \
        DS_REPL_NBR_DO_SCHEDULED_SYNCS | \
        DS_REPL_NBR_TWO_WAY_SYNC | \
        DS_REPL_NBR_IGNORE_CHANGE_NOTIFICATIONS | \
        DS_REPL_NBR_DISABLE_SCHEDULED_SYNC | \
        DS_REPL_NBR_COMPRESS_CHANGES | \
        DS_REPL_NBR_NO_CHANGE_NOTIFICATIONS \
        )

typedef struct _DS_REPL_NEIGHBORW {
    LPWSTR      pszNamingContext;
    LPWSTR      pszSourceDsaDN;
    LPWSTR      pszSourceDsaAddress;
    LPWSTR      pszAsyncIntersiteTransportDN;
    DWORD       dwReplicaFlags;
    DWORD       dwReserved;         // alignment

    UUID        uuidNamingContextObjGuid;
    UUID        uuidSourceDsaObjGuid;
    UUID        uuidSourceDsaInvocationID;
    UUID        uuidAsyncIntersiteTransportObjGuid;

    USN         usnLastObjChangeSynced;
    USN         usnAttributeFilter;

    FILETIME    ftimeLastSyncSuccess;
    FILETIME    ftimeLastSyncAttempt;

    DWORD       dwLastSyncResult;
    DWORD       cNumConsecutiveSyncFailures;
} DS_REPL_NEIGHBORW;

// Fields can be added only to the end of this structure.
typedef struct _DS_REPL_NEIGHBORW_BLOB {
    DWORD       oszNamingContext;
    DWORD       oszSourceDsaDN;
    DWORD       oszSourceDsaAddress;
    DWORD       oszAsyncIntersiteTransportDN;
    DWORD       dwReplicaFlags;
    DWORD       dwReserved;

    UUID        uuidNamingContextObjGuid;
    UUID        uuidSourceDsaObjGuid;
    UUID        uuidSourceDsaInvocationID;
    UUID        uuidAsyncIntersiteTransportObjGuid;

    USN         usnLastObjChangeSynced;
    USN         usnAttributeFilter;

    FILETIME    ftimeLastSyncSuccess;
    FILETIME    ftimeLastSyncAttempt;

    DWORD       dwLastSyncResult;
    DWORD       cNumConsecutiveSyncFailures;
} DS_REPL_NEIGHBORW_BLOB;

typedef struct _DS_REPL_NEIGHBORSW {
    DWORD       cNumNeighbors;
    DWORD       dwReserved;             // alignment
#ifdef MIDL_PASS
    [size_is(cNumNeighbors)] DS_REPL_NEIGHBORW rgNeighbor[];
#else
    DS_REPL_NEIGHBORW rgNeighbor[1];
#endif
} DS_REPL_NEIGHBORSW;

typedef struct _DS_REPL_CURSOR {
    UUID        uuidSourceDsaInvocationID;
    USN         usnAttributeFilter;
} DS_REPL_CURSOR;

typedef struct _DS_REPL_CURSOR_2 {
    UUID        uuidSourceDsaInvocationID;
    USN         usnAttributeFilter;
    FILETIME    ftimeLastSyncSuccess;
} DS_REPL_CURSOR_2;

typedef struct _DS_REPL_CURSOR_3W {
    UUID        uuidSourceDsaInvocationID;
    USN         usnAttributeFilter;
    FILETIME    ftimeLastSyncSuccess;
    LPWSTR      pszSourceDsaDN;
} DS_REPL_CURSOR_3W;

// Fields can be added only to the end of this structure.
typedef struct _DS_REPL_CURSOR_BLOB {
    UUID        uuidSourceDsaInvocationID;
    USN         usnAttributeFilter;
    FILETIME    ftimeLastSyncSuccess;
    DWORD       oszSourceDsaDN;
} DS_REPL_CURSOR_BLOB;

typedef struct _DS_REPL_CURSORS {
    DWORD       cNumCursors;
    DWORD       dwReserved;             // alignment
#ifdef MIDL_PASS
    [size_is(cNumCursors)] DS_REPL_CURSOR rgCursor[];
#else
    DS_REPL_CURSOR rgCursor[1];
#endif
} DS_REPL_CURSORS;

typedef struct _DS_REPL_CURSORS_2 {
    DWORD       cNumCursors;
    DWORD       dwEnumerationContext;
    // keep this 8 byte aligned
#ifdef MIDL_PASS
    [size_is(cNumCursors)] DS_REPL_CURSOR_2 rgCursor[];
#else
    DS_REPL_CURSOR_2 rgCursor[1];
#endif
} DS_REPL_CURSORS_2;

typedef struct _DS_REPL_CURSORS_3W {
    DWORD       cNumCursors;
    DWORD       dwEnumerationContext;
    // keep this 8 byte aligned
#ifdef MIDL_PASS
    [size_is(cNumCursors)] DS_REPL_CURSOR_3W rgCursor[];
#else
    DS_REPL_CURSOR_3W rgCursor[1];
#endif
} DS_REPL_CURSORS_3W;

typedef struct _DS_REPL_ATTR_META_DATA {
    LPWSTR      pszAttributeName;
    DWORD       dwVersion;
    FILETIME    ftimeLastOriginatingChange;
    UUID        uuidLastOriginatingDsaInvocationID;
    USN         usnOriginatingChange;   // in the originating DSA's USN space
    USN         usnLocalChange;         // in the local DSA's USN space
} DS_REPL_ATTR_META_DATA;

typedef struct _DS_REPL_ATTR_META_DATA_2 {
    LPWSTR      pszAttributeName;
    DWORD       dwVersion;
    FILETIME    ftimeLastOriginatingChange;
    UUID        uuidLastOriginatingDsaInvocationID;
    USN         usnOriginatingChange;   // in the originating DSA's USN space
    USN         usnLocalChange;         // in the local DSA's USN space
    LPWSTR      pszLastOriginatingDsaDN;
} DS_REPL_ATTR_META_DATA_2;

// Fields can be added only to the end of this structure.
typedef struct _DS_REPL_ATTR_META_DATA_BLOB {
    DWORD       oszAttributeName;
    DWORD       dwVersion;
    FILETIME    ftimeLastOriginatingChange;
    UUID        uuidLastOriginatingDsaInvocationID;
    USN         usnOriginatingChange;   // in the originating DSA's USN space
    USN         usnLocalChange;         // in the local DSA's USN space
    DWORD       oszLastOriginatingDsaDN;
} DS_REPL_ATTR_META_DATA_BLOB;

typedef struct _DS_REPL_OBJ_META_DATA {
    DWORD       cNumEntries;
    DWORD       dwReserved;             // alignment
#ifdef MIDL_PASS
    [size_is(cNumEntries)] DS_REPL_ATTR_META_DATA rgMetaData[];
#else
    DS_REPL_ATTR_META_DATA rgMetaData[1];
#endif
} DS_REPL_OBJ_META_DATA;

typedef struct _DS_REPL_OBJ_META_DATA_2 {
    DWORD       cNumEntries;
    DWORD       dwReserved;             // alignment
#ifdef MIDL_PASS
    [size_is(cNumEntries)] DS_REPL_ATTR_META_DATA_2 rgMetaData[];
#else
    DS_REPL_ATTR_META_DATA_2 rgMetaData[1];
#endif
} DS_REPL_OBJ_META_DATA_2;

typedef struct _DS_REPL_KCC_DSA_FAILUREW {
    LPWSTR      pszDsaDN;
    UUID        uuidDsaObjGuid;
    FILETIME    ftimeFirstFailure;
    DWORD       cNumFailures;
    DWORD       dwLastResult;   // Win32 error code
} DS_REPL_KCC_DSA_FAILUREW;

// Fields can be added only to the end of this structure.
typedef struct _DS_REPL_KCC_DSA_FAILUREW_BLOB {
    DWORD       oszDsaDN;
    UUID        uuidDsaObjGuid;
    FILETIME    ftimeFirstFailure;
    DWORD       cNumFailures;
    DWORD       dwLastResult;   // Win32 error code
} DS_REPL_KCC_DSA_FAILUREW_BLOB;

typedef struct _DS_REPL_KCC_DSA_FAILURESW {
    DWORD       cNumEntries;
    DWORD       dwReserved;             // alignment
#ifdef MIDL_PASS
    [size_is(cNumEntries)] DS_REPL_KCC_DSA_FAILUREW rgDsaFailure[];
#else
    DS_REPL_KCC_DSA_FAILUREW rgDsaFailure[1];
#endif
} DS_REPL_KCC_DSA_FAILURESW;

typedef enum _DS_REPL_OP_TYPE {
    DS_REPL_OP_TYPE_SYNC = 0,
    DS_REPL_OP_TYPE_ADD,
    DS_REPL_OP_TYPE_DELETE,
    DS_REPL_OP_TYPE_MODIFY,
    DS_REPL_OP_TYPE_UPDATE_REFS
} DS_REPL_OP_TYPE;

typedef struct _DS_REPL_OPW {
    FILETIME        ftimeEnqueued;  // time at which the operation was enqueued
    ULONG           ulSerialNumber; // ID of this sync; unique per machine per boot
    ULONG           ulPriority;     // > priority, > urgency
    DS_REPL_OP_TYPE OpType;

    ULONG           ulOptions;      // Zero or more bits specific to OpType; e.g.,
                                    //  DS_REPADD_* for DS_REPL_OP_TYPE_ADD,
                                    //  DS_REPSYNC_* for DS_REPL_OP_TYPE_SYNC, etc.
    LPWSTR          pszNamingContext;
    LPWSTR          pszDsaDN;
    LPWSTR          pszDsaAddress;

    UUID            uuidNamingContextObjGuid;
    UUID            uuidDsaObjGuid;
} DS_REPL_OPW;

// Fields can be added only to the end of this structure.
typedef struct _DS_REPL_OPW_BLOB {
    FILETIME        ftimeEnqueued;  // time at which the operation was enqueued
    ULONG           ulSerialNumber; // ID of this sync; unique per machine per boot
    ULONG           ulPriority;     // > priority, > urgency
    DS_REPL_OP_TYPE OpType;

    ULONG           ulOptions;      // Zero or more bits specific to OpType; e.g.,
                                    //  DS_REPADD_* for DS_REPL_OP_TYPE_ADD,
                                    //  DS_REPSYNC_* for DS_REPL_OP_TYPE_SYNC, etc.
    DWORD           oszNamingContext;
    DWORD           oszDsaDN;
    DWORD           oszDsaAddress;

    UUID            uuidNamingContextObjGuid;
    UUID            uuidDsaObjGuid;
} DS_REPL_OPW_BLOB;

typedef struct _DS_REPL_PENDING_OPSW {
    FILETIME            ftimeCurrentOpStarted;
    DWORD               cNumPendingOps;
#ifdef MIDL_PASS
    [size_is(cNumPendingOps)] DS_REPL_OPW rgPendingOp[];
#else
    DS_REPL_OPW         rgPendingOp[1];
#endif
} DS_REPL_PENDING_OPSW;

typedef struct _DS_REPL_VALUE_META_DATA {
    LPWSTR      pszAttributeName;
    LPWSTR      pszObjectDn;
    DWORD       cbData;
#ifdef MIDL_PASS
    [size_is(cbData), ptr] BYTE        *pbData;
#else
    BYTE        *pbData;
#endif
    FILETIME    ftimeDeleted;
    FILETIME    ftimeCreated;
    DWORD       dwVersion;
    FILETIME    ftimeLastOriginatingChange;
    UUID        uuidLastOriginatingDsaInvocationID;
    USN         usnOriginatingChange;   // in the originating DSA's USN space
    USN         usnLocalChange;         // in the local DSA's USN space
} DS_REPL_VALUE_META_DATA;

typedef struct _DS_REPL_VALUE_META_DATA_2 {
    LPWSTR      pszAttributeName;
    LPWSTR      pszObjectDn;
    DWORD       cbData;
#ifdef MIDL_PASS
    [size_is(cbData), ptr] BYTE        *pbData;
#else
    BYTE        *pbData;
#endif
    FILETIME    ftimeDeleted;
    FILETIME    ftimeCreated;
    DWORD       dwVersion;
    FILETIME    ftimeLastOriginatingChange;
    UUID        uuidLastOriginatingDsaInvocationID;
    USN         usnOriginatingChange;   // in the originating DSA's USN space
    USN         usnLocalChange;         // in the local DSA's USN space
    LPWSTR      pszLastOriginatingDsaDN;
} DS_REPL_VALUE_META_DATA_2;

// Fields can be added only to the end of this structure.
typedef struct _DS_REPL_VALUE_META_DATA_BLOB {
    DWORD       oszAttributeName;
    DWORD       oszObjectDn;
    DWORD       cbData;
    DWORD       obData;
    FILETIME    ftimeDeleted;
    FILETIME    ftimeCreated;
    DWORD       dwVersion;
    FILETIME    ftimeLastOriginatingChange;
    UUID        uuidLastOriginatingDsaInvocationID;
    USN         usnOriginatingChange;   // in the originating DSA's USN space
    USN         usnLocalChange;         // in the local DSA's USN space
    DWORD       oszLastOriginatingDsaDN;
} DS_REPL_VALUE_META_DATA_BLOB;

typedef struct _DS_REPL_ATTR_VALUE_META_DATA {
    DWORD       cNumEntries;
    DWORD       dwEnumerationContext;
#ifdef MIDL_PASS
    [size_is(cNumEntries)] DS_REPL_VALUE_META_DATA rgMetaData[];
#else
    DS_REPL_VALUE_META_DATA rgMetaData[1];
#endif
} DS_REPL_ATTR_VALUE_META_DATA;

typedef struct _DS_REPL_ATTR_VALUE_META_DATA_2 {
    DWORD       cNumEntries;
    DWORD       dwEnumerationContext;
#ifdef MIDL_PASS
    [size_is(cNumEntries)] DS_REPL_VALUE_META_DATA_2 rgMetaData[];
#else
    DS_REPL_VALUE_META_DATA_2 rgMetaData[1];
#endif
} DS_REPL_ATTR_VALUE_META_DATA_2;

typedef struct _DS_REPL_QUEUE_STATISTICSW
{
    FILETIME ftimeCurrentOpStarted;
    DWORD cNumPendingOps;
    FILETIME ftimeOldestSync;
    FILETIME ftimeOldestAdd;
    FILETIME ftimeOldestMod;
    FILETIME ftimeOldestDel;
    FILETIME ftimeOldestUpdRefs;
} DS_REPL_QUEUE_STATISTICSW;

// Fields can be added only to the end of this structure.
typedef struct _DS_REPL_QUEUE_STATISTICSW DS_REPL_QUEUE_STATISTICSW_BLOB;


NTDSAPI
DWORD
WINAPI
DsReplicaGetInfoW(
    HANDLE              hDS,                        // in
    DS_REPL_INFO_TYPE   InfoType,                   // in
    LPCWSTR             pszObject,                  // in
    UUID *              puuidForSourceDsaObjGuid,   // in
    VOID **             ppInfo);                    // out

// This API is not supported by Windows 2000 clients or Windows 2000 DCs.
NTDSAPI
DWORD
WINAPI
DsReplicaGetInfo2W(
    HANDLE              hDS,                        // in
    DS_REPL_INFO_TYPE   InfoType,                   // in
    LPCWSTR             pszObject,                  // in
    UUID *              puuidForSourceDsaObjGuid,   // in
    LPCWSTR             pszAttributeName,           // in
    LPCWSTR             pszValue,                   // in
    DWORD               dwFlags,                    // in
    DWORD               dwEnumerationContext,       // in
    VOID **             ppInfo);                    // out

NTDSAPI
void
WINAPI
DsReplicaFreeInfo(
    DS_REPL_INFO_TYPE   InfoType,   // in
    VOID *              pInfo);     // in


#ifdef UNICODE
#define DsReplicaGetInfo          DsReplicaGetInfoW
#define DsReplicaGetInfo2         DsReplicaGetInfo2W
#define DS_REPL_NEIGHBOR          DS_REPL_NEIGHBORW
#define DS_REPL_NEIGHBORS         DS_REPL_NEIGHBORSW
#define DS_REPL_CURSOR_3          DS_REPL_CURSOR_3W
#define DS_REPL_CURSORS_3         DS_REPL_CURSORS_3W
#define DS_REPL_KCC_DSA_FAILURES  DS_REPL_KCC_DSA_FAILURESW
#define DS_REPL_KCC_DSA_FAILURE   DS_REPL_KCC_DSA_FAILUREW
#define DS_REPL_OP                DS_REPL_OPW
#define DS_REPL_PENDING_OPS       DS_REPL_PENDING_OPSW
#else
// No ANSI equivalents currently supported.
#endif

NTDSAPI
DWORD
WINAPI
DsAddSidHistoryW(
    HANDLE                  hDS,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCWSTR                 SrcDomain,              // in - DNS or NetBIOS
    LPCWSTR                 SrcPrincipal,           // in - SAM account name
    LPCWSTR                 SrcDomainController,    // in, optional
    RPC_AUTH_IDENTITY_HANDLE SrcDomainCreds,        // in - creds for src domain
    LPCWSTR                 DstDomain,              // in - DNS or NetBIOS
    LPCWSTR                 DstPrincipal);          // in - SAM account name

NTDSAPI
DWORD
WINAPI
DsAddSidHistoryA(
    HANDLE                  hDS,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCSTR                  SrcDomain,              // in - DNS or NetBIOS
    LPCSTR                  SrcPrincipal,           // in - SAM account name
    LPCSTR                  SrcDomainController,    // in, optional
    RPC_AUTH_IDENTITY_HANDLE SrcDomainCreds,        // in - creds for src domain
    LPCSTR                  DstDomain,              // in - DNS or NetBIOS
    LPCSTR                  DstPrincipal);          // in - SAM account name

#ifdef UNICODE
#define DsAddSidHistory DsAddSidHistoryW
#else
#define DsAddSidHistory DsAddSidHistoryA
#endif

// The DsInheritSecurityIdentity API adds the source principal's SID and
// SID history to the destination principal's SID history and then DELETES
// THE SOURCE PRINCIPAL.  Source and destination principal must be in the
// same domain.

NTDSAPI
DWORD
WINAPI
DsInheritSecurityIdentityW(
    HANDLE                  hDS,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCWSTR                 SrcPrincipal,           // in - distinguished name
    LPCWSTR                 DstPrincipal);          // in - distinguished name

NTDSAPI
DWORD
WINAPI
DsInheritSecurityIdentityA(
    HANDLE                  hDS,                    // in
    DWORD                   Flags,                  // in - sbz for now
    LPCSTR                  SrcPrincipal,           // in - distinguished name
    LPCSTR                  DstPrincipal);          // in - distinguished name

#ifdef UNICODE
#define DsInheritSecurityIdentity DsInheritSecurityIdentityW
#else
#define DsInheritSecurityIdentity DsInheritSecurityIdentityA
#endif

#ifndef MIDL_PASS
/*++
==========================================================
NTDSAPI
DWORD
WINAPI
DsQuoteRdnValue(
    IN     DWORD    cUnquotedRdnValueLength,
    IN     LPCTCH   psUnquotedRdnValue,
    IN OUT DWORD    *pcQuotedRdnValueLength,
    OUT    LPTCH    psQuotedRdnValue
    )
/*++

Description

    This client call converts an RDN value into a quoted RDN value if
    the RDN value contains characters that require quotes. The resultant
    RDN can be submitted as part of a DN to the DS using various APIs
    such as LDAP.

    No quotes are added if none are needed. In this case, the
    output RDN value will be the same as the input RDN value.

    The RDN is quoted in accordance with the specification "Lightweight
    Directory Access Protocol (v3): UTF-8 String Representation of
    Distinguished Names", RFC 2253.

    The input and output RDN values are *NOT* NULL terminated.

    The changes made by this call can be undone by calling
    DsUnquoteRdnValue().

Arguments:

    cUnquotedRdnValueLength - The length of psUnquotedRdnValue in chars.

    psUnquotedRdnValue - Unquoted RDN value.

    pcQuotedRdnValueeLength - IN, maximum length of psQuotedRdnValue, in chars
                        OUT ERROR_SUCCESS, chars utilized in psQuotedRdnValue
                        OUT ERROR_BUFFER_OVERFLOW, chars needed in psQuotedRdnValue

    psQuotedRdnValue - The resultant and perhaps quoted RDN value

Return Value:
    ERROR_SUCCESS
        If quotes or escapes were needed, then psQuotedRdnValue contains
        the quoted, escaped version of psUnquotedRdnValue. Otherwise,
        psQuotedRdnValue contains a copy of psUnquotedRdnValue. In either
        case, pcQuotedRdnValueLength contains the space utilized, in chars.

    ERROR_BUFFER_OVERFLOW
        psQuotedRdnValueLength contains the space needed, in chars,
        to hold psQuotedRdnValue.

    ERROR_INVALID_PARAMETER
        Invalid parameter.

    ERROR_NOT_ENOUGH_MEMORY
        Allocation error.

--*/

NTDSAPI
DWORD
WINAPI
DsQuoteRdnValueW(
    IN     DWORD    cUnquotedRdnValueLength,
    __in_ecount(cUnquotedRdnValueLength) IN     LPCWCH   psUnquotedRdnValue,
    IN OUT DWORD    *pcQuotedRdnValueLength,
    __out_ecount_part(*pcQuotedRdnValueLength, *pcQuotedRdnValueLength) OUT    LPWCH    psQuotedRdnValue
);

NTDSAPI
DWORD
WINAPI
DsQuoteRdnValueA(
    IN     DWORD    cUnquotedRdnValueLength,
    __in_ecount (cUnquotedRdnValueLength) IN     LPCCH    psUnquotedRdnValue,
    IN OUT DWORD    *pcQuotedRdnValueLength,
    __out_ecount_part (*pcQuotedRdnValueLength, *pcQuotedRdnValueLength) OUT    LPCH     psQuotedRdnValue
);

#ifdef UNICODE
#define DsQuoteRdnValue DsQuoteRdnValueW
#else
#define DsQuoteRdnValue DsQuoteRdnValueA
#endif

/*++
==========================================================
NTDSAPI
DWORD
WINAPI
DsUnquoteRdnValue(
    IN     DWORD    cQuotedRdnValueLength,
    IN     LPCTCH   psQuotedRdnValue,
    IN OUT DWORD    *pcUnquotedRdnValueLength,
    OUT    LPTCH    psUnquotedRdnValue
    )

Description

    This client call converts a quoted RDN Value into an unquoted RDN
    Value. The resultant RDN value should *NOT* be submitted as part
    of a DN to the DS using various APIs such as LDAP.

    When psQuotedRdnValue is quoted:
        The leading and trailing quote are removed.

        Whitespace before the first quote is discarded.

        Whitespace trailing the last quote is discarded.

        Escapes are removed and the char following the escape is kept.

    The following actions are taken when psQuotedRdnValue is unquoted:

        Leading whitespace is discarded.

        Trailing whitespace is kept.

        Escaped non-special chars return an error.

        Unescaped special chars return an error.

        RDN values beginning with # (ignoring leading whitespace) are
        treated as a stringized BER value and converted accordingly.

        Escaped hex digits (\89) are converted into a binary byte (0x89).

        Escapes are removed from escaped special chars.

    The following actions are always taken:
        Escaped special chars are unescaped.

    The input and output RDN values are not NULL terminated.

Arguments:

    cQuotedRdnValueLength - The length of psQuotedRdnValue in chars.

    psQuotedRdnValue - RDN value that may be quoted and may be escaped.

    pcUnquotedRdnValueLength - IN, maximum length of psUnquotedRdnValue, in chars
                          OUT ERROR_SUCCESS, chars used in psUnquotedRdnValue
                          OUT ERROR_BUFFER_OVERFLOW, chars needed for psUnquotedRdnValue

    psUnquotedRdnValue - The resultant unquoted RDN value.

Return Value:
    ERROR_SUCCESS
        psUnquotedRdnValue contains the unquoted and unescaped version
        of psQuotedRdnValue. pcUnquotedRdnValueLength contains the space
        used, in chars.

    ERROR_BUFFER_OVERFLOW
        psUnquotedRdnValueLength contains the space needed, in chars,
        to hold psUnquotedRdnValue.

    ERROR_INVALID_PARAMETER
        Invalid parameter.

    ERROR_NOT_ENOUGH_MEMORY
        Allocation error.

--*/

NTDSAPI
DWORD
WINAPI
DsUnquoteRdnValueW(
    IN     DWORD    cQuotedRdnValueLength,
    __in_ecount (cQuotedRdnValueLength) IN     LPCWCH   psQuotedRdnValue,
    IN OUT DWORD    *pcUnquotedRdnValueLength,
    __out_ecount_part (*pcUnquotedRdnValueLength, *pcUnquotedRdnValueLength) OUT    LPWCH    psUnquotedRdnValue
);

NTDSAPI
DWORD
WINAPI
DsUnquoteRdnValueA(
    IN     DWORD    cQuotedRdnValueLength,
    __in_ecount (cQuotedRdnValueLength) IN     LPCCH    psQuotedRdnValue,
    IN OUT DWORD    *pcUnquotedRdnValueLength,
    __out_ecount_part (*pcUnquotedRdnValueLength, *pcUnquotedRdnValueLength) OUT    LPCH     psUnquotedRdnValue
);

#ifdef UNICODE
#define DsUnquoteRdnValue DsUnquoteRdnValueW
#else
#define DsUnquoteRdnValue DsUnquoteRdnValueA
#endif

/*++
==========================================================
NTDSAPI
DWORD
WINAPI
DsGetRdnW(
    IN OUT LPCWCH   *ppDN,
    IN OUT DWORD    *pcDN,
    OUT    LPCWCH   *ppKey,
    OUT    DWORD    *pcKey,
    OUT    LPCWCH   *ppVal,
    OUT    DWORD    *pcVal
    )

Description

    This client call accepts a DN with quoted RDNs and returns the address
    and length, in chars, of the key and value for the first RDN in the DN.
    The RDN value returned is still quoted. Use DsUnquoteRdnValue to unquote
    the value for display.

    This client call also returns the address and length of the rest of the
    DN. A subsequent call using the returned DN address and length will
    return information about the next RDN.

    The following loop processes each RDN in pDN:
        ccDN = wcslen(pDN)
        while (ccDN) {
            error = DsGetRdn(&pDN,
                             &ccDN,
                             &pKey,
                             &ccKey,
                             &pVal,
                             &ccVal);
            if (error != ERROR_SUCCESS) {
                process error;
                return;
            }
            if (ccKey) {
                process pKey;
            }
            if (ccVal) {
                process pVal;
            }
        }

    For example, given the DN "cn=bob,dc=com", the first call to DsGetRdnW
    returns the addresses for ",dc=com", "cn", and "bob" with respective
    lengths of 7, 2, and 3. A subsequent call with ",dc=com" returns "",
    "dc", and "com" with respective lengths 0, 2, and 3.

Arguments:
    ppDN
        IN : *ppDN points to a DN
        OUT: *ppDN points to the rest of the DN following the first RDN
    pcDN
        IN : *pcDN is the count of chars in the input *ppDN, not including
             any terminating NULL
        OUT: *pcDN is the count of chars in the output *ppDN, not including
             any terminating NULL
    ppKey
        OUT: Undefined if *pcKey is 0. Otherwise, *ppKey points to the first
             key in the DN
    pcKey
        OUT: *pcKey is the count of chars in *ppKey.

    ppVal
        OUT: Undefined if *pcVal is 0. Otherwise, *ppVal points to the first
             value in the DN
    pcVal
        OUT: *pcVal is the count of chars in *ppVal

Return Value:
    ERROR_SUCCESS
        If *pccDN is not 0, then *ppDN points to the rest of the DN following
        the first RDN. If *pccDN is 0, then *ppDN is undefined.

        If *pccKey is not 0, then *ppKey points to the first key in DN. If
        *pccKey is 0, then *ppKey is undefined.

        If *pccVal is not 0, then *ppVal points to the first value in DN. If
        *pccVal is 0, then *ppVal is undefined.

    ERROR_DS_NAME_UNPARSEABLE
        The first RDN in *ppDN could not be parsed. All output parameters
        are undefined.

    Any other error
        All output parameters are undefined.

--*/
NTDSAPI
DWORD
WINAPI
DsGetRdnW(
    IN OUT LPCWCH   *ppDN,
    IN OUT DWORD    *pcDN,
    OUT    LPCWCH   *ppKey,
    OUT    DWORD    *pcKey,
    OUT    LPCWCH   *ppVal,
    OUT    DWORD    *pcVal
    );


/*++
==========================================================

NTDSAPI
BOOL
WINAPI
DsCrackUnquotedMangledRdnW(
     IN LPCWSTR pszRDN,
     IN DWORD cchRDN,
     OUT OPTIONAL GUID *pGuid,
     OUT OPTIONAL DS_MANGLE_FOR *peDsMangleFor
     );

Description

Determine whether the given RDN is in mangled form. If so, the mangled RDN
is decoded, and the guid and mangle type are returned.

The RDN should already be in unquoted form. See DsUnquoteRdnValue.

Arguments:

    pszRDN (IN) - Character string containing RDN. Termination is optional.

    cchRDN (IN) - Length of RDN excluding termination, if any

    pGuid (OUT, OPTIONAL) - Pointer to storage to receive decoded guid.
                            Only returned if RDN is mangled.

    peDsMangleFor (OUT, OPTIONAL) - Pointer to storage to receive mangle type.
                            Only returned if RDN is mangled

Return Value:

    BOOL - Whether the RDN is mangled or not

--*/

NTDSAPI
BOOL
WINAPI
DsCrackUnquotedMangledRdnW(
     IN LPCWSTR pszRDN,
     IN DWORD cchRDN,
     OUT OPTIONAL GUID *pGuid,
     OUT OPTIONAL DS_MANGLE_FOR *peDsMangleFor
     );

NTDSAPI
BOOL
WINAPI
DsCrackUnquotedMangledRdnA(
     IN LPCSTR pszRDN,
     IN DWORD cchRDN,
     OUT OPTIONAL GUID *pGuid,
     OUT OPTIONAL DS_MANGLE_FOR *peDsMangleFor
     );

#ifdef UNICODE
#define DsCrackUnquotedMangledRdn DsCrackUnquotedMangledRdnW
#else
#define DsCrackUnquotedMangledRdn DsCrackUnquotedMangledRdnA
#endif

/*++
==========================================================

NTDSAPI
BOOL
WINAPI
DsIsMangledRdnValueW(
    LPCWSTR pszRdn,
    DWORD cRdn,
    DS_MANGLE_FOR eDsMangleForDesired
    );

Description

    Determine if the given RDN Value is mangled, and of the given type. Note that
    the key portion of an RDN should not be supplied.

    The name may be quoted or unquoted.  This routine tries to unquote the value.  If
    the unquote operation fails, the routine proceeds to attempt the unmangle.

    A change was made in the default quoting behavior of DNs returned from the DS
    between Windows 2000 and Windows XP. This routine transparently handles RDNs with
    special characters in either form.

    The routine expects the value part of the RDN.

    If you have full DN, use DsIsMangledDn() below.

    To check for deleted name:
        DsIsMangledRdnValueW( rdn, rdnlen, DS_MANGLE_OBJECT_FOR_DELETION )
    To check for a conflicted name:
        DsIsMangledRdnValueW( rdn, rdnlen, DS_MANGLE_OBJECT_FOR_NAME_CONFLICT )

Arguments:

    pszRdn (IN) - RDN value character string. Termination is not required and
        is ignored.

    cRdn (IN) - Length of RDN value in characters excluding termination

    eDsMangleForDesired (IN) - Type of mangling to check for

Return Value:

    BOOL - True if the Rdn is mangled and is of the required type

--*/

NTDSAPI
BOOL
WINAPI
DsIsMangledRdnValueW(
    LPCWSTR pszRdn,
    DWORD cRdn,
    DS_MANGLE_FOR eDsMangleForDesired
    );

NTDSAPI
BOOL
WINAPI
DsIsMangledRdnValueA(
    LPCSTR pszRdn,
    DWORD cRdn,
    DS_MANGLE_FOR eDsMangleForDesired
    );

#ifdef UNICODE
#define DsIsMangledRdnValue DsIsMangledRdnValueW
#else
#define DsIsMangledRdnValue DsIsMangledRdnValueA
#endif

/*++
==========================================================

NTDSAPI
BOOL
WINAPI
DsIsMangledDnW(
    LPCWSTR pszDn,
    DS_MANGLE_FOR eDsMangleFor
    );

Description

    Determine if the first RDN in a quoted DN is a mangled name of given type.

    The DN must be suitable for input to DsGetRdn().

    To check for deleted name:
        DsIsMangledDnW( dn, DS_MANGLE_OBJECT_FOR_DELETION )
    To check for a conflicted name:
        DsIsMangledDnW( Dn, DS_MANGLE_OBJECT_FOR_NAME_CONFLICT )

Arguments:

    pszDn (IN) - Quoted Distinguished Name as returned by DS functions

    eDsMangleFor (IN) - Type of mangling to check for

Return Value:

    BOOL - True if first RDN is mangled and is of the given mangle type

--*/

NTDSAPI
BOOL
WINAPI
DsIsMangledDnA(
    LPCSTR pszDn,
    DS_MANGLE_FOR eDsMangleFor
    );

NTDSAPI
BOOL
WINAPI
DsIsMangledDnW(
    LPCWSTR pszDn,
    DS_MANGLE_FOR eDsMangleFor
    );

#ifdef UNICODE
#define DsIsMangledDn DsIsMangledDnW
#else
#define DsIsMangledDn DsIsMangledDnA
#endif

// -------------------------------------------------------------------------
// strings used by ADAM for constructing keywords values for SCP publication
// -------------------------------------------------------------------------

// Site name, e.g. "site:Default-First-Site-Name"
#define ADAM_SCP_SITE_NAME_STRING        "site:"
#define ADAM_SCP_SITE_NAME_STRING_W     L"site:"

// Partition DN, e.g. "partition:O=MSFT,L=WA,C=US"
#define ADAM_SCP_PARTITION_STRING        "partition:"
#define ADAM_SCP_PARTITION_STRING_W     L"partition:"

// Instance name, e.g. "instance:instance1"
#define ADAM_SCP_INSTANCE_NAME_STRING    "instance:"
#define ADAM_SCP_INSTANCE_NAME_STRING_W L"instance:"

// FSMO, e.g. "fsmo:naming"
#define ADAM_SCP_FSMO_STRING             "fsmo:"
#define ADAM_SCP_FSMO_STRING_W          L"fsmo:"

// FSMO values, e.g. "fsmo:naming"
#define ADAM_SCP_FSMO_NAMING_STRING      "naming"
#define ADAM_SCP_FSMO_NAMING_STRING_W   L"naming"

#define ADAM_SCP_FSMO_SCHEMA_STRING      "schema"
#define ADAM_SCP_FSMO_SCHEMA_STRING_W   L"schema"

// -------------------------------------------------------------------------
// ADAM repl authenticaion mode:  Stored as an attribute on the config NC.
// -------------------------------------------------------------------------

// Negotiate with pass-through authentication. All instances must run using
// service accounts with the same name and password.
#define ADAM_REPL_AUTHENTICATION_MODE_NEGOTIATE_PASS_THROUGH                0

// Negotiate authentication. If Kerberos is available, it will be used.
// Otherwise, authentication will fall back to NTLM (unless machine policy
// forbids this).
#define ADAM_REPL_AUTHENTICATION_MODE_NEGOTIATE                             1

// ADAM will require Kerberos mutual authentication.
#define ADAM_REPL_AUTHENTICATION_MODE_MUTUAL_AUTH_REQUIRED                  2



#ifdef __cplusplus
}
#endif
#endif !MIDL_PASS

#endif // _NTDSAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NtLdap.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    ntldap.h

Abstract:

   This is the header that defines NT specific server LDAP extensions.

Environments :

    Win32 user mode

--*/

#ifndef NT_LDAP_H
#define NT_LDAP_H

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
//
// Server controls section
//

//
// Force Update Control.  No Data.
//

#define LDAP_SERVER_FORCE_UPDATE_OID        "1.2.840.113556.1.4.1974"
#define LDAP_SERVER_FORCE_UPDATE_OID_W     L"1.2.840.113556.1.4.1974"


//
// Permissive Modify Control.  No Data.
//

#define LDAP_SERVER_PERMISSIVE_MODIFY_OID        "1.2.840.113556.1.4.1413"
#define LDAP_SERVER_PERMISSIVE_MODIFY_OID_W     L"1.2.840.113556.1.4.1413"


//
// Show Deleted Control.  No Data.
//

#define LDAP_SERVER_SHOW_DELETED_OID            "1.2.840.113556.1.4.417"
#define LDAP_SERVER_SHOW_DELETED_OID_W         L"1.2.840.113556.1.4.417"

//
// Cross Domain Move Control. Data as follows
//      SEQUENCE {
//          Name OCTET STRING
//      }
//

#define LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID    "1.2.840.113556.1.4.521"
#define LDAP_SERVER_CROSSDOM_MOVE_TARGET_OID_W L"1.2.840.113556.1.4.521"

//
// Notification. No Data.
//

#define LDAP_SERVER_NOTIFICATION_OID            "1.2.840.113556.1.4.528"
#define LDAP_SERVER_NOTIFICATION_OID_W         L"1.2.840.113556.1.4.528"

//
// Shutdown Notification. No Data.
//

#define LDAP_SERVER_SHUTDOWN_NOTIFY_OID          "1.2.840.113556.1.4.1907"
#define LDAP_SERVER_SHUTDOWN_NOTIFY_OID_W       L"1.2.840.113556.1.4.1907"
    
//
// Lazy Commit. No Data.
//

#define LDAP_SERVER_LAZY_COMMIT_OID             "1.2.840.113556.1.4.619"
#define LDAP_SERVER_LAZY_COMMIT_OID_W          L"1.2.840.113556.1.4.619"

//
// Security Descriptor Flag. Data as follows
//      SEQUENCE {
//          Flags INTEGER
//      }
//

#define LDAP_SERVER_SD_FLAGS_OID                "1.2.840.113556.1.4.801"
#define LDAP_SERVER_SD_FLAGS_OID_W             L"1.2.840.113556.1.4.801"

//
// Tree Delete. No Data.
//

#define LDAP_SERVER_TREE_DELETE_OID             "1.2.840.113556.1.4.805"
#define LDAP_SERVER_TREE_DELETE_OID_W          L"1.2.840.113556.1.4.805"


//
// Attribute Scoped Query Request:
// SEQUENCE {
//        controlType   1.2.840.113556.1.4.1504 
//        controlValue  string
//        criticality   TRUE
// }
//
// Attribute Scoped Query Response:
// SEQUENCE {
//      result   ENUMERATED {
//           success (0),
//           invalidAttributeSyntax  (21),
//           unwillingToPerform      (53),
//           affectsMultipleDSAs     (71), 
//      }
// }
//

#define LDAP_SERVER_ASQ_OID                     "1.2.840.113556.1.4.1504"
#define LDAP_SERVER_ASQ_OID_W                  L"1.2.840.113556.1.4.1504"



//
// DirSync operation. Data as follows
//      SEQUENCE {
//          Flags   INTEGER
//          Size    INTEGER
//          Cookie  OCTET STRING
//      }
//
// Flags are listed below.
//

#define LDAP_SERVER_DIRSYNC_OID                 "1.2.840.113556.1.4.841"
#define LDAP_SERVER_DIRSYNC_OID_W              L"1.2.840.113556.1.4.841"

//
// Return extended DNs according to the requested format.  Optional data as
// follows
//      SEQUENCE {
//          Option  INTEGER
//      }
//
//  Option values:
//      0:  DN preceded by GUID and SID (if any) in hex string format
//      1:  DN preceded by GUID and SID (if any) in standard string format
//
//  If no data is provided then option 0 is selected for backwards compat.
//

#define LDAP_SERVER_EXTENDED_DN_OID             "1.2.840.113556.1.4.529"
#define LDAP_SERVER_EXTENDED_DN_OID_W          L"1.2.840.113556.1.4.529"

//
// Tell DC which server to verify with that a DN exist. Data as follows
//      SEQUENCE {
//          Flags   INTEGER,
//          ServerName OCTET STRING     // unicode server string
//      }
//

#define LDAP_SERVER_VERIFY_NAME_OID             "1.2.840.113556.1.4.1338"
#define LDAP_SERVER_VERIFY_NAME_OID_W          L"1.2.840.113556.1.4.1338"

//
// Tells server not to generate referrals
//

#define LDAP_SERVER_DOMAIN_SCOPE_OID            "1.2.840.113556.1.4.1339"
#define LDAP_SERVER_DOMAIN_SCOPE_OID_W         L"1.2.840.113556.1.4.1339"

//
// Server Search Options. Allows the client to pass in flags to control
// various search behaviours. Data as follows
//      SEQUENCE {
//          Flags   INTEGER
//      }
//

#define LDAP_SERVER_SEARCH_OPTIONS_OID          "1.2.840.113556.1.4.1340"
#define LDAP_SERVER_SEARCH_OPTIONS_OID_W       L"1.2.840.113556.1.4.1340"

//
// search option flags
//

#define SERVER_SEARCH_FLAG_DOMAIN_SCOPE         0x1 // no referrals generated
#define SERVER_SEARCH_FLAG_PHANTOM_ROOT         0x2 // search all NCs subordinate
                                                    // to search base

//
// This control is used to pass the sid of a security principle
// who's quota is being queried
//      SEQUENCE {
//          QuerySid OCTET STRING     // sid of security principle
//      }
//

#define LDAP_SERVER_QUOTA_CONTROL_OID           "1.2.840.113556.1.4.1852"
#define LDAP_SERVER_QUOTA_CONTROL_OID_W        L"1.2.840.113556.1.4.1852"

//
// Copy control
//      SEQUENCE {
//          Flags INTEGER
//      }
//
#define LDAP_SERVER_COPY_CONTROL_OID            "1.2.840.113556.1.4.1919"
#define LDAP_SERVER_COPY_CONTROL_OID_W          L"1.2.840.113556.1.4.1919"

//
// Copy control flags
//

#define LDAP_SERVER_COPY_CONTROL_USE_COPY 0
#define LDAP_SERVER_COPY_CONTROL_DONT_USE_COPY 1

//
// Range retrieval no error
// No control data

#define LDAP_SERVER_RANGE_RETRIEVAL_NOERR_OID       "1.2.840.113556.1.4.1948"
#define LDAP_SERVER_RANGE_RETRIEVAL_NOERR_OID_W    L"1.2.840.113556.1.4.1948"


//
// DN input control: This control is used to pass a DN as an input
//                          for a LDAP operation
//      SEQUENCE {
//          InputDN OCTET STRING     //
//      }
//
#define LDAP_SERVER_DN_INPUT_OID       "1.2.840.113556.1.4.2026"
#define LDAP_SERVER_DN_INPUT_OID_W    L"1.2.840.113556.1.4.2026"

//
// End of Server controls
//

//
//
// Operational Attributes
//

#define LDAP_OPATT_BECOME_DOM_MASTER            "becomeDomainMaster"
#define LDAP_OPATT_BECOME_DOM_MASTER_W          L"becomeDomainMaster"

#define LDAP_OPATT_BECOME_RID_MASTER            "becomeRidMaster"
#define LDAP_OPATT_BECOME_RID_MASTER_W          L"becomeRidMaster"

#define LDAP_OPATT_BECOME_SCHEMA_MASTER         "becomeSchemaMaster"
#define LDAP_OPATT_BECOME_SCHEMA_MASTER_W       L"becomeSchemaMaster"

#define LDAP_OPATT_RECALC_HIERARCHY             "recalcHierarchy"
#define LDAP_OPATT_RECALC_HIERARCHY_W           L"recalcHierarchy"

#define LDAP_OPATT_SCHEMA_UPDATE_NOW            "schemaUpdateNow"
#define LDAP_OPATT_SCHEMA_UPDATE_NOW_W          L"schemaUpdateNow"

#define LDAP_OPATT_BECOME_PDC                   "becomePdc"
#define LDAP_OPATT_BECOME_PDC_W                 L"becomePdc"

#define LDAP_OPATT_FIXUP_INHERITANCE            "fixupInheritance"
#define LDAP_OPATT_FIXUP_INHERITANCE_W          L"fixupInheritance"

#define LDAP_OPATT_INVALIDATE_RID_POOL          "invalidateRidPool"
#define LDAP_OPATT_INVALIDATE_RID_POOL_W        L"invalidateRidPool"

#define LDAP_OPATT_ABANDON_REPL                 "abandonReplication"
#define LDAP_OPATT_ABANDON_REPL_W               L"abandonReplication"

#define LDAP_OPATT_DO_GARBAGE_COLLECTION        "doGarbageCollection"
#define LDAP_OPATT_DO_GARBAGE_COLLECTION_W      L"doGarbageCollection"

//
//  Root DSE Attributes
//

#define LDAP_OPATT_SUBSCHEMA_SUBENTRY           "subschemaSubentry"
#define LDAP_OPATT_SUBSCHEMA_SUBENTRY_W         L"subschemaSubentry"

#define LDAP_OPATT_CURRENT_TIME                 "currentTime"
#define LDAP_OPATT_CURRENT_TIME_W               L"currentTime"

#define LDAP_OPATT_SERVER_NAME                  "serverName"
#define LDAP_OPATT_SERVER_NAME_W                L"serverName"

#define LDAP_OPATT_NAMING_CONTEXTS              "namingContexts"
#define LDAP_OPATT_NAMING_CONTEXTS_W            L"namingContexts"

#define LDAP_OPATT_DEFAULT_NAMING_CONTEXT       "defaultNamingContext"
#define LDAP_OPATT_DEFAULT_NAMING_CONTEXT_W     L"defaultNamingContext"

#define LDAP_OPATT_SUPPORTED_CONTROL            "supportedControl"
#define LDAP_OPATT_SUPPORTED_CONTROL_W          L"supportedControl"

#define LDAP_OPATT_HIGHEST_COMMITTED_USN        "highestCommitedUSN"
#define LDAP_OPATT_HIGHEST_COMMITTED_USN_W      L"highestCommitedUSN"

#define LDAP_OPATT_SUPPORTED_LDAP_VERSION       "supportedLDAPVersion"
#define LDAP_OPATT_SUPPORTED_LDAP_VERSION_W     L"supportedLDAPVersion"

#define LDAP_OPATT_SUPPORTED_LDAP_POLICIES      "supportedLDAPPolicies"
#define LDAP_OPATT_SUPPORTED_LDAP_POLICIES_W    L"supportedLDAPPolicies"

#define LDAP_OPATT_SCHEMA_NAMING_CONTEXT        "schemaNamingContext"
#define LDAP_OPATT_SCHEMA_NAMING_CONTEXT_W      L"schemaNamingContext"

#define LDAP_OPATT_CONFIG_NAMING_CONTEXT        "configurationNamingContext"
#define LDAP_OPATT_CONFIG_NAMING_CONTEXT_W      L"configurationNamingContext"

#define LDAP_OPATT_ROOT_DOMAIN_NAMING_CONTEXT   "rootDomainNamingContext"
#define LDAP_OPATT_ROOT_DOMAIN_NAMING_CONTEXT_W L"rootDomainNamingContext"

#define LDAP_OPATT_SUPPORTED_SASL_MECHANISM     "supportedSASLMechanisms"
#define LDAP_OPATT_SUPPORTED_SASL_MECHANISM_W   L"supportedSASLMechanisms"

#define LDAP_OPATT_DNS_HOST_NAME                "dnsHostName"
#define LDAP_OPATT_DNS_HOST_NAME_W              L"dnsHostName"

#define LDAP_OPATT_LDAP_SERVICE_NAME            "ldapServiceName"
#define LDAP_OPATT_LDAP_SERVICE_NAME_W          L"ldapServiceName"

#define LDAP_OPATT_DS_SERVICE_NAME              "dsServiceName"
#define LDAP_OPATT_DS_SERVICE_NAME_W            L"dsServiceName"

#define LDAP_OPATT_SUPPORTED_CAPABILITIES       "supportedCapabilities"
#define LDAP_OPATT_SUPPORTED_CAPABILITIES_W     L"supportedCapabilities"

//
// End of Operational attributes
//



//
//
// Server Capabilities
//

//
// NT5 Active Directory
//

#define LDAP_CAP_ACTIVE_DIRECTORY_OID          "1.2.840.113556.1.4.800"
#define LDAP_CAP_ACTIVE_DIRECTORY_OID_W        L"1.2.840.113556.1.4.800"

#define LDAP_CAP_ACTIVE_DIRECTORY_V51_OID      "1.2.840.113556.1.4.1670"
#define LDAP_CAP_ACTIVE_DIRECTORY_V51_OID_W    L"1.2.840.113556.1.4.1670"

#define LDAP_CAP_ACTIVE_DIRECTORY_LDAP_INTEG_OID   "1.2.840.113556.1.4.1791"
#define LDAP_CAP_ACTIVE_DIRECTORY_LDAP_INTEG_OID_W L"1.2.840.113556.1.4.1791"

#define LDAP_CAP_ACTIVE_DIRECTORY_ADAM_OID   "1.2.840.113556.1.4.1851"
#define LDAP_CAP_ACTIVE_DIRECTORY_ADAM_OID_W L"1.2.840.113556.1.4.1851"

#define LDAP_CAP_ACTIVE_DIRECTORY_PARTIAL_SECRETS_OID "1.2.840.113556.1.4.1920"
#define LDAP_CAP_ACTIVE_DIRECTORY_PARTIAL_SECRETS_OID_W L"1.2.840.113556.1.4.1920"

#define LDAP_CAP_ACTIVE_DIRECTORY_V61_OID    "1.2.840.113556.1.4.1935"
#define LDAP_CAP_ACTIVE_DIRECTORY_V61_OID_W L"1.2.840.113556.1.4.1935"

//
//  End of capabilities
//


//
//
// Matching Rules
//

//
// BIT AND
//

#define LDAP_MATCHING_RULE_BIT_AND              "1.2.840.113556.1.4.803"
#define LDAP_MATCHING_RULE_BIT_AND_W            L"1.2.840.113556.1.4.803"

//
// BIT OR
//

#define LDAP_MATCHING_RULE_BIT_OR               "1.2.840.113556.1.4.804"
#define LDAP_MATCHING_RULE_BIT_OR_W             L"1.2.840.113556.1.4.804"


//
//
// Extended Requests
//

//
// Fast bind mode.
//

#define LDAP_SERVER_FAST_BIND_OID               "1.2.840.113556.1.4.1781"
#define LDAP_SERVER_FAST_BIND_OID_W             L"1.2.840.113556.1.4.1781"

//
// WhoAmI extended request
//

#define LDAP_SERVER_WHO_AM_I_OID                "1.3.6.1.4.1.4203.1.11.3"
#define LDAP_SERVER_WHO_AM_I_OID_W              L"1.3.6.1.4.1.4203.1.11.3"

//
// DirSync flags
//

// Without this flag, the caller must have the replicate changes right. With this flag,
// the caller needs no rights, but is only allowed to see objects and attributes
// which are accessible to them.
#define LDAP_DIRSYNC_OBJECT_SECURITY             (0x1)

// Return parents before children, when parents would otherwise appear later
// in the replication stream.
#define LDAP_DIRSYNC_ANCESTORS_FIRST_ORDER    (0x0800)

// Do not return secret data. Always on by default.
#define LDAP_DIRSYNC_PUBLIC_DATA_ONLY         (0x2000)

// Without this flag, all the values (up to a limit) in a multi-valued attribute are
// returned when any value changes. With this flag, only the changed values are returned.
#define LDAP_DIRSYNC_INCREMENTAL_VALUES   (0x80000000)

// Do not return filtered attributes.  On by default, unless the caller asks
// for these attributes specifically.
#define LDAP_DIRSYNC_ROPAS_DATA_ONLY         (0x40000000)

#ifdef __cplusplus
}
#endif

#endif  // NT_LDAP_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NTSDExts.h ===
/*

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntsdexts.h

Abstract:

    This file contains procedure prototypes and structures
    needed to write old NTSD and KD debugger extensions.

    NOTE:  Newer defitions and interfaces are in wdbgexts.h

Environment:

    runs in the Win32 NTSD debug environment.

Revision History:

--*/

#ifndef _NTSDEXTNS_
#define _NTSDEXTNS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef
VOID
(__cdecl *PNTSD_OUTPUT_ROUTINE)(
    char *,
    ...
    );

typedef
ULONG_PTR
(*PNTSD_GET_EXPRESSION)(
    char *
    );

typedef
VOID
(*PNTSD_GET_SYMBOL)(
    ULONG_PTR offset,
    PUCHAR pchBuffer,
    ULONG_PTR *pDisplacement
    );

typedef
DWORD
(*PNTSD_DISASM)(
    ULONG_PTR *lpOffset,
    LPSTR lpBuffer,
    ULONG fShowEfeectiveAddress
    );

typedef
BOOL
(*PNTSD_CHECK_CONTROL_C)(
    VOID
    );

typedef struct _NTSD_EXTENSION_APIS {
    DWORD nSize;
    PNTSD_OUTPUT_ROUTINE lpOutputRoutine;
    PNTSD_GET_EXPRESSION lpGetExpressionRoutine;
    PNTSD_GET_SYMBOL lpGetSymbolRoutine;
    PNTSD_DISASM lpDisasmRoutine;
    PNTSD_CHECK_CONTROL_C lpCheckControlCRoutine;
} NTSD_EXTENSION_APIS, *PNTSD_EXTENSION_APIS;

typedef
VOID
(*PNTSD_EXTENSION_ROUTINE)(
    HANDLE hCurrentProcess,
    HANDLE hCurrentThread,
    DWORD dwCurrentPc,
    PNTSD_EXTENSION_APIS lpExtensionApis,
    LPSTR lpArgumentString
    );

#ifdef __cplusplus
}
#endif


#endif // _NTSDEXTNS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntiologc.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntiologc.h

Abstract:

    Constant definitions for the I/O error code log values.

Author:

Revision History:

--*/

#ifndef _NTIOLOGC_
#define _NTIOLOGC_

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-------------------------+-------------------------------+
//  |Sev|C|       Facility          |               Code            |
//  +---+-+-------------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_RPC_STUBS               0x3
#define FACILITY_RPC_RUNTIME             0x2
#define FACILITY_MCA_ERROR_CODE          0x5
#define FACILITY_IO_ERROR_CODE           0x4


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: IO_ERR_RETRY_SUCCEEDED
//
// MessageText:
//
// A retry was successful on %1.
//
#define IO_ERR_RETRY_SUCCEEDED           ((NTSTATUS)0x00040001L)

//
// MessageId: IO_ERR_INSUFFICIENT_RESOURCES
//
// MessageText:
//
// The driver could not allocate something necessary for the request for %1.
//
#define IO_ERR_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC0040002L)

//
// MessageId: IO_ERR_CONFIGURATION_ERROR
//
// MessageText:
//
// Driver or device is incorrectly configured for %1.
//
#define IO_ERR_CONFIGURATION_ERROR       ((NTSTATUS)0xC0040003L)

//
// MessageId: IO_ERR_DRIVER_ERROR
//
// MessageText:
//
// Driver detected an internal error in its data structures for %1.
//
#define IO_ERR_DRIVER_ERROR              ((NTSTATUS)0xC0040004L)

//
// MessageId: IO_ERR_PARITY
//
// MessageText:
//
// A parity error was detected on %1.
//
#define IO_ERR_PARITY                    ((NTSTATUS)0xC0040005L)

//
// MessageId: IO_ERR_SEEK_ERROR
//
// MessageText:
//
// The device, %1, had a seek error.
//
#define IO_ERR_SEEK_ERROR                ((NTSTATUS)0xC0040006L)

//
// MessageId: IO_ERR_BAD_BLOCK
//
// MessageText:
//
// The device, %1, has a bad block.
//
#define IO_ERR_BAD_BLOCK                 ((NTSTATUS)0xC0040007L)

//
// MessageId: IO_ERR_OVERRUN_ERROR
//
// MessageText:
//
// An overrun occurred on %1.
//
#define IO_ERR_OVERRUN_ERROR             ((NTSTATUS)0xC0040008L)

//
// MessageId: IO_ERR_TIMEOUT
//
// MessageText:
//
// The device, %1, did not respond within the timeout period.
//
#define IO_ERR_TIMEOUT                   ((NTSTATUS)0xC0040009L)

//
// MessageId: IO_ERR_SEQUENCE
//
// MessageText:
//
// The driver detected an unexpected sequence by the device, %1.
//
#define IO_ERR_SEQUENCE                  ((NTSTATUS)0xC004000AL)

//
// MessageId: IO_ERR_CONTROLLER_ERROR
//
// MessageText:
//
// The driver detected a controller error on %1.
//
#define IO_ERR_CONTROLLER_ERROR          ((NTSTATUS)0xC004000BL)

//
// MessageId: IO_ERR_INTERNAL_ERROR
//
// MessageText:
//
// The driver detected an internal driver error on %1.
//
#define IO_ERR_INTERNAL_ERROR            ((NTSTATUS)0xC004000CL)

//
// MessageId: IO_ERR_INCORRECT_IRQL
//
// MessageText:
//
// The driver was configured with an incorrect interrupt for %1.
//
#define IO_ERR_INCORRECT_IRQL            ((NTSTATUS)0xC004000DL)

//
// MessageId: IO_ERR_INVALID_IOBASE
//
// MessageText:
//
// The driver was configured with an invalid I/O base address for %1.
//
#define IO_ERR_INVALID_IOBASE            ((NTSTATUS)0xC004000EL)

//
// MessageId: IO_ERR_NOT_READY
//
// MessageText:
//
// The device, %1, is not ready for access yet.
//
#define IO_ERR_NOT_READY                 ((NTSTATUS)0xC004000FL)

//
// MessageId: IO_ERR_INVALID_REQUEST
//
// MessageText:
//
// The request is incorrectly formatted for %1.
//
#define IO_ERR_INVALID_REQUEST           ((NTSTATUS)0xC0040010L)

//
// MessageId: IO_ERR_VERSION
//
// MessageText:
//
// The wrong version of the driver has been loaded.
//
#define IO_ERR_VERSION                   ((NTSTATUS)0xC0040011L)

//
// MessageId: IO_ERR_LAYERED_FAILURE
//
// MessageText:
//
// The driver beneath this one has failed in some way for %1.
//
#define IO_ERR_LAYERED_FAILURE           ((NTSTATUS)0xC0040012L)

//
// MessageId: IO_ERR_RESET
//
// MessageText:
//
// The device, %1, has been reset.
//
#define IO_ERR_RESET                     ((NTSTATUS)0xC0040013L)

//
// MessageId: IO_ERR_PROTOCOL
//
// MessageText:
//
// A transport driver received a frame which violated the protocol.
//
#define IO_ERR_PROTOCOL                  ((NTSTATUS)0xC0040014L)

//
// MessageId: IO_ERR_MEMORY_CONFLICT_DETECTED
//
// MessageText:
//
// A conflict has been detected between two drivers which claimed two overlapping
// memory regions.
// Driver %2, with device <%3>, claimed a memory range with starting address
// in data address 0x28 and 0x2c, and length in data address 0x30.
//
#define IO_ERR_MEMORY_CONFLICT_DETECTED  ((NTSTATUS)0xC0040015L)

//
// MessageId: IO_ERR_PORT_CONFLICT_DETECTED
//
// MessageText:
//
// A conflict has been detected between two drivers which claimed two overlapping
// Io port regions.
// Driver %2, with device <%3>, claimed an IO port range with starting address
// in data address 0x28 and 0x2c, and length in data address 0x30.
//
#define IO_ERR_PORT_CONFLICT_DETECTED    ((NTSTATUS)0xC0040016L)

//
// MessageId: IO_ERR_DMA_CONFLICT_DETECTED
//
// MessageText:
//
// A conflict has been detected between two drivers which claimed equivalent DMA
// channels.
// Driver %2, with device <%3>, claimed the DMA Channel in data address 0x28, with
// optinal port in data address 0x2c.
//
#define IO_ERR_DMA_CONFLICT_DETECTED     ((NTSTATUS)0xC0040017L)

//
// MessageId: IO_ERR_IRQ_CONFLICT_DETECTED
//
// MessageText:
//
// A conflict has been detected between two drivers which claimed equivalent IRQs.
// Driver %2, with device <%3>, claimed an interrupt with Level in data address
// 0x28, vector in data address 0x2c and Affinity in data address 0x30.
//
#define IO_ERR_IRQ_CONFLICT_DETECTED     ((NTSTATUS)0xC0040018L)

//
// MessageId: IO_ERR_BAD_FIRMWARE
//
// MessageText:
//
// The driver has detected a device with old or out-of-date firmware.  The
// device will not be used.
//
#define IO_ERR_BAD_FIRMWARE              ((NTSTATUS)0xC0040019L)

//
// MessageId: IO_WRN_BAD_FIRMWARE
//
// MessageText:
//
// The driver has detected that device %1 has old or out-of-date firmware.
// Reduced performance may result.
//
#define IO_WRN_BAD_FIRMWARE              ((NTSTATUS)0x8004001AL)

//
// MessageId: IO_ERR_DMA_RESOURCE_CONFLICT
//
// MessageText:
//
// The device could not allocate one or more required resources due to conflicts
// with other devices.  The device DMA setting of '%2' could not be
// satisified due to a conflict with Driver '%3'.
//
#define IO_ERR_DMA_RESOURCE_CONFLICT     ((NTSTATUS)0xC004001BL)

//
// MessageId: IO_ERR_INTERRUPT_RESOURCE_CONFLICT
//
// MessageText:
//
// The device could not allocate one or more required resources due to conflicts
// with other devices.  The device interrupt setting of '%2' could not be
// satisified due to a conflict with Driver '%3'.
//
#define IO_ERR_INTERRUPT_RESOURCE_CONFLICT ((NTSTATUS)0xC004001CL)

//
// MessageId: IO_ERR_MEMORY_RESOURCE_CONFLICT
//
// MessageText:
//
// The device could not allocate one or more required resources due to conflicts
// with other devices.  The device memory setting of '%2' could not be
// satisified due to a conflict with Driver '%3'.
//
#define IO_ERR_MEMORY_RESOURCE_CONFLICT  ((NTSTATUS)0xC004001DL)

//
// MessageId: IO_ERR_PORT_RESOURCE_CONFLICT
//
// MessageText:
//
// The device could not allocate one or more required resources due to conflicts
// with other devices.  The device port setting of '%2' could not be
// satisified due to a conflict with Driver '%3'.
//
#define IO_ERR_PORT_RESOURCE_CONFLICT    ((NTSTATUS)0xC004001EL)

//
// MessageId: IO_BAD_BLOCK_WITH_NAME
//
// MessageText:
//
// The file %2 on device %1 contains a bad disk block.
//
#define IO_BAD_BLOCK_WITH_NAME           ((NTSTATUS)0xC004001FL)

//
// MessageId: IO_WRITE_CACHE_ENABLED
//
// MessageText:
//
// The driver detected that the device %1 has its write cache enabled. Data corruption
// may occur.
//
#define IO_WRITE_CACHE_ENABLED           ((NTSTATUS)0x80040020L)

//
// MessageId: IO_RECOVERED_VIA_ECC
//
// MessageText:
//
// Data was recovered using error correction code on device %1.
//
#define IO_RECOVERED_VIA_ECC             ((NTSTATUS)0x80040021L)

//
// MessageId: IO_WRITE_CACHE_DISABLED
//
// MessageText:
//
// The driver disabled the write cache on device %1.
//
#define IO_WRITE_CACHE_DISABLED          ((NTSTATUS)0x80040022L)

//
// MessageId: IO_FILE_QUOTA_THRESHOLD
//
// MessageText:
//
// A user hit their quota threshold on volume %2.
//
#define IO_FILE_QUOTA_THRESHOLD          ((NTSTATUS)0x40040024L)

//
// MessageId: IO_FILE_QUOTA_LIMIT
//
// MessageText:
//
// A user hit their quota limit on volume %2.
//
#define IO_FILE_QUOTA_LIMIT              ((NTSTATUS)0x40040025L)

//
// MessageId: IO_FILE_QUOTA_STARTED
//
// MessageText:
//
// The system has started rebuilding the user disk quota information on
// device %1 with label "%2".
//
#define IO_FILE_QUOTA_STARTED            ((NTSTATUS)0x40040026L)

//
// MessageId: IO_FILE_QUOTA_SUCCEEDED
//
// MessageText:
//
// The system has successfully rebuilt the user disk quota information on
// device %1 with label "%2".
//
#define IO_FILE_QUOTA_SUCCEEDED          ((NTSTATUS)0x40040027L)

//
// MessageId: IO_FILE_QUOTA_FAILED
//
// MessageText:
//
// The system has encounted an error rebuilding the user disk quota
// information on device %1 with label "%2".
//
#define IO_FILE_QUOTA_FAILED             ((NTSTATUS)0x80040028L)

//
// MessageId: IO_FILE_SYSTEM_CORRUPT
//
// MessageText:
//
// The file system structure on the disk is corrupt and unusable.
// Please run the chkdsk utility on the device %1 with label "%2".
//
#define IO_FILE_SYSTEM_CORRUPT           ((NTSTATUS)0xC0040029L)

//
// MessageId: IO_FILE_QUOTA_CORRUPT
//
// MessageText:
//
// The user disk quota information is unusable.
// To ensure accuracy, the file system quota information on the device %1 with label "%2" will
// be rebuilt.
//
#define IO_FILE_QUOTA_CORRUPT            ((NTSTATUS)0xC004002AL)

//
// MessageId: IO_SYSTEM_SLEEP_FAILED
//
// MessageText:
//
// The system sleep operation failed
//
#define IO_SYSTEM_SLEEP_FAILED           ((NTSTATUS)0xC004002BL)

//
// MessageId: IO_DUMP_POINTER_FAILURE
//
// MessageText:
//
// The system could not get file retrieval pointers for the dump file.
//
#define IO_DUMP_POINTER_FAILURE          ((NTSTATUS)0xC004002CL)

//
// MessageId: IO_DUMP_DRIVER_LOAD_FAILURE
//
// MessageText:
//
// The system could not sucessfully load the crash dump driver.
//
#define IO_DUMP_DRIVER_LOAD_FAILURE      ((NTSTATUS)0xC004002DL)

//
// MessageId: IO_DUMP_INITIALIZATION_FAILURE
//
// MessageText:
//
// Crash dump initialization failed!
//
#define IO_DUMP_INITIALIZATION_FAILURE   ((NTSTATUS)0xC004002EL)

//
// MessageId: IO_DUMP_DUMPFILE_CONFLICT
//
// MessageText:
//
// A valid crash dump was found in the paging file while trying to configure
// a direct dump. Direct dump is disabled! This occurs when the direct dump
// option is set in the registry but a stop error occured before configuration
// completed
//
#define IO_DUMP_DUMPFILE_CONFLICT        ((NTSTATUS)0xC004002FL)

//
// MessageId: IO_DUMP_DIRECT_CONFIG_FAILED
//
// MessageText:
//
// Direct dump configuration failed. Validate the filename and make sure the target device
// is not a Fault Tolerant set member, remote, or floppy device. The failure may
// be because there is not enough room on the dump device to create the dump file.
//
#define IO_DUMP_DIRECT_CONFIG_FAILED     ((NTSTATUS)0xC0040030L)

//
// MessageId: IO_DUMP_PAGE_CONFIG_FAILED
//
// MessageText:
//
// Configuring the Page file for crash dump failed. Make sure there is a page
// file on the boot partition and that is large enough to contain all physical
// memory.
//
#define IO_DUMP_PAGE_CONFIG_FAILED       ((NTSTATUS)0xC0040031L)

//
// MessageId: IO_LOST_DELAYED_WRITE
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %2. The data has been lost.
// This error may be caused by a failure of your computer hardware or network connection. Please try to save this file elsewhere.
//
#define IO_LOST_DELAYED_WRITE            ((NTSTATUS)0x80040032L)

//
// MessageId: IO_WARNING_PAGING_FAILURE
//
// MessageText:
//
// An error was detected on device %1 during a paging operation.
//
#define IO_WARNING_PAGING_FAILURE        ((NTSTATUS)0x80040033L)

//
// MessageId: IO_WRN_FAILURE_PREDICTED
//
// MessageText:
//
// The driver has detected that device %1 has predicted that it will fail.
// Immediately back up your data and replace your hard disk drive. A failure
// may be imminent.
//
#define IO_WRN_FAILURE_PREDICTED         ((NTSTATUS)0x80040034L)

//
// MessageId: IO_WARNING_INTERRUPT_STILL_PENDING
//
// MessageText:
//
// A pending interrupt was detected on device %1 during a timeout operation.  A
// large number of these warnings may indicate that the system is not correctly
// receiving or processing interrupts from the device.
//
#define IO_WARNING_INTERRUPT_STILL_PENDING ((NTSTATUS)0x80040035L)

//
// MessageId: IO_DRIVER_CANCEL_TIMEOUT
//
// MessageText:
//
// An Io Request to the device %1 did not complete or canceled within the
// specific timeout. This can occur if the device driver does not set a
// cancel routine for a given IO request packet.
//
#define IO_DRIVER_CANCEL_TIMEOUT         ((NTSTATUS)0x80040036L)

//
// MessageId: IO_FILE_SYSTEM_CORRUPT_WITH_NAME
//
// MessageText:
//
// The file system structure on the disk is corrupt and unusable.
// Please run the chkdsk utility on the volume %2.
//
#define IO_FILE_SYSTEM_CORRUPT_WITH_NAME ((NTSTATUS)0xC0040037L)

//
// MessageId: IO_WARNING_ALLOCATION_FAILED
//
// MessageText:
//
// The driver failed to allocate memory.
//
#define IO_WARNING_ALLOCATION_FAILED     ((NTSTATUS)0x80040038L)

//
// MessageId: IO_WARNING_LOG_FLUSH_FAILED
//
// MessageText:
//
// The system failed to flush data to the transaction log. Corruption may occur.
//
#define IO_WARNING_LOG_FLUSH_FAILED      ((NTSTATUS)0x80040039L)

//
// MessageId: IO_WARNING_DUPLICATE_SIGNATURE
//
// MessageText:
//
// Changing the disk signature of disk %2 because it is equal to the disk
// signature of disk %3.
//
#define IO_WARNING_DUPLICATE_SIGNATURE   ((NTSTATUS)0x8004003AL)

//
// MessageId: IO_WARNING_DUPLICATE_PATH
//
// MessageText:
//
// Disk %2 will not be used because it is a redundant path for disk %3.
//
#define IO_WARNING_DUPLICATE_PATH        ((NTSTATUS)0x8004003BL)

//
// MessageId: MCA_WARNING_CACHE
//
// MessageText:
//
// Machine Check Event reported is a corrected level %3 Cache error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_CACHE                ((NTSTATUS)0x8005003CL)

//
// MessageId: MCA_ERROR_CACHE
//
// MessageText:
//
// Machine Check Event reported is a fatal level %3 Cache error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_CACHE                  ((NTSTATUS)0xC005003DL)

//
// MessageId: MCA_WARNING_TLB
//
// MessageText:
//
// Machine Check Event reported is a corrected level %3 translation Buffer error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_TLB                  ((NTSTATUS)0x8005003EL)

//
// MessageId: MCA_ERROR_TLB
//
// MessageText:
//
// Machine Check Event reported is a fatal level %3 translation Buffer error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_TLB                    ((NTSTATUS)0xC005003FL)

//
// MessageId: MCA_WARNING_CPU_BUS
//
// MessageText:
//
// Machine Check Event reported is a corrected External/Internal bus error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_CPU_BUS              ((NTSTATUS)0x80050040L)

//
// MessageId: MCA_ERROR_CPU_BUS
//
// MessageText:
//
// Machine Check Event reported is a fatal External/Internal bus error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_CPU_BUS                ((NTSTATUS)0xC0050041L)

//
// MessageId: MCA_WARNING_REGISTER_FILE
//
// MessageText:
//
// Machine Check Event reported is a corrected internal CPU register access error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_REGISTER_FILE        ((NTSTATUS)0x80050042L)

//
// MessageId: MCA_ERROR_REGISTER_FILE
//
// MessageText:
//
// Machine Check Event reported is a fatal internal CPU register access error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_REGISTER_FILE          ((NTSTATUS)0xC0050043L)

//
// MessageId: MCA_WARNING_MAS
//
// MessageText:
//
// Machine Check Event reported is a corrected Micro Architecture Structure error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_MAS                  ((NTSTATUS)0x80050044L)

//
// MessageId: MCA_ERROR_MAS
//
// MessageText:
//
// Machine Check Event reported is a fatal Micro Architecture Structure error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_MAS                    ((NTSTATUS)0xC0050045L)

//
// MessageId: MCA_WARNING_MEM_UNKNOWN
//
// MessageText:
//
// Machine Check Event reported is a corrected ECC memory error at an unknown physical address reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_MEM_UNKNOWN          ((NTSTATUS)0x80050046L)

//
// MessageId: MCA_ERROR_MEM_UNKNOWN
//
// MessageText:
//
// Machine Check Event reported is a fatal ECC memory error at an unknown physical address reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_MEM_UNKNOWN            ((NTSTATUS)0xC0050047L)

//
// MessageId: MCA_WARNING_MEM_1_2
//
// MessageText:
//
// Machine Check Event reported is a corrected ECC memory error at physical address %3 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_MEM_1_2              ((NTSTATUS)0x80050048L)

//
// MessageId: MCA_ERROR_MEM_1_2
//
// MessageText:
//
// Machine Check Event reported is a fatal ECC memory error at physical address %3 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_MEM_1_2                ((NTSTATUS)0xC0050049L)

//
// MessageId: MCA_WARNING_MEM_1_2_5
//
// MessageText:
//
// Machine Check Event reported is a corrected ECC memory error at physical address %3 on memory module %4 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_MEM_1_2_5            ((NTSTATUS)0x8005004AL)

//
// MessageId: MCA_ERROR_MEM_1_2_5
//
// MessageText:
//
// Machine Check Event reported is a fatal ECC memory error at physical address %3 on memory module %4 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_MEM_1_2_5              ((NTSTATUS)0xC005004BL)

//
// MessageId: MCA_WARNING_MEM_1_2_5_4
//
// MessageText:
//
// Machine Check Event reported is a corrected ECC memory error at physical address %3 on memory module %4 on memory card %5 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_MEM_1_2_5_4          ((NTSTATUS)0x8005004CL)

//
// MessageId: MCA_ERROR_MEM_1_2_5_4
//
// MessageText:
//
// Machine Check Event reported is a fatal ECC memory error at physical address %3 on memory module %4 on memory card %5 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_MEM_1_2_5_4            ((NTSTATUS)0xC005004DL)

//
// MessageId: MCA_WARNING_SYSTEM_EVENT
//
// MessageText:
//
// Machine Check Event reported is a corrected System Event error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_SYSTEM_EVENT         ((NTSTATUS)0x8005004EL)

//
// MessageId: MCA_ERROR_SYSTEM_EVENT
//
// MessageText:
//
// Machine Check Event reported is a fatal System Event error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_SYSTEM_EVENT           ((NTSTATUS)0xC005004FL)

//
// MessageId: MCA_WARNING_PCI_BUS_PARITY
//
// MessageText:
//
// Machine Check Event reported is a corrected PCI bus Parity error during a transaction type %3 at address %4 on PCI bus %5 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_PCI_BUS_PARITY       ((NTSTATUS)0x80050050L)

//
// MessageId: MCA_ERROR_PCI_BUS_PARITY
//
// MessageText:
//
// Machine Check Event reported is a fatal PCI bus Parity error during a transaction type %3 at address %4 on PCI bus %5 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_PCI_BUS_PARITY         ((NTSTATUS)0xC0050051L)

//
// MessageId: MCA_WARNING_PCI_BUS_PARITY_NO_INFO
//
// MessageText:
//
// Machine Check Event reported is a corrected PCI bus Parity error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_PCI_BUS_PARITY_NO_INFO ((NTSTATUS)0x80050052L)

//
// MessageId: MCA_ERROR_PCI_BUS_PARITY_NO_INFO
//
// MessageText:
//
// Machine Check Event reported is a fatal PCI bus Parity error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_PCI_BUS_PARITY_NO_INFO ((NTSTATUS)0xC0050053L)

//
// MessageId: MCA_WARNING_PCI_BUS_SERR
//
// MessageText:
//
// Machine Check Event reported is a corrected PCI bus SERR error during a transaction type %3 at address %4 on PCI bus %5 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_PCI_BUS_SERR         ((NTSTATUS)0x80050054L)

//
// MessageId: MCA_ERROR_PCI_BUS_SERR
//
// MessageText:
//
// Machine Check Event reported is a fatal PCI bus SERR error during a transaction type %3 at address %4 on PCI bus %5 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_PCI_BUS_SERR           ((NTSTATUS)0xC0050055L)

//
// MessageId: MCA_WARNING_PCI_BUS_SERR_NO_INFO
//
// MessageText:
//
// Machine Check Event reported is a corrected PCI bus SERR error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_PCI_BUS_SERR_NO_INFO ((NTSTATUS)0x80050056L)

//
// MessageId: MCA_ERROR_PCI_BUS_SERR_NO_INFO
//
// MessageText:
//
// Machine Check Event reported is a fatal PCI bus SERR error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_PCI_BUS_SERR_NO_INFO   ((NTSTATUS)0xC0050057L)

//
// MessageId: MCA_WARNING_PCI_BUS_MASTER_ABORT
//
// MessageText:
//
// Machine Check Event reported is a corrected PCI bus Master abort error during a transaction type %3 at address %4 on PCI bus %5 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_PCI_BUS_MASTER_ABORT ((NTSTATUS)0x80050058L)

//
// MessageId: MCA_ERROR_PCI_BUS_MASTER_ABORT
//
// MessageText:
//
// Machine Check Event reported is a fatal PCI bus Master abort error during a transaction type %3 at address %4 on PCI bus %5 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_PCI_BUS_MASTER_ABORT   ((NTSTATUS)0xC0050059L)

//
// MessageId: MCA_WARNING_PCI_BUS_MASTER_ABORT_NO_INFO
//
// MessageText:
//
// Machine Check Event reported is a corrected PCI bus Master abort error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_PCI_BUS_MASTER_ABORT_NO_INFO ((NTSTATUS)0x8005005AL)

//
// MessageId: MCA_ERROR_PCI_BUS_MASTER_ABORT_NO_INFO
//
// MessageText:
//
// Machine Check Event reported is a fatal PCI bus Master abort error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_PCI_BUS_MASTER_ABORT_NO_INFO ((NTSTATUS)0xC005005BL)

//
// MessageId: MCA_WARNING_PCI_BUS_TIMEOUT
//
// MessageText:
//
// Machine Check Event reported is a corrected PCI bus Timeout error during a transaction type %3 at address %4 on PCI bus %5 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_PCI_BUS_TIMEOUT      ((NTSTATUS)0x8005005CL)

//
// MessageId: MCA_ERROR_PCI_BUS_TIMEOUT
//
// MessageText:
//
// Machine Check Event reported is a fatal PCI bus Timeout error during a transaction type %3 at address %4 on PCI bus %5 reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_PCI_BUS_TIMEOUT        ((NTSTATUS)0xC005005DL)

//
// MessageId: MCA_WARNING_PCI_BUS_TIMEOUT_NO_INFO
//
// MessageText:
//
// Machine Check Event reported is a corrected PCI bus Timeout error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_PCI_BUS_TIMEOUT_NO_INFO ((NTSTATUS)0x8005005EL)

//
// MessageId: MCA_ERROR_PCI_BUS_TIMEOUT_NO_INFO
//
// MessageText:
//
// Machine Check Event reported is a fatal PCI bus Timeout error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_PCI_BUS_TIMEOUT_NO_INFO ((NTSTATUS)0xC005005FL)

//
// MessageId: MCA_WARNING_PCI_BUS_UNKNOWN
//
// MessageText:
//
// Machine Check Event reported is an unknown corrected PCI bus error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_PCI_BUS_UNKNOWN      ((NTSTATUS)0x80050060L)

//
// MessageId: MCA_ERROR_PCI_BUS_UNKNOWN
//
// MessageText:
//
// Machine Check Event reported is an unknown fatal PCI bus error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_PCI_BUS_UNKNOWN        ((NTSTATUS)0xC0050061L)

//
// MessageId: MCA_WARNING_PCI_DEVICE
//
// MessageText:
//
// Machine Check Event reported is a corrected PCI component error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_PCI_DEVICE           ((NTSTATUS)0x80050062L)

//
// MessageId: MCA_ERROR_PCI_DEVICE
//
// MessageText:
//
// Machine Check Event reported is a fatal PCI component error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_PCI_DEVICE             ((NTSTATUS)0xC0050063L)

//
// MessageId: MCA_WARNING_SMBIOS
//
// MessageText:
//
// Machine Check Event reported is a corrected SMBIOS Device Type %3 error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_SMBIOS               ((NTSTATUS)0x80050064L)

//
// MessageId: MCA_ERROR_SMBIOS
//
// MessageText:
//
// Machine Check Event reported is a fatal SMBIOS Device Type %3 error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_SMBIOS                 ((NTSTATUS)0xC0050065L)

//
// MessageId: MCA_WARNING_PLATFORM_SPECIFIC
//
// MessageText:
//
// Machine Check Event reported is a corrected Platform Specific error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_PLATFORM_SPECIFIC    ((NTSTATUS)0x80050066L)

//
// MessageId: MCA_ERROR_PLATFORM_SPECIFIC
//
// MessageText:
//
// Machine Check Event reported is a fatal Platform Specific error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_PLATFORM_SPECIFIC      ((NTSTATUS)0xC0050067L)

//
// MessageId: MCA_WARNING_UNKNOWN
//
// MessageText:
//
// Machine Check Event reported is a corrected error reported to CPU %1.
//
#define MCA_WARNING_UNKNOWN              ((NTSTATUS)0x80050068L)

//
// MessageId: MCA_ERROR_UNKNOWN
//
// MessageText:
//
// Machine Check Event reported is a fatal error reported to CPU %1.
//
#define MCA_ERROR_UNKNOWN                ((NTSTATUS)0xC0050069L)

//
// MessageId: MCA_WARNING_UNKNOWN_NO_CPU
//
// MessageText:
//
// Machine Check Event reported is a corrected error.
//
#define MCA_WARNING_UNKNOWN_NO_CPU       ((NTSTATUS)0x8005006AL)

//
// MessageId: MCA_ERROR_UNKNOWN_NO_CPU
//
// MessageText:
//
// Machine Check Event reported is a fatal error.
//
#define MCA_ERROR_UNKNOWN_NO_CPU         ((NTSTATUS)0xC005006BL)

//
// MessageId: IO_ERR_THREAD_STUCK_IN_DEVICE_DRIVER
//
// MessageText:
//
// The driver %3 for the %2 device %1 got stuck in an infinite loop. This
// usually indicates a problem with the device itself or with the device
// driver programming the hardware incorrectly. Please check with your
// hardware device vendor for any driver updates.
//
#define IO_ERR_THREAD_STUCK_IN_DEVICE_DRIVER ((NTSTATUS)0xC004006CL)

//
// MessageId: MCA_WARNING_CMC_THRESHOLD_EXCEEDED
//
// MessageText:
//
// Corrected Machine Check Interrupt threshold exceeded. Interrupt has been disabled. Polling mode has been enabled.
//
#define MCA_WARNING_CMC_THRESHOLD_EXCEEDED ((NTSTATUS)0x8005006DL)

//
// MessageId: MCA_WARNING_CPE_THRESHOLD_EXCEEDED
//
// MessageText:
//
// Corrected Platform Error Interrupt threshold exceeded. Interrupt has been disabled. Polling mode has been enabled.
//
#define MCA_WARNING_CPE_THRESHOLD_EXCEEDED ((NTSTATUS)0x8005006EL)

//
// MessageId: MCA_WARNING_CPU_THERMAL_THROTTLED
//
// MessageText:
//
// Machine Check Event reported is a CPU thermal throttling event reported from CPU %1. The CPU has exceeded the temperature limit and has been throttled down. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_CPU_THERMAL_THROTTLED ((NTSTATUS)0x8005006FL)

//
// MessageId: MCA_INFO_CPU_THERMAL_THROTTLING_REMOVED
//
// MessageText:
//
// Machine Check Event reported is a CPU thermal throttling event reported from CPU %1. The CPU has dropped below the temperature limit and throttling has been removed. %2 additional error(s) are contained within the record.
//
#define MCA_INFO_CPU_THERMAL_THROTTLING_REMOVED ((NTSTATUS)0x40050070L)

//
// MessageId: MCA_WARNING_CPU
//
// MessageText:
//
// Machine Check Event reported is a corrected CPU error reported from CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_WARNING_CPU                  ((NTSTATUS)0x80050071L)

//
// MessageId: MCA_ERROR_CPU
//
// MessageText:
//
// Machine Check Event reported is a fatal CPU error reported to CPU %1. %2 additional error(s) are contained within the record.
//
#define MCA_ERROR_CPU                    ((NTSTATUS)0xC0050072L)

//
// MessageId: MCA_INFO_NO_MORE_CORRECTED_ERROR_LOGS
//
// MessageText:
//
// The maximum number of Machine Check Event corrected error events that can be saved to the Event Log has been reached. Logging of these events has been disabled.
//
#define MCA_INFO_NO_MORE_CORRECTED_ERROR_LOGS ((NTSTATUS)0x40050073L)

//
// MessageId: MCA_INFO_MEMORY_PAGE_MARKED_BAD
//
// MessageText:
//
// The memory page at physical address %1 has encountered multiple corrected hardware error events. As a result it will no longer be used by Windows.
//
#define MCA_INFO_MEMORY_PAGE_MARKED_BAD  ((NTSTATUS)0x40050074L)

//
// MessageId: IO_ERR_PORT_TIMEOUT
//
// MessageText:
//
// The driver for device %1 detected a port timeout due to prolonged inactivity. All associated busses were reset in an effort to clear the condition.
//
#define IO_ERR_PORT_TIMEOUT              ((NTSTATUS)0xC0040075L)

//
// MessageId: IO_WARNING_BUS_RESET
//
// MessageText:
//
// The driver for device %1 performed a bus reset upon request.
//
#define IO_WARNING_BUS_RESET             ((NTSTATUS)0x80040076L)

//
// MessageId: IO_INFO_THROTTLE_COMPLETE
//
// MessageText:
//
// The driver for device %1 delayed non-paging Io requests for %2 ms to recover from a low memory condition.
//
#define IO_INFO_THROTTLE_COMPLETE        ((NTSTATUS)0x40040077L)

//
// MessageId: MCA_MEMORYHIERARCHY_ERROR
//
// MessageText:
//
// Machine Check Event reported is a fatal memory hierarchy error.%r Trasaction Type: %1%r Memory Hierarchy Level: %2%r Request Type: %3%r Address: %4
//
#define MCA_MEMORYHIERARCHY_ERROR        ((NTSTATUS)0xC0050078L)

//
// MessageId: MCA_TLB_ERROR
//
// MessageText:
//
// Machine Check Event reported is a fatal TLB error.%r Transaction Type: %1%r Memory Hierarchy Level: %2%r Address: %3
//
#define MCA_TLB_ERROR                    ((NTSTATUS)0xC0050079L)

//
// MessageId: MCA_BUS_ERROR
//
// MessageText:
//
// Machine Check Event reported is a fatal Bus or Interconnect error.%r Memory Hierarchy Level: %1%r Participation: %2%r Request Type: %3%r Memory/IO: %4%r Address: %5
//
#define MCA_BUS_ERROR                    ((NTSTATUS)0xC005007AL)

//
// MessageId: MCA_BUS_TIMEOUT_ERROR
//
// MessageText:
//
// Machine Check Event reported is a fatal Bus or Interconnect timeout error.%r Memory Hierarchy Level: %1%r Participation: %2%r Request Type: %3%r Memory/IO: %4%r Address: %5
//
#define MCA_BUS_TIMEOUT_ERROR            ((NTSTATUS)0xC005007BL)

//
// MessageId: MCA_INTERNALTIMER_ERROR
//
// MessageText:
//
// Machine Check Event reported is a fatal internal watchdog timer error.
//
#define MCA_INTERNALTIMER_ERROR          ((NTSTATUS)0xC005007CL)

//
// MessageId: MCA_MICROCODE_ROM_PARITY_ERROR
//
// MessageText:
//
// Machine Check Event reported is a fatal microsoft ROM parity error.
//
#define MCA_MICROCODE_ROM_PARITY_ERROR   ((NTSTATUS)0xC005007EL)

//
// MessageId: MCA_EXTERNAL_ERROR
//
// MessageText:
//
// Machine Check Event reported is a fatal condition. A processor received an external signal that an unrecoverable error has occurred.
//
#define MCA_EXTERNAL_ERROR               ((NTSTATUS)0xC005007FL)

//
// MessageId: MCA_FRC_ERROR
//
// MessageText:
//
// Machine Check Event reported is a fatal functional redundancy check error.
//
#define MCA_FRC_ERROR                    ((NTSTATUS)0xC0050080L)

//
// MessageId: IO_WARNING_RESET
//
// MessageText:
//
// Reset to device, %1, was issued.
//
#define IO_WARNING_RESET                 ((NTSTATUS)0x80040081L)

//
// MessageId: IO_FILE_SYSTEM_REPAIR_SUCCESS
//
// MessageText:
//
// The file system structure on volume %2 has now been repaired.
//
#define IO_FILE_SYSTEM_REPAIR_SUCCESS    ((NTSTATUS)0x80040082L)

//
// MessageId: IO_FILE_SYSTEM_REPAIR_FAILED
//
// MessageText:
//
// The file system structure on volume %2 cannot be corrected.
// Please run the chkdsk utility on the volume %2.
//
#define IO_FILE_SYSTEM_REPAIR_FAILED     ((NTSTATUS)0xC0040083L)

//
// MessageId: IO_WARNING_WRITE_FUA_PROBLEM
//
// MessageText:
//
// Device %1 is not correctly processing some write requests. In Device Manager, ensure that the Write Cache option is disabled for this device or data corruption may occur.
//
#define IO_WARNING_WRITE_FUA_PROBLEM     ((NTSTATUS)0x80040084L)

//
// MessageId: IO_CDROM_EXCLUSIVE_LOCK
//
// MessageText:
//
// Device %1 is locked for exclusive access.
//
#define IO_CDROM_EXCLUSIVE_LOCK          ((NTSTATUS)0x40040085L)

//
// MessageId: IO_FILE_SYSTEM_TXF_RECOVERY_FAILURE
//
// MessageText:
//
// The transaction resource manager on volume %2 encountered an error during recovery.  The resource manager will continue recovery.
//
#define IO_FILE_SYSTEM_TXF_RECOVERY_FAILURE ((NTSTATUS)0x80040086L)

//
// MessageId: IO_FILE_SYSTEM_TXF_LOG_FULL_HANDLING_FAILED
//
// MessageText:
//
// The transaction resource manager on volume %2 was unable to create free space in its log due to a non-retryable error.  The data contains the error code.
//
#define IO_FILE_SYSTEM_TXF_LOG_FULL_HANDLING_FAILED ((NTSTATUS)0xC0040087L)

//
// MessageId: IO_FILE_SYSTEM_TXF_RESOURCE_MANAGER_RESET
//
// MessageText:
//
// The default transaction resource manager on volume %2 encountered an error while starting and its metadata was reset.  The data contains the error code.
//
#define IO_FILE_SYSTEM_TXF_RESOURCE_MANAGER_RESET ((NTSTATUS)0x80040088L)

//
// MessageId: IO_FILE_SYSTEM_TXF_RESOURCE_MANAGER_START_FAILED
//
// MessageText:
//
// The default transaction resource manager on volume %2 encountered a non-retryable error and could not start.  The data contains the error code.
//
#define IO_FILE_SYSTEM_TXF_RESOURCE_MANAGER_START_FAILED ((NTSTATUS)0xC0040089L)

//
// MessageId: IO_FILE_SYSTEM_TXF_RESOURCE_MANAGER_SHUT_DOWN
//
// MessageText:
//
// The transaction resource manager at %2%3 encountered a fatal error and was shut down.  The data contains the error code.
//
#define IO_FILE_SYSTEM_TXF_RESOURCE_MANAGER_SHUT_DOWN ((NTSTATUS)0xC004008AL)

//
// MessageId: IO_LOST_DELAYED_WRITE_NETWORK_DISCONNECTED
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %2; the data has been lost. 
// This error may be caused by network connectivity issues. Please try to save this file elsewhere.  
//
#define IO_LOST_DELAYED_WRITE_NETWORK_DISCONNECTED ((NTSTATUS)0x8004008BL)

//
// MessageId: IO_LOST_DELAYED_WRITE_NETWORK_SERVER_ERROR
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %2; the data has been lost. 
// This error was returned by the server on which the file exists. Please try to save this file elsewhere.  
//
#define IO_LOST_DELAYED_WRITE_NETWORK_SERVER_ERROR ((NTSTATUS)0x8004008CL)

//
// MessageId: IO_LOST_DELAYED_WRITE_NETWORK_LOCAL_DISK_ERROR
//
// MessageText:
//
// {Delayed Write Failed}
// Windows was unable to save all the data for the file %2; the data has been lost. 
// This error may be caused if the device has been removed or the media is write-protected.
//
#define IO_LOST_DELAYED_WRITE_NETWORK_LOCAL_DISK_ERROR ((NTSTATUS)0x8004008DL)

#endif /* _NTIOLOGC_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NTMSMli.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    39306
//  $AgreementName:  amendment 1 to development & license agreement
//  $AgreementType:  inbound license
//  $ExternalOrigin: highground systems
//$ENDTAG

//$TAG ENGR 
//  $Owner:    math
//  $Module:   drivers_published_sdk
//
//$ENDTAG

/*++

  Copyright (c) Microsoft Corporation. All rights reserved.
  Copyright (c) 1996-1999 Highground Systems

  Module Name:

        NtmsMli.h

  Abstract:

        This header contains the definitions of the 
        MediaLabelInfo structure. Media label libraries use
        this structure to pass information to RSM to use to
        identify media. 

        The name of this file reflects it's history.  RSM 
        began its life as NTMS.


--*/

#ifndef _INCL_NTMSMLI_H_
#define _INCL_NTMSMLI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#define NTMSMLI_MAXTYPE     64
#define NTMSMLI_MAXIDSIZE   256
#define NTMSMLI_MAXAPPDESCR 256

#ifndef NTMS_NOREDEF

typedef struct
{
        WCHAR   LabelType[NTMSMLI_MAXTYPE];
        DWORD   LabelIDSize;
        BYTE    LabelID[NTMSMLI_MAXIDSIZE];
        WCHAR   LabelAppDescr[NTMSMLI_MAXAPPDESCR];
} MediaLabelInfo, *pMediaLabelInfo;

#endif  // NTMS_NOREDEF

typedef DWORD ( WINAPI *MAXMEDIALABEL) (DWORD * const pMaxSize);
typedef DWORD ( WINAPI *CLAIMMEDIALABEL) (const BYTE * const pBuffer, const DWORD nBufferSize,
                                  MediaLabelInfo * const pLabelInfo);
typedef DWORD ( WINAPI *CLAIMMEDIALABELEX) (const BYTE * const pBuffer, const DWORD nBufferSize,
                                  MediaLabelInfo * const pLabelInfo, GUID * LabelGuid);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntmsv1_0.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ntmsv1_0.h

Abstract:

    This module contains the public data structures provided by
    the MSV1_0 authentication package.


Author:

--*/

#ifndef _NTMSV1_0_
#define _NTMSV1_0_

#if _MSC_VER > 1000
#pragma once
#endif

#include <sdkddkver.h>
#include <ntlsa.h>
#include <ntsam.h>

#ifdef __cplusplus
extern "C" {
#endif

// begin_ntifs begin_ntsecapi

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Name of the MSV1_0 authentication package                           //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

#define MSV1_0_PACKAGE_NAME     "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
#define MSV1_0_PACKAGE_NAMEW    L"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
#define MSV1_0_PACKAGE_NAMEW_LENGTH sizeof(MSV1_0_PACKAGE_NAMEW) - sizeof(WCHAR)

//
// Location of MSV authentication package data
//
#define MSV1_0_SUBAUTHENTICATION_KEY "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0"
#define MSV1_0_SUBAUTHENTICATION_VALUE "Auth"


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Widely used MSV1_0 data types                                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//       LOGON      Related Data Structures
//
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// When a LsaLogonUser() call is dispatched to the MsV1_0 authentication
// package, the beginning of the AuthenticationInformation buffer is
// cast to a MSV1_0_LOGON_SUBMIT_TYPE to determine the type of logon
// being requested.  Similarly, upon return, the type of profile buffer
// can be determined by typecasting it to a MSV_1_0_PROFILE_BUFFER_TYPE.
//

//
//  MSV1.0 LsaLogonUser() submission message types.
//

typedef enum _MSV1_0_LOGON_SUBMIT_TYPE {
    MsV1_0InteractiveLogon = 2,
    MsV1_0Lm20Logon,
    MsV1_0NetworkLogon,
    MsV1_0SubAuthLogon,
    MsV1_0WorkstationUnlockLogon = 7,
    // defined in Longhorn and up
    MsV1_0S4ULogon = 12,
} MSV1_0_LOGON_SUBMIT_TYPE, *PMSV1_0_LOGON_SUBMIT_TYPE;


//
//  MSV1.0 LsaLogonUser() profile buffer types.
//

typedef enum _MSV1_0_PROFILE_BUFFER_TYPE {
    MsV1_0InteractiveProfile = 2,
    MsV1_0Lm20LogonProfile,
    MsV1_0SmartCardProfile
} MSV1_0_PROFILE_BUFFER_TYPE, *PMSV1_0_PROFILE_BUFFER_TYPE;

//
// MsV1_0InteractiveLogon
//
// The AuthenticationInformation buffer of an LsaLogonUser() call to
// perform an interactive logon contains the following data structure:
//

typedef struct _MSV1_0_INTERACTIVE_LOGON {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;
} MSV1_0_INTERACTIVE_LOGON, *PMSV1_0_INTERACTIVE_LOGON;

//
// Where:
//
//     MessageType - Contains the type of logon being requested.  This
//         field must be set to MsV1_0InteractiveLogon.
//
//     UserName - Is a string representing the user's account name.  The
//         name may be up to 255 characters long.  The name is treated case
//         insensitive.
//
//     Password - Is a string containing the user's cleartext password.
//         The password may be up to 255 characters long and contain any
//         UNICODE value.
//
//


//
// The ProfileBuffer returned upon a successful logon of this type
// contains the following data structure:
//

typedef struct _MSV1_0_INTERACTIVE_PROFILE {
    MSV1_0_PROFILE_BUFFER_TYPE MessageType;
    USHORT LogonCount;
    USHORT BadPasswordCount;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING LogonScript;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING FullName;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING LogonServer;
    ULONG UserFlags;
} MSV1_0_INTERACTIVE_PROFILE, *PMSV1_0_INTERACTIVE_PROFILE;

//
// where:
//
//     MessageType - Identifies the type of profile data being returned.
//         Contains the type of logon being requested.  This field must
//         be set to MsV1_0InteractiveProfile.
//
//     LogonCount - Number of times the user is currently logged on.
//
//     BadPasswordCount - Number of times a bad password was applied to
//         the account since last successful logon.
//
//     LogonTime - Time when user last logged on.  This is an absolute
//         format NT standard time value.
//
//     LogoffTime - Time when user should log off.  This is an absolute
//         format NT standard time value.
//
//     KickOffTime - Time when system should force user logoff.  This is
//         an absolute format NT standard time value.
//
//     PasswordLastChanged - Time and date the password was last
//         changed.  This is an absolute format NT standard time
//         value.
//
//     PasswordCanChange - Time and date when the user can change the
//         password.  This is an absolute format NT time value.  To
//         prevent a password from ever changing, set this field to a
//         date very far into the future.
//
//     PasswordMustChange - Time and date when the user must change the
//         password.  If the user can never change the password, this
//         field is undefined.  This is an absolute format NT time
//         value.
//
//     LogonScript - The (relative) path to the account's logon
//         script.
//
//     HomeDirectory - The home directory for the user.
//


//
// MsV1_0Lm20Logon and MsV1_0NetworkLogon
//
// The AuthenticationInformation buffer of an LsaLogonUser() call to
// perform an network logon contains the following data structure:
//
// MsV1_0NetworkLogon logon differs from MsV1_0Lm20Logon in that the
// ParameterControl field exists.
//

#define MSV1_0_CHALLENGE_LENGTH 8
#define MSV1_0_USER_SESSION_KEY_LENGTH 16
#define MSV1_0_LANMAN_SESSION_KEY_LENGTH 8

//
// Values for ParameterControl.
//

#define MSV1_0_CLEARTEXT_PASSWORD_ALLOWED    0x02
#define MSV1_0_UPDATE_LOGON_STATISTICS       0x04
#define MSV1_0_RETURN_USER_PARAMETERS        0x08
#define MSV1_0_DONT_TRY_GUEST_ACCOUNT        0x10
#define MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT    0x20
#define MSV1_0_RETURN_PASSWORD_EXPIRY        0x40
// this next flag says that CaseInsensitiveChallengeResponse
//  (aka LmResponse) contains a client challenge in the first 8 bytes
#define MSV1_0_USE_CLIENT_CHALLENGE          0x80
#define MSV1_0_TRY_GUEST_ACCOUNT_ONLY        0x100
#define MSV1_0_RETURN_PROFILE_PATH           0x200
#define MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY     0x400
#define MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT 0x800
//#if (_WIN32_WINNT >= 0x0501) -- Disabled until IIS fixes their target version.
#define MSV1_0_DISABLE_PERSONAL_FALLBACK     0x00001000
#define MSV1_0_ALLOW_FORCE_GUEST             0x00002000
//#endif
#if (_WIN32_WINNT >= 0x0502)
#define MSV1_0_CLEARTEXT_PASSWORD_SUPPLIED   0x00004000
// Start
// Doesnt exist in Windows XP but does exist in Windows 2000 Security Rollup and up
#define MSV1_0_USE_DOMAIN_FOR_ROUTING_ONLY   0x00008000
#endif
#define MSV1_0_SUBAUTHENTICATION_DLL_EX      0x00100000
// Defined in Windows Server 2003 SP1 and above
#define MSV1_0_ALLOW_MSVCHAPV2               0x00010000

#if (_WIN32_WINNT >= 0x0600)

//Defined in Longhorn and up
#define MSV1_0_S4U2SELF                      0x00020000 // no password is needed
#define MSV1_0_CHECK_LOGONHOURS_FOR_S4U      0x00040000 // check logon hours for S4U logon

#endif

//
// The high order byte is a value indicating the SubAuthentication DLL.
//  Zero indicates no SubAuthentication DLL.
//
#define MSV1_0_SUBAUTHENTICATION_DLL         0xFF000000
#define MSV1_0_SUBAUTHENTICATION_DLL_SHIFT   24
#define MSV1_0_MNS_LOGON                     0x01000000

//
// This is the list of subauthentication dlls used in MS
//

#define MSV1_0_SUBAUTHENTICATION_DLL_RAS     2
#define MSV1_0_SUBAUTHENTICATION_DLL_IIS     132

typedef struct _MSV1_0_LM20_LOGON {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    STRING CaseSensitiveChallengeResponse;
    STRING CaseInsensitiveChallengeResponse;
    ULONG ParameterControl;
} MSV1_0_LM20_LOGON, * PMSV1_0_LM20_LOGON;

//
// NT 5.0 SubAuth dlls can use this struct
//

typedef struct _MSV1_0_SUBAUTH_LOGON{
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    STRING AuthenticationInfo1;
    STRING AuthenticationInfo2;
    ULONG ParameterControl;
    ULONG SubAuthPackageId;
} MSV1_0_SUBAUTH_LOGON, * PMSV1_0_SUBAUTH_LOGON;

#if (_WIN32_WINNT >= 0x0600)

//
// s4u2self logon
//
// Defined in Longhorn and above

//
// request to enforce logon hours policy
//

#define MSV1_0_S4U_LOGON_FLAG_CHECK_LOGONHOURS 0x2

typedef struct _MSV1_0_S4U_LOGON {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    ULONG Flags;
    UNICODE_STRING UserPrincipalName; // username or username@domain
    UNICODE_STRING DomainName; // Optional: if missing, using the local machine
} MSV1_0_S4U_LOGON, *PMSV1_0_S4U_LOGON;

#endif 

//
// Values for UserFlags.
//

#define LOGON_GUEST                 0x01
#define LOGON_NOENCRYPTION          0x02
#define LOGON_CACHED_ACCOUNT        0x04
#define LOGON_USED_LM_PASSWORD      0x08
#define LOGON_EXTRA_SIDS            0x20
#define LOGON_SUBAUTH_SESSION_KEY   0x40
#define LOGON_SERVER_TRUST_ACCOUNT  0x80
#define LOGON_NTLMV2_ENABLED        0x100       // says DC understands NTLMv2
#define LOGON_RESOURCE_GROUPS       0x200
#define LOGON_PROFILE_PATH_RETURNED 0x400
// Defined in Longhorn and above
#define LOGON_NT_V2                 0x800   // NT response was used for validation
#define LOGON_LM_V2                 0x1000  // LM response was used for validation
#define LOGON_NTLM_V2               0x2000  // LM response was used to authenticate but NT response was used to derive the session key

#if (_WIN32_WINNT >= 0x0600)

#define LOGON_OPTIMIZED             0x4000  // this is an optimized logon
#define LOGON_WINLOGON              0x8000  // the logon session was created for winlogon
#define LOGON_PKINIT               0x10000  // Kerberos PKINIT extension was used to authenticate the user
#define LOGON_NO_OPTIMIZED         0x20000  // optimized logon has been disabled for this account

#endif

//
// The high order byte is reserved for return by SubAuthentication DLLs.
//

#define MSV1_0_SUBAUTHENTICATION_FLAGS 0xFF000000

// Values returned by the MSV1_0_MNS_LOGON SubAuthentication DLL
#define LOGON_GRACE_LOGON              0x01000000

typedef struct _MSV1_0_LM20_LOGON_PROFILE {
    MSV1_0_PROFILE_BUFFER_TYPE MessageType;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER LogoffTime;
    ULONG UserFlags;
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UNICODE_STRING LogonDomainName;
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
    UNICODE_STRING LogonServer;
    UNICODE_STRING UserParameters;
} MSV1_0_LM20_LOGON_PROFILE, * PMSV1_0_LM20_LOGON_PROFILE;


//
// Supplemental credentials structure used for passing credentials into
// MSV1_0 from other packages
//

#define MSV1_0_OWF_PASSWORD_LENGTH 16
#define MSV1_0_CRED_LM_PRESENT 0x1
#define MSV1_0_CRED_NT_PRESENT 0x2
#define MSV1_0_CRED_VERSION 0

typedef struct _MSV1_0_SUPPLEMENTAL_CREDENTIAL {
    ULONG Version;
    ULONG Flags;
    UCHAR LmPassword[MSV1_0_OWF_PASSWORD_LENGTH];
    UCHAR NtPassword[MSV1_0_OWF_PASSWORD_LENGTH];
} MSV1_0_SUPPLEMENTAL_CREDENTIAL, *PMSV1_0_SUPPLEMENTAL_CREDENTIAL;


//
// NTLM3 definitions.
//

#define MSV1_0_NTLM3_RESPONSE_LENGTH 16
#define MSV1_0_NTLM3_OWF_LENGTH 16

//
// this is the longest amount of time we'll allow challenge response
// pairs to be used. Note that this also has to allow for worst case clock skew
//
#if (_WIN32_WINNT == 0x0500)
#define MSV1_0_MAX_NTLM3_LIFE 1800     // 30 minutes (in seconds)
#else
#define MSV1_0_MAX_NTLM3_LIFE 129600     // 36 hours (in seconds)
#endif
#define MSV1_0_MAX_AVL_SIZE 64000

#if (_WIN32_WINNT >= 0x0501)
//
// MsvAvFlags bit values
//
// Exists only after Windows 2000
//

#define MSV1_0_AV_FLAG_FORCE_GUEST                  0x00000001
#if (_WIN32_WINNT >= 0x0600)
#define MSV1_0_AV_FLAG_MIC_HANDSHAKE_MESSAGES       0x00000002 // the client supports
                                                               // hand-shake messages integrity
#endif
#endif

// this is an MSV1_0 private data structure, defining the layout of an NTLM3 response, as sent by a
//  client in the NtChallengeResponse field of the NETLOGON_NETWORK_INFO structure. If can be differentiated
//  from an old style NT response by its length. This is crude, but it needs to pass through servers and
//  the servers' DCs that do not understand NTLM3 but that are willing to pass longer responses.
typedef struct _MSV1_0_NTLM3_RESPONSE {
    UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH]; // hash of OWF of password with all the following fields
    UCHAR RespType;     // id number of response; current is 1
    UCHAR HiRespType;   // highest id number understood by client
    USHORT Flags;       // reserved; must be sent as zero at this version
    ULONG MsgWord;      // 32 bit message from client to server (for use by auth protocol)
    ULONGLONG TimeStamp;    // time stamp when client generated response -- NT system time, quad part
    UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
    ULONG AvPairsOff;   // offset to start of AvPairs (to allow future expansion)
    UCHAR Buffer[1];    // start of buffer with AV pairs (or future stuff -- so use the offset)
} MSV1_0_NTLM3_RESPONSE, *PMSV1_0_NTLM3_RESPONSE;

#define MSV1_0_NTLM3_INPUT_LENGTH (sizeof(MSV1_0_NTLM3_RESPONSE) - MSV1_0_NTLM3_RESPONSE_LENGTH)
#if(_WIN32_WINNT >= 0x0502)
#define MSV1_0_NTLM3_MIN_NT_RESPONSE_LENGTH RTL_SIZEOF_THROUGH_FIELD(MSV1_0_NTLM3_RESPONSE, AvPairsOff)
#endif

typedef enum {
    MsvAvEOL,                 // end of list
    MsvAvNbComputerName,      // server's computer name -- NetBIOS
    MsvAvNbDomainName,        // server's domain name -- NetBIOS
    MsvAvDnsComputerName,     // server's computer name -- DNS
    MsvAvDnsDomainName,       // server's domain name -- DNS
#if (_WIN32_WINNT >= 0x0501)
    MsvAvDnsTreeName,         // server's tree name -- DNS
    MsvAvFlags,               // server's extended flags -- DWORD mask
#if (_WIN32_WINNT >= 0x0600)
    MsvAvTimestamp,           // contains the server's local time in FILETIME,
                              // (64 bit 100 ns ticks since 1602
                              // (UTC)) in little endian byte order
    MsvAvRestrictions,        // token restrictions                              
#endif
#endif
} MSV1_0_AVID;

typedef struct  _MSV1_0_AV_PAIR {
    USHORT AvId;
    USHORT AvLen;
    // Data is treated as byte array following structure
} MSV1_0_AV_PAIR, *PMSV1_0_AV_PAIR;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//       CALL PACKAGE Related Data Structures                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
//  MSV1.0 LsaCallAuthenticationPackage() submission and response
//  message types.
//

typedef enum _MSV1_0_PROTOCOL_MESSAGE_TYPE {
    MsV1_0Lm20ChallengeRequest = 0,          // Both submission and response
    MsV1_0Lm20GetChallengeResponse,          // Both submission and response
    MsV1_0EnumerateUsers,                    // Both submission and response
    MsV1_0GetUserInfo,                       // Both submission and response
    MsV1_0ReLogonUsers,                      // Submission only
    MsV1_0ChangePassword,                    // Both submission and response
    MsV1_0ChangeCachedPassword,              // Both submission and response
    MsV1_0GenericPassthrough,                // Both submission and response
    MsV1_0CacheLogon,                        // Submission only, no response
    MsV1_0SubAuth,                           // Both submission and response
    MsV1_0DeriveCredential,                  // Both submission and response
    MsV1_0CacheLookup,                       // Both submission and response
#if (_WIN32_WINNT >= 0x0501)
    MsV1_0SetProcessOption,                  // Submission only, no response
#endif
#if (_WIN32_WINNT >= 0x0600)
    MsV1_0ConfigLocalAliases,
    MsV1_0ClearCachedCredentials,
#endif    
} MSV1_0_PROTOCOL_MESSAGE_TYPE, *PMSV1_0_PROTOCOL_MESSAGE_TYPE;

// end_ntsecapi

//
// MsV1_0Lm20ChallengeRequest submit buffer and response
//

typedef struct _MSV1_0_LM20_CHALLENGE_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
} MSV1_0_LM20_CHALLENGE_REQUEST, *PMSV1_0_LM20_CHALLENGE_REQUEST;

typedef struct _MSV1_0_LM20_CHALLENGE_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
} MSV1_0_LM20_CHALLENGE_RESPONSE, *PMSV1_0_LM20_CHALLENGE_RESPONSE;

//
// MsV1_0Lm20GetChallengeResponse submit buffer and response
//

#define USE_PRIMARY_PASSWORD            0x01
#define RETURN_PRIMARY_USERNAME         0x02
#define RETURN_PRIMARY_LOGON_DOMAINNAME 0x04
#define RETURN_NON_NT_USER_SESSION_KEY  0x08
#define GENERATE_CLIENT_CHALLENGE       0x10
#define GCR_NTLM3_PARMS                 0x20
#define GCR_TARGET_INFO                 0x40    // ServerName field contains target info AV pairs
#define RETURN_RESERVED_PARAMETER       0x80    // was 0x10
#define GCR_ALLOW_NTLM                 0x100    // allow the use of NTLM
// Exists in Windows XPSP2 and later
#define GCR_USE_OEM_SET                0x200    // response uses oem character set
#define GCR_MACHINE_CREDENTIAL         0x400
#define GCR_USE_OWF_PASSWORD           0x800    // use owf passwords
#define GCR_ALLOW_LM                  0x1000    // allow the use of LM
// Defined in Windows Server 2003 and above
#define GCR_ALLOW_NO_TARGET           0x2000    // allow no target server or target domain name

//
// version 1 of the GETCHALLENRESP structure, which was used by RAS and others.
// compiled before the additional fields added to GETCHALLENRESP_REQUEST.
// here to allow sizing operations for backwards compatibility.
//

typedef struct _MSV1_0_GETCHALLENRESP_REQUEST_V1 {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG ParameterControl;
    LUID LogonId;
    UNICODE_STRING Password;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
} MSV1_0_GETCHALLENRESP_REQUEST_V1, *PMSV1_0_GETCHALLENRESP_REQUEST_V1;

typedef struct _MSV1_0_GETCHALLENRESP_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG ParameterControl;
    LUID LogonId;
    UNICODE_STRING Password;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];

    //
    // the following 3 fields are only present if GCR_NTLM3_PARMS is set in ParameterControl
    //

    UNICODE_STRING UserName;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING ServerName;      // server domain or target info AV pairs
} MSV1_0_GETCHALLENRESP_REQUEST, *PMSV1_0_GETCHALLENRESP_REQUEST;

typedef struct _MSV1_0_GETCHALLENRESP_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    STRING CaseSensitiveChallengeResponse;
    STRING CaseInsensitiveChallengeResponse;
    UNICODE_STRING UserName;
    UNICODE_STRING LogonDomainName;
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
} MSV1_0_GETCHALLENRESP_RESPONSE, *PMSV1_0_GETCHALLENRESP_RESPONSE;

//
// MsV1_0EnumerateUsers submit buffer and response
//

typedef struct _MSV1_0_ENUMUSERS_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
} MSV1_0_ENUMUSERS_REQUEST, *PMSV1_0_ENUMUSERS_REQUEST;

typedef struct _MSV1_0_ENUMUSERS_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG NumberOfLoggedOnUsers;
    PLUID LogonIds;
    PULONG EnumHandles;
} MSV1_0_ENUMUSERS_RESPONSE, *PMSV1_0_ENUMUSERS_RESPONSE;

//
// MsV1_0GetUserInfo submit buffer and response
//

typedef struct _MSV1_0_GETUSERINFO_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID LogonId;
} MSV1_0_GETUSERINFO_REQUEST, *PMSV1_0_GETUSERINFO_REQUEST;

typedef struct _MSV1_0_GETUSERINFO_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    PSID UserSid;
    UNICODE_STRING UserName;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING LogonServer;
    SECURITY_LOGON_TYPE LogonType;
} MSV1_0_GETUSERINFO_RESPONSE, *PMSV1_0_GETUSERINFO_RESPONSE;

// end_ntifs

//
// MsV1_0RelogonUsers submit buffer
//

typedef struct _MSV1_0_RELOGON_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING LogonServer;
} MSV1_0_RELOGON_REQUEST, *PMSV1_0_RELOGON_REQUEST;

//
// MsV1_0ChangePassword and MsV1_0ChangeCachedPassword submit buffer
//
// MsV1_0ChangePassword changes the password on the SAM account plus
//  the password cache and logon credentials if applicable.
//
// MsV1_0ChangeCachedPassword only changes the password cache and the logon
//  credentials.
//

// begin_ntsecapi

typedef struct _MSV1_0_CHANGEPASSWORD_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING DomainName;
    UNICODE_STRING AccountName;
    UNICODE_STRING OldPassword;
    UNICODE_STRING NewPassword;
    BOOLEAN        Impersonating;
} MSV1_0_CHANGEPASSWORD_REQUEST, *PMSV1_0_CHANGEPASSWORD_REQUEST;

typedef struct _MSV1_0_CHANGEPASSWORD_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    BOOLEAN PasswordInfoValid;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
} MSV1_0_CHANGEPASSWORD_RESPONSE, *PMSV1_0_CHANGEPASSWORD_RESPONSE;


#if(_WIN32_WINNT >= 0x0502)
//
// MsV1_0GenericPassthrough - for remoting a CallPackage to
// a domain controller on the specified domain
//

typedef struct _MSV1_0_PASSTHROUGH_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING DomainName;
    UNICODE_STRING PackageName;
    ULONG DataLength;
    PUCHAR LogonData;
    ULONG Pad ;
} MSV1_0_PASSTHROUGH_REQUEST, *PMSV1_0_PASSTHROUGH_REQUEST;

typedef struct _MSV1_0_PASSTHROUGH_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG Pad;
    ULONG DataLength;
    PUCHAR ValidationData;
} MSV1_0_PASSTHROUGH_RESPONSE, *PMSV1_0_PASSTHROUGH_RESPONSE;
#endif

// end_ntsecapi


//
// MsV1_0CacheLogon submit buffer
//

// Values for RequestFlags
#define MSV1_0_CACHE_LOGON_REQUEST_MIT_LOGON        0x00000001
#define MSV1_0_CACHE_LOGON_REQUEST_INFO4            0x00000002
#define MSV1_0_CACHE_LOGON_DELETE_ENTRY             0x00000004
#define MSV1_0_CACHE_LOGON_REQUEST_SMARTCARD        0x00000008
#define MSV1_0_CACHE_LOGON_DELETE_ALL               0x00000010 // delete all entries for a particular user
#define MSV1_0_CACHE_LOGON_NO_OPTIMIZED_LOGON       0x00000020 // disable optimized logon

typedef struct _MSV1_0_CACHE_LOGON_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    PVOID LogonInformation;
    PVOID ValidationInformation;
    PVOID SupplementalCacheData;
    ULONG SupplementalCacheDataLength;
    ULONG RequestFlags;
} MSV1_0_CACHE_LOGON_REQUEST, *PMSV1_0_CACHE_LOGON_REQUEST;


//
// MsV1_0CacheLookup submit buffer
//

// values for CredentialType
#define MSV1_0_CACHE_LOOKUP_CREDTYPE_NONE                    0
#define MSV1_0_CACHE_LOOKUP_CREDTYPE_RAW                     1
#define MSV1_0_CACHE_LOOKUP_CREDTYPE_NTOWF                   2

typedef struct _MSV1_0_CACHE_LOOKUP_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING UserName;
    UNICODE_STRING DomainName;
    ULONG CredentialType;
    ULONG CredentialInfoLength;
    UCHAR CredentialSubmitBuffer[1];    // in-place array of length CredentialInfoLength
} MSV1_0_CACHE_LOOKUP_REQUEST, *PMSV1_0_CACHE_LOOKUP_REQUEST;

typedef struct _MSV1_0_CACHE_LOOKUP_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    PVOID ValidationInformation;
    PVOID SupplementalCacheData;
    ULONG SupplementalCacheDataLength;
} MSV1_0_CACHE_LOOKUP_RESPONSE, *PMSV1_0_CACHE_LOOKUP_RESPONSE;


//
// MsV1_0ConfigLocalAliases submit buffer
//

#define MSV1_0_CONFIG_LOCAL_ALIASES_ADD                        1
#define MSV1_0_CONFIG_LOCAL_ALIASES_DEL                        2
#define MSV1_0_CONFIG_LOCAL_ALIASES_ENUM                       4

typedef struct _MSV1_0_CONFIG_LOCAL_ALIASES_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG Flags;    // this indicates actions to perform
    UNICODE_STRING Alias;
} MSV1_0_CONFIG_LOCAL_ALIASES_REQUEST, *PMSV1_0_CONFIG_LOCAL_ALIASES_REQUEST;

typedef struct _MSV1_0_CONFIG_LOCAL_ALIASES_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING MultszAliases;
} MSV1_0_CONFIG_LOCAL_ALIASES_RESPONSE, *PMSV1_0_CONFIG_LOCAL_ALIASES_RESPONSE;


//
// MsV1_0ClearCachedCredentials submit buffer
//

typedef struct _MSV1_0_CLEAR_CACHED_CREDENTIALS_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG Flags;
} MSV1_0_CLEAR_CACHED_CREDENTIALS_REQUEST, *PMSV1_0_CLEAR_CACHED_CREDENTIALS_REQUEST;


// begin_ntsecapi

//
// MsV1_0SubAuthInfo submit buffer and response - for submitting a buffer to a
// specified Subauthentication Package during an LsaCallAuthenticationPackage().
// If this Subauthentication is to be done locally, then package this message
// in LsaCallAuthenticationPackage(). If this SubAuthentication needs to be done
// on the domain controller, then call LsaCallauthenticationPackage with the
// message type being MsV1_0GenericPassThrough and the LogonData in this struct
// should be a PMSV1_0_SUBAUTH_REQUEST
//

typedef struct _MSV1_0_SUBAUTH_REQUEST{
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG SubAuthPackageId;
    ULONG SubAuthInfoLength;
    PUCHAR SubAuthSubmitBuffer;
} MSV1_0_SUBAUTH_REQUEST, *PMSV1_0_SUBAUTH_REQUEST;

typedef struct _MSV1_0_SUBAUTH_RESPONSE{
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG SubAuthInfoLength;
    PUCHAR SubAuthReturnBuffer;
} MSV1_0_SUBAUTH_RESPONSE, *PMSV1_0_SUBAUTH_RESPONSE;


// end_ntsecapi

//
// Credential Derivation types for MsV1_0DeriveCredential Submit DeriveCredType
//

//
// Derive Credential using SHA-1 and Request buffer DeriveCredSubmitBuffer of
// length DeriveCredInfoLength mixing bytes.
// Response buffer DeriveCredReturnBuffer will contain SHA-1 hash of size
// A_SHA_DIGEST_LEN (20)
//

#define MSV1_0_DERIVECRED_TYPE_SHA1     0
#define MSV1_0_DERIVECRED_TYPE_SHA1_V2  1

//
// MsV1_0DeriveCredential submit buffer and response - for submitting a buffer
// an call to LsaCallAuthenticationPackage().
//

typedef struct _MSV1_0_DERIVECRED_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    LUID LogonId;
    ULONG DeriveCredType;
    ULONG DeriveCredInfoLength;
    UCHAR DeriveCredSubmitBuffer[1];    // in-place array of length DeriveCredInfoLength
} MSV1_0_DERIVECRED_REQUEST, *PMSV1_0_DERIVECRED_REQUEST;

typedef struct _MSV1_0_DERIVECRED_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG DeriveCredInfoLength;
    UCHAR DeriveCredReturnBuffer[1];    // in-place array of length DeriveCredInfoLength
} MSV1_0_DERIVECRED_RESPONSE, *PMSV1_0_DERIVECRED_RESPONSE;


//
// MsV1_0SetProcessOption submit buffer - for submitting a buffer
// an call to LsaCallAuthenticationPackage().
//

#define MSV1_0_OPTION_ALLOW_BLANK_PASSWORD      0x01
#define MSV1_0_OPTION_DISABLE_ADMIN_LOCKOUT     0x02
#define MSV1_0_OPTION_DISABLE_FORCE_GUEST       0x04
#define MSV1_0_OPTION_ALLOW_OLD_PASSWORD        0x08
#define MSV1_0_OPTION_TRY_CACHE_FIRST           0x10

typedef struct _MSV1_0_SETPROCESSOPTION_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG ProcessOptions;
    BOOLEAN DisableOptions;
} MSV1_0_SETPROCESSOPTION_REQUEST, *PMSV1_0_SETPROCESSOPTION_REQUEST;


#ifdef __cplusplus
}
#endif

#endif  //_NTMSV1_0_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\ntlsa.h ===
/*++ BUILD Version: 0011    // Increment this if a change has global effects

Copyright (c) 1989-1999 Microsoft Corporation

Module Name:

    ntlsa.h

Abstract:

    This module contains the public data structures and API definitions
    needed to utilize Local Security Authority (LSA) services.

Revision History:

--*/

#ifndef _NTLSA_
#define _NTLSA_

#include <sdkddkver.h>

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef MIDL_PASS
#define SIZE_IS(x)          [size_is(x)]
#define SWITCH_IS(x)        [switch_is(x)]
#define SWITCH_TYPE(x)      [switch_type(x)]
#define CASE(x)             [case(x)]
#define RANGE(x,y)          [range(x,y)]
#define VAR_SIZE_ARRAY
#define SID_POINTER         PISID
#define REF                 [ref]
#else
#define SIZE_IS(x)
#define SWITCH_IS(x)
#define SWITCH_TYPE(x)
#define CASE(x)
#define RANGE(x,y)          __in_range(x,y)
#define VAR_SIZE_ARRAY      (1)
#define SID_POINTER         PSID
#define REF
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Generic negative values for unknown IDs, inapplicable indices etc.
//

#define LSA_UNKNOWN_ID      ((ULONG) 0xFFFFFFFFL)
#define LSA_UNKNOWN_INDEX   ((LONG) -1)

// begin_ntsecapi
#ifndef _NTLSA_IFS_
// begin_ntifs


//
// Security operation mode of the system is held in a control
// longword.
//

typedef ULONG  LSA_OPERATIONAL_MODE, *PLSA_OPERATIONAL_MODE;

// end_ntifs
#endif // _NTLSA_IFS_

//
// The flags in the security operational mode are defined
// as:
//
//    PasswordProtected - Some level of authentication (such as
//        a password) must be provided by users before they are
//        allowed to use the system.  Once set, this value will
//        not be cleared without re-booting the system.
//
//    IndividualAccounts - Each user must identify an account to
//        logon to.  This flag is only meaningful if the
//        PasswordProtected flag is also set.  If this flag is
//        not set and the PasswordProtected flag is set, then all
//        users may logon to the same account.  Once set, this value
//        will not be cleared without re-booting the system.
//
//    MandatoryAccess - Indicates the system is running in a mandatory
//        access control mode (e.g., B-level as defined by the U.S.A's
//        Department of Defense's "Orange Book").  This is not utilized
//        in the current release of NT.  This flag is only meaningful
//        if both the PasswordProtected and IndividualAccounts flags are
//        set.  Once set, this value will not be cleared without
//        re-booting the system.
//
//    LogFull - Indicates the system has been brought up in a mode in
//        which if must perform security auditing, but its audit log
//        is full.  This may (should) restrict the operations that
//        can occur until the audit log is made not-full again.  THIS
//        VALUE MAY BE CLEARED WHILE THE SYSTEM IS RUNNING (I.E., WITHOUT
//        REBOOTING).
//
// If the PasswordProtected flag is not set, then the system is running
// without security, and user interface should be adjusted appropriately.
//

#define LSA_MODE_PASSWORD_PROTECTED     (0x00000001L)
#define LSA_MODE_INDIVIDUAL_ACCOUNTS    (0x00000002L)
#define LSA_MODE_MANDATORY_ACCESS       (0x00000004L)
#define LSA_MODE_LOG_FULL               (0x00000008L)

// end_ntsecapi


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Widely used LSA defines                                             //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// Defines for Count Limits on LSA API
//

#define LSA_MAXIMUM_SID_COUNT           (0x00000100L)
#define LSA_MAXIMUM_ENUMERATION_LENGTH  (32000)

//
// Flag OR'ed into AuthenticationPackage parameter of LsaLogonUser to
// request that the license server be called upon successful logon.
//

#define LSA_CALL_LICENSE_SERVER 0x80000000


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Data types used by logon processes                                  //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

// begin_ntsecapi
#ifndef _NTLSA_IFS_
// begin_ntifs
//
// Used by a logon process to indicate what type of logon is being
// requested.
//

typedef enum _SECURITY_LOGON_TYPE {
    UndefinedLogonType = 0, // This is used to specify an undefied logon type
    Interactive = 2,      // Interactively logged on (locally or remotely)
    Network,              // Accessing system via network
    Batch,                // Started via a batch queue
    Service,              // Service started by service controller
    Proxy,                // Proxy logon
    Unlock,               // Unlock workstation
    NetworkCleartext,     // Network logon with cleartext credentials
    NewCredentials,       // Clone caller, new default credentials
    //The types below only exist in Windows XP and greater
#if (_WIN32_WINNT >= 0x0501)
    RemoteInteractive,  // Remote, yet interactive. Terminal server
    CachedInteractive,  // Try cached credentials without hitting the net.
    // The types below only exist in Windows Server 2003 and greater
#endif
#if (_WIN32_WINNT >= 0x0502)
    CachedRemoteInteractive, // Same as RemoteInteractive, this is used internally for auditing purpose
    CachedUnlock        // Cached Unlock workstation
#endif
} SECURITY_LOGON_TYPE, *PSECURITY_LOGON_TYPE;

// end_ntifs
#endif // _NTLSA_IFS_

// end_ntsecapi


//
// Security System Access Flags.  These correspond to the enumerated
// type values in SECURITY_LOGON_TYPE.
//
// IF YOU ADD A NEW LOGON TYPE HERE, ALSO ADD IT TO THE POLICY_MODE_xxx
// data definitions.
//

#define SECURITY_ACCESS_INTERACTIVE_LOGON             ((ULONG) 0x00000001L)
#define SECURITY_ACCESS_NETWORK_LOGON                 ((ULONG) 0x00000002L)
#define SECURITY_ACCESS_BATCH_LOGON                   ((ULONG) 0x00000004L)
#define SECURITY_ACCESS_SERVICE_LOGON                 ((ULONG) 0x00000010L)
#define SECURITY_ACCESS_PROXY_LOGON                   ((ULONG) 0x00000020L)
#define SECURITY_ACCESS_DENY_INTERACTIVE_LOGON        ((ULONG) 0x00000040L)
#define SECURITY_ACCESS_DENY_NETWORK_LOGON            ((ULONG) 0x00000080L)
#define SECURITY_ACCESS_DENY_BATCH_LOGON              ((ULONG) 0x00000100L)
#define SECURITY_ACCESS_DENY_SERVICE_LOGON            ((ULONG) 0x00000200L)
#define SECURITY_ACCESS_REMOTE_INTERACTIVE_LOGON      ((ULONG) 0x00000400L)
#define SECURITY_ACCESS_DENY_REMOTE_INTERACTIVE_LOGON ((ULONG) 0x00000800L)

// begin_ntddk begin_ntosp begin_wdm
// begin_ntsecapi
#ifndef _NTLSA_IFS_
// begin_ntifs

//
// All of this stuff (between the Ifndef _NTLSA_AUDIT_ and its endif) were not
// present in NTIFS prior to Windows Server 2003 SP1. All of the definitions however
// exist down to windows 2000 (except for the few exceptions noted in the code).
//

#ifndef _NTLSA_AUDIT_
#define _NTLSA_AUDIT_

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Data types related to Auditing                                      //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The following enumerated type is used between the reference monitor and
// LSA in the generation of audit messages.  It is used to indicate the
// type of data being passed as a parameter from the reference monitor
// to LSA.  LSA is responsible for transforming the specified data type
// into a set of unicode strings that are added to the event record in
// the audit log.
//

typedef enum _SE_ADT_PARAMETER_TYPE {

    SeAdtParmTypeNone = 0,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  None.
                                    //
                                    //Results in:
                                    //
                                    //  a unicode string containing "-".
                                    //
                                    //Note:  This is typically used to
                                    //       indicate that a parameter value
                                    //       was not available.
                                    //

    SeAdtParmTypeString,            //Produces 1 parameter.
                                    //Received Value:
                                    //
                                    //  Unicode String (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  No transformation.  The string
                                    //  entered into the event record as
                                    //  received.
                                    //
                                    // The Address value of the audit info
                                    // should be a pointer to a UNICODE_STRING
                                    // structure.



    SeAdtParmTypeFileSpec,          //Produces 1 parameter.
                                    //Received value:
                                    //
                                    //  Unicode string containing a file or
                                    //  directory name.
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string with the prefix of the
                                    //  file's path replaced by a drive letter
                                    //  if possible.
                                    //




    SeAdtParmTypeUlong,             //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  Ulong
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value.


    SeAdtParmTypeSid,               //Produces 1 parameter.
                                    //Received value:
                                    //
                                    //  SID (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  String representation of SID
                                    //




    SeAdtParmTypeLogonId,           //Produces 4 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Sid string
                                    //  param 2: Username string
                                    //  param 3: domain name string
                                    //  param 4: Logon ID (Luid) string


    SeAdtParmTypeNoLogonId,         //Produces 3 parameters.
                                    //Received value:
                                    //
                                    //  None.
                                    //
                                    //Results in:
                                    //
                                    //  param 1: "-"
                                    //  param 2: "-"
                                    //  param 3: "-"
                                    //  param 4: "-"
                                    //
                                    //Note:
                                    //
                                    //  This type is used when a logon ID
                                    //  is needed, but one is not available
                                    //  to pass.  For example, if an
                                    //  impersonation logon ID is expected
                                    //  but the subject is not impersonating
                                    //  anyone.
                                    //

    SeAdtParmTypeAccessMask,        //Produces 1 parameter with formatting.
                                    //Received value:
                                    //
                                    //  ACCESS_MASK followed by
                                    //  a Unicode string.  The unicode
                                    //  string contains the name of the
                                    //  type of object the access mask
                                    //  applies to.  The event's source
                                    //  further qualifies the object type.
                                    //
                                    //Results in:
                                    //
                                    //  formatted unicode string built to
                                    //  take advantage of the specified
                                    //  source's parameter message file.
                                    //
                                    //Note:
                                    //
                                    //  An access mask containing three
                                    //  access types for a Widget object
                                    //  type (defined by the Foozle source)
                                    //  might end up looking like:
                                    //
                                    //      %%1062\n\t\t%1066\n\t\t%%601
                                    //
                                    //  The %%numbers are signals to the
                                    //  event viewer to perform parameter
                                    //  substitution before display.
                                    //



    SeAdtParmTypePrivs,             //Produces 1 parameter with formatting.
                                    //Received value:
                                    //
                                    //Results in:
                                    //
                                    //  formatted unicode string similar to
                                    //  that for access types.  Each priv
                                    //  will be formatted to be displayed
                                    //  on its own line.  E.g.,
                                    //
                                    //      %%642\n\t\t%%651\n\t\t%%655
                                    //

    SeAdtParmTypeObjectTypes,       //Produces 10 parameters with formatting.
                                    //Received value:
                                    //
                                    // Produces a list a stringized GUIDS along
                                    // with information similar to that for
                                    // an access mask.

    SeAdtParmTypeHexUlong,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  Ulong
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

// In W2k this value did not exist, it was ParmTypeLUID

    SeAdtParmTypePtr,               //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  pointer
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

//
// Everything below exists only in Windows XP and greater
//

    SeAdtParmTypeTime,              //Produces 2 parameters
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // date and time.

                                    //
    SeAdtParmTypeGuid,              //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  GUID pointer
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of GUID
                                    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                                    //

//
// Everything below exists only in Windows Server 2003 and Greater
//

    SeAdtParmTypeLuid,              //
                                    //Produces 1 parameter
                                    //Received value:
                                    //
                                    // LUID
                                    //
                                    //Results in:
                                    //
                                    // Hex LUID
                                    //

    SeAdtParmTypeHexInt64,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  64 bit integer
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

    SeAdtParmTypeStringList,        //Produces 1 parameter
                                    //Received value:
                                    //
                                    // ptr to LSAP_ADT_STRING_LIST
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // concatenation of the strings in the list

    SeAdtParmTypeSidList,           //Produces 1 parameter
                                    //Received value:
                                    //
                                    // ptr to LSAP_ADT_SID_LIST
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // concatenation of the SIDs in the list

    SeAdtParmTypeDuration,          //Produces 1 parameters
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // a duration.

    SeAdtParmTypeUserAccountControl,//Produces 3 parameters
                                    //Received value:
                                    //
                                    // old and new UserAccountControl values
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representations of
                                    // the flags in UserAccountControl.
                                    // 1 - old value in hex
                                    // 2 - new value in hex
                                    // 3 - difference as strings

    SeAdtParmTypeNoUac,             //Produces 3 parameters
                                    //Received value:
                                    //
                                    // none
                                    //
                                    //Results in:
                                    //
                                    // Three dashes ('-') as unicode strings.

    SeAdtParmTypeMessage,           //Produces 1 Parameter
                                    //Received value:
                                    //
                                    //  ULONG (MessageNo from msobjs.mc)
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // %%MessageNo which the event viewer
                                    // will replace with the message string
                                    // from msobjs.mc

    SeAdtParmTypeDateTime,          //Produces 1 Parameter
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // date and time (in _one_ string).

    SeAdtParmTypeSockAddr,          // Produces 2 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SOCKADDR_IN/SOCKADDR_IN6
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // param 1: IP address string
                                    // param 2: Port number string
                                    //

//
// Everything below this exists only in Longhorn and greater
//

    SeAdtParmTypeSD,                // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SECURITY_DESCRIPTOR
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // SDDL string representation of SD
                                    //

    SeAdtParmTypeLogonHours,        // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to LOGON_HOURS
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // String representation of allowed logon hours
                                    //

    SeAdtParmTypeLogonIdNoSid,      //Produces 3 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Username string
                                    //  param 2: domain name string
                                    //  param 3: Logon ID (Luid) string

    SeAdtParmTypeUlongNoConv,       // Produces 1 parameter.
                                    // Received Value:
                                    // Ulong
                                    //
                                    //Results in:
                                    // Not converted to string
                                    //

    SeAdtParmTypeSockAddrNoPort     // Produces 1 parameter
                                    //
                                    // Received value:
                                    //
                                    // pointer to SOCKADDR_IN/SOCKADDR_IN6
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // param 1: IPv4/IPv6 address string
                                    //

} SE_ADT_PARAMETER_TYPE, *PSE_ADT_PARAMETER_TYPE;

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

typedef struct _SE_ADT_OBJECT_TYPE {
    GUID ObjectType;
    USHORT Flags;
#define SE_ADT_OBJECT_ONLY 0x1
    USHORT Level;
    ACCESS_MASK AccessMask;
} SE_ADT_OBJECT_TYPE, *PSE_ADT_OBJECT_TYPE;

typedef struct _SE_ADT_PARAMETER_ARRAY_ENTRY {

    SE_ADT_PARAMETER_TYPE Type;
    ULONG Length;
    ULONG_PTR Data[2];
    PVOID Address;

} SE_ADT_PARAMETER_ARRAY_ENTRY, *PSE_ADT_PARAMETER_ARRAY_ENTRY;



//
// Structure that will be passed between the Reference Monitor and LSA
// to transmit auditing information.
//

#define SE_MAX_AUDIT_PARAMETERS 32
#define SE_MAX_GENERIC_AUDIT_PARAMETERS 28

typedef struct _SE_ADT_PARAMETER_ARRAY {

    ULONG CategoryId;
    ULONG AuditId;
    ULONG ParameterCount;
    ULONG Length;
    USHORT FlatSubCategoryId;
    USHORT Type;
    ULONG Flags;
    SE_ADT_PARAMETER_ARRAY_ENTRY Parameters[ SE_MAX_AUDIT_PARAMETERS ];

} SE_ADT_PARAMETER_ARRAY, *PSE_ADT_PARAMETER_ARRAY;


#define SE_ADT_PARAMETERS_SELF_RELATIVE     0x00000001
#define SE_ADT_PARAMETERS_SEND_TO_LSA       0x00000002
#define SE_ADT_PARAMETER_EXTENSIBLE_AUDIT   0x00000004
#define SE_ADT_PARAMETER_GENERIC_AUDIT      0x00000008
#define SE_ADT_PARAMETER_WRITE_SYNCHRONOUS  0x00000010


//
// This macro only existed in longhorn and after
//

#define LSAP_SE_ADT_PARAMETER_ARRAY_TRUE_SIZE(AuditParameters)    \
     ( sizeof(SE_ADT_PARAMETER_ARRAY) -                           \
       sizeof(SE_ADT_PARAMETER_ARRAY_ENTRY) *                     \
       (SE_MAX_AUDIT_PARAMETERS - AuditParameters->ParameterCount) )

#endif // _NTLSA_AUDIT_

// end_ntifs
#endif // _NTLSA_IFS_
// end_ntsecapi
// end_ntddk end_ntosp end_wdm

///////////////////////////////////////////////////////////////////////////
//                                                                       //
// Structures describing the complex param type SeAdtParmTypeStringList  //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

typedef struct _LSA_ADT_STRING_LIST_ENTRY
{
    ULONG                       Flags;
    UNICODE_STRING              String;
}
LSA_ADT_STRING_LIST_ENTRY, *PLSA_ADT_STRING_LIST_ENTRY;

typedef struct _LSA_ADT_STRING_LIST
{
    ULONG                       cStrings;
    PLSA_ADT_STRING_LIST_ENTRY  Strings;
}
LSA_ADT_STRING_LIST, *PLSA_ADT_STRING_LIST;


///////////////////////////////////////////////////////////////////////////
//                                                                       //
// Structures describing the complex param type SeAdtParmTypeSidList     //
//                                                                       //
///////////////////////////////////////////////////////////////////////////

typedef struct _LSA_ADT_SID_LIST_ENTRY
{
    ULONG                       Flags;
    PSID                        Sid;
}
LSA_ADT_SID_LIST_ENTRY, *PLSA_ADT_SID_LIST_ENTRY;

typedef struct _LSA_ADT_SID_LIST
{
    ULONG                       cSids;
    PLSA_ADT_SID_LIST_ENTRY     Sids;
}
LSA_ADT_SID_LIST, *PLSA_ADT_SID_LIST;



//
// The security source name
//

#define LSA_ADT_SECURITY_SOURCE_NAME L"Microsoft-Windows-Security-Auditing"

//
// The legacy source name
//

#define LSA_ADT_LEGACY_SECURITY_SOURCE_NAME L"Security"



//
// The count will begin at SE_ADT_POLICY_AUDIT_EVENT_TYPE_EX_BEGIN. This
// allows distinguishing the former categories (represented by
// POLICY_AUDIT_EVENT_TYPE) with the new categories/sub-categories
// audit events information
//

#define SE_ADT_POLICY_AUDIT_EVENT_TYPE_EX_BEGIN         100


//
// Changes to make when adding a new sub-category
// a) Add new sub-category at the end of a category in POLICY_AUDIT_EVENT_TYPE_EX
// b) Define new GUID (next guid ID in sequence) and add it to adtapi.w
// c) Add new sub-category to LsapAdtGuidToIdMapping in adtapi.c. Make sure GUID is added in
//        sequential order
// d) Update per-category count in ntrmlsa.w
// e) Add textual description for the new sub-category to msobjs.mc
// f) Add a task for this subcategory in MsAuditEvtLog.man. The task ID should be the same as the 
//    SubCategory ID defined in step a).
// g) Update LSAP_ADT_START_CATEGORY_ID_IN_MSOBJS and/or LSAP_ADT_START_SUB_CATEGORY_ID_IN_MSOBJS
//        if necessary.
// h) Update the subcategory count in base\published\ntseapi_x.w (POLICY_AUDIT_SUBCATEGORY_COUNT). This 
//    is necessary because base\wow64 compilation fails if we ask the compiler to compute 
//    the count via (((ULONG) AuditSubCategoryMaxType - AuditSubCategoryMinType + 1))
// i) Update AuditSubCategoryMaxType (in ntrmlsa.w) if necessary.
//


//
// Internally, the audit categories and sub-categories are treated
// just as categogies.
// IMPORTANT NOTE: Keep this in sync with the list beginning
// at POLICY_AUDIT_SYSTEM_SUBCATEGORIES in this file. Also update
// the per sub-category counts in ntrmlsa.w
//

typedef enum _POLICY_AUDIT_EVENT_TYPE_EX {

    iSystem_SecurityStateChange = SE_ADT_POLICY_AUDIT_EVENT_TYPE_EX_BEGIN,
    iSystem_SecuritySubsystemExtension,
    iSystem_Integrity,
    iSystem_IPSecDriverEvents,
    iSystem_Others,

    iLogon_Logon,
    iLogon_Logoff,
    iLogon_AccountLockout,
    iLogon_IPSecMainMode,
    iLogon_SpecialLogon,
    iLogon_IPSecQuickMode,
    iLogon_IPSecUsermode,
    iLogon_Others,
    iLogon_NPS,

    iObjectAccess_FileSystem,
    iObjectAccess_Registry,
    iObjectAccess_Kernel,
    iObjectAccess_Sam,
    iObjectAccess_Other,
    iObjectAccess_CertificationAuthority,
    iObjectAccess_ApplicationGenerated,
    iObjectAccess_HandleBasedAudits,
    iObjectAccess_Share,
    iObjectAccess_FirewallPacketDrops,
    iObjectAccess_FirewallConnection,

    iPrivilegeUse_Sensitive,
    iPrivilegeUse_NonSensitive,
    iPrivilegeUse_Others,

    iDetailedTracking_ProcessCreation,
    iDetailedTracking_ProcessTermination,
    iDetailedTracking_DpapiActivity,
    iDetailedTracking_RpcCall,

    iPolicyChange_AuditPolicy,
    iPolicyChange_AuthenticationPolicy,
    iPolicyChange_AuthorizationPolicy,
    iPolicyChange_MpsscvRulePolicy,
    iPolicyChange_WfpIPSecPolicy,
    iPolicyChange_Others,

    iAccountManagement_UserAccount,
    iAccountManagement_ComputerAccount,
    iAccountManagement_SecurityGroup,
    iAccountManagement_DistributionGroup,
    iAccountManagement_ApplicationGroup,
    iAccountManagement_Others,

    iDSAccess_DSAccess,
    iDSAccess_AdAuditChanges,
    iDS_Replication,
    iDS_DetailedReplication,

    iAccountLogon_CredentialValidation,
    iAccountLogon_Kerberos,
    iAccountLogon_Others,
    iAccountLogon_KerbCredentialValidation,

    iUnknownSubCategory = 999

} POLICY_AUDIT_EVENT_TYPE_EX, *PPOLICY_AUDIT_EVENT_TYPE_EX;

// begin_ntsecapi

//
// Audit Event Categories
//
// The following are the built-in types or Categories of audit event.
// WARNING!  This structure is subject to expansion.  The user should not
// compute the number of elements of this type directly, but instead
// should obtain the count of elements by calling LsaQueryInformationPolicy()
// for the PolicyAuditEventsInformation class and extracting the count from
// the MaximumAuditEventCount field of the returned structure.
//

typedef enum _POLICY_AUDIT_EVENT_TYPE {

    AuditCategorySystem = 0,
    AuditCategoryLogon,
    AuditCategoryObjectAccess,
    AuditCategoryPrivilegeUse,
    AuditCategoryDetailedTracking,
    AuditCategoryPolicyChange,
    AuditCategoryAccountManagement,
    AuditCategoryDirectoryServiceAccess,
    AuditCategoryAccountLogon

} POLICY_AUDIT_EVENT_TYPE, *PPOLICY_AUDIT_EVENT_TYPE;


//
// The following defines describe the auditing options for each
// event type
//

// Leave options specified for this event unchanged

#define POLICY_AUDIT_EVENT_UNCHANGED       (0x00000000L)

// Audit successful occurrences of events of this type

#define POLICY_AUDIT_EVENT_SUCCESS         (0x00000001L)

// Audit failed attempts to cause an event of this type to occur

#define POLICY_AUDIT_EVENT_FAILURE         (0x00000002L)

#define POLICY_AUDIT_EVENT_NONE            (0x00000004L)

// Mask of valid event auditing options

#define POLICY_AUDIT_EVENT_MASK \
    (POLICY_AUDIT_EVENT_SUCCESS | \
     POLICY_AUDIT_EVENT_FAILURE | \
     POLICY_AUDIT_EVENT_UNCHANGED | \
     POLICY_AUDIT_EVENT_NONE)


#ifdef _NTDEF_
// begin_ntifs
typedef UNICODE_STRING LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;
typedef STRING LSA_STRING, *PLSA_STRING;
typedef OBJECT_ATTRIBUTES LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;
// end_ntifs
#else // _NTDEF_

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif


typedef struct _LSA_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength/2), length_is(Length/2)]
#endif // MIDL_PASS
    PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;

typedef struct _LSA_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} LSA_STRING, *PLSA_STRING;

typedef struct _LSA_OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PLSA_UNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;



#endif // _NTDEF_
// end_ntsecapi

// begin_ntsecapi

//
// Macro for determining whether an API succeeded.
//

#define LSA_SUCCESS(Error) ((LONG)(Error) >= 0)

// end_ntsecapi



/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Services provided for use by logon processes                        //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

// begin_ntsecapi
#ifndef _NTLSA_IFS_
// begin_ntifs

NTSTATUS
NTAPI
LsaRegisterLogonProcess (
    __in PLSA_STRING LogonProcessName,
    __out PHANDLE LsaHandle,
    __out PLSA_OPERATIONAL_MODE SecurityMode
    );

//
// The function below did not exist in NTIFS before windows XP
// However, the function has always been there, so it is okay to use
// even on w2k
//

NTSTATUS
NTAPI
LsaLogonUser (
    __in HANDLE LsaHandle,
    __in PLSA_STRING OriginName,
    __in SECURITY_LOGON_TYPE LogonType,
    __in ULONG AuthenticationPackage,
    __in_bcount(AuthenticationInformationLength) PVOID AuthenticationInformation,
    __in ULONG AuthenticationInformationLength,
    __in_opt PTOKEN_GROUPS LocalGroups,
    __in PTOKEN_SOURCE SourceContext,
    __out PVOID *ProfileBuffer,
    __out PULONG ProfileBufferLength,
    __out PLUID LogonId,
    __out PHANDLE Token,
    __out PQUOTA_LIMITS Quotas,
    __out PNTSTATUS SubStatus
    );


// end_ntifs

NTSTATUS
NTAPI
LsaLookupAuthenticationPackage (
    __in HANDLE LsaHandle,
    __in PLSA_STRING PackageName,
    __out PULONG AuthenticationPackage
    );

// begin_ntifs

NTSTATUS
NTAPI
LsaFreeReturnBuffer (
    __in PVOID Buffer
    );

// end_ntifs

NTSTATUS
NTAPI
LsaCallAuthenticationPackage (
    __in HANDLE LsaHandle,
    __in ULONG AuthenticationPackage,
    __in_bcount(SubmitBufferLength) PVOID ProtocolSubmitBuffer,
    __in ULONG SubmitBufferLength,
    __out_opt PVOID *ProtocolReturnBuffer,
    __out_opt PULONG ReturnBufferLength,
    __out_opt PNTSTATUS ProtocolStatus
    );


NTSTATUS
NTAPI
LsaDeregisterLogonProcess (
    __in HANDLE LsaHandle
    );

NTSTATUS
NTAPI
LsaConnectUntrusted (
    __out PHANDLE LsaHandle
    );

#endif // _NTLSA_IFS_

// end_ntsecapi

typedef NTSTATUS
(NTAPI *PFN_LSA_CALL_AUTH_PKG) (
    __in HANDLE LsaHandle,
    __in ULONG AuthenticationPackage,
    __in_bcount(SubmitBufferLength) PVOID ProtocolSubmitBuffer,
    __in ULONG SubmitBufferLength,
    __out_opt PVOID *ProtocolReturnBuffer,
    __out_opt PULONG ReturnBufferLength,
    __out_opt PNTSTATUS ProtocolStatus
    );

typedef NTSTATUS
(NTAPI *PFN_LSA_DEREGISTER_PROC) (
    __in HANDLE LsaHandle
    );

typedef NTSTATUS
(NTAPI *PFN_LSA_FREE_BUFFER) (
    __in PVOID Buffer
    );

typedef NTSTATUS
(NTAPI *PFN_LSA_LOGON_USER) (
    __in HANDLE LsaHandle,
    __in PLSA_STRING OriginName,
    __in SECURITY_LOGON_TYPE LogonType,
    __in ULONG AuthenticationPackage,
    __in_bcount(AuthenticationInformationLength) PVOID AuthenticationInformation,
    __in ULONG AuthenticationInformationLength,
    __in_opt PTOKEN_GROUPS LocalGroups,
    __in PTOKEN_SOURCE SourceContext,
    __out PVOID *ProfileBuffer,
    __out PULONG ProfileBufferLength,
    __out PLUID LogonId,
    __out PHANDLE Token,
    __out PQUOTA_LIMITS Quotas,
    __out PNTSTATUS SubStatus
    );

typedef NTSTATUS
(NTAPI *PFN_LOOKUP_AUTH_PKG) (
    __in HANDLE LsaHandle,
    __in PLSA_STRING PackageName,
    __out PULONG AuthenticationPackage
    );

typedef NTSTATUS
(NTAPI *PFN_LSA_REGISTER_PROC) (
    __in PLSA_STRING LogonProcessName,
    __out PHANDLE LsaHandle,
    __out PLSA_OPERATIONAL_MODE SecurityMode
    );

typedef struct _LSA_AUTH_CALLBACKS {
    PFN_LSA_CALL_AUTH_PKG       LsaCallAuthPkgFn;  
    PFN_LSA_DEREGISTER_PROC     LsaDeregisterProcFn;
    PFN_LSA_FREE_BUFFER         LsaFreeReturnBufferFn;
    PFN_LSA_LOGON_USER          LsaLogonUserFn;
    PFN_LOOKUP_AUTH_PKG         LsaLookupAuthPkgFn;
    PFN_LSA_REGISTER_PROC       LsaRegisterProcFn;
} LSA_AUTH_CALLBACKS, *PLSA_AUTH_CALLBACKS;

typedef CONST LSA_AUTH_CALLBACKS *PCLSA_AUTH_CALLBACKS;

// begin_ntsecpkg

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Data types used by authentication packages                          //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

//
// opaque data type which represents a client request
//

typedef PVOID *PLSA_CLIENT_REQUEST;


//
// When a logon of a user is requested, the authentication package
// is expected to return one of the following structures indicating
// the contents of a user's token.
//

typedef enum _LSA_TOKEN_INFORMATION_TYPE {
    LsaTokenInformationNull,  // Implies LSA_TOKEN_INFORMATION_NULL data type
    LsaTokenInformationV1,     // Implies LSA_TOKEN_INFORMATION_V1 data type
    LsaTokenInformationV2     // Implies LSA_TOKEN_INFORMATION_V2 data type
} LSA_TOKEN_INFORMATION_TYPE, *PLSA_TOKEN_INFORMATION_TYPE;


//
// The NULL information is used in cases where a non-authenticated
// system access is needed.  For example, a non-authentication network
// circuit (such as LAN Manager's null session) can be given NULL
// information.  This will result in an anonymous token being generated
// for the logon that gives the user no ability to access protected system
// resources, but does allow access to non-protected system resources.
//

typedef struct _LSA_TOKEN_INFORMATION_NULL {

    //
    // Time at which the security context becomes invalid.
    // Use a value in the distant future if the context
    // never expires.
    //

    LARGE_INTEGER ExpirationTime;

    //
    // The SID(s) of groups the user is to be made a member of.  This should
    // not include WORLD or other system defined and assigned
    // SIDs.  These will be added automatically by LSA.
    //
    // Each SID is expected to be in a separately allocated block
    // of memory.  The TOKEN_GROUPS structure is also expected to
    // be in a separately allocated block of memory.
    //

    PTOKEN_GROUPS Groups;

} LSA_TOKEN_INFORMATION_NULL, *PLSA_TOKEN_INFORMATION_NULL;


//
// The V1 token information structure is superceeded by the V2 token
// information structure.  The V1 strucure should only be used for
// backwards compatability.
// This structure contains information that an authentication package
// can place in a Version 1 NT token object.
//

typedef struct _LSA_TOKEN_INFORMATION_V1 {

    //
    // Time at which the security context becomes invalid.
    // Use a value in the distant future if the context
    // never expires.
    //

    LARGE_INTEGER ExpirationTime;

    //
    // The SID of the user logging on.  The SID value is in a
    // separately allocated block of memory.
    //

    TOKEN_USER User;

    //
    // The SID(s) of groups the user is a member of.  This should
    // not include WORLD or other system defined and assigned
    // SIDs.  These will be added automatically by LSA.
    //
    // Each SID is expected to be in a separately allocated block
    // of memory.  The TOKEN_GROUPS structure is also expected to
    // be in a separately allocated block of memory.
    //

    PTOKEN_GROUPS Groups;

    //
    // This field is used to establish the primary group of the user.
    // This value does not have to correspond to one of the SIDs
    // assigned to the user.
    //
    // The SID pointed to by this structure is expected to be in
    // a separately allocated block of memory.
    //
    // This field is mandatory and must be filled in.
    //

    TOKEN_PRIMARY_GROUP PrimaryGroup;



    //
    // The privileges the user is assigned.  This list of privileges
    // will be augmented or over-ridden by any local security policy
    // assigned privileges.
    //
    // Each privilege is expected to be in a separately allocated
    // block of memory.  The TOKEN_PRIVILEGES structure is also
    // expected to be in a separately allocated block of memory.
    //
    // If there are no privileges to assign to the user, this field
    // may be set to NULL.
    //

    PTOKEN_PRIVILEGES Privileges;



    //
    // This field may be used to establish an explicit default
    // owner.  Normally, the user ID is used as the default owner.
    // If another value is desired, it must be specified here.
    //
    // The Owner.Sid field may be set to NULL to indicate there is no
    // alternate default owner value.
    //

    TOKEN_OWNER Owner;

    //
    // This field may be used to establish a default
    // protection for the user.  If no value is provided, then
    // a default protection that grants everyone all access will
    // be established.
    //
    // The DefaultDacl.DefaultDacl field may be set to NULL to indicate
    // there is no default protection.
    //

    TOKEN_DEFAULT_DACL DefaultDacl;

} LSA_TOKEN_INFORMATION_V1, *PLSA_TOKEN_INFORMATION_V1;

//
// The V2 information is used in most cases of logon.  The structure is identical
// to the V1 token information structure, with the exception that the memory allocation
// is handled differently.  The LSA_TOKEN_INFORMATION_V2 structure is intended to be
// allocated monolithiclly, with the privileges, DACL, sids, and group array either part of
// same allocation, or allocated and freed externally.
//

typedef LSA_TOKEN_INFORMATION_V1 LSA_TOKEN_INFORMATION_V2, *PLSA_TOKEN_INFORMATION_V2;


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Interface definitions available for use by authentication packages  //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



typedef NTSTATUS
(NTAPI LSA_CREATE_LOGON_SESSION) (
    IN PLUID LogonId
    );

typedef NTSTATUS
(NTAPI LSA_DELETE_LOGON_SESSION) (
    IN PLUID LogonId
    );

typedef NTSTATUS
(NTAPI LSA_ADD_CREDENTIAL) (
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN PLSA_STRING PrimaryKeyValue,
    IN PLSA_STRING Credentials
    );

typedef NTSTATUS
(NTAPI LSA_GET_CREDENTIALS) (
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN OUT PULONG QueryContext,
    IN BOOLEAN RetrieveAllCredentials,
    IN PLSA_STRING PrimaryKeyValue,
    OUT PULONG PrimaryKeyLength,
    IN PLSA_STRING Credentials
    );

typedef NTSTATUS
(NTAPI LSA_DELETE_CREDENTIAL) (
    IN PLUID LogonId,
    IN ULONG AuthenticationPackage,
    IN PLSA_STRING PrimaryKeyValue
    );

typedef PVOID
(NTAPI LSA_ALLOCATE_LSA_HEAP) (
    IN ULONG Length
    );

typedef VOID
(NTAPI LSA_FREE_LSA_HEAP) (
    IN PVOID Base
    );

typedef PVOID
(NTAPI LSA_ALLOCATE_PRIVATE_HEAP) (
    IN SIZE_T Length
    );

typedef VOID
(NTAPI LSA_FREE_PRIVATE_HEAP) (
    IN PVOID Base
    );

typedef NTSTATUS
(NTAPI LSA_ALLOCATE_CLIENT_BUFFER) (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG LengthRequired,
    OUT PVOID *ClientBaseAddress
    );

typedef NTSTATUS
(NTAPI LSA_FREE_CLIENT_BUFFER) (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ClientBaseAddress
    );

typedef NTSTATUS
(NTAPI LSA_COPY_TO_CLIENT_BUFFER) (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID ClientBaseAddress,
    IN PVOID BufferToCopy
    );

typedef NTSTATUS
(NTAPI LSA_COPY_FROM_CLIENT_BUFFER) (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN ULONG Length,
    IN PVOID BufferToCopy,
    IN PVOID ClientBaseAddress
    );

typedef LSA_CREATE_LOGON_SESSION * PLSA_CREATE_LOGON_SESSION;
typedef LSA_DELETE_LOGON_SESSION * PLSA_DELETE_LOGON_SESSION;
typedef LSA_ADD_CREDENTIAL * PLSA_ADD_CREDENTIAL;
typedef LSA_GET_CREDENTIALS * PLSA_GET_CREDENTIALS;
typedef LSA_DELETE_CREDENTIAL * PLSA_DELETE_CREDENTIAL;
typedef LSA_ALLOCATE_LSA_HEAP * PLSA_ALLOCATE_LSA_HEAP;
typedef LSA_FREE_LSA_HEAP * PLSA_FREE_LSA_HEAP;
typedef LSA_ALLOCATE_PRIVATE_HEAP * PLSA_ALLOCATE_PRIVATE_HEAP;
typedef LSA_FREE_PRIVATE_HEAP * PLSA_FREE_PRIVATE_HEAP;
typedef LSA_ALLOCATE_CLIENT_BUFFER * PLSA_ALLOCATE_CLIENT_BUFFER;
typedef LSA_FREE_CLIENT_BUFFER * PLSA_FREE_CLIENT_BUFFER;
typedef LSA_COPY_TO_CLIENT_BUFFER * PLSA_COPY_TO_CLIENT_BUFFER;
typedef LSA_COPY_FROM_CLIENT_BUFFER * PLSA_COPY_FROM_CLIENT_BUFFER;

//
// The dispatch table of LSA services which are available to
// authentication packages.
//
typedef struct _LSA_DISPATCH_TABLE {
    PLSA_CREATE_LOGON_SESSION CreateLogonSession;
    PLSA_DELETE_LOGON_SESSION DeleteLogonSession;
    PLSA_ADD_CREDENTIAL AddCredential;
    PLSA_GET_CREDENTIALS GetCredentials;
    PLSA_DELETE_CREDENTIAL DeleteCredential;
    PLSA_ALLOCATE_LSA_HEAP AllocateLsaHeap;
    PLSA_FREE_LSA_HEAP FreeLsaHeap;
    PLSA_ALLOCATE_CLIENT_BUFFER AllocateClientBuffer;
    PLSA_FREE_CLIENT_BUFFER FreeClientBuffer;
    PLSA_COPY_TO_CLIENT_BUFFER CopyToClientBuffer;
    PLSA_COPY_FROM_CLIENT_BUFFER CopyFromClientBuffer;
} LSA_DISPATCH_TABLE, *PLSA_DISPATCH_TABLE;



////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Interface definitions of services provided by authentication packages  //
//                                                                        //
////////////////////////////////////////////////////////////////////////////



//
// Routine names
//
// The routines provided by the DLL must be assigned the following names
// so that their addresses can be retrieved when the DLL is loaded.
//

#define LSA_AP_NAME_INITIALIZE_PACKAGE      "LsaApInitializePackage\0"
#define LSA_AP_NAME_LOGON_USER              "LsaApLogonUser\0"
#define LSA_AP_NAME_LOGON_USER_EX           "LsaApLogonUserEx\0"
#define LSA_AP_NAME_CALL_PACKAGE            "LsaApCallPackage\0"
#define LSA_AP_NAME_LOGON_TERMINATED        "LsaApLogonTerminated\0"
#define LSA_AP_NAME_CALL_PACKAGE_UNTRUSTED  "LsaApCallPackageUntrusted\0"
#define LSA_AP_NAME_CALL_PACKAGE_PASSTHROUGH "LsaApCallPackagePassthrough\0"


//
// Routine templates
//


typedef NTSTATUS
(NTAPI LSA_AP_INITIALIZE_PACKAGE) (
    IN ULONG AuthenticationPackageId,
    IN PLSA_DISPATCH_TABLE LsaDispatchTable,
    IN PLSA_STRING Database OPTIONAL,
    IN PLSA_STRING Confidentiality OPTIONAL,
    OUT PLSA_STRING *AuthenticationPackageName
    );

typedef NTSTATUS
(NTAPI LSA_AP_LOGON_USER) (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthenticationInformation,
    IN PVOID ClientAuthenticationBase,
    IN ULONG AuthenticationInformationLength,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PLSA_UNICODE_STRING *AccountName,
    OUT PLSA_UNICODE_STRING *AuthenticatingAuthority
    );

typedef NTSTATUS
(NTAPI LSA_AP_LOGON_USER_EX) (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN SECURITY_LOGON_TYPE LogonType,
    IN PVOID AuthenticationInformation,
    IN PVOID ClientAuthenticationBase,
    IN ULONG AuthenticationInformationLength,
    OUT PVOID *ProfileBuffer,
    OUT PULONG ProfileBufferLength,
    OUT PLUID LogonId,
    OUT PNTSTATUS SubStatus,
    OUT PLSA_TOKEN_INFORMATION_TYPE TokenInformationType,
    OUT PVOID *TokenInformation,
    OUT PUNICODE_STRING *AccountName,
    OUT PUNICODE_STRING *AuthenticatingAuthority,
    OUT PUNICODE_STRING *MachineName
    );

typedef NTSTATUS
(NTAPI LSA_AP_CALL_PACKAGE) (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

typedef NTSTATUS
(NTAPI LSA_AP_CALL_PACKAGE_PASSTHROUGH) (
    IN PLSA_CLIENT_REQUEST ClientRequest,
    IN PVOID ProtocolSubmitBuffer,
    IN PVOID ClientBufferBase,
    IN ULONG SubmitBufferLength,
    OUT PVOID *ProtocolReturnBuffer,
    OUT PULONG ReturnBufferLength,
    OUT PNTSTATUS ProtocolStatus
    );

typedef VOID
(NTAPI LSA_AP_LOGON_TERMINATED) (
    IN PLUID LogonId
    );

typedef LSA_AP_CALL_PACKAGE LSA_AP_CALL_PACKAGE_UNTRUSTED;

typedef LSA_AP_INITIALIZE_PACKAGE * PLSA_AP_INITIALIZE_PACKAGE;
typedef LSA_AP_LOGON_USER * PLSA_AP_LOGON_USER;
typedef LSA_AP_LOGON_USER_EX * PLSA_AP_LOGON_USER_EX;
typedef LSA_AP_CALL_PACKAGE * PLSA_AP_CALL_PACKAGE;
typedef LSA_AP_CALL_PACKAGE_PASSTHROUGH * PLSA_AP_CALL_PACKAGE_PASSTHROUGH;
typedef LSA_AP_LOGON_TERMINATED * PLSA_AP_LOGON_TERMINATED;
typedef LSA_AP_CALL_PACKAGE_UNTRUSTED * PLSA_AP_CALL_PACKAGE_UNTRUSTED;

// end_ntsecpkg
// begin_ntsecapi

////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy Administration API datatypes and defines         //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

//
// Access types for the Policy object
//

#define POLICY_VIEW_LOCAL_INFORMATION              0x00000001L
#define POLICY_VIEW_AUDIT_INFORMATION              0x00000002L
#define POLICY_GET_PRIVATE_INFORMATION             0x00000004L
#define POLICY_TRUST_ADMIN                         0x00000008L
#define POLICY_CREATE_ACCOUNT                      0x00000010L
#define POLICY_CREATE_SECRET                       0x00000020L
#define POLICY_CREATE_PRIVILEGE                    0x00000040L
#define POLICY_SET_DEFAULT_QUOTA_LIMITS            0x00000080L
#define POLICY_SET_AUDIT_REQUIREMENTS              0x00000100L
#define POLICY_AUDIT_LOG_ADMIN                     0x00000200L
#define POLICY_SERVER_ADMIN                        0x00000400L
#define POLICY_LOOKUP_NAMES                        0x00000800L
#define POLICY_NOTIFICATION                        0x00001000L

#define POLICY_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED         |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_VIEW_AUDIT_INFORMATION    |\
                               POLICY_GET_PRIVATE_INFORMATION   |\
                               POLICY_TRUST_ADMIN               |\
                               POLICY_CREATE_ACCOUNT            |\
                               POLICY_CREATE_SECRET             |\
                               POLICY_CREATE_PRIVILEGE          |\
                               POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                               POLICY_SET_AUDIT_REQUIREMENTS    |\
                               POLICY_AUDIT_LOG_ADMIN           |\
                               POLICY_SERVER_ADMIN              |\
                               POLICY_LOOKUP_NAMES)


#define POLICY_READ           (STANDARD_RIGHTS_READ             |\
                               POLICY_VIEW_AUDIT_INFORMATION    |\
                               POLICY_GET_PRIVATE_INFORMATION)

#define POLICY_WRITE          (STANDARD_RIGHTS_WRITE            |\
                               POLICY_TRUST_ADMIN               |\
                               POLICY_CREATE_ACCOUNT            |\
                               POLICY_CREATE_SECRET             |\
                               POLICY_CREATE_PRIVILEGE          |\
                               POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                               POLICY_SET_AUDIT_REQUIREMENTS    |\
                               POLICY_AUDIT_LOG_ADMIN           |\
                               POLICY_SERVER_ADMIN)

#define POLICY_EXECUTE        (STANDARD_RIGHTS_EXECUTE          |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_LOOKUP_NAMES)


//
// Policy object specific data types.
//

//
// The following data type is used to identify a domain
//

typedef struct _LSA_TRUST_INFORMATION {

    LSA_UNICODE_STRING Name;
    PSID Sid;

} LSA_TRUST_INFORMATION, *PLSA_TRUST_INFORMATION;

// where members have the following usage:
//
//     Name - The name of the domain.
//
//     Sid - A pointer to the Sid of the Domain
//

//
// The following data type is used in name and SID lookup services to
// describe the domains referenced in the lookup operation.
//

typedef struct _LSA_REFERENCED_DOMAIN_LIST {

    ULONG Entries;
    PLSA_TRUST_INFORMATION Domains;

} LSA_REFERENCED_DOMAIN_LIST, *PLSA_REFERENCED_DOMAIN_LIST;

// where members have the following usage:
//
//     Entries - Is a count of the number of domains described in the
//         Domains array.
//
//     Domains - Is a pointer to an array of Entries LSA_TRUST_INFORMATION data
//         structures.
//


//
// The following data type is used in name to SID lookup services to describe
// the domains referenced in the lookup operation.
//

typedef struct _LSA_TRANSLATED_SID {

    SID_NAME_USE Use;
    ULONG RelativeId;
    LONG DomainIndex;

} LSA_TRANSLATED_SID, *PLSA_TRANSLATED_SID;

// where members have the following usage:
//
//     Use - identifies the use of the SID.  If this value is SidUnknown or
//         SidInvalid, then the remainder of the record is not set and
//         should be ignored.
//
//     RelativeId - Contains the relative ID of the translated SID.  The
//         remainder of the SID (the prefix) is obtained using the
//         DomainIndex field.
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the
//         domain in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//

#if (_WIN32_WINNT >= 0x0501)
typedef struct _LSA_TRANSLATED_SID2 {

    SID_NAME_USE Use;
    PSID         Sid;
    LONG         DomainIndex;
    ULONG        Flags;

} LSA_TRANSLATED_SID2, *PLSA_TRANSLATED_SID2;

// where members have the following usage:
//
//     Use - identifies the use of the SID.  If this value is SidUnknown or
//         SidInvalid, then the remainder of the record is not set and
//         should be ignored.
//
//     Sid - Contains the complete Sid of the tranlated SID
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the
//         domain in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//
#endif

//
// The following data type is used in SID to name lookup services to
// describe the domains referenced in the lookup operation.
//

typedef struct _LSA_TRANSLATED_NAME {

    SID_NAME_USE Use;
    LSA_UNICODE_STRING Name;
    LONG DomainIndex;

} LSA_TRANSLATED_NAME, *PLSA_TRANSLATED_NAME;

// where the members have the following usage:
//
//     Use - Identifies the use of the name.  If this value is SidUnknown
//         or SidInvalid, then the remainder of the record is not set and
//         should be ignored.  If this value is SidWellKnownGroup then the
//         Name field is invalid, but the DomainIndex field is not.
//
//     Name - Contains the isolated name of the translated SID.
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the domain
//         in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//

// end_ntsecapi

//
// The following data type specifies the ways in which a user or member of
// an alias or group may be allowed to access the system.  An account may
// be granted zero or more of these types of access to the system.
//
// The types of access are:
//
//     Interactive - The user or alias/group member may interactively logon
//         to the system.
//
//     Network - The user or alias/group member may access the system via
//         the network (e.g., through shares).
//
//     Service - The user or alias may be activated as a service on the
//         system.
//

typedef ULONG POLICY_SYSTEM_ACCESS_MODE, *PPOLICY_SYSTEM_ACCESS_MODE;

#define POLICY_MODE_INTERACTIVE             SECURITY_ACCESS_INTERACTIVE_LOGON
#define POLICY_MODE_NETWORK                 SECURITY_ACCESS_NETWORK_LOGON
#define POLICY_MODE_BATCH                   SECURITY_ACCESS_BATCH_LOGON
#define POLICY_MODE_SERVICE                 SECURITY_ACCESS_SERVICE_LOGON
#define POLICY_MODE_PROXY                   SECURITY_ACCESS_PROXY_LOGON
#define POLICY_MODE_DENY_INTERACTIVE        SECURITY_ACCESS_DENY_INTERACTIVE_LOGON
#define POLICY_MODE_DENY_NETWORK            SECURITY_ACCESS_DENY_NETWORK_LOGON
#define POLICY_MODE_DENY_BATCH              SECURITY_ACCESS_DENY_BATCH_LOGON
#define POLICY_MODE_DENY_SERVICE            SECURITY_ACCESS_DENY_SERVICE_LOGON
#define POLICY_MODE_REMOTE_INTERACTIVE      SECURITY_ACCESS_REMOTE_INTERACTIVE_LOGON
#define POLICY_MODE_DENY_REMOTE_INTERACTIVE SECURITY_ACCESS_DENY_REMOTE_INTERACTIVE_LOGON

#define POLICY_MODE_ALL                     (POLICY_MODE_INTERACTIVE            | \
                                             POLICY_MODE_NETWORK                | \
                                             POLICY_MODE_BATCH                  | \
                                             POLICY_MODE_SERVICE                | \
                                             POLICY_MODE_PROXY                  | \
                                             POLICY_MODE_DENY_INTERACTIVE       | \
                                             POLICY_MODE_DENY_NETWORK           | \
                                             SECURITY_ACCESS_DENY_BATCH_LOGON   | \
                                             SECURITY_ACCESS_DENY_SERVICE_LOGON | \
                                             POLICY_MODE_REMOTE_INTERACTIVE     | \
                                             POLICY_MODE_DENY_REMOTE_INTERACTIVE )

//
// The following is the bits allowed in NT4.0
//
#define POLICY_MODE_ALL_NT4                 (POLICY_MODE_INTERACTIVE | \
                                             POLICY_MODE_NETWORK     | \
                                             POLICY_MODE_BATCH       | \
                                             POLICY_MODE_SERVICE     | \
                                             POLICY_MODE_PROXY )


// begin_ntsecapi

//
// The following data type is used to represent the role of the LSA
// server (primary or backup).
//

typedef enum _POLICY_LSA_SERVER_ROLE {

    PolicyServerRoleBackup = 2,
    PolicyServerRolePrimary

} POLICY_LSA_SERVER_ROLE, *PPOLICY_LSA_SERVER_ROLE;

#if (_WIN32_WINNT < 0x0502)
//
// The following data type is used to represent the state of the LSA
// server (enabled or disabled).  Some operations may only be performed on
// an enabled LSA server.
//

typedef enum _POLICY_SERVER_ENABLE_STATE {

    PolicyServerEnabled = 2,
    PolicyServerDisabled

} POLICY_SERVER_ENABLE_STATE, *PPOLICY_SERVER_ENABLE_STATE;
#endif

//
// The following data type is used to specify the auditing options for
// an Audit Event Type.
//

typedef ULONG POLICY_AUDIT_EVENT_OPTIONS, *PPOLICY_AUDIT_EVENT_OPTIONS;

// where the following flags can be set:
//
//     POLICY_AUDIT_EVENT_UNCHANGED - Leave existing auditing options
//         unchanged for events of this type.  This flag is only used for
//         set operations.  If this flag is set, then all other flags
//         are ignored.
//
//     POLICY_AUDIT_EVENT_NONE - Cancel all auditing options for events
//         of this type.  If this flag is set, the success/failure flags
//         are ignored.
//
//     POLICY_AUDIT_EVENT_SUCCESS - When auditing is enabled, audit all
//         successful occurrences of events of the given type.
//
//     POLICY_AUDIT_EVENT_FAILURE - When auditing is enabled, audit all
//         unsuccessful occurrences of events of the given type.
//



// end_ntsecapi

//
// The following data type is used to return information about privileges
// defined on a system.
//

typedef struct _POLICY_PRIVILEGE_DEFINITION {

    LSA_UNICODE_STRING Name;
    LUID LocalValue;

} POLICY_PRIVILEGE_DEFINITION, *PPOLICY_PRIVILEGE_DEFINITION;

//
// where the members have the following usage:
//
//     Name - Is the architected name of the privilege.  This is the
//         primary key of the privilege and the only value that is
//         transportable between systems.
//
//     Luid - is a LUID value assigned locally for efficient representation
//         of the privilege.  Ths value is meaningful only on the system it
//         was assigned on and is not transportable in any way.
//

//
// System Flags for LsaLookupNames2
//

//
// Note the flags start backward so that public values
// don't have gaps.
//

//
// This flag controls LsaLookupNames2 such that isolated names, including
// UPN's are not searched for off the machine.  Composite names
// (domain\username) are still sent off machine if necessary.
//
#define LSA_LOOKUP_ISOLATED_AS_LOCAL  0x80000000

typedef enum _LSA_SID_NAME_MAPPING_OPERATION_TYPE {

    LsaSidNameMappingOperation_Add,
    LsaSidNameMappingOperation_Remove,
    LsaSidNameMappingOperation_AddMultiple,

} LSA_SID_NAME_MAPPING_OPERATION_TYPE, *PLSA_SID_NAME_MAPPING_OPERATION_TYPE;

#define LSA_MAXIMUM_NUMBER_OF_CHARACTERS_IN_NAMES_FOR_SNMC  0x400

typedef struct _LSA_SID_NAME_MAPPING_OPERATION_ADD_INPUT {

    UNICODE_STRING      DomainName;
    UNICODE_STRING      AccountName;
    REF SID_POINTER     Sid;
    ULONG               Flags;

} LSA_SID_NAME_MAPPING_OPERATION_ADD_INPUT, *PLSA_SID_NAME_MAPPING_OPERATION_ADD_INPUT;

typedef struct _LSA_SID_NAME_MAPPING_OPERATION_REMOVE_INPUT {

    UNICODE_STRING  DomainName;
    UNICODE_STRING  AccountName;

} LSA_SID_NAME_MAPPING_OPERATION_REMOVE_INPUT, *PLSA_SID_NAME_MAPPING_OPERATION_REMOVE_INPUT;

#define LSA_MAXIMUM_NUMBER_OF_MAPPINGS_IN_ADD_MULTIPLE_INPUT    0x1000

typedef struct _LSA_SID_NAME_MAPPING_OPERATION_ADD_MULTIPLE_INPUT {

    RANGE( 1, LSA_MAXIMUM_NUMBER_OF_MAPPINGS_IN_ADD_MULTIPLE_INPUT )
                            ULONG                                       Count;
    REF SIZE_IS( Count )    PLSA_SID_NAME_MAPPING_OPERATION_ADD_INPUT   Mappings;

} LSA_SID_NAME_MAPPING_OPERATION_ADD_MULTIPLE_INPUT, *PLSA_SID_NAME_MAPPING_OPERATION_ADD_MULTIPLE_INPUT;

typedef SWITCH_TYPE( LSA_SID_NAME_MAPPING_OPERATION_TYPE ) union _LSA_SID_NAME_MAPPING_OPERATION_INPUT {

    CASE( LsaSidNameMappingOperation_Add )
        LSA_SID_NAME_MAPPING_OPERATION_ADD_INPUT            AddInput;
    CASE( LsaSidNameMappingOperation_Remove )
        LSA_SID_NAME_MAPPING_OPERATION_REMOVE_INPUT         RemoveInput;
    CASE( LsaSidNameMappingOperation_AddMultiple )
        LSA_SID_NAME_MAPPING_OPERATION_ADD_MULTIPLE_INPUT   AddMultipleInput;

} LSA_SID_NAME_MAPPING_OPERATION_INPUT, *PLSA_SID_NAME_MAPPING_OPERATION_INPUT;

typedef enum _LSA_SID_NAME_MAPPING_OPERATION_ERROR {

    LsaSidNameMappingOperation_Success,
    LsaSidNameMappingOperation_NonMappingError,
    LsaSidNameMappingOperation_NameCollision,
    LsaSidNameMappingOperation_SidCollision,
    LsaSidNameMappingOperation_DomainNotFound,
    LsaSidNameMappingOperation_DomainSidPrefixMismatch,
    LsaSidNameMappingOperation_MappingNotFound,

} LSA_SID_NAME_MAPPING_OPERATION_ERROR, *PLSA_SID_NAME_MAPPING_OPERATION_ERROR;

typedef struct _LSA_SID_NAME_MAPPING_OPERATION_GENERIC_OUTPUT {

    LSA_SID_NAME_MAPPING_OPERATION_ERROR    ErrorCode;

} LSA_SID_NAME_MAPPING_OPERATION_GENERIC_OUTPUT, *PLSA_SID_NAME_MAPPING_OPERATION_GENERIC_OUTPUT;

typedef LSA_SID_NAME_MAPPING_OPERATION_GENERIC_OUTPUT LSA_SID_NAME_MAPPING_OPERATION_ADD_OUTPUT, *PLSA_SID_NAME_MAPPING_OPERATION_ADD_OUTPUT;
typedef LSA_SID_NAME_MAPPING_OPERATION_GENERIC_OUTPUT LSA_SID_NAME_MAPPING_OPERATION_REMOVE_OUTPUT, *PLSA_SID_NAME_MAPPING_OPERATION_REMOVE_OUTPUT;
typedef LSA_SID_NAME_MAPPING_OPERATION_GENERIC_OUTPUT LSA_SID_NAME_MAPPING_OPERATION_ADD_MULTIPLE_OUTPUT, *PLSA_SID_NAME_MAPPING_OPERATION_ADD_MULTIPLE_OUTPUT;

typedef SWITCH_TYPE( LSA_SID_NAME_MAPPING_OPERATION_TYPE ) union _LSA_SID_NAME_MAPPING_OPERATION_OUTPUT {

    CASE( LsaSidNameMappingOperation_Add )
        LSA_SID_NAME_MAPPING_OPERATION_ADD_OUTPUT           AddOutput;
    CASE( LsaSidNameMappingOperation_Remove )
        LSA_SID_NAME_MAPPING_OPERATION_REMOVE_OUTPUT        RemoveOutput;
    CASE( LsaSidNameMappingOperation_AddMultiple )
        LSA_SID_NAME_MAPPING_OPERATION_ADD_MULTIPLE_OUTPUT  AddMultipleOutput;

} LSA_SID_NAME_MAPPING_OPERATION_OUTPUT, *PLSA_SID_NAME_MAPPING_OPERATION_OUTPUT;

// begin_ntsecapi

//
// The following data type defines the classes of Policy Information
// that may be queried/set.
//

typedef enum _POLICY_INFORMATION_CLASS {

    PolicyAuditLogInformation = 1,
    PolicyAuditEventsInformation,
    PolicyPrimaryDomainInformation,
    PolicyPdAccountInformation,
    PolicyAccountDomainInformation,
    PolicyLsaServerRoleInformation,
    PolicyReplicaSourceInformation,
    PolicyDefaultQuotaInformation,
    PolicyModificationInformation,
    PolicyAuditFullSetInformation,
    PolicyAuditFullQueryInformation,
    PolicyDnsDomainInformation,
    PolicyDnsDomainInformationInt,
    PolicyLocalAccountDomainInformation,
    PolicyLastEntry

} POLICY_INFORMATION_CLASS, *PPOLICY_INFORMATION_CLASS;


//
// The following data type corresponds to the PolicyAuditLogInformation
// information class.  It is used to represent information relating to
// the Audit Log.
//
// This structure may be used in both query and set operations.  However,
// when used in set operations, some fields are ignored.
//

typedef struct _POLICY_AUDIT_LOG_INFO {

    ULONG AuditLogPercentFull;
    ULONG MaximumLogSize;
    LARGE_INTEGER AuditRetentionPeriod;
    BOOLEAN AuditLogFullShutdownInProgress;
    LARGE_INTEGER TimeToShutdown;
    ULONG NextAuditRecordId;

} POLICY_AUDIT_LOG_INFO, *PPOLICY_AUDIT_LOG_INFO;

// where the members have the following usage:
//
//     AuditLogPercentFull - Indicates the percentage of the Audit Log
//         currently being used.
//
//     MaximumLogSize - Specifies the maximum size of the Audit Log in
//         kilobytes.
//
//     AuditRetentionPeriod - Indicates the length of time that Audit
//         Records are to be retained.  Audit Records are discardable
//         if their timestamp predates the current time minus the
//         retention period.
//
//     AuditLogFullShutdownInProgress - Indicates whether or not a system
//         shutdown is being initiated due to the security Audit Log becoming
//         full.  This condition will only occur if the system is configured
//         to shutdown when the log becomes full.
//
//         TRUE indicates that a shutdown is in progress
//         FALSE indicates that a shutdown is not in progress.
//
//         Once a shutdown has been initiated, this flag will be set to
//         TRUE.  If an administrator is able to currect the situation
//         before the shutdown becomes irreversible, then this flag will
//         be reset to false.
//
//         This field is ignored for set operations.
//
//     TimeToShutdown - If the AuditLogFullShutdownInProgress flag is set,
//         then this field contains the time left before the shutdown
//         becomes irreversible.
//
//         This field is ignored for set operations.
//


//
// The following data type corresponds to the PolicyAuditEventsInformation
// information class.  It is used to represent information relating to
// the audit requirements.
//

typedef struct _POLICY_AUDIT_EVENTS_INFO {

    BOOLEAN AuditingMode;
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    ULONG MaximumAuditEventCount;

} POLICY_AUDIT_EVENTS_INFO, *PPOLICY_AUDIT_EVENTS_INFO;

// where the members have the following usage:
//
//     AuditingMode - A Boolean variable specifying the Auditing Mode value.
//         This value is interpreted as follows:
//
//         TRUE - Auditing is to be enabled (set operations) or is enabled
//             (query operations).  Audit Records will be generated according
//             to the Event Auditing Options in effect (see the
//             EventAuditingOptions field.
//
//         FALSE - Auditing is to be disabled (set operations) or is
//             disabled (query operations).  No Audit Records will be
//             generated.  Note that for set operations the Event Auditing
//             Options in effect will still be updated as specified by the
//             EventAuditingOptions field whether Auditing is enabled or
//             disabled.
//
//    EventAuditingOptions - Pointer to an array of Auditing Options
//        indexed by Audit Event Type.
//
//    MaximumAuditEventCount - Specifiesa count of the number of Audit
//        Event Types specified by the EventAuditingOptions parameter.  If
//        this count is less than the number of Audit Event Types supported
//        by the system, the Auditing Options for Event Types with IDs
//        higher than (MaximumAuditEventCount + 1) are left unchanged.
//


//
// The following data type is used to represent information relating to
// the audit requirements.
//

typedef struct _POLICY_AUDIT_SUBCATEGORIES_INFO {

    ULONG MaximumSubCategoryCount;
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;

} POLICY_AUDIT_SUBCATEGORIES_INFO, *PPOLICY_AUDIT_SUBCATEGORIES_INFO;

typedef struct _POLICY_AUDIT_CATEGORIES_INFO {

    ULONG MaximumCategoryCount;
    PPOLICY_AUDIT_SUBCATEGORIES_INFO SubCategoriesInfo;

} POLICY_AUDIT_CATEGORIES_INFO, *PPOLICY_AUDIT_CATEGORIES_INFO;


//
// Valid bits for Per user policy mask.
//

#define PER_USER_POLICY_UNCHANGED               (0x00)
#define PER_USER_AUDIT_SUCCESS_INCLUDE          (0x01)
#define PER_USER_AUDIT_SUCCESS_EXCLUDE          (0x02)
#define PER_USER_AUDIT_FAILURE_INCLUDE          (0x04)
#define PER_USER_AUDIT_FAILURE_EXCLUDE          (0x08)
#define PER_USER_AUDIT_NONE                     (0x10)


#define VALID_PER_USER_AUDIT_POLICY_FLAG (PER_USER_AUDIT_SUCCESS_INCLUDE | \
                                          PER_USER_AUDIT_SUCCESS_EXCLUDE | \
                                          PER_USER_AUDIT_FAILURE_INCLUDE | \
                                          PER_USER_AUDIT_FAILURE_EXCLUDE | \
                                          PER_USER_AUDIT_NONE)


//
// The following structure corresponds to the PolicyAccountDomainInformation
// information class.
//

typedef struct _POLICY_ACCOUNT_DOMAIN_INFO {

    LSA_UNICODE_STRING DomainName;
    PSID DomainSid;

} POLICY_ACCOUNT_DOMAIN_INFO, *PPOLICY_ACCOUNT_DOMAIN_INFO;

// where the members have the following usage:
//
//     DomainName - Is the name of the domain
//
//     DomainSid - Is the Sid of the domain
//


//
// The following structure corresponds to the PolicyPrimaryDomainInformation
// information class.
//

typedef struct _POLICY_PRIMARY_DOMAIN_INFO {

    LSA_UNICODE_STRING Name;
    PSID Sid;

} POLICY_PRIMARY_DOMAIN_INFO, *PPOLICY_PRIMARY_DOMAIN_INFO;

// where the members have the following usage:
//
//     Name - Is the name of the domain
//
//     Sid - Is the Sid of the domain
//


//
// The following structure corresponds to the PolicyDnsDomainInformation
// information class
//

typedef struct _POLICY_DNS_DOMAIN_INFO
{
    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING DnsDomainName;
    LSA_UNICODE_STRING DnsForestName;
    GUID DomainGuid;
    PSID Sid;

} POLICY_DNS_DOMAIN_INFO, *PPOLICY_DNS_DOMAIN_INFO;

// where the members have the following usage:
//
//      Name - Is the name of the Domain
//
//      DnsDomainName - Is the DNS name of the domain
//
//      DnsForestName - Is the DNS forest name of the domain
//
//      DomainGuid - Is the GUID of the domain
//
//      Sid - Is the Sid of the domain


//
// The following structure corresponds to the PolicyPdAccountInformation
// information class.  This structure may be used in Query operations
// only.
//

typedef struct _POLICY_PD_ACCOUNT_INFO {

    LSA_UNICODE_STRING Name;

} POLICY_PD_ACCOUNT_INFO, *PPOLICY_PD_ACCOUNT_INFO;

// where the members have the following usage:
//
//     Name - Is the name of an account in the domain that should be used
//         for authentication and name/ID lookup requests.
//


//
// The following structure corresponds to the PolicyLsaServerRoleInformation
// information class.
//

typedef struct _POLICY_LSA_SERVER_ROLE_INFO {

    POLICY_LSA_SERVER_ROLE LsaServerRole;

} POLICY_LSA_SERVER_ROLE_INFO, *PPOLICY_LSA_SERVER_ROLE_INFO;

// where the fields have the following usage:
//
// TBS
//


//
// The following structure corresponds to the PolicyReplicaSourceInformation
// information class.
//

typedef struct _POLICY_REPLICA_SOURCE_INFO {

    LSA_UNICODE_STRING ReplicaSource;
    LSA_UNICODE_STRING ReplicaAccountName;

} POLICY_REPLICA_SOURCE_INFO, *PPOLICY_REPLICA_SOURCE_INFO;


//
// The following structure corresponds to the PolicyDefaultQuotaInformation
// information class.
//

typedef struct _POLICY_DEFAULT_QUOTA_INFO {

    QUOTA_LIMITS QuotaLimits;

} POLICY_DEFAULT_QUOTA_INFO, *PPOLICY_DEFAULT_QUOTA_INFO;


//
// The following structure corresponds to the PolicyModificationInformation
// information class.
//

typedef struct _POLICY_MODIFICATION_INFO {

    LARGE_INTEGER ModifiedId;
    LARGE_INTEGER DatabaseCreationTime;

} POLICY_MODIFICATION_INFO, *PPOLICY_MODIFICATION_INFO;

// where the members have the following usage:
//
//     ModifiedId - Is a 64-bit unsigned integer that is incremented each
//         time anything in the LSA database is modified.  This value is
//         only modified on Primary Domain Controllers.
//
//     DatabaseCreationTime - Is the date/time that the LSA Database was
//         created.  On Backup Domain Controllers, this value is replicated
//         from the Primary Domain Controller.
//

//
// The following structure type corresponds to the PolicyAuditFullSetInformation
// Information Class.
//

typedef struct _POLICY_AUDIT_FULL_SET_INFO {

    BOOLEAN ShutDownOnFull;

} POLICY_AUDIT_FULL_SET_INFO, *PPOLICY_AUDIT_FULL_SET_INFO;

//
// The following structure type corresponds to the PolicyAuditFullQueryInformation
// Information Class.
//

typedef struct _POLICY_AUDIT_FULL_QUERY_INFO {

    BOOLEAN ShutDownOnFull;
    BOOLEAN LogIsFull;

} POLICY_AUDIT_FULL_QUERY_INFO, *PPOLICY_AUDIT_FULL_QUERY_INFO;

//
// The following data type defines the classes of Policy Information
// that may be queried/set that has domain wide effect.
//

typedef enum _POLICY_DOMAIN_INFORMATION_CLASS {

#if (_WIN32_WINNT <= 0x0500)
    PolicyDomainQualityOfServiceInformation = 1,
#endif
    PolicyDomainEfsInformation = 2,
    PolicyDomainKerberosTicketInformation

} POLICY_DOMAIN_INFORMATION_CLASS, *PPOLICY_DOMAIN_INFORMATION_CLASS;

#if (_WIN32_WINNT < 0x0502)
//
// QualityOfService information.  Corresponds to PolicyDomainQualityOfServiceInformation
//

#define POLICY_QOS_SCHANNEL_REQUIRED            0x00000001
#define POLICY_QOS_OUTBOUND_INTEGRITY           0x00000002
#define POLICY_QOS_OUTBOUND_CONFIDENTIALITY     0x00000004
#define POLICY_QOS_INBOUND_INTEGRITY            0x00000008
#define POLICY_QOS_INBOUND_CONFIDENTIALITY      0x00000010
#define POLICY_QOS_ALLOW_LOCAL_ROOT_CERT_STORE  0x00000020
#define POLICY_QOS_RAS_SERVER_ALLOWED           0x00000040
#define POLICY_QOS_DHCP_SERVER_ALLOWED          0x00000080

//
// Bits 0x00000100 through 0xFFFFFFFF are reserved for future use.
//
#endif

#if (_WIN32_WINNT == 0x0500)
typedef struct _POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO {

    ULONG QualityOfService;

} POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO, *PPOLICY_DOMAIN_QUALITY_OF_SERVICE_INFO;
//
// where the members have the following usage:
//
//  QualityOfService - Determines what specific QOS actions a machine should take
//
#endif

//
// The following structure corresponds to the PolicyEfsInformation
// information class
//

typedef struct _POLICY_DOMAIN_EFS_INFO {

    ULONG   InfoLength;
    PUCHAR  EfsBlob;

} POLICY_DOMAIN_EFS_INFO, *PPOLICY_DOMAIN_EFS_INFO;

//
// where the members have the following usage:
//
//      InfoLength - Length of the EFS Information blob
//
//      EfsBlob - Efs blob data
//


//
// The following structure corresponds to the PolicyDomainKerberosTicketInformation
// information class
//

#define POLICY_KERBEROS_VALIDATE_CLIENT 0x00000080


typedef struct _POLICY_DOMAIN_KERBEROS_TICKET_INFO {

    ULONG AuthenticationOptions;
    LARGE_INTEGER MaxServiceTicketAge;
    LARGE_INTEGER MaxTicketAge;
    LARGE_INTEGER MaxRenewAge;
    LARGE_INTEGER MaxClockSkew;
    LARGE_INTEGER Reserved;
} POLICY_DOMAIN_KERBEROS_TICKET_INFO, *PPOLICY_DOMAIN_KERBEROS_TICKET_INFO;

//
// where the members have the following usage
//
//      AuthenticationOptions -- allowed ticket options (POLICY_KERBEROS_* flags )
//
//      MaxServiceTicketAge   -- Maximum lifetime for a service ticket
//
//      MaxTicketAge -- Maximum lifetime for the initial ticket
//
//      MaxRenewAge -- Maximum cumulative age a renewable ticket can be with
//                     requring authentication
//
//      MaxClockSkew -- Maximum tolerance for synchronization of computer clocks
//
//      Reserved   --  Reserved


//
// The following data type defines the classes of Policy Information / Policy Domain Information
// that may be used to request notification
//

typedef enum _POLICY_NOTIFICATION_INFORMATION_CLASS {

    PolicyNotifyAuditEventsInformation = 1,
    PolicyNotifyAccountDomainInformation,
    PolicyNotifyServerRoleInformation,
    PolicyNotifyDnsDomainInformation,
    PolicyNotifyDomainEfsInformation,
    PolicyNotifyDomainKerberosTicketInformation,
    PolicyNotifyMachineAccountPasswordInformation

} POLICY_NOTIFICATION_INFORMATION_CLASS, *PPOLICY_NOTIFICATION_INFORMATION_CLASS;

// end_ntsecapi

//
// Account object type-specific Access Types
//

#define ACCOUNT_VIEW                          0x00000001L
#define ACCOUNT_ADJUST_PRIVILEGES             0x00000002L
#define ACCOUNT_ADJUST_QUOTAS                 0x00000004L
#define ACCOUNT_ADJUST_SYSTEM_ACCESS          0x00000008L

#define ACCOUNT_ALL_ACCESS    (STANDARD_RIGHTS_REQUIRED         |\
                               ACCOUNT_VIEW                     |\
                               ACCOUNT_ADJUST_PRIVILEGES        |\
                               ACCOUNT_ADJUST_QUOTAS            |\
                               ACCOUNT_ADJUST_SYSTEM_ACCESS)

#define ACCOUNT_READ          (STANDARD_RIGHTS_READ             |\
                               ACCOUNT_VIEW)

#define ACCOUNT_WRITE         (STANDARD_RIGHTS_WRITE            |\
                               ACCOUNT_ADJUST_PRIVILEGES        |\
                               ACCOUNT_ADJUST_QUOTAS            |\
                               ACCOUNT_ADJUST_SYSTEM_ACCESS)

#define ACCOUNT_EXECUTE       (STANDARD_RIGHTS_EXECUTE)

// begin_ntsecapi

//
// LSA RPC Context Handle (Opaque form).  Note that a Context Handle is
// always a pointer type unlike regular handles.
//

typedef PVOID LSA_HANDLE, *PLSA_HANDLE;

// end_ntsecapi

//
// Trusted Domain object specific access types
//

#define TRUSTED_QUERY_DOMAIN_NAME                 0x00000001L
#define TRUSTED_QUERY_CONTROLLERS                 0x00000002L
#define TRUSTED_SET_CONTROLLERS                   0x00000004L
#define TRUSTED_QUERY_POSIX                       0x00000008L
#define TRUSTED_SET_POSIX                         0x00000010L
#define TRUSTED_SET_AUTH                          0x00000020L
#define TRUSTED_QUERY_AUTH                        0x00000040L


#define TRUSTED_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED     |\
                                TRUSTED_QUERY_DOMAIN_NAME    |\
                                TRUSTED_QUERY_CONTROLLERS    |\
                                TRUSTED_SET_CONTROLLERS      |\
                                TRUSTED_QUERY_POSIX          |\
                                TRUSTED_SET_POSIX            |\
                                TRUSTED_SET_AUTH             |\
                                TRUSTED_QUERY_AUTH)

#define TRUSTED_READ           (STANDARD_RIGHTS_READ         |\
                                TRUSTED_QUERY_DOMAIN_NAME)

#define TRUSTED_WRITE          (STANDARD_RIGHTS_WRITE        |\
                                TRUSTED_SET_CONTROLLERS      |\
                                TRUSTED_SET_POSIX            |\
                                TRUSTED_SET_AUTH )

#define TRUSTED_EXECUTE        (STANDARD_RIGHTS_EXECUTE      |\
                                TRUSTED_QUERY_CONTROLLERS    |\
                                TRUSTED_QUERY_POSIX)



// begin_ntsecapi

//
// Trusted Domain Object specific data types
//

//
// This data type defines the following information classes that may be
// queried or set.
//

typedef enum _TRUSTED_INFORMATION_CLASS {

    TrustedDomainNameInformation = 1,
    TrustedControllersInformation,
    TrustedPosixOffsetInformation,
    TrustedPasswordInformation,
    TrustedDomainInformationBasic,
    TrustedDomainInformationEx,
    TrustedDomainAuthInformation,
    TrustedDomainFullInformation,
    TrustedDomainAuthInformationInternal,
    TrustedDomainFullInformationInternal,
    TrustedDomainInformationEx2Internal,
    TrustedDomainFullInformation2Internal,
    TrustedDomainSupportedEncryptionTypes,
} TRUSTED_INFORMATION_CLASS, *PTRUSTED_INFORMATION_CLASS;

//
// The following data type corresponds to the TrustedDomainNameInformation
// information class.
//

typedef struct _TRUSTED_DOMAIN_NAME_INFO {

    LSA_UNICODE_STRING Name;

} TRUSTED_DOMAIN_NAME_INFO, *PTRUSTED_DOMAIN_NAME_INFO;

// where members have the following meaning:
//
// Name - The name of the Trusted Domain.
//

//
// The following data type corresponds to the TrustedControllersInformation
// information class.
//

typedef struct _TRUSTED_CONTROLLERS_INFO {

    ULONG Entries;
    PLSA_UNICODE_STRING Names;

} TRUSTED_CONTROLLERS_INFO, *PTRUSTED_CONTROLLERS_INFO;

// where members have the following meaning:
//
// Entries - Indicate how mamy entries there are in the Names array.
//
// Names - Pointer to an array of LSA_UNICODE_STRING structures containing the
//     names of domain controllers of the domain.  This information may not
//     be accurate and should be used only as a hint.  The order of this
//     list is considered significant and will be maintained.
//
//     By convention, the first name in this list is assumed to be the
//     Primary Domain Controller of the domain.  If the Primary Domain
//     Controller is not known, the first name should be set to the NULL
//     string.
//


//
// The following data type corresponds to the TrustedPosixOffsetInformation
// information class.
//

typedef struct _TRUSTED_POSIX_OFFSET_INFO {

    ULONG Offset;

} TRUSTED_POSIX_OFFSET_INFO, *PTRUSTED_POSIX_OFFSET_INFO;

// where members have the following meaning:
//
// Offset - Is an offset to use for the generation of Posix user and group
//     IDs from SIDs.  The Posix ID corresponding to any particular SID is
//     generated by adding the RID of that SID to the Offset of the SID's
//     corresponding TrustedDomain object.
//

//
// The following data type corresponds to the TrustedPasswordInformation
// information class.
//

typedef struct _TRUSTED_PASSWORD_INFO {
    LSA_UNICODE_STRING Password;
    LSA_UNICODE_STRING OldPassword;
} TRUSTED_PASSWORD_INFO, *PTRUSTED_PASSWORD_INFO;


typedef  LSA_TRUST_INFORMATION TRUSTED_DOMAIN_INFORMATION_BASIC;

typedef PLSA_TRUST_INFORMATION PTRUSTED_DOMAIN_INFORMATION_BASIC;

//
// Direction of the trust
//
#define TRUST_DIRECTION_DISABLED        0x00000000
#define TRUST_DIRECTION_INBOUND         0x00000001
#define TRUST_DIRECTION_OUTBOUND        0x00000002
#define TRUST_DIRECTION_BIDIRECTIONAL   (TRUST_DIRECTION_INBOUND | TRUST_DIRECTION_OUTBOUND)

#define TRUST_TYPE_DOWNLEVEL            0x00000001  // NT4 and before
#define TRUST_TYPE_UPLEVEL              0x00000002  // NT5
#define TRUST_TYPE_MIT                  0x00000003  // Trust with a MIT Kerberos realm

#if (_WIN32_WINNT < 0x0502)
#define TRUST_TYPE_DCE                  0x00000004  // Trust with a DCE realm
#endif

// Levels 0x5 - 0x000FFFFF reserved for future use
// Provider specific trust levels are from 0x00100000 to 0xFFF00000

#define TRUST_ATTRIBUTE_NON_TRANSITIVE                0x00000001  // Disallow transitivity
#define TRUST_ATTRIBUTE_UPLEVEL_ONLY                  0x00000002  // Trust link only valid for uplevel client
#if (_WIN32_WINNT == 0x0500)
#define TRUST_ATTRIBUTE_TREE_PARENT     0x00400000  // Denotes that we are setting the trust
                                                    // to our parent in the org tree...
#define TRUST_ATTRIBUTE_TREE_ROOT       0x00800000  // Denotes that we are setting the trust
                                                    // to another tree root in a forest...
// Trust attributes 0x00000004 through 0x004FFFFF reserved for future use
// Trust attributes 0x00F00000 through 0x00400000 are reserved for internal use
// Trust attributes 0x01000000 through 0xFF000000 are reserved for user
// defined values
#define TRUST_ATTRIBUTES_VALID  0xFF02FFFF
#endif

#if (_WIN32_WINNT < 0x0502)
#define TRUST_ATTRIBUTE_FILTER_SIDS        0x00000004  // Used to quarantine domains
#else
#define TRUST_ATTRIBUTE_QUARANTINED_DOMAIN            0x00000004  // Used to quarantine domains
#endif

#if (_WIN32_WINNT >= 0x0501)
#define TRUST_ATTRIBUTE_FOREST_TRANSITIVE             0x00000008  // This link may contain forest trust information
#if (_WIN32_WINNT >= 0x0502)
#define TRUST_ATTRIBUTE_CROSS_ORGANIZATION            0x00000010  // This trust is to a domain/forest which is not part of this enterprise
#define TRUST_ATTRIBUTE_WITHIN_FOREST                 0x00000020  // Trust is internal to this forest
#define TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL             0x00000040  // Trust is to be treated as external for trust boundary purposes
#if (_WIN32_WINNT >= 0x0600)
#define TRUST_ATTRIBUTE_TRUST_USES_RC4_ENCRYPTION     0x00000080  // MIT trust with RC4
#define TRUST_ATTRIBUTE_TRUST_USES_AES_KEYS           0x00000100  // Use AES keys to encrypte KRB TGTs
#endif
// Trust attributes 0x00000040 through 0x00200000 are reserved for future use
#else
// Trust attributes 0x00000010 through 0x00200000 are reserved for future use
#endif
// Trust attributes 0x00400000 through 0x00800000 were used previously (up to W2K) and should not be re-used
// Trust attributes 0x01000000 through 0x80000000 are reserved for user
#define TRUST_ATTRIBUTES_VALID          0xFF03FFFF
#endif
#define TRUST_ATTRIBUTES_USER           0xFF000000

typedef struct _TRUSTED_DOMAIN_INFORMATION_EX {

    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING FlatName;
    PSID  Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;

} TRUSTED_DOMAIN_INFORMATION_EX, *PTRUSTED_DOMAIN_INFORMATION_EX;

typedef struct _TRUSTED_DOMAIN_INFORMATION_EX2 {

    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING FlatName;
    PSID  Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;
    ULONG ForestTrustLength;
#ifdef MIDL_PASS
    [size_is( ForestTrustLength )]
#endif
    PUCHAR ForestTrustInfo;

} TRUSTED_DOMAIN_INFORMATION_EX2, *PTRUSTED_DOMAIN_INFORMATION_EX2;

//
// Type of authentication information
//
#define TRUST_AUTH_TYPE_NONE    0   // Ignore this entry
#define TRUST_AUTH_TYPE_NT4OWF  1   // NT4 OWF password
#define TRUST_AUTH_TYPE_CLEAR   2   // Cleartext password
#define TRUST_AUTH_TYPE_VERSION 3   // Cleartext password version number

typedef struct _LSA_AUTH_INFORMATION {

    LARGE_INTEGER LastUpdateTime;
    ULONG AuthType;
    ULONG AuthInfoLength;
    PUCHAR AuthInfo;
} LSA_AUTH_INFORMATION, *PLSA_AUTH_INFORMATION;

typedef struct _TRUSTED_DOMAIN_AUTH_INFORMATION {

    ULONG IncomingAuthInfos;
    PLSA_AUTH_INFORMATION   IncomingAuthenticationInformation;
    PLSA_AUTH_INFORMATION   IncomingPreviousAuthenticationInformation;
    ULONG OutgoingAuthInfos;
    PLSA_AUTH_INFORMATION   OutgoingAuthenticationInformation;
    PLSA_AUTH_INFORMATION   OutgoingPreviousAuthenticationInformation;

} TRUSTED_DOMAIN_AUTH_INFORMATION, *PTRUSTED_DOMAIN_AUTH_INFORMATION;

typedef struct _TRUSTED_DOMAIN_FULL_INFORMATION {

    TRUSTED_DOMAIN_INFORMATION_EX   Information;
    TRUSTED_POSIX_OFFSET_INFO       PosixOffset;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;

} TRUSTED_DOMAIN_FULL_INFORMATION, *PTRUSTED_DOMAIN_FULL_INFORMATION;

typedef struct _TRUSTED_DOMAIN_FULL_INFORMATION2 {

    TRUSTED_DOMAIN_INFORMATION_EX2  Information;
    TRUSTED_POSIX_OFFSET_INFO       PosixOffset;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;

} TRUSTED_DOMAIN_FULL_INFORMATION2, *PTRUSTED_DOMAIN_FULL_INFORMATION2;

typedef struct _TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES {

    ULONG      SupportedEncryptionTypes;

} TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES, *PTRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES;

typedef enum {

    ForestTrustTopLevelName,
    ForestTrustTopLevelNameEx,
    ForestTrustDomainInfo,
    ForestTrustRecordTypeLast = ForestTrustDomainInfo

} LSA_FOREST_TRUST_RECORD_TYPE;

#if (_WIN32_WINNT < 0x0502)
#define LSA_FOREST_TRUST_RECORD_TYPE_UNRECOGNIZED 0x80000000
#endif

//
// Bottom 16 bits of the flags are reserved for disablement reasons
//

#define LSA_FTRECORD_DISABLED_REASONS            ( 0x0000FFFFL )

//
// Reasons for a top-level name forest trust record to be disabled
//

#define LSA_TLN_DISABLED_NEW                     ( 0x00000001L )
#define LSA_TLN_DISABLED_ADMIN                   ( 0x00000002L )
#define LSA_TLN_DISABLED_CONFLICT                ( 0x00000004L )

//
// Reasons for a domain information forest trust record to be disabled
//

#define LSA_SID_DISABLED_ADMIN                   ( 0x00000001L )
#define LSA_SID_DISABLED_CONFLICT                ( 0x00000002L )
#define LSA_NB_DISABLED_ADMIN                    ( 0x00000004L )
#define LSA_NB_DISABLED_CONFLICT                 ( 0x00000008L )

typedef struct _LSA_FOREST_TRUST_DOMAIN_INFO {

#ifdef MIDL_PASS
    PISID Sid;
#else
    PSID Sid;
#endif
    LSA_UNICODE_STRING DnsName;
    LSA_UNICODE_STRING NetbiosName;

} LSA_FOREST_TRUST_DOMAIN_INFO, *PLSA_FOREST_TRUST_DOMAIN_INFO;


#if (_WIN32_WINNT >= 0x0502)
//
//  To prevent huge data to be passed in, we should put a limit on LSA_FOREST_TRUST_BINARY_DATA.
//      128K is large enough that can't be reached in the near future, and small enough not to
//      cause memory problems.

#define MAX_FOREST_TRUST_BINARY_DATA_SIZE ( 128 * 1024 )
#endif

typedef struct _LSA_FOREST_TRUST_BINARY_DATA {

#ifdef MIDL_PASS
    [range(0, MAX_FOREST_TRUST_BINARY_DATA_SIZE)] ULONG Length;
    [size_is( Length )] PUCHAR Buffer;
#else
    ULONG Length;
    PUCHAR Buffer;
#endif

} LSA_FOREST_TRUST_BINARY_DATA, *PLSA_FOREST_TRUST_BINARY_DATA;

typedef struct _LSA_FOREST_TRUST_RECORD {

    ULONG Flags;
    LSA_FOREST_TRUST_RECORD_TYPE ForestTrustType; // type of record
    LARGE_INTEGER Time;

#ifdef MIDL_PASS
    [switch_type( LSA_FOREST_TRUST_RECORD_TYPE ), switch_is( ForestTrustType )]
#endif

    union {                                       // actual data

#ifdef MIDL_PASS
        [case( ForestTrustTopLevelName,
               ForestTrustTopLevelNameEx )] LSA_UNICODE_STRING TopLevelName;
        [case( ForestTrustDomainInfo )] LSA_FOREST_TRUST_DOMAIN_INFO DomainInfo;
        [default] LSA_FOREST_TRUST_BINARY_DATA Data;
#else
        LSA_UNICODE_STRING TopLevelName;
        LSA_FOREST_TRUST_DOMAIN_INFO DomainInfo;
        LSA_FOREST_TRUST_BINARY_DATA Data;        // used for unrecognized types
#endif
    } ForestTrustData;

} LSA_FOREST_TRUST_RECORD, *PLSA_FOREST_TRUST_RECORD;

#if (_WIN32_WINNT >= 0x0502)
//
// To prevent forest trust blobs of large size, number of records must be
// smaller than MAX_RECORDS_IN_FOREST_TRUST_INFO
//

#define MAX_RECORDS_IN_FOREST_TRUST_INFO 4000
#endif

typedef struct _LSA_FOREST_TRUST_INFORMATION {

#ifdef MIDL_PASS
    [range(0, MAX_RECORDS_IN_FOREST_TRUST_INFO)] ULONG RecordCount;
    [size_is( RecordCount )] PLSA_FOREST_TRUST_RECORD * Entries;
#else
    ULONG RecordCount;
    PLSA_FOREST_TRUST_RECORD * Entries;
#endif

} LSA_FOREST_TRUST_INFORMATION, *PLSA_FOREST_TRUST_INFORMATION;

typedef enum {

    CollisionTdo,
    CollisionXref,
    CollisionOther

} LSA_FOREST_TRUST_COLLISION_RECORD_TYPE;

typedef struct _LSA_FOREST_TRUST_COLLISION_RECORD {

    ULONG Index;
    LSA_FOREST_TRUST_COLLISION_RECORD_TYPE Type;
    ULONG Flags;
    LSA_UNICODE_STRING Name;

} LSA_FOREST_TRUST_COLLISION_RECORD, *PLSA_FOREST_TRUST_COLLISION_RECORD;

typedef struct _LSA_FOREST_TRUST_COLLISION_INFORMATION {

    ULONG RecordCount;
#ifdef MIDL_PASS
    [size_is( RecordCount )]
#endif
    PLSA_FOREST_TRUST_COLLISION_RECORD * Entries;

} LSA_FOREST_TRUST_COLLISION_INFORMATION, *PLSA_FOREST_TRUST_COLLISION_INFORMATION;

// end_ntsecapi

//
// Secret object specific access types
//

#define SECRET_SET_VALUE                          0x00000001L
#define SECRET_QUERY_VALUE                        0x00000002L

#define SECRET_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED         |\
                               SECRET_SET_VALUE                 |\
                               SECRET_QUERY_VALUE)

#define SECRET_READ           (STANDARD_RIGHTS_READ             |\
                               SECRET_QUERY_VALUE)

#define SECRET_WRITE          (STANDARD_RIGHTS_WRITE            |\
                               SECRET_SET_VALUE)

#define SECRET_EXECUTE        (STANDARD_RIGHTS_EXECUTE)

//
// Global secret object prefix
//

#define LSA_GLOBAL_SECRET_PREFIX            L"G$"
#define LSA_GLOBAL_SECRET_PREFIX_LENGTH     2

#define LSA_LOCAL_SECRET_PREFIX             L"L$"
#define LSA_LOCAL_SECRET_PREFIX_LENGTH      2

#define LSA_MACHINE_SECRET_PREFIX           L"M$"
#define LSA_MACHINE_SECRET_PREFIX_LENGTH                        \
                ( ( sizeof( LSA_MACHINE_SECRET_PREFIX ) - sizeof( WCHAR ) ) / sizeof( WCHAR ) )

//
// Secret object specific data types.
//

//
// Secret object limits
//

#define LSA_SECRET_MAXIMUM_COUNT                  0x00001000L
#define LSA_SECRET_MAXIMUM_LENGTH                 0x00000200L

// begin_ntsecapi

//
// LSA Enumeration Context
//

typedef ULONG LSA_ENUMERATION_HANDLE, *PLSA_ENUMERATION_HANDLE;

//
// LSA Enumeration Information
//

typedef struct _LSA_ENUMERATION_INFORMATION {

    PSID Sid;

} LSA_ENUMERATION_INFORMATION, *PLSA_ENUMERATION_INFORMATION;


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy - Miscellaneous API function prototypes          //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


NTSTATUS
NTAPI
LsaFreeMemory(
    __in_opt PVOID Buffer
    );

NTSTATUS
NTAPI
LsaClose(
    __in LSA_HANDLE ObjectHandle
    );

// end_ntsecapi

NTSTATUS
NTAPI
LsaDelete(
    __in LSA_HANDLE ObjectHandle
    );

NTSTATUS
NTAPI
LsaQuerySecurityObject(
    __in LSA_HANDLE ObjectHandle,
    __in SECURITY_INFORMATION SecurityInformation,
    __out PSECURITY_DESCRIPTOR *SecurityDescriptor
    );

NTSTATUS
NTAPI
LsaSetSecurityObject(
    __in LSA_HANDLE ObjectHandle,
    __in SECURITY_INFORMATION SecurityInformation,
    __in PSECURITY_DESCRIPTOR SecurityDescriptor
    );

NTSTATUS
NTAPI
LsaChangePassword(
    __in PLSA_UNICODE_STRING ServerName,
    __in PLSA_UNICODE_STRING DomainName,
    __in PLSA_UNICODE_STRING AccountName,
    __in PLSA_UNICODE_STRING OldPassword,
    __in PLSA_UNICODE_STRING NewPassword
    );

// begin_ntsecapi

#if (_WIN32_WINNT >= 0x0600)

typedef struct _LSA_LAST_INTER_LOGON_INFO {
    LARGE_INTEGER LastSuccessfulLogon;
    LARGE_INTEGER LastFailedLogon;
    ULONG FailedAttemptCountSinceLastSuccessfulLogon;
} LSA_LAST_INTER_LOGON_INFO, *PLSA_LAST_INTER_LOGON_INFO;

#endif

#if (_WIN32_WINNT >= 0x0501)
typedef struct _SECURITY_LOGON_SESSION_DATA {
    ULONG               Size;
    LUID                LogonId;
    LSA_UNICODE_STRING  UserName;
    LSA_UNICODE_STRING  LogonDomain;
    LSA_UNICODE_STRING  AuthenticationPackage;
    ULONG               LogonType;
    ULONG               Session;
    PSID                Sid;
    LARGE_INTEGER       LogonTime;

    //
    // new for whistler:
    //

    LSA_UNICODE_STRING  LogonServer;
    LSA_UNICODE_STRING  DnsDomainName;
    LSA_UNICODE_STRING  Upn;

#if (_WIN32_WINNT >= 0x0600)
    
    // 
    // new for LH
    //
    
    ULONG UserFlags; 

    LSA_LAST_INTER_LOGON_INFO LastLogonInfo; 
    LSA_UNICODE_STRING LogonScript;
    LSA_UNICODE_STRING ProfilePath;         
    LSA_UNICODE_STRING HomeDirectory;
    LSA_UNICODE_STRING HomeDirectoryDrive;
    
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;

#endif
} SECURITY_LOGON_SESSION_DATA, * PSECURITY_LOGON_SESSION_DATA;

NTSTATUS
NTAPI
LsaEnumerateLogonSessions(
    __out PULONG  LogonSessionCount,
    __out PLUID * LogonSessionList
    );

NTSTATUS
NTAPI
LsaGetLogonSessionData(
    __in PLUID    LogonId,
    __out PSECURITY_LOGON_SESSION_DATA * ppLogonSessionData
    );

#endif
// end_ntsecapi

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Local Security Policy - Policy Object API function prototypes             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

// begin_ntsecapi
NTSTATUS
NTAPI
LsaOpenPolicy(
    __in_opt PLSA_UNICODE_STRING SystemName,
    __in PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE PolicyHandle
    );

// end_ntsecapi

NTSTATUS
NTAPI
LsaOpenPolicySce(
    __in_opt PLSA_UNICODE_STRING SystemName,
    __in PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE PolicyHandle
    );

// begin_ntsecapi

NTSTATUS
NTAPI
LsaQueryInformationPolicy(
    __in LSA_HANDLE PolicyHandle,
    __in POLICY_INFORMATION_CLASS InformationClass,
    __out PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetInformationPolicy(
    __in LSA_HANDLE PolicyHandle,
    __in POLICY_INFORMATION_CLASS InformationClass,
    __in PVOID Buffer
    );

NTSTATUS
NTAPI
LsaQueryDomainInformationPolicy(
    __in LSA_HANDLE PolicyHandle,
    __in POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    __out PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetDomainInformationPolicy(
    __in LSA_HANDLE PolicyHandle,
    __in POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    __in_opt PVOID Buffer
    );


NTSTATUS
NTAPI
LsaRegisterPolicyChangeNotification(
    __in POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    __in HANDLE  NotificationEventHandle
    );

NTSTATUS
NTAPI
LsaUnregisterPolicyChangeNotification(
    __in POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    __in HANDLE  NotificationEventHandle
    );


// end_ntsecapi

NTSTATUS
NTAPI
LsaClearAuditLog(
    __in LSA_HANDLE PolicyHandle
    );

NTSTATUS
NTAPI
LsaCreateAccount(
    __in LSA_HANDLE PolicyHandle,
    __in PSID AccountSid,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE AccountHandle
    );

NTSTATUS
NTAPI
LsaEnumerateAccounts(
    __in LSA_HANDLE PolicyHandle,
    __inout PLSA_ENUMERATION_HANDLE EnumerationContext,
    __out PVOID *Buffer,
    __in ULONG PreferedMaximumLength,
    __out PULONG CountReturned
    );

NTSTATUS
NTAPI
LsaCreateTrustedDomain(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_TRUST_INFORMATION TrustedDomainInformation,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE TrustedDomainHandle
    );

// begin_ntsecapi

NTSTATUS
NTAPI
LsaEnumerateTrustedDomains(
    __in LSA_HANDLE PolicyHandle,
    __inout PLSA_ENUMERATION_HANDLE EnumerationContext,
    __out PVOID *Buffer,
    __in ULONG PreferedMaximumLength,
    __out PULONG CountReturned
    );

// end_ntsecapi

NTSTATUS
NTAPI
LsaEnumeratePrivileges(
    __in LSA_HANDLE PolicyHandle,
    __inout PLSA_ENUMERATION_HANDLE EnumerationContext,
    __out PVOID *Buffer,
    __in ULONG PreferedMaximumLength,
    __out PULONG CountReturned
    );

// begin_ntsecapi

NTSTATUS
NTAPI
LsaLookupNames(
    __in LSA_HANDLE PolicyHandle,
    __in ULONG Count,
    __in PLSA_UNICODE_STRING Names,
    __out PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    __out PLSA_TRANSLATED_SID *Sids
    );

#if (_WIN32_WINNT >= 0x0501)
NTSTATUS
NTAPI
LsaLookupNames2(
    __in LSA_HANDLE PolicyHandle,
    __in ULONG Flags, // Reserved
    __in ULONG Count,
    __in PLSA_UNICODE_STRING Names,
    __out PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    __out PLSA_TRANSLATED_SID2 *Sids
    );
#endif

NTSTATUS
NTAPI
LsaLookupSids(
    __in LSA_HANDLE PolicyHandle,
    __in ULONG Count,
    __in PSID *Sids,
    __out PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    __out PLSA_TRANSLATED_NAME *Names
    );

// end_ntsecapi

NTSTATUS
NTAPI
LsaCreateSecret(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING SecretName,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE SecretHandle
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Local Security Policy - Account Object API function prototypes            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LsaOpenAccount(
    __in LSA_HANDLE PolicyHandle,
    __in PSID AccountSid,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE AccountHandle
    );

NTSTATUS
NTAPI
LsaEnumeratePrivilegesOfAccount(
    __in LSA_HANDLE AccountHandle,
    __out PPRIVILEGE_SET *Privileges
    );

NTSTATUS
NTAPI
LsaAddPrivilegesToAccount(
    __in LSA_HANDLE AccountHandle,
    __in PPRIVILEGE_SET Privileges
    );

NTSTATUS
NTAPI
LsaRemovePrivilegesFromAccount(
    __in LSA_HANDLE AccountHandle,
    __in BOOLEAN AllPrivileges,
    __in_opt PPRIVILEGE_SET Privileges
    );

NTSTATUS
NTAPI
LsaGetQuotasForAccount(
    __in LSA_HANDLE AccountHandle,
    __out PQUOTA_LIMITS QuotaLimits
    );

NTSTATUS
NTAPI
LsaSetQuotasForAccount(
    __in LSA_HANDLE AccountHandle,
    __in PQUOTA_LIMITS QuotaLimits
    );

NTSTATUS
NTAPI
LsaGetSystemAccessAccount(
    __in LSA_HANDLE AccountHandle,
    __out PULONG SystemAccess
    );

NTSTATUS
NTAPI
LsaSetSystemAccessAccount(
    __in LSA_HANDLE AccountHandle,
    __in ULONG SystemAccess
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Local Security Policy - Trusted Domain Object API function prototypes     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LsaOpenTrustedDomain(
    __in LSA_HANDLE PolicyHandle,
    __in PSID TrustedDomainSid,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE TrustedDomainHandle
    );

NTSTATUS
NTAPI
LsaQueryInfoTrustedDomain(
    __in LSA_HANDLE TrustedDomainHandle,
    __in TRUSTED_INFORMATION_CLASS InformationClass,
    __out PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetInformationTrustedDomain(
    __in LSA_HANDLE TrustedDomainHandle,
    __in TRUSTED_INFORMATION_CLASS InformationClass,
    __in PVOID Buffer
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Local Security Policy - Secret Object API function prototypes             //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LsaOpenSecret(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING SecretName,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE SecretHandle
    );

NTSTATUS
NTAPI
LsaSetSecret(
    __in LSA_HANDLE SecretHandle,
    __in_opt PLSA_UNICODE_STRING CurrentValue,
    __in_opt PLSA_UNICODE_STRING OldValue
    );

NTSTATUS
NTAPI
LsaQuerySecret(
    __in LSA_HANDLE SecretHandle,
    __out_opt OPTIONAL PLSA_UNICODE_STRING *CurrentValue,
    __out_opt PLARGE_INTEGER CurrentValueSetTime,
    __out_opt PLSA_UNICODE_STRING *OldValue,
    __out_opt PLARGE_INTEGER OldValueSetTime
    );


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Local Security Policy - Privilege Object API Prototypes             //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LsaLookupPrivilegeValue(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING Name,
    __out PLUID Value
    );

NTSTATUS
NTAPI
LsaLookupPrivilegeName(
    __in LSA_HANDLE PolicyHandle,
    __in PLUID Value,
    __out PLSA_UNICODE_STRING *Name
    );

NTSTATUS
NTAPI
LsaLookupPrivilegeDisplayName(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING Name,
    __out PLSA_UNICODE_STRING *DisplayName,
    __out PSHORT LanguageReturned
    );


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Local Security Policy - New APIs for NT 4.0 (SUR release)           //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

NTSTATUS
LsaGetUserName(
    __deref_out PLSA_UNICODE_STRING * UserName,
    __deref_opt_out PLSA_UNICODE_STRING * DomainName
    );

NTSTATUS                                                           
LsaGetRemoteUserName(
    __in_opt PLSA_UNICODE_STRING SystemName,
    __deref_out PLSA_UNICODE_STRING * UserName,
    __deref_opt_out PLSA_UNICODE_STRING * DomainName
    );


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Local Security Policy - New APIs for NT 3.51 (PPC release)          //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

// begin_ntsecapi


#define SE_INTERACTIVE_LOGON_NAME           TEXT("SeInteractiveLogonRight")
#define SE_NETWORK_LOGON_NAME               TEXT("SeNetworkLogonRight")
#define SE_BATCH_LOGON_NAME                 TEXT("SeBatchLogonRight")
#define SE_SERVICE_LOGON_NAME               TEXT("SeServiceLogonRight")
#define SE_DENY_INTERACTIVE_LOGON_NAME      TEXT("SeDenyInteractiveLogonRight")
#define SE_DENY_NETWORK_LOGON_NAME          TEXT("SeDenyNetworkLogonRight")
#define SE_DENY_BATCH_LOGON_NAME            TEXT("SeDenyBatchLogonRight")
#define SE_DENY_SERVICE_LOGON_NAME          TEXT("SeDenyServiceLogonRight")
#if (_WIN32_WINNT >= 0x0501)
#define SE_REMOTE_INTERACTIVE_LOGON_NAME    TEXT("SeRemoteInteractiveLogonRight")
#define SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME TEXT("SeDenyRemoteInteractiveLogonRight")
#endif

//
// This new API returns all the accounts with a certain privilege
//

NTSTATUS
NTAPI
LsaEnumerateAccountsWithUserRight(
    __in LSA_HANDLE PolicyHandle,
    __in_opt PLSA_UNICODE_STRING UserRight,
    __out PVOID *Buffer,
    __out PULONG CountReturned
    );

//
// These new APIs differ by taking a SID instead of requiring the caller
// to open the account first and passing in an account handle
//

NTSTATUS
NTAPI
LsaEnumerateAccountRights(
    __in LSA_HANDLE PolicyHandle,
    __in PSID AccountSid,
    __deref_out_ecount(*CountOfRights) PLSA_UNICODE_STRING *UserRights,
    __out PULONG CountOfRights
    );

NTSTATUS
NTAPI
LsaAddAccountRights(
    __in LSA_HANDLE PolicyHandle,
    __in PSID AccountSid,
    __in_ecount(CountOfRights) PLSA_UNICODE_STRING UserRights,
    __in ULONG CountOfRights
    );

NTSTATUS
NTAPI
LsaRemoveAccountRights(
    __in LSA_HANDLE PolicyHandle,
    __in PSID AccountSid,
    __in BOOLEAN AllRights,
    __in_ecount_opt(CountOfRights) PLSA_UNICODE_STRING UserRights,
    __in ULONG CountOfRights
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Local Security Policy - Trusted Domain Object API function prototypes     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LsaOpenTrustedDomainByName(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING TrustedDomainName,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE TrustedDomainHandle
    );


NTSTATUS
NTAPI
LsaQueryTrustedDomainInfo(
    __in LSA_HANDLE PolicyHandle,
    __in PSID TrustedDomainSid,
    __in TRUSTED_INFORMATION_CLASS InformationClass,
    __out PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetTrustedDomainInformation(
    __in LSA_HANDLE PolicyHandle,
    __in PSID TrustedDomainSid,
    __in TRUSTED_INFORMATION_CLASS InformationClass,
    __in PVOID Buffer
    );

NTSTATUS
NTAPI
LsaDeleteTrustedDomain(
    __in LSA_HANDLE PolicyHandle,
    __in PSID TrustedDomainSid
    );

NTSTATUS
NTAPI
LsaQueryTrustedDomainInfoByName(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING TrustedDomainName,
    __in TRUSTED_INFORMATION_CLASS InformationClass,
    __out PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetTrustedDomainInfoByName(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING TrustedDomainName,
    __in TRUSTED_INFORMATION_CLASS InformationClass,
    __in PVOID Buffer
    );

NTSTATUS
NTAPI
LsaEnumerateTrustedDomainsEx(
    __in LSA_HANDLE PolicyHandle,
    __inout PLSA_ENUMERATION_HANDLE EnumerationContext,
    __out PVOID *Buffer,
    __in ULONG PreferedMaximumLength,
    __out PULONG CountReturned
    );

NTSTATUS
NTAPI
LsaCreateTrustedDomainEx(
    __in LSA_HANDLE PolicyHandle,
    __in PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    __in PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE TrustedDomainHandle
    );

#if (_WIN32_WINNT >= 0x0501)
NTSTATUS
NTAPI
LsaQueryForestTrustInformation(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING TrustedDomainName,
    __out PLSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
    );

NTSTATUS
NTAPI
LsaSetForestTrustInformation(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING TrustedDomainName,
    __in PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo,
    __in BOOLEAN CheckOnly,
    __out PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
    );

// #define TESTING_MATCHING_ROUTINE

#ifdef TESTING_MATCHING_ROUTINE

NTSTATUS
NTAPI
LsaForestTrustFindMatch(
    __in LSA_HANDLE PolicyHandle,
    __in ULONG Type,
    __in PLSA_UNICODE_STRING Name,
    __out PLSA_UNICODE_STRING * Match
    );

#endif
#endif

//
// This API sets the workstation password (equivalent of setting/getting
// the SSI_SECRET_NAME secret)
//

NTSTATUS
NTAPI
LsaStorePrivateData(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING KeyName,
    __in_opt PLSA_UNICODE_STRING PrivateData
    );

NTSTATUS
NTAPI
LsaRetrievePrivateData(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING KeyName,
    __out PLSA_UNICODE_STRING * PrivateData
    );


ULONG
NTAPI
LsaNtStatusToWinError(
    __in NTSTATUS Status
    );


//
// Define a symbol so we can tell if ntifs.h has been included.
//

// begin_ntifs
#ifndef _NTLSA_IFS_
#define _NTLSA_IFS_
#endif
// end_ntifs


//
// SPNEGO package stuff
//

enum NEGOTIATE_MESSAGES {
    NegEnumPackagePrefixes = 0,
    NegGetCallerName = 1,
    NegCallPackageMax
};

#define NEGOTIATE_MAX_PREFIX    32

typedef struct _NEGOTIATE_PACKAGE_PREFIX {
    ULONG_PTR   PackageId;
    PVOID       PackageDataA;
    PVOID       PackageDataW;
    ULONG_PTR   PrefixLen;
    UCHAR       Prefix[ NEGOTIATE_MAX_PREFIX ];
} NEGOTIATE_PACKAGE_PREFIX, * PNEGOTIATE_PACKAGE_PREFIX;

typedef struct _NEGOTIATE_PACKAGE_PREFIXES {
    ULONG       MessageType;
    ULONG       PrefixCount;
    ULONG       Offset;        // Offset to array of _PREFIX above
#if(_WIN32_WINNT >= 0x0502)
    ULONG       Pad;           // Align structure for 64-bit
#endif
} NEGOTIATE_PACKAGE_PREFIXES, *PNEGOTIATE_PACKAGE_PREFIXES;

typedef struct _NEGOTIATE_CALLER_NAME_REQUEST {
    ULONG       MessageType;
    LUID        LogonId;
} NEGOTIATE_CALLER_NAME_REQUEST, *PNEGOTIATE_CALLER_NAME_REQUEST;

typedef struct _NEGOTIATE_CALLER_NAME_RESPONSE {
    ULONG       MessageType;
    PWSTR       CallerName;
} NEGOTIATE_CALLER_NAME_RESPONSE, * PNEGOTIATE_CALLER_NAME_RESPONSE;

// end_ntsecapi

#define NEGOTIATE_ALLOW_NTLM    0x10000000
#define NEGOTIATE_NEG_NTLM      0x20000000



//
// Define parallel structures for WOW64 environment.  These
// *must* stay in sync with their complements above.
//

typedef struct _NEGOTIATE_PACKAGE_PREFIX_WOW {
    ULONG       PackageId;
    ULONG       PackageDataA;
    ULONG       PackageDataW;
    ULONG       PrefixLen;
    UCHAR       Prefix[ NEGOTIATE_MAX_PREFIX ];
} NEGOTIATE_PACKAGE_PREFIX_WOW, * PNEGOTIATE_PACKAGE_PREFIX_WOW;

typedef struct _NEGOTIATE_CALLER_NAME_RESPONSE_WOW {
    ULONG       MessageType;
    ULONG       CallerName;
} NEGOTIATE_CALLER_NAME_RESPONSE_WOW, * PNEGOTIATE_CALLER_NAME_RESPONSE_WOW;

NTSTATUS
NTAPI
LsaSetPolicyReplicationHandle(
    IN OUT PLSA_HANDLE PolicyHandle
    );

NTSTATUS
NTAPI
LsaManageSidNameMapping(
    __in    LSA_SID_NAME_MAPPING_OPERATION_TYPE     OperationType,
    __in    PLSA_SID_NAME_MAPPING_OPERATION_INPUT   OperationInput,
    __out   PLSA_SID_NAME_MAPPING_OPERATION_OUTPUT  *OperationOutput
    );

#ifdef __cplusplus
}
#endif

#undef SIZE_IS
#undef SWITCH_IS
#undef SWITCH_TYPE
#undef CASE
#undef RANGE
#undef VAR_SIZE_ARRAY
#undef SID_POINTER
#undef REF

#endif // _NTLSA_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NTMSAPI.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved

Module Name:

    ntmsapi.h

Abstract:

    This module contains the RSM API prototypes
    and public definitions supported in the API
    The RSM API provides a "C" interface to RSM
    This file can be included in C and C++ code

    This file's  name is historical.  RSM began
    life as NTMS

--*/

#ifndef _INCL_NTMSAPI_H_
#define _INCL_NTMSAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#pragma pack(8)

#ifdef __cplusplus
extern "C" {
#endif

typedef GUID  NTMS_GUID;
typedef GUID* LPNTMS_GUID;

#define NTMS_NULLGUID  {0,0,0,{0,0,0,0,0,0,0,0}}
#define NTMS_IS_NULLGUID(id) ((id.Data1==0)&&(id.Data2==0)&&(id.Data3==0)&&\
                                                          (id.Data4[0]==0)&&(id.Data4[1]==0)&&(id.Data4[2]==0)&&\
                                                          (id.Data4[3]==0)&&(id.Data4[4]==0)&&(id.Data4[5]==0)&&\
                                                          (id.Data4[6]==0)&&(id.Data4[7]==0))

//
// Define unicode/ascii specific functions
// This include functions that get strings
//

#ifdef UNICODE
#define OpenNtmsSession OpenNtmsSessionW
#define GetNtmsDeviceName GetNtmsDeviceNameW
#define GetNtmsObjectInformation GetNtmsObjectInformationW
#define SetNtmsObjectInformation SetNtmsObjectInformationW
#define CreateNtmsMediaPool CreateNtmsMediaPoolW
#define GetNtmsMediaPoolName GetNtmsMediaPoolNameW
#define GetNtmsObjectAttribute GetNtmsObjectAttributeW
#define SetNtmsObjectAttribute SetNtmsObjectAttributeW
#define GetNtmsUIOptions GetNtmsUIOptionsW
#define SetNtmsUIOptions SetNtmsUIOptionsW
#define SubmitNtmsOperatorRequest SubmitNtmsOperatorRequestW
#define CreateNtmsMedia CreateNtmsMediaW
#define EjectDiskFromSADrive EjectDiskFromSADriveW
#define GetVolumesFromDrive GetVolumesFromDriveW
#else
#define OpenNtmsSession OpenNtmsSessionA
#define GetNtmsDeviceName GetNtmsDeviceNameA
#define GetNtmsObjectInformation GetNtmsObjectInformationA
#define SetNtmsObjectInformation SetNtmsObjectInformationA
#define CreateNtmsMediaPool CreateNtmsMediaPoolA
#define GetNtmsMediaPoolName GetNtmsMediaPoolNameA
#define GetNtmsObjectAttribute GetNtmsObjectAttributeA
#define SetNtmsObjectAttribute SetNtmsObjectAttributeA
#define GetNtmsUIOptions GetNtmsUIOptionsA
#define SetNtmsUIOptions SetNtmsUIOptionsA
#define SubmitNtmsOperatorRequest SubmitNtmsOperatorRequestA
#define CreateNtmsMedia CreateNtmsMediaA
#define EjectDiskFromSADrive EjectDiskFromSADriveA
#define GetVolumesFromDrive GetVolumesFromDriveA
#endif

#ifndef NTMS_NOREDEF

// WARNING : The object types are provided as an ordered list of NTMS
// database objects.  Do NOT modify without also modifying the object
// metadata table in dbobmeta.cpp

enum NtmsObjectsTypes {
    NTMS_UNKNOWN                    = 0,
    NTMS_OBJECT,
    NTMS_CHANGER,
    NTMS_CHANGER_TYPE,
    NTMS_COMPUTER,
    NTMS_DRIVE,
    NTMS_DRIVE_TYPE,
    NTMS_IEDOOR,
    NTMS_IEPORT,
    NTMS_LIBRARY,
    NTMS_LIBREQUEST,
    NTMS_LOGICAL_MEDIA,
    NTMS_MEDIA_POOL,
    NTMS_MEDIA_TYPE,
    NTMS_PARTITION,
    NTMS_PHYSICAL_MEDIA,
    NTMS_STORAGESLOT,
    NTMS_OPREQUEST,
    NTMS_UI_DESTINATION,

    NTMS_NUMBER_OF_OBJECT_TYPES
};

// async i/o defined for future implementation
typedef struct _NTMS_ASYNC_IO {
    NTMS_GUID   OperationId;                // reserved - do not use
    NTMS_GUID   EventId;                    // reserved - do not use
    DWORD       dwOperationType;            // reserved - do not use
    DWORD       dwResult;                   // completion status
    DWORD       dwAsyncState;               // current state of request
#ifdef MIDL_PASS
    NTMS_HANDLE hEvent;
#else
    HANDLE      hEvent;                     // event handle to signal on status change
#endif                                      // or request completion
    BOOL        bOnStateChange;             // indicate to signal on status change also
} NTMS_ASYNC_IO, *LPNTMS_ASYNC_IO;

enum NtmsAsyncStatus {
    NTMS_ASYNCSTATE_QUEUED          = 0,    // initial state is queued
    NTMS_ASYNCSTATE_WAIT_RESOURCE,
    NTMS_ASYNCSTATE_WAIT_OPERATOR,
    NTMS_ASYNCSTATE_INPROCESS,
    NTMS_ASYNCSTATE_COMPLETE                // complete, check result code
};

enum NtmsAsyncOperations {
    NTMS_ASYNCOP_MOUNT              = 1     // mount operation
};

#endif  // NTMS_NOREDEF

//=======================================================================
// SESSION ESTABLISHMENT
//=======================================================================

#ifndef MIDL_PASS

enum NtmsSessionOptions {
    NTMS_SESSION_QUERYEXPEDITE      = 0x1
};

HANDLE WINAPI OpenNtmsSessionW(
    LPCWSTR lpServer,
    LPCWSTR lpApplication,
    DWORD   dwOptions
    );

HANDLE WINAPI OpenNtmsSessionA(
    LPCSTR lpServer,
    LPCSTR lpApplication,
    DWORD   dwOptions
    );

DWORD WINAPI CloseNtmsSession(
    HANDLE hSession
    );

#endif  // MIDL_PASS

#ifndef NTMS_NOREDEF

//=======================================================================
// MOUNT DEFINITIONS
//=======================================================================

enum NtmsMountOptions {
    NTMS_MOUNT_READ                 = 0x0001,
    NTMS_MOUNT_WRITE                = 0x0002,
    NTMS_MOUNT_ERROR_NOT_AVAILABLE  = 0x0004,
    NTMS_MOUNT_ERROR_IF_UNAVAILABLE = 0x0004,
    NTMS_MOUNT_ERROR_OFFLINE        = 0x0008,
    NTMS_MOUNT_ERROR_IF_OFFLINE     = 0x0008,
    NTMS_MOUNT_SPECIFIC_DRIVE       = 0x0010,
    NTMS_MOUNT_NOWAIT               = 0x0020
};

enum NtmsDismountOptions {
    NTMS_DISMOUNT_DEFERRED          = 0x0001,
    NTMS_DISMOUNT_IMMEDIATE         = 0x0002
};

enum NtmsMountPriority {
    NTMS_PRIORITY_DEFAULT           = 0,
    NTMS_PRIORITY_HIGHEST           = 15,
    NTMS_PRIORITY_HIGH              = 7,
    NTMS_PRIORITY_NORMAL            = 0,
    NTMS_PRIORITY_LOW               = -7,
    NTMS_PRIORITY_LOWEST            = -15
};

typedef struct _NTMS_MOUNT_INFORMATION
{
    DWORD  dwSize;                  // size of structure
#ifdef MIDL_PASS
    [ptr]  LPNTMS_ASYNC_IO lpReserved;
#else
    LPVOID lpReserved;
#endif
} NTMS_MOUNT_INFORMATION, *LPNTMS_MOUNT_INFORMATION;

#endif  // NTMS_NOREDEF

//=======================================================================
// MOUNT AND DISMOUNT APIS
//=======================================================================

#ifndef MIDL_PASS

DWORD WINAPI MountNtmsMedia(
    HANDLE hSession,
    LPNTMS_GUID lpMediaId,
    LPNTMS_GUID lpDriveId,
    DWORD dwCount,
    DWORD dwOptions,
    int   dwPriority,
    DWORD dwTimeout,
    LPNTMS_MOUNT_INFORMATION lpMountInformation
    );

DWORD WINAPI DismountNtmsMedia(
    HANDLE hSession,
    LPNTMS_GUID lpMediaId,
    DWORD dwCount,
    DWORD dwOptions
    );

#endif  // MIDL_PASS

#ifndef NTMS_NOREDEF

//=======================================================================
// ALLOCATE DEFINITIONS
//=======================================================================

enum NtmsAllocateOptions {
    NTMS_ALLOCATE_NEW               = 0x0001,
    NTMS_ALLOCATE_NEXT              = 0x0002,
    NTMS_ALLOCATE_ERROR_IF_UNAVAILABLE = 0x0004
};

typedef struct _NTMS_ALLOCATION_INFORMATION
{
    DWORD  dwSize;                      // size of structure
#ifdef MIDL_PASS
    [ptr]  LPNTMS_ASYNC_IO lpReserved;  // future async io control
#else
    LPVOID lpReserved;
#endif
    NTMS_GUID AllocatedFrom;            // original source of media (scratch pool, app pool, import etc).
} NTMS_ALLOCATION_INFORMATION, *LPNTMS_ALLOCATION_INFORMATION;

#endif

//=======================================================================
// ALLOCATE AND DEALLOCATE APIS
//=======================================================================

#ifndef MIDL_PASS

DWORD WINAPI AllocateNtmsMedia(
    HANDLE hSession,
    LPNTMS_GUID lpMediaPool,
    LPNTMS_GUID lpPartition,        // optional
    LPNTMS_GUID lpMediaId,          // OUTPUT, media id or operator request id
    DWORD dwOptions,
    DWORD dwTimeout,
    LPNTMS_ALLOCATION_INFORMATION lpAllocateInformation
    );

DWORD WINAPI DeallocateNtmsMedia(
    HANDLE hSession,
    LPNTMS_GUID lpMediaId,
    DWORD dwOptions
    );

DWORD WINAPI SwapNtmsMedia(
    HANDLE hSession,
    LPNTMS_GUID lpMediaId1,
    LPNTMS_GUID lpMediaId2
    );

DWORD WINAPI AddNtmsMediaType(
    HANDLE hSession,
    LPNTMS_GUID lpMediaTypeId,
    LPNTMS_GUID lpLibId
    );

DWORD WINAPI DeleteNtmsMediaType(
    HANDLE hSession,
    LPNTMS_GUID lpMediaTypeId,
    LPNTMS_GUID lpLibId
    );

DWORD WINAPI ChangeNtmsMediaType(
    HANDLE hSession,
    LPNTMS_GUID lpMediaId,
    LPNTMS_GUID lpPoolId
    );

//=======================================================================
// MEDIA STATES
//=======================================================================

DWORD WINAPI DecommissionNtmsMedia(
    HANDLE hSession,
    LPNTMS_GUID lpMediaId
    );

DWORD WINAPI SetNtmsMediaComplete(
    HANDLE hSession,
    LPNTMS_GUID lpMediaId
    );

DWORD WINAPI DeleteNtmsMedia(
    HANDLE hSession,
    LPNTMS_GUID lpMediaId
    );

#endif  // MIDL_PASS

#ifndef NTMS_NOREDEF

//=======================================================================
// MEDIA POOLS
//=======================================================================

enum NtmsCreateOptions {
    NTMS_OPEN_EXISTING              = 0x0001,
    NTMS_CREATE_NEW                 = 0x0002,
    NTMS_OPEN_ALWAYS                = 0x0003
};

#endif  // NTMS_NOREDEF

#ifndef MIDL_PASS
#ifdef PRE_SEVIL

DWORD WINAPI CreateNtmsMediaPool(
    HANDLE hSession,
    LPCTSTR lpPoolName,
    LPNTMS_GUID lpMediaType,
    DWORD dwAction,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    LPNTMS_GUID lpPoolId            // OUT
    );

#endif

// SEVILIA
DWORD WINAPI CreateNtmsMediaPoolA(
    HANDLE hSession,
    LPCSTR lpPoolName,
    LPNTMS_GUID lpMediaType,
    DWORD dwAction,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    LPNTMS_GUID lpPoolId            // OUT
    );

DWORD WINAPI CreateNtmsMediaPoolW(
    HANDLE hSession,
    LPCWSTR lpPoolName,
    LPNTMS_GUID lpMediaType,
    DWORD dwAction,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    LPNTMS_GUID lpPoolId            // OUT
    );

DWORD
WINAPI
GetNtmsMediaPoolNameA(
    __in HANDLE hSession,
    __in LPNTMS_GUID lpPoolId,
    __out_ecount_part(*lpdwBufSize, *lpdwBufSize) LPSTR lpNameBuf,
    __inout LPDWORD lpdwBufSize
    );

DWORD
WINAPI
GetNtmsMediaPoolNameW(
    __in HANDLE hSession,
    __in LPNTMS_GUID lpPoolId,
    __out_ecount_part(*lpdwBufSize, *lpdwBufSize) LPWSTR lpNameBuf,
    __inout LPDWORD lpdwBufSize
    );

DWORD WINAPI MoveToNtmsMediaPool(
    HANDLE hSession,
    LPNTMS_GUID lpMediaId,
    LPNTMS_GUID lpPoolId
    );

DWORD WINAPI DeleteNtmsMediaPool(
    HANDLE hSession,
    LPNTMS_GUID lpPoolId
    );

DWORD WINAPI DeleteNtmsLibrary(
    HANDLE hSession,
    LPNTMS_GUID lpLibraryId
    );

DWORD WINAPI DeleteNtmsDrive(
    HANDLE hSession,
    LPNTMS_GUID lpDriveId
    );

#endif  // MIDL_PASS

#define NTMS_OBJECTNAME_LENGTH      64
#define NTMS_DESCRIPTION_LENGTH     127
#define NTMS_DEVICENAME_LENGTH      64
#define NTMS_SERIALNUMBER_LENGTH    32
#define NTMS_REVISION_LENGTH        32
#define NTMS_BARCODE_LENGTH         64
#define NTMS_SEQUENCE_LENGTH        32
#define NTMS_VENDORNAME_LENGTH      128
#define NTMS_PRODUCTNAME_LENGTH     128
#define NTMS_USERNAME_LENGTH        64
#define NTMS_APPLICATIONNAME_LENGTH 64
#define NTMS_COMPUTERNAME_LENGTH    64
#define NTMS_I1_MESSAGE_LENGTH      127
#define NTMS_MESSAGE_LENGTH         256
#define NTMS_POOLHIERARCHY_LENGTH   512
#define NTMS_OMIDLABELID_LENGTH     255
#define NTMS_OMIDLABELTYPE_LENGTH   64
#define NTMS_OMIDLABELINFO_LENGTH   256

#ifndef NTMS_NOREDEF

//======================================================================
// OBJECT INFORMATION STRUCTURES
//======================================================================

enum NtmsDriveState {
    NTMS_DRIVESTATE_DISMOUNTED      = 0,
    NTMS_DRIVESTATE_MOUNTED         = 1,
    NTMS_DRIVESTATE_LOADED          = 2,
    NTMS_DRIVESTATE_UNLOADED        = 5,
    NTMS_DRIVESTATE_BEING_CLEANED   = 6,
    NTMS_DRIVESTATE_DISMOUNTABLE    = 7
};

#ifdef UNICODE
#define _NTMS_DRIVEINFORMATION _NTMS_DRIVEINFORMATIONW
#define NTMS_DRIVEINFORMATION NTMS_DRIVEINFORMATIONW
#else
#define _NTMS_DRIVEINFORMATION _NTMS_DRIVEINFORMATIONA
#define NTMS_DRIVEINFORMATION NTMS_DRIVEINFORMATIONA
#endif

typedef struct _NTMS_DRIVEINFORMATIONA {
    DWORD       Number;
    DWORD       State;
    NTMS_GUID   DriveType;
    CHAR        szDeviceName[NTMS_DEVICENAME_LENGTH];
    CHAR        szSerialNumber[NTMS_SERIALNUMBER_LENGTH];
    CHAR        szRevision[NTMS_REVISION_LENGTH];
    WORD        ScsiPort;
    WORD        ScsiBus;
    WORD        ScsiTarget;
    WORD        ScsiLun;
    DWORD       dwMountCount;
    SYSTEMTIME  LastCleanedTs;
    NTMS_GUID   SavedPartitionId;
    NTMS_GUID   Library;
    GUID        Reserved;
    DWORD       dwDeferDismountDelay;
} NTMS_DRIVEINFORMATIONA;

typedef struct _NTMS_DRIVEINFORMATIONW {
    DWORD       Number;
    DWORD       State;
    NTMS_GUID   DriveType;
    WCHAR       szDeviceName[NTMS_DEVICENAME_LENGTH];
    WCHAR       szSerialNumber[NTMS_SERIALNUMBER_LENGTH];
    WCHAR       szRevision[NTMS_REVISION_LENGTH];
    WORD        ScsiPort;
    WORD        ScsiBus;
    WORD        ScsiTarget;
    WORD        ScsiLun;
    DWORD       dwMountCount;
    SYSTEMTIME  LastCleanedTs;
    NTMS_GUID   SavedPartitionId;
    NTMS_GUID   Library;
    GUID        Reserved;
    DWORD       dwDeferDismountDelay;
} NTMS_DRIVEINFORMATIONW;

enum NtmsLibraryType {
    NTMS_LIBRARYTYPE_UNKNOWN        = 0,
    NTMS_LIBRARYTYPE_OFFLINE        = 1,
    NTMS_LIBRARYTYPE_ONLINE         = 2,
    NTMS_LIBRARYTYPE_STANDALONE     = 3
};

// library flags
enum NtmsLibraryFlags {
    NTMS_LIBRARYFLAG_FIXEDOFFLINE     = 0x01,
    NTMS_LIBRARYFLAG_CLEANERPRESENT   = 0x02,
    NTMS_LIBRARYFLAG_AUTODETECTCHANGE = 0x04,
    NTMS_LIBRARYFLAG_IGNORECLEANERUSESREMAINING = 0x08,
    NTMS_LIBRARYFLAG_RECOGNIZECLEANERBARCODE = 0x10
};

enum NtmsInventoryMethod {
    NTMS_INVENTORY_NONE             = 0,
    NTMS_INVENTORY_FAST             = 1,
    NTMS_INVENTORY_OMID             = 2,
    NTMS_INVENTORY_DEFAULT          = 3,
    NTMS_INVENTORY_SLOT             = 4,
    NTMS_INVENTORY_STOP             = 5,
    NTMS_INVENTORY_MAX
};

typedef struct _NTMS_LIBRARYINFORMATION {
    DWORD       LibraryType;
    NTMS_GUID   CleanerSlot;
    NTMS_GUID   CleanerSlotDefault;
    BOOL        LibrarySupportsDriveCleaning;
    BOOL        BarCodeReaderInstalled;
    DWORD       InventoryMethod;
    DWORD       dwCleanerUsesRemaining;
    DWORD       FirstDriveNumber;
    DWORD       dwNumberOfDrives;
    DWORD       FirstSlotNumber;
    DWORD       dwNumberOfSlots;
    DWORD       FirstDoorNumber;
    DWORD       dwNumberOfDoors;
    DWORD       FirstPortNumber;
    DWORD       dwNumberOfPorts;
    DWORD       FirstChangerNumber;
    DWORD       dwNumberOfChangers;
    DWORD       dwNumberOfMedia;
    DWORD       dwNumberOfMediaTypes;
    DWORD       dwNumberOfLibRequests;
    GUID        Reserved;
    BOOL        AutoRecovery;
    DWORD       dwFlags;
} NTMS_LIBRARYINFORMATION;

#ifdef UNICODE
#define _NTMS_CHANGERINFORMATION _NTMS_CHANGERINFORMATIONW
#define NTMS_CHANGERINFORMATION NTMS_CHANGERINFORMATIONW
#else
#define _NTMS_CHANGERINFORMATION _NTMS_CHANGERINFORMATIONA
#define NTMS_CHANGERINFORMATION NTMS_CHANGERINFORMATIONA
#endif

typedef struct _NTMS_CHANGERINFORMATIONA {
    DWORD       Number;
    NTMS_GUID   ChangerType;
    CHAR        szSerialNumber[NTMS_SERIALNUMBER_LENGTH];
    CHAR        szRevision[NTMS_REVISION_LENGTH];
    CHAR        szDeviceName[NTMS_DEVICENAME_LENGTH];
    WORD        ScsiPort;
    WORD        ScsiBus;
    WORD        ScsiTarget;
    WORD        ScsiLun;
    NTMS_GUID   Library;
} NTMS_CHANGERINFORMATIONA;

typedef struct _NTMS_CHANGERINFORMATIONW {
    DWORD       Number;
    NTMS_GUID   ChangerType;
    WCHAR       szSerialNumber[NTMS_SERIALNUMBER_LENGTH];
    WCHAR       szRevision[NTMS_REVISION_LENGTH];
    WCHAR       szDeviceName[NTMS_DEVICENAME_LENGTH];
    WORD        ScsiPort;
    WORD        ScsiBus;
    WORD        ScsiTarget;
    WORD        ScsiLun;
    NTMS_GUID   Library;
} NTMS_CHANGERINFORMATIONW;

enum NtmsSlotState {
    NTMS_SLOTSTATE_UNKNOWN          = 0,
    NTMS_SLOTSTATE_FULL             = 1,
    NTMS_SLOTSTATE_EMPTY            = 2,
    NTMS_SLOTSTATE_NOTPRESENT       = 3,
    NTMS_SLOTSTATE_NEEDSINVENTORY   = 4
};

typedef struct _NTMS_STORAGESLOTINFORMATION {
    DWORD       Number;
    DWORD       State;
    NTMS_GUID   Library;
} NTMS_STORAGESLOTINFORMATION;

enum NtmsDoorState {
    NTMS_DOORSTATE_UNKNOWN          = 0,
    NTMS_DOORSTATE_CLOSED           = 1,
    NTMS_DOORSTATE_OPEN             = 2
};

typedef struct _NTMS_IEDOORINFORMATION {
    DWORD       Number;
    DWORD       State;
    WORD        MaxOpenSecs;
    NTMS_GUID   Library;
} NTMS_IEDOORINFORMATION;

enum NtmsPortPosition {
    NTMS_PORTPOSITION_UNKNOWN       = 0,
    NTMS_PORTPOSITION_EXTENDED      = 1,
    NTMS_PORTPOSITION_RETRACTED     = 2
};

enum NtmsPortContent {
    NTMS_PORTCONTENT_UNKNOWN        = 0,
    NTMS_PORTCONTENT_FULL           = 1,
    NTMS_PORTCONTENT_EMPTY          = 2
};

typedef struct _NTMS_IEPORTINFORMATION {
    DWORD       Number;
    DWORD       Content;
    DWORD       Position;
    WORD        MaxExtendSecs;
    NTMS_GUID   Library;
} NTMS_IEPORTINFORMATION;

enum NtmsBarCodeState {
    NTMS_BARCODESTATE_OK            = 1,
    NTMS_BARCODESTATE_UNREADABLE    = 2
};

enum NtmsMediaState {
    NTMS_MEDIASTATE_IDLE            = 0,
    NTMS_MEDIASTATE_INUSE           = 1,
    NTMS_MEDIASTATE_MOUNTED         = 2,
    NTMS_MEDIASTATE_LOADED          = 3,
    NTMS_MEDIASTATE_UNLOADED        = 4,
    NTMS_MEDIASTATE_OPERROR         = 5,
    // media is waiting for operator request servicing
    NTMS_MEDIASTATE_OPREQ           = 6
};

#ifdef UNICODE
#define _NTMS_PMIDINFORMATION _NTMS_PMIDINFORMATIONW
#define NTMS_PMIDINFORMATION NTMS_PMIDINFORMATIONW
#else
#define _NTMS_PMIDINFORMATION _NTMS_PMIDINFORMATIONA
#define NTMS_PMIDINFORMATION NTMS_PMIDINFORMATIONA
#endif

typedef struct _NTMS_PMIDINFORMATIONA {
    NTMS_GUID   CurrentLibrary;                 // the current library
    NTMS_GUID   MediaPool;                      // media pool that the media belongs to
    NTMS_GUID   Location;                       // actual location of the media
    DWORD       LocationType;
    NTMS_GUID   MediaType;
    NTMS_GUID   HomeSlot;                       // home slot for online media
    CHAR        szBarCode[NTMS_BARCODE_LENGTH]; // bar code string
    DWORD       BarCodeState;                   // current state of the bar code
    CHAR        szSequenceNumber[NTMS_SEQUENCE_LENGTH];
    DWORD       MediaState;                     // current media state
    DWORD       dwNumberOfPartitions;
    DWORD       dwMediaTypeCode;
    DWORD       dwDensityCode;
    NTMS_GUID   MountedPartition;
} NTMS_PMIDINFORMATIONA;

typedef struct _NTMS_PMIDINFORMATIONW {
    NTMS_GUID   CurrentLibrary;                 // the current library
    NTMS_GUID   MediaPool;                      // media pool that the media belongs to
    NTMS_GUID   Location;                       // actual location of the media
    DWORD       LocationType;
    NTMS_GUID   MediaType;
    NTMS_GUID   HomeSlot;                       // home slot for online media
    WCHAR       szBarCode[NTMS_BARCODE_LENGTH]; // bar code string
    DWORD       BarCodeState;                   // current state of the bar code
    WCHAR       szSequenceNumber[NTMS_SEQUENCE_LENGTH];
    DWORD       MediaState;                     // current media state
    DWORD       dwNumberOfPartitions;
    DWORD       dwMediaTypeCode;
    DWORD       dwDensityCode;
    NTMS_GUID   MountedPartition;
} NTMS_PMIDINFORMATIONW;

typedef struct _NTMS_LMIDINFORMATION {
    NTMS_GUID   MediaPool;
    DWORD       dwNumberOfPartitions;
} NTMS_LMIDINFORMATION;

enum NtmsPartitionState {
    NTMS_PARTSTATE_UNKNOWN          = 0,
    NTMS_PARTSTATE_UNPREPARED       = 1,
    NTMS_PARTSTATE_INCOMPATIBLE     = 2,
    NTMS_PARTSTATE_DECOMMISSIONED   = 3,
    NTMS_PARTSTATE_AVAILABLE        = 4,
    NTMS_PARTSTATE_ALLOCATED        = 5,
    NTMS_PARTSTATE_COMPLETE         = 6,
    NTMS_PARTSTATE_FOREIGN          = 7,
    NTMS_PARTSTATE_IMPORT           = 8,
    NTMS_PARTSTATE_RESERVED         = 9
};

// define the new state as the unknown state for now.
#define NTMS_PARTSTATE_NEW NTMS_PARTSTATE_UNKNOWN

#ifdef UNICODE
#define _NTMS_PARTITIONINFORMATION _NTMS_PARTITIONINFORMATIONW
#define NTMS_PARTITIONINFORMATION NTMS_PARTITIONINFORMATIONW
#else
#define _NTMS_PARTITIONINFORMATION _NTMS_PARTITIONINFORMATIONA
#define NTMS_PARTITIONINFORMATION NTMS_PARTITIONINFORMATIONA
#endif

typedef struct _NTMS_PARTITIONINFORMATIONA {
    NTMS_GUID   PhysicalMedia;
    NTMS_GUID   LogicalMedia;
    DWORD       State;
    WORD        Side;
    DWORD       dwOmidLabelIdLength;    // binary id
    BYTE        OmidLabelId[NTMS_OMIDLABELID_LENGTH];
    CHAR        szOmidLabelType[NTMS_OMIDLABELTYPE_LENGTH];     // type string
    CHAR        szOmidLabelInfo[NTMS_OMIDLABELINFO_LENGTH];     // info string
    DWORD       dwMountCount;
    DWORD       dwAllocateCount;
    LARGE_INTEGER Capacity;
} NTMS_PARTITIONINFORMATIONA;

typedef struct _NTMS_PARTITIONINFORMATIONW {
    NTMS_GUID   PhysicalMedia;
    NTMS_GUID   LogicalMedia;
    DWORD       State;
    WORD        Side;
    DWORD       dwOmidLabelIdLength;    // binary id
    BYTE        OmidLabelId[NTMS_OMIDLABELID_LENGTH];
    WCHAR       szOmidLabelType[NTMS_OMIDLABELTYPE_LENGTH];     // type string
    WCHAR       szOmidLabelInfo[NTMS_OMIDLABELINFO_LENGTH];     // info string
    DWORD       dwMountCount;
    DWORD       dwAllocateCount;
    LARGE_INTEGER Capacity;
} NTMS_PARTITIONINFORMATIONW;

enum NtmsPoolType {
    NTMS_POOLTYPE_UNKNOWN           = 0,
    NTMS_POOLTYPE_SCRATCH           = 1,
    NTMS_POOLTYPE_FOREIGN           = 2,
    NTMS_POOLTYPE_IMPORT            = 3,
    NTMS_POOLTYPE_APPLICATION       = 1000
};

enum NtmsAllocationPolicy {
    NTMS_ALLOCATE_FROMSCRATCH       = 1
};

enum NtmsDeallocationPolicy {
    NTMS_DEALLOCATE_TOSCRATCH       = 1
};

typedef struct _NTMS_MEDIAPOOLINFORMATION {
     DWORD      PoolType;
     NTMS_GUID  MediaType;
     NTMS_GUID  Parent;
     DWORD      AllocationPolicy;
     DWORD      DeallocationPolicy;
     DWORD      dwMaxAllocates;
     DWORD      dwNumberOfPhysicalMedia;
     DWORD      dwNumberOfLogicalMedia;
     DWORD      dwNumberOfMediaPools;
} NTMS_MEDIAPOOLINFORMATION;

enum NtmsReadWriteCharacteristics {
    NTMS_MEDIARW_UNKNOWN            = 0,
    NTMS_MEDIARW_REWRITABLE         = 1,
    NTMS_MEDIARW_WRITEONCE          = 2,
    NTMS_MEDIARW_READONLY           = 3
};

typedef struct _NTMS_MEDIATYPEINFORMATION {
    DWORD       MediaType;      // MediaTypeCodes
    DWORD       NumberOfSides;
    DWORD       ReadWriteCharacteristics;
    DWORD       DeviceType;
} NTMS_MEDIATYPEINFORMATION;

#ifdef UNICODE
#define _NTMS_DRIVETYPEINFORMATION _NTMS_DRIVETYPEINFORMATIONW
#define NTMS_DRIVETYPEINFORMATION NTMS_DRIVETYPEINFORMATIONW
#else
#define _NTMS_DRIVETYPEINFORMATION _NTMS_DRIVETYPEINFORMATIONA
#define NTMS_DRIVETYPEINFORMATION NTMS_DRIVETYPEINFORMATIONA
#endif

typedef struct _NTMS_DRIVETYPEINFORMATIONA {
    CHAR        szVendor[NTMS_VENDORNAME_LENGTH];
    CHAR        szProduct[NTMS_PRODUCTNAME_LENGTH];
    DWORD       NumberOfHeads;
    DWORD       DeviceType;
} NTMS_DRIVETYPEINFORMATIONA;

typedef struct _NTMS_DRIVETYPEINFORMATIONW {
    WCHAR       szVendor[NTMS_VENDORNAME_LENGTH];
    WCHAR       szProduct[NTMS_PRODUCTNAME_LENGTH];
    DWORD       NumberOfHeads;
    DWORD       DeviceType;
} NTMS_DRIVETYPEINFORMATIONW;

#ifdef UNICODE
#define _NTMS_CHANGERTYPEINFORMATION _NTMS_CHANGERTYPEINFORMATIONW
#define NTMS_CHANGERTYPEINFORMATION NTMS_CHANGERTYPEINFORMATIONW
#else
#define _NTMS_CHANGERTYPEINFORMATION _NTMS_CHANGERTYPEINFORMATIONA
#define NTMS_CHANGERTYPEINFORMATION NTMS_CHANGERTYPEINFORMATIONA
#endif

typedef struct _NTMS_CHANGERTYPEINFORMATIONA {
    CHAR        szVendor[NTMS_VENDORNAME_LENGTH];
    CHAR        szProduct[NTMS_PRODUCTNAME_LENGTH];
    DWORD       DeviceType;
} NTMS_CHANGERTYPEINFORMATIONA;

typedef struct _NTMS_CHANGERTYPEINFORMATIONW {
    WCHAR       szVendor[NTMS_VENDORNAME_LENGTH];
    WCHAR       szProduct[NTMS_PRODUCTNAME_LENGTH];
    DWORD       DeviceType;
} NTMS_CHANGERTYPEINFORMATIONW;

//
// Support both CHANGER & LIBRARY for (Dis/Enable) - backwards compatibility
//
enum NtmsLmOperation {
    NTMS_LM_REMOVE                  = 0,
    NTMS_LM_DISABLECHANGER          = 1,
    NTMS_LM_DISABLELIBRARY          = 1,
    NTMS_LM_ENABLECHANGER           = 2,
    NTMS_LM_ENABLELIBRARY           = 2,
    NTMS_LM_DISABLEDRIVE            = 3,
    NTMS_LM_ENABLEDRIVE             = 4,
    NTMS_LM_DISABLEMEDIA            = 5,
    NTMS_LM_ENABLEMEDIA             = 6,
    NTMS_LM_UPDATEOMID              = 7,
    NTMS_LM_INVENTORY               = 8,
    NTMS_LM_DOORACCESS              = 9,
    NTMS_LM_EJECT                   = 10,
    NTMS_LM_EJECTCLEANER            = 11,
    NTMS_LM_INJECT                  = 12,
    NTMS_LM_INJECTCLEANER           = 13,
    NTMS_LM_PROCESSOMID             = 14,
    NTMS_LM_CLEANDRIVE              = 15,
    NTMS_LM_DISMOUNT                = 16,
    NTMS_LM_MOUNT                   = 17,
    NTMS_LM_WRITESCRATCH            = 18,
    NTMS_LM_CLASSIFY                = 19,
    NTMS_LM_RESERVECLEANER          = 20,
    NTMS_LM_RELEASECLEANER          = 21,
    NTMS_LM_MAXWORKITEM
};

enum NtmsLmState {
    NTMS_LM_QUEUED                  = 0,
    NTMS_LM_INPROCESS               = 1,
    NTMS_LM_PASSED                  = 2,
    NTMS_LM_FAILED                  = 3,
    NTMS_LM_INVALID                 = 4,
    NTMS_LM_WAITING                 = 5,
    NTMS_LM_DEFERRED                = 6,
    NTMS_LM_DEFFERED                = 6,  // DO NOT USE.  Maintained for backward compatiblity
    NTMS_LM_CANCELLED               = 7,
    NTMS_LM_STOPPED                 = 8
};

#ifdef UNICODE
#define _NTMS_LIBREQUESTINFORMATION _NTMS_LIBREQUESTINFORMATIONW
#define NTMS_LIBREQUESTINFORMATION NTMS_LIBREQUESTINFORMATIONW
#else
#define _NTMS_LIBREQUESTINFORMATION _NTMS_LIBREQUESTINFORMATIONA
#define NTMS_LIBREQUESTINFORMATION NTMS_LIBREQUESTINFORMATIONA
#endif

typedef struct _NTMS_LIBREQUESTINFORMATIONA {
    DWORD       OperationCode;
    DWORD       OperationOption;
    DWORD       State;
    NTMS_GUID   PartitionId;
    NTMS_GUID   DriveId;
    NTMS_GUID   PhysMediaId;
    NTMS_GUID   Library;
    NTMS_GUID   SlotId;
    SYSTEMTIME  TimeQueued;
    SYSTEMTIME  TimeCompleted;
    CHAR        szApplication[NTMS_APPLICATIONNAME_LENGTH];
    CHAR        szUser[NTMS_USERNAME_LENGTH];
    CHAR        szComputer[NTMS_COMPUTERNAME_LENGTH];
    DWORD       dwErrorCode;                    // error value if state = FAILED
    NTMS_GUID   WorkItemId;                     // work item id for cancel and other requests that
    DWORD       dwPriority;                     // require and associated work item
} NTMS_LIBREQUESTINFORMATIONA;

typedef struct _NTMS_LIBREQUESTINFORMATIONW {
    DWORD       OperationCode;
    DWORD       OperationOption;
    DWORD       State;
    NTMS_GUID   PartitionId;
    NTMS_GUID   DriveId;
    NTMS_GUID   PhysMediaId;
    NTMS_GUID   Library;
    NTMS_GUID   SlotId;
    SYSTEMTIME  TimeQueued;
    SYSTEMTIME  TimeCompleted;
    WCHAR       szApplication[NTMS_APPLICATIONNAME_LENGTH];
    WCHAR       szUser[NTMS_USERNAME_LENGTH];
    WCHAR       szComputer[NTMS_COMPUTERNAME_LENGTH];
    DWORD       dwErrorCode;                    // error value if state = FAILED
    NTMS_GUID   WorkItemId;                     // work item id for cancel and other requests that
    DWORD       dwPriority;                     // require and associated work item
} NTMS_LIBREQUESTINFORMATIONW;

enum NtmsOpreqCommand {
    NTMS_OPREQ_UNKNOWN              = 0,
    NTMS_OPREQ_NEWMEDIA             = 1,
    NTMS_OPREQ_CLEANER              = 2,
    NTMS_OPREQ_DEVICESERVICE        = 3,
    NTMS_OPREQ_MOVEMEDIA            = 4,
    NTMS_OPREQ_MESSAGE              = 5
};

enum NtmsOpreqState {
    NTMS_OPSTATE_UNKNOWN            = 0,
    NTMS_OPSTATE_SUBMITTED          = 1,
    NTMS_OPSTATE_ACTIVE             = 2,
    NTMS_OPSTATE_INPROGRESS         = 3,
    NTMS_OPSTATE_REFUSED            = 4,
    NTMS_OPSTATE_COMPLETE           = 5
};

#ifdef UNICODE
#define _NTMS_OPREQUESTINFORMATION _NTMS_OPREQUESTINFORMATIONW
#define NTMS_OPREQUESTINFORMATION NTMS_OPREQUESTINFORMATIONW
#else
#define _NTMS_OPREQUESTINFORMATION _NTMS_OPREQUESTINFORMATIONA
#define NTMS_OPREQUESTINFORMATION NTMS_OPREQUESTINFORMATIONA
#endif

typedef struct _NTMS_OPREQUESTINFORMATIONA {
    DWORD       Request;
    SYSTEMTIME  Submitted;
    DWORD       State;
    CHAR        szMessage[NTMS_MESSAGE_LENGTH];
    DWORD       Arg1Type;
    NTMS_GUID   Arg1;
    DWORD       Arg2Type;
    NTMS_GUID   Arg2;
    CHAR        szApplication[NTMS_APPLICATIONNAME_LENGTH];
    CHAR        szUser[NTMS_USERNAME_LENGTH];
    CHAR        szComputer[NTMS_COMPUTERNAME_LENGTH];
} NTMS_OPREQUESTINFORMATIONA;

typedef struct _NTMS_OPREQUESTINFORMATIONW {
    DWORD       Request;
    SYSTEMTIME  Submitted;
    DWORD       State;
    WCHAR       szMessage[NTMS_MESSAGE_LENGTH];
    DWORD       Arg1Type;
    NTMS_GUID   Arg1;
    DWORD       Arg2Type;
    NTMS_GUID   Arg2;
    WCHAR       szApplication[NTMS_APPLICATIONNAME_LENGTH];
    WCHAR       szUser[NTMS_USERNAME_LENGTH];
    WCHAR       szComputer[NTMS_COMPUTERNAME_LENGTH];
} NTMS_OPREQUESTINFORMATIONW;

typedef struct _NTMS_COMPUTERINFORMATION {
    DWORD       dwLibRequestPurgeTime;
    DWORD       dwOpRequestPurgeTime;
    DWORD       dwLibRequestFlags;
    DWORD       dwOpRequestFlags;
    DWORD       dwMediaPoolPolicy;
} NTMS_COMPUTERINFORMATION;

// library request option flags
enum NtmsLibRequestFlags {
    NTMS_LIBREQFLAGS_NOAUTOPURGE    = 0x01,
    NTMS_LIBREQFLAGS_NOFAILEDPURGE  = 0x02
};

// operator request option flags
enum NtmsOpRequestFlags {
    NTMS_OPREQFLAGS_NOAUTOPURGE     = 0x01,
    NTMS_OPREQFLAGS_NOFAILEDPURGE   = 0x02,
    NTMS_OPREQFLAGS_NOALERTS        = 0x10,
    NTMS_OPREQFLAGS_NOTRAYICON      = 0x20
};

// media pool policy flags
enum NtmsMediaPoolPolicy {
    // purge offline scratch media.  By default we keep offline scratch media
    // in the fixed offline media pool
    NTMS_POOLPOLICY_PURGEOFFLINESCRATCH = 0x01,
    NTMS_POOLPOLICY_KEEPOFFLINEIMPORT   = 0x02
};

#ifdef UNICODE
#define _NTMS_OBJECTINFORMATION _NTMS_OBJECTINFORMATIONW
#define NTMS_OBJECTINFORMATION NTMS_OBJECTINFORMATIONW
#define LPNTMS_OBJECTINFORMATION LPNTMS_OBJECTINFORMATIONW
#else
#define _NTMS_OBJECTINFORMATION _NTMS_OBJECTINFORMATIONA
#define NTMS_OBJECTINFORMATION NTMS_OBJECTINFORMATIONA
#define LPNTMS_OBJECTINFORMATION LPNTMS_OBJECTINFORMATIONA
#endif

enum NtmsOperationalState {
    NTMS_READY                      = 0,
    NTMS_INITIALIZING               = 10,
    NTMS_NEEDS_SERVICE              = 20,
    NTMS_NOT_PRESENT                = 21
};

typedef struct _NTMS_OBJECTINFORMATIONA {
    DWORD       dwSize;
    DWORD       dwType;
    SYSTEMTIME  Created;
    SYSTEMTIME  Modified;
    NTMS_GUID   ObjectGuid;
    BOOL        Enabled;
    DWORD       dwOperationalState;
    CHAR        szName[NTMS_OBJECTNAME_LENGTH];
    CHAR        szDescription[NTMS_DESCRIPTION_LENGTH];
#ifdef MIDL_PASS
    [switch_is(dwType)] union {
        [case(NTMS_DRIVE)]              NTMS_DRIVEINFORMATIONA Drive;
        [case(NTMS_DRIVE_TYPE)]         NTMS_DRIVETYPEINFORMATIONA DriveType;
        [case(NTMS_LIBRARY)]            NTMS_LIBRARYINFORMATION Library;
        [case(NTMS_CHANGER)]            NTMS_CHANGERINFORMATIONA Changer;
        [case(NTMS_CHANGER_TYPE)]       NTMS_CHANGERTYPEINFORMATIONA ChangerType;
        [case(NTMS_STORAGESLOT)]        NTMS_STORAGESLOTINFORMATION StorageSlot;
        [case(NTMS_IEDOOR)]             NTMS_IEDOORINFORMATION IEDoor;
        [case(NTMS_IEPORT)]             NTMS_IEPORTINFORMATION IEPort;
        [case(NTMS_PHYSICAL_MEDIA)]     NTMS_PMIDINFORMATIONA PhysicalMedia;
        [case(NTMS_LOGICAL_MEDIA)]      NTMS_LMIDINFORMATION LogicalMedia;
        [case(NTMS_PARTITION)]          NTMS_PARTITIONINFORMATIONA Partition;
        [case(NTMS_MEDIA_POOL)]         NTMS_MEDIAPOOLINFORMATION MediaPool;
        [case(NTMS_MEDIA_TYPE)]         NTMS_MEDIATYPEINFORMATION MediaType;
        [case(NTMS_LIBREQUEST)]         NTMS_LIBREQUESTINFORMATIONA LibRequest;
        [case(NTMS_OPREQUEST)]          NTMS_OPREQUESTINFORMATIONA OpRequest;
        [case(NTMS_COMPUTER)]           NTMS_COMPUTERINFORMATION Computer;
        [default]                                       ;
    } Info;
#else
    union {
        NTMS_DRIVEINFORMATIONA      Drive;
        NTMS_DRIVETYPEINFORMATIONA  DriveType;
        NTMS_LIBRARYINFORMATION     Library;
        NTMS_CHANGERINFORMATIONA    Changer;
        NTMS_CHANGERTYPEINFORMATIONA ChangerType;
        NTMS_STORAGESLOTINFORMATION StorageSlot;
        NTMS_IEDOORINFORMATION      IEDoor;
        NTMS_IEPORTINFORMATION      IEPort;
        NTMS_PMIDINFORMATIONA       PhysicalMedia;
        NTMS_LMIDINFORMATION        LogicalMedia;
        NTMS_PARTITIONINFORMATIONA  Partition;
        NTMS_MEDIAPOOLINFORMATION   MediaPool;
        NTMS_MEDIATYPEINFORMATION   MediaType;
        NTMS_LIBREQUESTINFORMATIONA LibRequest;
        NTMS_OPREQUESTINFORMATIONA  OpRequest;
        NTMS_COMPUTERINFORMATION    Computer;
    } Info;
#endif  // MIDL_PASS
} NTMS_OBJECTINFORMATIONA, *LPNTMS_OBJECTINFORMATIONA;

typedef struct _NTMS_OBJECTINFORMATIONW {
    DWORD       dwSize;
    DWORD       dwType;
    SYSTEMTIME  Created;
    SYSTEMTIME  Modified;
    NTMS_GUID   ObjectGuid;
    BOOL        Enabled;
    DWORD       dwOperationalState;
    WCHAR       szName[NTMS_OBJECTNAME_LENGTH];
    WCHAR       szDescription[NTMS_DESCRIPTION_LENGTH];
#ifdef MIDL_PASS
    [switch_is(dwType)] union {
        [case(NTMS_DRIVE)]              NTMS_DRIVEINFORMATIONW Drive;
        [case(NTMS_DRIVE_TYPE)]         NTMS_DRIVETYPEINFORMATIONW DriveType;
        [case(NTMS_LIBRARY)]            NTMS_LIBRARYINFORMATION Library;
        [case(NTMS_CHANGER)]            NTMS_CHANGERINFORMATIONW Changer;
        [case(NTMS_CHANGER_TYPE)]       NTMS_CHANGERTYPEINFORMATIONW ChangerType;
        [case(NTMS_STORAGESLOT)]        NTMS_STORAGESLOTINFORMATION StorageSlot;
        [case(NTMS_IEDOOR)]             NTMS_IEDOORINFORMATION IEDoor;
        [case(NTMS_IEPORT)]             NTMS_IEPORTINFORMATION IEPort;
        [case(NTMS_PHYSICAL_MEDIA)]     NTMS_PMIDINFORMATIONW PhysicalMedia;
        [case(NTMS_LOGICAL_MEDIA)]      NTMS_LMIDINFORMATION LogicalMedia;
        [case(NTMS_PARTITION)]          NTMS_PARTITIONINFORMATIONW Partition;
        [case(NTMS_MEDIA_POOL)]         NTMS_MEDIAPOOLINFORMATION MediaPool;
        [case(NTMS_MEDIA_TYPE)]         NTMS_MEDIATYPEINFORMATION MediaType;
        [case(NTMS_LIBREQUEST)]         NTMS_LIBREQUESTINFORMATIONW LibRequest;
        [case(NTMS_OPREQUEST)]          NTMS_OPREQUESTINFORMATIONW OpRequest;
        [case(NTMS_COMPUTER)]           NTMS_COMPUTERINFORMATION Computer;
        [default]                                       ;
    } Info;
#else
    union {
        NTMS_DRIVEINFORMATIONW Drive;
        NTMS_DRIVETYPEINFORMATIONW DriveType;
        NTMS_LIBRARYINFORMATION Library;
        NTMS_CHANGERINFORMATIONW Changer;
        NTMS_CHANGERTYPEINFORMATIONW ChangerType;
        NTMS_STORAGESLOTINFORMATION StorageSlot;
        NTMS_IEDOORINFORMATION IEDoor;
        NTMS_IEPORTINFORMATION IEPort;
        NTMS_PMIDINFORMATIONW PhysicalMedia;
        NTMS_LMIDINFORMATION LogicalMedia;
        NTMS_PARTITIONINFORMATIONW Partition;
        NTMS_MEDIAPOOLINFORMATION MediaPool;
        NTMS_MEDIATYPEINFORMATION MediaType;
        NTMS_LIBREQUESTINFORMATIONW LibRequest;
        NTMS_OPREQUESTINFORMATIONW OpRequest;
        NTMS_COMPUTERINFORMATION Computer;
    } Info;
#endif  // MIDL_PASS
} NTMS_OBJECTINFORMATIONW, *LPNTMS_OBJECTINFORMATIONW;

//********************************************************************************
// NT 5.0 BETA1 variations of object information.  Required to keep here for
// backward compatibility in DCOM interface.
// Different data structures add the _I1_ to the structure name, denoting
// used for Interface 1 only.
// DO NOT MODIFY IN FUTURE VERSIONS !!
//********************************************************************************

#ifdef UNICODE
#define NTMS_I1_LIBREQUESTINFORMATION   NTMS_I1_LIBREQUESTINFORMATIONW
#define NTMS_I1_PARTITIONINFORMATION    NTMS_I1_PARTITIONINFORMATIONW
#define NTMS_I1_PMIDINFORMATION         NTMS_I1_PMIDINFORMATIONW
#define NTMS_I1_OPREQUESTINFORMATION    NTMS_I1_OPREQUESTINFORMATIONW
#define NTMS_I1_OBJECTINFORMATION       NTMS_I1_OBJECTINFORMATIONW
#else
#define NTMS_I1_LIBREQUESTINFORMATION   NTMS_I1_LIBREQUESTINFORMATIONA
#define NTMS_I1_PARTITIONINFORMATION    NTMS_I1_PARTITIONINFORMATIONA
#define NTMS_I1_PMIDINFORMATION         NTMS_I1_PMIDINFORMATIONA
#define NTMS_I1_OPREQUESTINFORMATION    NTMS_I1_OPREQUESTINFORMATIONA
#define NTMS_I1_OBJECTINFORMATION       NTMS_I1_OBJECTINFORMATIONA
#endif

typedef struct _NTMS_I1_LIBRARYINFORMATION {
    DWORD       LibraryType;
    NTMS_GUID   CleanerSlot;
    NTMS_GUID   CleanerSlotDefault;
    BOOL        LibrarySupportsDriveCleaning;
    BOOL        BarCodeReaderInstalled;
    DWORD       InventoryMethod;
    DWORD       dwCleanerUsesRemaining;
    DWORD       FirstDriveNumber;
    DWORD       dwNumberOfDrives;
    DWORD       FirstSlotNumber;
    DWORD       dwNumberOfSlots;
    DWORD       FirstDoorNumber;
    DWORD       dwNumberOfDoors;
    DWORD       FirstPortNumber;
    DWORD       dwNumberOfPorts;
    DWORD       FirstChangerNumber;
    DWORD       dwNumberOfChangers;
    DWORD       dwNumberOfMedia;
    DWORD       dwNumberOfMediaTypes;
    DWORD       dwNumberOfLibRequests;
    GUID        Reserved;
} NTMS_I1_LIBRARYINFORMATION;

typedef struct _NTMS_I1_LIBREQUESTINFORMATIONA {
    DWORD       OperationCode;
    DWORD       OperationOption;
    DWORD       State;
    NTMS_GUID   PartitionId;
    NTMS_GUID   DriveId;
    NTMS_GUID   PhysMediaId;
    NTMS_GUID   Library;
    NTMS_GUID   SlotId;
    SYSTEMTIME  TimeQueued;
    SYSTEMTIME  TimeCompleted;
    CHAR        szApplication[NTMS_APPLICATIONNAME_LENGTH];
    CHAR        szUser[NTMS_USERNAME_LENGTH];
    CHAR        szComputer[NTMS_COMPUTERNAME_LENGTH];
} NTMS_I1_LIBREQUESTINFORMATIONA;

typedef struct _NTMS_I1_LIBREQUESTINFORMATIONW {
    DWORD       OperationCode;
    DWORD       OperationOption;
    DWORD       State;
    NTMS_GUID   PartitionId;
    NTMS_GUID   DriveId;
    NTMS_GUID   PhysMediaId;
    NTMS_GUID   Library;
    NTMS_GUID   SlotId;
    SYSTEMTIME  TimeQueued;
    SYSTEMTIME  TimeCompleted;
    WCHAR       szApplication[NTMS_APPLICATIONNAME_LENGTH];
    WCHAR       szUser[NTMS_USERNAME_LENGTH];
    WCHAR       szComputer[NTMS_COMPUTERNAME_LENGTH];
} NTMS_I1_LIBREQUESTINFORMATIONW;

typedef struct _NTMS_I1_PMIDINFORMATIONA {
    NTMS_GUID   CurrentLibrary;                 // the current library
    NTMS_GUID   MediaPool;                      // media pool that the media belongs to
    NTMS_GUID   Location;                       // actual location of the media
    DWORD       LocationType;
    NTMS_GUID   MediaType;
    NTMS_GUID   HomeSlot;                       // home slot for online media
    CHAR        szBarCode[NTMS_BARCODE_LENGTH]; // bar code string
    DWORD       BarCodeState;                   // current state of the bar code
    CHAR        szSequenceNumber[NTMS_SEQUENCE_LENGTH];
    DWORD       MediaState;                     // current media state
    DWORD       dwNumberOfPartitions;
} NTMS_I1_PMIDINFORMATIONA;

typedef struct _NTMS_I1_PMIDINFORMATIONW {
    NTMS_GUID   CurrentLibrary;                 // the current library
    NTMS_GUID   MediaPool;                      // media pool that the media belongs to
    NTMS_GUID   Location;                       // actual location of the media
    DWORD       LocationType;
    NTMS_GUID   MediaType;
    NTMS_GUID   HomeSlot;                       // home slot for online media
    WCHAR       szBarCode[NTMS_BARCODE_LENGTH]; // bar code string
    DWORD       BarCodeState;                   // current state of the bar code
    WCHAR       szSequenceNumber[NTMS_SEQUENCE_LENGTH];
    DWORD       MediaState;                     // current media state
    DWORD       dwNumberOfPartitions;
} NTMS_I1_PMIDINFORMATIONW;

typedef struct _NTMS_I1_PARTITIONINFORMATIONA {
    NTMS_GUID   PhysicalMedia;
    NTMS_GUID   LogicalMedia;
    DWORD       State;
    WORD        Side;
    DWORD       dwOmidLabelIdLength;    // binary id
    BYTE        OmidLabelId[255];
    CHAR        szOmidLabelType[64];    // type string
    CHAR        szOmidLabelInfo[256];   // info string
    DWORD       dwMountCount;
    DWORD       dwAllocateCount;
} NTMS_I1_PARTITIONINFORMATIONA;

typedef struct _NTMS_I1_PARTITIONINFORMATIONW {
    NTMS_GUID   PhysicalMedia;
    NTMS_GUID   LogicalMedia;
    DWORD       State;
    WORD        Side;
    DWORD       dwOmidLabelIdLength;    // binary id
    BYTE        OmidLabelId[255];
    WCHAR       szOmidLabelType[64];    // type string
    WCHAR       szOmidLabelInfo[256];   // info string
    DWORD       dwMountCount;
    DWORD       dwAllocateCount;
} NTMS_I1_PARTITIONINFORMATIONW;

typedef struct _NTMS_I1_OPREQUESTINFORMATIONA {
    DWORD       Request;
    SYSTEMTIME  Submitted;
    DWORD       State;
    CHAR        szMessage[NTMS_I1_MESSAGE_LENGTH];
    DWORD       Arg1Type;
    NTMS_GUID   Arg1;
    DWORD       Arg2Type;
    NTMS_GUID   Arg2;
    CHAR        szApplication[NTMS_APPLICATIONNAME_LENGTH];
    CHAR        szUser[NTMS_USERNAME_LENGTH];
    CHAR        szComputer[NTMS_COMPUTERNAME_LENGTH];
} NTMS_I1_OPREQUESTINFORMATIONA;

typedef struct _NTMS_I1_OPREQUESTINFORMATIONW {
    DWORD       Request;
    SYSTEMTIME  Submitted;
    DWORD       State;
    WCHAR       szMessage[NTMS_I1_MESSAGE_LENGTH];
    DWORD       Arg1Type;
    NTMS_GUID   Arg1;
    DWORD       Arg2Type;
    NTMS_GUID   Arg2;
    WCHAR       szApplication[NTMS_APPLICATIONNAME_LENGTH];
    WCHAR       szUser[NTMS_USERNAME_LENGTH];
    WCHAR       szComputer[NTMS_COMPUTERNAME_LENGTH];
} NTMS_I1_OPREQUESTINFORMATIONW;

typedef struct _NTMS_I1_OBJECTINFORMATIONA {
    DWORD       dwSize;
    DWORD       dwType;
    SYSTEMTIME  Created;
    SYSTEMTIME  Modified;
    NTMS_GUID   ObjectGuid;
    BOOL        Enabled;
    DWORD       dwOperationalState;
    CHAR        szName[NTMS_OBJECTNAME_LENGTH];
    CHAR        szDescription[NTMS_DESCRIPTION_LENGTH];
#ifdef MIDL_PASS
    [switch_is(dwType)] union {
        [case(NTMS_DRIVE)]              NTMS_DRIVEINFORMATIONA Drive;
        [case(NTMS_DRIVE_TYPE)]         NTMS_DRIVETYPEINFORMATIONA DriveType;
        [case(NTMS_LIBRARY)]            NTMS_I1_LIBRARYINFORMATION Library;
        [case(NTMS_CHANGER)]            NTMS_CHANGERINFORMATIONA Changer;
        [case(NTMS_CHANGER_TYPE)]       NTMS_CHANGERTYPEINFORMATIONA ChangerType;
        [case(NTMS_STORAGESLOT)]        NTMS_STORAGESLOTINFORMATION StorageSlot;
        [case(NTMS_IEDOOR)]             NTMS_IEDOORINFORMATION IEDoor;
        [case(NTMS_IEPORT)]             NTMS_IEPORTINFORMATION IEPort;
        [case(NTMS_PHYSICAL_MEDIA)]     NTMS_I1_PMIDINFORMATIONA PhysicalMedia;
        [case(NTMS_LOGICAL_MEDIA)]      NTMS_LMIDINFORMATION LogicalMedia;
        [case(NTMS_PARTITION)]          NTMS_I1_PARTITIONINFORMATIONA Partition;
        [case(NTMS_MEDIA_POOL)]         NTMS_MEDIAPOOLINFORMATION MediaPool;
        [case(NTMS_MEDIA_TYPE)]         NTMS_MEDIATYPEINFORMATION MediaType;
        [case(NTMS_LIBREQUEST)]         NTMS_I1_LIBREQUESTINFORMATIONA LibRequest;
        [case(NTMS_OPREQUEST)]          NTMS_I1_OPREQUESTINFORMATIONA OpRequest;
        [default]                                       ;
    } Info;
#else
    union {
        NTMS_DRIVEINFORMATIONA Drive;
        NTMS_DRIVETYPEINFORMATIONA DriveType;
        NTMS_I1_LIBRARYINFORMATION Library;
        NTMS_CHANGERINFORMATIONA Changer;
        NTMS_CHANGERTYPEINFORMATIONA ChangerType;
        NTMS_STORAGESLOTINFORMATION StorageSlot;
        NTMS_IEDOORINFORMATION IEDoor;
        NTMS_IEPORTINFORMATION IEPort;
        NTMS_I1_PMIDINFORMATIONA PhysicalMedia;
        NTMS_LMIDINFORMATION LogicalMedia;
        NTMS_I1_PARTITIONINFORMATIONA Partition;
        NTMS_MEDIAPOOLINFORMATION MediaPool;
        NTMS_MEDIATYPEINFORMATION MediaType;
        NTMS_I1_LIBREQUESTINFORMATIONA LibRequest;
        NTMS_I1_OPREQUESTINFORMATIONA OpRequest;
    } Info;
#endif  // MIDL_PASS
} NTMS_I1_OBJECTINFORMATIONA, *LPNTMS_I1_OBJECTINFORMATIONA;

typedef struct _NTMS_I1_OBJECTINFORMATIONW {
    DWORD       dwSize;
    DWORD       dwType;
    SYSTEMTIME  Created;
    SYSTEMTIME  Modified;
    NTMS_GUID   ObjectGuid;
    BOOL        Enabled;
    DWORD       dwOperationalState;
    WCHAR       szName[NTMS_OBJECTNAME_LENGTH];
    WCHAR       szDescription[NTMS_DESCRIPTION_LENGTH];
#ifdef MIDL_PASS
    [switch_is(dwType)] union {
        [case(NTMS_DRIVE)]              NTMS_DRIVEINFORMATIONW Drive;
        [case(NTMS_DRIVE_TYPE)]         NTMS_DRIVETYPEINFORMATIONW DriveType;
        [case(NTMS_LIBRARY)]            NTMS_I1_LIBRARYINFORMATION Library;
        [case(NTMS_CHANGER)]            NTMS_CHANGERINFORMATIONW Changer;
        [case(NTMS_CHANGER_TYPE)]       NTMS_CHANGERTYPEINFORMATIONW ChangerType;
        [case(NTMS_STORAGESLOT)]        NTMS_STORAGESLOTINFORMATION StorageSlot;
        [case(NTMS_IEDOOR)]             NTMS_IEDOORINFORMATION IEDoor;
        [case(NTMS_IEPORT)]             NTMS_IEPORTINFORMATION IEPort;
        [case(NTMS_PHYSICAL_MEDIA)]     NTMS_I1_PMIDINFORMATIONW PhysicalMedia;
        [case(NTMS_LOGICAL_MEDIA)]      NTMS_LMIDINFORMATION LogicalMedia;
        [case(NTMS_PARTITION)]          NTMS_I1_PARTITIONINFORMATIONW Partition;
        [case(NTMS_MEDIA_POOL)]         NTMS_MEDIAPOOLINFORMATION MediaPool;
        [case(NTMS_MEDIA_TYPE)]         NTMS_MEDIATYPEINFORMATION MediaType;
        [case(NTMS_LIBREQUEST)]         NTMS_I1_LIBREQUESTINFORMATIONW LibRequest;
        [case(NTMS_OPREQUEST)]          NTMS_I1_OPREQUESTINFORMATIONW OpRequest;
        [default]                                       ;
    } Info;
#else
    union {
        NTMS_DRIVEINFORMATIONW Drive;
        NTMS_DRIVETYPEINFORMATIONW DriveType;
        NTMS_I1_LIBRARYINFORMATION Library;
        NTMS_CHANGERINFORMATIONW Changer;
        NTMS_CHANGERTYPEINFORMATIONW ChangerType;
        NTMS_STORAGESLOTINFORMATION StorageSlot;
        NTMS_IEDOORINFORMATION IEDoor;
        NTMS_IEPORTINFORMATION IEPort;
        NTMS_I1_PMIDINFORMATIONW PhysicalMedia;
        NTMS_LMIDINFORMATION LogicalMedia;
        NTMS_I1_PARTITIONINFORMATIONW Partition;
        NTMS_MEDIAPOOLINFORMATION MediaPool;
        NTMS_MEDIATYPEINFORMATION MediaType;
        NTMS_I1_LIBREQUESTINFORMATIONW LibRequest;
        NTMS_I1_OPREQUESTINFORMATIONW OpRequest;
    } Info;
#endif  // MIDL_PASS
} NTMS_I1_OBJECTINFORMATIONW, *LPNTMS_I1_OBJECTINFORMATIONW;

#endif  // NTMS_NOREDEF

#ifndef NTMS_NOREDEF

//=======================================================================
// CREATENTMSMEDIA DEFINITIONS
//=======================================================================

enum NtmsCreateNtmsMediaOptions {
    NTMS_ERROR_ON_DUPLICATE         = 0x0001
};

#endif

#ifndef MIDL_PASS

//======================================================================
// OBJECT MANAGEMENT APIS
//======================================================================

#ifdef PRE_SEVIL

DWORD WINAPI GetNtmsObjectInformation(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    LPNTMS_OBJECTINFORMATION lpInfo
    );

DWORD WINAPI SetNtmsObjectInformation(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    LPNTMS_OBJECTINFORMATION lpInfo
    );

#endif

// Added by SEvilia
DWORD WINAPI GetNtmsObjectInformationA(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    LPNTMS_OBJECTINFORMATIONA lpInfo
    );

DWORD WINAPI GetNtmsObjectInformationW(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    LPNTMS_OBJECTINFORMATIONW lpInfo
    );

DWORD WINAPI SetNtmsObjectInformationA(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    LPNTMS_OBJECTINFORMATIONA lpInfo
    );

DWORD WINAPI SetNtmsObjectInformationW(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    LPNTMS_OBJECTINFORMATIONW lpInfo
    );
// END of SEVILIA

DWORD WINAPI CreateNtmsMediaA(
    HANDLE hSession,
    LPNTMS_OBJECTINFORMATIONA lpMedia,
    LPNTMS_OBJECTINFORMATIONA lpList,
    DWORD dwOptions
    ) ;

DWORD WINAPI CreateNtmsMediaW(
    HANDLE hSession,
    LPNTMS_OBJECTINFORMATIONW lpMedia,
    LPNTMS_OBJECTINFORMATIONW lpList,
    DWORD dwOptions
    ) ;

enum NtmsEnumerateOption {
    NTMS_ENUM_DEFAULT                   = 0,
    NTMS_ENUM_ROOTPOOL                  = 1
    };

DWORD WINAPI EnumerateNtmsObject(
    HANDLE hSession,
    const LPNTMS_GUID lpContainerId,
    LPNTMS_GUID lpList,
    LPDWORD lpdwListSize,
    DWORD dwType,
    DWORD dwOptions
    );

DWORD WINAPI DisableNtmsObject(
    HANDLE hSession,
    DWORD dwType,
    LPNTMS_GUID lpObjectId
    );

DWORD WINAPI EnableNtmsObject(
    HANDLE hSession,
    DWORD dwType,
    LPNTMS_GUID lpObjectId
    );

enum NtmsEjectOperation {
    NTMS_EJECT_START                = 0,
    NTMS_EJECT_STOP                 = 1,
    NTMS_EJECT_QUEUE                = 2,
    NTMS_EJECT_FORCE                = 3,
    NTMS_EJECT_IMMEDIATE            = 4,
    NTMS_EJECT_ASK_USER             = 5
};

DWORD WINAPI EjectNtmsMedia(
    HANDLE hSession,
    LPNTMS_GUID lpMediaId,
    LPNTMS_GUID lpEjectOperation,
    DWORD dwAction
    );

enum NtmsInjectOperation {
    NTMS_INJECT_START               = 0,
    NTMS_INJECT_STOP                = 1,
    NTMS_INJECT_RETRACT             = 2,
    NTMS_INJECT_STARTMANY           = 3
};

DWORD WINAPI InjectNtmsMedia(
    HANDLE hSession,
    LPNTMS_GUID lpLibraryId,
    LPNTMS_GUID lpInjectOperation,
    DWORD dwAction
    );

DWORD WINAPI AccessNtmsLibraryDoor(
    HANDLE hSession,
    LPNTMS_GUID lpLibraryId,
    DWORD dwAction
    );

DWORD WINAPI CleanNtmsDrive(
    HANDLE hSession,
    LPNTMS_GUID lpDriveId
    );

DWORD WINAPI DismountNtmsDrive(
    HANDLE hSession,
    LPNTMS_GUID lpDriveId
    );

DWORD WINAPI InventoryNtmsLibrary(
    HANDLE hSession,
    LPNTMS_GUID lpLibraryId,
    DWORD dwAction
    );

DWORD WINAPI IdentifyNtmsSlot(
    HANDLE hSession,
    LPNTMS_GUID lpSlotId,
    DWORD dwOption
    );

// definitions for the UpdateNtmsOmidInfo ...
#define NTMS_OMID_TYPE_RAW_LABEL        0x01
#define NTMS_OMID_TYPE_FILESYSTEM_INFO  0x02

typedef struct
{
    WCHAR FileSystemType[64] ;
    WCHAR VolumeName[256] ;
    DWORD SerialNumber ;
} NTMS_FILESYSTEM_INFO ;

DWORD WINAPI UpdateNtmsOmidInfo(
    HANDLE hSession,
    LPNTMS_GUID lpMediaId,
    DWORD labelType,
    DWORD numberOfBytes,
    LPVOID lpBuffer
    );

DWORD WINAPI CancelNtmsLibraryRequest(
    HANDLE hSession,
    LPNTMS_GUID lpRequestId
    );

DWORD WINAPI GetNtmsRequestOrder(
    HANDLE hSession,
    LPNTMS_GUID lpRequestId,
    LPDWORD lpdwOrderNumber
    );

DWORD WINAPI SetNtmsRequestOrder(
    HANDLE hSession,
    LPNTMS_GUID lpRequestId,
    DWORD dwOrderNumber
    );

DWORD WINAPI DeleteNtmsRequests(
    HANDLE hSession,
    LPNTMS_GUID lpRequestId,
    DWORD dwType,
    DWORD dwCount
    );

DWORD WINAPI ReserveNtmsCleanerSlot (
    HANDLE hSession,
    LPNTMS_GUID lpLibrary,
    LPNTMS_GUID lpSlot
    );

DWORD WINAPI ReleaseNtmsCleanerSlot (
    HANDLE hSession,
    LPNTMS_GUID lpLibrary
    );

DWORD WINAPI InjectNtmsCleaner (
    HANDLE hSession,
    LPNTMS_GUID lpLibrary,
    LPNTMS_GUID lpInjectOperation,
    DWORD dwNumberOfCleansLeft,
    DWORD dwAction
    );

DWORD WINAPI EjectNtmsCleaner (
    HANDLE hSession,
    LPNTMS_GUID lpLibrary,
    LPNTMS_GUID lpEjectOperation,
    DWORD dwAction
    );

DWORD WINAPI BeginNtmsDeviceChangeDetection(
    HANDLE hSession,
    LPHANDLE lpDetectHandle
    );

DWORD WINAPI SetNtmsDeviceChangeDetection(
    HANDLE hSession,
    HANDLE DetectHandle,
    LPNTMS_GUID lpRequestId,
    DWORD dwType,
    DWORD dwCount
    );

DWORD WINAPI EndNtmsDeviceChangeDetection(
    HANDLE hSession,
    HANDLE DetectHandle
    );

#endif  // MIDL_PASS

#ifndef NTMS_NOREDEF
enum NtmsDriveType {
    NTMS_UNKNOWN_DRIVE              = 0
};

#endif  // NTMS_NOREDEF

#ifndef MIDL_PASS

// Security for NTMS API
DWORD WINAPI GetNtmsObjectSecurity(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    DWORD dwType,
    SECURITY_INFORMATION RequestedInformation,
    PSECURITY_DESCRIPTOR lpSecurityDescriptor,
    DWORD nLength,
    LPDWORD lpnLengthNeeded
    );

DWORD WINAPI SetNtmsObjectSecurity(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    DWORD dwType,
    SECURITY_INFORMATION SecurityInformation,
    PSECURITY_DESCRIPTOR lpSecurityDescriptor
    );

// Security Access Control Masks :
// NTMS_USE_ACCESS is required to use an NTMS object.  For example,
// you will need this access to a library in order to mount media
// within it.
// NTMS_MODIFY_ACCESS is required to make changes to an NTMS object.
// For example, you will need modify access in order to change the name
// of an object or change its attributes.
// NTMS_CONTROL_ACCESS is required to control an NTMS object.  For
// example, you will need control access to a library in order to
// inject media, eject media, clean or open the door.
//
enum NtmsAccessMask {
    NTMS_USE_ACCESS                 = 0x1,
    NTMS_MODIFY_ACCESS              = 0x2,
    NTMS_CONTROL_ACCESS             = 0x4
};

// Generic Mappings :
#define NTMS_GENERIC_READ           NTMS_USE_ACCESS
#define NTMS_GENERIC_WRITE          (NTMS_USE_ACCESS | NTMS_MODIFY_ACCESS)
#define NTMS_GENERIC_EXECUTE        (NTMS_USE_ACCESS | NTMS_MODIFY_ACCESS | NTMS_CONTROL_ACCESS)
#define NTMS_GENERIC_ALL            (NTMS_USE_ACCESS | NTMS_MODIFY_ACCESS | NTMS_CONTROL_ACCESS)

// Maximum attribute size for NTMS Object attribute API's
#define NTMS_MAXATTR_LENGTH         0x10000

// Maximum len of attribute name (# of chars.)
#define NTMS_MAXATTR_NAMELEN        32

// Object extensions for NTMS API
DWORD WINAPI GetNtmsObjectAttributeA(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    DWORD dwType,
    LPCSTR lpAttributeName,
    LPVOID lpAttributeData,
    LPDWORD lpAttributeSize
    );

DWORD WINAPI GetNtmsObjectAttributeW(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    DWORD dwType,
    LPCWSTR lpAttributeName,
    LPVOID lpAttributeData,
    LPDWORD lpAttributeSize
    );

DWORD WINAPI SetNtmsObjectAttributeA(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    DWORD dwType,
    LPCSTR lpAttributeName,
    LPVOID lpAttributeData,
    DWORD dwAttributeSize
    );

DWORD WINAPI SetNtmsObjectAttributeW(
    HANDLE hSession,
    LPNTMS_GUID lpObjectId,
    DWORD dwType,
    LPCWSTR lpAttributeName,
    LPVOID lpAttributeData,
    DWORD AttributeSize
    );

//UI Notification
enum NtmsUITypes {
    NTMS_UITYPE_INVALID             = 0,
    NTMS_UITYPE_INFO,
    NTMS_UITYPE_REQ,
    NTMS_UITYPE_ERR,
    NTMS_UITYPE_MAX
};

enum NtmsUIOperations {
    NTMS_UIDEST_ADD                 = 1,
    NTMS_UIDEST_DELETE,
    NTMS_UIDEST_DELETEALL,
    NTMS_UIOPERATION_MAX
};

DWORD
WINAPI
GetNtmsUIOptionsA(
    __in HANDLE hSession,
    __in const LPNTMS_GUID lpObjectId,
    __in DWORD dwType,
    __out_ecount_part(*lpdwBufSize, *lpdwBufSize) LPSTR lpszDestination,
    __inout LPDWORD lpdwBufSize
    );

__success (return == ERROR_SUCCESS)
DWORD
WINAPI
GetNtmsUIOptionsW(
    __in HANDLE hSession,
    __in const LPNTMS_GUID lpObjectId,
    __in DWORD dwType,
    __out_ecount_part(*lpdwBufSize, *lpdwBufSize) LPWSTR lpszDestination,
    __inout LPDWORD lpdwBufSize
    );

DWORD WINAPI SetNtmsUIOptionsA(
    HANDLE hSession,
    const LPNTMS_GUID lpObjectId,
    DWORD dwType,
    DWORD dwOperation,
    LPCSTR lpszDestination
    );

DWORD WINAPI SetNtmsUIOptionsW(
    HANDLE hSession,
    const LPNTMS_GUID lpObjectId,
    DWORD dwType,
    DWORD dwOperation,
    LPCWSTR lpszDestination
    );


// Operator Requests
DWORD WINAPI SubmitNtmsOperatorRequestW(
    HANDLE hSession,
    DWORD dwRequest,
    LPCWSTR lpMessage,
    LPNTMS_GUID lpArg1Id,
    LPNTMS_GUID lpArg2Id,
    LPNTMS_GUID lpRequestId
    );

DWORD WINAPI SubmitNtmsOperatorRequestA(
    HANDLE hSession,
    DWORD dwRequest,
    LPCSTR lpMessage,
    LPNTMS_GUID lpArg1Id,
    LPNTMS_GUID lpArg2Id,
    LPNTMS_GUID lpRequestId
    );

DWORD WINAPI WaitForNtmsOperatorRequest(
    HANDLE hSession,
    LPNTMS_GUID lpRequestId,
    DWORD dwTimeout
    );

DWORD WINAPI CancelNtmsOperatorRequest(
    HANDLE hSession,
    LPNTMS_GUID lpRequestId
    );

DWORD WINAPI SatisfyNtmsOperatorRequest(
    HANDLE hSession,
    LPNTMS_GUID lpRequestId
    );

#endif  // MIDL_PASS

#ifndef NTMS_NOREDEF

enum NtmsNotificationOperations {
    NTMS_OBJ_UPDATE                 = 1,
    NTMS_OBJ_INSERT                 = 2,
    NTMS_OBJ_DELETE                 = 3,
    NTMS_EVENT_SIGNAL               = 4,
    NTMS_EVENT_COMPLETE             = 5
};

// object notification
typedef struct _NTMS_NOTIFICATIONINFORMATION {
    DWORD dwOperation;
    NTMS_GUID ObjectId;
} NTMS_NOTIFICATIONINFORMATION, *LPNTMS_NOTIFICATIONINFORMATION;

#endif  // NTMS_NOREDEF

#ifndef MIDL_PASS

DWORD WINAPI ImportNtmsDatabase(
    HANDLE hSession
    );

DWORD WINAPI ExportNtmsDatabase(
    HANDLE hSession
    );

#endif  // MIDL_PASS

#ifndef MIDL_PASS

DWORD WINAPI ImportNtmsDatabase(
    HANDLE hSession
    );

DWORD WINAPI ExportNtmsDatabase(
    HANDLE hSession
    );

#endif  // MIDL_PASS

#ifndef MIDL_PASS

HANDLE WINAPI OpenNtmsNotification(
    HANDLE hSession,
    DWORD dwType
    );

DWORD WINAPI WaitForNtmsNotification(
    HANDLE hNotification,
    LPNTMS_NOTIFICATIONINFORMATION lpNotificationInformation,
    DWORD dwTimeout
    );

DWORD WINAPI CloseNtmsNotification(
    HANDLE hNotification
    );

#endif  // MIDL_PASS

#ifndef MIDL_PASS

DWORD WINAPI EjectDiskFromSADriveW(
    LPCWSTR lpComputerName,
    LPCWSTR lpAppName,
    LPCWSTR lpDeviceName,
    HWND hWnd,
    LPCWSTR lpTitle,
    LPCWSTR lpMessage,
    DWORD dwOptions
    );

DWORD WINAPI EjectDiskFromSADriveA(
    LPCSTR lpComputerName,
    LPCSTR lpAppName,
    LPCSTR lpDeviceName,
    HWND hWnd,
    LPCSTR lpTitle,
    LPCSTR lpMessage,
    DWORD dwOptions
    );

#endif

#ifndef MIDL_PASS

DWORD
WINAPI
GetVolumesFromDriveW(
    __in LPWSTR pszDriveName,
    __deref_out LPWSTR *VolumeNameBufferPtr,
    __deref_out LPWSTR *DriveLetterBufferPtr
    );

DWORD
WINAPI
GetVolumesFromDriveA(
    __in LPSTR pszDriveName,
    __deref_out LPSTR *VolumeNameBufferPtr,
    __deref_out LPSTR *DriveLetterBufferPtr
    );

#endif

#ifdef __cplusplus
} // end extern "C"
#endif

#pragma pack()

#endif // _INCL_NTMSAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NTQuery.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  File:       NtQuery.h
//
//  Contents:   Main query header; Defines all exported query API
//
//----------------------------------------------------------------------------

#if !defined(__NTQUERY_H__)
#define __NTQUERY_H__

#if _MSC_VER > 1000
#pragma once
#endif

#include "stgprop.h"

#if defined(__cplusplus)
extern "C"
{
#endif

//
// Use this path for the null catalog, one that doesn't have an index.
// Use it to search for properties of files that are not indexed.
//

#define CINULLCATALOG L"::_noindex_::"

//
// Use this path to connect to the server for administration work
// (i.e. DocStoreAdmin.) No catalog is associated with the connection
//

#define CIADMIN L"::_nodocstore_::"

//
// Minimal support for persistent handlers.
//

STDAPI LoadIFilter( PCWSTR pwcsPath,
                    __in IUnknown * pUnkOuter,
                    __deref_out void ** ppIUnk );

#define LIFF_LOAD_DEFINED_FILTER                   1
#define LIFF_IMPLEMENT_TEXT_FILTER_FALLBACK_POLICY 2
#define LIFF_FORCE_TEXT_FILTER_FALLBACK            3

STDAPI LoadIFilterEx( PCWSTR pwcsPath,
                      DWORD dwFlags,
                      REFIID riid,
                      __deref_out void ** ppIUnk );
                      
STDAPI BindIFilterFromStorage(__in IStorage * pStg,
                              __in IUnknown * pUnkOuter,
                              __deref_out void ** ppIUnk );

STDAPI BindIFilterFromStream(__in IStream * pStm,
                             __in IUnknown * pUnkOuter,
                             __deref_out void ** ppIUnk );

STDAPI LocateCatalogsW(__in WCHAR const * pwszScope,
                       ULONG         iBmk,
                       __out_ecount_part(*pccMachine, *pccMachine) LPWSTR    pwszMachine,
                       __inout ULONG *       pccMachine,
                       __out_ecount_part(*pccCat, *pccCat) WCHAR *                pwszCat,
                       __inout ULONG *       pccCat);

//
// For calling from VB
//

STDAPI LocateCatalogsA( PCSTR pwszScope,
                        ULONG iBmk,
                        __out_ecount_part(*pccMachine, *pccMachine) char * pwszMachine,
                        __inout ULONG * pccMachine,
                        __out_ecount_part(*pccCat, *pccCat) char * pwszCat,
                        __inout ULONG * pccCat );

#ifdef UNICODE
#define LocateCatalogs  LocateCatalogsW
#else
#define LocateCatalogs  LocateCatalogsA
#endif // !UNICODE

// The Index Server Data Source Object CLSID

#define CLSID_INDEX_SERVER_DSO \
    { 0xF9AE8980, 0x7E52, 0x11d0, \
      { 0x89, 0x64, 0x00, 0xC0, 0x4F, 0xD6, 0x11, 0xD7 } }


// The filename PKEY_Filename property set
#define PSGUID_FILENAME \
    { 0x41CF5AE0, 0xF75A, 0x4806, \
      { 0xBD, 0x87, 0x59, 0xC7, 0xD9, 0x24, 0x8E, 0xB9} }
#define PID_FILENAME 100


// File System Content Index Framework property set

#define DBPROPSET_FSCIFRMWRK_EXT \
    { 0xA9BD1526, 0x6A80, 0x11D0, \
      { 0x8C, 0x9D, 0x00, 0x20, 0xAF, 0x1D, 0x74, 0x0E } }

#define DBPROP_CI_CATALOG_NAME     2
#define DBPROP_CI_INCLUDE_SCOPES   3
#define DBPROP_CI_DEPTHS           4 // obsolete
#define DBPROP_CI_SCOPE_FLAGS      4
#define DBPROP_CI_EXCLUDE_SCOPES   5
#define DBPROP_CI_SECURITY_ID      6
#define DBPROP_CI_QUERY_TYPE       7
#define DBPROP_CI_PROVIDER         8

// The VT_UI4 value of DBPROP_CI_PROVIDER

#define CI_PROVIDER_MSSEARCH          1          // Only try MSSearch
#define CI_PROVIDER_INDEXING_SERVICE  2          // Only try Indexing Service
#define CI_PROVIDER_ALL               0xffffffff // Try all -- the default

// Session level Query Extension property set

#define DBPROPSET_SESS_QUERYEXT \
    { 0x63623309, 0x2d8b, 0x4d17, \
      { 0xb1, 0x52, 0x6e, 0x29, 0x56, 0xc2, 0x6a, 0x70 } }

#define DBPROP_DEFAULT_EQUALS_BEHAVIOR   2

// Query Extension property set

#define DBPROPSET_QUERYEXT \
    { 0xA7AC77ED, 0xF8D7, 0x11CE, \
      { 0xA7, 0x98, 0x00, 0x20, 0xF8, 0x00, 0x80, 0x25 } }

#define DBPROP_USECONTENTINDEX           2
#define DBPROP_DEFERNONINDEXEDTRIMMING   3
#define DBPROP_USEEXTENDEDDBTYPES        4
#define DBPROP_IGNORENOISEONLYCLAUSES    5
#define DBPROP_GENERICOPTIONS_STRING     6
#define DBPROP_FIRSTROWS                 7
#define DBPROP_DEFERCATALOGVERIFICATION  8
#define DBPROP_CATALOGLISTID             9
#define DBPROP_GENERATEPARSETREE        10
#define DBPROP_APPLICATION_NAME         11
#define DBPROP_FREETEXTANYTERM          12
#define DBPROP_FREETEXTUSESTEMMING      13
#define DBPROP_IGNORESBRI               14

// Content Index Framework Core property set

#define DBPROPSET_CIFRMWRKCORE_EXT \
    { 0xafafaca5, 0xb5d1, 0x11d0, \
      { 0x8c, 0x62, 0x00, 0xc0, 0x4f, 0xc2, 0xdb, 0x8d } }

#define DBPROP_MACHINE      2
#define DBPROP_CLIENT_CLSID 3

// MSIDXS Rowset property set

#define DBPROPSET_MSIDXS_ROWSETEXT \
    { 0xaa6ee6b0, 0xe828, 0x11d0, \
      { 0xb2, 0x3e, 0x00, 0xaa, 0x00, 0x47, 0xfc, 0x01 } }

#define MSIDXSPROP_ROWSETQUERYSTATUS        2
#define MSIDXSPROP_COMMAND_LOCALE_STRING    3
#define MSIDXSPROP_QUERY_RESTRICTION        4
#define MSIDXSPROP_PARSE_TREE               5
#define MSIDXSPROP_MAX_RANK                 6
#define MSIDXSPROP_RESULTS_FOUND            7

//
// Query status values returned by MSIDXSPROP_ROWSETQUERYSTATUS
//
// Bits   Effect
// -----  -----------------------------------------------------
// 00-02  Fill Status: How data is being updated, if at all.
// 03-15  Bitfield query reliability: How accurate the result is

#define STAT_BUSY                       ( 0 )
#define STAT_ERROR                      ( 0x1 )
#define STAT_DONE                       ( 0x2 )
#define STAT_REFRESH                    ( 0x3 )
#define QUERY_FILL_STATUS(x)            ( ( x ) & 0x7 )

#define STAT_PARTIAL_SCOPE              ( 0x8 )
#define STAT_NOISE_WORDS                ( 0x10 )
#define STAT_CONTENT_OUT_OF_DATE        ( 0x20 )
#define STAT_REFRESH_INCOMPLETE         ( 0x40 )
#define STAT_CONTENT_QUERY_INCOMPLETE   ( 0x80 )
#define STAT_TIME_LIMIT_EXCEEDED        ( 0x100 )
#define STAT_SHARING_VIOLATION          ( 0x200 )
#define STAT_MISSING_RELDOC             ( 0x400 )
#define STAT_MISSING_PROP_IN_RELDOC     ( 0x800 )
#define STAT_RELDOC_ACCESS_DENIED       ( 0x1000 )
#define STAT_COALESCE_COMP_ALL_NOISE    ( 0x2000 )
#define QUERY_RELIABILITY_STATUS(x)     ( ( x ) & 0xFFF8 )

// Scope flags

#define QUERY_SHALLOW        0
#define QUERY_DEEP           1
#define QUERY_PHYSICAL_PATH  0
#define QUERY_VIRTUAL_PATH   2

// query property set (PSGUID_QUERY) properties not defined in oledb.h

#define PROPID_QUERY_WORKID        5
#define PROPID_QUERY_UNFILTERED    7
#define PROPID_QUERY_VIRTUALPATH   9
#define PROPID_QUERY_LASTSEENTIME 10

//
// Change or get the current state of a catalog specified.
//
#define CICAT_STOPPED     0x1
#define CICAT_READONLY    0x2
#define CICAT_WRITABLE    0x4
#define CICAT_NO_QUERY    0x8
#define CICAT_GET_STATE   0x10
#define CICAT_ALL_OPENED  0x20

STDAPI SetCatalogState ( WCHAR const * pwcsCat,
                         WCHAR const * pwcsMachine,
                         DWORD dwNewState,
                         DWORD * pdwOldState );

//
// Query catalog state
//

#define CI_STATE_SHADOW_MERGE          0x0001    // Index is performing a shadow merge
#define CI_STATE_MASTER_MERGE          0x0002    // Index is performing a master merge
#define CI_STATE_CONTENT_SCAN_REQUIRED 0x0004    // Index is likely corrupt, and a rescan is required
#define CI_STATE_ANNEALING_MERGE       0x0008    // Index is performing an annealing (optimizing) merge
#define CI_STATE_SCANNING              0x0010    // Scans are in-progress
#define CI_STATE_RECOVERING            0x0020    // Index metadata is being recovered
#define CI_STATE_INDEX_MIGRATION_MERGE 0x0040    // Reserved for future use
#define CI_STATE_LOW_MEMORY            0x0080    // Indexing is paused due to low memory availability
#define CI_STATE_HIGH_IO               0x0100    // Indexing is paused due to a high rate of I/O
#define CI_STATE_MASTER_MERGE_PAUSED   0x0200    // Master merge is paused
#define CI_STATE_READ_ONLY             0x0400    // Indexing has been manually paused (read-only)
#define CI_STATE_BATTERY_POWER         0x0800    // Indexing is paused to conserve battery life
#define CI_STATE_USER_ACTIVE           0x1000    // Indexing is paused due to high user activity (keyboard/mouse)
#define CI_STATE_STARTING              0x2000    // Index is still starting up
#define CI_STATE_READING_USNS          0x4000    // USNs on NTFS volumes are being processed
#define CI_STATE_DELETION_MERGE        0x8000    // Index is performing a deletion merge
#define CI_STATE_LOW_DISK             0x10000    // Index is paused due to low disk availability
#define CI_STATE_HIGH_CPU             0x20000    // Index is paused due to high CPU

#ifndef CI_STATE_DEFINED
#define CI_STATE_DEFINED
#include <pshpack4.h>
typedef struct  _CI_STATE
    {
    DWORD cbStruct;
    DWORD cWordList;
    DWORD cPersistentIndex;
    DWORD cQueries;
    DWORD cDocuments;
    DWORD cFreshTest;
    DWORD dwMergeProgress;
    DWORD eState;
    DWORD cFilteredDocuments;
    DWORD cTotalDocuments;
    DWORD cPendingScans;
    DWORD dwIndexSize;
    DWORD cUniqueKeys;
    DWORD cSecQDocuments;
    DWORD dwPropCacheSize;
    }   CI_STATE;

#include <poppack.h>
#endif   // CI_STATE_DEFINED

STDAPI CIState( WCHAR const * pwcsCat,
                WCHAR const * pwcsMachine,
                CI_STATE *    pCiState );

#if defined __ICommand_INTERFACE_DEFINED__

//
// Create an ICommand, specifying scopes, catalogs, and machines
//
STDAPI CIMakeICommand( ICommand **           ppCommand,
                       ULONG                 cScope,
                       DWORD const *         aDepths,
                       WCHAR const * const * awcsScope,
                       WCHAR const * const * awcsCatalogs,
                       WCHAR const * const * awcsMachine );

//
// Create an ICommand, specifying a catalog and machine
//

STDAPI CICreateCommand( IUnknown **   ppCommand,     // New object
                        IUnknown *    pUnkOuter,     // Outer unknown
                        REFIID        riid,          // IID of returned object.
                                                     // Must be IID_IUnknown unless pUnkOuter == 0
                        WCHAR const * pwcsCatalog,   // Catalog
                        WCHAR const * pwcsMachine ); // Machine


#if defined __ICommandTree_INTERFACE_DEFINED__

#ifndef __propertydef_h__

typedef struct tagCIPROPERTYDEF
{
    LPWSTR wcsFriendlyName;
    DWORD  dbType;
    DBID   dbCol;
} CIPROPERTYDEF;

#endif //__propertydef_h__

//
// Values for ulDialect in CITextToSelectTreeEx and CITextToFullTreeEx
//

#define ISQLANG_V1 1 // Same as the non-Ex versions
#define ISQLANG_V2 2

//
// Convert pwszRestriction in Triplish to a command tree.
//
STDAPI CITextToSelectTree( WCHAR const *     pwszRestriction,
                           DBCOMMANDTREE * * ppTree,
                           ULONG             cProperties,
             /*optional*/  CIPROPERTYDEF *   pProperties,
                           LCID              LocaleID );

STDAPI CITextToSelectTreeEx( WCHAR const *     pwszRestriction,
                             ULONG             ulDialect,
                             DBCOMMANDTREE * * ppTree,
                             ULONG             cProperties,
               /*optional*/  CIPROPERTYDEF *   pProperties,
                             LCID              LocaleID );

//
// Convert pwszRestriction in Triplish, project columns, sort columns
// and grouping columns to a command tree.
//
STDAPI CITextToFullTree( WCHAR const *     pwszRestriction,
                         WCHAR const *     pwszColumns,
                         WCHAR const *     pwszSortColumns, // may be NULL
                         WCHAR const *     pwszGroupings,   // may be NULL
                         DBCOMMANDTREE * * ppTree,
                         ULONG             cProperties,
           /*optional*/  CIPROPERTYDEF *   pProperties,
                         LCID              LocaleID );

STDAPI CITextToFullTreeEx( WCHAR const *     pwszRestriction,
                           ULONG             ulDialect,
                           WCHAR const *     pwszColumns,
                           WCHAR const *     pwszSortColumns, // may be NULL
                           WCHAR const *     pwszGroupings,   // may be NULL
                           DBCOMMANDTREE * * ppTree,
                           ULONG             cProperties,
             /*optional*/  CIPROPERTYDEF *   pProperties,
                           LCID              LocaleID );

//
// Build a simple restriction node.
//

STDAPI CIBuildQueryNode( WCHAR const *wcsProperty,    // friendly property name
                         DBCOMMANDOP dbOperator,    // enumerated constant
                         PROPVARIANT const *pvarPropertyValue, // value of the property
                         DBCOMMANDTREE ** ppTree, // ptr to tree returned here. should be non-null
                         ULONG cProperties,
                         CIPROPERTYDEF const * pProperty, // Can be 0.
                         LCID LocaleID );  // locale id to interpret strings

//
// Build a restriction tree from an existing tree (could be empty) and a newly added node/tree.
//

STDAPI CIBuildQueryTree( DBCOMMANDTREE const *pExistingTree,  // existing tree. can be null.
                         DBCOMMANDOP dbBoolOp,   // enumerator constant
                         ULONG cSiblings, // number of siblings in the array
                         DBCOMMANDTREE const * const *ppSibsToCombine,
                         DBCOMMANDTREE ** ppTree);   // ptr to tree returned here. should be non-null

//
// Convert restriction tree, project columns, sort columns
// and grouping columns to a command tree.
//
STDAPI CIRestrictionToFullTree( DBCOMMANDTREE const *pTree,
                         WCHAR const * pwszColumns,
                         WCHAR const * pwszSortColumns, // may be NULL
                         WCHAR const * pwszGroupings,   // may be NULL
                         DBCOMMANDTREE * * ppTree,
                         ULONG cProperties,
           /*optional*/  CIPROPERTYDEF * pReserved,
                         LCID LocaleID );

#endif  // __ICommandTree_INTERFACE_DEFINED__
#endif  // __ICommand_INTERFACE_DEFINED__

#if defined(__cplusplus)
}
#endif

#endif // __NTQUERY_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\win2k8\sdk\include\NTSecAPI.h ===
/*++ BUILD Version: 0000     Increment this if a change has global effects

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ntsecapi.h

Abstract:

    This module defines the Local Security Authority APIs.

Revision History:

--*/





//
// All the subcategories are named as <Audit_CategoryName_SubCategoryName>
//

#ifdef DEFINE_GUID

/* 0cce9210-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_SecurityStateChange_defined)
    DEFINE_GUID(
        Audit_System_SecurityStateChange, 
        0x0cce9210, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_System_SecurityStateChange_defined
    #endif
#endif

/* 0cce9211-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_SecuritySubsystemExtension_defined)
    DEFINE_GUID(
        Audit_System_SecuritySubsystemExtension, 
        0x0cce9211, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_System_SecuritySubsystemExtension_defined
    #endif
#endif

/* 0cce9212-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_Integrity_defined)
    DEFINE_GUID(
        Audit_System_Integrity, 
        0x0cce9212, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_System_Integrity_defined
    #endif
#endif

/* 0cce9213-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_IPSecDriverEvents_defined)
    DEFINE_GUID(
        Audit_System_IPSecDriverEvents, 
        0x0cce9213, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_System_IPSecDriverEvents_defined
    #endif
#endif

/* 0cce9214-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_Others_defined)
    DEFINE_GUID(
        Audit_System_Others, 
        0x0cce9214, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_System_Others_defined
    #endif
#endif

/* 0cce9215-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_Logon_defined)
    DEFINE_GUID(
        Audit_Logon_Logon, 
        0x0cce9215, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_Logon_Logon_defined
    #endif
#endif

/* 0cce9216-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_Logoff_defined)
    DEFINE_GUID(
        Audit_Logon_Logoff, 
        0x0cce9216, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_Logon_Logoff_defined
    #endif
#endif

/* 0cce9217-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_AccountLockout_defined)
    DEFINE_GUID(
        Audit_Logon_AccountLockout, 
        0x0cce9217, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_Logon_AccountLockout_defined
    #endif
#endif

/* 0cce9218-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_IPSecMainMode_defined)
    DEFINE_GUID(
        Audit_Logon_IPSecMainMode, 
        0x0cce9218, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_Logon_IPSecMainMode_defined
    #endif
#endif

/* 0cce9219-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_IPSecQuickMode_defined)
    DEFINE_GUID(
        Audit_Logon_IPSecQuickMode, 
        0x0cce9219, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_Logon_IPSecQuickMode_defined
    #endif
#endif

/* 0cce921a-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_IPSecUserMode_defined)
    DEFINE_GUID(
        Audit_Logon_IPSecUserMode, 
        0x0cce921a, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_Logon_IPSecUserMode_defined
    #endif
#endif

/* 0cce921b-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_SpecialLogon_defined)
    DEFINE_GUID(
        Audit_Logon_SpecialLogon, 
        0x0cce921b, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_Logon_SpecialLogon_defined
    #endif
#endif

/* 0cce921c-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_Others_defined)
    DEFINE_GUID(
        Audit_Logon_Others, 
        0x0cce921c, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_Logon_Others_defined
    #endif
#endif

/* 0cce921d-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_FileSystem_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_FileSystem, 
        0x0cce921d, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_ObjectAccess_FileSystem_defined
    #endif
#endif

/* 0cce921e-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Registry_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Registry, 
        0x0cce921e, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_ObjectAccess_Registry_defined
    #endif
#endif

/* 0cce921f-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Kernel_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Kernel, 
        0x0cce921f, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_ObjectAccess_Kernel_defined
    #endif
#endif

/* 0cce9220-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Sam_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Sam, 
        0x0cce9220, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_ObjectAccess_Sam_defined
    #endif
#endif

/* 0cce9221-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_CertificationServices_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_CertificationServices, 
        0x0cce9221, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_ObjectAccess_CertificationServices_defined
    #endif
#endif

/* 0cce9222-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_ApplicationGenerated_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_ApplicationGenerated, 
        0x0cce9222, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_ObjectAccess_ApplicationGenerated_defined
    #endif
#endif

/*
The Audit_ObjectAccess_Handle sub-category behaves different from the other sub-categories.
For handle based audits to be generated (Open handle AuditId: 0x1230, Close handle AuditId:
0x1232), the corresponding object sub-category AND Audit_ObjectAccess_Handle must be 
enabled. For eg, to generate handle based audits for Reg keys, both 
Audit_ObjectAccess_Registry and Audit_ObjectAccess_Handle must be enabled
*/

/* 0cce9223-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Handle_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Handle, 
        0x0cce9223, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_ObjectAccess_Handle_defined
    #endif
#endif

/* 0cce9224-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Share_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Share, 
        0x0cce9224, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_ObjectAccess_Share_defined
    #endif
#endif

/* 0cce9225-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_FirewallPacketDrops_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_FirewallPacketDrops, 
        0x0cce9225, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_ObjectAccess_FirewallPacketDrops_defined
    #endif
#endif

/* 0cce9226-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_FirewallConnection_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_FirewallConnection, 
        0x0cce9226, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_ObjectAccess_FirewallConnection_defined
    #endif
#endif

/* 0cce9227-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_Other_defined)
    DEFINE_GUID(
        Audit_ObjectAccess_Other, 
        0x0cce9227, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_ObjectAccess_Other_defined
    #endif
#endif

/* 0cce9228-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PrivilegeUse_Sensitive_defined)
    DEFINE_GUID(
        Audit_PrivilegeUse_Sensitive, 
        0x0cce9228, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_PrivilegeUse_Sensitive_defined
    #endif
#endif

/* 0cce9229-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PrivilegeUse_NonSensitive_defined)
    DEFINE_GUID(
        Audit_PrivilegeUse_NonSensitive, 
        0x0cce9229, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_PrivilegeUse_NonSensitive_defined
    #endif
#endif

/* 0cce922a-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PrivilegeUse_Others_defined)
    DEFINE_GUID(
        Audit_PrivilegeUse_Others, 
        0x0cce922a, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_PrivilegeUse_Others_defined
    #endif
#endif

/* 0cce922b-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_ProcessCreation_defined)
    DEFINE_GUID(
        Audit_DetailedTracking_ProcessCreation, 
        0x0cce922b, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_DetailedTracking_ProcessCreation_defined
    #endif
#endif

/* 0cce922c-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_ProcessTermination_defined)
    DEFINE_GUID(
        Audit_DetailedTracking_ProcessTermination, 
        0x0cce922c, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_DetailedTracking_ProcessTermination_defined
    #endif
#endif

/* 0cce922d-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_DpapiActivity_defined)
    DEFINE_GUID(
        Audit_DetailedTracking_DpapiActivity, 
        0x0cce922d, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_DetailedTracking_DpapiActivity_defined
    #endif
#endif

/* 0cce922e-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_RpcCall_defined)
    DEFINE_GUID(
        Audit_DetailedTracking_RpcCall, 
        0x0cce922e, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_DetailedTracking_RpcCall_defined
    #endif
#endif

/* 0cce922f-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_AuditPolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_AuditPolicy, 
        0x0cce922f, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_PolicyChange_AuditPolicy_defined
    #endif
#endif

/* 0cce9230-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_AuthenticationPolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_AuthenticationPolicy, 
        0x0cce9230, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_PolicyChange_AuthenticationPolicy_defined
    #endif
#endif

/* 0cce9231-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_AuthorizationPolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_AuthorizationPolicy, 
        0x0cce9231, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_PolicyChange_AuthorizationPolicy_defined
    #endif
#endif

/* 0cce9232-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_MpsscvRulePolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_MpsscvRulePolicy, 
        0x0cce9232, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_PolicyChange_MpsscvRulePolicy_defined
    #endif
#endif

/* 0cce9233-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_WfpIPSecPolicy_defined)
    DEFINE_GUID(
        Audit_PolicyChange_WfpIPSecPolicy, 
        0x0cce9233, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_PolicyChange_WfpIPSecPolicy_defined
    #endif
#endif

/* 0cce9234-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_Others_defined)
    DEFINE_GUID(
        Audit_PolicyChange_Others, 
        0x0cce9234, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_PolicyChange_Others_defined
    #endif
#endif

/* 0cce9235-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_UserAccount_defined)
    DEFINE_GUID(
        Audit_AccountManagement_UserAccount, 
        0x0cce9235, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_AccountManagement_UserAccount_defined
    #endif
#endif

/* 0cce9236-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_ComputerAccount_defined)
    DEFINE_GUID(
        Audit_AccountManagement_ComputerAccount, 
        0x0cce9236, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_AccountManagement_ComputerAccount_defined
    #endif
#endif

/* 0cce9237-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_SecurityGroup_defined)
    DEFINE_GUID(
        Audit_AccountManagement_SecurityGroup, 
        0x0cce9237, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_AccountManagement_SecurityGroup_defined
    #endif
#endif

/* 0cce9238-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_DistributionGroup_defined)
    DEFINE_GUID(
        Audit_AccountManagement_DistributionGroup, 
        0x0cce9238, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_AccountManagement_DistributionGroup_defined
    #endif
#endif

/* 0cce9239-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_ApplicationGroup_defined)
    DEFINE_GUID(
        Audit_AccountManagement_ApplicationGroup, 
        0x0cce9239, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_AccountManagement_ApplicationGroup_defined
    #endif
#endif

/* 0cce923a-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_Others_defined)
    DEFINE_GUID(
        Audit_AccountManagement_Others, 
        0x0cce923a, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_AccountManagement_Others_defined
    #endif
#endif

/* 0cce923b-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DSAccess_DSAccess_defined)
    DEFINE_GUID(
        Audit_DSAccess_DSAccess, 
        0x0cce923b, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_DSAccess_DSAccess_defined
    #endif
#endif

/* 0cce923c-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DsAccess_AdAuditChanges_defined)
    DEFINE_GUID(
        Audit_DsAccess_AdAuditChanges, 
        0x0cce923c, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_DsAccess_AdAuditChanges_defined
    #endif
#endif

/* 0cce923d-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Ds_Replication_defined)
    DEFINE_GUID(
        Audit_Ds_Replication, 
        0x0cce923d, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_Ds_Replication_defined
    #endif
#endif

/* 0cce923e-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Ds_DetailedReplication_defined)
    DEFINE_GUID(
        Audit_Ds_DetailedReplication, 
        0x0cce923e, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_Ds_DetailedReplication_defined
    #endif
#endif

/* 0cce923f-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_CredentialValidation_defined)
    DEFINE_GUID(
        Audit_AccountLogon_CredentialValidation, 
        0x0cce923f, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_AccountLogon_CredentialValidation_defined
    #endif
#endif

/* 0cce9240-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_Kerberos_defined)
    DEFINE_GUID(
        Audit_AccountLogon_Kerberos, 
        0x0cce9240, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_AccountLogon_Kerberos_defined
    #endif
#endif

/* 0cce9241-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_Others_defined)
    DEFINE_GUID(
        Audit_AccountLogon_Others, 
        0x0cce9241, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_AccountLogon_Others_defined
    #endif
#endif

/* 0cce9242-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_KerbCredentialValidation_defined)
    DEFINE_GUID(
        Audit_AccountLogon_KerbCredentialValidation, 
        0x0cce9242, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_AccountLogon_KerbCredentialValidation_defined
    #endif
#endif

/* 0cce9243-69ae-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_NPS_defined)
    DEFINE_GUID(
        Audit_Logon_NPS, 
        0x0cce9243, 
        0x69ae, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_Logon_NPS_defined
    #endif
#endif


#endif // DEFINE_GUID


//
// All categories are named as <Audit_CategoryName>
//

#ifdef DEFINE_GUID

/* 69979848-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_System_defined)
    DEFINE_GUID(
        Audit_System, 
        0x69979848, 
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_System_defined
    #endif
#endif

/* 69979849-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_Logon_defined)
    DEFINE_GUID(
        Audit_Logon, 
        0x69979849, 
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_Logon_defined
    #endif
#endif

/* 6997984a-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_ObjectAccess_defined)
    DEFINE_GUID(
        Audit_ObjectAccess,
        0x6997984a, 
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_ObjectAccess_defined
    #endif
#endif

/* 6997984b-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PrivilegeUse_defined)
    DEFINE_GUID(
        Audit_PrivilegeUse, 
        0x6997984b, 
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_PrivilegeUse_defined
    #endif
#endif

/* 6997984c-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DetailedTracking_defined)
    DEFINE_GUID(
        Audit_DetailedTracking, 
        0x6997984c, 
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_DetailedTracking_defined
    #endif
#endif

/* 6997984d-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_PolicyChange_defined)
    DEFINE_GUID(
        Audit_PolicyChange, 
        0x6997984d, 
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_PolicyChange_defined
    #endif
#endif

/* 6997984e-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountManagement_defined)
    DEFINE_GUID(
        Audit_AccountManagement, 
        0x6997984e, 
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_AccountManagement_defined
    #endif
#endif

/* 6997984f-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_DirectoryServiceAccess_defined)
    DEFINE_GUID(
        Audit_DirectoryServiceAccess, 
        0x6997984f, 
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_DirectoryServiceAccess_defined
    #endif
#endif

/* 69979850-797a-11d9-bed3-505054503030 */
#if !defined(INITGUID) || !defined(Audit_AccountLogon_defined)
    DEFINE_GUID(
        Audit_AccountLogon, 
        0x69979850, 
        0x797a, 0x11d9, 0xbe, 0xd3, 0x50, 0x50, 0x54, 0x50, 0x30, 0x30
        );
    #ifdef INITGUID
    #define Audit_AccountLogon_defined
    #endif
#endif

#endif // DEFINE_GUID




#ifndef _NTSECAPI_
#define _NTSECAPI_

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _NTDEF_
typedef LONG NTSTATUS, *PNTSTATUS;
#endif

#ifndef _NTLSA_IFS_
// begin_ntifs


//
// Security operation mode of the system is held in a control
// longword.
//

typedef ULONG  LSA_OPERATIONAL_MODE, *PLSA_OPERATIONAL_MODE;

// end_ntifs
#endif // _NTLSA_IFS_

//
// The flags in the security operational mode are defined
// as:
//
//    PasswordProtected - Some level of authentication (such as
//        a password) must be provided by users before they are
//        allowed to use the system.  Once set, this value will
//        not be cleared without re-booting the system.
//
//    IndividualAccounts - Each user must identify an account to
//        logon to.  This flag is only meaningful if the
//        PasswordProtected flag is also set.  If this flag is
//        not set and the PasswordProtected flag is set, then all
//        users may logon to the same account.  Once set, this value
//        will not be cleared without re-booting the system.
//
//    MandatoryAccess - Indicates the system is running in a mandatory
//        access control mode (e.g., B-level as defined by the U.S.A's
//        Department of Defense's "Orange Book").  This is not utilized
//        in the current release of NT.  This flag is only meaningful
//        if both the PasswordProtected and IndividualAccounts flags are
//        set.  Once set, this value will not be cleared without
//        re-booting the system.
//
//    LogFull - Indicates the system has been brought up in a mode in
//        which if must perform security auditing, but its audit log
//        is full.  This may (should) restrict the operations that
//        can occur until the audit log is made not-full again.  THIS
//        VALUE MAY BE CLEARED WHILE THE SYSTEM IS RUNNING (I.E., WITHOUT
//        REBOOTING).
//
// If the PasswordProtected flag is not set, then the system is running
// without security, and user interface should be adjusted appropriately.
//

#define LSA_MODE_PASSWORD_PROTECTED     (0x00000001L)
#define LSA_MODE_INDIVIDUAL_ACCOUNTS    (0x00000002L)
#define LSA_MODE_MANDATORY_ACCESS       (0x00000004L)
#define LSA_MODE_LOG_FULL               (0x00000008L)

#ifndef _NTLSA_IFS_
// begin_ntifs
//
// Used by a logon process to indicate what type of logon is being
// requested.
//

typedef enum _SECURITY_LOGON_TYPE {
    UndefinedLogonType = 0, // This is used to specify an undefied logon type
    Interactive = 2,      // Interactively logged on (locally or remotely)
    Network,              // Accessing system via network
    Batch,                // Started via a batch queue
    Service,              // Service started by service controller
    Proxy,                // Proxy logon
    Unlock,               // Unlock workstation
    NetworkCleartext,     // Network logon with cleartext credentials
    NewCredentials,       // Clone caller, new default credentials
    //The types below only exist in Windows XP and greater
#if (_WIN32_WINNT >= 0x0501)
    RemoteInteractive,  // Remote, yet interactive. Terminal server
    CachedInteractive,  // Try cached credentials without hitting the net.
    // The types below only exist in Windows Server 2003 and greater
#endif
#if (_WIN32_WINNT >= 0x0502)
    CachedRemoteInteractive, // Same as RemoteInteractive, this is used internally for auditing purpose
    CachedUnlock        // Cached Unlock workstation
#endif
} SECURITY_LOGON_TYPE, *PSECURITY_LOGON_TYPE;

// end_ntifs
#endif // _NTLSA_IFS_

#ifndef _NTLSA_IFS_
// begin_ntifs

//
// All of this stuff (between the Ifndef _NTLSA_AUDIT_ and its endif) were not
// present in NTIFS prior to Windows Server 2003 SP1. All of the definitions however
// exist down to windows 2000 (except for the few exceptions noted in the code).
//

#ifndef _NTLSA_AUDIT_
#define _NTLSA_AUDIT_

/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Data types related to Auditing                                      //
//                                                                     //
/////////////////////////////////////////////////////////////////////////


//
// The following enumerated type is used between the reference monitor and
// LSA in the generation of audit messages.  It is used to indicate the
// type of data being passed as a parameter from the reference monitor
// to LSA.  LSA is responsible for transforming the specified data type
// into a set of unicode strings that are added to the event record in
// the audit log.
//

typedef enum _SE_ADT_PARAMETER_TYPE {

    SeAdtParmTypeNone = 0,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  None.
                                    //
                                    //Results in:
                                    //
                                    //  a unicode string containing "-".
                                    //
                                    //Note:  This is typically used to
                                    //       indicate that a parameter value
                                    //       was not available.
                                    //

    SeAdtParmTypeString,            //Produces 1 parameter.
                                    //Received Value:
                                    //
                                    //  Unicode String (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  No transformation.  The string
                                    //  entered into the event record as
                                    //  received.
                                    //
                                    // The Address value of the audit info
                                    // should be a pointer to a UNICODE_STRING
                                    // structure.



    SeAdtParmTypeFileSpec,          //Produces 1 parameter.
                                    //Received value:
                                    //
                                    //  Unicode string containing a file or
                                    //  directory name.
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string with the prefix of the
                                    //  file's path replaced by a drive letter
                                    //  if possible.
                                    //




    SeAdtParmTypeUlong,             //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  Ulong
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value.


    SeAdtParmTypeSid,               //Produces 1 parameter.
                                    //Received value:
                                    //
                                    //  SID (variable length)
                                    //
                                    //Results in:
                                    //
                                    //  String representation of SID
                                    //




    SeAdtParmTypeLogonId,           //Produces 4 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Sid string
                                    //  param 2: Username string
                                    //  param 3: domain name string
                                    //  param 4: Logon ID (Luid) string


    SeAdtParmTypeNoLogonId,         //Produces 3 parameters.
                                    //Received value:
                                    //
                                    //  None.
                                    //
                                    //Results in:
                                    //
                                    //  param 1: "-"
                                    //  param 2: "-"
                                    //  param 3: "-"
                                    //  param 4: "-"
                                    //
                                    //Note:
                                    //
                                    //  This type is used when a logon ID
                                    //  is needed, but one is not available
                                    //  to pass.  For example, if an
                                    //  impersonation logon ID is expected
                                    //  but the subject is not impersonating
                                    //  anyone.
                                    //

    SeAdtParmTypeAccessMask,        //Produces 1 parameter with formatting.
                                    //Received value:
                                    //
                                    //  ACCESS_MASK followed by
                                    //  a Unicode string.  The unicode
                                    //  string contains the name of the
                                    //  type of object the access mask
                                    //  applies to.  The event's source
                                    //  further qualifies the object type.
                                    //
                                    //Results in:
                                    //
                                    //  formatted unicode string built to
                                    //  take advantage of the specified
                                    //  source's parameter message file.
                                    //
                                    //Note:
                                    //
                                    //  An access mask containing three
                                    //  access types for a Widget object
                                    //  type (defined by the Foozle source)
                                    //  might end up looking like:
                                    //
                                    //      %%1062\n\t\t%1066\n\t\t%%601
                                    //
                                    //  The %%numbers are signals to the
                                    //  event viewer to perform parameter
                                    //  substitution before display.
                                    //



    SeAdtParmTypePrivs,             //Produces 1 parameter with formatting.
                                    //Received value:
                                    //
                                    //Results in:
                                    //
                                    //  formatted unicode string similar to
                                    //  that for access types.  Each priv
                                    //  will be formatted to be displayed
                                    //  on its own line.  E.g.,
                                    //
                                    //      %%642\n\t\t%%651\n\t\t%%655
                                    //

    SeAdtParmTypeObjectTypes,       //Produces 10 parameters with formatting.
                                    //Received value:
                                    //
                                    // Produces a list a stringized GUIDS along
                                    // with information similar to that for
                                    // an access mask.

    SeAdtParmTypeHexUlong,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  Ulong
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

// In W2k this value did not exist, it was ParmTypeLUID

    SeAdtParmTypePtr,               //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  pointer
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

//
// Everything below exists only in Windows XP and greater
//

    SeAdtParmTypeTime,              //Produces 2 parameters
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // date and time.

                                    //
    SeAdtParmTypeGuid,              //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  GUID pointer
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of GUID
                                    // {xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx}
                                    //

//
// Everything below exists only in Windows Server 2003 and Greater
//

    SeAdtParmTypeLuid,              //
                                    //Produces 1 parameter
                                    //Received value:
                                    //
                                    // LUID
                                    //
                                    //Results in:
                                    //
                                    // Hex LUID
                                    //

    SeAdtParmTypeHexInt64,          //Produces 1 parameter
                                    //Received value:
                                    //
                                    //  64 bit integer
                                    //
                                    //Results in:
                                    //
                                    //  Unicode string representation of
                                    //  unsigned integer value in hexadecimal.

    SeAdtParmTypeStringList,        //Produces 1 parameter
                                    //Received value:
                                    //
                                    // ptr to LSAP_ADT_STRING_LIST
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // concatenation of the strings in the list

    SeAdtParmTypeSidList,           //Produces 1 parameter
                                    //Received value:
                                    //
                                    // ptr to LSAP_ADT_SID_LIST
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // concatenation of the SIDs in the list

    SeAdtParmTypeDuration,          //Produces 1 parameters
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // a duration.

    SeAdtParmTypeUserAccountControl,//Produces 3 parameters
                                    //Received value:
                                    //
                                    // old and new UserAccountControl values
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representations of
                                    // the flags in UserAccountControl.
                                    // 1 - old value in hex
                                    // 2 - new value in hex
                                    // 3 - difference as strings

    SeAdtParmTypeNoUac,             //Produces 3 parameters
                                    //Received value:
                                    //
                                    // none
                                    //
                                    //Results in:
                                    //
                                    // Three dashes ('-') as unicode strings.

    SeAdtParmTypeMessage,           //Produces 1 Parameter
                                    //Received value:
                                    //
                                    //  ULONG (MessageNo from msobjs.mc)
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // %%MessageNo which the event viewer
                                    // will replace with the message string
                                    // from msobjs.mc

    SeAdtParmTypeDateTime,          //Produces 1 Parameter
                                    //Received value:
                                    //
                                    //  LARGE_INTEGER
                                    //
                                    //Results in:
                                    //
                                    // Unicode string representation of
                                    // date and time (in _one_ string).

    SeAdtParmTypeSockAddr,          // Produces 2 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SOCKADDR_IN/SOCKADDR_IN6
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // param 1: IP address string
                                    // param 2: Port number string
                                    //

//
// Everything below this exists only in Longhorn and greater
//

    SeAdtParmTypeSD,                // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to SECURITY_DESCRIPTOR
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // SDDL string representation of SD
                                    //

    SeAdtParmTypeLogonHours,        // Produces 1 parameters
                                    //
                                    // Received value:
                                    //
                                    // pointer to LOGON_HOURS
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // String representation of allowed logon hours
                                    //

    SeAdtParmTypeLogonIdNoSid,      //Produces 3 parameters.
                                    //Received Value:
                                    //
                                    //  LUID (fixed length)
                                    //
                                    //Results in:
                                    //
                                    //  param 1: Username string
                                    //  param 2: domain name string
                                    //  param 3: Logon ID (Luid) string

    SeAdtParmTypeUlongNoConv,       // Produces 1 parameter.
                                    // Received Value:
                                    // Ulong
                                    //
                                    //Results in:
                                    // Not converted to string
                                    //

    SeAdtParmTypeSockAddrNoPort     // Produces 1 parameter
                                    //
                                    // Received value:
                                    //
                                    // pointer to SOCKADDR_IN/SOCKADDR_IN6
                                    // structure
                                    //
                                    // Results in:
                                    //
                                    // param 1: IPv4/IPv6 address string
                                    //

} SE_ADT_PARAMETER_TYPE, *PSE_ADT_PARAMETER_TYPE;

#ifndef GUID_DEFINED
#include <guiddef.h>
#endif /* GUID_DEFINED */

typedef struct _SE_ADT_OBJECT_TYPE {
    GUID ObjectType;
    USHORT Flags;
#define SE_ADT_OBJECT_ONLY 0x1
    USHORT Level;
    ACCESS_MASK AccessMask;
} SE_ADT_OBJECT_TYPE, *PSE_ADT_OBJECT_TYPE;

typedef struct _SE_ADT_PARAMETER_ARRAY_ENTRY {

    SE_ADT_PARAMETER_TYPE Type;
    ULONG Length;
    ULONG_PTR Data[2];
    PVOID Address;

} SE_ADT_PARAMETER_ARRAY_ENTRY, *PSE_ADT_PARAMETER_ARRAY_ENTRY;



//
// Structure that will be passed between the Reference Monitor and LSA
// to transmit auditing information.
//

#define SE_MAX_AUDIT_PARAMETERS 32
#define SE_MAX_GENERIC_AUDIT_PARAMETERS 28

typedef struct _SE_ADT_PARAMETER_ARRAY {

    ULONG CategoryId;
    ULONG AuditId;
    ULONG ParameterCount;
    ULONG Length;
    USHORT FlatSubCategoryId;
    USHORT Type;
    ULONG Flags;
    SE_ADT_PARAMETER_ARRAY_ENTRY Parameters[ SE_MAX_AUDIT_PARAMETERS ];

} SE_ADT_PARAMETER_ARRAY, *PSE_ADT_PARAMETER_ARRAY;


#define SE_ADT_PARAMETERS_SELF_RELATIVE     0x00000001
#define SE_ADT_PARAMETERS_SEND_TO_LSA       0x00000002
#define SE_ADT_PARAMETER_EXTENSIBLE_AUDIT   0x00000004
#define SE_ADT_PARAMETER_GENERIC_AUDIT      0x00000008
#define SE_ADT_PARAMETER_WRITE_SYNCHRONOUS  0x00000010


//
// This macro only existed in longhorn and after
//

#define LSAP_SE_ADT_PARAMETER_ARRAY_TRUE_SIZE(AuditParameters)    \
     ( sizeof(SE_ADT_PARAMETER_ARRAY) -                           \
       sizeof(SE_ADT_PARAMETER_ARRAY_ENTRY) *                     \
       (SE_MAX_AUDIT_PARAMETERS - AuditParameters->ParameterCount) )

#endif // _NTLSA_AUDIT_

// end_ntifs
#endif // _NTLSA_IFS_

//
// Audit Event Categories
//
// The following are the built-in types or Categories of audit event.
// WARNING!  This structure is subject to expansion.  The user should not
// compute the number of elements of this type directly, but instead
// should obtain the count of elements by calling LsaQueryInformationPolicy()
// for the PolicyAuditEventsInformation class and extracting the count from
// the MaximumAuditEventCount field of the returned structure.
//

typedef enum _POLICY_AUDIT_EVENT_TYPE {

    AuditCategorySystem = 0,
    AuditCategoryLogon,
    AuditCategoryObjectAccess,
    AuditCategoryPrivilegeUse,
    AuditCategoryDetailedTracking,
    AuditCategoryPolicyChange,
    AuditCategoryAccountManagement,
    AuditCategoryDirectoryServiceAccess,
    AuditCategoryAccountLogon

} POLICY_AUDIT_EVENT_TYPE, *PPOLICY_AUDIT_EVENT_TYPE;


//
// The following defines describe the auditing options for each
// event type
//

// Leave options specified for this event unchanged

#define POLICY_AUDIT_EVENT_UNCHANGED       (0x00000000L)

// Audit successful occurrences of events of this type

#define POLICY_AUDIT_EVENT_SUCCESS         (0x00000001L)

// Audit failed attempts to cause an event of this type to occur

#define POLICY_AUDIT_EVENT_FAILURE         (0x00000002L)

#define POLICY_AUDIT_EVENT_NONE            (0x00000004L)

// Mask of valid event auditing options

#define POLICY_AUDIT_EVENT_MASK \
    (POLICY_AUDIT_EVENT_SUCCESS | \
     POLICY_AUDIT_EVENT_FAILURE | \
     POLICY_AUDIT_EVENT_UNCHANGED | \
     POLICY_AUDIT_EVENT_NONE)


#ifdef _NTDEF_
// begin_ntifs
typedef UNICODE_STRING LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;
typedef STRING LSA_STRING, *PLSA_STRING;
typedef OBJECT_ATTRIBUTES LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;
// end_ntifs
#else // _NTDEF_

#ifndef IN
#define IN
#endif

#ifndef OUT
#define OUT
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif


typedef struct _LSA_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength/2), length_is(Length/2)]
#endif // MIDL_PASS
    PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;

typedef struct _LSA_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} LSA_STRING, *PLSA_STRING;

typedef struct _LSA_OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PLSA_UNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;



#endif // _NTDEF_

//
// Macro for determining whether an API succeeded.
//

#define LSA_SUCCESS(Error) ((LONG)(Error) >= 0)

#ifndef _NTLSA_IFS_
// begin_ntifs

NTSTATUS
NTAPI
LsaRegisterLogonProcess (
    __in PLSA_STRING LogonProcessName,
    __out PHANDLE LsaHandle,
    __out PLSA_OPERATIONAL_MODE SecurityMode
    );

//
// The function below did not exist in NTIFS before windows XP
// However, the function has always been there, so it is okay to use
// even on w2k
//

NTSTATUS
NTAPI
LsaLogonUser (
    __in HANDLE LsaHandle,
    __in PLSA_STRING OriginName,
    __in SECURITY_LOGON_TYPE LogonType,
    __in ULONG AuthenticationPackage,
    __in_bcount(AuthenticationInformationLength) PVOID AuthenticationInformation,
    __in ULONG AuthenticationInformationLength,
    __in_opt PTOKEN_GROUPS LocalGroups,
    __in PTOKEN_SOURCE SourceContext,
    __out PVOID *ProfileBuffer,
    __out PULONG ProfileBufferLength,
    __out PLUID LogonId,
    __out PHANDLE Token,
    __out PQUOTA_LIMITS Quotas,
    __out PNTSTATUS SubStatus
    );


// end_ntifs

NTSTATUS
NTAPI
LsaLookupAuthenticationPackage (
    __in HANDLE LsaHandle,
    __in PLSA_STRING PackageName,
    __out PULONG AuthenticationPackage
    );

// begin_ntifs

NTSTATUS
NTAPI
LsaFreeReturnBuffer (
    __in PVOID Buffer
    );

// end_ntifs

NTSTATUS
NTAPI
LsaCallAuthenticationPackage (
    __in HANDLE LsaHandle,
    __in ULONG AuthenticationPackage,
    __in_bcount(SubmitBufferLength) PVOID ProtocolSubmitBuffer,
    __in ULONG SubmitBufferLength,
    __out_opt PVOID *ProtocolReturnBuffer,
    __out_opt PULONG ReturnBufferLength,
    __out_opt PNTSTATUS ProtocolStatus
    );


NTSTATUS
NTAPI
LsaDeregisterLogonProcess (
    __in HANDLE LsaHandle
    );

NTSTATUS
NTAPI
LsaConnectUntrusted (
    __out PHANDLE LsaHandle
    );

#endif // _NTLSA_IFS_


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy Administration API datatypes and defines         //
//                                                                        //
////////////////////////////////////////////////////////////////////////////

//
// Access types for the Policy object
//

#define POLICY_VIEW_LOCAL_INFORMATION              0x00000001L
#define POLICY_VIEW_AUDIT_INFORMATION              0x00000002L
#define POLICY_GET_PRIVATE_INFORMATION             0x00000004L
#define POLICY_TRUST_ADMIN                         0x00000008L
#define POLICY_CREATE_ACCOUNT                      0x00000010L
#define POLICY_CREATE_SECRET                       0x00000020L
#define POLICY_CREATE_PRIVILEGE                    0x00000040L
#define POLICY_SET_DEFAULT_QUOTA_LIMITS            0x00000080L
#define POLICY_SET_AUDIT_REQUIREMENTS              0x00000100L
#define POLICY_AUDIT_LOG_ADMIN                     0x00000200L
#define POLICY_SERVER_ADMIN                        0x00000400L
#define POLICY_LOOKUP_NAMES                        0x00000800L
#define POLICY_NOTIFICATION                        0x00001000L

#define POLICY_ALL_ACCESS     (STANDARD_RIGHTS_REQUIRED         |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_VIEW_AUDIT_INFORMATION    |\
                               POLICY_GET_PRIVATE_INFORMATION   |\
                               POLICY_TRUST_ADMIN               |\
                               POLICY_CREATE_ACCOUNT            |\
                               POLICY_CREATE_SECRET             |\
                               POLICY_CREATE_PRIVILEGE          |\
                               POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                               POLICY_SET_AUDIT_REQUIREMENTS    |\
                               POLICY_AUDIT_LOG_ADMIN           |\
                               POLICY_SERVER_ADMIN              |\
                               POLICY_LOOKUP_NAMES)


#define POLICY_READ           (STANDARD_RIGHTS_READ             |\
                               POLICY_VIEW_AUDIT_INFORMATION    |\
                               POLICY_GET_PRIVATE_INFORMATION)

#define POLICY_WRITE          (STANDARD_RIGHTS_WRITE            |\
                               POLICY_TRUST_ADMIN               |\
                               POLICY_CREATE_ACCOUNT            |\
                               POLICY_CREATE_SECRET             |\
                               POLICY_CREATE_PRIVILEGE          |\
                               POLICY_SET_DEFAULT_QUOTA_LIMITS  |\
                               POLICY_SET_AUDIT_REQUIREMENTS    |\
                               POLICY_AUDIT_LOG_ADMIN           |\
                               POLICY_SERVER_ADMIN)

#define POLICY_EXECUTE        (STANDARD_RIGHTS_EXECUTE          |\
                               POLICY_VIEW_LOCAL_INFORMATION    |\
                               POLICY_LOOKUP_NAMES)


//
// Policy object specific data types.
//

//
// The following data type is used to identify a domain
//

typedef struct _LSA_TRUST_INFORMATION {

    LSA_UNICODE_STRING Name;
    PSID Sid;

} LSA_TRUST_INFORMATION, *PLSA_TRUST_INFORMATION;

// where members have the following usage:
//
//     Name - The name of the domain.
//
//     Sid - A pointer to the Sid of the Domain
//

//
// The following data type is used in name and SID lookup services to
// describe the domains referenced in the lookup operation.
//

typedef struct _LSA_REFERENCED_DOMAIN_LIST {

    ULONG Entries;
    PLSA_TRUST_INFORMATION Domains;

} LSA_REFERENCED_DOMAIN_LIST, *PLSA_REFERENCED_DOMAIN_LIST;

// where members have the following usage:
//
//     Entries - Is a count of the number of domains described in the
//         Domains array.
//
//     Domains - Is a pointer to an array of Entries LSA_TRUST_INFORMATION data
//         structures.
//


//
// The following data type is used in name to SID lookup services to describe
// the domains referenced in the lookup operation.
//

typedef struct _LSA_TRANSLATED_SID {

    SID_NAME_USE Use;
    ULONG RelativeId;
    LONG DomainIndex;

} LSA_TRANSLATED_SID, *PLSA_TRANSLATED_SID;

// where members have the following usage:
//
//     Use - identifies the use of the SID.  If this value is SidUnknown or
//         SidInvalid, then the remainder of the record is not set and
//         should be ignored.
//
//     RelativeId - Contains the relative ID of the translated SID.  The
//         remainder of the SID (the prefix) is obtained using the
//         DomainIndex field.
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the
//         domain in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//

#if (_WIN32_WINNT >= 0x0501)
typedef struct _LSA_TRANSLATED_SID2 {

    SID_NAME_USE Use;
    PSID         Sid;
    LONG         DomainIndex;
    ULONG        Flags;

} LSA_TRANSLATED_SID2, *PLSA_TRANSLATED_SID2;

// where members have the following usage:
//
//     Use - identifies the use of the SID.  If this value is SidUnknown or
//         SidInvalid, then the remainder of the record is not set and
//         should be ignored.
//
//     Sid - Contains the complete Sid of the tranlated SID
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the
//         domain in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//
#endif

//
// The following data type is used in SID to name lookup services to
// describe the domains referenced in the lookup operation.
//

typedef struct _LSA_TRANSLATED_NAME {

    SID_NAME_USE Use;
    LSA_UNICODE_STRING Name;
    LONG DomainIndex;

} LSA_TRANSLATED_NAME, *PLSA_TRANSLATED_NAME;

// where the members have the following usage:
//
//     Use - Identifies the use of the name.  If this value is SidUnknown
//         or SidInvalid, then the remainder of the record is not set and
//         should be ignored.  If this value is SidWellKnownGroup then the
//         Name field is invalid, but the DomainIndex field is not.
//
//     Name - Contains the isolated name of the translated SID.
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the domain
//         in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//


//
// The following data type is used to represent the role of the LSA
// server (primary or backup).
//

typedef enum _POLICY_LSA_SERVER_ROLE {

    PolicyServerRoleBackup = 2,
    PolicyServerRolePrimary

} POLICY_LSA_SERVER_ROLE, *PPOLICY_LSA_SERVER_ROLE;

#if (_WIN32_WINNT < 0x0502)
//
// The following data type is used to represent the state of the LSA
// server (enabled or disabled).  Some operations may only be performed on
// an enabled LSA server.
//

typedef enum _POLICY_SERVER_ENABLE_STATE {

    PolicyServerEnabled = 2,
    PolicyServerDisabled

} POLICY_SERVER_ENABLE_STATE, *PPOLICY_SERVER_ENABLE_STATE;
#endif

//
// The following data type is used to specify the auditing options for
// an Audit Event Type.
//

typedef ULONG POLICY_AUDIT_EVENT_OPTIONS, *PPOLICY_AUDIT_EVENT_OPTIONS;

// where the following flags can be set:
//
//     POLICY_AUDIT_EVENT_UNCHANGED - Leave existing auditing options
//         unchanged for events of this type.  This flag is only used for
//         set operations.  If this flag is set, then all other flags
//         are ignored.
//
//     POLICY_AUDIT_EVENT_NONE - Cancel all auditing options for events
//         of this type.  If this flag is set, the success/failure flags
//         are ignored.
//
//     POLICY_AUDIT_EVENT_SUCCESS - When auditing is enabled, audit all
//         successful occurrences of events of the given type.
//
//     POLICY_AUDIT_EVENT_FAILURE - When auditing is enabled, audit all
//         unsuccessful occurrences of events of the given type.
//




//
// The following data type defines the classes of Policy Information
// that may be queried/set.
//

typedef enum _POLICY_INFORMATION_CLASS {

    PolicyAuditLogInformation = 1,
    PolicyAuditEventsInformation,
    PolicyPrimaryDomainInformation,
    PolicyPdAccountInformation,
    PolicyAccountDomainInformation,
    PolicyLsaServerRoleInformation,
    PolicyReplicaSourceInformation,
    PolicyDefaultQuotaInformation,
    PolicyModificationInformation,
    PolicyAuditFullSetInformation,
    PolicyAuditFullQueryInformation,
    PolicyDnsDomainInformation,
    PolicyDnsDomainInformationInt,
    PolicyLocalAccountDomainInformation,
    PolicyLastEntry

} POLICY_INFORMATION_CLASS, *PPOLICY_INFORMATION_CLASS;


//
// The following data type corresponds to the PolicyAuditLogInformation
// information class.  It is used to represent information relating to
// the Audit Log.
//
// This structure may be used in both query and set operations.  However,
// when used in set operations, some fields are ignored.
//

typedef struct _POLICY_AUDIT_LOG_INFO {

    ULONG AuditLogPercentFull;
    ULONG MaximumLogSize;
    LARGE_INTEGER AuditRetentionPeriod;
    BOOLEAN AuditLogFullShutdownInProgress;
    LARGE_INTEGER TimeToShutdown;
    ULONG NextAuditRecordId;

} POLICY_AUDIT_LOG_INFO, *PPOLICY_AUDIT_LOG_INFO;

// where the members have the following usage:
//
//     AuditLogPercentFull - Indicates the percentage of the Audit Log
//         currently being used.
//
//     MaximumLogSize - Specifies the maximum size of the Audit Log in
//         kilobytes.
//
//     AuditRetentionPeriod - Indicates the length of time that Audit
//         Records are to be retained.  Audit Records are discardable
//         if their timestamp predates the current time minus the
//         retention period.
//
//     AuditLogFullShutdownInProgress - Indicates whether or not a system
//         shutdown is being initiated due to the security Audit Log becoming
//         full.  This condition will only occur if the system is configured
//         to shutdown when the log becomes full.
//
//         TRUE indicates that a shutdown is in progress
//         FALSE indicates that a shutdown is not in progress.
//
//         Once a shutdown has been initiated, this flag will be set to
//         TRUE.  If an administrator is able to currect the situation
//         before the shutdown becomes irreversible, then this flag will
//         be reset to false.
//
//         This field is ignored for set operations.
//
//     TimeToShutdown - If the AuditLogFullShutdownInProgress flag is set,
//         then this field contains the time left before the shutdown
//         becomes irreversible.
//
//         This field is ignored for set operations.
//


//
// The following data type corresponds to the PolicyAuditEventsInformation
// information class.  It is used to represent information relating to
// the audit requirements.
//

typedef struct _POLICY_AUDIT_EVENTS_INFO {

    BOOLEAN AuditingMode;
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;
    ULONG MaximumAuditEventCount;

} POLICY_AUDIT_EVENTS_INFO, *PPOLICY_AUDIT_EVENTS_INFO;

// where the members have the following usage:
//
//     AuditingMode - A Boolean variable specifying the Auditing Mode value.
//         This value is interpreted as follows:
//
//         TRUE - Auditing is to be enabled (set operations) or is enabled
//             (query operations).  Audit Records will be generated according
//             to the Event Auditing Options in effect (see the
//             EventAuditingOptions field.
//
//         FALSE - Auditing is to be disabled (set operations) or is
//             disabled (query operations).  No Audit Records will be
//             generated.  Note that for set operations the Event Auditing
//             Options in effect will still be updated as specified by the
//             EventAuditingOptions field whether Auditing is enabled or
//             disabled.
//
//    EventAuditingOptions - Pointer to an array of Auditing Options
//        indexed by Audit Event Type.
//
//    MaximumAuditEventCount - Specifiesa count of the number of Audit
//        Event Types specified by the EventAuditingOptions parameter.  If
//        this count is less than the number of Audit Event Types supported
//        by the system, the Auditing Options for Event Types with IDs
//        higher than (MaximumAuditEventCount + 1) are left unchanged.
//


//
// The following data type is used to represent information relating to
// the audit requirements.
//

typedef struct _POLICY_AUDIT_SUBCATEGORIES_INFO {

    ULONG MaximumSubCategoryCount;
    PPOLICY_AUDIT_EVENT_OPTIONS EventAuditingOptions;

} POLICY_AUDIT_SUBCATEGORIES_INFO, *PPOLICY_AUDIT_SUBCATEGORIES_INFO;

typedef struct _POLICY_AUDIT_CATEGORIES_INFO {

    ULONG MaximumCategoryCount;
    PPOLICY_AUDIT_SUBCATEGORIES_INFO SubCategoriesInfo;

} POLICY_AUDIT_CATEGORIES_INFO, *PPOLICY_AUDIT_CATEGORIES_INFO;


//
// Valid bits for Per user policy mask.
//

#define PER_USER_POLICY_UNCHANGED               (0x00)
#define PER_USER_AUDIT_SUCCESS_INCLUDE          (0x01)
#define PER_USER_AUDIT_SUCCESS_EXCLUDE          (0x02)
#define PER_USER_AUDIT_FAILURE_INCLUDE          (0x04)
#define PER_USER_AUDIT_FAILURE_EXCLUDE          (0x08)
#define PER_USER_AUDIT_NONE                     (0x10)


#define VALID_PER_USER_AUDIT_POLICY_FLAG (PER_USER_AUDIT_SUCCESS_INCLUDE | \
                                          PER_USER_AUDIT_SUCCESS_EXCLUDE | \
                                          PER_USER_AUDIT_FAILURE_INCLUDE | \
                                          PER_USER_AUDIT_FAILURE_EXCLUDE | \
                                          PER_USER_AUDIT_NONE)


//
// The following structure corresponds to the PolicyAccountDomainInformation
// information class.
//

typedef struct _POLICY_ACCOUNT_DOMAIN_INFO {

    LSA_UNICODE_STRING DomainName;
    PSID DomainSid;

} POLICY_ACCOUNT_DOMAIN_INFO, *PPOLICY_ACCOUNT_DOMAIN_INFO;

// where the members have the following usage:
//
//     DomainName - Is the name of the domain
//
//     DomainSid - Is the Sid of the domain
//


//
// The following structure corresponds to the PolicyPrimaryDomainInformation
// information class.
//

typedef struct _POLICY_PRIMARY_DOMAIN_INFO {

    LSA_UNICODE_STRING Name;
    PSID Sid;

} POLICY_PRIMARY_DOMAIN_INFO, *PPOLICY_PRIMARY_DOMAIN_INFO;

// where the members have the following usage:
//
//     Name - Is the name of the domain
//
//     Sid - Is the Sid of the domain
//


//
// The following structure corresponds to the PolicyDnsDomainInformation
// information class
//

typedef struct _POLICY_DNS_DOMAIN_INFO
{
    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING DnsDomainName;
    LSA_UNICODE_STRING DnsForestName;
    GUID DomainGuid;
    PSID Sid;

} POLICY_DNS_DOMAIN_INFO, *PPOLICY_DNS_DOMAIN_INFO;

// where the members have the following usage:
//
//      Name - Is the name of the Domain
//
//      DnsDomainName - Is the DNS name of the domain
//
//      DnsForestName - Is the DNS forest name of the domain
//
//      DomainGuid - Is the GUID of the domain
//
//      Sid - Is the Sid of the domain


//
// The following structure corresponds to the PolicyPdAccountInformation
// information class.  This structure may be used in Query operations
// only.
//

typedef struct _POLICY_PD_ACCOUNT_INFO {

    LSA_UNICODE_STRING Name;

} POLICY_PD_ACCOUNT_INFO, *PPOLICY_PD_ACCOUNT_INFO;

// where the members have the following usage:
//
//     Name - Is the name of an account in the domain that should be used
//         for authentication and name/ID lookup requests.
//


//
// The following structure corresponds to the PolicyLsaServerRoleInformation
// information class.
//

typedef struct _POLICY_LSA_SERVER_ROLE_INFO {

    POLICY_LSA_SERVER_ROLE LsaServerRole;

} POLICY_LSA_SERVER_ROLE_INFO, *PPOLICY_LSA_SERVER_ROLE_INFO;

// where the fields have the following usage:
//
// TBS
//


//
// The following structure corresponds to the PolicyReplicaSourceInformation
// information class.
//

typedef struct _POLICY_REPLICA_SOURCE_INFO {

    LSA_UNICODE_STRING ReplicaSource;
    LSA_UNICODE_STRING ReplicaAccountName;

} POLICY_REPLICA_SOURCE_INFO, *PPOLICY_REPLICA_SOURCE_INFO;


//
// The following structure corresponds to the PolicyDefaultQuotaInformation
// information class.
//

typedef struct _POLICY_DEFAULT_QUOTA_INFO {

    QUOTA_LIMITS QuotaLimits;

} POLICY_DEFAULT_QUOTA_INFO, *PPOLICY_DEFAULT_QUOTA_INFO;


//
// The following structure corresponds to the PolicyModificationInformation
// information class.
//

typedef struct _POLICY_MODIFICATION_INFO {

    LARGE_INTEGER ModifiedId;
    LARGE_INTEGER DatabaseCreationTime;

} POLICY_MODIFICATION_INFO, *PPOLICY_MODIFICATION_INFO;

// where the members have the following usage:
//
//     ModifiedId - Is a 64-bit unsigned integer that is incremented each
//         time anything in the LSA database is modified.  This value is
//         only modified on Primary Domain Controllers.
//
//     DatabaseCreationTime - Is the date/time that the LSA Database was
//         created.  On Backup Domain Controllers, this value is replicated
//         from the Primary Domain Controller.
//

//
// The following structure type corresponds to the PolicyAuditFullSetInformation
// Information Class.
//

typedef struct _POLICY_AUDIT_FULL_SET_INFO {

    BOOLEAN ShutDownOnFull;

} POLICY_AUDIT_FULL_SET_INFO, *PPOLICY_AUDIT_FULL_SET_INFO;

//
// The following structure type corresponds to the PolicyAuditFullQueryInformation
// Information Class.
//

typedef struct _POLICY_AUDIT_FULL_QUERY_INFO {

    BOOLEAN ShutDownOnFull;
    BOOLEAN LogIsFull;

} POLICY_AUDIT_FULL_QUERY_INFO, *PPOLICY_AUDIT_FULL_QUERY_INFO;

//
// The following data type defines the classes of Policy Information
// that may be queried/set that has domain wide effect.
//

typedef enum _POLICY_DOMAIN_INFORMATION_CLASS {

#if (_WIN32_WINNT <= 0x0500)
    PolicyDomainQualityOfServiceInformation = 1,
#endif
    PolicyDomainEfsInformation = 2,
    PolicyDomainKerberosTicketInformation

} POLICY_DOMAIN_INFORMATION_CLASS, *PPOLICY_DOMAIN_INFORMATION_CLASS;

#if (_WIN32_WINNT < 0x0502)
//
// QualityOfService information.  Corresponds to PolicyDomainQualityOfServiceInformation
//

#define POLICY_QOS_SCHANNEL_REQUIRED            0x00000001
#define POLICY_QOS_OUTBOUND_INTEGRITY           0x00000002
#define POLICY_QOS_OUTBOUND_CONFIDENTIALITY     0x00000004
#define POLICY_QOS_INBOUND_INTEGRITY            0x00000008
#define POLICY_QOS_INBOUND_CONFIDENTIALITY      0x00000010
#define POLICY_QOS_ALLOW_LOCAL_ROOT_CERT_STORE  0x00000020
#define POLICY_QOS_RAS_SERVER_ALLOWED           0x00000040
#define POLICY_QOS_DHCP_SERVER_ALLOWED          0x00000080

//
// Bits 0x00000100 through 0xFFFFFFFF are reserved for future use.
//
#endif

#if (_WIN32_WINNT == 0x0500)
typedef struct _POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO {

    ULONG QualityOfService;

} POLICY_DOMAIN_QUALITY_OF_SERVICE_INFO, *PPOLICY_DOMAIN_QUALITY_OF_SERVICE_INFO;
//
// where the members have the following usage:
//
//  QualityOfService - Determines what specific QOS actions a machine should take
//
#endif

//
// The following structure corresponds to the PolicyEfsInformation
// information class
//

typedef struct _POLICY_DOMAIN_EFS_INFO {

    ULONG   InfoLength;
    PUCHAR  EfsBlob;

} POLICY_DOMAIN_EFS_INFO, *PPOLICY_DOMAIN_EFS_INFO;

//
// where the members have the following usage:
//
//      InfoLength - Length of the EFS Information blob
//
//      EfsBlob - Efs blob data
//


//
// The following structure corresponds to the PolicyDomainKerberosTicketInformation
// information class
//

#define POLICY_KERBEROS_VALIDATE_CLIENT 0x00000080


typedef struct _POLICY_DOMAIN_KERBEROS_TICKET_INFO {

    ULONG AuthenticationOptions;
    LARGE_INTEGER MaxServiceTicketAge;
    LARGE_INTEGER MaxTicketAge;
    LARGE_INTEGER MaxRenewAge;
    LARGE_INTEGER MaxClockSkew;
    LARGE_INTEGER Reserved;
} POLICY_DOMAIN_KERBEROS_TICKET_INFO, *PPOLICY_DOMAIN_KERBEROS_TICKET_INFO;

//
// where the members have the following usage
//
//      AuthenticationOptions -- allowed ticket options (POLICY_KERBEROS_* flags )
//
//      MaxServiceTicketAge   -- Maximum lifetime for a service ticket
//
//      MaxTicketAge -- Maximum lifetime for the initial ticket
//
//      MaxRenewAge -- Maximum cumulative age a renewable ticket can be with
//                     requring authentication
//
//      MaxClockSkew -- Maximum tolerance for synchronization of computer clocks
//
//      Reserved   --  Reserved


//
// The following data type defines the classes of Policy Information / Policy Domain Information
// that may be used to request notification
//

typedef enum _POLICY_NOTIFICATION_INFORMATION_CLASS {

    PolicyNotifyAuditEventsInformation = 1,
    PolicyNotifyAccountDomainInformation,
    PolicyNotifyServerRoleInformation,
    PolicyNotifyDnsDomainInformation,
    PolicyNotifyDomainEfsInformation,
    PolicyNotifyDomainKerberosTicketInformation,
    PolicyNotifyMachineAccountPasswordInformation

} POLICY_NOTIFICATION_INFORMATION_CLASS, *PPOLICY_NOTIFICATION_INFORMATION_CLASS;


//
// LSA RPC Context Handle (Opaque form).  Note that a Context Handle is
// always a pointer type unlike regular handles.
//

typedef PVOID LSA_HANDLE, *PLSA_HANDLE;


//
// Trusted Domain Object specific data types
//

//
// This data type defines the following information classes that may be
// queried or set.
//

typedef enum _TRUSTED_INFORMATION_CLASS {

    TrustedDomainNameInformation = 1,
    TrustedControllersInformation,
    TrustedPosixOffsetInformation,
    TrustedPasswordInformation,
    TrustedDomainInformationBasic,
    TrustedDomainInformationEx,
    TrustedDomainAuthInformation,
    TrustedDomainFullInformation,
    TrustedDomainAuthInformationInternal,
    TrustedDomainFullInformationInternal,
    TrustedDomainInformationEx2Internal,
    TrustedDomainFullInformation2Internal,
    TrustedDomainSupportedEncryptionTypes,
} TRUSTED_INFORMATION_CLASS, *PTRUSTED_INFORMATION_CLASS;

//
// The following data type corresponds to the TrustedDomainNameInformation
// information class.
//

typedef struct _TRUSTED_DOMAIN_NAME_INFO {

    LSA_UNICODE_STRING Name;

} TRUSTED_DOMAIN_NAME_INFO, *PTRUSTED_DOMAIN_NAME_INFO;

// where members have the following meaning:
//
// Name - The name of the Trusted Domain.
//

//
// The following data type corresponds to the TrustedControllersInformation
// information class.
//

typedef struct _TRUSTED_CONTROLLERS_INFO {

    ULONG Entries;
    PLSA_UNICODE_STRING Names;

} TRUSTED_CONTROLLERS_INFO, *PTRUSTED_CONTROLLERS_INFO;

// where members have the following meaning:
//
// Entries - Indicate how mamy entries there are in the Names array.
//
// Names - Pointer to an array of LSA_UNICODE_STRING structures containing the
//     names of domain controllers of the domain.  This information may not
//     be accurate and should be used only as a hint.  The order of this
//     list is considered significant and will be maintained.
//
//     By convention, the first name in this list is assumed to be the
//     Primary Domain Controller of the domain.  If the Primary Domain
//     Controller is not known, the first name should be set to the NULL
//     string.
//


//
// The following data type corresponds to the TrustedPosixOffsetInformation
// information class.
//

typedef struct _TRUSTED_POSIX_OFFSET_INFO {

    ULONG Offset;

} TRUSTED_POSIX_OFFSET_INFO, *PTRUSTED_POSIX_OFFSET_INFO;

// where members have the following meaning:
//
// Offset - Is an offset to use for the generation of Posix user and group
//     IDs from SIDs.  The Posix ID corresponding to any particular SID is
//     generated by adding the RID of that SID to the Offset of the SID's
//     corresponding TrustedDomain object.
//

//
// The following data type corresponds to the TrustedPasswordInformation
// information class.
//

typedef struct _TRUSTED_PASSWORD_INFO {
    LSA_UNICODE_STRING Password;
    LSA_UNICODE_STRING OldPassword;
} TRUSTED_PASSWORD_INFO, *PTRUSTED_PASSWORD_INFO;


typedef  LSA_TRUST_INFORMATION TRUSTED_DOMAIN_INFORMATION_BASIC;

typedef PLSA_TRUST_INFORMATION PTRUSTED_DOMAIN_INFORMATION_BASIC;

//
// Direction of the trust
//
#define TRUST_DIRECTION_DISABLED        0x00000000
#define TRUST_DIRECTION_INBOUND         0x00000001
#define TRUST_DIRECTION_OUTBOUND        0x00000002
#define TRUST_DIRECTION_BIDIRECTIONAL   (TRUST_DIRECTION_INBOUND | TRUST_DIRECTION_OUTBOUND)

#define TRUST_TYPE_DOWNLEVEL            0x00000001  // NT4 and before
#define TRUST_TYPE_UPLEVEL              0x00000002  // NT5
#define TRUST_TYPE_MIT                  0x00000003  // Trust with a MIT Kerberos realm

#if (_WIN32_WINNT < 0x0502)
#define TRUST_TYPE_DCE                  0x00000004  // Trust with a DCE realm
#endif

// Levels 0x5 - 0x000FFFFF reserved for future use
// Provider specific trust levels are from 0x00100000 to 0xFFF00000

#define TRUST_ATTRIBUTE_NON_TRANSITIVE                0x00000001  // Disallow transitivity
#define TRUST_ATTRIBUTE_UPLEVEL_ONLY                  0x00000002  // Trust link only valid for uplevel client
#if (_WIN32_WINNT == 0x0500)
#define TRUST_ATTRIBUTE_TREE_PARENT     0x00400000  // Denotes that we are setting the trust
                                                    // to our parent in the org tree...
#define TRUST_ATTRIBUTE_TREE_ROOT       0x00800000  // Denotes that we are setting the trust
                                                    // to another tree root in a forest...
// Trust attributes 0x00000004 through 0x004FFFFF reserved for future use
// Trust attributes 0x00F00000 through 0x00400000 are reserved for internal use
// Trust attributes 0x01000000 through 0xFF000000 are reserved for user
// defined values
#define TRUST_ATTRIBUTES_VALID  0xFF02FFFF
#endif

#if (_WIN32_WINNT < 0x0502)
#define TRUST_ATTRIBUTE_FILTER_SIDS        0x00000004  // Used to quarantine domains
#else
#define TRUST_ATTRIBUTE_QUARANTINED_DOMAIN            0x00000004  // Used to quarantine domains
#endif

#if (_WIN32_WINNT >= 0x0501)
#define TRUST_ATTRIBUTE_FOREST_TRANSITIVE             0x00000008  // This link may contain forest trust information
#if (_WIN32_WINNT >= 0x0502)
#define TRUST_ATTRIBUTE_CROSS_ORGANIZATION            0x00000010  // This trust is to a domain/forest which is not part of this enterprise
#define TRUST_ATTRIBUTE_WITHIN_FOREST                 0x00000020  // Trust is internal to this forest
#define TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL             0x00000040  // Trust is to be treated as external for trust boundary purposes
#if (_WIN32_WINNT >= 0x0600)
#define TRUST_ATTRIBUTE_TRUST_USES_RC4_ENCRYPTION     0x00000080  // MIT trust with RC4
#define TRUST_ATTRIBUTE_TRUST_USES_AES_KEYS           0x00000100  // Use AES keys to encrypte KRB TGTs
#endif
// Trust attributes 0x00000040 through 0x00200000 are reserved for future use
#else
// Trust attributes 0x00000010 through 0x00200000 are reserved for future use
#endif
// Trust attributes 0x00400000 through 0x00800000 were used previously (up to W2K) and should not be re-used
// Trust attributes 0x01000000 through 0x80000000 are reserved for user
#define TRUST_ATTRIBUTES_VALID          0xFF03FFFF
#endif
#define TRUST_ATTRIBUTES_USER           0xFF000000

typedef struct _TRUSTED_DOMAIN_INFORMATION_EX {

    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING FlatName;
    PSID  Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;

} TRUSTED_DOMAIN_INFORMATION_EX, *PTRUSTED_DOMAIN_INFORMATION_EX;

typedef struct _TRUSTED_DOMAIN_INFORMATION_EX2 {

    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING FlatName;
    PSID  Sid;
    ULONG TrustDirection;
    ULONG TrustType;
    ULONG TrustAttributes;
    ULONG ForestTrustLength;
#ifdef MIDL_PASS
    [size_is( ForestTrustLength )]
#endif
    PUCHAR ForestTrustInfo;

} TRUSTED_DOMAIN_INFORMATION_EX2, *PTRUSTED_DOMAIN_INFORMATION_EX2;

//
// Type of authentication information
//
#define TRUST_AUTH_TYPE_NONE    0   // Ignore this entry
#define TRUST_AUTH_TYPE_NT4OWF  1   // NT4 OWF password
#define TRUST_AUTH_TYPE_CLEAR   2   // Cleartext password
#define TRUST_AUTH_TYPE_VERSION 3   // Cleartext password version number

typedef struct _LSA_AUTH_INFORMATION {

    LARGE_INTEGER LastUpdateTime;
    ULONG AuthType;
    ULONG AuthInfoLength;
    PUCHAR AuthInfo;
} LSA_AUTH_INFORMATION, *PLSA_AUTH_INFORMATION;

typedef struct _TRUSTED_DOMAIN_AUTH_INFORMATION {

    ULONG IncomingAuthInfos;
    PLSA_AUTH_INFORMATION   IncomingAuthenticationInformation;
    PLSA_AUTH_INFORMATION   IncomingPreviousAuthenticationInformation;
    ULONG OutgoingAuthInfos;
    PLSA_AUTH_INFORMATION   OutgoingAuthenticationInformation;
    PLSA_AUTH_INFORMATION   OutgoingPreviousAuthenticationInformation;

} TRUSTED_DOMAIN_AUTH_INFORMATION, *PTRUSTED_DOMAIN_AUTH_INFORMATION;

typedef struct _TRUSTED_DOMAIN_FULL_INFORMATION {

    TRUSTED_DOMAIN_INFORMATION_EX   Information;
    TRUSTED_POSIX_OFFSET_INFO       PosixOffset;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;

} TRUSTED_DOMAIN_FULL_INFORMATION, *PTRUSTED_DOMAIN_FULL_INFORMATION;

typedef struct _TRUSTED_DOMAIN_FULL_INFORMATION2 {

    TRUSTED_DOMAIN_INFORMATION_EX2  Information;
    TRUSTED_POSIX_OFFSET_INFO       PosixOffset;
    TRUSTED_DOMAIN_AUTH_INFORMATION AuthInformation;

} TRUSTED_DOMAIN_FULL_INFORMATION2, *PTRUSTED_DOMAIN_FULL_INFORMATION2;

typedef struct _TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES {

    ULONG      SupportedEncryptionTypes;

} TRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES, *PTRUSTED_DOMAIN_SUPPORTED_ENCRYPTION_TYPES;

typedef enum {

    ForestTrustTopLevelName,
    ForestTrustTopLevelNameEx,
    ForestTrustDomainInfo,
    ForestTrustRecordTypeLast = ForestTrustDomainInfo

} LSA_FOREST_TRUST_RECORD_TYPE;

#if (_WIN32_WINNT < 0x0502)
#define LSA_FOREST_TRUST_RECORD_TYPE_UNRECOGNIZED 0x80000000
#endif

//
// Bottom 16 bits of the flags are reserved for disablement reasons
//

#define LSA_FTRECORD_DISABLED_REASONS            ( 0x0000FFFFL )

//
// Reasons for a top-level name forest trust record to be disabled
//

#define LSA_TLN_DISABLED_NEW                     ( 0x00000001L )
#define LSA_TLN_DISABLED_ADMIN                   ( 0x00000002L )
#define LSA_TLN_DISABLED_CONFLICT                ( 0x00000004L )

//
// Reasons for a domain information forest trust record to be disabled
//

#define LSA_SID_DISABLED_ADMIN                   ( 0x00000001L )
#define LSA_SID_DISABLED_CONFLICT                ( 0x00000002L )
#define LSA_NB_DISABLED_ADMIN                    ( 0x00000004L )
#define LSA_NB_DISABLED_CONFLICT                 ( 0x00000008L )

typedef struct _LSA_FOREST_TRUST_DOMAIN_INFO {

#ifdef MIDL_PASS
    PISID Sid;
#else
    PSID Sid;
#endif
    LSA_UNICODE_STRING DnsName;
    LSA_UNICODE_STRING NetbiosName;

} LSA_FOREST_TRUST_DOMAIN_INFO, *PLSA_FOREST_TRUST_DOMAIN_INFO;


#if (_WIN32_WINNT >= 0x0502)
//
//  To prevent huge data to be passed in, we should put a limit on LSA_FOREST_TRUST_BINARY_DATA.
//      128K is large enough that can't be reached in the near future, and small enough not to
//      cause memory problems.

#define MAX_FOREST_TRUST_BINARY_DATA_SIZE ( 128 * 1024 )
#endif

typedef struct _LSA_FOREST_TRUST_BINARY_DATA {

#ifdef MIDL_PASS
    [range(0, MAX_FOREST_TRUST_BINARY_DATA_SIZE)] ULONG Length;
    [size_is( Length )] PUCHAR Buffer;
#else
    ULONG Length;
    PUCHAR Buffer;
#endif

} LSA_FOREST_TRUST_BINARY_DATA, *PLSA_FOREST_TRUST_BINARY_DATA;

typedef struct _LSA_FOREST_TRUST_RECORD {

    ULONG Flags;
    LSA_FOREST_TRUST_RECORD_TYPE ForestTrustType; // type of record
    LARGE_INTEGER Time;

#ifdef MIDL_PASS
    [switch_type( LSA_FOREST_TRUST_RECORD_TYPE ), switch_is( ForestTrustType )]
#endif

    union {                                       // actual data

#ifdef MIDL_PASS
        [case( ForestTrustTopLevelName,
               ForestTrustTopLevelNameEx )] LSA_UNICODE_STRING TopLevelName;
        [case( ForestTrustDomainInfo )] LSA_FOREST_TRUST_DOMAIN_INFO DomainInfo;
        [default] LSA_FOREST_TRUST_BINARY_DATA Data;
#else
        LSA_UNICODE_STRING TopLevelName;
        LSA_FOREST_TRUST_DOMAIN_INFO DomainInfo;
        LSA_FOREST_TRUST_BINARY_DATA Data;        // used for unrecognized types
#endif
    } ForestTrustData;

} LSA_FOREST_TRUST_RECORD, *PLSA_FOREST_TRUST_RECORD;

#if (_WIN32_WINNT >= 0x0502)
//
// To prevent forest trust blobs of large size, number of records must be
// smaller than MAX_RECORDS_IN_FOREST_TRUST_INFO
//

#define MAX_RECORDS_IN_FOREST_TRUST_INFO 4000
#endif

typedef struct _LSA_FOREST_TRUST_INFORMATION {

#ifdef MIDL_PASS
    [range(0, MAX_RECORDS_IN_FOREST_TRUST_INFO)] ULONG RecordCount;
    [size_is( RecordCount )] PLSA_FOREST_TRUST_RECORD * Entries;
#else
    ULONG RecordCount;
    PLSA_FOREST_TRUST_RECORD * Entries;
#endif

} LSA_FOREST_TRUST_INFORMATION, *PLSA_FOREST_TRUST_INFORMATION;

typedef enum {

    CollisionTdo,
    CollisionXref,
    CollisionOther

} LSA_FOREST_TRUST_COLLISION_RECORD_TYPE;

typedef struct _LSA_FOREST_TRUST_COLLISION_RECORD {

    ULONG Index;
    LSA_FOREST_TRUST_COLLISION_RECORD_TYPE Type;
    ULONG Flags;
    LSA_UNICODE_STRING Name;

} LSA_FOREST_TRUST_COLLISION_RECORD, *PLSA_FOREST_TRUST_COLLISION_RECORD;

typedef struct _LSA_FOREST_TRUST_COLLISION_INFORMATION {

    ULONG RecordCount;
#ifdef MIDL_PASS
    [size_is( RecordCount )]
#endif
    PLSA_FOREST_TRUST_COLLISION_RECORD * Entries;

} LSA_FOREST_TRUST_COLLISION_INFORMATION, *PLSA_FOREST_TRUST_COLLISION_INFORMATION;


//
// LSA Enumeration Context
//

typedef ULONG LSA_ENUMERATION_HANDLE, *PLSA_ENUMERATION_HANDLE;

//
// LSA Enumeration Information
//

typedef struct _LSA_ENUMERATION_INFORMATION {

    PSID Sid;

} LSA_ENUMERATION_INFORMATION, *PLSA_ENUMERATION_INFORMATION;


////////////////////////////////////////////////////////////////////////////
//                                                                        //
// Local Security Policy - Miscellaneous API function prototypes          //
//                                                                        //
////////////////////////////////////////////////////////////////////////////


NTSTATUS
NTAPI
LsaFreeMemory(
    __in_opt PVOID Buffer
    );

NTSTATUS
NTAPI
LsaClose(
    __in LSA_HANDLE ObjectHandle
    );


#if (_WIN32_WINNT >= 0x0600)

typedef struct _LSA_LAST_INTER_LOGON_INFO {
    LARGE_INTEGER LastSuccessfulLogon;
    LARGE_INTEGER LastFailedLogon;
    ULONG FailedAttemptCountSinceLastSuccessfulLogon;
} LSA_LAST_INTER_LOGON_INFO, *PLSA_LAST_INTER_LOGON_INFO;

#endif

#if (_WIN32_WINNT >= 0x0501)
typedef struct _SECURITY_LOGON_SESSION_DATA {
    ULONG               Size;
    LUID                LogonId;
    LSA_UNICODE_STRING  UserName;
    LSA_UNICODE_STRING  LogonDomain;
    LSA_UNICODE_STRING  AuthenticationPackage;
    ULONG               LogonType;
    ULONG               Session;
    PSID                Sid;
    LARGE_INTEGER       LogonTime;

    //
    // new for whistler:
    //

    LSA_UNICODE_STRING  LogonServer;
    LSA_UNICODE_STRING  DnsDomainName;
    LSA_UNICODE_STRING  Upn;

#if (_WIN32_WINNT >= 0x0600)
    
    // 
    // new for LH
    //
    
    ULONG UserFlags; 

    LSA_LAST_INTER_LOGON_INFO LastLogonInfo; 
    LSA_UNICODE_STRING LogonScript;
    LSA_UNICODE_STRING ProfilePath;         
    LSA_UNICODE_STRING HomeDirectory;
    LSA_UNICODE_STRING HomeDirectoryDrive;
    
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;

#endif
} SECURITY_LOGON_SESSION_DATA, * PSECURITY_LOGON_SESSION_DATA;

NTSTATUS
NTAPI
LsaEnumerateLogonSessions(
    __out PULONG  LogonSessionCount,
    __out PLUID * LogonSessionList
    );

NTSTATUS
NTAPI
LsaGetLogonSessionData(
    __in PLUID    LogonId,
    __out PSECURITY_LOGON_SESSION_DATA * ppLogonSessionData
    );

#endif
NTSTATUS
NTAPI
LsaOpenPolicy(
    __in_opt PLSA_UNICODE_STRING SystemName,
    __in PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE PolicyHandle
    );


NTSTATUS
NTAPI
LsaQueryInformationPolicy(
    __in LSA_HANDLE PolicyHandle,
    __in POLICY_INFORMATION_CLASS InformationClass,
    __out PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetInformationPolicy(
    __in LSA_HANDLE PolicyHandle,
    __in POLICY_INFORMATION_CLASS InformationClass,
    __in PVOID Buffer
    );

NTSTATUS
NTAPI
LsaQueryDomainInformationPolicy(
    __in LSA_HANDLE PolicyHandle,
    __in POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    __out PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetDomainInformationPolicy(
    __in LSA_HANDLE PolicyHandle,
    __in POLICY_DOMAIN_INFORMATION_CLASS InformationClass,
    __in_opt PVOID Buffer
    );


NTSTATUS
NTAPI
LsaRegisterPolicyChangeNotification(
    __in POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    __in HANDLE  NotificationEventHandle
    );

NTSTATUS
NTAPI
LsaUnregisterPolicyChangeNotification(
    __in POLICY_NOTIFICATION_INFORMATION_CLASS InformationClass,
    __in HANDLE  NotificationEventHandle
    );



NTSTATUS
NTAPI
LsaEnumerateTrustedDomains(
    __in LSA_HANDLE PolicyHandle,
    __inout PLSA_ENUMERATION_HANDLE EnumerationContext,
    __out PVOID *Buffer,
    __in ULONG PreferedMaximumLength,
    __out PULONG CountReturned
    );


NTSTATUS
NTAPI
LsaLookupNames(
    __in LSA_HANDLE PolicyHandle,
    __in ULONG Count,
    __in PLSA_UNICODE_STRING Names,
    __out PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    __out PLSA_TRANSLATED_SID *Sids
    );

#if (_WIN32_WINNT >= 0x0501)
NTSTATUS
NTAPI
LsaLookupNames2(
    __in LSA_HANDLE PolicyHandle,
    __in ULONG Flags, // Reserved
    __in ULONG Count,
    __in PLSA_UNICODE_STRING Names,
    __out PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    __out PLSA_TRANSLATED_SID2 *Sids
    );
#endif

NTSTATUS
NTAPI
LsaLookupSids(
    __in LSA_HANDLE PolicyHandle,
    __in ULONG Count,
    __in PSID *Sids,
    __out PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    __out PLSA_TRANSLATED_NAME *Names
    );



#define SE_INTERACTIVE_LOGON_NAME           TEXT("SeInteractiveLogonRight")
#define SE_NETWORK_LOGON_NAME               TEXT("SeNetworkLogonRight")
#define SE_BATCH_LOGON_NAME                 TEXT("SeBatchLogonRight")
#define SE_SERVICE_LOGON_NAME               TEXT("SeServiceLogonRight")
#define SE_DENY_INTERACTIVE_LOGON_NAME      TEXT("SeDenyInteractiveLogonRight")
#define SE_DENY_NETWORK_LOGON_NAME          TEXT("SeDenyNetworkLogonRight")
#define SE_DENY_BATCH_LOGON_NAME            TEXT("SeDenyBatchLogonRight")
#define SE_DENY_SERVICE_LOGON_NAME          TEXT("SeDenyServiceLogonRight")
#if (_WIN32_WINNT >= 0x0501)
#define SE_REMOTE_INTERACTIVE_LOGON_NAME    TEXT("SeRemoteInteractiveLogonRight")
#define SE_DENY_REMOTE_INTERACTIVE_LOGON_NAME TEXT("SeDenyRemoteInteractiveLogonRight")
#endif

//
// This new API returns all the accounts with a certain privilege
//

NTSTATUS
NTAPI
LsaEnumerateAccountsWithUserRight(
    __in LSA_HANDLE PolicyHandle,
    __in_opt PLSA_UNICODE_STRING UserRight,
    __out PVOID *Buffer,
    __out PULONG CountReturned
    );

//
// These new APIs differ by taking a SID instead of requiring the caller
// to open the account first and passing in an account handle
//

NTSTATUS
NTAPI
LsaEnumerateAccountRights(
    __in LSA_HANDLE PolicyHandle,
    __in PSID AccountSid,
    __deref_out_ecount(*CountOfRights) PLSA_UNICODE_STRING *UserRights,
    __out PULONG CountOfRights
    );

NTSTATUS
NTAPI
LsaAddAccountRights(
    __in LSA_HANDLE PolicyHandle,
    __in PSID AccountSid,
    __in_ecount(CountOfRights) PLSA_UNICODE_STRING UserRights,
    __in ULONG CountOfRights
    );

NTSTATUS
NTAPI
LsaRemoveAccountRights(
    __in LSA_HANDLE PolicyHandle,
    __in PSID AccountSid,
    __in BOOLEAN AllRights,
    __in_ecount_opt(CountOfRights) PLSA_UNICODE_STRING UserRights,
    __in ULONG CountOfRights
    );

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Local Security Policy - Trusted Domain Object API function prototypes     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
NTAPI
LsaOpenTrustedDomainByName(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING TrustedDomainName,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE TrustedDomainHandle
    );


NTSTATUS
NTAPI
LsaQueryTrustedDomainInfo(
    __in LSA_HANDLE PolicyHandle,
    __in PSID TrustedDomainSid,
    __in TRUSTED_INFORMATION_CLASS InformationClass,
    __out PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetTrustedDomainInformation(
    __in LSA_HANDLE PolicyHandle,
    __in PSID TrustedDomainSid,
    __in TRUSTED_INFORMATION_CLASS InformationClass,
    __in PVOID Buffer
    );

NTSTATUS
NTAPI
LsaDeleteTrustedDomain(
    __in LSA_HANDLE PolicyHandle,
    __in PSID TrustedDomainSid
    );

NTSTATUS
NTAPI
LsaQueryTrustedDomainInfoByName(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING TrustedDomainName,
    __in TRUSTED_INFORMATION_CLASS InformationClass,
    __out PVOID *Buffer
    );

NTSTATUS
NTAPI
LsaSetTrustedDomainInfoByName(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING TrustedDomainName,
    __in TRUSTED_INFORMATION_CLASS InformationClass,
    __in PVOID Buffer
    );

NTSTATUS
NTAPI
LsaEnumerateTrustedDomainsEx(
    __in LSA_HANDLE PolicyHandle,
    __inout PLSA_ENUMERATION_HANDLE EnumerationContext,
    __out PVOID *Buffer,
    __in ULONG PreferedMaximumLength,
    __out PULONG CountReturned
    );

NTSTATUS
NTAPI
LsaCreateTrustedDomainEx(
    __in LSA_HANDLE PolicyHandle,
    __in PTRUSTED_DOMAIN_INFORMATION_EX TrustedDomainInformation,
    __in PTRUSTED_DOMAIN_AUTH_INFORMATION AuthenticationInformation,
    __in ACCESS_MASK DesiredAccess,
    __out PLSA_HANDLE TrustedDomainHandle
    );

#if (_WIN32_WINNT >= 0x0501)
NTSTATUS
NTAPI
LsaQueryForestTrustInformation(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING TrustedDomainName,
    __out PLSA_FOREST_TRUST_INFORMATION * ForestTrustInfo
    );

NTSTATUS
NTAPI
LsaSetForestTrustInformation(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING TrustedDomainName,
    __in PLSA_FOREST_TRUST_INFORMATION ForestTrustInfo,
    __in BOOLEAN CheckOnly,
    __out PLSA_FOREST_TRUST_COLLISION_INFORMATION * CollisionInfo
    );

// #define TESTING_MATCHING_ROUTINE

#ifdef TESTING_MATCHING_ROUTINE

NTSTATUS
NTAPI
LsaForestTrustFindMatch(
    __in LSA_HANDLE PolicyHandle,
    __in ULONG Type,
    __in PLSA_UNICODE_STRING Name,
    __out PLSA_UNICODE_STRING * Match
    );

#endif
#endif

//
// This API sets the workstation password (equivalent of setting/getting
// the SSI_SECRET_NAME secret)
//

NTSTATUS
NTAPI
LsaStorePrivateData(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING KeyName,
    __in_opt PLSA_UNICODE_STRING PrivateData
    );

NTSTATUS
NTAPI
LsaRetrievePrivateData(
    __in LSA_HANDLE PolicyHandle,
    __in PLSA_UNICODE_STRING KeyName,
    __out PLSA_UNICODE_STRING * PrivateData
    );


ULONG
NTAPI
LsaNtStatusToWinError(
    __in NTSTATUS Status
    );


//
// Define a symbol so we can tell if ntifs.h has been included.
//

// begin_ntifs
#ifndef _NTLSA_IFS_
#define _NTLSA_IFS_
#endif
// end_ntifs


//
// SPNEGO package stuff
//

enum NEGOTIATE_MESSAGES {
    NegEnumPackagePrefixes = 0,
    NegGetCallerName = 1,
    NegCallPackageMax
};

#define NEGOTIATE_MAX_PREFIX    32

typedef struct _NEGOTIATE_PACKAGE_PREFIX {
    ULONG_PTR   PackageId;
    PVOID       PackageDataA;
    PVOID       PackageDataW;
    ULONG_PTR   PrefixLen;
    UCHAR       Prefix[ NEGOTIATE_MAX_PREFIX ];
} NEGOTIATE_PACKAGE_PREFIX, * PNEGOTIATE_PACKAGE_PREFIX;

typedef struct _NEGOTIATE_PACKAGE_PREFIXES {
    ULONG       MessageType;
    ULONG       PrefixCount;
    ULONG       Offset;        // Offset to array of _PREFIX above
#if(_WIN32_WINNT >= 0x0502)
    ULONG       Pad;           // Align structure for 64-bit
#endif
} NEGOTIATE_PACKAGE_PREFIXES, *PNEGOTIATE_PACKAGE_PREFIXES;

typedef struct _NEGOTIATE_CALLER_NAME_REQUEST {
    ULONG       MessageType;
    LUID        LogonId;
} NEGOTIATE_CALLER_NAME_REQUEST, *PNEGOTIATE_CALLER_NAME_REQUEST;

typedef struct _NEGOTIATE_CALLER_NAME_RESPONSE {
    ULONG       MessageType;
    PWSTR       CallerName;
} NEGOTIATE_CALLER_NAME_RESPONSE, * PNEGOTIATE_CALLER_NAME_RESPONSE;

#ifndef _NTDEF_
typedef LSA_UNICODE_STRING UNICODE_STRING, *PUNICODE_STRING;
typedef LSA_STRING STRING, *PSTRING ;
#endif

#ifndef _DOMAIN_PASSWORD_INFORMATION_DEFINED
#define _DOMAIN_PASSWORD_INFORMATION_DEFINED
typedef struct _DOMAIN_PASSWORD_INFORMATION {
    USHORT MinPasswordLength;
    USHORT PasswordHistoryLength;
    ULONG PasswordProperties;
#if defined(MIDL_PASS)
    OLD_LARGE_INTEGER MaxPasswordAge;
    OLD_LARGE_INTEGER MinPasswordAge;
#else
    LARGE_INTEGER MaxPasswordAge;
    LARGE_INTEGER MinPasswordAge;
#endif
} DOMAIN_PASSWORD_INFORMATION, *PDOMAIN_PASSWORD_INFORMATION;
#endif

#if (_WIN32_WINNT >= 0x0501)
//
// PasswordProperties flags
//

#define DOMAIN_PASSWORD_COMPLEX             0x00000001L
#define DOMAIN_PASSWORD_NO_ANON_CHANGE      0x00000002L
#define DOMAIN_PASSWORD_NO_CLEAR_CHANGE     0x00000004L
#define DOMAIN_LOCKOUT_ADMINS               0x00000008L
#define DOMAIN_PASSWORD_STORE_CLEARTEXT     0x00000010L
#define DOMAIN_REFUSE_PASSWORD_CHANGE       0x00000020L
#if(_WIN32_WINNT >= 0x0502)
#define DOMAIN_NO_LM_OWF_CHANGE             0x00000040L
#endif
#endif



#ifndef _PASSWORD_NOTIFICATION_DEFINED
#define _PASSWORD_NOTIFICATION_DEFINED
typedef NTSTATUS (*PSAM_PASSWORD_NOTIFICATION_ROUTINE) (
    PUNICODE_STRING UserName,
    ULONG RelativeId,
    PUNICODE_STRING NewPassword
);

#define SAM_PASSWORD_CHANGE_NOTIFY_ROUTINE  "PasswordChangeNotify"

typedef BOOLEAN (*PSAM_INIT_NOTIFICATION_ROUTINE) (
);

#define SAM_INIT_NOTIFICATION_ROUTINE  "InitializeChangeNotify"

#define SAM_PASSWORD_FILTER_ROUTINE  "PasswordFilter"

typedef BOOLEAN (*PSAM_PASSWORD_FILTER_ROUTINE) (
    IN PUNICODE_STRING  AccountName,
    IN PUNICODE_STRING  FullName,
    IN PUNICODE_STRING Password,
    IN BOOLEAN SetOperation
    );


#endif // _PASSWORD_NOTIFICATION_DEFINED


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Name of the MSV1_0 authentication package                           //
//                                                                     //
/////////////////////////////////////////////////////////////////////////

#define MSV1_0_PACKAGE_NAME     "MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
#define MSV1_0_PACKAGE_NAMEW    L"MICROSOFT_AUTHENTICATION_PACKAGE_V1_0"
#define MSV1_0_PACKAGE_NAMEW_LENGTH sizeof(MSV1_0_PACKAGE_NAMEW) - sizeof(WCHAR)

//
// Location of MSV authentication package data
//
#define MSV1_0_SUBAUTHENTICATION_KEY "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0"
#define MSV1_0_SUBAUTHENTICATION_VALUE "Auth"


/////////////////////////////////////////////////////////////////////////
//                                                                     //
// Widely used MSV1_0 data types                                       //
//                                                                     //
/////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//       LOGON      Related Data Structures
//
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// When a LsaLogonUser() call is dispatched to the MsV1_0 authentication
// package, the beginning of the AuthenticationInformation buffer is
// cast to a MSV1_0_LOGON_SUBMIT_TYPE to determine the type of logon
// being requested.  Similarly, upon return, the type of profile buffer
// can be determined by typecasting it to a MSV_1_0_PROFILE_BUFFER_TYPE.
//

//
//  MSV1.0 LsaLogonUser() submission message types.
//

typedef enum _MSV1_0_LOGON_SUBMIT_TYPE {
    MsV1_0InteractiveLogon = 2,
    MsV1_0Lm20Logon,
    MsV1_0NetworkLogon,
    MsV1_0SubAuthLogon,
    MsV1_0WorkstationUnlockLogon = 7,
    // defined in Longhorn and up
    MsV1_0S4ULogon = 12,
} MSV1_0_LOGON_SUBMIT_TYPE, *PMSV1_0_LOGON_SUBMIT_TYPE;


//
//  MSV1.0 LsaLogonUser() profile buffer types.
//

typedef enum _MSV1_0_PROFILE_BUFFER_TYPE {
    MsV1_0InteractiveProfile = 2,
    MsV1_0Lm20LogonProfile,
    MsV1_0SmartCardProfile
} MSV1_0_PROFILE_BUFFER_TYPE, *PMSV1_0_PROFILE_BUFFER_TYPE;

//
// MsV1_0InteractiveLogon
//
// The AuthenticationInformation buffer of an LsaLogonUser() call to
// perform an interactive logon contains the following data structure:
//

typedef struct _MSV1_0_INTERACTIVE_LOGON {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Password;
} MSV1_0_INTERACTIVE_LOGON, *PMSV1_0_INTERACTIVE_LOGON;

//
// Where:
//
//     MessageType - Contains the type of logon being requested.  This
//         field must be set to MsV1_0InteractiveLogon.
//
//     UserName - Is a string representing the user's account name.  The
//         name may be up to 255 characters long.  The name is treated case
//         insensitive.
//
//     Password - Is a string containing the user's cleartext password.
//         The password may be up to 255 characters long and contain any
//         UNICODE value.
//
//


//
// The ProfileBuffer returned upon a successful logon of this type
// contains the following data structure:
//

typedef struct _MSV1_0_INTERACTIVE_PROFILE {
    MSV1_0_PROFILE_BUFFER_TYPE MessageType;
    USHORT LogonCount;
    USHORT BadPasswordCount;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING LogonScript;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING FullName;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING LogonServer;
    ULONG UserFlags;
} MSV1_0_INTERACTIVE_PROFILE, *PMSV1_0_INTERACTIVE_PROFILE;

//
// where:
//
//     MessageType - Identifies the type of profile data being returned.
//         Contains the type of logon being requested.  This field must
//         be set to MsV1_0InteractiveProfile.
//
//     LogonCount - Number of times the user is currently logged on.
//
//     BadPasswordCount - Number of times a bad password was applied to
//         the account since last successful logon.
//
//     LogonTime - Time when user last logged on.  This is an absolute
//         format NT standard time value.
//
//     LogoffTime - Time when user should log off.  This is an absolute
//         format NT standard time value.
//
//     KickOffTime - Time when system should force user logoff.  This is
//         an absolute format NT standard time value.
//
//     PasswordLastChanged - Time and date the password was last
//         changed.  This is an absolute format NT standard time
//         value.
//
//     PasswordCanChange - Time and date when the user can change the
//         password.  This is an absolute format NT time value.  To
//         prevent a password from ever changing, set this field to a
//         date very far into the future.
//
//     PasswordMustChange - Time and date when the user must change the
//         password.  If the user can never change the password, this
//         field is undefined.  This is an absolute format NT time
//         value.
//
//     LogonScript - The (relative) path to the account's logon
//         script.
//
//     HomeDirectory - The home directory for the user.
//


//
// MsV1_0Lm20Logon and MsV1_0NetworkLogon
//
// The AuthenticationInformation buffer of an LsaLogonUser() call to
// perform an network logon contains the following data structure:
//
// MsV1_0NetworkLogon logon differs from MsV1_0Lm20Logon in that the
// ParameterControl field exists.
//

#define MSV1_0_CHALLENGE_LENGTH 8
#define MSV1_0_USER_SESSION_KEY_LENGTH 16
#define MSV1_0_LANMAN_SESSION_KEY_LENGTH 8

//
// Values for ParameterControl.
//

#define MSV1_0_CLEARTEXT_PASSWORD_ALLOWED    0x02
#define MSV1_0_UPDATE_LOGON_STATISTICS       0x04
#define MSV1_0_RETURN_USER_PARAMETERS        0x08
#define MSV1_0_DONT_TRY_GUEST_ACCOUNT        0x10
#define MSV1_0_ALLOW_SERVER_TRUST_ACCOUNT    0x20
#define MSV1_0_RETURN_PASSWORD_EXPIRY        0x40
// this next flag says that CaseInsensitiveChallengeResponse
//  (aka LmResponse) contains a client challenge in the first 8 bytes
#define MSV1_0_USE_CLIENT_CHALLENGE          0x80
#define MSV1_0_TRY_GUEST_ACCOUNT_ONLY        0x100
#define MSV1_0_RETURN_PROFILE_PATH           0x200
#define MSV1_0_TRY_SPECIFIED_DOMAIN_ONLY     0x400
#define MSV1_0_ALLOW_WORKSTATION_TRUST_ACCOUNT 0x800
//#if (_WIN32_WINNT >= 0x0501) -- Disabled until IIS fixes their target version.
#define MSV1_0_DISABLE_PERSONAL_FALLBACK     0x00001000
#define MSV1_0_ALLOW_FORCE_GUEST             0x00002000
//#endif
#if (_WIN32_WINNT >= 0x0502)
#define MSV1_0_CLEARTEXT_PASSWORD_SUPPLIED   0x00004000
// Start
// Doesnt exist in Windows XP but does exist in Windows 2000 Security Rollup and up
#define MSV1_0_USE_DOMAIN_FOR_ROUTING_ONLY   0x00008000
#endif
#define MSV1_0_SUBAUTHENTICATION_DLL_EX      0x00100000
// Defined in Windows Server 2003 SP1 and above
#define MSV1_0_ALLOW_MSVCHAPV2               0x00010000

#if (_WIN32_WINNT >= 0x0600)

//Defined in Longhorn and up
#define MSV1_0_S4U2SELF                      0x00020000 // no password is needed
#define MSV1_0_CHECK_LOGONHOURS_FOR_S4U      0x00040000 // check logon hours for S4U logon

#endif

//
// The high order byte is a value indicating the SubAuthentication DLL.
//  Zero indicates no SubAuthentication DLL.
//
#define MSV1_0_SUBAUTHENTICATION_DLL         0xFF000000
#define MSV1_0_SUBAUTHENTICATION_DLL_SHIFT   24
#define MSV1_0_MNS_LOGON                     0x01000000

//
// This is the list of subauthentication dlls used in MS
//

#define MSV1_0_SUBAUTHENTICATION_DLL_RAS     2
#define MSV1_0_SUBAUTHENTICATION_DLL_IIS     132

typedef struct _MSV1_0_LM20_LOGON {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    STRING CaseSensitiveChallengeResponse;
    STRING CaseInsensitiveChallengeResponse;
    ULONG ParameterControl;
} MSV1_0_LM20_LOGON, * PMSV1_0_LM20_LOGON;

//
// NT 5.0 SubAuth dlls can use this struct
//

typedef struct _MSV1_0_SUBAUTH_LOGON{
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    UNICODE_STRING LogonDomainName;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
    UCHAR ChallengeToClient[MSV1_0_CHALLENGE_LENGTH];
    STRING AuthenticationInfo1;
    STRING AuthenticationInfo2;
    ULONG ParameterControl;
    ULONG SubAuthPackageId;
} MSV1_0_SUBAUTH_LOGON, * PMSV1_0_SUBAUTH_LOGON;

#if (_WIN32_WINNT >= 0x0600)

//
// s4u2self logon
//
// Defined in Longhorn and above

//
// request to enforce logon hours policy
//

#define MSV1_0_S4U_LOGON_FLAG_CHECK_LOGONHOURS 0x2

typedef struct _MSV1_0_S4U_LOGON {
    MSV1_0_LOGON_SUBMIT_TYPE MessageType;
    ULONG Flags;
    UNICODE_STRING UserPrincipalName; // username or username@domain
    UNICODE_STRING DomainName; // Optional: if missing, using the local machine
} MSV1_0_S4U_LOGON, *PMSV1_0_S4U_LOGON;

#endif 

//
// Values for UserFlags.
//

#define LOGON_GUEST                 0x01
#define LOGON_NOENCRYPTION          0x02
#define LOGON_CACHED_ACCOUNT        0x04
#define LOGON_USED_LM_PASSWORD      0x08
#define LOGON_EXTRA_SIDS            0x20
#define LOGON_SUBAUTH_SESSION_KEY   0x40
#define LOGON_SERVER_TRUST_ACCOUNT  0x80
#define LOGON_NTLMV2_ENABLED        0x100       // says DC understands NTLMv2
#define LOGON_RESOURCE_GROUPS       0x200
#define LOGON_PROFILE_PATH_RETURNED 0x400
// Defined in Longhorn and above
#define LOGON_NT_V2                 0x800   // NT response was used for validation
#define LOGON_LM_V2                 0x1000  // LM response was used for validation
#define LOGON_NTLM_V2               0x2000  // LM response was used to authenticate but NT response was used to derive the session key

#if (_WIN32_WINNT >= 0x0600)

#define LOGON_OPTIMIZED             0x4000  // this is an optimized logon
#define LOGON_WINLOGON              0x8000  // the logon session was created for winlogon
#define LOGON_PKINIT               0x10000  // Kerberos PKINIT extension was used to authenticate the user
#define LOGON_NO_OPTIMIZED         0x20000  // optimized logon has been disabled for this account

#endif

//
// The high order byte is reserved for return by SubAuthentication DLLs.
//

#define MSV1_0_SUBAUTHENTICATION_FLAGS 0xFF000000

// Values returned by the MSV1_0_MNS_LOGON SubAuthentication DLL
#define LOGON_GRACE_LOGON              0x01000000

typedef struct _MSV1_0_LM20_LOGON_PROFILE {
    MSV1_0_PROFILE_BUFFER_TYPE MessageType;
    LARGE_INTEGER KickOffTime;
    LARGE_INTEGER LogoffTime;
    ULONG UserFlags;
    UCHAR UserSessionKey[MSV1_0_USER_SESSION_KEY_LENGTH];
    UNICODE_STRING LogonDomainName;
    UCHAR LanmanSessionKey[MSV1_0_LANMAN_SESSION_KEY_LENGTH];
    UNICODE_STRING LogonServer;
    UNICODE_STRING UserParameters;
} MSV1_0_LM20_LOGON_PROFILE, * PMSV1_0_LM20_LOGON_PROFILE;


//
// Supplemental credentials structure used for passing credentials into
// MSV1_0 from other packages
//

#define MSV1_0_OWF_PASSWORD_LENGTH 16
#define MSV1_0_CRED_LM_PRESENT 0x1
#define MSV1_0_CRED_NT_PRESENT 0x2
#define MSV1_0_CRED_VERSION 0

typedef struct _MSV1_0_SUPPLEMENTAL_CREDENTIAL {
    ULONG Version;
    ULONG Flags;
    UCHAR LmPassword[MSV1_0_OWF_PASSWORD_LENGTH];
    UCHAR NtPassword[MSV1_0_OWF_PASSWORD_LENGTH];
} MSV1_0_SUPPLEMENTAL_CREDENTIAL, *PMSV1_0_SUPPLEMENTAL_CREDENTIAL;


//
// NTLM3 definitions.
//

#define MSV1_0_NTLM3_RESPONSE_LENGTH 16
#define MSV1_0_NTLM3_OWF_LENGTH 16

//
// this is the longest amount of time we'll allow challenge response
// pairs to be used. Note that this also has to allow for worst case clock skew
//
#if (_WIN32_WINNT == 0x0500)
#define MSV1_0_MAX_NTLM3_LIFE 1800     // 30 minutes (in seconds)
#else
#define MSV1_0_MAX_NTLM3_LIFE 129600     // 36 hours (in seconds)
#endif
#define MSV1_0_MAX_AVL_SIZE 64000

#if (_WIN32_WINNT >= 0x0501)
//
// MsvAvFlags bit values
//
// Exists only after Windows 2000
//

#define MSV1_0_AV_FLAG_FORCE_GUEST                  0x00000001
#if (_WIN32_WINNT >= 0x0600)
#define MSV1_0_AV_FLAG_MIC_HANDSHAKE_MESSAGES       0x00000002 // the client supports
                                                               // hand-shake messages integrity
#endif
#endif

// this is an MSV1_0 private data structure, defining the layout of an NTLM3 response, as sent by a
//  client in the NtChallengeResponse field of the NETLOGON_NETWORK_INFO structure. If can be differentiated
//  from an old style NT response by its length. This is crude, but it needs to pass through servers and
//  the servers' DCs that do not understand NTLM3 but that are willing to pass longer responses.
typedef struct _MSV1_0_NTLM3_RESPONSE {
    UCHAR Response[MSV1_0_NTLM3_RESPONSE_LENGTH]; // hash of OWF of password with all the following fields
    UCHAR RespType;     // id number of response; current is 1
    UCHAR HiRespType;   // highest id number understood by client
    USHORT Flags;       // reserved; must be sent as zero at this version
    ULONG MsgWord;      // 32 bit message from client to server (for use by auth protocol)
    ULONGLONG TimeStamp;    // time stamp when client generated response -- NT system time, quad part
    UCHAR ChallengeFromClient[MSV1_0_CHALLENGE_LENGTH];
    ULONG AvPairsOff;   // offset to start of AvPairs (to allow future expansion)
    UCHAR Buffer[1];    // start of buffer with AV pairs (or future stuff -- so use the offset)
} MSV1_0_NTLM3_RESPONSE, *PMSV1_0_NTLM3_RESPONSE;

#define MSV1_0_NTLM3_INPUT_LENGTH (sizeof(MSV1_0_NTLM3_RESPONSE) - MSV1_0_NTLM3_RESPONSE_LENGTH)
#if(_WIN32_WINNT >= 0x0502)
#define MSV1_0_NTLM3_MIN_NT_RESPONSE_LENGTH RTL_SIZEOF_THROUGH_FIELD(MSV1_0_NTLM3_RESPONSE, AvPairsOff)
#endif

typedef enum {
    MsvAvEOL,                 // end of list
    MsvAvNbComputerName,      // server's computer name -- NetBIOS
    MsvAvNbDomainName,        // server's domain name -- NetBIOS
    MsvAvDnsComputerName,     // server's computer name -- DNS
    MsvAvDnsDomainName,       // server's domain name -- DNS
#if (_WIN32_WINNT >= 0x0501)
    MsvAvDnsTreeName,         // server's tree name -- DNS
    MsvAvFlags,               // server's extended flags -- DWORD mask
#if (_WIN32_WINNT >= 0x0600)
    MsvAvTimestamp,           // contains the server's local time in FILETIME,
                              // (64 bit 100 ns ticks since 1602
                              // (UTC)) in little endian byte order
    MsvAvRestrictions,        // token restrictions                              
#endif
#endif
} MSV1_0_AVID;

typedef struct  _MSV1_0_AV_PAIR {
    USHORT AvId;
    USHORT AvLen;
    // Data is treated as byte array following structure
} MSV1_0_AV_PAIR, *PMSV1_0_AV_PAIR;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
//       CALL PACKAGE Related Data Structures                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
//  MSV1.0 LsaCallAuthenticationPackage() submission and response
//  message types.
//

typedef enum _MSV1_0_PROTOCOL_MESSAGE_TYPE {
    MsV1_0Lm20ChallengeRequest = 0,          // Both submission and response
    MsV1_0Lm20GetChallengeResponse,          // Both submission and response
    MsV1_0EnumerateUsers,                    // Both submission and response
    MsV1_0GetUserInfo,                       // Both submission and response
    MsV1_0ReLogonUsers,                      // Submission only
    MsV1_0ChangePassword,                    // Both submission and response
    MsV1_0ChangeCachedPassword,              // Both submission and response
    MsV1_0GenericPassthrough,                // Both submission and response
    MsV1_0CacheLogon,                        // Submission only, no response
    MsV1_0SubAuth,                           // Both submission and response
    MsV1_0DeriveCredential,                  // Both submission and response
    MsV1_0CacheLookup,                       // Both submission and response
#if (_WIN32_WINNT >= 0x0501)
    MsV1_0SetProcessOption,                  // Submission only, no response
#endif
#if (_WIN32_WINNT >= 0x0600)
    MsV1_0ConfigLocalAliases,
    MsV1_0ClearCachedCredentials,
#endif    
} MSV1_0_PROTOCOL_MESSAGE_TYPE, *PMSV1_0_PROTOCOL_MESSAGE_TYPE;


typedef struct _MSV1_0_CHANGEPASSWORD_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING DomainName;
    UNICODE_STRING AccountName;
    UNICODE_STRING OldPassword;
    UNICODE_STRING NewPassword;
    BOOLEAN        Impersonating;
} MSV1_0_CHANGEPASSWORD_REQUEST, *PMSV1_0_CHANGEPASSWORD_REQUEST;

typedef struct _MSV1_0_CHANGEPASSWORD_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    BOOLEAN PasswordInfoValid;
    DOMAIN_PASSWORD_INFORMATION DomainPasswordInfo;
} MSV1_0_CHANGEPASSWORD_RESPONSE, *PMSV1_0_CHANGEPASSWORD_RESPONSE;


#if(_WIN32_WINNT >= 0x0502)
//
// MsV1_0GenericPassthrough - for remoting a CallPackage to
// a domain controller on the specified domain
//

typedef struct _MSV1_0_PASSTHROUGH_REQUEST {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    UNICODE_STRING DomainName;
    UNICODE_STRING PackageName;
    ULONG DataLength;
    PUCHAR LogonData;
    ULONG Pad ;
} MSV1_0_PASSTHROUGH_REQUEST, *PMSV1_0_PASSTHROUGH_REQUEST;

typedef struct _MSV1_0_PASSTHROUGH_RESPONSE {
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG Pad;
    ULONG DataLength;
    PUCHAR ValidationData;
} MSV1_0_PASSTHROUGH_RESPONSE, *PMSV1_0_PASSTHROUGH_RESPONSE;
#endif


//
// MsV1_0SubAuthInfo submit buffer and response - for submitting a buffer to a
// specified Subauthentication Package during an LsaCallAuthenticationPackage().
// If this Subauthentication is to be done locally, then package this message
// in LsaCallAuthenticationPackage(). If this SubAuthentication needs to be done
// on the domain controller, then call LsaCallauthenticationPackage with the
// message type being MsV1_0GenericPassThrough and the LogonData in this struct
// should be a PMSV1_0_SUBAUTH_REQUEST
//

typedef struct _MSV1_0_SUBAUTH_REQUEST{
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG SubAuthPackageId;
    ULONG SubAuthInfoLength;
    PUCHAR SubAuthSubmitBuffer;
} MSV1_0_SUBAUTH_REQUEST, *PMSV1_0_SUBAUTH_REQUEST;

typedef struct _MSV1_0_SUBAUTH_RESPONSE{
    MSV1_0_PROTOCOL_MESSAGE_TYPE MessageType;
    ULONG SubAuthInfoLength;
    PUCHAR SubAuthReturnBuffer;
} MSV1_0_SUBAUTH_RESPONSE, *PMSV1_0_SUBAUTH_RESPONSE;


#if(_WIN32_WINNT >= 0x0501)
#define RtlGenRandom                    SystemFunction036
#endif
#if(_WIN32_WINNT >= 0x0500)
#define RtlEncryptMemory                SystemFunction040
#define RtlDecryptMemory                SystemFunction041
#endif

#if(_WIN32_WINNT >= 0x0501)
BOOLEAN
RtlGenRandom(
    __out_bcount(RandomBufferLength) PVOID RandomBuffer,
    __in ULONG RandomBufferLength
    );
#endif

/*
 * #if(_WIN32_WINNT >= 0x0500) -- Disabled until WinHTTP fixes their target version.
 */

//
// The buffer passed into RtlEncryptMemory and RtlDecryptMemory
// must be a multiple of this length.
//

#define RTL_ENCRYPT_MEMORY_SIZE             8

//
// Allow Encrypt/Decrypt across process boundaries.
// eg: encrypted buffer passed across LPC to another process which calls RtlDecryptMemory.
//

#define RTL_ENCRYPT_OPTION_CROSS_PROCESS    0x01

//
// Allow Encrypt/Decrypt across callers with same LogonId.
// eg: encrypted buffer passed across LPC to another process which calls RtlDecryptMemory whilst impersonating.
//

#define RTL_ENCRYPT_OPTION_SAME_LOGON       0x02

NTSTATUS
RtlEncryptMemory(
    __inout_bcount(MemorySize) PVOID Memory,
    __in ULONG MemorySize,
    __in ULONG OptionFlags
    );

NTSTATUS
RtlDecryptMemory(
    __inout_bcount(MemorySize) PVOID Memory,
    __in ULONG MemorySize,
    __in ULONG OptionFlags
    );
//#endif
    

// Revision of the Kerberos Protocol.  MS uses Version 5, Revision 6

#define KERBEROS_VERSION    5
#define KERBEROS_REVISION   6



// Encryption Types:
// These encryption types are supported by the default MS KERBSUPP DLL
// as crypto systems.  Values over 127 are local values, and may be changed
// without notice.

#define KERB_ETYPE_NULL             0
#define KERB_ETYPE_DES_CBC_CRC      1
#define KERB_ETYPE_DES_CBC_MD4      2
#define KERB_ETYPE_DES_CBC_MD5      3
#define KERB_ETYPE_AES128_CTS_HMAC_SHA1_96    17
#define KERB_ETYPE_AES256_CTS_HMAC_SHA1_96    18


#define KERB_ETYPE_RC4_MD4      