PERTY_DISPLAY_ADAPTER_GUID = 1,                        //Returns the Adapter GUID. 
    KSPROPERTY_PREFERRED_CAPTURE_SURFACE,                       //Returns the memory surface preferred by that pin
    KSPROPERTY_CURRENT_CAPTURE_SURFACE,                         //Sets/Gets currently selected capture surface
    KSPROPERTY_MAP_CAPTURE_HANDLE_TO_VRAM_ADDRESS       //Maps VRAM surface handle to VRAM physical address
} KSPROPERTY_VIDMEM_TRANSPORT;

#define DEFINE_KSPROPERTY_ITEM_DISPLAY_ADAPTER_GUID(GetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_DISPLAY_ADAPTER_GUID,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(GUID),\
        NULL,\
        NULL, 0, NULL, NULL, 0)
#define DEFINE_KSPROPERTY_PREFERRED_CAPTURE_SURFACE(GetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_PREFERRED_CAPTURE_SURFACE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(CAPTURE_MEMORY_ALLOCATION_FLAGS),\
        NULL,\
        NULL, 0, NULL, NULL, 0)
#define DEFINE_KSPROPERTY_CURRENT_CAPTURE_SURFACE(GetHandler, SetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_CURRENT_CAPTURE_SURFACE,\
        (GetHandler),\
        sizeof(KSPROPERTY),\
        sizeof(CAPTURE_MEMORY_ALLOCATION_FLAGS),\
        (SetHandler),\
        NULL, 0, NULL, NULL, 0)
#define DEFINE_KSPROPERTY_MAP_CAPTURE_HANDLE_TO_VRAM_ADDRESS(GetHandler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_MAP_CAPTURE_HANDLE_TO_VRAM_ADDRESS,\
        (GetHandler),\
        sizeof(VRAM_SURFACE_INFO_PROPERTY_S),\
        sizeof(DWORD),\
        NULL,\
        NULL, 0, NULL, NULL, 0)

//
//Surface info passed on to the mini driver. 
//
typedef struct {
    UINT_PTR hSurface;
    LONGLONG VramPhysicalAddress;
    DWORD cbCaptured;
    DWORD dwWidth; 
    DWORD dwHeight;
    DWORD dwLinearSize;
    LONG  lPitch;  
    ULONGLONG ullReserved[16];
} VRAM_SURFACE_INFO, *PVRAM_SURFACE_INFO;

typedef struct {
        KSPROPERTY Property;
        PVRAM_SURFACE_INFO pVramSurfaceInfo;
}VRAM_SURFACE_INFO_PROPERTY_S, *PVRAM_SURFACE_INFO_PROPERTY_S;


#define STATIC_KSPROPSETID_MPEG4_MediaType_Attributes\
    0xff6c4bfa, 0x7a9, 0x4c7b, 0xa2, 0x37, 0x67, 0x2f, 0x9d, 0x68, 0x6, 0x5f
DEFINE_GUIDSTRUCT("FF6C4BFA-07A9-4c7b-A237-672F9D68065F", KSPROPSETID_MPEG4_MediaType_Attributes);
#define KSPROPSETID_MPEG4_MediaType_Attributes DEFINE_GUIDNAMED(KSPROPSETID_MPEG4_MediaType_Attributes)

typedef enum {
    KSPROPERTY_MPEG4_MEDIATYPE_SD_BOX = 1
}KSPROPERTY_MPEG4_MEDIATYPE_ATTRIBUTES;

#define STATIC_KSEVENTSETID_DynamicFormatChange\
    0x162ac456, 0x83d7, 0x4239, 0x96, 0xdf, 0xc7, 0x5f, 0xfa, 0x13, 0x8b, 0xc6
DEFINE_GUIDSTRUCT("162AC456-83D7-4239-96DF-C75FFA138BC6", KSEVENTSETID_DynamicFormatChange);
#define KSEVENTSETID_DynamicFormatChange DEFINE_GUIDNAMED(KSEVENTSETID_DynamicFormatChange)

typedef enum {
	KSEVENT_DYNAMIC_FORMAT_CHANGE = 0
};

//===========================================================================
// KSSTREAM_HEADER extensions for digital video
//===========================================================================

#define KS_VIDEO_FLAG_FIELD_MASK   0x0003L        // Frame or Field (default is frame)
#define KS_VIDEO_FLAG_FRAME        0x0000L        // Frame or Field (default is frame)
#define KS_VIDEO_FLAG_FIELD1       0x0001L
#define KS_VIDEO_FLAG_FIELD2       0x0002L
#define KS_VIDEO_FLAG_FIELD1FIRST  0x0004L
#define KS_VIDEO_FLAG_WEAVE        0x0008L

#define KS_VIDEO_FLAG_IPB_MASK     0x0030L        // I, B, or P (default is I)
#define KS_VIDEO_FLAG_I_FRAME      0x0000L        // I, B, or P (default is I)
#define KS_VIDEO_FLAG_P_FRAME      0x0010L
#define KS_VIDEO_FLAG_B_FRAME      0x0020L
#define KS_VIDEO_FLAG_REPEAT_FIELD 0x0040L


typedef struct tagKS_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;       // Field1, Field2, or Frame
    LONGLONG                PictureNumber;
    LONGLONG                DropCount;

    // The following are only set when using OverlayMixer
    HANDLE                  hDirectDraw;        // user mode DDraw handle
    HANDLE                  hSurfaceHandle;     // user mode surface handle
    RECT                    DirectDrawRect;     // portion of surface locked
    union {
    	LONG                    lSurfacePitch;
  // Contains surface pitch a.k.a stride
        DWORD                   Reserved1;
    };
    // Reserved fields, never reference these
    DWORD                   Reserved2;
    DWORD                   Reserved3;
    DWORD                   Reserved4;
} KS_FRAME_INFO, *PKS_FRAME_INFO;

//===========================================================================
// KSSTREAM_HEADER extensions for VBI
//===========================================================================

#if (NTDDI_VERSION < NTDDI_WINXP)
#define KS_VBI_FLAG_FRAME                0x0000L // Frame or Field (default is frame)
#endif
#define KS_VBI_FLAG_FIELD1               0x0001L
#define KS_VBI_FLAG_FIELD2               0x0002L

#if (NTDDI_VERSION >= NTDDI_WINXP)
#define KS_VBI_FLAG_MV_PRESENT           0x0100L
#define KS_VBI_FLAG_MV_HARDWARE          0x0200L
#define KS_VBI_FLAG_MV_DETECTED          0x0400L
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#define KS_VBI_FLAG_TVTUNER_CHANGE       0x0010L // TvTunerChangeInfo is valid
#define KS_VBI_FLAG_VBIINFOHEADER_CHANGE 0x0020L // VBIInfoHeader is valid

typedef struct tagKS_VBI_FRAME_INFO {
    ULONG                   ExtendedHeaderSize; // Size of this extended header
    DWORD                   dwFrameFlags;  // Field1, Field2, or Frame; & etc
    LONGLONG                PictureNumber; // Test only?
    LONGLONG                DropCount;     // Test only?
    DWORD                   dwSamplingFrequency;
    KS_TVTUNER_CHANGE_INFO  TvTunerChangeInfo;
    KS_VBIINFOHEADER        VBIInfoHeader;
    //
    //The following are for VRAM surface transport to support LDDM Capture
    //
        //VRAM_SURFACE_INFO             VramSurfaceInfo;    
} KS_VBI_FRAME_INFO, *PKS_VBI_FRAME_INFO;


//===========================================================================
// Analog video formats, used with:
//      Analog Video Decoders
//      TVTuners
//      Analog Video Encoders
//
// XXX_STANDARDS_SUPPORTED returns a bitmask
//===========================================================================

typedef enum
{
    KS_AnalogVideo_None     = 0x00000000,  // This is a digital sensor
    KS_AnalogVideo_NTSC_M   = 0x00000001,  //        75 IRE Setup
    KS_AnalogVideo_NTSC_M_J = 0x00000002,  // Japan,  0 IRE Setup
    KS_AnalogVideo_NTSC_433 = 0x00000004,

    KS_AnalogVideo_PAL_B    = 0x00000010,
    KS_AnalogVideo_PAL_D    = 0x00000020,
    KS_AnalogVideo_PAL_G    = 0x00000040,
    KS_AnalogVideo_PAL_H    = 0x00000080,
    KS_AnalogVideo_PAL_I    = 0x00000100,
    KS_AnalogVideo_PAL_M    = 0x00000200,
    KS_AnalogVideo_PAL_N    = 0x00000400,

    KS_AnalogVideo_PAL_60   = 0x00000800,

    KS_AnalogVideo_SECAM_B  = 0x00001000,
    KS_AnalogVideo_SECAM_D  = 0x00002000,
    KS_AnalogVideo_SECAM_G  = 0x00004000,
    KS_AnalogVideo_SECAM_H  = 0x00008000,
    KS_AnalogVideo_SECAM_K  = 0x00010000,
    KS_AnalogVideo_SECAM_K1 = 0x00020000,
    KS_AnalogVideo_SECAM_L  = 0x00040000,
    KS_AnalogVideo_SECAM_L1 = 0x00080000

#if (NTDDI_VERSION >= NTDDI_WINXP)
    , KS_AnalogVideo_PAL_N_COMBO
                            = 0x00100000
#endif // (NTDDI_VERSION >= NTDDI_WINXP)

} KS_AnalogVideoStandard;

#define KS_AnalogVideo_NTSC_Mask  0x00000007
#if (NTDDI_VERSION >= NTDDI_WINXP)
#define KS_AnalogVideo_PAL_Mask   0x00100FF0
#else
#define KS_AnalogVideo_PAL_Mask   0x00000FF0
#endif
#define KS_AnalogVideo_SECAM_Mask 0x000FF000

//===========================================================================
// Property set definitions
// The comments show whether a given property is:
//      R  : READ only
//      w  : WRITE only
//      RW : READ / WRITE
//      O  : Optional (return E_UNSUPPORTED if you don't handle this)
//===========================================================================

#define STATIC_PROPSETID_ALLOCATOR_CONTROL\
    0x53171960, 0x148e, 0x11d2, 0x99, 0x79, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba
DEFINE_GUIDSTRUCT("53171960-148E-11d2-9979-0000C0CC16BA", PROPSETID_ALLOCATOR_CONTROL);
#define PROPSETID_ALLOCATOR_CONTROL DEFINE_GUIDNAMED(PROPSETID_ALLOCATOR_CONTROL)
typedef enum {
    KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,      // R O (will allocate exactly this number of buffers)
    KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE      // R O (return 2 DWORDs specifying surface size)

#if (NTDDI_VERSION >= NTDDI_WINXP)

    // W I (informn a capture driver whether interleave capture is possible or
    //      not - a value of 1 means that interleaved capture is supported)
    , KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS
 
    // R O (if value == 1, then the ovmixer will turn on the DDVP_INTERLEAVE
    //      flag thus allowing interleaved capture of the video)
    , KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

} KSPROPERTY_ALLOCATOR_CONTROL;

#if (NTDDI_VERSION >= NTDDI_WINXP)

typedef struct {
    //KSPROPERTY Property;
    ULONG       CX;
        ULONG   CY;
} KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S, *PKSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE_S; 
 
typedef struct {
    //KSPROPERTY Property;
    ULONG       InterleavedCapSupported;
} KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S, *PKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS_S;

 
typedef struct {
    //KSPROPERTY Property;
    ULONG       InterleavedCapPossible;
} KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S, *PKSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE_S;

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEOPROCAMP\
    0xC6E13360L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13360-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOPROCAMP);
#define PROPSETID_VIDCAP_VIDEOPROCAMP DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOPROCAMP)

typedef enum {
    KSPROPERTY_VIDEOPROCAMP_BRIGHTNESS,                 // RW O
    KSPROPERTY_VIDEOPROCAMP_CONTRAST,                   // RW O
    KSPROPERTY_VIDEOPROCAMP_HUE,                        // RW O
    KSPROPERTY_VIDEOPROCAMP_SATURATION,                 // RW O
    KSPROPERTY_VIDEOPROCAMP_SHARPNESS,                  // RW O
    KSPROPERTY_VIDEOPROCAMP_GAMMA,                      // RW O
    KSPROPERTY_VIDEOPROCAMP_COLORENABLE,                // RW O
    KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE,               // RW O
    KSPROPERTY_VIDEOPROCAMP_BACKLIGHT_COMPENSATION      // RW O

#if (NTDDI_VERSION >= NTDDI_WINXP)

    , KSPROPERTY_VIDEOPROCAMP_GAIN                      // RW O

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

    , KSPROPERTY_VIDEOPROCAMP_DIGITAL_MULTIPLIER        // RW O
    , KSPROPERTY_VIDEOPROCAMP_DIGITAL_MULTIPLIER_LIMIT  // RW O
    , KSPROPERTY_VIDEOPROCAMP_WHITEBALANCE_COMPONENT    // RW O
    , KSPROPERTY_VIDEOPROCAMP_POWERLINE_FREQUENCY       // RW O    

#endif // XP SP2 and later (chronologically)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

} KSPROPERTY_VIDCAP_VIDEOPROCAMP;

typedef struct {
    KSPROPERTY Property;
    LONG   Value;                       // Value to set or get
    ULONG  Flags;                       // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
    ULONG  Capabilities;                // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
} KSPROPERTY_VIDEOPROCAMP_S, *PKSPROPERTY_VIDEOPROCAMP_S;

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

typedef struct {
    KSP_NODE NodeProperty;
    LONG  Value;                        // Value to set or get
    ULONG Flags;                        // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
    ULONG Capabilities;                 // KSPROPERTY_VIDEOPROCAMP_FLAGS_*
} KSPROPERTY_VIDEOPROCAMP_NODE_S, *PKSPROPERTY_VIDEOPROCAMP_NODE_S;

typedef struct {
    KSPROPERTY Property;
    LONG Value1;
    ULONG Flags;
    ULONG Capabilities;
    LONG Value2;
} KSPROPERTY_VIDEOPROCAMP_S2, *PKSPROPERTY_VIDEOPROCAMP_S2;

typedef struct {
    KSP_NODE NodeProperty;
    LONG Value1;
    ULONG Flags;
    ULONG Capabilities;
    LONG Value2;
} KSPROPERTY_VIDEOPROCAMP_NODE_S2, *PKSPROPERTY_VIDEOPROCAMP_NODE_S2;

#endif // XP SP2 and later (chronologically)

#define KSPROPERTY_VIDEOPROCAMP_FLAGS_AUTO        0X0001L
#define KSPROPERTY_VIDEOPROCAMP_FLAGS_MANUAL      0X0002L

//===========================================================================

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

#define STATIC_PROPSETID_VIDCAP_SELECTOR \
    0x1ABDAECA, 0x68B6, 0x4F83, 0x93, 0x71, 0xB4, 0x13, 0x90, 0x7C, 0x7B, 0x9F
DEFINE_GUIDSTRUCT("1ABDAECA-68B6-4F83-9371-B413907C7B9F", PROPSETID_VIDCAP_SELECTOR);
#define PROPSETID_VIDCAP_SELECTOR DEFINE_GUIDNAMED(PROPSETID_VIDCAP_SELECTOR)

typedef enum {
    KSPROPERTY_SELECTOR_SOURCE_NODE_ID,              // RW
    KSPROPERTY_SELECTOR_NUM_SOURCES                  // R
} KSPROPERTY_VIDCAP_SELECTOR, *PKSPROPERTY_VIDCAP_SELECTOR;

typedef struct {
    KSPROPERTY Property;
    LONG  Value;                        // Value to set or get
    ULONG Flags;                        
    ULONG Capabilities;                 
} KSPROPERTY_SELECTOR_S, *PKSPROPERTY_SELECTOR_S;

typedef struct {
    KSP_NODE NodeProperty;
    LONG  Value;                        // Value to set or get
    ULONG Flags;
    ULONG Capabilities;
} KSPROPERTY_SELECTOR_NODE_S, *PKSPROPERTY_SELECTOR_NODE_S;

#endif // XP SP2 and later (chronologically)

//===========================================================================


#define STATIC_PROPSETID_TUNER\
    0x6a2e0605L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0605-28e4-11d0-a18c-00a0c9118956", PROPSETID_TUNER);
#define PROPSETID_TUNER DEFINE_GUIDNAMED(PROPSETID_TUNER)

typedef enum {
    KSPROPERTY_TUNER_CAPS,              // R  -overall device capabilities
    KSPROPERTY_TUNER_MODE_CAPS,         // R  -capabilities in this mode
    KSPROPERTY_TUNER_MODE,              // RW -set a mode (TV, FM, AM, DSS)
    KSPROPERTY_TUNER_STANDARD,          // R  -get TV standard (only if TV mode)
    KSPROPERTY_TUNER_FREQUENCY,         // RW -set/get frequency
    KSPROPERTY_TUNER_INPUT,             // RW -select an input
    KSPROPERTY_TUNER_STATUS,            // R  -tuning status
    KSPROPERTY_TUNER_IF_MEDIUM,         // R O-Medium for IF or Transport Pin
    KSPROPERTY_TUNER_SCAN_CAPS,         // R  -overall device capabilities for scanning
    KSPROPERTY_TUNER_SCAN_STATUS,       // R  -status of scan
    KSPROPERTY_TUNER_STANDARD_MODE,     // RW -autodetect mode for signal standard
    KSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS // R -network type specific tuner capabilities
} KSPROPERTY_TUNER;


//
// Tuning support definitions and interfaces
//

// Definitions

typedef enum {
    KSPROPERTY_TUNER_MODE_TV            = 0X0001,
    KSPROPERTY_TUNER_MODE_FM_RADIO      = 0X0002,
    KSPROPERTY_TUNER_MODE_AM_RADIO      = 0X0004,
    KSPROPERTY_TUNER_MODE_DSS           = 0X0008,
    KSPROPERTY_TUNER_MODE_ATSC          = 0X0010,  // also used for DVB-T, DVB-C
} KSPROPERTY_TUNER_MODES;

// Describes how the device tunes.  Only one of these flags may be set
// in KSPROPERTY_TUNER_MODE_CAPS_S.Strategy

// Describe how the driver should attempt to tune:
// EXACT:   just go to the frequency specified (no fine tuning)
// FINE:    (slow) do an exhaustive search for the best signal
// COARSE:  (fast) use larger frequency jumps to just determine if any signal

typedef enum {
    KS_TUNER_TUNING_EXACT = 1,        // No fine tuning
    KS_TUNER_TUNING_FINE,             // Fine grained search
    KS_TUNER_TUNING_COARSE,           // Coarse search
}KS_TUNER_TUNING_FLAGS;

typedef enum {
    KS_TUNER_STRATEGY_PLL             = 0X01, // Tune by PLL offset
    KS_TUNER_STRATEGY_SIGNAL_STRENGTH = 0X02, // Tune by signal strength
    KS_TUNER_STRATEGY_DRIVER_TUNES    = 0X04, // Driver does fine tuning
}KS_TUNER_STRATEGY;


// Tuning operations

typedef struct {
    KSPROPERTY Property;
    ULONG  ModesSupported;              // KS_PROPERTY_TUNER_MODES_*
    KSPIN_MEDIUM VideoMedium;           // GUID_NULL (no pin), or GUID
    KSPIN_MEDIUM TVAudioMedium;         // GUID_NULL (no pin), or GUID
    KSPIN_MEDIUM RadioAudioMedium;      // GUID_NULL (no pin), or GUID
} KSPROPERTY_TUNER_CAPS_S, *PKSPROPERTY_TUNER_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    KSPIN_MEDIUM IFMedium;              // GUID_NULL (no pin), or GUID
} KSPROPERTY_TUNER_IF_MEDIUM_S, *PKSPROPERTY_TUNER_IF_MEDIUM_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Mode;                        // IN: KSPROPERTY_TUNER_MODE
    ULONG  StandardsSupported;          // KS_AnalogVideo_* (if TV or DSS)
    ULONG  MinFrequency;                // Hz
    ULONG  MaxFrequency;                // Hz
    ULONG  TuningGranularity;           // Hz
    ULONG  NumberOfInputs;              // count of inputs
    ULONG  SettlingTime;                // milliSeconds
    ULONG  Strategy;                    // KS_TUNER_STRATEGY
} KSPROPERTY_TUNER_MODE_CAPS_S, *PKSPROPERTY_TUNER_MODE_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Mode;                        // IN: KSPROPERTY_TUNER_MODE
} KSPROPERTY_TUNER_MODE_S, *PKSPROPERTY_TUNER_MODE_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Frequency;                   // Hz
    ULONG  LastFrequency;               // Hz (last known good)
    ULONG  TuningFlags;                 // KS_TUNER_TUNING_FLAGS
    ULONG  VideoSubChannel;             // DSS
    ULONG  AudioSubChannel;             // DSS
    ULONG  Channel;                     // VBI decoders
    ULONG  Country;                     // VBI decoders
} KSPROPERTY_TUNER_FREQUENCY_S, *PKSPROPERTY_TUNER_FREQUENCY_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  Standard;                    // KS_AnalogVideo_*
} KSPROPERTY_TUNER_STANDARD_S, *PKSPROPERTY_TUNER_STANDARD_S;

typedef struct {
    KSPROPERTY Property;
    BOOL AutoDetect;                 // RW - specifies whether the driver is in auto-detect mode for the signal standard
} KSPROPERTY_TUNER_STANDARD_MODE_S, *PKSPROPERTY_TUNER_STANDARD_MODE_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  InputIndex;                  // 0 to (n-1) inputs
} KSPROPERTY_TUNER_INPUT_S, *PKSPROPERTY_TUNER_INPUT_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  CurrentFrequency;            // Hz
    ULONG  PLLOffset;                   // if Strategy.KS_TUNER_STRATEGY_PLL
    ULONG  SignalStrength;              // if Stretegy.KS_TUNER_STRATEGY_SIGNAL_STRENGTH
    ULONG  Busy;                        // TRUE if in the process of tuning
} KSPROPERTY_TUNER_STATUS_S, *PKSPROPERTY_TUNER_STATUS_S;


//
// Exhaustive Scanning tuner support definitions and interfaces
//

// Definitions

typedef enum _TunerDecoderLockType {
    Tuner_LockType_None                      = 0x00,   // Not locked on a signal. Can be returned at end of scan.
    Tuner_LockType_Within_Scan_Sensing_Range = 0x01,   // Signal is near by, not able to report exact frequency. Can be returned at end of scan.
    Tuner_LockType_Locked                    = 0x02    // Fine tune signal lock established. Can be returned at end of scan.
} TunerLockType;

// Data structures returned for KSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS_S operations

typedef struct {
    ULONG  Mode;                        // IN -KSPROPERTY_TUNER_MODE
    ULONG  StandardsSupported;          // KS_AnalogVideo_* (defined in KS_AnalogVideoStandard)
    ULONG  MinFrequency;                // R -Hz
    ULONG  MaxFrequency;                // R -Hz
    ULONG  TuningGranularity;           // R -Hz
    ULONG  SettlingTime;                // R -milliSeconds
    ULONG  ScanSensingRange;            // R -max range (Hz) in which tuner can detect presence of a signal
    ULONG  FineTuneSensingRange;        // R -max range (Hz) in which tuner can detect actual frequency of a signal
}TUNER_ANALOG_CAPS_S, *PTUNER_ANALOG_CAPS_S;

// ... 
// More to come if new structures are needed for different network types.

#define STATIC_EVENTSETID_TUNER\
    0x6a2e0606L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0606-28e4-11d0-a18c-00a0c9118956", EVENTSETID_TUNER);
#define EVENTSETID_TUNER DEFINE_GUIDNAMED(EVENTSETID_TUNER)

typedef enum {
    KSEVENT_TUNER_CHANGED,
    KSEVENT_TUNER_INITIATE_SCAN    // initiate frequency scan 
} KSEVENT_TUNER;


// Exhaustive Scanning operations

// Determine if ES is possible with device
typedef struct {
    KSPROPERTY Property;
    BOOL fSupportsHardwareAssistedScanning; // R 
    ULONG SupportedBroadcastStandards;      // R 
    PVOID GUIDBucket;                       // RW
    ULONG lengthofBucket;                   // R   
} KSPROPERTY_TUNER_SCAN_CAPS_S, *PKSPROPERTY_TUNER_SCAN_CAPS_S;

// Get specific network type capabilities structure (such as TUNER_ANALOG_CAPS_S for example)
typedef struct {
    KSPROPERTY Property;
    GUID   NetworkType;               // R  -one of the interested GUIDs returned in KSPROPERTY_TUNER_SCAN_CAPS_S 
    ULONG  BufferSize;                // R  -size of the buffer;
    PVOID  NetworkTunerCapabilities;  // RW -Buffer
}KSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS_S, *PKSPROPERTY_TUNER_NETWORKTYPE_SCAN_CAPS_S;

// Obtain current scan operation status
typedef struct {
    KSPROPERTY Property;
    TunerLockType LockStatus; // R -none, within scan sensing range, or locked
    ULONG CurrentFrequency;   // R -current frequency
} KSPROPERTY_TUNER_SCAN_STATUS_S, *PKSPROPERTY_TUNER_SCAN_STATUS_S;

// Start a scan
typedef struct {
    KSEVENTDATA EventData;
    ULONG StartFrequency;          // W -initial frequency for the scan
    ULONG EndFrequency;            // W -final frequency for the scan
} KSEVENT_TUNER_INITIATE_SCAN_S, *PKSEVENT_TUNER_INITIATE_SCAN_S;



//
// Kernel Streaming Video node type definitions
//

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

//===========================================================================
// USB Video Class Definitions

#define STATIC_KSNODETYPE_VIDEO_STREAMING \
    0xDFF229E1L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96 
DEFINE_GUIDSTRUCT("DFF229E1-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_STREAMING);
#define KSNODETYPE_VIDEO_STREAMING DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_STREAMING)

#define STATIC_KSNODETYPE_VIDEO_INPUT_TERMINAL \
    0xDFF229E2L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E2-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_INPUT_TERMINAL);
#define KSNODETYPE_VIDEO_INPUT_TERMINAL DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_INPUT_TERMINAL)

#define STATIC_KSNODETYPE_VIDEO_OUTPUT_TERMINAL \
    0xDFF229E3L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E3-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_OUTPUT_TERMINAL);
#define KSNODETYPE_VIDEO_OUTPUT_TERMINAL DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_OUTPUT_TERMINAL)

#define STATIC_KSNODETYPE_VIDEO_SELECTOR \
    0xDFF229E4L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E4-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_SELECTOR);
#define KSNODETYPE_VIDEO_SELECTOR DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_SELECTOR)

#define STATIC_KSNODETYPE_VIDEO_PROCESSING \
    0xDFF229E5L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E5-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_PROCESSING);
#define KSNODETYPE_VIDEO_PROCESSING DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_PROCESSING)

#define STATIC_KSNODETYPE_VIDEO_CAMERA_TERMINAL \
    0xDFF229E6L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E6-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_CAMERA_TERMINAL);
#define KSNODETYPE_VIDEO_CAMERA_TERMINAL DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_CAMERA_TERMINAL)

#define STATIC_KSNODETYPE_VIDEO_INPUT_MTT \
    0xDFF229E7L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E7-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_INPUT_MTT);
#define KSNODETYPE_VIDEO_INPUT_MTT DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_INPUT_MTT)

#define STATIC_KSNODETYPE_VIDEO_OUTPUT_MTT \
    0xDFF229E8L, 0xF70F, 0x11D0, 0xB9, 0x17, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("DFF229E8-F70F-11D0-B917-00A0C9223196", KSNODETYPE_VIDEO_OUTPUT_MTT);
#define KSNODETYPE_VIDEO_OUTPUT_MTT DEFINE_GUIDNAMED(KSNODETYPE_VIDEO_OUTPUT_MTT)

#endif // XP SP2 and later (chronologically)

//===========================================================================


#define STATIC_PROPSETID_VIDCAP_VIDEOENCODER\
    0x6a2e0610L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0610-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOENCODER);
#define PROPSETID_VIDCAP_VIDEOENCODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOENCODER)

typedef enum {
    KSPROPERTY_VIDEOENCODER_CAPS,                       // R
    KSPROPERTY_VIDEOENCODER_STANDARD,                   // RW
    KSPROPERTY_VIDEOENCODER_COPYPROTECTION,             // RW O
    KSPROPERTY_VIDEOENCODER_CC_ENABLE,                  // RW O
} KSPROPERTY_VIDCAP_VIDEOENCODER;

typedef struct {
    KSPROPERTY Property;
    LONG       Value;                   // value to get or set
    ULONG      Flags;                   //
    ULONG      Capabilities;            //
} KSPROPERTY_VIDEOENCODER_S, *PKSPROPERTY_VIDEOENCODER_S;

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_VIDEODECODER\
    0xC6E13350L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13350-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEODECODER);
#define PROPSETID_VIDCAP_VIDEODECODER DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEODECODER)

typedef enum {
    KSPROPERTY_VIDEODECODER_CAPS,                       // R
    KSPROPERTY_VIDEODECODER_STANDARD,                   // RW
    KSPROPERTY_VIDEODECODER_STATUS,                     // R
    KSPROPERTY_VIDEODECODER_OUTPUT_ENABLE,              // Rw O
    KSPROPERTY_VIDEODECODER_VCR_TIMING,                 // RW O
    KSPROPERTY_VIDEODECODER_STATUS2                     // R
} KSPROPERTY_VIDCAP_VIDEODECODER;

typedef enum {
    KS_VIDEODECODER_FLAGS_CAN_DISABLE_OUTPUT  = 0X0001, // VP Output can tri-stae
    KS_VIDEODECODER_FLAGS_CAN_USE_VCR_LOCKING = 0X0002, // VCR PLL timings
    KS_VIDEODECODER_FLAGS_CAN_INDICATE_LOCKED = 0X0004, // Can indicate valid signal
}KS_VIDEODECODER_FLAGS;

typedef struct {
    KSPROPERTY Property;
    ULONG      StandardsSupported;      // KS_AnalogVideo_*
    ULONG      Capabilities;            // KS_VIDEODECODER_FLAGS_*
    ULONG      SettlingTime;            // milliseconds
    ULONG      HSyncPerVSync;           // Number of HSync Pulses per VSync
} KSPROPERTY_VIDEODECODER_CAPS_S, *PKSPROPERTY_VIDEODECODER_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      NumberOfLines;           // 525 or 625 lines detected
    ULONG      SignalLocked;            // TRUE if signal is locked
} KSPROPERTY_VIDEODECODER_STATUS_S, *PKSPROPERTY_VIDEODECODER_STATUS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      NumberOfLines;       // R - 525 or 625 lines detected
    ULONG      SignalLocked;        // R - TRUE if signal is locked
    ULONG      ChromaLock;          // R - TRUE if a chroma signal is present
} KSPROPERTY_VIDEODECODER_STATUS2_S, *PKSPROPERTY_VIDEODECODER_STATUS2_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      Value;                   // Get or set a value
} KSPROPERTY_VIDEODECODER_S, *PKSPROPERTY_VIDEODECODER_S;

#define STATIC_EVENTSETID_VIDEODECODER\
    0x6a2e0621L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0621-28e4-11d0-a18c-00a0c9118956", EVENTSETID_VIDEODECODER);
#define EVENTSETID_VIDEODECODER DEFINE_GUIDNAMED(EVENTSETID_VIDEODECODER)

typedef enum {
    KSEVENT_VIDEODECODER_CHANGED
} KSEVENT_VIDEODECODER;

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_CAMERACONTROL\
    0xC6E13370L, 0x30AC, 0x11d0, 0xa1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13370-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_CAMERACONTROL);
#define PROPSETID_VIDCAP_CAMERACONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CAMERACONTROL)

typedef enum {
    KSPROPERTY_CAMERACONTROL_PAN,                       // RW O
    KSPROPERTY_CAMERACONTROL_TILT,                      // RW O
    KSPROPERTY_CAMERACONTROL_ROLL,                      // RW O
    KSPROPERTY_CAMERACONTROL_ZOOM,                      // RW O
    KSPROPERTY_CAMERACONTROL_EXPOSURE,                  // RW O
    KSPROPERTY_CAMERACONTROL_IRIS,                      // RW O
    KSPROPERTY_CAMERACONTROL_FOCUS                      // RW O

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

    , KSPROPERTY_CAMERACONTROL_SCANMODE                 // RW O
    , KSPROPERTY_CAMERACONTROL_PRIVACY                  // RW O
    , KSPROPERTY_CAMERACONTROL_PANTILT                  // RW O
    , KSPROPERTY_CAMERACONTROL_PAN_RELATIVE             // RW O
    , KSPROPERTY_CAMERACONTROL_TILT_RELATIVE            // RW O
    , KSPROPERTY_CAMERACONTROL_ROLL_RELATIVE            // RW O
    , KSPROPERTY_CAMERACONTROL_ZOOM_RELATIVE            // RW O
    , KSPROPERTY_CAMERACONTROL_EXPOSURE_RELATIVE        // RW O
    , KSPROPERTY_CAMERACONTROL_IRIS_RELATIVE            // RW O
    , KSPROPERTY_CAMERACONTROL_FOCUS_RELATIVE           // RW O
    , KSPROPERTY_CAMERACONTROL_PANTILT_RELATIVE         // RW O
    , KSPROPERTY_CAMERACONTROL_FOCAL_LENGTH             // R  O    
    , KSPROPERTY_CAMERACONTROL_AUTO_EXPOSURE_PRIORITY   // RW O

#endif // XP SP2 and later (chronologically)

} KSPROPERTY_VIDCAP_CAMERACONTROL;

typedef struct {
    KSPROPERTY Property;
    LONG       Value;                   // value to get or set
    ULONG      Flags;                   // KSPROPERTY_CAMERACONTROL_FLAGS_*
    ULONG      Capabilities;            // KSPROPERTY_CAMERACONTROL_FLAGS_*
} KSPROPERTY_CAMERACONTROL_S, *PKSPROPERTY_CAMERACONTROL_S;

#define KSPROPERTY_CAMERACONTROL_FLAGS_AUTO        0X0001L
#define KSPROPERTY_CAMERACONTROL_FLAGS_MANUAL      0X0002L

#define KSPROPERTY_CAMERACONTROL_FLAGS_ABSOLUTE    0X0000L
#define KSPROPERTY_CAMERACONTROL_FLAGS_RELATIVE    0X0010L

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

typedef struct {
    KSP_NODE NodeProperty;
    LONG  Value;                        // value to get or set
    ULONG Flags;                        // KSPROPERTY_CAMERACONTROL_FLAGS_*
    ULONG Capabilities;                 // KSPROPERTY_CAMERACONTROL_FLAGS_*
} KSPROPERTY_CAMERACONTROL_NODE_S, PKSPROPERTY_CAMERACONTROL_NODE_S;

typedef struct {
    KSPROPERTY Property;
    LONG Value1;
    ULONG Flags;
    ULONG Capabilities;
    LONG Value2;
} KSPROPERTY_CAMERACONTROL_S2, *PKSPROPERTY_CAMERACONTROL_S2;

typedef struct {
    KSP_NODE NodeProperty;
    LONG Value1;
    ULONG Flags;
    ULONG Capabilities;
    LONG Value2;
} KSPROPERTY_CAMERACONTROL_NODE_S2, *PKSPROPERTY_CAMERACONTROL_NODE_S2;

typedef struct {
    KSPROPERTY Property;
    LONG lOcularFocalLength;
    LONG lObjectiveFocalLengthMin;
    LONG lObjectiveFocalLengthMax;
} KSPROPERTY_CAMERACONTROL_FOCAL_LENGTH_S, *PKSPROPERTY_CAMERACONTROL_FOCAL_LENGTH_S;

typedef struct {
    KSNODEPROPERTY NodeProperty;
    LONG lOcularFocalLength;
    LONG lObjectiveFocalLengthMin;
    LONG lObjectiveFocalLengthMax;
} KSPROPERTY_CAMERACONTROL_NODE_FOCAL_LENGTH_S, *PKSPROPERTY_CAMERACONTROL_NODE_FOCAL_LENGTH_S;

#ifndef __EDevCtrl__
#define __EDevCtrl__
//===========================================================================

#define STATIC_PROPSETID_EXT_DEVICE\
    0xB5730A90L, 0x1A2C, 0x11cf, 0x8c, 0x23, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("B5730A90-1A2C-11cf-8C23-00AA006B6814", PROPSETID_EXT_DEVICE);
#define PROPSETID_EXT_DEVICE DEFINE_GUIDNAMED(PROPSETID_EXT_DEVICE)

typedef enum {
    KSPROPERTY_EXTDEVICE_ID,                // R
    KSPROPERTY_EXTDEVICE_VERSION,           // R
    KSPROPERTY_EXTDEVICE_POWER_STATE,       // RW
    KSPROPERTY_EXTDEVICE_PORT,              // R
    KSPROPERTY_EXTDEVICE_CAPABILITIES       // R
} KSPROPERTY_EXTDEVICE;

typedef struct tagDEVCAPS{
    LONG CanRecord;
    LONG CanRecordStrobe;
    LONG HasAudio;
    LONG HasVideo;
    LONG UsesFiles;
    LONG CanSave;
    LONG DeviceType;
    LONG TCRead;
    LONG TCWrite;
    LONG CTLRead;
    LONG IndexRead;
    LONG Preroll;
    LONG Postroll;
    LONG SyncAcc;
    LONG NormRate;
    LONG CanPreview;
    LONG CanMonitorSrc;
    LONG CanTest;
    LONG VideoIn;
    LONG AudioIn;
    LONG Calibrate;
    LONG SeekType;
    LONG SimulatedHardware;        
} DEVCAPS, *PDEVCAPS;

typedef struct {
    KSPROPERTY Property;
    union {
        DEVCAPS  Capabilities;          // Device capabilities
        ULONG    DevPort;               // 1394, USB, etc.
        ULONG    PowerState;            // On, standby or off
        WCHAR    pawchString[MAX_PATH]; // Version
        DWORD    NodeUniqueID[2];       // Unique NodeID
    } u;
} KSPROPERTY_EXTDEVICE_S, *PKSPROPERTY_EXTDEVICE_S;

//===========================================================================

#define STATIC_PROPSETID_EXT_TRANSPORT\
    0xA03CD5F0L, 0x3045, 0x11cf, 0x8c, 0x44, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("A03CD5F0-3045-11cf-8C44-00AA006B6814", PROPSETID_EXT_TRANSPORT);
#define PROPSETID_EXT_TRANSPORT DEFINE_GUIDNAMED(PROPSETID_EXT_TRANSPORT)

typedef enum {
    KSPROPERTY_EXTXPORT_CAPABILITIES,       // (R)  Transport specific capability 
    KSPROPERTY_EXTXPORT_INPUT_SIGNAL_MODE,  // (RW) Input signal: e.g. dvsd/NTSC/PAL, dvsl/NTSC/PAL, MPEG2-TS etc
    KSPROPERTY_EXTXPORT_OUTPUT_SIGNAL_MODE, // (RW) Output signal: e.g. dvsd/NTSC/PAL, dvsl/NTSC/PAL, MPEG2-TS etc
    KSPROPERTY_EXTXPORT_LOAD_MEDIUM,        // (RW) Eject, open tray, close tray
    KSPROPERTY_EXTXPORT_MEDIUM_INFO,        // (R)  Cassettte type, tape grade and write protection
    KSPROPERTY_EXTXPORT_STATE,              // (RW) Current transport mode and state
    KSPROPERTY_EXTXPORT_STATE_NOTIFY,       // (RW) Notify of transport mode and state change
    KSPROPERTY_EXTXPORT_TIMECODE_SEARCH,    // (W)  Search to a specific timecode on a tape
    KSPROPERTY_EXTXPORT_ATN_SEARCH,         // (W)  Search to a specific absolute track number (ATN) on a tape
    KSPROPERTY_EXTXPORT_RTC_SEARCH,         // (W)  Search to a specific relative time counter (RTC) on a tape
    KSPROPERTY_RAW_AVC_CMD                  // (RW) Issue a raw AVC commnad
} KSPROPERTY_EXTXPORT;

typedef struct tagTRANSPORTSTATUS{
    LONG Mode;
    LONG LastError;
    LONG RecordInhibit;
    LONG ServoLock;
    LONG MediaPresent;
    LONG MediaLength;
    LONG MediaSize;
    LONG MediaTrackCount;
    LONG MediaTrackLength;
    LONG MediaTrackSide;
    LONG MediaType;
    LONG LinkMode;
    LONG NotifyOn;
} TRANSPORTSTATUS, *PTRANSPORTSTATUS;

typedef struct tagTRANSPORTBASICPARMS{
    LONG TimeFormat;
    LONG TimeReference;
    LONG Superimpose;
    LONG EndStopAction;
    LONG RecordFormat;
    LONG StepFrames;
    LONG SetpField;
    LONG Preroll;
    LONG RecPreroll;
    LONG Postroll;
    LONG EditDelay;
    LONG PlayTCDelay;
    LONG RecTCDelay;
    LONG EditField;
    LONG FrameServo;
    LONG ColorFrameServo;
    LONG ServoRef;
    LONG WarnGenlock;
    LONG SetTracking;
    TCHAR VolumeName[40];
    LONG Ballistic[20];
    LONG Speed;
    LONG CounterFormat;
    LONG TunerChannel;
    LONG TunerNumber;
    LONG TimerEvent;
    LONG TimerStartDay;
    LONG TimerStartTime;
    LONG TimerStopDay;
    LONG TimerStopTime;
} TRANSPORTBASICPARMS, *PTRANSPORTBASICPARMS;

typedef struct tagTRANSPORTVIDEOPARMS{
    LONG OutputMode;
    LONG Input;
} TRANSPORTVIDEOPARMS, *PTRANSPORTVIDEOPARMS;

typedef struct tagTRANSPORTAUDIOPARMS{
    LONG EnableOutput;
    LONG EnableRecord;
    LONG EnableSelsync;
    LONG Input;
    LONG MonitorSource;
} TRANSPORTAUDIOPARMS, *PTRANSPORTAUDIOPARMS;

typedef struct {
    BOOL  MediaPresent;      
    ULONG MediaType;         
    BOOL  RecordInhibit;    
} MEDIUM_INFO, *PMEDIUM_INFO;

typedef struct {
    ULONG Mode;              
    ULONG State;
} TRANSPORT_STATE, *PTRANSPORT_STATE;

typedef struct {
    KSPROPERTY Property;
    union {    
        ULONG      Capabilities;
        ULONG      SignalMode;
        ULONG      LoadMedium;
        MEDIUM_INFO MediumInfo;
        TRANSPORT_STATE XPrtState;
        struct {
          BYTE frame;        
          BYTE second;
          BYTE minute;
          BYTE hour;
        } Timecode;
        DWORD dwTimecode;            
        DWORD dwAbsTrackNumber;      
        struct {
            ULONG   PayloadSize;
            BYTE    Payload[512];  
        } RawAVC;                    
    } u;
     
} KSPROPERTY_EXTXPORT_S, *PKSPROPERTY_EXTXPORT_S;

typedef struct {
    KSP_NODE NodeProperty;
    union {    
        ULONG      Capabilities;
        ULONG      SignalMode;
        ULONG      LoadMedium;
        MEDIUM_INFO MediumInfo;
        TRANSPORT_STATE XPrtState;
        struct {
          BYTE frame;        
          BYTE second;
          BYTE minute;
          BYTE hour;
        } Timecode;
        DWORD dwTimecode;            
        DWORD dwAbsTrackNumber;      
        struct {
            ULONG   PayloadSize;
            BYTE    Payload[512];  
        } RawAVC;                    
    } u;
     
} KSPROPERTY_EXTXPORT_NODE_S, *PKSPROPERTY_EXTXPORT_NODE_S;

//===========================================================================

#define STATIC_PROPSETID_TIMECODE_READER\
    0x9B496CE1L, 0x811B, 0x11cf, 0x8C, 0x77, 0x00, 0xAA, 0x00, 0x6B, 0x68, 0x14
DEFINE_GUIDSTRUCT("9B496CE1-811B-11cf-8C77-00AA006B6814", PROPSETID_TIMECODE_READER);
#define PROPSETID_TIMECODE_READER DEFINE_GUIDNAMED(PROPSETID_TIMECODE_READER)

typedef enum {
    KSPROPERTY_TIMECODE_READER,  // (R) Timecode for the current tape position
    KSPROPERTY_ATN_READER,       // (R) Absolute track number for the current tape position
    KSPROPERTY_RTC_READER        // (R) Relative time counter for the current tape position
} KSPROPERTY_TIMECODE;

#ifndef TIMECODE_DEFINED
#define TIMECODE_DEFINED
typedef union _timecode {
    struct {
        WORD   wFrameRate;
        WORD   wFrameFract;
        DWORD  dwFrames;
        };
    DWORDLONG  qw;
} TIMECODE;
typedef TIMECODE *PTIMECODE;

typedef struct tagTIMECODE_SAMPLE {
    LONGLONG qwTick;
    TIMECODE timecode;
    DWORD dwUser;
    DWORD dwFlags;
} TIMECODE_SAMPLE;

typedef TIMECODE_SAMPLE *PTIMECODE_SAMPLE;

#endif /* TIMECODE_DEFINED */

typedef struct {
    KSPROPERTY Property;
    TIMECODE_SAMPLE TimecodeSamp;
} KSPROPERTY_TIMECODE_S, *PKSPROPERTY_TIMECODE_S;

typedef struct {
    KSP_NODE NodeProperty;
    TIMECODE_SAMPLE TimecodeSamp;
} KSPROPERTY_TIMECODE_NODE_S, *PKSPROPERTY_TIMECODE_NODE_S;

//===========================================================================

#define STATIC_KSEVENTSETID_EXTDEV_Command\
    0x109c7988L, 0xb3cb, 0x11d2, 0xb4, 0x8e, 0x00, 0x60, 0x97, 0xb3, 0x39, 0x1b
DEFINE_GUIDSTRUCT("109c7988-b3cb-11d2-b48e-006097b3391b", KSEVENTSETID_EXTDEV_Command);
#define KSEVENTSETID_EXTDEV_Command DEFINE_GUIDNAMED(KSEVENTSETID_EXTDEV_Command)

typedef enum {
    KSEVENT_EXTDEV_COMMAND_NOTIFY_INTERIM_READY,     // Final response is ready for notify command 
    KSEVENT_EXTDEV_COMMAND_CONTROL_INTERIM_READY,    // Final response is ready for control command.
    KSEVENT_EXTDEV_COMMAND_BUSRESET,                 // A bus reset has occured.
    KSEVENT_EXTDEV_TIMECODE_UPDATE,                  // Timecode has changed.
    KSEVENT_EXTDEV_OPERATION_MODE_UPDATE,            // Operting mode (VCR,Camera, etc.) has changed.
    KSEVENT_EXTDEV_TRANSPORT_STATE_UPDATE,           // Transport state has changed.
    KSEVENT_EXTDEV_NOTIFY_REMOVAL,                   // Device was surprise removal.
    KSEVENT_EXTDEV_NOTIFY_MEDIUM_CHANGE              // Tape medium is removed or added.
} KSEVENT_DEVCMD;

#endif // __EDevCtrl__

#endif // XP SP2 and later (chronologically)

//===========================================================================

#define STATIC_PROPSETID_VIDCAP_CROSSBAR\
    0x6a2e0640L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0640-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_CROSSBAR);
#define PROPSETID_VIDCAP_CROSSBAR DEFINE_GUIDNAMED(PROPSETID_VIDCAP_CROSSBAR)

typedef enum {
    KSPROPERTY_CROSSBAR_CAPS,                     // R
    KSPROPERTY_CROSSBAR_PININFO,                  // R
    KSPROPERTY_CROSSBAR_CAN_ROUTE,                // R
    KSPROPERTY_CROSSBAR_ROUTE,                    // RW
    KSPROPERTY_CROSSBAR_INPUT_ACTIVE              // R
} KSPROPERTY_VIDCAP_CROSSBAR;

typedef struct {
    KSPROPERTY Property;
    ULONG  NumberOfInputs;      // the number of audio and video input pins
    ULONG  NumberOfOutputs;     // the number of audio and video output pins
} KSPROPERTY_CROSSBAR_CAPS_S, *PKSPROPERTY_CROSSBAR_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    KSPIN_DATAFLOW Direction;     // KSPIN_DATAFLOW_IN or KSPIN_DATAFLOW_OUT?
    ULONG  Index;                 // Which pin to return data for?
    ULONG  PinType;               // KS_PhysConn_Video_* or KS_PhysConn_Audio_*
    ULONG  RelatedPinIndex;       // For video pins, this is the related audio pin
    KSPIN_MEDIUM  Medium;         // Identifies the hardware connection
} KSPROPERTY_CROSSBAR_PININFO_S, *PKSPROPERTY_CROSSBAR_PININFO_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  IndexInputPin;        // Zero based index of the input pin
    ULONG  IndexOutputPin;       // Zero based index of the output pin
    ULONG  CanRoute;             // returns non-zero on CAN_ROUTE if routing is possible
} KSPROPERTY_CROSSBAR_ROUTE_S, *PKSPROPERTY_CROSSBAR_ROUTE_S;

typedef struct {
    KSPROPERTY Property;
    ULONG  IndexInputPin;        // W - Zero based index of the input pin
    ULONG  Active;               // R - returns whether an active signal is present on the given input
} KSPROPERTY_CROSSBAR_ACTIVE_S, *PKSPROPERTY_CROSSBAR_ACTIVE_S;

#define STATIC_EVENTSETID_CROSSBAR\
    0x6a2e0641L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0641-28e4-11d0-a18c-00a0c9118956", EVENTSETID_CROSSBAR);
#define EVENTSETID_CROSSBAR DEFINE_GUIDNAMED(EVENTSETID_CROSSBAR)

typedef enum {
    KSEVENT_CROSSBAR_CHANGED
} KSEVENT_CROSSBAR;

// The following IDs should match the AM equivalents
typedef enum {
    KS_PhysConn_Video_Tuner = 1,
    KS_PhysConn_Video_Composite,
    KS_PhysConn_Video_SVideo,
    KS_PhysConn_Video_RGB,
    KS_PhysConn_Video_YRYBY,
    KS_PhysConn_Video_SerialDigital,
    KS_PhysConn_Video_ParallelDigital,
    KS_PhysConn_Video_SCSI,
    KS_PhysConn_Video_AUX,
    KS_PhysConn_Video_1394,
    KS_PhysConn_Video_USB,
    KS_PhysConn_Video_VideoDecoder,
    KS_PhysConn_Video_VideoEncoder,
    KS_PhysConn_Video_SCART,

    KS_PhysConn_Audio_Tuner = 4096,
    KS_PhysConn_Audio_Line,
    KS_PhysConn_Audio_Mic,
    KS_PhysConn_Audio_AESDigital,
    KS_PhysConn_Audio_SPDIFDigital,
    KS_PhysConn_Audio_SCSI,
    KS_PhysConn_Audio_AUX,
    KS_PhysConn_Audio_1394,
    KS_PhysConn_Audio_USB,
    KS_PhysConn_Audio_AudioDecoder
} KS_PhysicalConnectorType;


//===========================================================================

#define STATIC_PROPSETID_VIDCAP_TVAUDIO\
    0x6a2e0650L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0650-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_TVAUDIO);
#define PROPSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(PROPSETID_VIDCAP_TVAUDIO)

typedef enum {
    KSPROPERTY_TVAUDIO_CAPS,                            // R
    KSPROPERTY_TVAUDIO_MODE,                            // RW
    KSPROPERTY_TVAUDIO_CURRENTLY_AVAILABLE_MODES        // R
} KSPROPERTY_VIDCAP_TVAUDIO;

#define KS_TVAUDIO_MODE_MONO           0x0001          // Mono
#define KS_TVAUDIO_MODE_STEREO         0x0002          // Stereo
#define KS_TVAUDIO_MODE_LANG_A         0x0010          // Primary language
#define KS_TVAUDIO_MODE_LANG_B         0x0020          // 2nd avail language
#define KS_TVAUDIO_MODE_LANG_C         0x0040          // 3rd avail language
#if (NTDDI_VERSION >= NTDDI_VISTA)
#define KS_TVAUDIO_PRESET_STEREO       0x0200          // if present, stereo
#define KS_TVAUDIO_PRESET_LANG_A       0x1000          // if present, Language A
#define KS_TVAUDIO_PRESET_LANG_B       0x2000          // if present, Language B
#define KS_TVAUDIO_PRESET_LANG_C       0x4000          // if present, Language C
#endif // (NTDDI_VERSION >= NTDDI_VISTA

typedef struct {
    KSPROPERTY Property;
    ULONG      Capabilities;             // Bitmask of KS_TVAUDIO_MODE_*
    KSPIN_MEDIUM InputMedium;
    KSPIN_MEDIUM OutputMedium;
} KSPROPERTY_TVAUDIO_CAPS_S, *PKSPROPERTY_TVAUDIO_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      Mode;                     // KS_TVAUDIO_MODE_*
} KSPROPERTY_TVAUDIO_S, *PKSPROPERTY_TVAUDIO_S;


#define STATIC_KSEVENTSETID_VIDCAP_TVAUDIO\
    0x6a2e0651L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0651-28e4-11d0-a18c-00a0c9118956", KSEVENTSETID_VIDCAP_TVAUDIO);
#define KSEVENTSETID_VIDCAP_TVAUDIO DEFINE_GUIDNAMED(KSEVENTSETID_VIDCAP_TVAUDIO)

typedef enum {
    KSEVENT_TVAUDIO_CHANGED,
} KSEVENT_TVAUDIO;

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_VIDEOCOMPRESSION\
    0xC6E13343L, 0x30AC, 0x11d0, 0xA1, 0x8C, 0x00, 0xA0, 0xC9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13343-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_VIDEOCOMPRESSION);
#define PROPSETID_VIDCAP_VIDEOCOMPRESSION DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCOMPRESSION)

typedef enum {
    KSPROPERTY_VIDEOCOMPRESSION_GETINFO,              // R
    KSPROPERTY_VIDEOCOMPRESSION_KEYFRAME_RATE,        // RW
    KSPROPERTY_VIDEOCOMPRESSION_PFRAMES_PER_KEYFRAME, // RW
    KSPROPERTY_VIDEOCOMPRESSION_QUALITY,              // RW
    KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_KEYFRAME,    // W
    KSPROPERTY_VIDEOCOMPRESSION_OVERRIDE_FRAME_SIZE,  // W
    KSPROPERTY_VIDEOCOMPRESSION_WINDOWSIZE            // RW
} KSPROPERTY_VIDCAP_VIDEOCOMPRESSION;

typedef enum {
    KS_CompressionCaps_CanQuality = 1,
    KS_CompressionCaps_CanCrunch = 2,
    KS_CompressionCaps_CanKeyFrame = 4,
    KS_CompressionCaps_CanBFrame = 8,
    KS_CompressionCaps_CanWindow = 0x10
} KS_CompressionCaps;

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

typedef enum {
    KS_StreamingHint_FrameInterval = 0x0100,
    KS_StreamingHint_KeyFrameRate = 0x0200,
    KS_StreamingHint_PFrameRate = 0x0400,
    KS_StreamingHint_CompQuality = 0x0800,
    KS_StreamingHint_CompWindowSize = 0x1000
} KS_VideoStreamingHints;

#endif // XP SP2 and later (chronologically)

typedef struct {
    KSPROPERTY Property;
    // Note, no VersionString!
    // Note, no DescriptionString!
    ULONG      StreamIndex;             // zero based index of stream
    LONG       DefaultKeyFrameRate;     // Key frame rate
    LONG       DefaultPFrameRate;       // Predeicted frames per Key frame
    LONG       DefaultQuality;          // 0 to 10000
    LONG       NumberOfQualitySettings; // How many discreet quality settings?
    LONG       Capabilities;            // KS_CompressionCaps_*
} KSPROPERTY_VIDEOCOMPRESSION_GETINFO_S, *PKSPROPERTY_VIDEOCOMPRESSION_GETINFO_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;             // zero based index of stream
    LONG       Value;                   // value to get or set
} KSPROPERTY_VIDEOCOMPRESSION_S, *PKSPROPERTY_VIDEOCOMPRESSION_S;

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

typedef struct {
    KSPROPERTY  Property;
    ULONG       StreamIndex;             // zero based index of stream
    LONG        Value;                   // value to get or set
    ULONG       Flags;
} KSPROPERTY_VIDEOCOMPRESSION_S1, *PKSPROPERTY_VIDEOCOMPRESSION_S1;

#endif // XP SP2 and later (chronologically)

//===========================================================================
// MEDIASUBTYPE_Overlay
#define STATIC_KSDATAFORMAT_SUBTYPE_OVERLAY\
    0xe436eb7fL, 0x524f, 0x11ce, 0x9f, 0x53, 0x00, 0x20, 0xaf, 0x0b, 0xa7, 0x70
DEFINE_GUIDSTRUCT("e436eb7f-524f-11ce-9f53-0020af0ba770", KSDATAFORMAT_SUBTYPE_OVERLAY);
#define KSDATAFORMAT_SUBTYPE_OVERLAY DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_OVERLAY)

#define STATIC_KSPROPSETID_OverlayUpdate\
    0x490EA5CFL, 0x7681, 0x11D1, 0xA2, 0x1C, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
DEFINE_GUIDSTRUCT("490EA5CF-7681-11D1-A21C-00A0C9223196", KSPROPSETID_OverlayUpdate);
#define KSPROPSETID_OverlayUpdate DEFINE_GUIDNAMED(KSPROPSETID_OverlayUpdate)

typedef enum {
    KSPROPERTY_OVERLAYUPDATE_INTERESTS,
    KSPROPERTY_OVERLAYUPDATE_CLIPLIST = 0x1,
    KSPROPERTY_OVERLAYUPDATE_PALETTE = 0x2,
    KSPROPERTY_OVERLAYUPDATE_COLORKEY = 0x4,
    KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION = 0x8,
    KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE = 0x10,
    KSPROPERTY_OVERLAYUPDATE_COLORREF = 0x10000000
} KSPROPERTY_OVERLAYUPDATE;

typedef struct {
    ULONG   PelsWidth;
    ULONG   PelsHeight;
    ULONG   BitsPerPel;
    WCHAR   DeviceID[1];
} KSDISPLAYCHANGE, *PKSDISPLAYCHANGE;

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_INTERESTS(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_INTERESTS,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(ULONG),\
        NULL, NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_PALETTE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_PALETTE,\
        NULL,\
        sizeof(KSPROPERTY),\
        0,\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORKEY(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_COLORKEY,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(COLORKEY),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_CLIPLIST(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_CLIPLIST,\
        NULL,\
        sizeof(KSPROPERTY),\
        2 * sizeof(RECT) + sizeof(RGNDATAHEADER),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_VIDEOPOSITION(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_VIDEOPOSITION,\
        NULL,\
        sizeof(KSPROPERTY),\
        2 * sizeof(RECT),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_DISPLAYCHANGE(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_DISPLAYCHANGE,\
        NULL,\
        sizeof(KSPROPERTY),\
        sizeof(KSDISPLAYCHANGE),\
        (Handler),\
        NULL, 0, NULL, NULL, 0)

#define DEFINE_KSPROPERTY_ITEM_OVERLAYUPDATE_COLORREF(Handler)\
    DEFINE_KSPROPERTY_ITEM(\
        KSPROPERTY_OVERLAYUPDATE_COLORREF,\
        (Handler),\
        sizeof(KSPROPERTY),\
        sizeof(COLORREF),\
        NULL,\
        NULL, 0, NULL, NULL, 0)

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_VIDEOCONTROL\
    0x6a2e0670L, 0x28e4, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("6a2e0670-28e4-11d0-a18c-00a0c9118956", PROPSETID_VIDCAP_VIDEOCONTROL);
#define PROPSETID_VIDCAP_VIDEOCONTROL DEFINE_GUIDNAMED(PROPSETID_VIDCAP_VIDEOCONTROL)

typedef enum {
    KSPROPERTY_VIDEOCONTROL_CAPS,               // R
    KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE,  // R O
    KSPROPERTY_VIDEOCONTROL_FRAME_RATES,        // R O
    KSPROPERTY_VIDEOCONTROL_MODE                // RWO
} KSPROPERTY_VIDCAP_VIDEOCONTROL;

typedef enum {
    KS_VideoControlFlag_FlipHorizontal        = 0x0001,
    KS_VideoControlFlag_FlipVertical          = 0x0002,
    KS_Obsolete_VideoControlFlag_ExternalTriggerEnable = 0x0010,    // ***WARNING *** Flag msimatch with DSHOW.
    KS_Obsolete_VideoControlFlag_Trigger               = 0x0020,  // ***WARNING *** Flag msimatch with DSHOW.
    KS_VideoControlFlag_ExternalTriggerEnable = 0x0004,
    KS_VideoControlFlag_Trigger                      = 0x0008
} KS_VideoControlFlags;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;
    ULONG      VideoControlCaps;                // KS_VideoControlFlags_*
} KSPROPERTY_VIDEOCONTROL_CAPS_S, *PKSPROPERTY_VIDEOCONTROL_CAPS_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;
    LONG       Mode;                            // KS_VideoControlFlags_*
} KSPROPERTY_VIDEOCONTROL_MODE_S, *PKSPROPERTY_VIDEOCONTROL_MODE_S;

typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      RangeIndex;                      // Index of range
    SIZE       Dimensions;                      // Size of image
    LONGLONG   CurrentActualFrameRate;          // Only correct if pin is open
    LONGLONG   CurrentMaxAvailableFrameRate;    // Max Rate temporarily limited on USB or 1394?
} KSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S, *PKSPROPERTY_VIDEOCONTROL_ACTUAL_FRAME_RATE_S;

// KSPROPERTY_VIDEOCONTROL_FRAME_RATES returns a list of available frame rates in 100 nS units
typedef struct {
    KSPROPERTY Property;
    ULONG      StreamIndex;                     // Index of stream
    ULONG      RangeIndex;                      // Index of range
    SIZE       Dimensions;                      // Size of image
} KSPROPERTY_VIDEOCONTROL_FRAME_RATES_S, *PKSPROPERTY_VIDEOCONTROL_FRAME_RATES_S;

//===========================================================================
#define STATIC_PROPSETID_VIDCAP_DROPPEDFRAMES\
    0xC6E13344L, 0x30AC, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0xc9, 0x11, 0x89, 0x56
DEFINE_GUIDSTRUCT("C6E13344-30AC-11d0-A18C-00A0C9118956", PROPSETID_VIDCAP_DROPPEDFRAMES);
#define PROPSETID_VIDCAP_DROPPEDFRAMES DEFINE_GUIDNAMED(PROPSETID_VIDCAP_DROPPEDFRAMES)

typedef enum {
    KSPROPERTY_DROPPEDFRAMES_CURRENT            // R
} KSPROPERTY_VIDCAP_DROPPEDFRAMES;

typedef struct {
    KSPROPERTY Property;
    LONGLONG   PictureNumber;                   // Current Picture Number
    LONGLONG   DropCount;                       // Count of frames dropped
    ULONG      AverageFrameSize;                // Average size of frames captured
} KSPROPERTY_DROPPEDFRAMES_CURRENT_S, *PKSPROPERTY_DROPPEDFRAMES_CURRENT_S;

//===========================================================================
// VPE

#define STATIC_KSPROPSETID_VPConfig\
    0xbc29a660L, 0x30e3, 0x11d0, 0x9e, 0x69, 0x00, 0xc0, 0x4f, 0xd7, 0xc1, 0x5b
DEFINE_GUIDSTRUCT("bc29a660-30e3-11d0-9e69-00c04fd7c15b", KSPROPSETID_VPConfig);
#define KSPROPSETID_VPConfig DEFINE_GUIDNAMED(KSPROPSETID_VPConfig)

#define STATIC_KSPROPSETID_VPVBIConfig\
    0xec529b00L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("ec529b00-1a1f-11d1-bad9-00609744111a", KSPROPSETID_VPVBIConfig);
#define KSPROPSETID_VPVBIConfig DEFINE_GUIDNAMED(KSPROPSETID_VPVBIConfig)

// Both of the above property sets use the same list of properties below

typedef enum {
    KSPROPERTY_VPCONFIG_NUMCONNECTINFO,
    KSPROPERTY_VPCONFIG_GETCONNECTINFO,
    KSPROPERTY_VPCONFIG_SETCONNECTINFO,
    KSPROPERTY_VPCONFIG_VPDATAINFO,
    KSPROPERTY_VPCONFIG_MAXPIXELRATE,
    KSPROPERTY_VPCONFIG_INFORMVPINPUT,
    KSPROPERTY_VPCONFIG_NUMVIDEOFORMAT,
    KSPROPERTY_VPCONFIG_GETVIDEOFORMAT,
    KSPROPERTY_VPCONFIG_SETVIDEOFORMAT,
    KSPROPERTY_VPCONFIG_INVERTPOLARITY,
    KSPROPERTY_VPCONFIG_DECIMATIONCAPABILITY,   // E_NOTIMPL for VBI
    KSPROPERTY_VPCONFIG_SCALEFACTOR,            // E_NOTIMPL for VBI
    KSPROPERTY_VPCONFIG_DDRAWHANDLE,
    KSPROPERTY_VPCONFIG_VIDEOPORTID,
    KSPROPERTY_VPCONFIG_DDRAWSURFACEHANDLE,
    KSPROPERTY_VPCONFIG_SURFACEPARAMS
} KSPROPERTY_VPCONFIG;

#if (NTDDI_VERSION >= NTDDI_WINXP)
//=========================
// IBasicAudio
//
#define STATIC_CLSID_KsIBasicAudioInterfaceHandler\
    0xb9f8ac3e, 0x0f71, 0x11d2, 0xb7, 0x2c, 0x00, 0xc0, 0x4f, 0xb6, 0xbd, 0x3d
DEFINE_GUIDSTRUCT("b9f8ac3e-0f71-11d2-b72c-00c04fb6bd3d", CLSID_KsIBasicAudioInterfaceHandler);
#define CLSID_KsIBasicAudioInterfaceHandler DEFINE_GUIDNAMED(CLSID_KsIBasicAudioInterfaceHandler)

#endif // (NTDDI_VERSION >= NTDDI_WINXP)

#if defined(__IVPType__)

typedef struct {
    AMVPSIZE    Size;
    DWORD       MaxPixelsPerSecond;
    DWORD       Reserved;
} KSVPMAXPIXELRATE, *PKSVPMAXPIXELRATE;

typedef struct {
    KSPROPERTY      Property;
    AMVPSIZE        Size;
} KSVPSIZE_PROP, *PKSVPSIZE_PROP;

typedef struct {
    DWORD   dwPitch;
    DWORD   dwXOrigin;
    DWORD   dwYOrigin;
} KSVPSURFACEPARAMS, *PKSVPSURFACEPARAMS;

#else  // !defined(__IVPType__)

#if !defined(__DDRAW_INCLUDED__)

//==========================================================================
// The following definitions must be in sync with DDraw.h in DirectX SDK
//==========================================================================

/*
 * The FourCC code is valid.
 */
#define DDPF_FOURCC                             0x00000004l


typedef struct _DDPIXELFORMAT
{
    DWORD       dwSize;                 // size of structure
    DWORD       dwFlags;                // pixel format flags
    DWORD       dwFourCC;               // (FOURCC code)
    union
    {
    DWORD   dwRGBBitCount;          // how many bits per pixel (BD_1,2,4,8,16,24,32)
    DWORD   dwYUVBitCount;          // how many bits per pixel (BD_4,8,16,24,32)
    DWORD   dwZBufferBitDepth;      // how many bits for z buffers (BD_8,16,24,32)
    DWORD   dwAlphaBitDepth;        // how many bits for alpha channels (BD_1,2,4,8)
    };
    union
    {
    DWORD   dwRBitMask;             // mask for red bit
    DWORD   dwYBitMask;             // mask for Y bits
    };
    union
    {
    DWORD   dwGBitMask;             // mask for green bits
    DWORD   dwUBitMask;             // mask for U bits
    };
    union
    {
    DWORD   dwBBitMask;             // mask for blue bits
    DWORD   dwVBitMask;             // mask for V bits
    };
    union
    {
    DWORD   dwRGBAlphaBitMask;      // mask for alpha channel
    DWORD   dwYUVAlphaBitMask;      // mask for alpha channel
    DWORD   dwRGBZBitMask;          // mask for Z channel
    DWORD   dwYUVZBitMask;          // mask for Z channel
    };
} DDPIXELFORMAT, * LPDDPIXELFORMAT;

#endif // !defined(__DDRAW_INCLUDED__)

//==========================================================================
// End of DDraw.h header info
//==========================================================================

//==========================================================================
// The following definitions must be in sync with DVP.h in DirectX SDK
//==========================================================================

#if !defined(__DVP_INCLUDED__)

typedef struct _DDVIDEOPORTCONNECT {
    DWORD dwSize;           // size of the DDVIDEOPORTCONNECT structure
    DWORD dwPortWidth;      // Width of the video port
    GUID  guidTypeID;       // Description of video port connection
    DWORD dwFlags;          // Connection flags
    ULONG_PTR dwReserved1;  // Reserved, set to zero.
} DDVIDEOPORTCONNECT, * LPDDVIDEOPORTCONNECT;

#define DDVPTYPE_E_HREFH_VREFH  \
    0x54F39980L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#define DDVPTYPE_E_HREFL_VREFL  \
    0xE09C77E0L,0xDA60,0x11CF,0x9B,0x06,0x00,0xA0,0xC9,0x03,0xA3,0xB8

#endif // !defined(__DVP_INCLUDED__)

//==========================================================================
// End of DVP.h header info
//==========================================================================


//==========================================================================
// The following definitions must be in sync with VPType.h in AM 2.0 SDK
//==========================================================================

// pixel aspect ratios corresponding to a 720x480 NTSC image or a 720x576 image
typedef enum // AMPixAspectRatio
{
    KS_PixAspectRatio_NTSC4x3,
    KS_PixAspectRatio_NTSC16x9,
    KS_PixAspectRatio_PAL4x3,
    KS_PixAspectRatio_PAL16x9
} KS_AMPixAspectRatio ;

typedef enum // AMVP_SELECTFORMATBY
{
    KS_AMVP_DO_NOT_CARE,
    KS_AMVP_BEST_BANDWIDTH,
    KS_AMVP_INPUT_SAME_AS_OUTPUT
} KS_AMVP_SELECTFORMATBY;

typedef enum // AMVP_MODE
{
    KS_AMVP_MODE_WEAVE,
    KS_AMVP_MODE_BOBINTERLEAVED,
    KS_AMVP_MODE_BOBNONINTERLEAVED,
    KS_AMVP_MODE_SKIPEVEN,
    KS_AMVP_MODE_SKIPODD
} KS_AMVP_MODE ;

typedef struct tagKS_AMVPDIMINFO      // AMVPDIMINFO
{
    DWORD dwFieldWidth ;            // [out] field width
    DWORD dwFieldHeight ;           // [out] field height
    DWORD dwVBIWidth ;              // [out] VBI data width
    DWORD dwVBIHeight ;             // [out] VBI data height
    RECT  rcValidRegion ;           // [out] valid rect for data cropping
} KS_AMVPDIMINFO, *PKS_AMVPDIMINFO ;

typedef struct tagKS_AMVPDATAINFO   // AMVPDATAINFO
{
    DWORD           dwSize;                 // Size of the struct
    DWORD           dwMicrosecondsPerField; // Time taken by each field
    KS_AMVPDIMINFO  amvpDimInfo;            // Dimensional Information
    DWORD           dwPictAspectRatioX;     // Pict aspect ratio in X dimn
    DWORD           dwPictAspectRatioY;     // Pict aspect ratio in Y dimn
    BOOL            bEnableDoubleClock;     // Videoport should enable double clocking
    BOOL            bEnableVACT;            // Videoport should use an external VACT signal
    BOOL            bDataIsInterlaced;      // Indicates that the signal is interlaced
    LONG            lHalfLinesOdd;          // number of halflines in the odd field
    BOOL            bFieldPolarityInverted; // Device inverts the polarity by default
    DWORD           dwNumLinesInVREF;       // Number of lines of data in VREF
    LONG            lHalfLinesEven;         // number of halflines in the even field
    DWORD           dwReserved1;            // Reserved for future use
} KS_AMVPDATAINFO, *PKS_AMVPDATAINFO;

typedef struct tagKS_AMVPSIZE   // AMVPSIZE
{
    DWORD dwWidth ;                  // [in] width in pixels
    DWORD dwHeight ;                 // [in] height in pixels
} KS_AMVPSIZE, *PKS_AMVPSIZE ;

//==========================================================================
// End of VPType.h header info
//==========================================================================

typedef struct {
    KS_AMVPSIZE     Size;
    DWORD           MaxPixelsPerSecond;
    DWORD           Reserved;
} KSVPMAXPIXELRATE, *PKSVPMAXPIXELRATE;

typedef struct {
    KSPROPERTY      Property;
    KS_AMVPSIZE     Size;
} KSVPSIZE_PROP, *PKSVPSIZE_PROP;

typedef struct {
    DWORD   dwPitch;
    DWORD   dwXOrigin;
    DWORD   dwYOrigin;
} KSVPSURFACEPARAMS, *PKSVPSURFACEPARAMS;

#endif // !defined(__IVPType__)

//
//  IVPNotify event notification
//
#define STATIC_KSEVENTSETID_VPNotify\
    0x20c5598eL, 0xd3c8, 0x11d0, 0x8d, 0xfc, 0x00, 0xc0, 0x4f, 0xd7, 0xc0, 0x8b
DEFINE_GUIDSTRUCT("20c5598e-d3c8-11d0-8dfc-00c04fd7c08b", KSEVENTSETID_VPNotify);
#define KSEVENTSETID_VPNotify DEFINE_GUIDNAMED(KSEVENTSETID_VPNotify)

typedef enum {
    KSEVENT_VPNOTIFY_FORMATCHANGE
} KSEVENT_VPNOTIFY;

//
//  VIDCAPTOSTI event notification
//
#define STATIC_KSEVENTSETID_VIDCAPTOSTI\
    0xdb47de20, 0xf628, 0x11d1, 0xba, 0x41, 0x0, 0xa0, 0xc9, 0xd, 0x2b, 0x5
DEFINE_GUIDSTRUCT("DB47DE20-F628-11d1-BA41-00A0C90D2B05", KSEVENTSETID_VIDCAPTOSTI);
#define KSEVENTSETID_VIDCAPNotify DEFINE_GUIDNAMED(KSEVENTSETID_VIDCAPTOSTI)

typedef enum {
    KSEVENT_VIDCAPTOSTI_EXT_TRIGGER
#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)
    , KSEVENT_VIDCAP_AUTO_UPDATE
    , KSEVENT_VIDCAP_SEARCH
#endif // XP SP2 and later (chronologically)
} KSEVENT_VIDCAPTOSTI;

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

//
// Extension Unit Properties
//
typedef enum {
    KSPROPERTY_EXTENSION_UNIT_INFO,                  // (R)
    KSPROPERTY_EXTENSION_UNIT_CONTROL,               // (RW) 
    KSPROPERTY_EXTENSION_UNIT_PASS_THROUGH = 0xffff  // (RW) 
} KSPROPERTY_EXTENSION_UNIT, *PKSPROPERTY_EXTENSION_UNIT;

#endif // XP SP2 and later (chronologically)

//
//  IVPVBINotify event notification
//
#define STATIC_KSEVENTSETID_VPVBINotify\
    0xec529b01L, 0x1a1f, 0x11d1, 0xba, 0xd9, 0x0, 0x60, 0x97, 0x44, 0x11, 0x1a
DEFINE_GUIDSTRUCT("ec529b01-1a1f-11d1-bad9-00609744111a", KSEVENTSETID_VPVBINotify);
#define KSEVENTSETID_VPVBINotify DEFINE_GUIDNAMED(KSEVENTSETID_VPVBINotify)

typedef enum {
    KSEVENT_VPVBINOTIFY_FORMATCHANGE
} KSEVENT_VPVBINOTIFY;


//
// closed caption information
//

#define STATIC_KSDATAFORMAT_TYPE_AUXLine21Data \
0x670aea80L, 0x3a82, 0x11d0, 0xb7, 0x9b, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("670aea80-3a82-11d0-b79b-00aa003767a7", KSDATAFORMAT_TYPE_AUXLine21Data);
#define KSDATAFORMAT_TYPE_AUXLine21Data DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_AUXLine21Data)

#define STATIC_KSDATAFORMAT_SUBTYPE_Line21_BytePair \
0x6e8d4a22L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("6e8d4a22-310c-11d0-b79a-00aa003767a7", KSDATAFORMAT_SUBTYPE_Line21_BytePair);
#define KSDATAFORMAT_SUBTYPE_Line21_BytePair DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Line21_BytePair)

#define STATIC_KSDATAFORMAT_SUBTYPE_Line21_GOPPacket \
0x6e8d4a23L, 0x310c, 0x11d0, 0xb7, 0x9a, 0x00, 0xaa, 0x00, 0x37, 0x67, 0xa7
DEFINE_GUIDSTRUCT("6e8d4a23-310c-11d0-b79a-00aa003767a7", KSDATAFORMAT_SUBTYPE_Line21_GOPPacket);
#define KSDATAFORMAT_SUBTYPE_Line21_GOPPacket DEFINE_GUIDNAMED(KSDATAFORMAT_SUBTYPE_Line21_GOPPacket)

typedef struct _KSGOP_USERDATA {
    ULONG sc;
    ULONG reserved1;
    BYTE cFields;
    CHAR l21Data[3];
} KSGOP_USERDATA, *PKSGOP_USERDATA;

//
// DVD encrypted PACK format type definition
//

#define STATIC_KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK\
    0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x4f, 0xc3, 0x1d, 0x60
DEFINE_GUIDSTRUCT("ed0b916a-044d-11d1-aa78-00c04fc31d60", KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK);
#define KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK DEFINE_GUIDNAMED(KSDATAFORMAT_TYPE_DVD_ENCRYPTED_PACK)

#define KS_AM_UseNewCSSKey              0x0001L
// -----------------------------------------------------------------------
// KS_AM_KSPROPSETID_TSRateChange property set definitions for time stamp
// rate changes.
// -----------------------------------------------------------------------


#define STATIC_KSPROPSETID_TSRateChange\
    0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0

DEFINE_GUIDSTRUCT("A503C5C0-1D1D-11D1-AD80-444553540000", KSPROPSETID_TSRateChange);
#define KSPROPSETID_TSRateChange DEFINE_GUIDNAMED(KSPROPSETID_TSRateChange)
typedef enum {
    KS_AM_RATE_SimpleRateChange=1,  // rw, use KS_AM_SimpleRateChange
    KS_AM_RATE_ExactRateChange=2,   // rw, use KS_AM_ExactRateChange
    KS_AM_RATE_MaxFullDataRate=3,   // r, use KS_AM_MaxFullDataRate
    KS_AM_RATE_Step=4               // w, use KS_AM_Step
} KS_AM_PROPERTY_TS_RATE_CHANGE;

typedef struct {
    // this is the simplest mechanism to set a time stamp rate change on
    // a filter (simplest for the person setting the rate change, harder
    // for the filter doing the rate change).
    REFERENCE_TIME  StartTime;  //stream time at which to start this rate
    LONG        Rate;       //new rate * 10000 (decimal)
} KS_AM_SimpleRateChange, *PKS_AM_SimpleRateChange;

typedef struct {
    REFERENCE_TIME  OutputZeroTime; //input TS that maps to zero output TS
    LONG        Rate;       //new rate * 10000 (decimal)
} KS_AM_ExactRateChange, *PKS_AM_ExactRateChange;

typedef LONG KS_AM_MaxFullDataRate; //rate * 10000 (decimal)

typedef DWORD KS_AM_Step; // number of frame to step

#if (NTDDI_VERSION >= NTDDI_WINXPSP1)

//===========================================================================
//ENCODER API DEFINITIONS
//===========================================================================

#define STATIC_KSCATEGORY_ENCODER \
    0x19689bf6, 0xc384, 0x48fd, 0xad, 0x51, 0x90, 0xe5, 0x8c, 0x79, 0xf7, 0xb
DEFINE_GUIDSTRUCT("19689BF6-C384-48fd-AD51-90E58C79F70B", KSCATEGORY_ENCODER);
#define KSCATEGORY_ENCODER DEFINE_GUIDNAMED(KSCATEGORY_ENCODER)

#define STATIC_KSCATEGORY_MULTIPLEXER \
    0x7a5de1d3, 0x1a1, 0x452c, 0xb4, 0x81, 0x4f, 0xa2, 0xb9, 0x62, 0x71, 0xe8
DEFINE_GUIDSTRUCT("7A5DE1D3-01A1-452c-B481-4FA2B96271E8", KSCATEGORY_MULTIPLEXER);
#define KSCATEGORY_MULTIPLEXER DEFINE_GUIDNAMED(KSCATEGORY_MULTIPLEXER)

#ifndef __ENCODER_API_GUIDS__
#define __ENCODER_API_GUIDS__

#define STATIC_ENCAPIPARAM_BITRATE \
    0x49cc4c43, 0xca83, 0x4ad4, 0xa9, 0xaf, 0xf3, 0x69, 0x6a, 0xf6, 0x66, 0xdf
DEFINE_GUIDSTRUCT("49CC4C43-CA83-4ad4-A9AF-F3696AF666DF", ENCAPIPARAM_BITRATE);
#define ENCAPIPARAM_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE)

#define STATIC_ENCAPIPARAM_PEAK_BITRATE \
    0x703f16a9, 0x3d48, 0x44a1, 0xb0, 0x77, 0x1, 0x8d, 0xff, 0x91, 0x5d, 0x19
DEFINE_GUIDSTRUCT("703F16A9-3D48-44a1-B077-018DFF915D19", ENCAPIPARAM_PEAK_BITRATE);
#define ENCAPIPARAM_PEAK_BITRATE DEFINE_GUIDNAMED(ENCAPIPARAM_PEAK_BITRATE)

#define STATIC_ENCAPIPARAM_BITRATE_MODE \
    0xee5fb25c, 0xc713, 0x40d1, 0x9d, 0x58, 0xc0, 0xd7, 0x24, 0x1e, 0x25, 0xf
DEFINE_GUIDSTRUCT("EE5FB25C-C713-40d1-9D58-C0D7241E250F", ENCAPIPARAM_BITRATE_MODE);
#define ENCAPIPARAM_BITRATE_MODE DEFINE_GUIDNAMED(ENCAPIPARAM_BITRATE_MODE)

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

#define STATIC_CODECAPI_CHANGELISTS \
    0x62b12acf, 0xf6b0, 0x47d9, 0x94, 0x56, 0x96, 0xf2, 0x2c, 0x4e, 0x0b, 0x9d
DEFINE_GUIDSTRUCT("62B12ACF-F6B0-47D9-9456-96F22C4E0B9D", CODECAPI_CHANGELISTS );
#define CODECAPI_CHANGELISTS DEFINE_GUIDNAMED(CODECAPI_CHANGELISTS )

#define STATIC_CODECAPI_VIDEO_ENCODER \
    0x7112e8e1, 0x3d03, 0x47ef, 0x8e, 0x60, 0x03, 0xf1, 0xcf, 0x53, 0x73, 0x01
DEFINE_GUIDSTRUCT("7112E8E1-3D03-47EF-8E60-03F1CF537301", CODECAPI_VIDEO_ENCODER );
#define CODECAPI_VIDEO_ENCODER DEFINE_GUIDNAMED(CODECAPI_VIDEO_ENCODER )

#define STATIC_CODECAPI_AUDIO_ENCODER \
    0xb9d19a3e, 0xf897, 0x429c, 0xbc, 0x46, 0x81, 0x38, 0xb7, 0x27, 0x2b, 0x2d
DEFINE_GUIDSTRUCT("B9D19A3E-F897-429C-BC46-8138B7272B2D", CODECAPI_AUDIO_ENCODER );
#define CODECAPI_AUDIO_ENCODER DEFINE_GUIDNAMED(CODECAPI_AUDIO_ENCODER )

#define STATIC_CODECAPI_SETALLDEFAULTS \
    0x6c5e6a7c, 0xacf8, 0x4f55, 0xa9, 0x99, 0x1a, 0x62, 0x81, 0x09, 0x05, 0x1b
DEFINE_GUIDSTRUCT("6C5E6A7C-ACF8-4F55-A999-1A628109051B", CODECAPI_SETALLDEFAULTS );
#define CODECAPI_SETALLDEFAULTS DEFINE_GUIDNAMED(CODECAPI_SETALLDEFAULTS )

#define STATIC_CODECAPI_ALLSETTINGS \
    0x6a577e92, 0x83e1, 0x4113, 0xad, 0xc2, 0x4f, 0xce, 0xc3, 0x2f, 0x83, 0xa1
DEFINE_GUIDSTRUCT("6A577E92-83E1-4113-ADC2-4FCEC32F83A1", CODECAPI_ALLSETTINGS );
#define CODECAPI_ALLSETTINGS DEFINE_GUIDNAMED(CODECAPI_ALLSETTINGS )

#define STATIC_CODECAPI_SUPPORTSEVENTS \
    0x0581af97, 0x7693, 0x4dbd, 0x9d, 0xca, 0x3f, 0x9e, 0xbd, 0x65, 0x85, 0xa1 
DEFINE_GUIDSTRUCT("0581AF97-7693-4DBD-9DCA-3F9EBD6585A1", CODECAPI_SUPPORTSEVENTS );
#define CODECAPI_SUPPORTSEVENTS DEFINE_GUIDNAMED(CODECAPI_SUPPORTSEVENTS )

#define STATIC_CODECAPI_CURRENTCHANGELIST \
    0x1cb14e83, 0x7d72, 0x4657, 0x83, 0xfd, 0x47, 0xa2, 0xc5, 0xb9, 0xd1, 0x3d 
DEFINE_GUIDSTRUCT("1CB14E83-7D72-4657-83FD-47A2C5B9D13D", CODECAPI_CURRENTCHANGELIST );
#define CODECAPI_CURRENTCHANGELIST DEFINE_GUIDNAMED(CODECAPI_CURRENTCHANGELIST )

#endif // XP SP2 and later (chronologically)

#endif // __ENCODER_API_GUIDS__

#ifndef __ENCODER_API_DEFINES__
#define __ENCODER_API_DEFINES__

typedef enum {

    //
    // Bit rate used for encoding is constant
    //
    ConstantBitRate = 0,

    //
    // Bit rate used for encoding is variable with the specified bitrate used
    // as a guaranteed average over a specified window.  The default window 
    // size is considered to be 5 minutes.
    //
    VariableBitRateAverage,

    //
    // Bit rate used for encoding is variable with the specified bitrate used
    // as an average with a peak not to exceed the specified peak bitrate over 
    // a specified window.  The default window size is considered to be 500ms 
    // (classically one GOP).
    //
    VariableBitRatePeak

} VIDEOENCODER_BITRATE_MODE;

#endif // __ENCODER_API_DEFINES__

//===========================================================================
// JACK DESCRIPTION DEFINITIONS
//===========================================================================
#define STATIC_KSPROPSETID_Jack\
    0x4509f757, 0x2d46, 0x4637, 0x8e, 0x62, 0xce, 0x7d, 0xb9, 0x44, 0xf5, 0x7b
DEFINE_GUIDSTRUCT("4509F757-2D46-4637-8E62-CE7DB944F57B", KSPROPSETID_Jack);
#define KSPROPSETID_Jack DEFINE_GUIDNAMED(KSPROPSETID_Jack)

// define new property id 
typedef enum {
    KSPROPERTY_JACK_DESCRIPTION = 1,
    KSPROPERTY_JACK_DESCRIPTION2,
    KSPROPERTY_JACK_SINK_INFO
} KSPROPERTY_JACK;

// Enums used in KSPROPERTY_JACK_INFO_STRUCT

typedef enum
{
    eConnTypeUnknown,
    eConnType3Point5mm,
    eConnTypeQuarter,
    eConnTypeAtapiInternal,
    eConnTypeRCA,
    eConnTypeOptical,
    eConnTypeOtherDigital,
    eConnTypeOtherAnalog,
    eConnTypeMultichannelAnalogDIN,
    eConnTypeXlrProfessional,
    eConnTypeRJ11Modem,
    eConnTypeCombination
} EPcxConnectionType;

typedef enum
{
    eGeoLocRear = 0x1,
    eGeoLocFront,
    eGeoLocLeft,
    eGeoLocRight,
    eGeoLocTop,
    eGeoLocBottom,
    eGeoLocRearPanel,
    eGeoLocRiser,
    eGeoLocInsideMobileLid,
    eGeoLocDrivebay,
    eGeoLocHDMI,
    eGeoLocOutsideMobileLid,
    eGeoLocATAPI,
    eGeoLocReserved5,
    eGeoLocReserved6,
    EPcxGeoLocation_enum_count
} EPcxGeoLocation;

typedef enum
{
    eGenLocPrimaryBox = 0,
    eGenLocInternal,
    eGenLocSeparate,
    eGenLocOther,
    EPcxGenLocation_enum_count
} EPcxGenLocation;

typedef enum
{
    ePortConnJack = 0,
    ePortConnIntegratedDevice,
    ePortConnBothIntegratedAndJack,
    ePortConnUnknown
} EPxcPortConnection;

// structure for KSPROPERTY_JACK_DESCRIPTION pin property
typedef struct 
{
    DWORD                 ChannelMapping;
    COLORREF              Color;   // use RGB() macro to generate these
    EPcxConnectionType    ConnectionType;
    EPcxGeoLocation       GeoLocation;
    EPcxGenLocation       GenLocation;
    EPxcPortConnection    PortConnection;
    BOOL                  IsConnected;
} KSJACK_DESCRIPTION, *PKSJACK_DESCRIPTION;

typedef enum 
{
    KSJACK_SINK_CONNECTIONTYPE_HDMI = 0,            // HDMI
    KSJACK_SINK_CONNECTIONTYPE_DISPLAYPORT,         // DisplayPort
} KSJACK_SINK_CONNECTIONTYPE;

#define MAX_SINK_DESCRIPTION_NAME_LENGTH 32
typedef struct _tagKSJACK_SINK_INFORMATION
{
  KSJACK_SINK_CONNECTIONTYPE ConnType;              // Connection Type
  WORD  ManufacturerId;                             // Sink manufacturer ID
  WORD  ProductId;                                  // Sink product ID
  WORD  AudioLatency;                                    // Sink audio latency
  BOOL  HDCPCapable;                                // HDCP Support
  BOOL  AICapable;                                  // ACP Packet, ISRC1, and ISRC2 Support
  UCHAR SinkDescriptionLength;                      // Monitor/Sink name length
  WCHAR SinkDescription[MAX_SINK_DESCRIPTION_NAME_LENGTH];   // Monitor/Sink name
  LUID  PortId;                                     // Video port identifier
}  KSJACK_SINK_INFORMATION, *PKSJACK_SINK_INFORMATION;

#define JACKDESC2_PRESENCE_DETECT_CAPABILITY       0x00000001 
#define JACKDESC2_DYNAMIC_FORMAT_CHANGE_CAPABILITY 0x00000002

typedef struct _tagKSJACK_DESCRIPTION2
{
  DWORD              DeviceStateInfo; // Top 16 bits: Report current device state, active, streaming, idle, or hardware not ready
                                      // Bottom 16 bits: detailed reason to further explain state in top 16 bits
  DWORD              JackCapabilities; // Report jack capabilities such as jack presence detection capability 
                                       // or dynamic format changing capability         
} KSJACK_DESCRIPTION2, *PKSJACK_DESCRIPTION2;

#endif // (NTDDI_VERSION >= NTDDI_WINXPSP1)

//===========================================================================
// Audio Buffer Duration
#define STATIC_KSPROPSETID_AudioBufferDuration\
    0x4e73c07f, 0x23cc, 0x4955, 0xa7, 0xea, 0x3d, 0xa5, 0x2, 0x49, 0x62, 0x90 
DEFINE_GUIDSTRUCT("4E73C07F-23CC-4955-A7EA-3DA502496290", KSPROPSETID_AudioBufferDuration);
#define KSPROPSETID_AudioBufferDuration DEFINE_GUIDNAMED(KSPROPSETID_AudioBufferDuration)

// define new property id 
#define KSPROPERTY_AUDIO_BUFFER_DURATION 1

#endif // !defined(_KSMEDIA_)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ksamd64.inc ===
include kxamd64.inc

;
;  Pointer size in bytes
;

SizeofPointer equ 00008H

;
;  Process State Enumerated Type Values
;

ProcessInMemory equ 00000H
ProcessOutOfMemory equ 00001H
ProcessInTransition equ 00002H

;
;  Thread State Enumerated Type Values
;

Initialized equ 00000H
Ready equ 00001H
Running equ 00002H
Standby equ 00003H
Terminated equ 00004H
Waiting equ 00005H

;
;  Processor Mode Definitions
;

KernelMode equ 00000H
UserMode equ 00001H

;
;  Wait Reason and Wait Type Enumerated Type Values
;

WrExecutive equ 00000H
WrDispatchInt equ 0001FH
WaitAny equ 00001H
WaitAll equ 00000H

;
;  Apc State Structure Offset Definitions
;

AsApcListHead equ 00000H
AsProcess equ 00020H
AsKernelApcInProgress equ 00028H
AsKernelApcPending equ 00029H
AsUserApcPending equ 0002AH

;
;  Bug Check Code Definitions
;

APC_INDEX_MISMATCH equ 00001H
KERNEL_APC_PENDING_DURING_EXIT equ 00020H
ATTEMPTED_SWITCH_FROM_DPC equ 000B8H
DATA_BUS_ERROR equ 0002EH
DATA_COHERENCY_EXCEPTION equ 00055H
HAL1_INITIALIZATION_FAILED equ 00061H
INSTRUCTION_BUS_ERROR equ 0002FH
INSTRUCTION_COHERENCY_EXCEPTION equ 00056H
INTERRUPT_EXCEPTION_NOT_HANDLED equ 0003DH
INTERRUPT_UNWIND_ATTEMPTED equ 0003CH
INVALID_AFFINITY_SET equ 00003H
INVALID_DATA_ACCESS_TRAP equ 00004H
IRQL_GT_ZERO_AT_SYSTEM_SERVICE equ 0004AH
IRQL_NOT_LESS_OR_EQUAL equ 0000AH
KMODE_EXCEPTION_NOT_HANDLED equ 0001EH
NMI_HARDWARE_FAILURE equ 00080H
NO_USER_MODE_CONTEXT equ 0000EH
PAGE_FAULT_WITH_INTERRUPTS_OFF equ 00049H
PANIC_STACK_SWITCH equ 0002BH
SPIN_LOCK_INIT_FAILURE equ 00081H
SYSTEM_EXIT_OWNED_MUTEX equ 00039H
SYSTEM_SERVICE_EXCEPTION equ 0003BH
SYSTEM_UNWIND_PREVIOUS_USER equ 0003AH
TRAP_CAUSE_UNKNOWN equ 00012H
UNEXPECTED_KERNEL_MODE_TRAP equ 0007FH
HARDWARE_INTERRUPT_STORM equ 000F2H
RECURSIVE_MACHINE_CHECK equ 000FBH
RECURSIVE_NMI equ 00111H

;
;  Breakpoint type definitions
;

DBG_STATUS_CONTROL_C equ 00001H
STATUS_ASSERTION_FAILURE equ 0C0000420H

;
;  Client Id Structure Offset Definitions
;

CidUniqueProcess equ 00000H
CidUniqueThread equ 00008H

;
;  Critical Section Structure Offset Definitions
;

CsDebugInfo equ 00000H
CsLockCount equ 00008H
CsRecursionCount equ 0000CH
CsOwningThread equ 00010H
CsLockSemaphore equ 00018H
CsSpinCount equ 00020H

;
;  Critical Section Debug Information Structure Offset Definitions
;

CsType equ 00000H
CsCreatorBackTraceIndex equ 00002H
CsCriticalSection equ 00008H
CsProcessLocksList equ 00010H
CsEntryCount equ 00020H
CsContentionCount equ 00024H

;
;  Exception Record Offset, Flag, and Enumerated Type Definitions
;

EXCEPTION_NONCONTINUABLE equ 00001H
EXCEPTION_UNWINDING equ 00002H
EXCEPTION_EXIT_UNWIND equ 00004H
EXCEPTION_STACK_INVALID equ 00008H
EXCEPTION_NESTED_CALL equ 00010H
EXCEPTION_TARGET_UNWIND equ 00020H
EXCEPTION_COLLIDED_UNWIND equ 00040H
EXCEPTION_UNWIND equ 00066H
EXCEPTION_EXECUTE_HANDLER equ 00001H
EXCEPTION_CONTINUE_SEARCH equ 00000H
EXCEPTION_CONTINUE_EXECUTION equ 0FFFFFFFFH

ExceptionContinueExecution equ 00000H
ExceptionContinueSearch equ 00001H
ExceptionNestedException equ 00002H
ExceptionCollidedUnwind equ 00003H

ErExceptionCode equ 00000H
ErExceptionFlags equ 00004H
ErExceptionRecord equ 00008H
ErExceptionAddress equ 00010H
ErNumberParameters equ 00018H
ErExceptionInformation equ 00020H
ExceptionRecordLength equ 000A0H

;
;  Fast Mutex Structure Offset Definitions
;

FmCount equ 00000H
FmOwner equ 00008H
FmContention equ 00010H
FmOldIrql equ 00030H

;
;  Interrupt Priority Request Level Definitions
;

PASSIVE_LEVEL equ 00000H
APC_LEVEL equ 00001H
DISPATCH_LEVEL equ 00002H
CLOCK_LEVEL equ 0000DH
IPI_LEVEL equ 0000EH
POWER_LEVEL equ 0000EH
PROFILE_LEVEL equ 0000FH
HIGH_LEVEL equ 0000FH
ifdef NT_UP
SYNCH_LEVEL equ 00002H
else
SYNCH_LEVEL equ 0000CH
endif

;
;  Large Integer Structure Offset Definitions
;

LiLowPart equ 00000H
LiHighPart equ 00004H

;
;  List Entry Structure Offset Definitions
;

LsFlink equ 00000H
LsBlink equ 00008H

;
;  String Structure Offset Definitions
;

StrLength equ 00000H
StrMaximumLength equ 00002H
StrBuffer equ 00008H

;
;  User Shared Data Structure Offset Definitions
;

UsTickCountMultiplier equ 00004H
UsInterruptTime equ 00008H
UsSystemTime equ 00014H
UsTimeZoneBias equ 00020H
UsImageNumberLow equ 0002CH
UsImageNumberHigh equ 0002EH
UsNtSystemRoot equ 00030H
UsMaxStackTraceDepth equ 00238H
UsCryptoExponent equ 0023CH
UsTimeZoneId equ 00240H
UsLargePageMinimum equ 00244H
UsReserved2 equ 00248H
UsNtProductType equ 00264H
UsProductTypeIsValid equ 00268H
UsNtMajorVersion equ 0026CH
UsNtMinorVersion equ 00270H
UsProcessorFeatures equ 00274H
UsReserved1 equ 002B4H
UsReserved3 equ 002B8H
UsTimeSlip equ 002BCH
UsAlternativeArchitecture equ 002C0H
UsSystemExpirationDate equ 002C8H
UsSuiteMask equ 002D0H
UsKdDebuggerEnabled equ 002D4H
UsActiveConsoleId equ 002D8H
UsDismountCount equ 002DCH
UsComPlusPackage equ 002E0H
UsLastSystemRITEventTickCount equ 002E4H
UsNumberOfPhysicalPages equ 002E8H
UsSafeBootMode equ 002ECH
UsTscQpcData equ 002EDH
UsTestRetInstruction equ 002F8H
UsSystemCall equ 00300H
UsSystemCallReturn equ 00304H
UsSystemCallPad equ 00308H
UsTickCount equ 00320H
UsTickCountQuad equ 00320H
UsWow64SharedInformation equ 00340H

;
;  Time Structure Offset Definitions
;

TmLowTime equ 00000H
TmHighTime equ 00004H

;
;  Thread Switch Counter Offset Definitions
;

TwFindAny equ 00000H
TwFindIdeal equ 00004H
TwFindLast equ 00008H
TwIdleAny equ 0000CH
TwIdleCurrent equ 00010H
TwIdleIdeal equ 00014H
TwIdleLast equ 00018H
TwPreemptAny equ 0001CH
TwPreemptCurrent equ 00020H
TwPreemptLast equ 00024H
TwSwitchToIdle equ 00028H

;
;  Status Code Definitions
;

STATUS_ACCESS_VIOLATION equ 0C0000005H
STATUS_ARRAY_BOUNDS_EXCEEDED equ 0C000008CH
STATUS_BAD_COMPRESSION_BUFFER equ 0C0000242H
STATUS_BREAKPOINT equ 080000003H
STATUS_CALLBACK_POP_STACK equ 0C0000423H
STATUS_DATATYPE_MISALIGNMENT equ 080000002H
STATUS_FLOAT_DENORMAL_OPERAND equ 0C000008DH
STATUS_FLOAT_DIVIDE_BY_ZERO equ 0C000008EH
STATUS_FLOAT_INEXACT_RESULT equ 0C000008FH
STATUS_FLOAT_INVALID_OPERATION equ 0C0000090H
STATUS_FLOAT_OVERFLOW equ 0C0000091H
STATUS_FLOAT_STACK_CHECK equ 0C0000092H
STATUS_FLOAT_UNDERFLOW equ 0C0000093H
STATUS_FLOAT_MULTIPLE_FAULTS equ 0C00002B4H
STATUS_FLOAT_MULTIPLE_TRAPS equ 0C00002B5H
STATUS_GUARD_PAGE_VIOLATION equ 080000001H
STATUS_ILLEGAL_FLOAT_CONTEXT equ 0C000014AH
STATUS_ILLEGAL_INSTRUCTION equ 0C000001DH
STATUS_INSTRUCTION_MISALIGNMENT equ 0C00000AAH
STATUS_INVALID_HANDLE equ 0C0000008H
STATUS_INVALID_LOCK_SEQUENCE equ 0C000001EH
STATUS_INVALID_OWNER equ 0C000005AH
STATUS_INVALID_PARAMETER equ 0C000000DH
STATUS_INVALID_PARAMETER_1 equ 0C00000EFH
STATUS_INVALID_SYSTEM_SERVICE equ 0C000001CH
STATUS_INVALID_THREAD equ 0C000071CH
STATUS_INTEGER_DIVIDE_BY_ZERO equ 0C0000094H
STATUS_INTEGER_OVERFLOW equ 0C0000095H
STATUS_IN_PAGE_ERROR equ 0C0000006H
STATUS_KERNEL_APC equ 00100H
STATUS_LONGJUMP equ 080000026H
STATUS_NO_CALLBACK_ACTIVE equ 0C0000258H
STATUS_NO_EVENT_PAIR equ 0C000014EH
STATUS_PRIVILEGED_INSTRUCTION equ 0C0000096H
STATUS_SINGLE_STEP equ 080000004H
STATUS_STACK_BUFFER_OVERRUN equ 0C0000409H
STATUS_STACK_OVERFLOW equ 0C00000FDH
STATUS_SUCCESS equ 00000H
STATUS_THREAD_IS_TERMINATING equ 0C000004BH
STATUS_TIMEOUT equ 00102H
STATUS_UNWIND equ 0C0000027H
STATUS_UNWIND_CONSOLIDATE equ 080000029H
STATUS_USER_APC equ 000C0H
STATUS_WAKE_SYSTEM_DEBUGGER equ 080000007H

;
;  APC Object Structure Offset Definitions
;

ApType equ 00000H
ApSize equ 00002H
ApThread equ 00008H
ApApcListEntry equ 00010H
ApKernelRoutine equ 00020H
ApRundownRoutine equ 00028H
ApNormalRoutine equ 00030H
ApNormalContext equ 00038H
ApSystemArgument1 equ 00040H
ApSystemArgument2 equ 00048H
ApApcStateIndex equ 00050H
ApApcMode equ 00051H
ApInserted equ 00052H
ApcObjectLength equ 00058H

;
;  DPC object Structure Offset Definitions
;

DpType equ 00000H
DpNumber equ 00002H
DpImportance equ 00001H
DpDpcListEntry equ 00008H
DpDeferredRoutine equ 00018H
DpDeferredContext equ 00020H
DpSystemArgument1 equ 00028H
DpSystemArgument2 equ 00030H
DpDpcData equ 00038H
DpcObjectLength equ 00040H

KI_DPC_ALL_FLAGS equ 0003FH

;
;  Device Queue Object Structure Offset Definitions
;

DvType equ 00000H
DvSize equ 00002H
DvDeviceListHead equ 00008H
DvSpinLock equ 00018H
DvBusy equ 00020H
DeviceQueueObjectLength equ 00028H

;
;  Device Queue Entry Structure Offset Definitions
;

DeDeviceListEntry equ 00000H
DeSortKey equ 00010H
DeInserted equ 00014H
DeviceQueueEntryLength equ 00018H

;
;  Event Object Structure Offset Definitions
;

EvType equ 00000H
EvSize equ 00002H
EvSignalState equ 00004H
EvWaitListHead equ 00008H
EventObjectLength equ 00018H

;
;  Event Pair Object Structure Offset Definitions
;

EpType equ 00000H
EpSize equ 00002H
EpEventLow equ 00008H
EpEventHigh equ 00020H

;
;  Interrupt Object Structure Offset Definitions
;

InLevelSensitive equ 00000H
InLatched equ 00001H

InType equ 00000H
InSize equ 00002H
InInterruptListEntry equ 00008H
InServiceRoutine equ 00018H
InServiceContext equ 00030H
InSpinLock equ 00038H
InTickCount equ 00040H
InActualLock equ 00048H
InDispatchAddress equ 00050H
InVector equ 00058H
InIrql equ 0005CH
InSynchronizeIrql equ 0005DH
InFloatingSave equ 0005EH
InConnected equ 0005FH
InNumber equ 00060H
InShareVector equ 00064H
InMode equ 00068H
InServiceCount equ 00070H
InDispatchCount equ 00074H
InTrapFrame equ 00080H
InDispatchCode equ 00090H
InterruptObjectLength equ 000A0H

;
;  Process Object Structure Offset Definitions
;

PrType equ 00000H
PrSize equ 00002H
PrSignalState equ 00004H
PrProfileListHead equ 00018H
PrDirectoryTableBase equ 00028H
PrThreadListHead equ 00030H
PrAffinity equ 00048H
PrReadyListHead equ 00070H
PrSwapListEntry equ 00080H
PrActiveProcessors equ 00088H
PrProcessFlags equ 000B0H
PrBasePriority equ 000B4H
PrQuantumReset equ 000B5H
PrCycleTime equ 000F0H
PrKernelTime equ 000F8H
PrUserTime equ 000FCH
PrInstrumentationCallback equ 00100H
KernelProcessObjectLength equ 00160H
ExecutiveProcessObjectLength equ 004D0H

;
;  Profile Object Structure Offset Definitions
;

PfType equ 00000H
PfSize equ 00002H
PfProfileListEntry equ 00008H
PfProcess equ 00018H
PfRangeBase equ 00020H
PfRangeLimit equ 00028H
PfBucketShift equ 00030H
PfBuffer equ 00038H
PfSegment equ 00040H
PfAffinity equ 00048H
PfSource equ 00070H
PfStarted equ 00072H
ProfileObjectLength equ 00078H

;
;  Queue Object Structure Offset Definitions
;

QuSignalState equ 00004H
QuEntryListHead equ 00018H
QuCurrentCount equ 00028H
QuMaximumCount equ 0002CH
QuThreadListHead equ 00030H
QueueObjectLength equ 00040H

;
;  Thread Object Structure Offset Definitions
;

EeKernelEventPair equ 00000H
EtCid equ 003B0H

;
;  User Mode Scheduling Definitions
;

ThUcb equ 001B8H

ThType equ 00000H
ThSize equ 00002H
ThLock equ 00000H
THREAD_FLAGS_CYCLE_PROFILING equ 00002H
THREAD_FLAGS_CYCLE_PROFILING_LOCK_BIT equ 00011H
THREAD_FLAGS_CYCLE_PROFILING_LOCK equ 020000H
THREAD_FLAGS_COUNTER_PROFILING equ 00004H
THREAD_FLAGS_COUNTER_PROFILING_LOCK_BIT equ 00012H
THREAD_FLAGS_COUNTER_PROFILING_LOCK equ 040000H
ThDebugActive equ 00003H
ThThreadControlFlags equ 00002H
THREAD_FLAGS_CPU_THROTTLED equ 00001H
THREAD_FLAGS_CPU_THROTTLED_BIT equ 00000H
THREAD_FLAGS_ACCOUNTING_ANY equ 00005H
ThSignalState equ 00004H
ThCycleTime equ 00018H
ThInitialStack equ 00028H
ThStackLimit equ 00030H
ThKernelStack equ 00038H
ThThreadLock equ 00040H
ThApcState equ 00050H
ThNextProcessor equ 0007CH
ThDeferredProcessor equ 00080H
ThAdjustReason equ 001F4H
ThAdjustIncrement equ 001F5H
ThWaitStatus equ 00090H
ThWaitBlockList equ 00098H
ThWaitReason equ 0026BH
ThPriority equ 0007BH
ThRunning equ 00049H
ThAlerted equ 0004AH
ThWaitListEntry equ 000A0H
ThSwapListEntry equ 000A0H
ThQueue equ 000B0H
ThTeb equ 000B8H
ThTimer equ 000C0H

KTHREAD_AUTO_ALIGNMENT_BIT equ 00000H
KTHREAD_GUI_THREAD_MASK equ 00080H
DEBUG_ACTIVE_PRIMARY_THREAD equ 00080H
DEBUG_ACTIVE_PRIMARY_THREAD_BIT equ 00007H
DEBUG_ACTIVE_PRIMARY_THREAD_LOCK_BIT equ 0001FH
DEBUG_ACTIVE_SCHEDULED_THREAD equ 00040H
DEBUG_ACTIVE_SCHEDULED_THREAD_BIT equ 00006H
DEBUG_ACTIVE_SCHEDULED_THREAD_LOCK_BIT equ 0001EH
DEBUG_ACTIVE_SCHEDULED_THREAD_LOCK equ 040000000H

KTHREAD_UMS_DIRECTED_SWITCH_ENABLE_BIT equ 0000BH
KTHREAD_UMS_PERFORMING_SYSCALL_BIT equ 00008H

ThMiscFlags equ 0004CH
ThThreadFlags equ 00100H
ThWaitBlock equ 00108H
ThPreviousMode equ 001F6H
ThResourceIndex equ 00281H
ThLargeStack equ 002D3H
ThContextSwitches equ 00134H
ThState equ 00164H
ThNpxState equ 00165H
ThWaitIrql equ 00166H
ThWaitMode equ 00167H
ThWaitTime equ 00194H
ThCombinedApcDisable equ 001C4H
ThKernelApcDisable equ 001C4H
ThSpecialApcDisable equ 001C6H
ThQueueListEntry equ 001C8H
ThTrapFrame equ 001D8H
ThFirstArgument equ 001E0H
ThCallbackStack equ 001E8H
ThCallbackDepth equ 001E8H
ThApcStateIndex equ 001F0H
ThIdealProcessor equ 00228H
ThBasePriority equ 001F1H
ThPriorityDecrement equ 001F2H
ThSaturation equ 001F7H
ThSystemCallNumber equ 001F8H
ThUserAffinity equ 00200H
ThProcess equ 00210H
ThAffinity equ 00218H
ThApcStatePointer equ 00230H
ThSavedApcState equ 00240H
ThFreezeCount equ 001FCH
ThSuspendCount equ 0026CH
ThUserIdealProcessor equ 0022CH
ThCodePatchInProgress equ 0026EH
ThWin32Thread equ 00270H
ThStackBase equ 00278H
ThSuspendApc equ 00280H
ThKernelTime equ 00284H
ThLegoData equ 002C8H
ThUserTime equ 002D4H
ThSuspendSemaphore equ 002D8H
ThSListFaultCount equ 002F4H
ThMutantListHead equ 00308H
ThThreadListEntry equ 002F8H
ThSListFaultAddress equ 00318H

KI_SLIST_FAULT_COUNT_MAXIMUM equ 00400H

KernelThreadObjectLength equ 00360H
ExecutiveThreadObjectLength equ 00498H


;
;  Timer object Structure Offset Definitions
;

TiType equ 00000H
TiSize equ 00002H
TiSignalState equ 00004H
TiDueTime equ 00018H
TiTimerListEntry equ 00020H
TiDpc equ 00030H
TiPeriod equ 0003CH
TimerObjectLength equ 00040H


;
;  Wait Block Structure Offset Definitions
;

WbWaitListEntry equ 00000H
WbThread equ 00010H
WbObject equ 00018H
WbNextWaitBlock equ 00020H
WbWaitKey equ 00028H
WbWaitType equ 0002AH

;
;  Fiber Structure Offset Definitions
;

FbFiberData equ 00000H
FbExceptionList equ 00008H
FbStackBase equ 00010H
FbStackLimit equ 00018H
FbDeallocationStack equ 00020H
FbFiberContext equ 00030H
FbWx86Tib equ 00500H
FbActivationContextStackPointer equ 00508H
FbFlsData equ 00510H
FbGuaranteedStackBytes equ 00518H
FbTebFlags equ 0051CH

;
;  UMS Context Structure Definitions
;

UcTeb equ 004E0H
UcContext equ 00010H
UcFlags equ 004F0H
UcLink equ 00000H
UcContextLock equ 004F8H
UcPrimaryUmsContext equ 00520H
UMSCTX_SCHEDULED_THREAD_MASK equ 00001H
UMSCTX_SCHEDULED_THREAD_BIT equ 00000H
UMSCTX_VOLATILE_CONTEXT_MASK equ 00020H
UMSCTX_VOLATILE_CONTEXT_BIT equ 00005H
UMSCTX_TERMINATED_MASK equ 00040H
UMSCTX_TERMINATED_BIT equ 00006H
UMSCTX_SUSPENDED_MASK equ 00010H
UMSCTX_SUSPENDED_BIT equ 00004H
UMSCTX_DEBUG_ACTIVE_MASK equ 00080H
UMSCTX_DEBUG_ACTIVE_BIT equ 00007H
UMSCTX_DENY_RUNNING_ON_SELF_THREAD_MASK equ 00200H
UMSCTX_DENY_RUNNING_ON_SELF_THREAD_BIT equ 00009H


;
;  RTL_UMS_SCHEDULER_REASON Enum Definitions
;

UmsSchedulerStartup equ 00000H
UmsSchedulerThreadBlocked equ 00001H
UmsSchedulerThreadYield equ 00002H


;
;  Process Environment Block Structure Offset Definitions
;

PeBeingDebugged equ 00002H
PeProcessParameters equ 00020H
PeKernelCallbackTable equ 00058H
ProcessEnvironmentBlockLength equ 00380H

;
;  Process Parameters Block Structure Offset Definitions
;

PpFlags equ 00008H
USER_CALLBACK_FILTER equ 080000H

;
;  System Service Descriptor Table Structure Definitions
;

NUMBER_SERVICE_TABLES equ 00002H
SERVICE_NUMBER_MASK equ 00FFFH
SERVICE_TABLE_SHIFT equ 00007H
SERVICE_TABLE_MASK equ 00020H
SERVICE_TABLE_TEST equ 00020H

ThBase equ 00000H
ThLimit equ 00008H
SdBase equ 00000H
SdCount equ 00008H
SdLimit equ 00010H
SdNumber equ 00018H
SdLength equ 00020H

;
;  Thread Environment Block Structure Offset Definitions
;

TeCmTeb equ 00000H
TeStackBase equ 00008H
TeStackLimit equ 00010H
TeFiberData equ 00020H
TeSelf equ 00030H
TeEnvironmentPointer equ 00038H
TeClientId equ 00040H
TeActiveRpcHandle equ 00050H
TeThreadLocalStoragePointer equ 00058H
TeCountOfOwnedCriticalSections equ 0006CH
TePeb equ 00060H
TeCsrClientThread equ 00070H
TeWOW32Reserved equ 00100H
TeSoftFpcr equ 0010CH
TeExceptionCode equ 002C0H
TeActivationContextStackPointer equ 002C8H
TeGdiClientPID equ 007F0H
TeGdiClientTID equ 007F4H
TeGdiThreadLocalInfo equ 007F8H
TeglDispatchTable equ 009F0H
TeglReserved1 equ 01138H
TeglReserved2 equ 01220H
TeglSectionInfo equ 01228H
TeglSection equ 01230H
TeglTable equ 01238H
TeglCurrentRC equ 01240H
TeglContext equ 01248H
TeDeallocationStack equ 01478H
TeTlsSlots equ 01480H
TeTlsExpansionSlots equ 01780H
TeLastErrorValue equ 00068H
TeVdm equ 01690H
TeInstrumentation equ 016B8H
TeGdiBatchCount equ 01740H
TeGuaranteedStackBytes equ 01748H
TeFlsData equ 017C8H
ThreadEnvironmentBlockLength equ 01818H
CmThreadEnvironmentBlockOffset equ 02000H
TLS_MINIMUM_AVAILABLE equ 00040H
TLS_EXPANSION_SLOTS equ 00400H
UMS_TLS_THREAD_CONTEXT equ 00004H

;
;  Lock Queue Structure Offset Definitions
;

LOCK_QUEUE_WAIT equ 00001H
LOCK_QUEUE_OWNER equ 00002H
LOCK_QUEUE_HEADER_SIZE equ 00010H


LqNext equ 00000H
LqLock equ 00008H

LqhNext equ 00000H
LqhLock equ 00008H
LqhOldIrql equ 00010H

;
;  Kernel Stack Control Structure Offset (relative to initial stack pointer) Definitions
;

KcPreviousBase equ 00028H
KcPreviousLimit equ 00030H
KcPreviousKernel equ 00038H
KcPreviousInitial equ 00040H

KERNEL_STACK_CONTROL_LARGE_STACK equ 00001H

;
;  Performance Definitions
;

PERF_CONTEXTSWAP_OFFSET equ 00004H
PERF_CONTEXTSWAP_FLAG equ 00004H
PERF_INTERRUPT_OFFSET equ 00004H
PERF_INTERRUPT_FLAG equ 04000H
PERF_PROFILE_OFFSET equ 00004H
PERF_PROFILE_FLAG equ 00002H
PERF_SYSCALL_OFFSET equ 00008H
PERF_SYSCALL_FLAG equ 00040H
PERF_SPINLOCK_OFFSET equ 00004H
PERF_SPINLOCK_FLAG equ 010000H
NTOS_YIELD_MACRO equ 00001H

;
;  ETW Definitions
;

ETW_SPINLOCK_BASIC equ 00000H
ETW_SPINLOCK_QUEUED equ 00001H

;
;  Hal enlightenment structure definitions
;

HeEnlightenments equ 00000H
HeHypervisorConnected equ 00004H
HeEndOfInterrupt equ 00008H
HeApicWriteIcr equ 00010H
HeSpinCountMask equ 0001CH
HeLongSpinWait equ 00020H

;
;  XState context structure offset definitions
;

XctxMask equ 00000H
XctxLength equ 00008H
XctxArea equ 00010H

;
;  GETSETCONTEXT structure offset definitions
;

GetSetCtxContextPtr equ 00078H
XSAVE_ALIGN equ 00040H

;
;  XSAVE_AREA structure offset definitions
;

XsaHeader equ 00200H
XsaHeaderLength equ 00040H
XSTATE_MASK_LEGACY_FLOATING_POINT equ 00001H
XSTATE_MASK_LEGACY_SSE equ 00002H
XSTATE_MASK_LEGACY equ 00003H
XSTATE_MASK_GSSE equ 00004H

;
;  Extended context structure offset definitions
;

CxxAllOffset equ 00000H
CxxAllLength equ 00004H
CxxLegacyOffset equ 00008H
CxxLegacyLength equ 0000CH
CxxXStateOffset equ 00010H
CxxXStateLength equ 00014H

;
;  KAFFINITY_EX offsets
;

AfCount equ 00000H
AfBitmap equ 00008H

;
;  Register Argument Home Address Offset Definitions
;

P1Home equ 00008H
P2Home equ 00010H
P3Home equ 00018H
P4Home equ 00020H

;
;  Apc Record Structure Offset Definitions
;

ArNormalRoutine equ 00000H
ArNormalContext equ 00008H
ArSystemArgument1 equ 00010H
ArSystemArgument2 equ 00018H
ApcRecordLength equ 00020H


;
;  Special Register Structure Offset Definition
;

SrKernelDr0 equ 00020H
SrKernelDr1 equ 00028H
SrKernelDr2 equ 00030H
SrKernelDr3 equ 00038H
SrKernelDr6 equ 00040H
SrKernelDr7 equ 00048H
SrGdtr equ 00050H
SrIdtr equ 00060H
SrTr equ 00070H
SrMxCsr equ 00074H
SrMsrGsBase equ 000A8H
SrMsrGsSwap equ 000B0H
SrMsrStar equ 000B8H
SrMsrLStar equ 000C0H
SrMsrCStar equ 000C8H
SrMsrSyscallMask equ 000D0H

;
;  Processor Control Region Structure Offset Definitions
;

PcGdt equ 00000H
PcTss equ 00008H
PcUserRsp equ 00010H
PcSelf equ 00018H
PcCurrentPrcb equ 00020H
PcLockArray equ 00028H
PcTeb equ 00030H
PcIdt equ 00038H
PcIrql equ 00050H
PcStallScaleFactor equ 00064H
PcHalReserved equ 000C0H
PcPrcb equ 00180H
PcMxCsr equ 00180H
PcInterruptRequest equ 00186H
PcIdleHalt equ 00187H
PcCurrentThread equ 00188H
PcNextThread equ 00190H
PcIdleThread equ 00198H
PcIpiFrozen equ 02284H
PcNestingLevel equ 001A0H
PcNumber equ 001A4H
PcRspBase equ 001A8H
PcPrcbLock equ 001B0H
PcGroup equ 007D8H
PcGroupSetMember equ 007E0H
PcCr0 equ 001C0H
PcCr2 equ 001C8H
PcCr3 equ 001D0H
PcCr4 equ 001D8H
PcKernelDr0 equ 001E0H
PcKernelDr1 equ 001E8H
PcKernelDr2 equ 001F0H
PcKernelDr3 equ 001F8H
PcKernelDr7 equ 00208H
PcGdtrLimit equ 00216H
PcGdtrBase equ 00218H
PcIdtrLimit equ 00226H
PcIdtrBase equ 00228H
PcTr equ 00230H
PcLdtr equ 00232H
PcDebugControl equ 00238H
PcLastBranchToRip equ 00240H
PcLastBranchFromRip equ 00248H
PcLastExceptionToRip equ 00250H
PcLastExceptionFromRip equ 00258H
PcCr8 equ 00260H
PcCpuType equ 00770H
PcCpuID equ 00771H
PcCpuStep equ 00772H
PcCpuVendor equ 007BDH
PcVirtualApicAssist equ 04BA8H
PcFeatureBits equ 04D48H
PcNmiActive equ 045E6H
CPU_AMD equ 00001H
CPU_INTEL equ 00002H
CPU_VIA equ 00003H
PcCFlushSize equ 007C4H
PcDeferredReadyListHead equ 02208H
PcSystemCalls equ 02238H
PcDpcRoutineActive equ 0235AH
PcInterruptCount equ 04880H
PcDebuggerSavedIRQL equ 04898H
PcTickOffset equ 045F0H
PcStartCycles equ 048C0H
ProcessorControlRegisterLength equ 08E40H

;
;  Defines for user shared data
;

USER_SHARED_DATA equ 0FFFFF78000000000H
MM_SHARED_USER_DATA_VA equ 07FFE0000H
PF_COMPARE_EXCHANGE128 equ 0000EH
UsTickCountMultiplier equ 00004H
UsInterruptTime equ 00008H
UsSystemTime equ 00014H
UsTestRetInstruction equ 002F8H
UsProcessorFeatures equ 00274H

;
;  Tss Structure Offset Definitions
;

TssRsp0 equ 00004H
TssRsp1 equ 0000CH
TssRsp2 equ 00014H
TssPanicStack equ 00024H
TssMcaStack equ 0002CH
TssNmiStack equ 00034H
TssIoMapBase equ 00066H
TssLength equ 00068H

;
;  Gdt Descriptor Offset Definitions
;

KGDT64_NULL equ 00000H
KGDT64_R0_CODE equ 00010H
KGDT64_R0_DATA equ 00018H
KGDT64_R3_CMCODE equ 00020H
KGDT64_R3_DATA equ 00028H
KGDT64_R3_CODE equ 00030H
KGDT64_SYS_TSS equ 00040H
KGDT64_R3_CMTEB equ 00050H
KGDT64_R0_LDT equ 00070H

;
;  GDT Entry Offset Definitions
;

KgdtBaseLow equ 00002H
KgdtBaseMiddle equ 00004H
KgdtBaseHigh equ 00007H
KgdtBaseUpper equ 00008H
KgdtLimitHigh equ 00006H
KgdtLimitLow equ 00000H
KGDT_LIMIT_ENCODE_MASK equ 03C00H


;
;  Processor Block Structure Offset Definitions
;

PbMxCsr equ 00000H
PbInterruptRequest equ 00006H
PbIdleHalt equ 00007H
PbCurrentThread equ 00008H
PbNextThread equ 00010H
PbIdleThread equ 00018H
PbNestingLevel equ 00020H
PbNumber equ 00024H
PbRspBase equ 00028H
PbPrcbLock equ 00030H
PbGroupSetMember equ 00660H
PbProcessorState equ 00040H
PbCpuType equ 005F0H
PbCpuID equ 005F1H
PbCpuStep equ 005F2H
PbHalReserved equ 005F8H
PbMinorVersion equ 00638H
PbMajorVersion equ 0063AH
PbBuildType equ 0063CH
PbCpuVendor equ 0063DH
PbCoresPerPhysicalProcessor equ 0063EH
PbLogicalProcessorsPerCore equ 0063FH
PbApicMask equ 00640H
PbCFlushSize equ 00644H
PbAcpiReserved equ 00648H
PbInitialApicId equ 00650H
PbStride equ 00654H
PbLockQueue equ 00670H
PbPPLookasideList equ 00780H
PbPPNPagedLookasideList equ 00880H
PbPPPagedLookasideList equ 01480H
PbPacketBarrier equ 02080H
PbDeferredReadyListHead equ 02088H
PbLookasideIrpFloat equ 020D8H
PbSystemCalls equ 020B8H
PbReadOperationCount equ 020DCH
PbWriteOperationCount equ 020E0H
PbOtherOperationCount equ 020E4H
PbReadTransferCount equ 020E8H
PbWriteTransferCount equ 020F0H
PbOtherTransferCount equ 020F8H
PbContextSwitches equ 020BCH
PbTargetCount equ 02100H
PbIpiFrozen equ 02104H
PbRequestMailbox equ 04C80H
PbMailbox equ 04C00H
PbDpcListHead equ 02180H
PbDpcLock equ 02190H
PbDpcCount equ 0219CH
PbDpcStack equ 021C0H
PbMaximumDpcQueueDepth equ 021C8H
PbDpcRequestRate equ 021CCH
PbMinimumDpcRate equ 021D0H
PbDpcRoutineActive equ 021DAH
PbNormalDpcState equ 021DCH
PbTickOffset equ 04470H
PbDpcLastCount equ 021D4H
PbQuantumEnd equ 021D9H
PbIdleSchedule equ 021DBH
PbReadySummary equ 04498H
PbDispatcherReadyListHead equ 04500H
PbInterruptCount equ 04700H
PbKernelTime equ 04704H
PbUserTime equ 04708H
PbDpcTime equ 0470CH
PbInterruptTime equ 04710H
PbAdjustDpcThreshold equ 04714H
PbParentNode equ 04738H
PbStartCycles equ 04740H
PbPageColor equ 04764H
PbNodeColor equ 04768H
PbNodeShiftedColor equ 0476CH
PbSecondaryColorMask equ 04770H
PbCycleTime equ 04778H
PbFastReadNoWait equ 020C0H
PbFastReadWait equ 020C4H
PbFastReadNotPossible equ 020C8H
PbCopyReadNoWait equ 020CCH
PbCopyReadWait equ 020D0H
PbCopyReadNoWaitMiss equ 020D4H
PbAlignmentFixupCount equ 04910H
PbExceptionDispatchCount equ 04734H
PbVendorString equ 04BB8H
ProcessorBlockLength equ 04D00H

;
;  Time Fields (TIME_FIELDS) Structure Offset Definitions
;

TfSecond equ 0000AH
TfMinute equ 00008H
TfHour equ 00006H
TfWeekday equ 0000EH
TfDay equ 00004H
TfMonth equ 00002H
TfYear equ 00000H
TfMilliseconds equ 0000CH


;
;  Define constants for system IRQL and IDT vector conversion
;

MAXIMUM_IDTVECTOR equ 000FFH
MAXIMUM_PRIMARY_VECTOR equ 000FFH
PRIMARY_VECTOR_BASE equ 00030H
RPL_MASK equ 00003H
MODE_BIT equ 00000H
MODE_MASK equ 00001H
LDT_MASK equ 00004H

;
;  Flags in the CR0 register
;

CR0_PG equ 080000000H
CR0_ET equ 00010H
CR0_TS equ 00008H
CR0_EM equ 00004H
CR0_MP equ 00002H
CR0_PE equ 00001H
CR0_CD equ 040000000H
CR0_NW equ 020000000H
CR0_AM equ 040000H
CR0_WP equ 010000H
CR0_NE equ 00020H

;
;  Flags in the CR4 register
;

CR4_VME equ 00001H
CR4_PVI equ 00002H
CR4_TSD equ 00004H
CR4_DE equ 00008H
CR4_PSE equ 00010H
CR4_PAE equ 00020H
CR4_MCE equ 00040H
CR4_PGE equ 00080H
CR4_FXSR equ 00200H
CR4_XMMEXCPT equ 00400H
CR4_XSAVE equ 040000H

;
;  Legacy Floating Status Bit Masks
;

FSW_INVALID_OPERATION equ 00001H
FSW_DENORMAL equ 00002H
FSW_ZERO_DIVIDE equ 00004H
FSW_OVERFLOW equ 00008H
FSW_UNDERFLOW equ 00010H
FSW_PRECISION equ 00020H
FSW_STACK_FAULT equ 00040H
FSW_ERROR_SUMMARY equ 00080H
FSW_CONDITION_CODE_0 equ 00100H
FSW_CONDITION_CODE_1 equ 00200H
FSW_CONDITION_CODE_2 equ 00400H
FSW_CONDITION_CODE_3 equ 04000H
FSW_ERROR_MASK equ 0003FH

;
;  MXCSR Floating Control/Status Bit Masks
;

XSW_INVALID_OPERATION equ 00001H
XSW_DENORMAL equ 00002H
XSW_ZERO_DIVIDE equ 00004H
XSW_OVERFLOW equ 00008H
XSW_UNDERFLOW equ 00010H
XSW_PRECISION equ 00020H
XSW_ERROR_MASK equ 0003FH
XSW_ERROR_SHIFT equ 00007H
XCW_INVALID_OPERATION equ 00080H
XCW_DENORMAL equ 00100H
XCW_ZERO_DIVIDE equ 00200H
XCW_OVERFLOW equ 00400H
XCW_UNDERFLOW equ 00800H
XCW_PRECISION equ 01000H
XCW_ROUND_CONTROL equ 06000H
XCW_FLUSH_ZERO equ 08000H
INITIAL_FPCSR equ 0027FH
INITIAL_MXCSR equ 01F80H

;
;  Machine Specific Register Numbers
;

MSR_EFER equ 0C0000080H
MSR_STAR equ 0C0000081H
MSR_LSTAR equ 0C0000082H
MSR_CSTAR equ 0C0000083H
MSR_SYSCALL_MASK equ 0C0000084H
MSR_FS_BASE equ 0C0000100H
MSR_GS_BASE equ 0C0000101H
MSR_GS_SWAP equ 0C0000102H
MSR_MCG_STATUS equ 0017AH
MSR_AMD_ACCESS equ 09C5A203AH

;
;  Flags within MSR_EFER
;

MSR_LMA equ 00400H
MSR_LME equ 00100H
MSR_SCE equ 00001H
MSR_NXE equ 00800H
MSR_PAT equ 00277H
MSR_DEBUG_CTL equ 001D9H

;
;  Flags within MSR_DEGUG_CTL
;

MSR_DEBUG_CTL_LBR equ 00001H
MSR_DEBUG_CTL_BTF equ 00002H

;
;  Miscellaneous Definitions
;

MAXIMUM_PROCESSORS equ 00040H
INITIAL_STALL_COUNT equ 00064H
IRQL_NOT_GREATER_OR_EQUAL equ 00009H
IRQL_NOT_LESS_OR_EQUAL equ 0000AH
MUTEX_ALREADY_OWNED equ 000BFH
THREAD_NOT_MUTEX_OWNER equ 00011H
SPIN_LOCK_ALREADY_OWNED equ 0000FH
SPIN_LOCK_NOT_OWNED equ 00010H
Executive equ 00000H
FALSE equ 00000H
TRUE equ 00001H
KERNEL_MCA_EXCEPTION_STACK_SIZE equ 02000H
NMI_STACK_SIZE equ 02000H
EXCEPTION_EXECUTE_FAULT equ 00008H
KCACHE_ERRATA_MONITOR_FLAGS equ 00003H
BASE_PRIORITY_THRESHOLD equ 00008H
EVENT_PAIR_INCREMENT equ 00001H
LOW_REALTIME_PRIORITY equ 00010H
BlackHole equ 0FFFFA000H
KERNEL_LARGE_STACK_COMMIT equ 06000H
KERNEL_LARGE_STACK_SIZE equ 012000H
KERNEL_STACK_SIZE equ 06000H
DOUBLE_FAULT_STACK_SIZE equ 02000H
BREAKPOINT_BREAK equ 00000H
BREAKPOINT_COMMAND_STRING equ 00005H
BREAKPOINT_PRINT equ 00001H
BREAKPOINT_PROMPT equ 00002H
BREAKPOINT_LOAD_SYMBOLS equ 00003H
BREAKPOINT_UNLOAD_SYMBOLS equ 00004H
CLOCK_QUANTUM_DECREMENT equ 00003H
READY_SKIP_QUANTUM equ 00002H
THREAD_QUANTUM equ 00006H
WAIT_QUANTUM_DECREMENT equ 00001H
ROUND_TRIP_DECREMENT_COUNT equ 00010H
KI_EXCEPTION_GP_FAULT equ 010000001H
KI_EXCEPTION_INVALID_OP equ 010000002H
KI_EXCEPTION_INTEGER_DIVIDE_BY_ZERO equ 010000003H
KI_EXCEPTION_ACCESS_VIOLATION equ 010000004H
TARGET_FREEZE equ 00005H
KI_DPC_INTERRUPT_FLAGS equ 0002FH

;
;  Equates for exceptions which cause system fatal error
;

EXCEPTION_DIVIDED_BY_ZERO equ 00000H
EXCEPTION_DEBUG equ 00001H
EXCEPTION_NMI equ 00002H
EXCEPTION_INT3 equ 00003H
EXCEPTION_BOUND_CHECK equ 00005H
EXCEPTION_INVALID_OPCODE equ 00006H
EXCEPTION_NPX_NOT_AVAILABLE equ 00007H
EXCEPTION_DOUBLE_FAULT equ 00008H
EXCEPTION_NPX_OVERRUN equ 00009H
EXCEPTION_INVALID_TSS equ 0000AH
EXCEPTION_SEGMENT_NOT_PRESENT equ 0000BH
EXCEPTION_STACK_FAULT equ 0000CH
EXCEPTION_GP_FAULT equ 0000DH
EXCEPTION_RESERVED_TRAP equ 0000FH
EXCEPTION_NPX_ERROR equ 00010H
EXCEPTION_ALIGNMENT_CHECK equ 00011H

;
;  Exception Frame Offset Definitions and Length
;

ExP1Home equ 00000H
ExP2Home equ 00008H
ExP3Home equ 00010H
ExP4Home equ 00018H
ExP5 equ 00020H
ExXmm6 equ 00030H
ExXmm7 equ 00040H
ExXmm8 equ 00050H
ExXmm9 equ 00060H
ExXmm10 equ 00070H
ExXmm11 equ 00080H
ExXmm12 equ 00090H
ExXmm13 equ 000A0H
ExXmm14 equ 000B0H
ExXmm15 equ 000C0H
ExMxCsr equ 000F0H
ExRbp equ 000F8H
ExRbx equ 00100H
ExRdi equ 00108H
ExRsi equ 00110H
ExR12 equ 00118H
ExR13 equ 00120H
ExR14 equ 00128H
ExR15 equ 00130H
ExReturn equ 00138H

KEXCEPTION_FRAME_LENGTH equ 00140H
EXCEPTION_RECORD_LENGTH equ 000A0H


;
;  Ums Context Header definitions and length
;

UcbUmsTeb equ 00080H
UchStackTop equ 00020H
UchStackSize equ 00028H
UchRspOffset equ 00030H
UchRip equ 00038H
UchTrapFrame equ 00050H
UchExceptionFrame equ 00058H
UchFltSave equ 00040H
UchFlags equ 00048H
KUMS_UCH_VOLATILE_BIT equ 00000H
KUMS_UCH_VOLATILE_MASK equ 00001H
KUMS_CONTEXT_HEADER_LENGTH equ 00070H


;
;  Jump Offset Definitions and Length
;

JbFrame equ 00000H
JbRbx equ 00008H
JbRsp equ 00010H
JbRbp equ 00018H
JbRsi equ 00020H
JbRdi equ 00028H
JbR12 equ 00030H
JbR13 equ 00038H
JbR14 equ 00040H
JbR15 equ 00048H
JbRip equ 00050H
JbMxCsr equ 00058H
JbFpCsr equ 0005CH
JbXmm6 equ 00060H
JbXmm7 equ 00070H
JbXmm8 equ 00080H
JbXmm9 equ 00090H
JbXmm10 equ 000A0H
JbXmm11 equ 000B0H
JbXmm12 equ 000C0H
JbXmm13 equ 000D0H
JbXmm14 equ 000E0H
JbXmm15 equ 000F0H

;
;  Switch Frame Offset Definitions and Length
;

SwP5Home equ 00020H
SwApcBypass equ 00028H
SwRbp equ 00030H
SwReturn equ 00038H

KSWITCH_FRAME_LENGTH equ 00040H

;
;  Start System Thread Frame Offset Definitions and Length
;

SfP1Home equ 00000H
SfP2Home equ 00008H
SfP3Home equ 00010H
SfP4Home equ 00018H
SfReturn equ 00028H

KSTART_FRAME_LENGTH equ 00030H

;
;  Trap Frame Offset and EFLAG Definitions and Length
;

EFLAGS_TF_MASK equ 00100H
EFLAGS_TF_SHIFT equ 00008H
EFLAGS_ID_MASK equ 0200000H
EFLAGS_IF_MASK equ 00200H
EFLAGS_IF_SHIFT equ 00009H

TrP1Home equ 0FFFFFF80H
TrP2Home equ 0FFFFFF88H
TrP3Home equ 0FFFFFF90H
TrP4Home equ 0FFFFFF98H
TrP5 equ 0FFFFFFA0H
TrPreviousMode equ 0FFFFFFA8H
TrPreviousIrql equ 0FFFFFFA9H
TrFaultIndicator equ 0FFFFFFAAH
TrExceptionActive equ 0FFFFFFABH
TrMxCsr equ 0FFFFFFACH
TrRax equ 0FFFFFFB0H
TrRcx equ 0FFFFFFB8H
TrRdx equ 0FFFFFFC0H
TrR8 equ 0FFFFFFC8H
TrR9 equ 0FFFFFFD0H
TrR10 equ 0FFFFFFD8H
TrR11 equ 0FFFFFFE0H
TrGsBase equ 0FFFFFFE8H
TrGsSwap equ 0FFFFFFE8H
TrXmm0 equ 0FFFFFFF0H
TrXmm1 equ 00000H
TrXmm2 equ 00010H
TrXmm3 equ 00020H
TrXmm4 equ 00030H
TrXmm5 equ 00040H
TrFaultAddress equ 00050H
TrTimeStampCKCL equ 00050H
TrDr0 equ 00058H
TrDr1 equ 00060H
TrDr2 equ 00068H
TrDr3 equ 00070H
TrDr6 equ 00078H
TrDr7 equ 00080H
TrDebugControl equ 00088H
TrLastBranchToRip equ 00090H
TrLastBranchFromRip equ 00098H
TrLastExceptionToRip equ 000A0H
TrLastExceptionFromRip equ 000A8H
TrLastBranchControl equ 00088H
TrLastBranchMSR equ 00090H
TrSegDs equ 000B0H
TrSegEs equ 000B2H
TrSegFs equ 000B4H
TrSegGs equ 000B6H
TrTrapFrame equ 000B8H
TrRbx equ 000C0H
TrRdi equ 000C8H
TrRsi equ 000D0H
TrRbp equ 000D8H
TrErrorCode equ 000E0H
TrTimeStampKlog equ 000E0H
TrRip equ 000E8H
TrSegCs equ 000F0H
TrLogging equ 000F3H
TrEFlags equ 000F8H
TrRsp equ 00100H
TrSegSs equ 00108H
TrCodePatchCycle equ 0010CH

KTRAP_FRAME_LENGTH equ 00190H

;
;  CPU information structure offset definitions
;

CpuEax equ 00000H
CpuEbx equ 00004H
CpuEcx equ 00008H
CpuEdx equ 0000CH

;
;  Usermode Callout User Frame Definitions
;

CkBuffer equ 00020H
CkLength equ 00028H
CkApiNumber equ 0002CH
CkRsp equ 00048H
CkRip equ 00030H
CalloutFrameLength equ 00058H

;
;  Machine Frame Offset Definitions
;

MfRip equ 00000H
MfSegCs equ 00008H
MfEFlags equ 00010H
MfRsp equ 00018H
MfSegSs equ 00020H
MachineFrameLength equ 00028H

;
;  DPC Stack Frame Defintions
;

DpRsp equ 00040H
DpRip equ 00028H

;
;  LPC Structure Offset Definitions
;

PmLength equ 00000H
PmZeroInit equ 00004H
PmClientId equ 00008H
PmProcess equ 00008H
PmThread equ 00010H
PmMessageId equ 00018H
PmClientViewSize equ 00020H
PortMessageLength equ 00028H

;
;  Client Id Structure Offset Definitions
;

CidUniqueProcess equ 00000H
CidUniqueThread equ 00008H

;
;  Context Frame Offset and Flag Definitions
;

CONTEXT_FULL equ 010000BH
CONTEXT_CONTROL equ 0100001H
CONTEXT_INTEGER equ 0100002H
CONTEXT_SEGMENTS equ 0100004H
CONTEXT_FLOATING_POINT equ 0100008H
CONTEXT_DEBUG_REGISTERS equ 0100010H
CONTEXT_XSTATE equ 0100020H

CxP1Home equ 00000H
CxP2Home equ 00008H
CxP3Home equ 00010H
CxP4Home equ 00018H
CxP5Home equ 00020H
CxP6Home equ 00028H
CxContextFlags equ 00030H
CxMxCsr equ 00034H
CxSegCs equ 00038H
CxSegDs equ 0003AH
CxSegEs equ 0003CH
CxSegFs equ 0003EH
CxSegGs equ 00040H
CxSegSs equ 00042H
CxEFlags equ 00044H
CxDr0 equ 00048H
CxDr1 equ 00050H
CxDr2 equ 00058H
CxDr3 equ 00060H
CxDr6 equ 00068H
CxDr7 equ 00070H
CxRax equ 00078H
CxRcx equ 00080H
CxRdx equ 00088H
CxRbx equ 00090H
CxRsp equ 00098H
CxRbp equ 000A0H
CxRsi equ 000A8H
CxRdi equ 000B0H
CxR8 equ 000B8H
CxR9 equ 000C0H
CxR10 equ 000C8H
CxR11 equ 000D0H
CxR12 equ 000D8H
CxR13 equ 000E0H
CxR14 equ 000E8H
CxR15 equ 000F0H
CxRip equ 000F8H
CxFltSave equ 00100H
CxXmm0 equ 001A0H
CxXmm1 equ 001B0H
CxXmm2 equ 001C0H
CxXmm3 equ 001D0H
CxXmm4 equ 001E0H
CxXmm5 equ 001F0H
CxXmm6 equ 00200H
CxXmm7 equ 00210H
CxXmm8 equ 00220H
CxXmm9 equ 00230H
CxXmm10 equ 00240H
CxXmm11 equ 00250H
CxXmm12 equ 00260H
CxXmm13 equ 00270H
CxXmm14 equ 00280H
CxXmm15 equ 00290H
CxDebugControl equ 004A8H
CxLastBranchToRip equ 004B0H
CxLastBranchFromRip equ 004B8H
CxLastExceptionToRip equ 004C0H
CxLastExceptionFromRip equ 004C8H
CxVectorControl equ 004A0H
CxVectorRegister equ 00300H
CONTEXT_FRAME_LENGTH equ 004D0H
CONTEXT_EX_LENGTH equ 00020H

;
;  Debug Control Register Masks
;

DR7_LEGAL equ 0FFFF0355H
DR7_ACTIVE equ 00355H
DR7_TRACE_BRANCH equ 00200H
DR7_LAST_BRANCH equ 00100H
DEBUG_ACTIVE_DR7 equ 00001H
DEBUG_ACTIVE_INSTRUMENTED equ 00002H
DEBUG_ACTIVE_DBG_INSTRUMENTED equ 00003H

;
;  Dispatcher Context Structure Offset Definitions
;

DcControlPc equ 00000H
DcImageBase equ 00008H
DcFunctionEntry equ 00010H
DcEstablisherFrame equ 00018H
DcTargetIp equ 00020H
DcContextRecord equ 00028H
DcLanguageHandler equ 00030H
DcHandlerData equ 00038H
DcHistoryTable equ 00040H
DcScopeIndex equ 00048H

;
;  Legacy Floating Save Area Structure Offset definitions
;

LfControlWord equ 00000H
LfStatusWord equ 00002H
LfTagWord equ 00004H
LfErrorOpcode equ 00006H
LfErrorOffset equ 00008H
LfErrorSelector equ 0000CH
LfDataOffset equ 00010H
LfDataSelector equ 00014H
LfMxCsr equ 00018H
LfMxCsr_Mask equ 0001CH
LfFloatRegisters equ 00020H


;
;  Kernel Stack Control Structure Offset (relative to initial stack pointer) Definitions
;

KcCurrentBase equ 00000H
KcCurrentLimit equ 00008H
KcActualLimit equ 00020H

;
;  Kernel stack area field offset definitions
;

SaNpxFrame equ 00050H
SaStackControl equ 00000H


;
;  Processor State Frame Offset Definitions
;

PsSpecialRegisters equ 00000H
PsCr0 equ 00000H
PsCr2 equ 00008H
PsCr3 equ 00010H
PsCr4 equ 00018H
PsKernelDr0 equ 00020H
PsKernelDr1 equ 00028H
PsKernelDr2 equ 00030H
PsKernelDr3 equ 00038H
PsKernelDr6 equ 00040H
PsKernelDr7 equ 00048H
PsGdtr equ 00056H
PsIdtr equ 00066H
PsTr equ 00070H
PsLdtr equ 00072H
PsMxCsr equ 00074H
PsContextFrame equ 000E0H
PsDebugControl equ 00078H
PsLastBranchToRip equ 00080H
PsLastBranchFromRip equ 00088H
PsLastExceptionToRip equ 00090H
PsLastExceptionFromRip equ 00098H
PsCr8 equ 000A0H
ProcessorStateLength equ 005B0H

;
;  Processor Start Block Offset Definitions
;

PsbCompletionFlag equ 00004H
PsbGdt32 equ 00008H
PsbIdt32 equ 0000EH
PsbGdt equ 00018H
PsbTiledCr3 equ 00058H
PsbPmTarget equ 00060H
PsbLmTarget equ 00070H
PsbLmIdentityTarget equ 00066H
PsbSelfMap equ 00078H
PsbMsrPat equ 00080H
PsbMsrEFER equ 00088H
PsbProcessorState equ 00090H
ProcessorStartBlockLength equ 00640H

;
;  KTHREAD
;

ThTebMappedLowVa equ 001B0H

;
;  KPROCESS
;

PrLdtSystemDescriptor equ 00108H
PrLdtBaseAddress equ 00118H

;
;  EPROCESS
;

EpDebugPort equ 001F0H

;
;  Machine type definitions (Temporarily)
;

MACHINE_TYPE_ISA equ 00000H
MACHINE_TYPE_EISA equ 00001H
MACHINE_TYPE_MCA equ 00002H

;
;  KeFeatureBits defines
;

KF_RDTSC equ 00002H
KF_CR4 equ 00004H
KF_GLOBAL_PAGE equ 00010H
KF_LARGE_PAGE equ 00020H
KF_CMPXCHG8B equ 00080H
KF_FAST_SYSCALL equ 01000H
KF_BRANCH equ 020000H
KF_XSTATE equ 0800000H

;
;  LoaderParameterBlock offsets relative to base
;

LpbLoadOrderListHead equ 00010H
LpbMemoryDescriptorListHead equ 00020H
LpbKernelStack equ 00040H
LpbPrcb equ 00048H
LpbProcess equ 00050H
LpbThread equ 00058H
LpbI386 equ 000C0H
LpbRegistryLength equ 00060H
LpbRegistryBase equ 00068H
LpbConfigurationRoot equ 00070H
LpbArcBootDeviceName equ 00078H
LpbArcHalDeviceName equ 00080H
LpbLoadOptions equ 00098H
PAGE_SIZE equ 01000H

;
;  Kernel Mode Callout Frame Definitions
;

CuInitialStack equ 00028H
CuTrapFrame equ 000D0H
CuCallbackStack equ 000D8H
CuOutputBuffer equ 000E0H
CuOutputLength equ 000E8H

;
;  Hypervisor Enlightenment Definitions
;

HV_MMU_USE_HYPERCALL_FOR_ADDRESS_SWITCH equ 00001H
HV_MMU_USE_HYPERCALL_FOR_LOCAL_FLUSH equ 00002H
HV_MMU_USE_HYPERCALL_FOR_REMOTE_FLUSH equ 00004H
HV_X64_MSR_EOI equ 040000070H
HV_APIC_ENLIGHTENED equ 00010H
HV_KE_USE_HYPERCALL_FOR_LONG_SPIN_WAIT equ 00040H
HV_VIRTUAL_APIC_NO_EOI_REQUIRED equ 00000H
HvApicFlags equ 00000H

;
;  IO Status Block Offset Definitions
;

IoStatus equ 00000H
IoPointer equ 00000H
IoInformation equ 00008H

;
;  Kernel Node Offset Definitions
;

KnRight equ 00078H
KnLeft equ 0007CH
KnColor equ 00059H
KnSeed equ 0005CH
KnNodeNumber equ 00054H
KnFlags equ 0005AH
knMmShiftedColor equ 00060H
KnFreeCount equ 00068H
KNODE_SIZE equ 000C0H

;
;  KAFFINITY_EX size
;

AffinityExLength equ 00028H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ktmtypes.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ktmtypes.h

Abstract:

    Common types for KTM exposed at both the Nt- and Win32-layer.

Revision History:

--*/

// begin_wdm begin_winnt
#ifndef _KTMTYPES_
#define _KTMTYPES_


#ifdef __cplusplus
extern "C" {
#endif


typedef GUID UOW, *PUOW;
typedef GUID CRM_PROTOCOL_ID, *PCRM_PROTOCOL_ID;

//
// Define the TransactionManager option values
//

#define TRANSACTION_MANAGER_VOLATILE              0x00000001
#define TRANSACTION_MANAGER_COMMIT_DEFAULT        0x00000000
#define TRANSACTION_MANAGER_COMMIT_SYSTEM_VOLUME  0x00000002
#define TRANSACTION_MANAGER_COMMIT_SYSTEM_HIVES   0x00000004
#define TRANSACTION_MANAGER_COMMIT_LOWEST         0x00000008
#define TRANSACTION_MANAGER_CORRUPT_FOR_RECOVERY  0x00000010
#define TRANSACTION_MANAGER_CORRUPT_FOR_PROGRESS  0x00000020
#define TRANSACTION_MANAGER_MAXIMUM_OPTION        0x0000003F


//
// Define the Transaction option values
//

#define TRANSACTION_DO_NOT_PROMOTE        0x00000001
#define TRANSACTION_MAXIMUM_OPTION        0x00000001


//
// Define the ResourceManager option values
//

#define RESOURCE_MANAGER_VOLATILE            0x00000001
#define RESOURCE_MANAGER_COMMUNICATION       0x00000002
#define RESOURCE_MANAGER_MAXIMUM_OPTION      0x00000003


//
// Define the RegisterProtocol option values
//

#define CRM_PROTOCOL_EXPLICIT_MARSHAL_ONLY      0x00000001
#define CRM_PROTOCOL_DYNAMIC_MARSHAL_INFO       0x00000002
#define CRM_PROTOCOL_MAXIMUM_OPTION             0x00000003


//
// Define the Enlistment option values
//

#define ENLISTMENT_SUPERIOR                  0x00000001
#define ENLISTMENT_MAXIMUM_OPTION            0x00000001


typedef ULONG NOTIFICATION_MASK;
#define TRANSACTION_NOTIFY_MASK                 0x3FFFFFFF
#define TRANSACTION_NOTIFY_PREPREPARE           0x00000001
#define TRANSACTION_NOTIFY_PREPARE              0x00000002
#define TRANSACTION_NOTIFY_COMMIT               0x00000004
#define TRANSACTION_NOTIFY_ROLLBACK             0x00000008
#define TRANSACTION_NOTIFY_PREPREPARE_COMPLETE  0x00000010
#define TRANSACTION_NOTIFY_PREPARE_COMPLETE     0x00000020
#define TRANSACTION_NOTIFY_COMMIT_COMPLETE      0x00000040
#define TRANSACTION_NOTIFY_ROLLBACK_COMPLETE    0x00000080
#define TRANSACTION_NOTIFY_RECOVER              0x00000100
#define TRANSACTION_NOTIFY_SINGLE_PHASE_COMMIT  0x00000200
#define TRANSACTION_NOTIFY_DELEGATE_COMMIT      0x00000400
#define TRANSACTION_NOTIFY_RECOVER_QUERY        0x00000800
#define TRANSACTION_NOTIFY_ENLIST_PREPREPARE    0x00001000
#define TRANSACTION_NOTIFY_LAST_RECOVER         0x00002000
#define TRANSACTION_NOTIFY_INDOUBT              0x00004000
#define TRANSACTION_NOTIFY_PROPAGATE_PULL       0x00008000
#define TRANSACTION_NOTIFY_PROPAGATE_PUSH       0x00010000
#define TRANSACTION_NOTIFY_MARSHAL              0x00020000
#define TRANSACTION_NOTIFY_ENLIST_MASK          0x00040000
#define TRANSACTION_NOTIFY_RM_DISCONNECTED      0x01000000
#define TRANSACTION_NOTIFY_TM_ONLINE            0x02000000
#define TRANSACTION_NOTIFY_COMMIT_REQUEST       0x04000000
#define TRANSACTION_NOTIFY_PROMOTE              0x08000000
#define TRANSACTION_NOTIFY_PROMOTE_NEW          0x10000000
#define TRANSACTION_NOTIFY_REQUEST_OUTCOME      0x20000000
//
//  Note that this flag is not included in the TRANSACTION_NOTIFY_MASK.
//  The reason being that KTM does not understand this flag yet. This
//  flag is strictly for the use of filter manager. In fact we mask it
//  out before enlisting in any transaction.
//
#define TRANSACTION_NOTIFY_COMMIT_FINALIZE      0x40000000 

//
// Path to the transaction manager objects in the NT
// object namespace.
//
#define TRANSACTIONMANAGER_OBJECT_PATH  L"\\TransactionManager\\"
#define TRANSACTION_OBJECT_PATH         L"\\Transaction\\"
#define ENLISTMENT_OBJECT_PATH          L"\\Enlistment\\"
#define RESOURCE_MANAGER_OBJECT_PATH    L"\\ResourceManager\\"

//
// The following three defines are here to ease the allocation
// of string buffers which are to contain a fully qualified 
// transaction manager object name, e.g., \Transaction\{GUID}
//
#define TRANSACTIONMANAGER_OBJECT_NAME_LENGTH_IN_BYTES      (sizeof(TRANSACTIONMANAGER_OBJECT_PATH)+(38*sizeof(WCHAR)))
#define TRANSACTION_OBJECT_NAME_LENGTH_IN_BYTES      (sizeof(TRANSACTION_OBJECT_PATH)+(38*sizeof(WCHAR)))
#define ENLISTMENT_OBJECT_NAME_LENGTH_IN_BYTES       (sizeof(ENLISTMENT_OBJECT_PATH)+(38*sizeof(WCHAR)))
#define RESOURCE_MANAGER_OBJECT_NAME_LENGTH_IN_BYTES (sizeof(RESOURCE_MANAGER_OBJECT_PATH)+(38*sizeof(WCHAR)))

// TODO: warning, duplicated def in tm.h.
typedef struct _TRANSACTION_NOTIFICATION {
    PVOID         TransactionKey;
    ULONG         TransactionNotification;
    LARGE_INTEGER TmVirtualClock;
    ULONG         ArgumentLength;
} TRANSACTION_NOTIFICATION, *PTRANSACTION_NOTIFICATION;

typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    GUID   EnlistmentId;
    UOW    UOW;
} TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT, *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;

#define TRANSACTION_NOTIFICATION_TM_ONLINE_FLAG_IS_CLUSTERED 0x1

typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    GUID TmIdentity;
    ULONG Flags;
} TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT, *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;

typedef ULONG SAVEPOINT_ID, *PSAVEPOINT_ID;

typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    SAVEPOINT_ID SavepointId;
} TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT, *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    ULONG PropagationCookie;
    GUID  UOW;
    GUID  TmIdentity;
    ULONG BufferLength;
    // Bufferlength bytes of Buffer follow
} TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    ULONG MarshalCookie;
    GUID  UOW;
} TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT, *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;

typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT;

#define KTM_MARSHAL_BLOB_VERSION_MAJOR 1
#define KTM_MARSHAL_BLOB_VERSION_MINOR 1

#define MAX_TRANSACTION_DESCRIPTION_LENGTH  64
#define MAX_RESOURCEMANAGER_DESCRIPTION_LENGTH  64

typedef struct _KCRM_MARSHAL_HEADER {
    ULONG              VersionMajor;
    ULONG              VersionMinor;
    ULONG              NumProtocols;
    ULONG              Unused;        // for alignment purposes
} KCRM_MARSHAL_HEADER, *PKCRM_MARSHAL_HEADER, *RESTRICTED_POINTER PRKCRM_MARSHAL_HEADER;

typedef struct _KCRM_TRANSACTION_BLOB {
    UOW                UOW;
    GUID               TmIdentity;
    ULONG              IsolationLevel;
    ULONG              IsolationFlags;
    ULONG              Timeout;
    WCHAR              Description[MAX_TRANSACTION_DESCRIPTION_LENGTH];
} KCRM_TRANSACTION_BLOB, *PKCRM_TRANSACTION_BLOB, *RESTRICTED_POINTER PRKCRM_TRANSACTION_BLOB;

typedef struct _KCRM_PROTOCOL_BLOB {
    CRM_PROTOCOL_ID    ProtocolId;
    __in_range (0,ULONG_MAX/2) ULONG StaticInfoLength;
    ULONG              TransactionIdInfoLength; //??? ProtocolDynamicInfoLength;
    ULONG              Unused1;        // for alignment purposes
    ULONG              Unused2;        // for alignment purposes
} KCRM_PROTOCOL_BLOB, *PKCRM_PROTOCOL_BLOB, *RESTRICTED_POINTER PRKCRM_PROTOCOL_BLOB;

#ifdef __cplusplus
}
#endif

#endif // _KTMTYPES_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ksuuids.h ===
//------------------------------------------------------------------------------
// File: ksuuids.h
//
// Desc: Contains the GUIDs for the MediaType type, subtype fields and format
//       types for DVD/MPEG2 media types.
//
// Copyright (c) Microsoft Corporation. All rights reserved.
//------------------------------------------------------------------------------


//
// --- MPEG 2 definitions ---
//

// 36523B13-8EE5-11d1-8CA3-0060B057664A
OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PACK,
0x36523B13, 0x8EE5, 0x11d1, 0x8C, 0xA3, 0x00, 0x60, 0xB0, 0x57, 0x66, 0x4A)

// e06d8020-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_MPEG2_PES,
0xe06d8020, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)


#if 0
DEFINE_GUID(MEDIATYPE_CONTROL,
0xe06d8021, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea);
#endif // #if 0

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

OUR_GUID_ENTRY( MEDIATYPE_MPEG2_SECTIONS,
    0x455f176c, 0x4b06, 0x47ce, 0x9a, 0xef, 0x8c, 0xae, 0xf7, 0x3d, 0xf7, 0xb5)

// {1ED988B0-3FFC-4523-8725-347BEEC1A8A0}
OUR_GUID_ENTRY( MEDIASUBTYPE_MPEG2_VERSIONED_TABLES,
    0x1ed988b0, 0x3ffc, 0x4523, 0x87, 0x25, 0x34, 0x7b, 0xee, 0xc1, 0xa8, 0xa0)

OUR_GUID_ENTRY(MEDIASUBTYPE_ATSC_SI,
0xb3c7397c, 0xd303, 0x414d, 0xb3, 0x3c, 0x4e, 0xd2, 0xc9, 0xd2, 0x97, 0x33)

OUR_GUID_ENTRY(MEDIASUBTYPE_DVB_SI,
0xe9dd31a3, 0x221d, 0x4adb, 0x85, 0x32, 0x9a, 0xf3, 0x9, 0xc1, 0xa4, 0x8)

OUR_GUID_ENTRY(MEDIASUBTYPE_ISDB_SI,
0xe89ad298, 0x3601, 0x4b06, 0xaa, 0xec, 0x9d, 0xde, 0xed, 0xcc, 0x5b, 0xd0)

// {EC232EB2-CB96-4191-B226-0EA129F38250}
OUR_GUID_ENTRY(MEDIASUBTYPE_TIF_SI,
0xec232eb2, 0xcb96, 0x4191, 0xb2, 0x26, 0xe, 0xa1, 0x29, 0xf3, 0x82, 0x50)

// {C892E55B-252D-42b5-A316-D997E7A5D995}
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2DATA,
0xc892e55b, 0x252d, 0x42b5, 0xa3, 0x16, 0xd9, 0x97, 0xe7, 0xa5, 0xd9, 0x95)

#endif

OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_WMDRM_TRANSPORT,
0x18BEC4EA, 0x4676, 0x450e, 0xB4, 0x78, 0x0C, 0xD8, 0x4C, 0x54, 0xB3, 0x27)

// e06d8026-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_VIDEO,
0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// use MPEG2VIDEOINFO (defined below) with FORMAT_MPEG2_VIDEO
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2_VIDEO,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea)

// F72A76A0-EB0A-11d0-ACE4-0000C0CC16BA       (FORMAT_VideoInfo2)
OUR_GUID_ENTRY(FORMAT_VIDEOINFO2,
0xf72a76A0L, 0xeb0a, 0x11d0, 0xac, 0xe4, 0x0, 0x0, 0xc0, 0xcc, 0x16, 0xba)

// MPEG2 Other subtypes
// e06d8022-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_PROGRAM,
0xe06d8022, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8023-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_TRANSPORT,
0xe06d8023, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

#if (NTDDI_VERSION >= NTDDI_WINXP)

// 138AA9A4-1EE2-4c5b-988E-19ABFDBC8A11
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_TRANSPORT_STRIDE,
0x138aa9a4, 0x1ee2, 0x4c5b, 0x98, 0x8e, 0x19, 0xab, 0xfd, 0xbc, 0x8a, 0x11)

// {18BEC4EA-4676-450e-B478-0CD84C54B327}
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_UDCR_TRANSPORT,
0x18BEC4EA, 0x4676, 0x450e, 0xB4, 0x78, 0x0C, 0xD8, 0x4C, 0x54, 0xB3, 0x27)

// {0d7aed42-cb9a-11db-9705-005056c00008}
OUR_GUID_ENTRY( MEDIASUBTYPE_MPEG2_PBDA_TRANSPORT_RAW, 
0x0d7aed42, 0xcb9a, 0x11db, 0x97, 0x5, 0x0, 0x50, 0x56, 0xc0, 0x0, 0x8 )

// {af748dd4-d800-11db-9705-005056c00008}
OUR_GUID_ENTRY ( MEDIASUBTYPE_MPEG2_PBDA_TRANSPORT_PROCESSED,
0xaf748dd4, 0xd80, 0x11db, 0x97, 0x5, 0x0, 0x50, 0x56, 0xc0, 0x0, 0x8 )

#endif

// e06d802b-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_MPEG2_AUDIO,
0xe06d802b, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802c-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DOLBY_AC3,
0xe06d802c, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802d-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_SUBPICTURE,
0xe06d802d, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8032-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_LPCM_AUDIO,
0xe06d8032, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

#if (NTDDI_VERSION >= NTDDI_WINXP)

// e06d8033-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DTS,
0xe06d8033, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8034-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_SDDS,
0xe06d8034, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

#endif

// DVD-related mediatypes
// ED0B916A-044D-11d1-AA78-00C04FC31D60
OUR_GUID_ENTRY(MEDIATYPE_DVD_ENCRYPTED_PACK,
0xed0b916a, 0x044d, 0x11d1, 0xaa, 0x78, 0x00, 0xc0, 0x04f, 0xc3, 0x1d, 0x60)

// e06d802e-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIATYPE_DVD_NAVIGATION,
0xe06d802e, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d802f-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PCI,
0xe06d802f, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8030-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_DSI,
0xe06d8030, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d8031-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER,
0xe06d8031, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

//
// DVD - MPEG2/AC3-related Formats
//
// e06d80e3-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Video,
0xe06d80e3, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e4-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DolbyAC3,
0xe06d80e4, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e5-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_MPEG2Audio,
0xe06d80e5, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)

// e06d80e6-db46-11cf-b4d1-00805f6cbbea
OUR_GUID_ENTRY(FORMAT_DVD_LPCMAudio,
0xe06d80e6, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x05f, 0x6c, 0xbb, 0xea)


//
// KS Property Set Id (to communicate with the WDM Proxy filter) -- from
// ksmedia.h of WDM DDK.
//

// BFABE720-6E1F-11D0-BCF2-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_AC3,
0xBFABE720, 0x6E1F, 0x11D0, 0xBC, 0xF2, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00)

// ac390460-43af-11d0-bd6a-003505c103a9
OUR_GUID_ENTRY(AM_KSPROPSETID_DvdSubPic,
0xac390460, 0x43af, 0x11d0, 0xbd, 0x6a, 0x00, 0x35, 0x05, 0xc1, 0x03, 0xa9)

// 0E8A0A40L-6AEF-11D0-9ED0-00A024CA19B3
OUR_GUID_ENTRY(AM_KSPROPSETID_CopyProt,
0x0E8A0A40, 0x6AEF, 0x11D0, 0x9E, 0xD0, 0x00, 0xA0, 0x24, 0xCA, 0x19, 0xB3)

// A503C5C0-1D1D-11d1-AD80-444553540000
OUR_GUID_ENTRY(AM_KSPROPSETID_TSRateChange,
0xa503c5c0, 0x1d1d, 0x11d1, 0xad, 0x80, 0x44, 0x45, 0x53, 0x54, 0x0, 0x0)

#if (NTDDI_VERSION >= NTDDI_WINXP)

// 3577EB09-9582-477f-B29C-B0C452A4FF9A
OUR_GUID_ENTRY(AM_KSPROPSETID_DVD_RateChange,
0x3577eb09, 0x9582, 0x477f, 0xb2, 0x9c, 0xb0, 0xc4, 0x52, 0xa4, 0xff, 0x9a)

// ae4720ae-aa71-42d8-b82a-fffdf58b76fd
OUR_GUID_ENTRY(AM_KSPROPSETID_DvdKaraoke,
0xae4720ae, 0xaa71, 0x42d8, 0xb8, 0x2a, 0xff, 0xfd, 0xf5, 0x8b, 0x76, 0xfd)

// c830acbd-ab07-492f-8852-45b6987c2979
OUR_GUID_ENTRY(AM_KSPROPSETID_FrameStep,
0xc830acbd, 0xab07, 0x492f, 0x88, 0x52, 0x45, 0xb6, 0x98, 0x7c, 0x29, 0x79)

#endif

// -----------------------------------------------
// MPEG4 related KSPROPSETIDs from ksmedia.h of WDK
// -----------------------------------------------

// FF6C4BFA-07A9-4c7b-A237-672F9D68065F
OUR_GUID_ENTRY(AM_KSPROPSETID_MPEG4_MediaType_Attributes,
0xff6c4bfa, 0x7a9, 0x4c7b, 0xa2, 0x37, 0x67, 0x2f, 0x9d, 0x68, 0x6, 0x5f)

//
// KS categories from ks.h and ksmedia.h
//
//

// 65E8773D-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_CAPTURE,
0x65E8773DL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 65E8773E-8F56-11D0-A3B9-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_RENDER,
0x65E8773EL, 0x8F56, 0x11D0, 0xA3, 0xB9, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 1E84C900-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_KSCATEGORY_DATACOMPRESSOR,
0x1E84C900L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)

// 6994AD04-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_AUDIO,
0x6994AD04L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 6994AD05-93EF-11D0-A3CC-00A0C9223196
OUR_GUID_ENTRY(AM_KSCATEGORY_VIDEO,
0x6994AD05L, 0x93EF, 0x11D0, 0xA3, 0xCC, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// a799a800-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVTUNER,
0xa799a800L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)

// a799a801-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_CROSSBAR,
0xa799a801L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)

// a799a802-a46d-11d0-a18c-00a02401dcd4
OUR_GUID_ENTRY(AM_KSCATEGORY_TVAUDIO,
0xa799a802L, 0xa46d, 0x11d0, 0xa1, 0x8c, 0x00, 0xa0, 0x24, 0x01, 0xdc, 0xd4)


// 07dad660L-22f1-11d1-a9f4-00c04fbbde8f
OUR_GUID_ENTRY(AM_KSCATEGORY_VBICODEC,
0x07dad660L, 0x22f1, 0x11d1, 0xa9, 0xf4, 0x00, 0xc0, 0x4f, 0xbb, 0xde, 0x8f)

#if (NTDDI_VERSION >= NTDDI_WS03SP1)
// multi-instance safe codec categories(kernel or user mode)
// {9C24A977-0951-451a-8006-0E49BD28CD5F}
OUR_GUID_ENTRY(AM_KSCATEGORY_VBICODEC_MI,
0x9c24a977, 0x951, 0x451a, 0x80, 0x6, 0xe, 0x49, 0xbd, 0x28, 0xcd, 0x5f)
#endif

// 0A4252A0L-7E70-11D0-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_KSCATEGORY_SPLITTER,
0x0A4252A0L, 0x7E70, 0x11D0, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)


//
// GUIDs needed to support IKsPin interface
//

// d3abc7e0l-9a61-11d0-a40d00a0c9223196
OUR_GUID_ENTRY(IID_IKsInterfaceHandler,
0xD3ABC7E0L, 0x9A61, 0x11D0, 0xA4, 0x0D, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 5ffbaa02l-49a3-11d0-9f3600aa00a216a1
OUR_GUID_ENTRY(IID_IKsDataTypeHandler,
0x5FFBAA02L, 0x49A3, 0x11D0, 0x9F, 0x36, 0x00, 0xAA, 0x00, 0xA2, 0x16, 0xA1)

// b61178d1-a2d9-11cf-9e53-00aa00a216a1
OUR_GUID_ENTRY(IID_IKsPin,
0xb61178d1L, 0xa2d9, 0x11cf, 0x9e, 0x53, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1)

// 28F54685-06FD-11D2-B27A-00A0C9223196
OUR_GUID_ENTRY(IID_IKsControl,
0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// CD5EBE6B-8B6E-11D1-8AE0-00A0C9223196
OUR_GUID_ENTRY(IID_IKsPinFactory,
0xCD5EBE6BL, 0x8B6E, 0x11D1, 0x8A, 0xE0, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96)

// 1A8766A0-62CE-11CF-A5D6-28DB04C10000
OUR_GUID_ENTRY(AM_INTERFACESETID_Standard,
0x1A8766A0L, 0x62CE, 0x11CF, 0xA5, 0xD6, 0x28, 0xDB, 0x04, 0xC1, 0x00, 0x00)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\KsProxy.h ===
/*++

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    ksproxy.h

Abstract:

    Interface definitions for WDM-CSA proxy filters.

--*/

#ifndef __KSPROXY__
#define __KSPROXY__

#ifdef __cplusplus
extern "C" {
#endif

#undef KSDDKAPI
#ifdef _KSDDK_
#define KSDDKAPI
#else // !_KSDDK_
#define KSDDKAPI DECLSPEC_IMPORT
#endif // _KSDDK_

#define STATIC_IID_IKsObject\
    0x423c13a2L, 0x2070, 0x11d0, 0x9e, 0xf7, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1

#define STATIC_IID_IKsPinEx\
    0x7bb38260L, 0xd19c, 0x11d2, 0xb3, 0x8a, 0x00, 0xa0, 0xc9, 0x5e, 0xc2, 0x2e

#define STATIC_IID_IKsPin\
    0xb61178d1L, 0xa2d9, 0x11cf, 0x9e, 0x53, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1
    
#define STATIC_IID_IKsPinPipe\
    0xe539cd90L, 0xa8b4, 0x11d1, 0x81, 0x89, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02

#define STATIC_IID_IKsDataTypeHandler\
    0x5ffbaa02L, 0x49a3, 0x11d0, 0x9f, 0x36, 0x00, 0xaa, 0x00, 0xa2, 0x16, 0xa1

#define STATIC_IID_IKsDataTypeCompletion\
    0x827D1A0EL, 0x0F73, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_IID_IKsInterfaceHandler\
    0xD3ABC7E0L, 0x9A61, 0x11D0, 0xA4, 0x0D, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_IID_IKsClockPropertySet\
    0x5C5CBD84L, 0xE755, 0x11D0, 0xAC, 0x18, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_IID_IKsAllocator\
    0x8da64899L, 0xc0d9, 0x11d0, 0x84, 0x13, 0x00, 0x00, 0xf8, 0x22, 0xfe, 0x8a
    
#define STATIC_IID_IKsAllocatorEx\
    0x091bb63aL, 0x603f, 0x11d1, 0xb0, 0x67, 0x00, 0xa0, 0xc9, 0x06, 0x28, 0x02
    

#ifndef STATIC_IID_IKsPropertySet
#define STATIC_IID_IKsPropertySet\
    0x31EFAC30L, 0x515C, 0x11d0, 0xA9, 0xAA, 0x00, 0xAA, 0x00, 0x61, 0xBE, 0x93
#endif // STATIC_IID_IKsPropertySet

#define STATIC_IID_IKsTopology\
    0x28F54683L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#ifndef STATIC_IID_IKsControl
#define STATIC_IID_IKsControl\
    0x28F54685L, 0x06FD, 0x11D2, 0xB2, 0x7A, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96
#endif // STATIC_IID_IKsControl

#define STATIC_IID_IKsAggregateControl\
    0x7F40EAC0L, 0x3947, 0x11D2, 0x87, 0x4E, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#define STATIC_CLSID_Proxy \
    0x17CCA71BL, 0xECD7, 0x11D0, 0xB9, 0x08, 0x00, 0xA0, 0xC9, 0x22, 0x31, 0x96

#ifdef _KS_

#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsObject);

DEFINE_GUIDEX(IID_IKsPin);

DEFINE_GUIDEX(IID_IKsPinEx);

DEFINE_GUIDEX(IID_IKsPinPipe);

DEFINE_GUIDEX(IID_IKsDataTypeHandler);

DEFINE_GUIDEX(IID_IKsDataTypeCompletion);

DEFINE_GUIDEX(IID_IKsInterfaceHandler);

DEFINE_GUIDEX(IID_IKsClockPropertySet);

DEFINE_GUIDEX(IID_IKsAllocator);

DEFINE_GUIDEX(IID_IKsAllocatorEx);

#define IID_IKsQualityForwarder KSCATEGORY_QUALITY
#endif // !defined(__cplusplus) || _MSC_VER < 1100

#define STATIC_IID_IKsQualityForwarder STATIC_KSCATEGORY_QUALITY

typedef enum {
    KsAllocatorMode_User,
    KsAllocatorMode_Kernel
} KSALLOCATORMODE;


typedef enum {
    FramingProp_Uninitialized,
    FramingProp_None,
    FramingProp_Old,
    FramingProp_Ex
} FRAMING_PROP;

typedef FRAMING_PROP *PFRAMING_PROP;


typedef enum {
    Framing_Cache_Update,     // request to bypass cache when read/write
    Framing_Cache_ReadLast,
    Framing_Cache_ReadOrig,
    Framing_Cache_Write
} FRAMING_CACHE_OPS;


typedef struct {
    LONGLONG     MinTotalNominator;  
    LONGLONG     MaxTotalNominator;
    LONGLONG     TotalDenominator;
} OPTIMAL_WEIGHT_TOTALS;

// forward declaration
typedef struct IPin IPin;
typedef struct IKsPin IKsPin;
typedef struct IKsAllocator IKsAllocator;
typedef struct IKsAllocatorEx IKsAllocatorEx;

                      
//
// allocators strategy is defined by graph manager
//
#define AllocatorStrategy_DontCare                      0

//
// what to optimize
//
#define AllocatorStrategy_MinimizeNumberOfFrames        0x00000001
#define AllocatorStrategy_MinimizeFrameSize             0x00000002
#define AllocatorStrategy_MinimizeNumberOfAllocators    0x00000004
#define AllocatorStrategy_MaximizeSpeed                 0x00000008 

//
// factors (flags) defining the Pipes properties
//
#define PipeFactor_None                   0
#define PipeFactor_UserModeUpstream       0x00000001
#define PipeFactor_UserModeDownstream     0x00000002
#define PipeFactor_MemoryTypes            0x00000004
#define PipeFactor_Flags                  0x00000008
#define PipeFactor_PhysicalRanges         0x00000010
#define PipeFactor_OptimalRanges          0x00000020
#define PipeFactor_FixedCompression       0x00000040
#define PipeFactor_UnknownCompression     0x00000080

#define PipeFactor_Buffers                0x00000100
#define PipeFactor_Align                  0x00000200

#define PipeFactor_PhysicalEnd            0x00000400
#define PipeFactor_LogicalEnd             0x00000800



typedef enum {
    PipeState_DontCare,
    PipeState_RangeNotFixed,
    PipeState_RangeFixed,
    PipeState_CompressionUnknown,
    PipeState_Finalized
} PIPE_STATE;


//
// pipe dimensions relative to BeginPin.
//

typedef struct _PIPE_DIMENSIONS {
    KS_COMPRESSION    AllocatorPin;
    KS_COMPRESSION    MaxExpansionPin;
    KS_COMPRESSION    EndPin;
} PIPE_DIMENSIONS, *PPIPE_DIMENSIONS;


typedef enum {
    Pipe_Allocator_None,
    Pipe_Allocator_FirstPin,
    Pipe_Allocator_LastPin,
    Pipe_Allocator_MiddlePin
} PIPE_ALLOCATOR_PLACE;

typedef PIPE_ALLOCATOR_PLACE  *PPIPE_ALLOCATOR_PLACE;


typedef enum {
    KS_MemoryTypeDontCare = 0,
    KS_MemoryTypeKernelPaged,
    KS_MemoryTypeKernelNonPaged,
    KS_MemoryTypeDeviceHostMapped,
    KS_MemoryTypeDeviceSpecific,
    KS_MemoryTypeUser,
    KS_MemoryTypeAnyHost
} KS_LogicalMemoryType;

typedef KS_LogicalMemoryType  *PKS_LogicalMemoryType;



typedef struct _PIPE_TERMINATION {
    ULONG                       Flags;
    ULONG                       OutsideFactors;
    ULONG                       Weigth;            // outside weight
    KS_FRAMING_RANGE            PhysicalRange;
    KS_FRAMING_RANGE_WEIGHTED   OptimalRange;      
    KS_COMPRESSION              Compression;       // relative to the connected pin on a neighboring filter.
} PIPE_TERMINATION;


//
// extended allocator properties 
//
typedef struct _ALLOCATOR_PROPERTIES_EX
    {
    long cBuffers;
    long cbBuffer;
    long cbAlign;
    long cbPrefix;
// new part
    GUID                       MemoryType;         
    GUID                       BusType;            // one of the buses this pipe is using
    PIPE_STATE                 State;                        
    PIPE_TERMINATION           Input;                        
    PIPE_TERMINATION           Output;                       
    ULONG                      Strategy;
    ULONG                      Flags;              
    ULONG                      Weight;
    KS_LogicalMemoryType       LogicalMemoryType;
    PIPE_ALLOCATOR_PLACE       AllocatorPlace;
    PIPE_DIMENSIONS            Dimensions;
    KS_FRAMING_RANGE           PhysicalRange;      // on allocator pin
    IKsAllocatorEx*            PrevSegment;        // doubly-linked list of KS allocators
    ULONG                      CountNextSegments;  // possible multiple dependent pipes
    IKsAllocatorEx**           NextSegments;
    ULONG                      InsideFactors;      // existing factors (different from "don't care")
    ULONG                      NumberPins;                   
} ALLOCATOR_PROPERTIES_EX;

typedef ALLOCATOR_PROPERTIES_EX *PALLOCATOR_PROPERTIES_EX;


#ifdef __STREAMS__

struct DECLSPEC_UUID("5C5CBD84-E755-11D0-AC18-00A0C9223196") IKsClockPropertySet;
#undef INTERFACE
#define INTERFACE IKsClockPropertySet
DECLARE_INTERFACE_(IKsClockPropertySet, IUnknown)
{
    STDMETHOD(KsGetTime)(
        THIS_
        __out LONGLONG* Time
    ) PURE;
    STDMETHOD(KsSetTime)(
        THIS_
        __in LONGLONG Time
    ) PURE;
    STDMETHOD(KsGetPhysicalTime)(
        THIS_
        __out LONGLONG* Time
    ) PURE;
    STDMETHOD(KsSetPhysicalTime)(
        THIS_
        __in LONGLONG Time
    ) PURE;
    STDMETHOD(KsGetCorrelatedTime)(
        THIS_
        __out KSCORRELATED_TIME* CorrelatedTime
    ) PURE;
    STDMETHOD(KsSetCorrelatedTime)(
        THIS_
        __in KSCORRELATED_TIME* CorrelatedTime
    ) PURE;
    STDMETHOD(KsGetCorrelatedPhysicalTime)(
        THIS_
        __out KSCORRELATED_TIME* CorrelatedTime
    ) PURE;
    STDMETHOD(KsSetCorrelatedPhysicalTime)(
        THIS_
        __in KSCORRELATED_TIME* CorrelatedTime
    ) PURE;
    STDMETHOD(KsGetResolution)(
        THIS_
        __out KSRESOLUTION* Resolution
    ) PURE;
    STDMETHOD(KsGetState)(
        THIS_
        __out KSSTATE* State
    ) PURE;
};


interface DECLSPEC_UUID("8da64899-c0d9-11d0-8413-0000f822fe8a") IKsAllocator;
#undef INTERFACE
#define INTERFACE IKsAllocator
DECLARE_INTERFACE_(IKsAllocator, IUnknown)
{
    STDMETHOD_(HANDLE, KsGetAllocatorHandle)(
        THIS
    ) PURE;
    STDMETHOD_(KSALLOCATORMODE, KsGetAllocatorMode)(
        THIS
    ) PURE;
    STDMETHOD(KsGetAllocatorStatus)(
        THIS_
        __out PKSSTREAMALLOCATOR_STATUS AllocatorStatus
    ) PURE;
    STDMETHOD_(VOID, KsSetAllocatorMode)(
        THIS_
        __in KSALLOCATORMODE Mode
    ) PURE;
};

interface DECLSPEC_UUID("091bb63a-603f-11d1-b067-00a0c9062802") IKsAllocatorEx;
#undef INTERFACE
#define INTERFACE IKsAllocatorEx
DECLARE_INTERFACE_(IKsAllocatorEx, IKsAllocator)
{
    STDMETHOD_(PALLOCATOR_PROPERTIES_EX, KsGetProperties)(
        THIS
    ) PURE;
    STDMETHOD_(VOID, KsSetProperties)(
        THIS_
        __in PALLOCATOR_PROPERTIES_EX 
    ) PURE;
    STDMETHOD_(VOID, KsSetAllocatorHandle)(
        THIS_
        __in HANDLE AllocatorHandle
    ) PURE;
    STDMETHOD_(HANDLE, KsCreateAllocatorAndGetHandle)(
        THIS_
        __in IKsPin*   KsPin
    ) PURE;
};  

typedef enum {
    KsPeekOperation_PeekOnly,
    KsPeekOperation_AddRef
} KSPEEKOPERATION;

typedef struct _KSSTREAM_SEGMENT *PKSSTREAM_SEGMENT;

interface DECLSPEC_UUID("b61178d1-a2d9-11cf-9e53-00aa00a216a1") IKsPin;

#undef INTERFACE
#define INTERFACE IKsPin
DECLARE_INTERFACE_(IKsPin, IUnknown)
{
    STDMETHOD(KsQueryMediums)(
        THIS_
        __deref_out PKSMULTIPLE_ITEM* MediumList
    ) PURE;
    STDMETHOD(KsQueryInterfaces)(
        THIS_
        __deref_out PKSMULTIPLE_ITEM* InterfaceList
    ) PURE;
    STDMETHOD(KsCreateSinkPinHandle)(
        THIS_
        __in KSPIN_INTERFACE& Interface,
        __in KSPIN_MEDIUM& Medium
    ) PURE;
    STDMETHOD(KsGetCurrentCommunication)(
        THIS_
        __out_opt KSPIN_COMMUNICATION *Communication,
        __out_opt KSPIN_INTERFACE *Interface,
        __out_opt KSPIN_MEDIUM *Medium
    ) PURE;
    STDMETHOD(KsPropagateAcquire)(
        THIS
    ) PURE;
    STDMETHOD(KsDeliver)(
        THIS_
        __in IMediaSample* Sample,
        __in ULONG Flags
    ) PURE;
    STDMETHOD(KsMediaSamplesCompleted)(
        THIS_
        __in PKSSTREAM_SEGMENT StreamSegment
    ) PURE;
    STDMETHOD_(IMemAllocator *, KsPeekAllocator)(
        THIS_
        __in KSPEEKOPERATION Operation
    ) PURE;
    STDMETHOD(KsReceiveAllocator)(
        THIS_
        __in_opt IMemAllocator *MemAllocator
    ) PURE;
    STDMETHOD(KsRenegotiateAllocator)(
        THIS
    ) PURE;
    STDMETHOD_(LONG, KsIncrementPendingIoCount)(
        THIS
    ) PURE;
    STDMETHOD_(LONG, KsDecrementPendingIoCount)(
        THIS
    ) PURE;
    STDMETHOD(KsQualityNotify)(
        THIS_
        __in ULONG Proportion,
        __in REFERENCE_TIME TimeDelta
    ) PURE;
};

interface DECLSPEC_UUID("7bb38260-d19c-11d2-b38a-00a0c95ec22e") IKsPinEx;
#undef INTERFACE
#define INTERFACE IKsPinEx
DECLARE_INTERFACE_(IKsPinEx, IKsPin)
{
    STDMETHOD_(VOID, KsNotifyError)(
        THIS_
        __in IMediaSample* Sample,
        __in HRESULT hr
    ) PURE;        
};
                         
interface DECLSPEC_UUID("e539cd90-a8b4-11d1-8189-00a0c9062802") IKsPinPipe;
#undef INTERFACE
#define INTERFACE IKsPinPipe
DECLARE_INTERFACE_(IKsPinPipe, IUnknown)
{
    STDMETHOD(KsGetPinFramingCache)(
        THIS_
        __out PKSALLOCATOR_FRAMING_EX *FramingEx,
        __out PFRAMING_PROP FramingProp,
        __in FRAMING_CACHE_OPS Option
    ) PURE;
    STDMETHOD(KsSetPinFramingCache)(
        THIS_
        __in PKSALLOCATOR_FRAMING_EX FramingEx,
        __in PFRAMING_PROP FramingProp,
        __in FRAMING_CACHE_OPS Option
    ) PURE;
    STDMETHOD_(IPin*, KsGetConnectedPin)(
        THIS
    ) PURE;
    STDMETHOD_(IKsAllocatorEx*, KsGetPipe)(
        THIS_
        __in KSPEEKOPERATION Operation
    ) PURE;
    STDMETHOD(KsSetPipe)(
        THIS_
        __in IKsAllocatorEx *KsAllocator
    ) PURE;
    STDMETHOD_(ULONG, KsGetPipeAllocatorFlag)(
        THIS
    ) PURE;
    STDMETHOD(KsSetPipeAllocatorFlag)(
        THIS_
        __in ULONG Flag
    ) PURE;
    STDMETHOD_(GUID, KsGetPinBusCache)(
        THIS
    ) PURE;
    STDMETHOD(KsSetPinBusCache)(
        THIS_
        __in GUID Bus
    ) PURE;
//
// very useful methods for tracing.
//
    STDMETHOD_(PWCHAR, KsGetPinName)(
        THIS
    ) PURE;
    STDMETHOD_(PWCHAR, KsGetFilterName)(
        THIS
    ) PURE;
};


interface DECLSPEC_UUID("CD5EBE6B-8B6E-11D1-8AE0-00A0C9223196") IKsPinFactory;
#undef INTERFACE
#define INTERFACE IKsPinFactory
DECLARE_INTERFACE_(IKsPinFactory, IUnknown)
{
    STDMETHOD(KsPinFactory)(
        THIS_
        __out ULONG* PinFactory
    ) PURE;
};

typedef enum {
    KsIoOperation_Write,
    KsIoOperation_Read
} KSIOOPERATION;

interface DECLSPEC_UUID("5ffbaa02-49a3-11d0-9f36-00aa00a216a1") IKsDataTypeHandler;
#undef INTERFACE
#define INTERFACE IKsDataTypeHandler
DECLARE_INTERFACE_(IKsDataTypeHandler, IUnknown)
{
    STDMETHOD(KsCompleteIoOperation)(
        THIS_
        __inout IMediaSample *Sample,
        __inout PVOID StreamHeader,
        __in KSIOOPERATION IoOperation,
        __in BOOL Cancelled
    ) PURE;
    STDMETHOD(KsIsMediaTypeInRanges)(
        THIS_
        __in PVOID DataRanges
        ) PURE;
    STDMETHOD(KsPrepareIoOperation)(
        THIS_
        __inout IMediaSample *Sample,
        __inout PVOID StreamHeader,
        __in KSIOOPERATION IoOperation
    ) PURE;
    STDMETHOD(KsQueryExtendedSize)(
        THIS_
        __out ULONG* ExtendedSize
    ) PURE;
    STDMETHOD(KsSetMediaType)(
        THIS_
        __in const AM_MEDIA_TYPE* AmMediaType
    ) PURE;
};

interface DECLSPEC_UUID("827D1A0E-0F73-11D2-B27A-00A0C9223196") IKsDataTypeCompletion;
#undef INTERFACE
#define INTERFACE IKsDataTypeCompletion
DECLARE_INTERFACE_(IKsDataTypeCompletion, IUnknown)
{
    STDMETHOD(KsCompleteMediaType)(
        THIS_
        __in HANDLE FilterHandle,
        __in ULONG PinFactoryId,
        __inout AM_MEDIA_TYPE* AmMediaType
    ) PURE;
};

interface DECLSPEC_UUID("D3ABC7E0-9A61-11d0-A40D-00A0C9223196") IKsInterfaceHandler;
#undef INTERFACE
#define INTERFACE IKsInterfaceHandler
DECLARE_INTERFACE_(IKsInterfaceHandler, IUnknown)
{
    STDMETHOD(KsSetPin)(
        THIS_
        __in IKsPin *KsPin
    ) PURE;
    STDMETHOD(KsProcessMediaSamples)(
        THIS_
        __in IKsDataTypeHandler *KsDataTypeHandler,
        __in_ecount(SampleCount) IMediaSample** SampleList,
        __inout PLONG SampleCount,
        __in KSIOOPERATION IoOperation,
        __out PKSSTREAM_SEGMENT *StreamSegment
    ) PURE;
    STDMETHOD(KsCompleteIo)(
        THIS_
        __inout PKSSTREAM_SEGMENT StreamSegment
    ) PURE;
};


//
// This structure definition is the common header required by the proxy to 
// dispatch the stream segment to the interface handler.  Interface handlers 
// will create extended structures to include other information such as 
// media samples, extended header size and so on.
//

typedef struct _KSSTREAM_SEGMENT {
    IKsInterfaceHandler     *KsInterfaceHandler;
    IKsDataTypeHandler      *KsDataTypeHandler;
    KSIOOPERATION           IoOperation;
    HANDLE                  CompletionEvent;
    
} KSSTREAM_SEGMENT;

interface DECLSPEC_UUID("423c13a2-2070-11d0-9ef7-00aa00a216a1") IKsObject;
#undef INTERFACE
#define INTERFACE IKsObject
DECLARE_INTERFACE_(IKsObject, IUnknown)
{
    STDMETHOD_(HANDLE, KsGetObjectHandle)(
        THIS
    ) PURE;
};

interface DECLSPEC_UUID("97ebaacb-95bd-11d0-a3ea-00a0c9223196") IKsQualityForwarder;
#undef INTERFACE
#define INTERFACE IKsQualityForwarder
DECLARE_INTERFACE_(IKsQualityForwarder, IKsObject)
{
    STDMETHOD_(VOID, KsFlushClient)(
        THIS_
        __in IKsPin* Pin
    ) PURE;
};

#if ( (NTDDI_VERSION >= NTDDI_WINXPSP2) && (NTDDI_VERSION < NTDDI_WS03) ) || (NTDDI_VERSION >= NTDDI_WS03SP1)

interface DECLSPEC_UUID("412bd695-f84b-46c1-ac73-54196dbc8fa7") IKsNotifyEvent;
#undef INTERFACE
#define INTERFACE IKsNotifyEvent
DECLARE_INTERFACE_(IKsNotifyEvent, IUnknown)
{
    STDMETHOD(KsNotifyEvent)(
        THIS_
        __in ULONG Event,
        __in ULONG_PTR lParam1,
        __in ULONG_PTR lParam2
    ) PURE;
};

#endif

KSDDKAPI
HRESULT
WINAPI
KsResolveRequiredAttributes(
    __in PKSDATARANGE DataRange,
    __in_opt PKSMULTIPLE_ITEM Attributes
    );

KSDDKAPI
HRESULT
WINAPI
KsOpenDefaultDevice(
    __in REFGUID Category,
    __in ACCESS_MASK Access,
    __out PHANDLE DeviceHandle
    );
KSDDKAPI
HRESULT
WINAPI
KsSynchronousDeviceControl(
    __in HANDLE      Handle,
    __in ULONG       IoControl,
    __in_bcount_opt(InLength) PVOID   InBuffer,
    __in ULONG       InLength,
    __out_bcount_opt(OutLength) PVOID  OutBuffer,
    __in ULONG       OutLength,
    __inout_opt PULONG BytesReturned
    );
KSDDKAPI
HRESULT
WINAPI
KsGetMultiplePinFactoryItems(
    __in HANDLE  FilterHandle,
    __in ULONG   PinFactoryId,
    __in ULONG   PropertyId,
    __deref_out PVOID*  Items
    );
KSDDKAPI
HRESULT
WINAPI
KsGetMediaTypeCount(
    __in HANDLE      FilterHandle,
    __in ULONG       PinFactoryId,
    __out ULONG*      MediaTypeCount
    );
KSDDKAPI
HRESULT
WINAPI
KsGetMediaType(
    __in int         Position,
    __out AM_MEDIA_TYPE* AmMediaType,
    __in HANDLE      FilterHandle,
    __in ULONG       PinFactoryId
    );

#endif // __STREAMS__

#ifndef _IKsPropertySet_
#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsPropertySet);
#endif // !defined(__cplusplus) || _MSC_VER < 1100
#endif // _IKsPropertySet_

#ifndef _IKsControl_
#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsControl);
#endif // !defined(__cplusplus) || _MSC_VER < 1100
#endif // _IKsControl_

#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsAggregateControl);
#endif // !defined(__cplusplus) || _MSC_VER < 1100

#ifndef _IKsTopology_
#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUIDEX(IID_IKsTopology);
#endif // !defined(__cplusplus) || _MSC_VER < 1100
#endif // _IKsTopology_

DEFINE_GUIDSTRUCT("17CCA71B-ECD7-11D0-B908-00A0C9223196", CLSID_Proxy);
#define CLSID_Proxy DEFINE_GUIDNAMED(CLSID_Proxy)

#else // !_KS_

#ifndef _IKsPropertySet_
#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUID(IID_IKsPropertySet, STATIC_IID_IKsPropertySet);
#endif // !defined(__cplusplus) || _MSC_VER < 1100
#endif // _IKsPropertySet_

#if !defined(__cplusplus) || _MSC_VER < 1100
DEFINE_GUID(CLSID_Proxy, STATIC_CLSID_Proxy);
#else  // defined(__cplusplus) && _MSC_VER >= 1100
DECLSPEC_UUID("17CCA71B-ECD7-11D0-B908-00A0C9223196") CLSID_Proxy;
#endif  // defined(__cplusplus) && _MSC_VER >= 1100

#endif // !_KS_

#ifndef _IKsPropertySet_
#define _IKsPropertySet_

#define KSPROPERTY_SUPPORT_GET 1
#define KSPROPERTY_SUPPORT_SET 2

#ifdef DECLARE_INTERFACE_

interface DECLSPEC_UUID("31EFAC30-515C-11d0-A9AA-00aa0061be93") IKsPropertySet;
#undef INTERFACE
#define INTERFACE IKsPropertySet
DECLARE_INTERFACE_(IKsPropertySet, IUnknown)
{
    STDMETHOD(Set)(
        THIS_
        __in REFGUID PropSet,
        __in ULONG Id,
        __in_bcount(InstanceLength) LPVOID InstanceData,
        __in ULONG InstanceLength,
        __in_bcount(DataLength) LPVOID PropertyData,
        __in ULONG DataLength
    ) PURE;

    STDMETHOD(Get)(
        THIS_
        __in REFGUID PropSet,
        __in ULONG Id,
        __in_bcount(InstanceLength) LPVOID InstanceData,
        __in ULONG InstanceLength,
        __out_bcount(DataLength) LPVOID PropertyData,
        __in ULONG DataLength,
        __out ULONG* BytesReturned
    ) PURE;

    STDMETHOD(QuerySupported)(
        THIS_
        __in REFGUID PropSet,
        __in ULONG Id,
        __out ULONG* TypeSupport
    ) PURE;
};

#endif // DECLARE_INTERFACE_

#endif // _IKsPropertySet_

#ifndef _IKsControl_
#define _IKsControl_

#ifdef DECLARE_INTERFACE_

interface DECLSPEC_UUID("28F54685-06FD-11D2-B27A-00A0C9223196") IKsControl;
#undef INTERFACE
#define INTERFACE IKsControl
DECLARE_INTERFACE_(IKsControl, IUnknown)
{
    STDMETHOD(KsProperty)(
        THIS_
        __in_bcount(PropertyLength) PKSPROPERTY Property,
        __in ULONG PropertyLength,
        __inout_bcount(DataLength) LPVOID PropertyData,
        __in ULONG DataLength,
        __inout_opt ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsMethod)(
        THIS_
        __in_bcount(MethodLength) PKSMETHOD Method,
        __in ULONG MethodLength,
        __inout_bcount(DataLength) LPVOID MethodData,
        __in ULONG DataLength,
        __inout_opt ULONG* BytesReturned
    ) PURE;
    STDMETHOD(KsEvent)(
        THIS_
        __in_bcount_opt(EventLength) PKSEVENT Event,
        __in ULONG EventLength,
        __inout_bcount(DataLength) LPVOID EventData,
        __in ULONG DataLength,
        __inout_opt ULONG* BytesReturned
    ) PURE;
};

#endif // DECLARE_INTERFACE_

#endif // _IKsControl_


#ifdef DECLARE_INTERFACE_

interface DECLSPEC_UUID("7F40EAC0-3947-11D2-874E-00A0C9223196") IKsAggregateControl;
#undef INTERFACE
#define INTERFACE IKsAggregateControl
DECLARE_INTERFACE_(IKsAggregateControl, IUnknown)
{
    STDMETHOD(KsAddAggregate)(
        THIS_
        __in REFGUID AggregateClass
    ) PURE;
    STDMETHOD(KsRemoveAggregate)(
        THIS_
        __in REFGUID AggregateClass
    ) PURE;
};

#endif // DECLARE_INTERFACE_

#ifndef _IKsTopology_
#define _IKsTopology_

#ifdef DECLARE_INTERFACE_

interface DECLSPEC_UUID("28F54683-06FD-11D2-B27A-00A0C9223196") IKsTopology;
#undef INTERFACE
#define INTERFACE IKsTopology
DECLARE_INTERFACE_(IKsTopology, IUnknown)
{
    STDMETHOD(CreateNodeInstance)(
        THIS_
        __in ULONG NodeId,
        __in ULONG Flags,
        __in ACCESS_MASK DesiredAccess,
        __in_opt IUnknown* UnkOuter,
        __in REFGUID InterfaceId,
        __out LPVOID* Interface
    ) PURE;
};

#endif // DECLARE_INTERFACE_

#endif // _IKsTopology_

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __KSPROXY__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\ktmw32.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ktmw32.h

Abstract:

    Public API include file for the TM subcomponent of the NTOS project

Author:

    Jon Cargille (jcargill) 5-Jun-2001

Revision History:

--*/

#ifndef _KTMUSER_
#define _KTMUSER_


#ifdef __cplusplus
extern "C" {
#endif


//
// Win32-level transaction manager API calls
//

HANDLE
APIENTRY
CreateTransaction (
    IN LPSECURITY_ATTRIBUTES lpTransactionAttributes OPTIONAL,
    IN LPGUID UOW OPTIONAL,
    IN DWORD CreateOptions OPTIONAL,
    IN DWORD IsolationLevel OPTIONAL,
    IN DWORD IsolationFlags OPTIONAL,
    IN DWORD Timeout OPTIONAL,
    __in_opt LPWSTR Description
    );

HANDLE
APIENTRY
OpenTransaction (
    IN DWORD dwDesiredAccess,
    IN LPGUID TransactionId
    );

BOOL
APIENTRY
CommitTransaction (
    IN HANDLE TransactionHandle
    );

BOOL
APIENTRY
CommitTransactionAsync (
    IN HANDLE TransactionHandle
    );

BOOL
APIENTRY
RollbackTransaction (
    IN HANDLE TransactionHandle
    );

BOOL
APIENTRY
RollbackTransactionAsync (
    IN HANDLE TransactionHandle
    );

BOOL
APIENTRY
GetTransactionId (
    IN HANDLE TransactionHandle,
    OUT LPGUID TransactionId
    );


BOOL
APIENTRY
GetTransactionInformation (
    IN HANDLE TransactionHandle,
    OUT PDWORD Outcome OPTIONAL,
    OUT PDWORD IsolationLevel OPTIONAL,
    OUT PDWORD IsolationFlags OPTIONAL,
    OUT PDWORD Timeout OPTIONAL,
    __in DWORD BufferLength,
    __out_ecount_part_opt(BufferLength, return + 1) LPWSTR Description
    );

BOOL
APIENTRY
SetTransactionInformation (
    IN HANDLE TransactionHandle,
    IN DWORD IsolationLevel OPTIONAL,
    IN DWORD IsolationFlags OPTIONAL,
    IN DWORD Timeout OPTIONAL,
    __in_opt LPWSTR Description
    );

HANDLE
APIENTRY
CreateTransactionManager (
    IN LPSECURITY_ATTRIBUTES lpTransactionAttributes OPTIONAL,
    __in LPWSTR LogFileName,
    IN ULONG CreateOptions OPTIONAL,
    IN ULONG CommitStrength OPTIONAL
    );

HANDLE
APIENTRY
OpenTransactionManager (
    __in LPWSTR LogFileName,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions OPTIONAL
    );

HANDLE
APIENTRY
OpenTransactionManagerById (
    __in LPGUID TransactionManagerId,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG OpenOptions OPTIONAL
    );

BOOL
APIENTRY
RenameTransactionManager (
    __in LPWSTR LogFileName,
    IN LPGUID ExistingTransactionManagerGuid
    );

BOOL
APIENTRY
RollforwardTransactionManager (
    IN HANDLE TransactionManagerHandle,
    IN PLARGE_INTEGER TmVirtualClock
    );

BOOL
APIENTRY
RecoverTransactionManager (
    IN HANDLE TransactionManagerHandle
    );

BOOL
GetCurrentClockTransactionManager(
    IN HANDLE TransactionManagerHandle,
    OUT PLARGE_INTEGER TmVirtualClock
    );

BOOL
GetTransactionManagerId(
    IN HANDLE TransactionManagerHandle,
    OUT LPGUID TransactionManagerId
    );

HANDLE
APIENTRY
CreateResourceManager (
    IN LPSECURITY_ATTRIBUTES lpResourceManagerAttributes OPTIONAL,
    IN LPGUID ResourceManagerId,
    IN DWORD CreateOptions OPTIONAL,
    IN HANDLE TmHandle,
    __in_opt LPWSTR Description
    );

HANDLE
APIENTRY
OpenResourceManager (
    IN DWORD dwDesiredAccess,
    IN HANDLE TmHandle,
    IN LPGUID ResourceManagerId
    );

BOOL
APIENTRY
RecoverResourceManager (
    IN HANDLE ResourceManagerHandle
    );

BOOL
APIENTRY
GetNotificationResourceManager (
    IN  HANDLE                          ResourceManagerHandle,
    OUT PTRANSACTION_NOTIFICATION       TransactionNotification,
    IN  ULONG                           NotificationLength,
    IN  DWORD                           dwMilliseconds OPTIONAL,
    OUT PULONG                          ReturnLength OPTIONAL
    );

BOOL
APIENTRY
GetNotificationResourceManagerAsync (
    IN  HANDLE                        ResourceManagerHandle,
    OUT PTRANSACTION_NOTIFICATION     TransactionNotification,
    IN  ULONG                         TransactionNotificationLength,
    OUT PULONG                        ReturnLength,
    IN  LPOVERLAPPED                  lpOverlapped
    );
    
BOOL
APIENTRY
SetResourceManagerCompletionPort(
    IN HANDLE    ResourceManagerHandle,
    IN HANDLE    IoCompletionPortHandle,
    IN ULONG_PTR CompletionKey
    );

HANDLE
APIENTRY
CreateEnlistment (
    IN LPSECURITY_ATTRIBUTES lpEnlistmentAttributes OPTIONAL,
    IN HANDLE            ResourceManagerHandle,
    IN HANDLE            TransactionHandle,
    IN NOTIFICATION_MASK NotificationMask,
    IN DWORD             CreateOptions OPTIONAL,
    IN PVOID             EnlistmentKey OPTIONAL
    );

HANDLE
APIENTRY
OpenEnlistment (
    IN DWORD              dwDesiredAccess,
    IN HANDLE             ResourceManagerHandle,
    IN LPGUID             EnlistmentId
    );


BOOL
APIENTRY
RecoverEnlistment (
    IN HANDLE EnlistmentHandle,
    IN PVOID EnlistmentKey OPTIONAL
    );


BOOL
APIENTRY
GetEnlistmentRecoveryInformation (
    IN  HANDLE EnlistmentHandle,
    IN  ULONG  BufferSize,
    OUT PVOID  Buffer,
    OUT PULONG BufferUsed OPTIONAL
    );

BOOL
APIENTRY
GetEnlistmentId (
    IN HANDLE EnlistmentHandle,
    OUT LPGUID EnlistmentId
    );

BOOL
APIENTRY
SetEnlistmentRecoveryInformation (
    IN HANDLE EnlistmentHandle,
    IN ULONG  BufferSize,
    IN PVOID  Buffer
    );

BOOL
APIENTRY
PrepareEnlistment (
    IN HANDLE EnlistmentHandle,
    IN PLARGE_INTEGER TmVirtualClock
    );

BOOL
APIENTRY
PrePrepareEnlistment (
    IN HANDLE EnlistmentHandle,
    IN PLARGE_INTEGER TmVirtualClock
    );

BOOL
APIENTRY
CommitEnlistment (
    IN HANDLE EnlistmentHandle,
    IN PLARGE_INTEGER TmVirtualClock
    );

BOOL
APIENTRY
RollbackEnlistment (
    IN HANDLE EnlistmentHandle,
    IN PLARGE_INTEGER TmVirtualClock
    );

BOOL
APIENTRY
PrePrepareComplete (
    IN  HANDLE            EnlistmentHandle,
    IN  PLARGE_INTEGER    TmVirtualClock
    );

BOOL
APIENTRY
PrepareComplete (
    IN  HANDLE            EnlistmentHandle,
    IN  PLARGE_INTEGER    TmVirtualClock
    );

BOOL
APIENTRY
ReadOnlyEnlistment (
    IN  HANDLE            EnlistmentHandle,
    IN  PLARGE_INTEGER    TmVirtualClock
    );

BOOL
APIENTRY
CommitComplete (
    IN  HANDLE            EnlistmentHandle,
    IN  PLARGE_INTEGER    TmVirtualClock
    );

BOOL
APIENTRY
RollbackComplete (
    IN  HANDLE            EnlistmentHandle,
    IN  PLARGE_INTEGER    TmVirtualClock
    );

BOOL
APIENTRY
SinglePhaseReject (
    IN  HANDLE            EnlistmentHandle,
    IN  PLARGE_INTEGER    TmVirtualClock
    );

#ifdef __cplusplus
}
#endif


#endif // _KTMUSER_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\kxia64.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects
*/
//++
//
// Module Name:
//
//  kxia64.h
//
// Abstract:
//
//  This module contains the nongenerated part of the IA64 assembler
//  header file. In general, it contains processor architecture constant
//  information, however some assembler macros are also included.
//
// Revision History:
//
//--

#define SHADOW_IRQL_IMPLEMENTATION 1

//
// N. B. Register aliases have been moved to ksia64.h (because we
// use assembler aliases not #define's)
//

// Register constants

// For setting non-rotating predicates (not used very much)

#define PS0 0x0001
#define PS1 0x0002
#define PS2 0x0004
#define PS3 0x0008
#define PS4 0x0010
#define PS5 0x0020

#define PRP 0x0080

#define PT0 0x0040
#define PT1 0x0100
#define PT2 0x0200
#define PT3 0x0400
#define PT4 0x0800
#define PT5 0x1000
#define PT6 0x2000
#define PT7 0x4000
#define PT8 0x8000

// For setting nomination register

#define NOM_BS0 0x0001
#define NOM_BS1 0x0002
#define NOM_BS2 0x0004
#define NOM_BS3 0x0008
#define NOM_BS4 0x0010
#define NOM_BS5 0x0020

#define NOM_BRP 0x0080

#define NOM_BT0 0x0040
#define NOM_BT1 0x0100
#define NOM_BT2 0x0200
#define NOM_BT3 0x0400
#define NOM_BT4 0x0800
#define NOM_BT5 0x1000
#define NOM_BT6 0x2000
#define NOM_BT7 0x4000
#define NOM_BT8 0x8000
//
//
// Define IA64 system registers.
//
// Define IA64 system register bit field offsets.
//
// Processor Status Register (PSR) Bit positions

// User / System mask
#define PSR_MBZ4    0
#define PSR_BE      1
#define PSR_UP      2
#define PSR_AC      3
#define PSR_MFL     4
#define PSR_MFH     5
// PSR bits 6-12 reserved (must be zero)
#define PSR_MBZ0    6
#define PSR_MBZ0_V  0x7fi64
// System only mask
#define PSR_IC      13
#define PSR_I       14
#define PSR_PK      15
#define PSR_MBZ1    16
#define PSR_MBZ1_V  0x1i64
#define PSR_DT      17
#define PSR_DFL     18
#define PSR_DFH     19
#define PSR_SP      20
#define PSR_PP      21
#define PSR_DI      22
#define PSR_SI      23
#define PSR_DB      24
#define PSR_LP      25
#define PSR_TB      26
#define PSR_RT      27
// PSR bits 28-31 reserved (must be zero)
#define PSR_MBZ2    28
#define PSR_MBZ2_V  0xfi64
// Neither mask
#define PSR_CPL     32
#define PSR_CPL_LEN 2
#define PSR_IS      34
#define PSR_MC      35
#define PSR_IT      36
#define PSR_ID      37
#define PSR_DA      38
#define PSR_DD      39
#define PSR_SS      40
#define PSR_RI      41
#define PSR_RI_LEN  2
#define PSR_ED      43
#define PSR_BN      44
#define PSR_IA      45
// PSR bits 46-63 reserved (must be zero)
#define PSR_MBZ3    46
#define PSR_MBZ3_V  0x3ffffi64

//
// Privilege levels
//

#define PL_KERNEL    0
#define PL_USER      3

//
// Instruction set (IS) bits
//

#define IS_EM        0
#define IS_IA        1

// Floating Point Status Register (FPSR) Bit positions

// Status Field 0 - Flags
#define FPSR_VD        0
#define FPSR_DD        1
#define FPSR_ZD        2
#define FPSR_OD        3
#define FPSR_UD        4
#define FPSR_ID        5
// Status Field 0 - Controls
#define FPSR_FTZ0      6
#define FPSR_WRE0      7
#define FPSR_PC0       8
#define FPSR_RC0       10
#define FPSR_TD0       12
// Status Field 0 - Flags
#define FPSR_V0        13
#define FPSR_D0        14
#define FPSR_Z0        15
#define FPSR_O0        16
#define FPSR_U0        17
#define FPSR_I0        18
// Status Field 1 - Controls
#define FPSR_FTZ1      19
#define FPSR_WRE1      20
#define FPSR_PC1       21
#define FPSR_RC1       23
#define FPSR_TD1       25
// Status Field 1 - Flags
#define FPSR_V1        26
#define FPSR_D1        27
#define FPSR_Z1        28
#define FPSR_O1        29
#define FPSR_U1        30
#define FPSR_I1        31
// Status Field 2 - Controls
#define FPSR_FTZ2      32
#define FPSR_WRE2      33
#define FPSR_PC2       34
#define FPSR_RC2       36
#define FPSR_TD2       38
// Status Field 2 - Flags
#define FPSR_V2        39
#define FPSR_D2        40
#define FPSR_Z2        41
#define FPSR_O2        42
#define FPSR_U2        43
#define FPSR_I2        44
// Status Field 3 - Controls
#define FPSR_FTZ3      45
#define FPSR_WRE3      46
#define FPSR_PC3       47
#define FPSR_RC3       49
#define FPSR_TD3       51
// Status Field 3 - Flags
#define FPSR_V3        52
#define FPSR_D3        53
#define FPSR_Z3        54
#define FPSR_O3        55
#define FPSR_U3        56
#define FPSR_I3        57
// FPSR bits 58-63 Reserved -- Must be zero
#define FPSR_MBZ0      58
#define FPSR_MBZ0_V    0x3fi64

//
// For setting up FPSR on kernel entry
//
// all FP exceptions masked
//
// rounding to nearest, 64-bit precision, wide range enabled for FPSR.fs1
//
// rounding to nearest, 53-bit precision, wide range disabled for FPSR.fs0
//

#define FPSR_FOR_KERNEL 0x9804C0270033F

//
// Define hardware Task Priority Register (TPR)
//
// TPR bit positions

// Bits 0 - 3 ignored
#define TPR_MIC        4
#define TPR_MIC_LEN    4
// Bits 8 - 15 reserved
// TPR.mmi is always 0 in NT
#define TPR_MMI        16
// Bits 17 - 63 ignored

//
// The current IRQL is maintained in the TPR.mic field. The
// shift count is the number of bits to shift right to extract the
// IRQL from the TPR. See the GET/SET_IRQL macros.
//

#define TPR_IRQL_SHIFT TPR_MIC

//
// To go from vector number <-> IRQL we just do a shift
//

#define VECTOR_IRQL_SHIFT TPR_IRQL_SHIFT

//
// Define hardware Interrupt Status Register (ISR)
//
// ISR bit positions

#define ISR_CODE       0
#define ISR_CODE_LEN   16
#define ISR_CODE_MASK  0xFFFF
#define ISR_NA_CODE_MASK  0xF
#define ISR_IA_VECTOR  16
#define ISR_IA_VECTOR_LEN 8
// ISR bits 24-31 reserved
#define ISR_MBZ0       24
#define ISR_MBZ0_V     0xff
#define ISR_X          32
#define ISR_W          33
#define ISR_R          34
#define ISR_NA         35
#define ISR_SP         36
#define ISR_RS         37
#define ISR_IR         38
#define ISR_NI         39
// ISR bit 40 reserved
#define ISR_MBZ1       40
#define ISR_EI         41
#define ISR_ED         43
// ISR bits 44-63 reserved
#define ISR_MBZ2       44
#define ISR_MBZ2_V     0xfffff

//
// ISR codes for Non-Access Instructions: ISR{3:0}
//

#define ISR_TPA            0        // tpa instruction
#define ISR_FC             1        // fc instruction
#define ISR_PROBE          2        // probe instruction
#define ISR_TAK            3        // tak instruction
#define ISR_LFETCH         4        // lfetch, lfetch.fault instruction
#define ISR_PROBE_FAULT    5        // probe.fault instruction

//
// ISR codes for General Exceptions: ISR{7:4}
//

#define ISR_ILLEGAL_OP     0        // Illegal operation fault
#define ISR_PRIV_OP        1        // Privileged operation fault
#define ISR_PRIV_REG       2        // Privileged register fault
#define ISR_RESVD_REG      3        // Reserved register/field fault
#define ISR_ILLEGAL_ISA    4        // Disabled instruction set transition fault
#define ISR_ILLEGAL_HAZARD 8        // Illegal hazard fault

//
// ISR codes for Nat Consumption Faults: ISR{7:4}
//

#define ISR_NAT_REG     1           // Nat Register Consumption fault
#define ISR_NAT_PAGE    2           // Nat Page Consumption fault

//
// For Traps ISR{3:0}
//

// FP trap
#define ISR_FP_TRAP    0
// Lower privilege transfer trap
#define ISR_LP_TRAP    1
// Taken branch trap
#define ISR_TB_TRAP    2
// Single step trap
#define ISR_SS_TRAP    3
// Unimplemented instruction address trap
#define ISR_UI_TRAP    4

//
// Define hardware Default Control Register (DCR)
//
// DCR bit positions

#define DCR_PP         0
#define DCR_BE         1
#define DCR_LC         2
// DCR bits 3-7 reserved
#define DCR_DM         8
#define DCR_DP         9
#define DCR_DK         10
#define DCR_DX         11
#define DCR_DR         12
#define DCR_DA         13
#define DCR_DD         14
#define DCR_DEFER_ALL  0x7f00
// DCR bits 16-63 reserved
#define DCR_MBZ1       2
#define DCR_MBZ1_V     0xffffffffffffi64

// Define hardware RSE Configuration Register
//
// RS Configuration (RSC) bit field positions

#define RSC_MODE       0
#define RSC_PL         2
#define RSC_BE         4
// RSC bits 5-15 reserved
#define RSC_MBZ0       5
#define RSC_MBZ0_V     0x3ff
#define RSC_LOADRS     16
#define RSC_LOADRS_LEN 14
// RSC bits 30-63 reserved
#define RSC_MBZ1       30
#define RSC_MBZ1_LEN   34
#define RSC_MBZ1_V     0x3ffffffffi64

// RSC modes
// Lazy
#define RSC_MODE_LY (0x0)
// Store intensive
#define RSC_MODE_SI (0x1)
// Load intensive
#define RSC_MODE_LI (0x2)
// Eager
#define RSC_MODE_EA (0x3)

// RSC Endian bit values
#define RSC_BE_LITTLE 0
#define RSC_BE_BIG    1

// RSC while in kernel: enabled, little endian, pl = 0, eager mode
#define RSC_KERNEL ((RSC_MODE_EA<<RSC_MODE) | (RSC_BE_LITTLE<<RSC_BE))
// RSE disabled: disabled, pl = 0, little endian, eager mode
#define RSC_KERNEL_DISABLED ((RSC_MODE_LY<<RSC_MODE) | (RSC_BE_LITTLE<<RSC_BE))

//
// Define Interruption Function State (IFS) Register
//
// IFS bit field positions
//

#define IFS_IFM        0
#define IFS_IFM_LEN    38
#define IFS_MBZ0       38
#define IFS_MBZ0_V     0x1ffffffi64
#define IFS_V          63
#define IFS_V_LEN      1

//
// IFS is valid when IFS_V = IFS_VALID
//

#define IFS_VALID      1

//
// define the width of each size field in PFS/IFS
//

#define PFS_PPL                  62         // pfs.ppl bit location
#define PFS_PPL_LEN              PSR_CPL_LEN
#define PFS_EC_SHIFT             52
#define PFS_EC_SIZE              6
#define PFS_EC_MASK              0x3F
#define PFS_SIZE_SHIFT           7
#define PFS_SIZE_MASK            0x7F
#define NAT_BITS_PER_RNAT_REG    63
#define RNAT_ALIGNMENT           (NAT_BITS_PER_RNAT_REG << 3)

//
// Define Region Register (RR)
//
// RR bit field positions
//

#define RR_VE          0
#define RR_MBZ0        1
#define RR_PS          2
#define RR_PS_LEN      6
#define RR_RID         8
#define RR_RID_LEN     24
#define RR_MBZ1        32

//
// indirect mov index for loading RR
//

#define RR_INDEX       61
#define RR_INDEX_LEN   3

//
// Define low order 8 bit's of RR. All RR's have same PS and VE
//

#define RR_PS_VE  ( (PAGE_SHIFT<<RR_PS) | (1<<RR_VE) )

//
// Number of region registers used by NT
//

#define NT_RR_SIZE 4

//
// Total number of region registers
//

#define RR_SIZE 8

//
// Define Protection Key Register (PKR)
//
// PKR bit field positions
//

#define PKR_V          0
#define PKR_WD         1
#define PKR_RD         2
#define PKR_XD         3
#define PKR_MBZ0       4
#define PKR_KEY        8
#define PKR_KEY_LEN    24
#define PKR_MBZ1       32

//
// Define low order 8 bit's of PKR. All valid PKR's have same V, WD, RD, XD
//

#define PKR_VALID  (1<<PKR_V)

//
// Number of protection key registers
//

#define PKRNUM 16

//
// Define Interrupt TLB Insertion Register
//
// ITIR bit field positions
//

#define ITIR_RV0       0
#define ITIR_PS        2
#define ITIR_KEY       8
#define ITIR_RV1       32

//
// The following definitions are obsolete but
// there are codes in ke/ia64 reference them.
//
// Define Interruption Translation Register (IDTR/IITR)
//
// IDTR/IITR bit field positions
//

#define IDTR_MBZ0      0
#define IDTR_PS        2
#define IDTR_KEY       8
#define IDTR_MBZ1      32
#define IDTR_IGN0      48
#define IDTR_PPN       56
#define IDTR_MBZ2      63

#define IITR_MBZ0      IDTR_MBZ0
#define IITR_PS        IDTR_PS
#define IITR_KEY       IDTR_KEY
#define IITR_MBZ1      IDTR_MBZ1
#define IITR_IGN0      IDTR_IGN0
#define IITR_PPN       IDTR_PPN
#define IITR_MBZ2      IDTR_MBZ2

//
// ITIR  bit field masks

#define IITR_PPN_MASK              0x7FFF000000000000
#define IITR_ATTRIBUTE_PPN_MASK    0x0003FFFFFFFFF000

//
// Define Translation Insertion Format (TR)
//
// TR bit field positions
//

#define TR_P           0
#define TR_RV0         1
#define TR_MA          2
#define TR_A           5
#define TR_D           6
#define TR_PL          7
#define TR_AR          9
#define TR_PPN         13          // must be same as PAGE_SHIFT
#define TR_RV1         50
#define TR_ED          52
#define TR_IGN0        53

//
// Macros for generating TR value
//
#define TR_VALUE(ed, ppn, ar, pl, d, a, ma, p)        \
                ( ( ed << TR_ED )                  |  \
                  ( ppn & IITR_ATTRIBUTE_PPN_MASK) |  \
                  ( ar << TR_AR )                  |  \
                  ( pl << TR_PL )                  |  \
                  ( d << TR_D )                    |  \
                  ( a << TR_A )                    |  \
                  ( ma << TR_MA )                  |  \
                  ( p << TR_P )                       \
                )

#define ITIR_VALUE(key, ps)                                             \
                ( ( ps << ITIR_PS )                                  |  \
                  ( key << ITIR_KEY )                                   \
                )

//
// Page size definitions
//
#define PS_4K        0xC             // 0xC=12, 2^12=4K
#define PS_8K        0xD             // 0xD=13, 2^13=8K
#define PS_16K       0xE             // 0xE=14, 2^14=16K
#define PS_64K       0x10            // 0x10=16, 2^16=64K
#define PS_256K      0x12            // 0x12=18, 2^18=256K
#define PS_1M        0x14            // 0x14=20, 2^20=1M
#define PS_4M        0x16            // 0x16=22, 2^22=4M
#define PS_16M       0x18            // 0x18=24, 2^24=16M
#define PS_64M       0x1a            // 0x1a=26, 2^26=64M
#define PS_256M      0x1c            // 0x1a=26, 2^26=64M

//
// Debug Registers definitions
//

//
// At least, 4 data and 4 instruction register pairs are implemented
// on all processor models.
//
#define NUMBER_OF_DEBUG_REGISTER_PAIRS    4

//
// For the break conditions (mask):
//

#define DR_MASK      0         // Mask
#define DR_MASK_LEN  56        // Mask length
#define DR_PLM0      56        // Enable privlege level 0
#define DR_PLM1      57        // Enable privlege level 1
#define DR_PLM2      58        // Enable privlege level 2
#define DR_PLM3      59        // Enable privlege level 3 (user)
#define DR_IG        60        // Ignore
#define DR_RW        62        // Read/Write
#define DR_RW_LEN     2        // R/W length
#define DR_X         63        // Execute

//
// Performance Monitor Registers definitions
//

//
// At least, 4 data and 4 instruction register pairs are implemented
// on all processor models.
//
#define NUMBER_OF_PERFMON_REGISTER_PAIRS    4

//
// Macro to generate mask value from bit position
// N.B. If this macro is used in a C expression and the result is a
// 64-bit, the "value" argument shoud be cast as "unsigned long long" to
// produce a 64-bit mask.
//

#define MASK_IA64(bp,value)  (value << bp)

//
// Interrupt Vector Definitions
//

#define APC_VECTOR          APC_LEVEL << VECTOR_IRQL_SHIFT
#define DISPATCH_VECTOR     DISPATCH_LEVEL << VECTOR_IRQL_SHIFT

//
// Define interruption vector offsets
//

#define OFFSET_VECTOR_BREAK         0x2800  // Break instruction vector
#define OFFSET_VECTOR_EXT_INTERRUPT 0x2c00  // External interrupt vector
#define OFFSET_VECTOR_EXC_GENERAL   0x4400  // General exception vector

//
//
// Define IA64 page mask values.
//
#define PAGEMASK_4KB 0x0                // 4kb page
#define PAGEMASK_16KB 0x3               // 16kb page
#define PAGEMASK_64KB 0xf               // 64kb page
#define PAGEMASK_256KB 0x3f             // 256kb page
#define PAGEMASK_1MB 0xff               // 1mb page
#define PAGEMASK_4MB 0x3ff              // 4mb page
#define PAGEMASK_16MB 0xfff             // 16mb page

//
// Define IA64 primary cache states.
//
#define PRIMARY_CACHE_INVALID 0x0       // primary cache invalid
#define PRIMARY_CACHE_SHARED 0x1        // primary cache shared (clean or dirty)
#define PRIMARY_CACHE_CLEAN_EXCLUSIVE 0x2 // primary cache clean exclusive
#define PRIMARY_CACHE_DIRTY_EXCLUSIVE 0x3 // primary cache dirty exclusive

//
// Page table constants
//

#define PS_SHIFT         2
#define PS_LEN           6
#define PTE_VALID_MASK   1
#define PTE_ACCESS_MASK  0x20
#define PTE_NOCACHE      0x10
#define PTE_CACHE_SHIFT  2
#define PTE_CACHE_LEN    3
#define PTE_LARGE_PAGE   54
#define PTE_PFN_SHIFT    8
#define PTE_PFN_LEN      24
#define PTE_ATTR_SHIFT   1
#define PTE_ATTR_LEN     5
#define PTE_PS           55
#define PTE_OFFSET_LEN   10
#define PDE_OFFSET_LEN   10
#define VFN_LEN          19
#define VFN_LEN64        24
#define TB_USER_MASK     0x180
#define PTE_DIRTY_MASK   0x40
#define PTE_WRITE_MASK   0x400
#define PTE_EXECUTE_MASK 0x200
#define PTE_CACHE_MASK   0x0
#define PTE_EXC_DEFER 0x10000000000000

#define VALID_KERNEL_PTE (PTE_VALID_MASK|PTE_ACCESS_MASK|PTE_WRITE_MASK|PTE_CACHE_MASK|PTE_DIRTY_MASK)
#define VALID_KERNEL_EXECUTE_PTE (PTE_VALID_MASK|PTE_ACCESS_MASK|PTE_EXECUTE_MASK|PTE_WRITE_MASK|PTE_CACHE_MASK|PTE_DIRTY_MASK|PTE_EXC_DEFER)
#define PTE_VALID        0
#define PTE_ACCESS       5
#define PTE_OWNER        7
#define PTE_WRITE        10
#define PTE_LP_CACHE_SHIFT    53
#define ATE_INDIRECT     62
#define ATE_MASK         0xFFFFFFFFFFFFF9DE
#define ATE_MASK0        0x621
#define PAGE4K_SHIFT     12
#define ALT4KB_BASE 0x6FC00000000
#define ALT4KB_END  0x6FC00800000

#define VRN_SHIFT        61
#define KSEG3_VRN        4
#define KSEG4_VRN        5
#define MAX_PHYSICAL_SHIFT 44

//
// Translation register usage
//

//
// In NTLDR
//

//
// Boot loader CONFIGFLAG definitions.
//

#define DISABLE_TAR_FIX           0
#define DISABLE_BTB_FIX           1
#define DISABLE_DATA_BP_FIX       2
#define DISABLE_DET_STALL_FIX     3
#define ENABLE_FULL_DISPERSAL     4
#define ENABLE_TB_BROADCAST       5
#define DISABLE_CPL_FIX           6
#define ENABLE_POWER_MANAGEMENT   7
#define DISABLE_IA32BR_FIX        8
#define DISABLE_L1_BYPASS         9
#define DISABLE_VHPT_WALKER      10
#define DISABLE_IA32RSB_FIX      11
#define DISABLE_INTERRUPTION_LOG 13
#define DISABLE_UNSAFE_FILL      14
#define DISABLE_STORE_UPDATE     15
#define ENABLE_HISTORY_BUFFER    16

#define BL_4M                0x00400000
#define BL_16M               0x01000000
#define BL_20M               0x01400000
#define BL_24M               0x01800000
#define BL_28M               0x01C00000
#define BL_32M               0x02000000
#define BL_36M               0x02400000
#define BL_40M               0x02800000
#define BL_48M               0x03000000
#define BL_64M               0x04000000
#define BL_80M               0x05000000
#define BL_128M              0x08000000

#define TR_INFO_TABLE_SIZE   10

//
// DTRs used by NTOSKRNL
//

#define DTR_KIPCR_INDEX      0
#define DTR_KERNEL_INDEX     1
#define DTR_KTBASE_INDEX     2
#define DTR_UTBASE_INDEX     3
#define DTR_STBASE_INDEX     4
#define DTR_PAL_INDEX        6
#define DTR_UTBASE_INDEX_TMP 7        // freed during the phase 0 init

//
// ITRs used by NTOSKRNL
//

#define ITR_EPC_INDEX        0
#define ITR_KERNEL_INDEX     1
#define ITR_PAL_INDEX        4

//
// Indexes into the HalReserved portion of PCR
//

#define SIZE_OF_HALRESERVED_ENTRY           8
#define PHYSICAL_SALEVENTRESOURCE_OFFSET     ( 31 * SIZE_OF_HALRESERVED_ENTRY )
 
//
// MCA recovery action hints 
//

#define MCA_CONTEXT_BAD             0x1
#define MCA_POISON_MEMORY           0x2

#define MEM_4K         0x1000
#define MEM_8K         0x2000
#define MEM_16K        0x4000
#define MEM_64K        0x10000
#define MEM_256K       0x40000
#define MEM_1M         0x100000
#define MEM_4M         0x400000
#define MEM_16M        0x1000000
#define MEM_64M        0x4000000
#define MEM_256M       0x10000000

//
// Macro for translation memory size in bytes to page size in TR format
//
#define MEM_SIZE_TO_PS(MemSize, TrPageSize)             \
                if (MemSize <= MEM_4K) {                \
                    TrPageSize = PS_4K;                 \
                } else if (MemSize <= MEM_8K)       {   \
                    TrPageSize = PS_8K;                 \
                } else if (MemSize <= MEM_16K)      {   \
                    TrPageSize = PS_16K;                \
                } else if (MemSize <= MEM_64K)      {   \
                    TrPageSize = PS_64K;                \
                } else if (MemSize <= MEM_256K)     {   \
                    TrPageSize = PS_256K;               \
                } else if (MemSize <= MEM_1M)       {   \
                    TrPageSize = PS_1M;                 \
                } else if (MemSize <= MEM_4M)       {   \
                    TrPageSize = PS_4M;                 \
                } else if (MemSize <= MEM_16M)      {   \
                    TrPageSize = PS_16M;                \
                } else if (MemSize <= MEM_64M)      {   \
                    TrPageSize = PS_64M;                \
                } else if (MemSize <= MEM_256M)     {   \
                    TrPageSize = PS_256M;               \
                }

//
// TLB forward progress queue
//

#define NUMBER_OF_FWP_ENTRIES 8

//
// Initial value of DCR (64-bits)
// res              rv dd da dr dx dk dp dm res   lc be pp
// 0x000000000000   0  1  1  1  1  1  1  0  00000 1  0  1
//
#define DCR_INITIAL 0x0000000000007e05

//
// Initial value of user PSR (64-bits)
// Bits 63-32
// res                     bn ed ri ss dd da id it mc is cpl
// 0000 0000 0000 0000 000 1   0 00 0  0  0  0  1  0  0  11
// Bits 31-0
// res  rt tb lp db si di pp sp dfh dfl dt rv pk i ic res        mfh mfl ac up be res
// 0000 1  0  0  0  0  0  1  0  1   0   1  0  0  1 1  0 0000 00  0   0   1  0  0  0
//
#define USER_PSR_INITIAL 0x00001013082a6008i64

//
// Initial value of user FPSR (64-bits)
//
// all FP exceptions masked
//
// rounding to nearest, 64-bit precision, wide range enabled for FPSR.fs1
//
// rounding to nearest, 53-bit precision, wide range disabled for FPSR.fs0
//

#define USER_FPSR_INITIAL 0x9804C0270033F

//
// Initial value of DCR (64-bits)
// res             dd da dr dx dk dp dm res   lc be pp
// 0x000000000000   1  1  1  1  1  1  1  00000 1  0  1
//
#define USER_DCR_INITIAL 0x0000000000007f05i64

//
// Initial value of user RSC (low 32-bits)
// Mode: Lazy. Little endian. User PL.
//
#define USER_RSC_INITIAL ((RSC_MODE_LY<<RSC_MODE) \
                          | (RSC_BE_LITTLE<<RSC_BE) \
                          | (0x3<<RSC_PL))

//
// Definitions that used by CSD and SSD
//

#define USER_CODE_DESCRIPTOR  0xCFBFFFFF00000000   
#define USER_DATA_DESCRIPTOR  0xCF3FFFFF00000000

//
//
// IA64 Software conventions
//

// Bytes in stack scratch area
#define STACK_SCRATCH_AREA  16

//
// Constants for trap
//

// Bits to shift for computing interrupt routine funtion pointer: fp = base + irql<<INT_ROUTINE_SHIFT

#ifdef _WIN64
#define INT_ROUTINES_SHIFT 3
#else
#define INT_ROUTINES_SHIFT 2
#endif

//
//
// Define disable and restore interrupt macros.
// Note: Serialization is implicit for rsm
//

#define DISABLE_INTERRUPTS(reg) \
         mov       reg = psr                    ;\
         rsm       1 << PSR_I

//
// Restore psr.i bit based on value of bit PSR_I in reg
// Enable does not do serialization, so interrupts may not be enabeld for
// a number of cycles after ssm.
//

#define RESTORE_INTERRUPTS(reg)  \
         tbit##.##nz   pt0,pt1 = reg, PSR_I;;   ;\
(pt0)    ssm       1 << PSR_I                   ;\
(pt1)    rsm       1 << PSR_I

//
// The FAST versions can be used when it is not necessary to save/restore
// the previous interrupt enable state.
//

#define FAST_DISABLE_INTERRUPTS \
         rsm       1 << PSR_I

//
// FAST ENABLE does not do serialization -- we don't care if interrupt
// enable is not visible for few instructions.
//

#define FAST_ENABLE_INTERRUPTS \
         ssm       1 << PSR_I

#define YIELD   hint##.##m 0

//
//
// Define TB and cache parameters.
//
#define PCR_ENTRY 0                     // TB entry numbers (2) for the PCR
#define PDR_ENTRY 2                     // TB entry number (1) for the PDR
#define LARGE_ENTRY 3                   // TB entry number (1) for large entry
#define DMA_ENTRY 4                     // TB entry number (1) for DMA/InterruptSource

#define TB_ENTRY_SIZE (3 * 4)           // size of TB entry
#define FIXED_BASE 0                    // base index of fixed TB entries
#define FIXED_ENTRIES (DMA_ENTRY + 1)   // number of fixed TB entries

//
// Define cache parameters
//

#define DCACHE_SIZE 4 * 1024            // size of data cache in bytes
#define ICACHE_SIZE 4 * 1024            // size of instruction cache in bytes
#define MINIMUM_CACHE_SIZE 4 * 1024     // minimum size of cache
#define MAXIMUM_CACHE_SIZE 128 * 1024   // maximum size fo cache

//
// RID and Sequence number limits.
// Start with 1 because 0 means not initialized.
// RID's are 24 bits.
//

#define KSEG3_RID          0x00000
#define START_GLOBAL_RID   0x00001
#define START_SESSION_RID  0x00003
#define START_PROCESS_RID  0x00004

//
// making the maximum RID to 18-bit, temp fix for Merced
//

#define MAXIMUM_RID        0x3FFFF

//
// Sequence numbers are 32 bits
// Start with 1 because 0 means not initialized.
//

#define START_SEQUENCE     1
#define MAXIMUM_SEQUENCE   0xFFFFFFFFFFFFFFFF

//
//
// Define subtitle macro
//

#define SBTTL(x)

//
// Define procedure entry macros
//

#define PROLOGUE_BEGIN     .##prologue;
#define PROLOGUE_END       .##body;

#define ALTERNATE_ENTRY(Name)                    \
         .##global Name;                         \
         .##type   Name, @function;              \
Name::

#define CPUBLIC_LEAF_ENTRY(Name,i)               \
         .##text;                                \
         .##proc   Name##@##i;                   \
Name##@##i::

#define LEAF_ENTRY(Name)                         \
         .##text;                                \
         .##global Name;                         \
         .##proc   Name;                         \
Name::

#define LEAF_SETUP(i,l,o,r)                      \
         .##regstk i,l,o,r;                      \
         alloc     r31=ar##.##pfs,i,l,o,r

#define CPUBLIC_NESTED_ENTRY(Name,i)             \
         .##text;                                \
         .##proc   Name##@##i;                   \
         .##unwentry;                            \
Name##@##i::

#define NESTED_ENTRY_EX(Name, Handler)           \
         .##text;                                \
         .##global Name;                         \
         .##proc   Name;                         \
         .##personality Handler;                 \
Name::

#define NESTED_ENTRY(Name)                       \
         .##text;                                \
         .##global Name;                         \
         .##proc   Name;                         \
Name::

// Note: use of NESTED_SETUP requires number of locals (l) >= 2

#define NESTED_SETUP(i,l,o,r)                    \
         .##regstk i,l,o,r;                      \
         .##prologue 0xC, loc0;                  \
         alloc     savedpfs=ar##.##pfs,i,l,o,r  ;\
         mov       savedbrp=brp;

//
// Define procedure exit macros
//

#define LEAF_RETURN                              \
         br##.##ret##.##sptk##.##few##.##clr brp

#define NESTED_RETURN                            \
         mov       ar##.##pfs = savedpfs;        \
         mov       brp = savedbrp;               \
         br##.##ret##.##sptk##.##few##.##clr brp

#define LEAF_EXIT(Name)                          \
         .##endp Name;

#define NESTED_EXIT(Name)                        \
         .##endp Name;


//++
// Routine:
//
//       LDPTR(rD, rPtr)
//
// Routine Description:
//
//       load pointer value.
//
// Agruments:
//
//       rD:     destination register
//       rPtr: register containing pointer
//
// Return Value:
//
//       rD = load from address [rPtr]
//
// Notes:
//
//       rPtr is unchanged
//
//--

#ifdef  _WIN64
#define LDPTR(rD, rPtr) \
       ld8        rD = [rPtr]
#else
#define LDPTR(rD, rPtr) \
       ld4        rD = [rPtr] ;\
       ;;                     ;\
       sxt4       rD = rD
#endif

//++
// Routine:
//
//       LDPTRINC(rD, rPtr, imm)
//
// Routine Description:
//
//       load pointer value and update base.
//
// Agruments:
//
//       rD:     destination register
//       rPtr: register containing pointer
//       imm:  number to be incremented to base
//
// Return Value:
//
//       rD = load from address [rPtr] and rPtr += imm
//
// Notes:
//
//--

#ifdef  _WIN64
#define LDPTRINC(rD, rPtr, imm) \
       ld8        rD = [rPtr], imm
#else
#define LDPTRINC(rD, rPtr, imm) \
       ld4        rD = [rPtr], imm ;\
       ;;                     ;\
       sxt4       rD = rD
#endif

//++
// Routine:
//
//       PLDPTRINC(rP, rD, rPtr, imm)
//
// Routine Description:
//
//       predicated load pointer value and update base.
//
// Agruments:
//
//       rP:   predicate register
//       rD:   destination register
//       rPtr: register containing pointer
//       imm:  number to be incremented to base
//
// Return Value:
//
//       if (rP) rD = load from address [rPtr] and rPtr += imm
//
// Notes:
//
//--

#ifdef  _WIN64
#define PLDPTRINC(rP, rD, rPtr, imm) \
(rP)   ld8        rD = [rPtr], imm
#else
#define PLDPTRINC(rP, rD, rPtr, imm) \
(rP)   ld4        rD = [rPtr], imm ;\
       ;;                     ;\
(rP)   sxt4       rD = rD
#endif

//++
// Routine:
//
//       PLDPTR(rP, rD, rPtr)
//
// Routine Description:
//
//       predicated load pointer value.
//
// Agruments:
//
//       rP:   predicate register
//       rD:   destination register
//       rPtr: register containing pointer
//
// Return Value:
//
//       if (rP == 1)  rD = load from address [rPtr], else NO-OP
//
// Notes:
//
//       rPtr is unchanged
//
//--

#ifdef  _WIN64
#define PLDPTR(rP, rD, rPtr) \
(rP)    ld8       rD = [rPtr]
#else
#define PLDPTR(rP, rD, rPtr) \
(rP)    ld4       rD = [rPtr] ;\
       ;;                     ;\
(rP)    sxt4      rD = rD
#endif

//++
// Routine:
//
//       STPTR(rPtr, rS)
//
// Routine Description:
//
//       store pointer value.
//
// Agruments:
//
//       rPtr: register containing pointer
//       rS  : source pointer value
//
// Return Value:
//
//       store [rPtr] = rS
//
// Notes:
//
//       rPtr is unchanged
//
//--

#ifdef  _WIN64
#define STPTR(rPtr, rS) \
       st8        [rPtr] = rS
#else
#define STPTR(rPtr, rS) \
       st4        [rPtr] = rS
#endif

//++
// Routine:
//
//       PSTPTR(rP, rPtr, rS)
//
// Routine Description:
//
//       predicated store pointer value.
//
// Agruments:
//
//       rP:   predicate register
//       rPtr: register containing pointer
//       rS  : source pointer value
//
// Return Value:
//
//       if (rP)  store [rPtr] = rS
//
// Notes:
//
//       rPtr is unchanged
//
//--

#ifdef  _WIN64
#define PSTPTR(rP, rPtr, rS) \
(rP)   st8        [rPtr] = rS
#else
#define PSTPTR(rP, rPtr, rS) \
(rP)   st4        [rPtr] = rS
#endif

//++
// Routine:
//
//       STPTRINC(rPtr, rS, imm)
//
// Routine Description:
//
//       store pointer value.
//
// Agruments:
//
//       rPtr: register containing pointer
//       rS  : source pointer value
//       imm:  number to be incremented to base
//
// Return Value:
//
//       if (rP) store [rPtr] = rS, rPtr += imm
//
// Notes:
//
//--

#ifdef  _WIN64
#define STPTRINC(rPtr, rS, imm) \
       st8        [rPtr] = rS, imm
#else
#define STPTRINC(rPtr, rS, imm) \
       st4        [rPtr] = rS, imm
#endif

//++
// Routine:
//
//       ARGPTR(rPtr)
//
// Routine Description:
//
//       sign extend the pointer argument for WIN32
//
// Agruments:
//
//       rPtr: register containing pointer argument
//
// Return Value:
//
//
// Notes:
//
//
//
//--

#ifdef  _WIN64
#define ARGPTR(rPtr)
#else
#define ARGPTR(rPtr) \
        sxt4      rPtr = rPtr
#endif


//
// Assembler spinlock macros
//

//++
// Routine:
//
//       SPINLOCK_LOG_PRE_ACQUIRE(rPrcb, rLog, rStartTime, rIntCount)
//
// Routine Description:
//
//       spinlock logging processing prior to spinlock acquisition.
//
// Agruments:
//
//       rPrcb: pointer to the current PRCB.
//       rLog: predicate to hold the logging status
//       rStartTime: register to hold the current time.
//       rIntCount: register to hold the current interrupt count in PRCB.
//
// Return Value:
//
//       rLog: 1 if spinlock logging is enabled, 0 if it is disabled.
//       rStartTime: current time.
//       rIntCount: current interrupt count in PRCB.
//
// Notes:
//
//       Uses temporaries: GRs t21, t22. GR t1 is used but is preserved.
//--

#define SPINLOCK_LOG_PRE_ACQUIRE(rPrcb, rLog, rStartTime, rIntCount)           \
         mov           t21 = t1                                               ;\
         movl          t22 = PerfGlobalGroupMask+PERF_SPINLOCK_OFFSET         ;\
         ;;                                                                   ;\
         add           rIntCount = PbInterruptCount, rPrcb                    ;\
         ld4           t22 = [t22]                                            ;\
         mov           t1 = ar.itc                                            ;\
         ;;                                                                   ;\
         ld4           rIntCount = [rIntCount]                                ;\
         mov           rStartTime = t1                                        ;\
         tbit##.##nz   rLog = t22, PERF_SPINLOCK_FLAG_SHIFT                   ;\
         ;;                                                                   ;\
         mov           t1 = t21

//++
// Routine:
//
//       SPINLOCK_LOG_POST_ACQUIRE(rLog, rLock, rStartTime, rSpinCount, Type)
//
// Routine Description:
//
//       spinlock logging processing after spinlock acquisition.
//
// Agruments:
//
//       rLog: the logging status, enabled or disabled
//       rLock: pointer to the spinlock 
//       rStartTime: the time just before attempting to acquire the spinlock
//       rSpinCount: supplies the spin count during lock acquisition
//       Type: Type of the spinlock
//
// Return Value:
//
//       None.
//
// Notes:
//
//       Uses temporaries: GR t22. GR t1 is used but is preserved.
//       out4 is assumed to be properly assigned before this routine is 
//       invoked.
//--

#define SPINLOCK_LOG_POST_ACQUIRE(rLog, rLock, rStartTime, rSpinCount, Type)   \
(rLog)   mov           out0 = rLock                                           ;\
(rLog)   mov           out3 = rSpinCount                                      ;\
(rLog)   mov           t22 = t1                                               ;\
         ;;                                                                   ;\
(rLog)   mov           t1 = ar.itc                                            ;\
         ;;                                                                   ;\
(rLog)   mov           out1 = t1                                              ;\
(rLog)   sub           out2 = t1, rStartTime                                  ;\
(rLog)   mov           out5 = Type                                            ;\
         ;;                                                                   ;\
(rLog)   mov           t1 = t22                                               ;\
(rLog)   br##.##call##.##spnt brp = PerfLogSpinLockAcquire

//++
// Routine:
//
//       SPINLOCK_LOG_PRE_RELEASE(rLog, rStartTime)
//
// Routine Description:
//
//       spinlock logging processing prior to spinlock release.
//
// Agruments:
//
//       rLog: predicate to hold the logging status
//       rStartTime: register to hold the current time.
//
// Return Value:
//
//       rLog: 1 if spinlock logging is enabled, 0 if it is disabled.
//       rStartTime: current time.
//
// Notes:
//
//       Uses temporaries: GRs t21, t22. GR t1 is used but is preserved.
//--

#define SPINLOCK_LOG_PRE_RELEASE(rLog, rStartTime)                             \
         mov           t21 = t1                                               ;\
         movl          t22 = PerfGlobalGroupMask+PERF_SPINLOCK_OFFSET         ;\
         ;;                                                                   ;\
         ld4           t22 = [t22]                                            ;\
         mov           t1 = ar.itc                                            ;\
         ;;                                                                   ;\
         mov           rStartTime = t1                                        ;\
         tbit##.##nz   rLog = t22, PERF_SPINLOCK_FLAG_SHIFT                   ;\
         ;;                                                                   ;\
         mov           t1 = t21

//++
// Routine:
//
//       SPINLOCK_LOG_POST_RELEASE(rLog, rLock)
//
// Routine Description:
//
//       spinlock logging processing after spinlock release.
//
// Agruments:
//
//       rLog: the logging status, enabled or disabled
//       rLock: pointer to the spinlock
//
// Return Value:
//
//       None.
//
// Notes:
//
//       out2 is assumed to be properly assigned before this routine is
//       invoked.
//--

#define SPINLOCK_LOG_POST_RELEASE(rLog, rLock)                                 \
(rLog)   mov           out0 = rLock                                           ;\
(rLog)   mov           out1 = savedbrp                                        ;\
         ;;                                                                   ;\
(rLog)   br##.##call##.##spnt brp = PerfLogSpinLockRelease

//++
// Routine:
//
//       ACQUIRE_SPINLOCK(rpLock, rOwn, rSpinCount, Loop)
//
// Routine Description:
//
//       Acquire a spinlock. Waits for lock to become free
//       by spinning on the cached lock value.
//
// Agruments:
//
//       rpLock: pointer to the spinlock (64-bit)
//       rOwn:   value to store in lock to indicate owner
//               Depending on call location, it could be:
//                  - rpLock
//                  - pointer to process
//                  - pointer to thread
//                  - pointer to PRCB
//       rSpinCount: regsiter to hold the spincount on return
//       Loop:   unique name for loop label
//
// Return Value:
//
//       rSpinCount: returns the spincount
//
// Notes:
//
//       Uses temporaries: predicates pt0 - pt2, and GR t22
//       The first time through the loop pt0 is 1 and pt1 is 0. 
//       Other registers are uninitialized.
//--

#define ACQUIRE_SPINLOCK(rpLock, rOwn, rSpinCount, Loop)                       \
         cmp##.##eq    pt0, pt1 = zero, zero                                  ;\
         mov           rSpinCount = zero                                      ;\
         ;;                                                                   ;\
Loop:                                                                         ;\
.pred.rel "mutex",pt0,pt1                                                     ;\
(pt1)    YIELD                                                                ;\
(pt0)    xchg8         t22 = [rpLock], rOwn                                   ;\
(pt1)    ld8##.##nt1   t22 = [rpLock]                                         ;\
         ;;                                                                   ;\
(pt0)    cmp##.##ne    pt2 = zero, t22                                        ;\
         cmp##.##eq    pt0, pt1 = zero, t22                                   ;\
         ;;                                                                   ;\
(pt1)    add           rSpinCount = 1, rSpinCount                             ;\
(pt2)    br##.##dpnt   Loop

//++
// Routine:
//
//       UPDATE_SPINLOCK_COUNTERS(rPrcb, rStatus, rSpinCount)
//
// Routine Description:
//
//       Update various spinlock instrumentation counters in PRCB.
//
// Agruments:
//
//       rPrcb: pointer to the current PRCB.
//       rStatus: non-zero if acqusition is successful, 0 if not.
//       rSpinCount: supplies the spin count during lock acquisition. 
//
// Return Value:
//
//       None
//
// Notes:
//
//       Uses temporaries: predicates pt0 and pt1, and GR t17 - t22
//--

#define UPDATE_SPINLOCK_COUNTERS(rPrcb, rStatus, rSpinCount)                   \
         ;;                                                                   ;\
         cmp##.##ne    pt0 = zero, rSpinCount                                 ;\
         cmp##.##ne    pt1 = zero, rStatus                                    ;\
         ;;                                                                   ;\
(pt1)    movl          t17 = PbSpinLockAcquireCount                           ;\
(pt0)    movl          t18 = PbSpinLockContentionCount                        ;\
(pt0)    movl          t19 = PbSpinLockSpinCount                              ;\
         ;;                                                                   ;\
(pt1)    add           t17 = t17, rPrcb                                       ;\
(pt0)    add           t18 = t18, rPrcb                                       ;\
(pt0)    add           t19 = t19, rPrcb                                       ;\
         ;;                                                                   ;\
(pt1)    ld4           t20 = [t17]                                            ;\
(pt0)    ld4           t21 = [t18]                                            ;\
(pt0)    ld4           t22 = [t19]                                            ;\
         ;;                                                                   ;\
(pt1)    add           t20 = 1, t20                                           ;\
(pt0)    add           t21 = 1, t21                                           ;\
(pt0)    add           t22 = rSpinCount, t22                                  ;\
         ;;                                                                   ;\
(pt1)    st4           [t17] = t20                                            ;\
(pt0)    st4           [t18] = t21                                            ;\
(pt0)    st4           [t19] = t22

//++
// Routine:
//
//       RELEASE_SPINLOCK(rpLock)
//
// Routine Description:
//
//       Release a spinlock by setting lock to zero.
//
// Agruments:
//
//       rpLock: pointer to the spinlock.
//
// Return Value:
//
//       None
//
// Notes:
//
//       Uses an ordered store to ensure previous memory accesses in
//       critical section complete.
//--

#define RELEASE_SPINLOCK(rpLock)                                               \
         st8##.##rel           [rpLock] = zero

//++
// Routine:
//
//       PRELEASE_SPINLOCK(rpLock)
//
// Routine Description:
//
//       Predicated release spinlock.
//
// Agruments:
//
//       rpLock: pointer (swizzled) to the spinlock.
//               spinlock itself is 32-bit.
//
// Return Value:
//
//       None
//
// Notes:
//
//       Uses an ordered store to ensure previous memory accesses in
//       critical section complete.
//--

#define PRELEASE_SPINLOCK(px, rpLock)                                          \
(px)    st8##.##rel   [rpLock] = zero

//
// Interrupt and IRQL macros
//

//++
// Routine:
//
//       END_OF_INTERRUPT
//
// Routine Description:
//
//       Hook to perform end-of-interrupt processing. Currently
//       just writes to the EOI control register.
//
// Agruments:
//
//       None
//
// Return Value:
//
//       None
//
// Note:
//
//       Writing EOI requires explicit data serialize. srlz must be preceded by
//       stop bit.
//--

#define END_OF_INTERRUPT                         \
         mov       cr##.##eoi = zero            ;\
         ;;                                     ;\
         srlz##.##d    /* Requires data srlz */

//++
// Routine:
//
//       GET_IRQL(rOldIrql)
//
// Routine Description:
//
//       Read the current IRQL by reading the TPR control register.
//
// Agruments:
//
//       Register to contain the result.
//
// Return Value:
//
//       rOldIrql: the current value of the IRQL.
//
//--

#ifndef SHADOW_IRQL_IMPLEMENTATION

#define GET_IRQL(rOldIrql)                       \
        mov         rOldIrql = cr##.##tpr      ;;\
        extr##.##u  rOldIrql = rOldIrql, TPR_MIC, TPR_MIC_LEN

#else

#define GET_IRQL(rOldIrql)                              \
        movl        rOldIrql = KiPcr+PcCurrentIrql;;    \
        ld1         rOldIrql = [rOldIrql]

#endif

//++
// Routine:
//
//       SET_IRQL(rNewIrql)
//
// Routine Description:
//
//       Update the IRQL by writing the TPR control register.
//       register t21 & t22 are used as a scratch
//
// Agruments:
//
//       Register with the new IRQL value. Contains the unshifted
//       IRQL value (0-15).
//
// Return Value:
//
//       None.
//
// Notes:
//
//       Writing TPR requires explicit data serialize. srlz must be preceded by
//       stop bit.
//
//--

#ifndef SHADOW_IRQL_IMPLEMENTATION

#define SET_IRQL(rNewIrql)                                    \
        dep##.##z t22 = rNewIrql, TPR_MIC, TPR_MIC_LEN;;     ;\
        mov       cr##.##tpr = t22;;                         ;\
        srlz##.##d
#else

#define SET_IRQL(rNewIrql)                                  \
        dep##.##z t22 = rNewIrql, TPR_MIC, TPR_MIC_LEN;;   ;\
        movl      t21 = KiPcr+PcCurrentIrql;;              ;\
        mov       cr##.##tpr = t22                         ;\
        st1       [t21] = rNewIrql

#endif

//++
// Routine:
//
//       PSET_IRQL(pr, rNewIrql)
//
// Routine Description:
//
//       Update the IRQL by writing the TPR control register, predicated
//       on pr
//       register t21 & t22 are used as a scratch
//
// Agruments:
//
//       pr:       predicate -- set irql if pr true.
//
//       rNewIrql: Register with the new IRQL value. Contains the unshifted
//                 IRQL value (0-15).
//
// Return Value:
//
//       None.
//
// Notes:
//
//       Relies on TPR.mi always 0.
//       Writing TPR requires explicit data serialize. srlz must be preceded by
//       stop bit.
//--

#ifndef SHADOW_IRQL_IMPLEMENTATION

#define PSET_IRQL(pr, rNewIrql)                             \
        dep##.##z t22 = rNewIrql, TPR_MIC, TPR_MIC_LEN;;   ;\
(pr)    mov       cr##.##tpr = t22;;                       ;\
(pr)    srlz##.##d

#else

#define PSET_IRQL(pr, rNewIrql)                             \
        mov       t21 = rNewIrql                           ;\
        dep##.##z t22 = rNewIrql, TPR_MIC, TPR_MIC_LEN;;   ;\
(pr)    mov       cr##.##tpr = t22                         ;\
(pr)    movl      t22 = KiPcr+PcCurrentIrql;;              ;\
(pr)    st1       [t22] = t21

#endif

//++
// Routine:
//
//       SWAP_IRQL(rNewIrql)
//
// Routine Description:
//
//       get the current IRQL value and set the IRQL to the new value
//       register t21 and t22 are used as a scratch
//
// Agruments:
//
//       Register with the new IRQL value. Contains the unshifted
//       IRQL value (0-15).
//
// Return Value:
//
//       v0 - current IRQL
//
//--

#define SWAP_IRQL(rNewIrql)                                 \
        movl      t22 = KiPcr+PcCurrentIrql;;              ;\
        ld1       v0 = [t22]                               ;\
        dep##.##z t21 = rNewIrql, TPR_MIC, TPR_MIC_LEN;;   ;\
        mov       cr##.##tpr = t21                         ;\
        st1       [t22] = rNewIrql

//++
// Routine:
//
//       GET_IRQL_FOR_VECTOR(pGet,rIrql,rVector)
//
// Routine Description:
//
//       Hook to get the IRQL associated with an interrupt vector.
//       Currently just returns bit {7:4} of the 8-bit vector number.
//
// Agruments:
//
//       pGet:    Predicate: if true then get, else skip.
//       rIrql:   Register to contain the associated IRQL.
//       rVector: Register containing the vector number.
//
// Return Value:
//
//       rIrql: The IRQL value. A 4-bit value in bits {3:0}. All
//              other bits are zero.
//
//--

#define GET_IRQL_FOR_VECTOR(pGet,rIrql,rVector)                      \
(pGet)  shr         rIrql = rVector, VECTOR_IRQL_SHIFT



//++
// Routine:
//
//       GET_VECTOR_FOR_IRQL(pGet,rVector,rIrql)
//
// Routine Description:
//
//       Hook to get the interrupt vector associated with an IRQL.
//       Currently just returns IRQL << 4.
//
// Agruments:
//
//       pGet:    Predicate: if true then get, else skip.
//       rVector: Register containing the associated vector number.
//       rIrql:   Register to containing the IRQL.
//
// Return Value:
//
//       rVector: The vector value. An 8-bit value in bits {7:0}. All
//              other bits are zero.
//
//--

#define GET_VECTOR_FOR_IRQL(pGet, rVector, rIrql)                     \
(pGet)  shl         rVector = rIrql, VECTOR_IRQL_SHIFT

// Routine:
//
//       REQUEST_APC_INT(pReq)
//       REQUEST_DISPATCH_INT(pReq)
//
// Routine Description:
//
//       Request a software interrupt. Used to request
//       APC and DPC interrupts.
//
// Agruments:
//
//       pReq: Predicate: if true then do request, else skip
//
// Return Value:
//
//       None
//
// Notes:
//
//       Uses temporary registers t20, t21
//--

#define REQUEST_APC_INT(pReq)                                                  \
        mov         t20 = 1                                                   ;\
        movl        t21 = KiPcr+PcApcInterrupt                                ;\
        ;;                                                                    ;\
(pReq)  st1         [t21] = t20

#define REQUEST_DISPATCH_INT(pReq)                                             \
        mov         t20 = 1                                                   ;\
        movl        t21 = KiPcr+PcDispatchInterrupt                           ;\
        ;;                                                                    ;\
(pReq)  st1         [t21] = t20


#ifdef __assembler
//++
// Routine:
//
//       LOWER_IRQL(rNewIrql, trapFrame)
//
// Routine Description:
//
//       Check for pending s/w interrupts and lower Irql
//
// Agruments:
//
//       rNewIrql: interrupt request level
//
//       trapFrame: trap frame at the time of the interruption
//
// Return Value:
//
//       None
//
// Notes:
//
//       Pending s/w interrupts are dispatched if new IRQL is low enough,
//       even though interrupts are disabled
//--

#define LOWER_IRQL(rNewIrql, trapFrame)                                        \
        cmp##.##gtu pt0, pt1 = DISPATCH_LEVEL, rNewIrql                       ;\
        movl        t22 = KiPcr+PcSoftwareInterruptPending;;                  ;\
        ld2         t22 = [t22]                                               ;\
        mov         out0 = rNewIrql                                           ;\
        mov         out1 = trapFrame;;                                        ;\
(pt0)   cmp##.##ne  pt0, pt1 = r0, t22                                        ;\
        PSET_IRQL(pt1, rNewIrql)                                              ;\
(pt0)   br##.##call##.##spnt brp = KiCheckForSoftwareInterrupt

//++
//
// Routine:
//
//       LEAF_LOWER_IRQL_AND_RETURN(rNewIrql)
//
// Routine Description:
//
//       Check for pending s/w interrupts and lower Irql
//
//       If a software interupt is in fact pending and would
//       logically fire if IRQL is lowered to the new level,
//       branch to code that will promote to a nested function
//       and handle the interrupt, otherwise, lower IRQL and
//       return from this leaf function.
//
// Agruments:
//
//       rNewIrql: interrupt request level
//       End: label marking the end of the macro
//
// Return Value:
//
//       None
//
// Notes:
//
//       Pending s/w interrupts are dispatched if new IRQL is low enough,
//       even though interrupts are disabled
//--

#define CHECK_PENDING_SW_INT_AND_LOWER_IRQL(rNewIrql, End)                     \
        cmp##.##gtu pt0 = DISPATCH_LEVEL, rNewIrql                            ;\
        cmp##.##ne  pt1 = zero, zero                                          ;\
        movl        t21 = KiPcr+PcSoftwareInterruptPending;;                  ;\
        ;;                                                                    ;\
(pt0)   rsm         1 << PSR_I                                                ;\
(pt0)   ld2         t21 = [t21]                                               ;\
        ;;                                                                    ;\
(pt0)   cmp##.##ltu##.##unc pt1 = rNewIrql, t21                               ;\
        ;;                                                                    ;\
(pt1)   mov         out0 = rNewIrql                                           ;\
(pt1)   mov         out1 = zero                                               ;\
        ;;                                                                    ;\
(pt1)   ssm         1 << PSR_I                                                ;\
(pt1)   br##.##call##.##sptk brp = KiCheckForSoftwareInterrupt                ;\
(pt1)   br##.##sptk End                                                       ;\
        SET_IRQL(rNewIrql)                                                    ;\
        ssm         1 << PSR_I                                                ;\
End:

#endif // __assembler

//*******
//*
//* The following macros are used in C runtime asm code
//*
//* beginSection - a macro for declaring and beginning a section
//*         .sdata is used to create short data section, if it does not exist
//*
//* endSection - a macro for ending a previously declared section
//*
//*******

#define beginSection(SectName)  .##section   .CRT$##SectName, "a", "progbits"

#define endSection(SectName)

#define PublicFunction(Name) .##global Name; .##type Name,@function

//  XIA  Begin C Initializer Sections
//  XIC   Microsoft Reserved
//  XIU   User
//  XIZ  End C Initializer Sections
//
//  XCA  Begin C++ Constructor Sections
//  XCC   Compiler (MS)
//  XCL   Library
//  XCU   User
//  XCZ  End C++ Constructor Sections
//
//  XPA  Begin C Pre-Terminator Sections
//  XPU   User
//  XPX   Microsoft Reserved
//  XPZ  End C Pre-Terminator Sections
//
//  XTA  Begin C Pre-Terminator Sections
//  XTU   User
//  XTX   Microsoft Reserved
//  XTZ  End C Pre-Terminator Sections
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\listeneradapter.h ===
/*++

Copyright (c) 1998-2005 Microsoft Corporation

Module Name:

    listeneradapter.h

Abstract:

    The exported routines for the wbhstipm dll.

--*/

#ifndef _LISTENER_ADAPTER_H_
#define _LISTENER_ADAPTER_H_


#ifdef __cplusplus
extern "C" {
#endif

//
//
//
// Enumerations
//

//
// callback function definitions
//

//
// *** Config Manager Callback functions ***
//

//
// Notifies the listener adapter that the configuration
// manager has connected.  After this call the listener
// adapter can expect configuration notifications to fire so 
// it can setup the listener to wait on incoming requests.   
// This notification will always proceed any configuration 
// notifications, and is a signal that they listener adapter
// should be in a clean state and ready to receive new
// configuration.
//
// WAS does not wait on the completion of this notification.
// 
typedef VOID
(*PFN_WEBHOST_LISTENER_CONFIG_MANAGER_CONNECTED)(
    IN VOID * pContext
    );

//
// Notifies the listener adapter that the WAS service
// has disconnected.  This may happen if WAS were to 
// crash.  In this case, the listener adapter is expected
// to cleanup everything that WAS configured.  Once WAS
// restarts it will provide any running listener adapters
// with configuration info again, so the listener adapter
// has to prepare to be re-configured.
//
// WAS does not wait on the completion of this notification.
// 
// 
typedef VOID
(*PFN_WEBHOST_LISTENER_CONFIG_MANAGER_DISCONNECT)(
    IN VOID * pContext,
    IN HRESULT hr
    );


//
// Notifies a listener adapter that WAS has completed passing
// all configuration for the service.  No more configuration
// will be passed until change notifications cause it.  At this
// point a listener adapter should activate all configured
// applications, not before.  Before this notification the listener
// adapter may have partial configuration data and may mis-route
// due to not realizing that another application that changes
// the routing exists.  It is also at this point that a service
// waiting on all applications and app pools to be configured
// can declare itself started.
//
// WAS does not wait on the completion of this notification.
// 
//
typedef VOID
(*PFN_WEBHOST_LISTENER_CONFIG_MANAGER_INITIALIZATION_COMPLETED)(
    IN VOID * pContext
    );


//
// *** App Pool Callback functions ***
//

//
// The application in the eyes of this listener adapter
// has been created.  In other words, an application that
// wants to participate in this app pool has been configured
// to use this protocol.  
//
// WAS does not wait on the completion of this notification.
//

typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_POOL_CREATED)(
    IN VOID * pContext,
    IN LPCWSTR AppPoolId,
    IN PSID    PSID
    );

//
// A notification the the app pool in the eyes of this
// listener is being deleted.  Once this call completes,
// the listener adapter should be capable of creating
// this app pool again should it be told to.  
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_POOL_DELETED)(
    IN VOID * pContext,
    IN LPCWSTR AppPoolId
    );

//
// A notification that worker processes running 
// under this app pool will be running with a new
// identity.  
//
// WAS does wait on the completion of this notification.
//
// Once all all of the listener adapters have completed 
// this notification any recycles neccessary will be 
// performed, and worker processes will again be able to launch.  
// A listener adapter blocking on this routine can block 
// all others in the app pool from starting worker processes.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_POOL_IDENTITY_CHANGED)(
    IN VOID * pContext,
    IN LPCWSTR AppPoolId,
    IN PSID    PSID
    );

//
// Notify's a listener adapter that the state of an
// app pool has changed.  Either the app pool is now capable
// of launching and running worker processes, or the app 
// pool is now disabled and will not run worker processes.
// 
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_POOL_STATE_CHANGED)(
    IN VOID * pContext,
    IN LPCWSTR AppPoolId,
    IN BOOL    fIsEnabled
    );

//
// Notify's a listener adapter that it is possible to 
// launch other instances of this listener channel.  The listener
// adapter should call start listener channel when it receives the 
// next request to be processed.  The listener adapter
// should not call start listener channel after that until it is
// once again told to through this function.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_POOL_CAN_OPEN_NEW_LISTENER_CHANNEL_INSTANCE)(
    IN VOID * pContext,
    IN LPCWSTR AppPoolId,
    IN DWORD ListenerChannelId
    );

//
// Notify's a listener adapter that all instances of a particular
// listener channel have been stopped.  During shutdown a listener adapter
// should wait on this before stopping, otherwise restarting
// may have problems, with listener channels all ready being in use.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_POOL_ALL_LISTENER_CHANNEL_INSTANCES_STOPPED)(
    IN VOID * pContext,
    IN LPCWSTR AppPoolId,
    IN DWORD ListenerChannelId
    );

//
// *** App Pool Callback functions ***
//

//
// Notifies the listener adapter that an application exists in
// the eyes of this listener adapter.  Whether the listener 
// adapter chooses to configure this application with the listener
// is up to the listener adapter.  The RequestsBlocked value tells the
// listener adapter that while you should listen on this application
// you should not process requests.  It is to block requests from going
// to parent applications because the child does not support the
// protocol.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_CREATED)(
    IN VOID * pContext,
    IN LPCWSTR AppKey,
    IN LPCWSTR Path,
    IN DWORD   SiteId,
    IN LPCWSTR AppPoolId,
    IN PBYTE   Bindings,
    IN DWORD   NumberOfBindings,
    IN BOOL    RequestsBlocked
    );

//
// Notifies the listener adapter that the application no longer
// should exist in the listener adapters eyes.  This may mean
// that the application was deleted, or that all applications for
// this site no longer use this protocol.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_DELETED)(
    IN VOID * pContext,
    IN LPCWSTR AppKey
    );

//
// Notifies the listener adapter that the bindings for a particular
// application have changed.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_BINDINGS_CHANGED)(
    IN VOID * pContext,
    IN LPCWSTR AppKey,
    IN PBYTE   Bindings,
    IN DWORD   NumberOfBindings
    );

//
// Notifies the listener adapter that the app pool for a particular
// application have changed.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_APP_POOL_CHANGED)(
    IN VOID * pContext,
    IN LPCWSTR AppKey,
    IN LPCWSTR AppPoolId
    );

//
// Notifies the listener adapter that it should either no longer
// reject requests for the application, or that it should start
// rejecting requests for the application.
//
// WAS does not wait on the completion of this notification.
//
typedef VOID
(*PFN_WEBHOST_LISTENER_APPLICATION_REQUESTS_BLOCKED_CHANGED)(
    IN VOID * pContext,
    IN LPCWSTR AppKey,
    IN BOOL    RequestsBlocked
    );

//
// Callback structure
//
struct WEBHOST_LISTENER_CALLBACKS
{
    DWORD                                                                         dwBytesInCallbackStructure;
    PFN_WEBHOST_LISTENER_CONFIG_MANAGER_CONNECTED                                 pfnWebhostListenerConfigManagerConnected;
    PFN_WEBHOST_LISTENER_CONFIG_MANAGER_DISCONNECT                                pfnWebhostListenerConfigManagerDisconnected;
    PFN_WEBHOST_LISTENER_CONFIG_MANAGER_INITIALIZATION_COMPLETED                  pfnWebhostListenerConfigManagerInitializationCompleted;

    PFN_WEBHOST_LISTENER_APPLICATION_POOL_CREATED                                 pfnWebhostListenerApplicationPoolCreated;
    PFN_WEBHOST_LISTENER_APPLICATION_POOL_DELETED                                 pfnWebhostListenerApplicationPoolDeleted;
    PFN_WEBHOST_LISTENER_APPLICATION_POOL_IDENTITY_CHANGED                        pfnWebhostListenerApplicationPoolIdentityChanged;
    PFN_WEBHOST_LISTENER_APPLICATION_POOL_STATE_CHANGED                           pfnWebhostListenerApplicationPoolStateChanged;
    PFN_WEBHOST_LISTENER_APPLICATION_POOL_CAN_OPEN_NEW_LISTENER_CHANNEL_INSTANCE  pfnWebhostListenerApplicationPoolCanOpenNewListenerChannelInstance;
    PFN_WEBHOST_LISTENER_APPLICATION_POOL_ALL_LISTENER_CHANNEL_INSTANCES_STOPPED  pfnWebhostListenerApplicationPoolAllListenerChannelInstancesStopped;

    PFN_WEBHOST_LISTENER_APPLICATION_CREATED                                      pfnWebhostListenerApplicationCreated;
    PFN_WEBHOST_LISTENER_APPLICATION_DELETED                                      pfnWebhostListenerApplicationDeleted;
    PFN_WEBHOST_LISTENER_APPLICATION_BINDINGS_CHANGED                             pfnWebhostListenerApplicationBindingsChanged;
    PFN_WEBHOST_LISTENER_APPLICATION_APP_POOL_CHANGED                             pfnWebhostListenerApplicationAppPoolChanged;
    PFN_WEBHOST_LISTENER_APPLICATION_REQUESTS_BLOCKED_CHANGED                     pfnWebhostListenerApplicationRequestsBlockedChanged;
};

//
// exported functions
//

//
// Webhost client can call to determine
// the version of webhost it is running 
// against.  This information will allow 
// it to understand what exported functions
// it should expect.
//
HRESULT
WebhostGetVersion(
    OUT DWORD* pMajorVersion,
    OUT DWORD* pMinorVersion
    );

//
// Registers a protocol for WAS to honor
// when it is running.  The ProtocolHandle returned
// can be used to activate other calls against
// the registered protocol.
//
// pListenerCallbacks will be 
//
HRESULT
WebhostRegisterProtocol(
    IN LPCWSTR ProtocolId,
    IN VOID*   pListenerCallbacks,
    IN VOID *  pContext,
    OUT DWORD* pProtocolHandle
    );

//
// Before a protocol goes down, it should first 
// stop any listener channels that were running, and wait for
// those listener channels to stop (detemined through private means).
// Then it should unregister the protocol with the W3SVC
// client library.
//
HRESULT
WebhostUnregisterProtocol(
    IN DWORD   ProtocolHandle
    );

//
// This will request a listener channel be started in a 
// worker process for this app pool.  
//
// It is a failure to call if the client
// library is not in a connected state.
//
HRESULT
WebhostOpenListenerChannelInstance(
    IN DWORD   ProtocolHandle,
    IN LPCWSTR AppPoolId,
    IN DWORD   ListenerChannelId,
    IN PBYTE   ListenerChannelBlob,
    IN DWORD   ListenerChannelBlobByteCount
    );

//
// Function will stop all instances of
// this listener channel.  It is not a failure to call
// with no listener channels running.  It is a failure
// to call if not in a connected state.
//
HRESULT
WebhostCloseAllListenerChannelInstances(
    IN DWORD   ProtocolHandle,
    IN LPCWSTR AppPoolId,
    IN DWORD   ListenerChannelId
    );

//
// =========================================================================================
//


#ifdef __cplusplus
}
#endif

#endif  // _LISTENER_ADAPTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\kxamd64.inc ===
;++
;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
;
; Module:
;
;   kxamd64.w
;
; Astract:
;
;   Contains AMD64 architecture constants and assembly macros.
;
;
;--

include macamd64.inc

;
; Define macro to clear legacy floating exceptions.
;

clfpex  macro

        db      0dbh, 0e2h

        endm

;
; Define macro to perform an enlightened yield.
;
; Arguments:
;
;   None.
;
; N.B. This macro is restricted to only freely using the register specified by
;      the 'Register' parameter and rcx. 'Register' should be nonvolatile.
;

EnlightenedYield macro Register

        local skip

ifnb <Register>

        inc     Register                ; increment counter and test
        test    HvlLongSpinCountMask, Register
        jnz     short skip              ; max count not hit, yield
        test    HvlEnlightenments, HV_KE_USE_HYPERCALL_FOR_LONG_SPIN_WAIT
        jz      short skip              ; long spin not enlightened, yield
        mov     ecx, Register           ; prepare argument
        call    HvlNotifyLongSpinWait   ; issue the hypercall

endif

skip:   Yield

        endm

;
; Define macro to acquire spin lock.
;
; Arguments:
;
;   None.
;
; N.B. This macro is restricted to only freely using the register specified by
;      the 'Register' parameter and rcx. 'Register' should be nonvolatile.
;
; N.B. If 'Register' is specified, 'Address' must be nonvolatile or global.
;

AcquireSpinLock macro Address, Register

        local exit, spin

ifndef NT_UP

   lock bts     qword ptr Address, 0    ; attempt to acquire spin lock
        jnc     short exit              ; if nc, spin lock acquired

ifnb <Register>

        xor     Register, Register      ; initialize spin count

endif

spin:   EnlightenedYield <Register>     ; yield execution
        test    qword ptr Address, 1    ; check if lock currently owned
        jnz     short spin              ; if nz, spin lock owned
   lock bts     qword ptr Address, 0    ; attempt to acquire spin lock
        jc      short spin              ; if c, spin lock owned

exit:                                   ; continue

endif

        endm

;
; Define macro to acquire spin lock and mask interrupts.
;
; Arguments:
;
;   None.
;
; Note:
;
;   rsp is assumed to point to pushed EFLAGS
;
; N.B. This macro uses no registers.
;

AcquireSpinLockDisable macro Address

        local exit, spin, spin1

        cli                             ; disable interrupts

ifndef NT_UP

   lock bts     qword ptr Address, 0    ; attempt to acquire spin lock
        jnc     short exit              ; if nc, spin lock acquired
spin:   test    dword ptr [rsp], EFLAGS_IF_MASK ; test if interrupts enabled
        jz      short spin1             ; if z, interrupts disabled
        sti                             ; enable interrupts

spin1:  Yield                           ; yield execution

        test    qword ptr Address, 1    ; check if lock currently owned
        jnz     short spin1             ; if nz, spin lock owned
        cli                             ; lock is (was) clear, disable ints
   lock bts     qword ptr Address, 0    ; attempt to acquire spin lock
        jc      short spin              ; if c, spin lock owned
exit:                                   ; continue

endif

        endm

;
; Define macro to release spin lock.
;
; Arguments:
;
;   None.
;
; N.B. This macro uses no registers.
;

ReleaseSpinLock macro Address

ifndef NT_UP

   lock and     qword ptr Address, 0    ; release spin lock

endif

        endm

;
; Define macro to release spin lock and restore the interrupt flag.
;
; Arguments:
;
;   None.
;
; Note:
;
;   rsp is assumed to point to pushd EFLAGS
;
; N.B. This macro uses no registers.
;

ReleaseSpinLockEnable macro Address

        local exit

ifndef NT_UP

   lock and     qword ptr Address, 0    ; release spin lock

endif

        test    dword ptr [rsp], EFLAGS_IF_MASK ; test if interrupts enabled
        jz      short exit              ; if z, interrupts not enabled
        sti                             ; enable interrupts
exit:                                   ; continue

        endm

;
; Define macro to try to acquire spin lock.
;
; Arguments:
;
;   None.
;
; N.B. This macro uses no registers.
;

TryToAcquireSpinLock macro Address

ifndef NT_UP

        lock bts qword ptr Address, 0   ; attempt to acquire spin lock

endif

        endm

;
; Define macro to perform the equivalent of reading cr8.
;
; Arguments:
;
;   None
;
; The equivalent of the contents of cr8 is returned in rax
;
; N.B. This macro is restricted to using only rax.
;

ReadCr8 macro

        mov     rax, cr8                ; read IRQL

        endm

;
; Define macro to perform the equivalent of writing cr8.
;
; Arguments:
;
;   rcx - The desired value of cr8.
;

WriteCr8 macro

        mov     cr8, rcx                ; write IRQL

        endm

;
; Define macro to get current IRQL.
;
; Arguments:
;
;   None.
;
; The previous IRQL is returned in rax.
;

CurrentIrql macro

        ReadCr8                         ; get current IRQL

        endm

;
; Define macro to lower IRQL.
;
; Arguments:
;
;   rcx - Supplies the new IRQL.
;
; N.B. The register rax is destroyed.
;
; N.B. This macro is restricted to using only rcx and rdx.
;

LowerIrql macro

        local   exit

if DBG

        mov     rdx, rax                ; preserve rax
        ReadCr8                         ; get current IRQL
        cmp     eax, ecx                ; check new IRQL
        jge     short exit              ; if ge, new IRQL okay
        int     3                       ; break into debugger
exit:   mov     rax, rdx

endif

        WriteCr8                        ; set new IRQL

        endm

;
; Define macro to raise IRQL.
;
; Arguments:
;
;   rcx - Supplies the new IRQL.
;
; The previous IRQL is returned in rax.
;
; N.B. This macro is restricted to using only rax and rcx.
;

RaiseIrql macro

        local   exit

        ReadCr8                         ; get current IRQL

if DBG

        cmp     eax, ecx                ; check new IRQL
        jle     short exit              ; if le, new IRQL okay
        int     3                       ; break into debugger

endif

exit:   WriteCr8                        ; set new IRQL

        endm

;
; Define macro to set IRQL.
;
; Arguments:
;
;   rcx - Supplies the new IRQL.
;
; N.B. This macro is restricted to using only rcx.
;

SetIrql macro

        WriteCr8                        ; set new IRQL

        endm

;
; Define macro to swap IRQL.
;
; Arguments:
;
;   rcx - Supplies the new IRQL.
;
; The previous IRQL is returned in rax.
;
; N.B. This macro is restricted to using only rax and rcx.
;

SwapIrql macro

        ReadCr8                         ; get current IRQL
        WriteCr8                        ; set new IRQL

        endm

;
; Define end system interrupt macro.
;
; Arguments:
;
;   None.
;
; N.B. Any violatile registers used in this routine must be preserved. This
;      macro is used by APC/DPC interrupt handler which may not save the
;      machine state. HalPerformEndOfInterrupt is responsible for preserving
;      all the violatile registers it uses.
;

EndSystemInterrupt macro

        push    rcx
        mov     rcx, __imp_HalPerformEndOfInterrupt
        call    qword ptr [rcx]
        pop     rcx

        endm

;
; Define restore exception state macro.
;
;   This macro restores the nonvolatile state.
;
; Arguments:
;
;   Flag - If blank, then nonvolatile floating and integer registers are
;       restored. If nonblank and identical to "Rbp", then rbp is restored
;       in addition to the nonvolatile floating and integer registers. If
;       nonblank and identical to "NoFp", then only the nonvolatile integer
;       registers are restored.
;
; Implicit arguments:
;
;   rsp - Supplies the address of the exception frame.
;

RESTORE_EXCEPTION_STATE macro Flag

        lea     rcx, 100h[rsp]          ; set frame display pointer

ifdif <Flag>, <NoFp>

        movaps  xmm6, ExXmm6[rsp]       ; restore nonvolatile xmm registers
        movaps  xmm7, ExXmm7[rsp]       ;
        movaps  xmm8, ExXmm8[rsp]       ;
        movaps  xmm9, ExXmm9[rsp]       ;
        movaps  xmm10, ExXmm10[rsp]     ;
        movaps  xmm11, (ExXmm11 - 100h)[rcx] ;
        movaps  xmm12, (ExXmm12 - 100h)[rcx] ;
        movaps  xmm13, (ExXmm13 - 100h)[rcx] ;
        movaps  xmm14, (ExXmm14 - 100h)[rcx] ;
        movaps  xmm15, (ExXmm15 - 100h)[rcx] ;

endif

        mov     rbx, (ExRbx - 100h)[rcx] ; restore nonvolatile integer registers
        mov     rdi, (ExRdi - 100h)[rcx] ;
        mov     rsi, (ExRsi - 100h)[rcx] ;
        mov     r12, (ExR12 - 100h)[rcx] ;
        mov     r13, (ExR13 - 100h)[rcx] ;
        mov     r14, (ExR14 - 100h)[rcx] ;
        mov     r15, (ExR15 - 100h)[rcx] ;

ifdif <Flag>, <NoPop>

ifidn <Flag>, <Rbp>

        mov     rbp, (ExRbp - 100h)[rcx]  ; restore nonvolatile integer register

endif

        add     rsp, KEXCEPTION_FRAME_LENGTH - (1 * 8) ; deallocate frame

endif

        endm

;
; Define generate exception frame macro.
;
;   This macro allocates an exception frame and saves the nonvolatile state.
;
; Arguments:
;
;   Flag - If blank, then nonvolatile floating and integer registers are
;       saved. If nonblank and identical to "Rbp", then rbp is saved in
;       addition to the nonvolatile floating and integer registers. If
;       nonblank and identical to "NoFp", then only the nonvolatile integer
;       registers are saved. If nonblank and identical to "NoPop", then
;       allocate an exception record in addition to an exception frame.
;
; Implicit arguments:
;
;   The top of the stack is assumed to contain a return address.
;

GENERATE_EXCEPTION_FRAME macro Flag


ifidn <Flag>, <NoPop>

        alloc_stack (EXCEPTION_RECORD_LENGTH + KEXCEPTION_FRAME_LENGTH - (1 * 8)) ; allocate frame

else

        alloc_stack (KEXCEPTION_FRAME_LENGTH - (1 * 8)) ; allocate frame

endif

        lea     rax, 100h[rsp]          ; set frame display pointer

ifdif <Flag>, <NoFp>

        save_xmm128 xmm6, ExXmm6        ; save xmm nonvolatile registers
        save_xmm128 xmm7, ExXmm7        ;
        save_xmm128 xmm8, ExXmm8        ;
        save_xmm128 xmm9, ExXmm9        ;
        save_xmm128 xmm10, ExXmm10      ;

        movaps  (ExXmm11 - 100h)[rax], xmm11 ;
        .savexmm128 xmm11, ExXmm11      ;

        movaps  (ExXmm12 - 100h)[rax], xmm12 ;
        .savexmm128 xmm12, ExXmm12      ;

        movaps  (ExXmm13 - 100h)[rax], xmm13 ;
        .savexmm128 xmm13, ExXmm13      ;

        movaps  (ExXmm14 - 100h)[rax], xmm14 ;
        .savexmm128 xmm14, ExXmm14      ;

        movaps  (ExXmm15 - 100h)[rax], xmm15 ;
        .savexmm128 xmm15, ExXmm15      ;

endif

ifidn <Flag>, <Rbp>

        mov     (ExRbp - 100h)[rax], rbp  ; save nonvolatile integer register
        .savereg rbp, ExRbp             ;
        set_frame rbp, 0                ; set frame pointer

endif

        mov     (ExRbx - 100h)[rax], rbx  ;
        .savereg rbx, ExRbx             ;

        mov     (ExRdi - 100h)[rax], rdi  ;
        .savereg rdi, ExRdi             ;

        mov     (ExRsi - 100h)[rax], rsi  ;
        .savereg rsi, ExRsi             ;

        mov     (ExR12 - 100h)[rax], r12  ;
        .savereg r12, ExR12             ;

        mov     (ExR13 - 100h)[rax], r13  ;
        .savereg r13, ExR13             ;

        mov     (ExR14 - 100h)[rax], r14  ;
        .savereg r14, ExR14             ;

        mov     (ExR15 - 100h)[rax], r15  ;
        .savereg r15, ExR15             ;

        END_PROLOGUE

        endm

;
; Define the instrumentation return macro.
;
;   This macro determines whether an instrumentation callback is enabled for this
;   thread's process.  If it is, then the return address in the trap frame is
;   replaced with the instrumentation callback address, and r10 is used to
;   indicate the actual return address.
;
; Arguments:
;
;   None
;
; Implicit arguments:
;
;   rbp - Supplies the address of the trap frame
;

SETUP_FOR_INSTRUMENTATION_RETURN macro

        local   exit

        mov     rax, gs:[PcCurrentThread]           ; get current thread address
        mov     rax, ThApcState + AsProcess[rax]    ; get current process
        mov     rax, PrInstrumentationCallback[rax] ; get callback address
        or      rax, rax                            ; check if non-null
        jz      exit                                ; if z, it is null

        cmp     word ptr TrSegCs[rbp], (KGDT64_R3_CODE or RPL_MASK) ; check for 64-bit mode
        jne     exit

        mov     r10, TrRip[rbp]                     ; r10 = original address
        mov     TrRip[rbp], rax                     ; return to callback address
exit:

        endm

;
; Define restore trap state macro.
;
;   This macro restores the volatile state, and if necessary, restores the
;   user debug state, deallocats the trap frame, and exits the trap.
;
;   N.B. This macro must preserve eax in case it is not reloaded from the
;        trap frame.
;
; Arguments:
;
;   State - Determines what state is restored and what tests are made. Valid
;       values are:
;
;           Service - restore state for a service executed from user mode.
;           Kernel - restore state for a service executed from kernel mode.
;           Volatile - restore state for a trap or interrupt.
;
;   Disable - If blank, then disable interrupts.
;
; Implicit arguments:
;
;   rbp - Supplies the address of the trap frame.
;

RESTORE_TRAP_STATE macro State, Disable, NmiFlag, LBranch

        local   first, second, third, fourth

ifb <Disable>

        cli                             ; disable interrupts

endif

ifdif <State>, <Kernel>

;
; State is either <Volatile> or <Service>
;

ifidn <State>, <Volatile>

        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jz      fourth                  ; if z, previous mode not user

endif

ifdif <NmiFlag>, <Nmi>

        mov     rcx, gs:[PcCurrentThread] ; get current thread address
        cmp     byte ptr ThApcState + AsUserApcPending[rcx], 0 ; APC pending?
        je      short first             ; if e, no user APC pending

endif

ifidn <State>, <Service>

        mov     TrRax[rbp], rax         ; save service status
        xor     eax, eax                ; scrub volatile integer registers in the trap frame
        mov     TrRcx[rbp], rax         ;
        mov     TrRdx[rbp], rax         ;
        mov     TrR8[rbp], rax          ;
        mov     TrR9[rbp], rax          ;
        mov     TrR10[rbp], rax         ;
        mov     TrR11[rbp], rax         ;
        pxor    xmm0, xmm0              ; scrub volatile floating registers in the trap frame
        movaps  TrXmm0[rbp], xmm0       ;
        movaps  TrXmm1[rbp], xmm0       ;
        movaps  TrXmm2[rbp], xmm0       ;
        movaps  TrXmm3[rbp], xmm0       ;
        movaps  TrXmm4[rbp], xmm0       ;
        movaps  TrXmm5[rbp], xmm0       ;

endif

ifdif <NmiFlag>, <Nmi>

        mov     ecx, APC_LEVEL          ; get APC level

        SetIrql                         ; set IRQL to APC level

        sti                             ; allow interrupts
        call    KiInitiateUserApc       ; initiate APC execution
        cli                             ; disable interrupts
        mov     ecx, PASSIVE_LEVEL      ; get PASSIVE level

        SetIrql                         ; set IRQL to PASSIVE level

endif

ifidn <State>, <Service>

        mov     rax, TrRax[rbp]         ; restore service status

endif

first:

;
; Check if the thread is a Scheduled UMS Thread or profiling is active.
;

ifdif <NmiFlag>, <Nmi>
        mov     rcx, gs:[PcCurrentThread] ; get current thread address
        test    dword ptr ThLock[rcx], DEBUG_ACTIVE_SCHEDULED_THREAD_LOCK or THREAD_FLAGS_CYCLE_PROFILING_LOCK
        jz      short second            ; if z, profiling and UMS are not enabled

ifidn <State>, <Service>
        mov     TrRax[rbp], rax         ; save service status
endif

        test    byte ptr ThThreadControlFlags[rcx], THREAD_FLAGS_CYCLE_PROFILING ; check for profiling
        jz      short @f                ; if z, profiling is not enabled
        call    KiCopyCounters
        mov     rcx, gs:[PcCurrentThread] ; reload current thread address
@@:
        test    byte ptr ThDebugActive[rcx], DEBUG_ACTIVE_SCHEDULED_THREAD    ; Is thread a KT/UMS thread?
        jz      short @f                ; if z, thread is not ums scheduled thread.
        lea     rsp, (-128)[rbp]        ; set the stack to top of returning trap frame

ifidn <State>, <Service>

        xor     rcx, rcx

else

        .errnz  (KUMS_UCH_VOLATILE_MASK AND 0FFFFFFFFFFFFFF00h)

        mov     cl, KUMS_UCH_VOLATILE_MASK
endif
        call    KiUmsExit
@@:

ifidn <State>, <Service>

        mov     rax, TrRax[rbp]         ; restore service status

endif

second:

endif

        ldmxcsr TrMxCsr[rbp]            ; restore XMM control/status

ifidn <State>, <Service>

        xor     r10, r10                ; scrub volatile integer register

endif

        cmp     word ptr TrDr7[rbp],  0 ; test if debug active
        jz      short third             ; if z, debug not active

ifidn <State>, <Service>

        mov     TrRax[rbp], rax         ; save service status

endif

        call    KiRestoreDebugRegisterState ; restore user debug register state

ifidn <State>, <Service>

        SETUP_FOR_INSTRUMENTATION_RETURN

        mov     rax, TrRax[rbp]         ; restore service status
endif

third:                                  ;

;
; At this point it is known that the return will be to user mode.
;

ifidn <State>, <Volatile>

        movaps  xmm0, TrXmm0[rbp]       ; restore volatile XMM registers
        movaps  xmm1, TrXmm1[rbp]       ;
        movaps  xmm2, TrXmm2[rbp]       ;
        movaps  xmm3, TrXmm3[rbp]       ;
        movaps  xmm4, TrXmm4[rbp]       ;
        movaps  xmm5, TrXmm5[rbp]       ;

        mov     r11, TrR11[rbp]         ; restore volatile integer state
        mov     r10, TrR10[rbp]         ;
        mov     r9, TrR9[rbp]           ;
        mov     r8, TrR8[rbp]           ;

ifnb <LBranch>

        mov     ecx, TrLastBranchMSR[rbp] ; get last branch MSR number
        or      ecx, ecx                ; test if last branch MSR defined
        jz      short @f                ; if z, last branch MSR not defined
        mov     eax, TrLastBranchControl[rbp] ; write last branch control register
        mov     edx, TrLastBranchControl + 4[rbp] ;
        wrmsr                           ;
@@:                                     ;

endif

        mov     rdx, TrRdx[rbp]         ;
        mov     rcx, TrRcx[rbp]         ;
        mov     rax, TrRax[rbp]         ;
        mov     rsp, rbp                ; trim stack to frame offset
        mov     rbp, TrRbp[rbp]         ; restore RBP
        add     rsp, (KTRAP_FRAME_LENGTH - (5 * 8) - 128) ; deallocate stack
        swapgs                          ; swap GS base to user mode TEB
        iretq                           ;

else

        mov     r8, TrRsp[rbp]          ; get previous RSP value
        mov     r9, TrRbp[rbp]          ; get previous RBP value
        xor     edx, edx                ; scrub volatile integer registers
        pxor    xmm0, xmm0              ; scrub volatile floating registers
        pxor    xmm1, xmm1              ;
        pxor    xmm2, xmm2              ;
        pxor    xmm3, xmm3              ;
        pxor    xmm4, xmm4              ;
        pxor    xmm5, xmm5              ;
        mov     rcx, TrRip[rbp]         ; get return address
        mov     r11, TrEFlags[rbp]      ; get previous EFLAGS
        mov     rbp, r9                 ; restore RBP
        mov     rsp, r8                 ; restore RSP
        swapgs                          ; swap GS base to user mode TEB
        sysretq                         ; return from system call to user mode

endif

ifidn <State>, <Volatile>

fourth: ldmxcsr TrMxCsr[rbp]            ; restore XMM control/status
        movaps  xmm0, TrXmm0[rbp]       ; restore volatile XMM registers
        movaps  xmm1, TrXmm1[rbp]       ;
        movaps  xmm2, TrXmm2[rbp]       ;
        movaps  xmm3, TrXmm3[rbp]       ;
        movaps  xmm4, TrXmm4[rbp]       ;
        movaps  xmm5, TrXmm5[rbp]       ;

ifidn <NmiFlag>, <Nmi>

        mov     eax, TrGsBase[rbp]      ; restore GS base MSR
        mov     edx, TrGsBase + 4[rbp]  ;
        mov     ecx, MSR_GS_BASE        ;
        wrmsr                           ;
        mov     rax, TrFaultAddress[rbp] ; restore CR2
        mov     cr2, rax                ;

endif

        mov     r11, TrR11[rbp]         ; restore volatile integer state
        mov     r10, TrR10[rbp]         ;
        mov     r9, TrR9[rbp]           ;
        mov     r8, TrR8[rbp]           ;

ifnb <LBranch>

        mov     ecx, TrLastBranchMSR[rbp] ; get last branch MSR number
        or      ecx, ecx                ; test if last branch MSR defined
        jz      short @f                ; if z, last branch MSR not defined
        mov     eax, TrLastBranchControl[rbp] ; write last branch control register
        mov     edx, TrLastBranchControl + 4[rbp] ;
        wrmsr                           ;
@@:                                     ;

endif

        mov     rdx, TrRdx[rbp]         ;
        mov     rcx, TrRcx[rbp]         ;
        mov     rax, TrRax[rbp]         ;
        mov     rsp, rbp                ; trim stack to frame offset
        mov     rbp, TrRbp[rbp]         ; restore RBP
        add     rsp, (KTRAP_FRAME_LENGTH - (5 * 8) - 128) ; deallocate stack
        iretq                           ;

endif

;
; State is kernel mode.
;

else

        mov     rsp, rbp                ; trim stack to frame offset
        mov     rbp, TrRbp[rbp]         ; restore RBP
        mov     rsp, TrRsp[rsp]         ; restore RSP
        sti                             ; enable interrupts
        ret                             ; return from system call to kernel mode

endif

        endm

;
; Define User Mode Scheduling information generation macro.
;
;   This macro detects whether the current thread participates in User Mode
;   scheduling and has entered the kernel on behalf of another user mode
;   thread.
;
;   Registers RAX, RCX, and RDX should be avaialable for consumption by this
;   macro.
;
; Arguments:
;
;   SaveGSSwap - If non-blank, then the GS Swap MSR contents are available in
;       EAX:EDX.
;
;   Thread - Supplies the register containing the current thread.
;
;   SkipLabel - Supplies a skip label if the indicated thread is not a primary.
;

PREPARE_UMS_DIRECTED_SWITCH macro SaveGSSwap, Thread, SkipLabel

        local   first

        test    byte ptr ThDebugActive[Thread], DEBUG_ACTIVE_PRIMARY_THREAD

ifnb <SkipLabel>

        jz      short SkipLabel         ; not a primary, jump to target

else

        jz      short first             ; not a primary, exit

endif

;
; If GS swap save is set, the EAX:EDX pair contains the TEB.
;

ifb <SaveGSSwap>

        mov     ecx, MSR_GS_SWAP        ; set GS swap MSR number
        rdmsr                           ; read MSR

endif

        shl     rdx, 32                 ; shift high bits
        or      rax, rdx                ; merge value to form full TEB value
        cmp     qword ptr ThTeb[Thread], rax ; check if TEB matches

ifnb <SkipLabel>

        jz      short SkipLabel         ; match, not a directed switch

else

        jz      short first             ; match, not a directed switch

endif

        cmp     qword ptr ThTebMappedLowVa[Thread], rax ; check if low TEB matches

ifnb <SkipLabel>

        jz      short SkipLabel         ; match, not a directed switch

else

        jz      short first             ; match, not a directed switch

endif

;
; This thread will attempt to perform a directed switch. Until it reaches the
; control transfer point disable normal kernel apcs (e.g. suspend) as the
; backing UMS KT may attempt to synchronize with this thread.
;

        mov     rdx, ThUcb[Thread]      ; load UMS control block
        bts     dword ptr ThMiscFlags[Thread], KTHREAD_UMS_DIRECTED_SWITCH_ENABLE_BIT
        dec     word ptr ThKernelApcDisable[Thread] ; disable normal APCs
        mov     UcbUmsTeb[rdx], rax     ; save into UCB storage slot

first:

        endm


;
; Define save trap state macro.
;
;   This macro saves the volatile state, and if necessary, saves the user
;   debug state and loads the kernel debug state.
;
; Arguments:
;
;   SaveGSSwap - If non-blank, then save the GS swap register if the previous
;       mode is user.
;
; Implicit arguments:
;
;    rbp - Supplies the address of the trap frame.
;

SAVE_TRAP_STATE macro Service, SaveGSSwap, NmiFlag, LBranch, PrepareUms

        local   first, second

        mov     TrRax[rbp], rax         ; save volatile integer registers
        mov     TrRcx[rbp], rcx         ;
        mov     TrRdx[rbp], rdx         ;

ifnb <LBranch>

        mov     ecx, KeLastBranchMSR    ; get last branch MSR number
        or      ecx, ecx                ; test if last branch MSR defined
        jz      short @f                ; if z, last branch MSR not defined
        rdmsr                           ; read last branch control register
        mov     TrLastBranchControl[rbp], eax ; save last branch control
        mov     TrLastBranchControl + 4[rbp], edx ;
        btr     eax, 0                  ; clear bit 0 in last branch control
        wrmsr                           ; disable last branch recording
@@:     mov     TrLastBranchMSR[rbp], ecx ; save last branch MSR number

endif

        mov     TrR8[rbp], r8           ;
        mov     TrR9[rbp], r9           ;
        mov     TrR10[rbp], r10         ;
        mov     TrR11[rbp], r11         ;

ifidn <NmiFlag>, <Nmi>

        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jnz     short second            ; if nz, previous mode user

;
; Preserve the current GS base in the trap frame.
;

        mov     ecx, MSR_GS_BASE        ; save GS base MSR in trap frame
        rdmsr                           ;
        mov     TrGsBase[rbp], eax      ;
        mov     TrGsBase + 4[rbp], edx  ;

;
; Load the correct kernel GS base.
;

        lea     rcx, KiProcessorBlock   ; get processor block array address
        lea     rdx, KiProcessorNumberToIndexMappingTable ; get mapping table
        mov     eax, KGDT64_R3_CMTEB    ; set selector number
        lsl     eax, eax                ; load segment limit
        mov     r8d, eax                ; make a copy of segment limit
        and     r8d, 3ffh               ; get group number
        shl     r8d, 6                  ; shift the group number by 6 bits
        shr     eax, 14                 ; extract processor number
        or      eax, r8d                ; get the index to the mapping table
        mov     eax, [rdx + rax * 4]    ; processor index
        mov     rdx, [rcx + rax * 8]    ; get current PRCB address
        sub     rdx, PcPrcb             ; compute current PCR address
        mov     eax, edx                ; set current GS base MSR
        shr     rdx, 32                 ;
        mov     ecx, MSR_GS_BASE        ;
        wrmsr                           ;

;
; Preserve CR2 in the trap frame.
;

        mov     rax, cr2                ; save CR2 in trap frame
        mov     TrFaultAddress[rbp], rax ;
        jmp     short first             ;

second:

else

        test    byte ptr TrSegCs[rbp], MODE_MASK ; test if previous mode user
        jz      short first             ; if z, previous mode kernel

endif

        swapgs                          ; swap GS base to kernel mode PCR
        mov     r10, gs:[PcCurrentThread] ; get current thread address

ifnb <SaveGSSwap>

        cmp     word ptr TrSegCs[rbp], (KGDT64_R3_CODE or RPL_MASK) ; check for 64-bit mode
        jne     short @f                ; if ne, not running in 64-bit mode
        mov     ecx, MSR_GS_SWAP        ; set GS swap MSR number
        rdmsr                           ; read GS swap MSR
        mov     TrGsSwap[rbp], eax      ; save GS swap MSR
        mov     TrGsSwap + 4[rbp], edx  ;

endif

ifnb <PrepareUms>

        PREPARE_UMS_DIRECTED_SWITCH <SaveGSSwap>, r10

endif

@@:

        test    byte ptr ThDebugActive[r10], DEBUG_ACTIVE_DBG_INSTRUMENTED ; test if debug enabled
        mov     word ptr TrDr7[rbp], 0  ; assume debug not enabled
        jz      short first             ; if e, debug/instrumentation not enabled
        call    KiSaveDebugRegisterState ; save debug register state
first:  cld                             ; clear direction flag
        stmxcsr TrMxCsr[rbp]            ; save XMM control/status
        ldmxcsr dword ptr gs:[PcMxCsr]  ; set default XMM control/status
        movaps  TrXmm0[rbp], xmm0       ; save volatile xmm registers
        movaps  TrXmm1[rbp], xmm1       ;
        movaps  TrXmm2[rbp], xmm2       ;
        movaps  TrXmm3[rbp], xmm3       ;
        movaps  TrXmm4[rbp], xmm4       ;
        movaps  TrXmm5[rbp], xmm5       ;

        endm

;
; Define interrupt frame generation macro.
;
;   This macro generates an interrupt frame.
;
; Arguments:
;
;   Vector - If non-blank, then the vector number is on the stack.
;
;   Direct - If non-blank, then the interrupt is directly connected.
;
; Return value:
;
;   If Vector is non-blank, then the value of the vector is returned in eax.
;
; Note: Trap and interrupt frames are exempt from the "first instruction must
;       be two bytes" rule.
;

GENERATE_INTERRUPT_FRAME macro Vector, Direct, NmiFlag, LBranch

        extern  KiInterlockedPopEntrySListEndEntryPoint:qword
        extern  KiInterlockedPopEntrySListResumeEntryPoint:qword
        extern  KiCheckForSListAddress:proc

;
; At this point the hardware frame has been pushed onto an aligned stack. The
; vector number or a dummy vector number and rbp have also been pushed on the
; stack.
;

ifb <Direct>

        push_reg rsi                    ; save nonvolatile register
        alloc_stack (KTRAP_FRAME_LENGTH - (8 * 8)) ; allocate fixed frame
        mov     rsi, rbp                ; set address of interrupt object

else

        alloc_stack (KTRAP_FRAME_LENGTH - (8 * 7)) ; allocate fixed frame

endif

        set_frame rbp, 128              ; set frame pointer

        END_PROLOGUE

        mov     byte ptr TrExceptionActive[rbp], 0 ; set interrupt active

        SAVE_TRAP_STATE <>, <>, <NmiFlag>, <LBranch> ; save trap state

;
; Check if a kernel-mode SLIST pop operation is being interrupted and reset
; RIP as necessary.
;

ifdifi <Direct>, <DirectNoSListCheck>

        mov     rax, KiInterlockedPopEntrySListResumeEntryPoint ; get SLIST resume address
        cmp     rax, TrRip[rbp]         ; check resume address is above RIP
        jae     short not_slist         ; if ae, resume address above RIP
        mov     rax, KiInterlockedPopEntrySListEndEntryPoint ; get SLIST end address
        cmp     rax, TrRip[rbp]         ; check end address is below RIP
        jb      short not_slist         ; if b, end address below RIP
        lea     rcx, (-128)[rbp]        ; set trap frame address
        call    KiCheckForSListAddress  ; check RIP and reset if necessary
not_slist:                              ;

endif

ifnb <Vector>

        mov     eax, TrErrorCode[rbp]   ; return vector number

endif

        inc     dword ptr gs:[PcInterruptCount] ; increment interrupt count

        endm

;
; Define enter interrupt macro.
;
;   This macro raises IRQL, sets the interrupt flag, records the previous
;   IRQL in the trap frame, and invokes the HAL to perform an EOI.
;
; Arguments:
;
;   NoEOI - If blank, then generate end of interrupt.
;
;   NoCount - If blank, then increment nesting level.
;
; Implicit arguments:
;
;   rcx - Supplies the interrupt IRQL.
;
;   rbp - Supplies the address of the trap frame.
;
;   Interrupt flag is clear.
;
; Return Value:
;
;   None.
;

ENTER_INTERRUPT macro NoEOI, NoCount, NmiFlag

        local   exit

;
; N.B. It is possible for a interrupt to occur at an IRQL that is lower
;      than the current IRQL. This happens when the IRQL raised and at
;      the same time an interrupt request is granted.
;
;
; N.B. Raise IRQL cannot be used below since this macro is used in the NMI
;      handler and would trigger a false assert.
;

        SwapIrql                        ; raise IRQL to interrupt level

        mov     TrPreviousIrql[rbp], al ; save previous IRQL

ifb <NoCount>

        mov     rcx, gs:[PcCurrentPrcb] ; get current PRCB address
        inc     byte ptr PbNestingLevel[rcx] ; increment nesting level
        cmp     byte ptr PbNestingLevel[rcx], 1 ; check if thread time
        jne     short exit              ; if ne, not thread time
        mov     r8, PbCurrentThread[rcx] ; get current thread address
        rdtsc                           ; read time stamp counter
        shl     rdx, 32                 ; combine low and high parts
        or      rax, rdx                ;
        sub     rax, PbStartCycles[rcx] ; compute total cycles for period
        add     ThCycleTime[r8], rax    ; accumulate cycles
        add     PbStartCycles[rcx], rax ; compute start of next period
        test    byte ptr ThThreadControlFlags[r8], THREAD_FLAGS_ACCOUNTING_ANY ; check for throttle or profiling
        jz      short exit              ; if z, not active
        test    byte ptr ThThreadControlFlags[r8], THREAD_FLAGS_CPU_THROTTLED ; check for throttle
        jz      @f                      ; if z, throttling not active
        mov     rdx, rax                ; set total cycles for period
        call    PsChargeProcessCpuCycles ; charge CPU cycles
        mov     r8, gs:[PcCurrentThread] ; reload current thread address
@@:     test    byte ptr ThThreadControlFlags[r8], THREAD_FLAGS_COUNTER_PROFILING ; check for profiling
        jz      short exit              ; if z, counter is enabled
        mov     rcx, r8                 ; set current thread address
        call    KiEndCounterAccumulation ;
exit:                                   ;

endif

ifb <NoEOI>

        EndSystemInterrupt              ; perform EOI

endif

ifdif <NmiFlag>, <Nmi>

        sti                             ; enable interrupts

endif

        endm

;
; Define exit interrupt macro.
;
;   This macro exits an interrupt.
;
; Arguments:
;
;   NoEOI - If blank, then generate end of interrupt.
;
;   NoCount - If blank, then decrement nesting level.
;
;   Direct - If non-blank, then the interrupt is directly connected.
;
; Implicit arguments:
;
;   rbp - Supplies the address of the trap frame.
;
; Return Value:
;
;   None.
;

EXIT_INTERRUPT macro NoEOI, NoCount, Direct, NmiFlag, LBranch

        local   decrement, exit, request

        cli                             ; disable interrupts

ifb <NoEOI>

        EndSystemInterrupt              ; perform EOI

endif

ifb <NoCount>

        mov     rcx, gs:[PcCurrentPrcb] ; get current PRCB address
        cmp     byte ptr PbNestingLevel[rcx], 1 ; check if ending processor time
        ja      short decrement         ; if nz, more interrupts nested
        rdtsc                           ; read time stamp counter
        shl     rdx, 32                 ; combine low and high parts
        or      rax, rdx                ;
        sub     rax, PbStartCycles[rcx] ; compute total cycles for period
        add     PbCycleTime[rcx], rax   ; accumulate cycles
        add     PbStartCycles[rcx], rax ; compute start of next period
        mov     rax, PbCurrentThread[rcx] ; get current thread address
        test    byte ptr ThThreadControlFlags[rax], THREAD_FLAGS_COUNTER_PROFILING ; check for counters
        jz      short @f                ; if z, counter is not enabled
        setz    dl                      ; set call from context switch to FALSE
        mov     rcx, rax                ; set current thread address
        call    KiBeginCounterAccumulation ; call counter accumulation routine
        mov     rcx, gs:[PcCurrentPrcb] ; reload rcx
@@:     mov     dl, PbInterruptRequest[rcx] ; get interrupt request value
        and     byte ptr PbInterruptRequest[rcx], 0 ; clear interrupt request
        cmp     byte ptr PbIdleHalt[rcx], 0 ; check for idle halt interrupt
        jne     short decrement         ; if ne, interrupt from idle halt
        test    dl, dl                  ; test if dispatch interrupt request
        jz      short decrement         ; if z, no dispatch interrupt request
        cmp     byte ptr TrPreviousIrql[rbp], DISPATCH_LEVEL ; check for bypass
        jae     short request           ; if ae, bypass not possible
        and     byte ptr PbNestingLevel[rcx], 0 ; clear nesting level
        call    KiDpcInterruptBypass    ; bypass dispatch interrupt
        jmp     short exit              ; finish in common code

request:                                ;
        mov     ecx, DISPATCH_LEVEL     ; request dispatch interrupt
        call    __imp_HalRequestSoftwareInterrupt ;
        mov     rcx, gs:[PcCurrentPrcb] ; reload rcx

decrement:
        dec     byte ptr PbNestingLevel[rcx] ; decrement nesting level                                ;

exit:

endif

        movzx   ecx, byte ptr TrPreviousIrql[rbp] ; get previous IRQL

        SetIrql                         ; set IRQL to previous level

ifb <Direct>

        mov     rsi, TrRsi[rbp]         ; restore extra register

endif

        RESTORE_TRAP_STATE <Volatile>, <NoDisable>, <NmiFlag>, <LBranch> ; restore trap state

        endm

;
; Define trap frame generation macro.
;
;   This macro generates a trap frame.
;
; Arguments:
;
;   ErrorCode - If non-blank, then an error code is on the stack.
;
;   PatchCycle - If non-blank, then store the global patch cycle count in
;       the trap frame.
;
;   SaveGSSwap - If non-blank, then save the GS swap register if the previous
;       mode is user.
;
;   PrepareUms - If non-blank, then this trap entry point supports user mode
;       scheduling (UMS). Function must either always call KiExceptionDispatch
;       at some point or explicitly call KiUmsTrapEntry upfront if 
;       KTHREAD_UMS_DIRECTED_SWITCH_ENABLE_BIT is set.
;
; Return value:
;
;   If ErrorCode is non-blank, then the value of the error code is returned
;   in eax.
;
; Note: Trap and interrupt frames are exempt from the "first instruction must
;       be two bytes" rule.
;

GENERATE_TRAP_FRAME macro ErrorCode, PatchCycle, SaveGSSwap, PrepareUms

        local   exit

ifb <ErrorCode>

        push_frame                      ; mark machine frame without error code
        alloc_stack 8                   ; allocate dummy error code

else

ifidn <ErrorCode>, <MxCsr>

        push_frame                      ; mark machine frame without error code
        alloc_stack 8                   ; allocate dummy error code

else

        push_frame code                 ; mark machine frame with error code

endif

endif

        push_reg rbp                    ; save nonvolatile register
        alloc_stack (KTRAP_FRAME_LENGTH - (7 * 8)) ; allocate fixed frame
        set_frame rbp, 128              ; set frame pointer

        END_PROLOGUE

        mov     byte ptr TrExceptionActive[rbp], 1 ; set exception active

        SAVE_TRAP_STATE <>, <SaveGSSwap>, <>, <>, <PrepareUms> ; save trap state

ifnb <PatchCycle>

        mov     eax, KiCodePatchCycle   ; get current patch cycle count
        mov     TrCodePatchCycle[rbp], eax ; save patch cycle count

endif

ifnb <ErrorCode>

ifidn <ErrorCode>, <MxCsr>

        mov     ax, TrMxCsr[rbp]        ; return saved MXCSR

else

        mov     eax, TrErrorCode[rbp]   ; return error code

ifidn <ErrorCode>, <Virtual>

        mov     rcx, cr2                ; return virtual address

endif

endif

endif

;
; Enable interrupts if and only if they were enabled before the trap occurred.
; If the exception is not handled by the kernel debugger and interrupts were
; previously disabled, then a bug check will occur.
;

        test    qword ptr TrEFlags[rbp], EFLAGS_IF_MASK ; test if interrupt enabled
        jz      short exit              ; if z, interrupts not enabled
        sti                             ; enable interrupts
exit:                                   ; reference label

        endm

;
; Define kernel icecap macros for tracing assembly routines.
;

ifdef _CAPKERN

ifndef _ICECAP_ASM

        extern  __CAP_Start_Profiling:proc
        extern  __CAP_End_Profiling:proc

endif

;
; CAPSTART - Log a call-record.
;
; Both Caller and Callee are functions.
;
; __CAP_Start_Profiling does not use PxHome locations.
;

CAPSTART macro Caller, Callee

        push    rcx                     ; save volatile register
        lea     rcx, Callee             ; set address of callee
        call    __CAP_Start_Profiling   ; record profiling information
        pop     rcx                     ; restore volatile register

        endm

;
; CAPSTART2 - Log a call-record.
;
; Caller is a function and Callee is a register or memory location.
;
; The reason for having CAPSTART2 is that AMD64 assembler does not
; allow "mov <register>, <function-name>" -- it only accepts "lea"
; for storing a function-pointer into a register (see above).
;
; __CAP_Start_Profiling does not use PxHome locations.
;

CAPSTART2 macro Caller, Callee

        push    rcx                     ; save volatile register
        mov     rcx, Callee             ; set address of callee
        call    __CAP_Start_Profiling   ; record profiling information
        pop     rcx                     ; restore volatile register

        endm

;
; CAPEND - Log a return record.
;
; Caller is a function.
;
; __CAP_End_Profiling does not use PxHome locations.
;

CAPEND macro Caller

        push    rcx                     ; save volatile register
        call    __CAP_End_Profiling     ; record profiling information
        pop     rcx                     ; restore volatile register

        endm

;
; CAPTRAP - Log a trap record.
;

CAPTRAP macro

        call    __CAP_Trap              ; record profile information

        endm

;
; CAPSYSTEMSERVICE - Log a system service record.
;

CAPSYSTEMSERVICE macro

        call    __CAP_SystemService     ; record profile information

        endm

else

CAPSTART macro Caller, Callee

        endm

CAPSTART2 macro Caller, Callee

        endm

CAPEND macro Caller

        endm

CAPTRAP macro

        endm

CAPSYSTEMSERVICE macro

        endm

endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\l2cmn.h ===
/*++

Copyright (c) 2004 Microsoft Corporation

Module Name:

    l2cmn.h

Abstract:

    Definitions and data strcutures for common layer 2

Environment:

    User mode only

--*/

#ifndef _L2CMN_H
#define _L2CMN_H

#pragma once

#ifdef __cplusplus
extern "C" {
#endif

// Profile name max length, in characters
#define L2_PROFILE_MAX_NAME_LENGTH     256

// If a notification needs to be private that is only consumed by internal components 
// then it should be part of l2cmnpriv.h 


// the types of notification
// This signifies what kind of notification is to be passed on , the 
// 0X0000FFFF  signifies all public notifications , so all notfications that need to be public 
// should be in this range and have a single bit set as these flags can be combined.
#define L2_NOTIFICATION_SOURCE_NONE                   0
#define L2_NOTIFICATION_SOURCE_DOT3_AUTO_CONFIG       0X00000001
#define L2_NOTIFICATION_SOURCE_SECURITY  		    0X00000002
#define L2_NOTIFICATION_SOURCE_ONEX                   0X00000004	
#define L2_NOTIFICATION_SOURCE_WLAN_ACM          0X00000008
#define L2_NOTIFICATION_SOURCE_WLAN_MSM          0X00000010
#define L2_NOTIFICATION_SOURCE_WLAN_SECURITY     0X00000020
#define L2_NOTIFICATION_SOURCE_WLAN_IHV          0X00000040
#define L2_NOTIFICATION_SOURCE_WLAN_HNWK         0X00000080

#define L2_NOTIFICATION_SOURCE_ALL          				0X0000FFFF
#define L2_NOTIFICATION_CODE_PUBLIC_BEGIN         0X00000000
#define L2_NOTIFICATION_CODE_GROUP_SIZE           0x00001000
#define L2_NOTIFICATION_CODE_V2_BEGIN             (L2_NOTIFICATION_CODE_PUBLIC_BEGIN+L2_NOTIFICATION_CODE_GROUP_SIZE)

// L2 reason code 
// reason code bases
#define L2_REASON_CODE_GROUP_SIZE             0x10000
#define L2_REASON_CODE_GEN_BASE               0x10000
#define L2_REASON_CODE_DOT11_AC_BASE          (L2_REASON_CODE_GEN_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_DOT11_MSM_BASE         (L2_REASON_CODE_DOT11_AC_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_DOT11_SECURITY_BASE    (L2_REASON_CODE_DOT11_MSM_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_ONEX_BASE              (L2_REASON_CODE_DOT11_SECURITY_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_DOT3_AC_BASE           (L2_REASON_CODE_ONEX_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_DOT3_MSM_BASE          (L2_REASON_CODE_DOT3_AC_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_PROFILE_BASE           (L2_REASON_CODE_DOT3_MSM_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_IHV_BASE               (L2_REASON_CODE_PROFILE_BASE+L2_REASON_CODE_GROUP_SIZE)
#define L2_REASON_CODE_WIMAX_BASE             (L2_REASON_CODE_IHV_BASE+L2_REASON_CODE_GROUP_SIZE)

// the common reason codes
#define L2_REASON_CODE_SUCCESS			      0

// general reason code
#define L2_REASON_CODE_UNKNOWN                  (L2_REASON_CODE_GEN_BASE+1)

// common profile section missing
#define L2_REASON_CODE_PROFILE_MISSING          0x00000001

// This structure is the notification structure which needs to be filled in by each component 
// The interface guid is filled in only by the AC 
// The NotificationSource signifies the type above 
// and NotificationCode is one of the enum values 
typedef struct _L2_NOTIFICATION_DATA {
    DWORD NotificationSource;
    DWORD NotificationCode;
    GUID InterfaceGuid;
    DWORD dwDataSize;
    
#ifdef __midl
    [unique, size_is(dwDataSize)] PBYTE pData;
#else
    __field_bcount(dwDataSize) PVOID pData;
#endif

} L2_NOTIFICATION_DATA, *PL2_NOTIFICATION_DATA;

#ifdef __cplusplus
}
#endif

#endif  // _L2CMN_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LM.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lm.h

Abstract:

    This is the top level include file that includes all the files
    necessary for writing Lan Manager Application.

[Environment:]

    User Mode - Win32

--*/

#ifndef _LM_
#define _LM_

#if _MSC_VER > 1000
#pragma once
#endif

#include <lmcons.h>     // LAN Manager common definitions
#include <lmerr.h>      // LAN Manager network error definitions

#include <lmaccess.h>   // Access, Domain, Group and User classes
#include <lmalert.h>    // Alerter
#include <lmshare.h>    // Connection, File, Session and Share classes
#include <lmmsg.h>      // Message class
#include <lmremutl.h>   // Remote Utility class
#include <lmrepl.h>     // Replicator class
#include <lmserver.h>   // Server class
#include <lmsvc.h>      // Service class
#include <lmuse.h>      // Use class
#include <lmwksta.h>    // Workstation class
#include <lmapibuf.h>   // NetApiBuffer class
#include <lmerrlog.h>   // NetErrorLog class
#include <lmconfig.h>   // NetConfig class
#include <lmstats.h>    // NetStats class
#include <lmaudit.h>    // NetAudit class
#include <lmjoin.h>     // NetJoinDomain class

#endif // _LM_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMalert.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    alert.h

Abstract:

    This file contains structures for communication with the Alerter
    service.

Environment:

    User Mode - Win32

Notes:

    You must include LmCons.H before this file, since this file depends
    on values defined in LmCons.H.

    ALERT.H includes ALERTMSG.H which defines the alert message numbers


--*/


#ifndef _ALERT_
#define _ALERT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetAlertRaise(
    __in LPCWSTR AlertType,
    __in LPVOID  Buffer,
    __in DWORD   BufferSize
    );

NET_API_STATUS NET_API_FUNCTION
NetAlertRaiseEx(
    __in LPCWSTR AlertType,
    __in LPVOID  VariableInfo,
    __in DWORD   VariableInfoSize,
    __in LPCWSTR ServiceName
    );


//
//  Data Structures
//

typedef struct _STD_ALERT {
    DWORD  alrt_timestamp;
    WCHAR  alrt_eventname[EVLEN + 1];
    WCHAR  alrt_servicename[SNLEN + 1];
}STD_ALERT, *PSTD_ALERT, *LPSTD_ALERT;

typedef struct _ADMIN_OTHER_INFO {
    DWORD  alrtad_errcode;
    DWORD  alrtad_numstrings;
}ADMIN_OTHER_INFO, *PADMIN_OTHER_INFO, *LPADMIN_OTHER_INFO;

typedef struct _ERRLOG_OTHER_INFO {
    DWORD  alrter_errcode;
    DWORD  alrter_offset;
}ERRLOG_OTHER_INFO, *PERRLOG_OTHER_INFO, *LPERRLOG_OTHER_INFO;

typedef struct _PRINT_OTHER_INFO {
    DWORD  alrtpr_jobid;
    DWORD  alrtpr_status;
    DWORD  alrtpr_submitted;
    DWORD  alrtpr_size;
}PRINT_OTHER_INFO, *PPRINT_OTHER_INFO, *LPPRINT_OTHER_INFO;

typedef struct _USER_OTHER_INFO {
    DWORD  alrtus_errcode;
    DWORD  alrtus_numstrings;
}USER_OTHER_INFO, *PUSER_OTHER_INFO, *LPUSER_OTHER_INFO;

//
// Special Values and Constants
//

//
// Name of mailslot to send alert notifications
//
#define ALERTER_MAILSLOT          L"\\\\.\\MAILSLOT\\Alerter"

//
// The following macro gives a pointer to the other_info data.
// It takes an alert structure and returns a pointer to structure
// beyond the standard portion.
//

#define ALERT_OTHER_INFO(x)    ((LPBYTE)(x) + sizeof(STD_ALERT))

//
// The following macro gives a pointer to the variable-length data.
// It takes a pointer to one of the other-info structs and returns a
// pointer to the variable data portion.
//

#define ALERT_VAR_DATA(p)      ((LPBYTE)(p) + sizeof(*p))

//
//      Names of standard Microsoft-defined alert events.
//

#define ALERT_PRINT_EVENT           L"PRINTING"
#define ALERT_MESSAGE_EVENT         L"MESSAGE"
#define ALERT_ERRORLOG_EVENT        L"ERRORLOG"
#define ALERT_ADMIN_EVENT           L"ADMIN"
#define ALERT_USER_EVENT            L"USER"

//
//      Bitmap masks for prjob_status field of PRINTJOB.
//

// 2-7 bits also used in device status

#define PRJOB_QSTATUS       0x3         // Bits 0,1
#define PRJOB_DEVSTATUS     0x1fc       // 2-8 bits
#define PRJOB_COMPLETE      0x4         // Bit 2
#define PRJOB_INTERV        0x8         // Bit 3
#define PRJOB_ERROR         0x10        // Bit 4
#define PRJOB_DESTOFFLINE   0x20        // Bit 5
#define PRJOB_DESTPAUSED    0x40        // Bit 6
#define PRJOB_NOTIFY        0x80        // BIT 7
#define PRJOB_DESTNOPAPER   0x100       // BIT 8
#define PRJOB_DELETED       0x8000      // BIT 15

//
//      Values of PRJOB_QSTATUS bits in prjob_status field of PRINTJOB.
//

#define PRJOB_QS_QUEUED                 0
#define PRJOB_QS_PAUSED                 1
#define PRJOB_QS_SPOOLING               2
#define PRJOB_QS_PRINTING               3


#ifdef __cplusplus
}
#endif

#endif // _ALERT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMAPIbuf.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmapibuf.h

Abstract:

    This file contains information about NetApiBuffer APIs.

Environment:

    User Mode - Win32

Notes:

    You must include LMCONS.H before this file, since this file depends
    on values defined in LMCONS.H.

--*/

#ifndef _LMAPIBUF_
#define _LMAPIBUF_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetApiBufferAllocate(
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferFree (
    IN LPVOID Buffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferReallocate(
    IN LPVOID OldBuffer OPTIONAL,
    IN DWORD NewByteCount,
    OUT LPVOID * NewBuffer
    );

NET_API_STATUS NET_API_FUNCTION
NetApiBufferSize(
    IN LPVOID Buffer,
    OUT LPDWORD ByteCount
    );


//
// The following private function will go away eventually.
// Call NetApiBufferAllocate instead.
//
NET_API_STATUS NET_API_FUNCTION
NetapipBufferAllocate (                 // Internal Function
    IN DWORD ByteCount,
    OUT LPVOID * Buffer
    );

#ifdef __cplusplus
}
#endif

#endif // _LMAPIBUF_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMaccess.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmaccess.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetUser, NetUserModals, NetGroup, NetAccess, and NetLogon API.

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

//
// User Class
//

#ifndef _LMUSER_
#define _LMUSER_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>     // unfortunately created a dependence on this

//
// Function Prototypes - User
//

NET_API_STATUS NET_API_FUNCTION
NetUserAdd (
    IN  LPCWSTR     servername OPTIONAL,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    OUT LPDWORD    parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserEnum (
    IN  LPCWSTR     servername OPTIONAL,
    IN  DWORD      level,
    IN  DWORD      filter,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetInfo (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     username,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetUserSetInfo (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    OUT LPDWORD   parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserDel (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetGroups (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username,
    IN  DWORD     level,
    OUT LPBYTE    *bufptr,
    IN  DWORD     prefmaxlen,
    OUT LPDWORD   entriesread,
    OUT LPDWORD   totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserSetGroups (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    IN  DWORD     num_entries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserGetLocalGroups (
    IN  LPCWSTR    servername OPTIONAL,
    IN  LPCWSTR    username,
    IN  DWORD     level,
    IN  DWORD     flags,
    OUT LPBYTE    *bufptr,
    IN  DWORD     prefmaxlen,
    OUT LPDWORD   entriesread,
    OUT LPDWORD   totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetUserModalsGet (
    IN  LPCWSTR    servername OPTIONAL,
    IN  DWORD     level,
    OUT LPBYTE    *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetUserModalsSet (
    IN  LPCWSTR    servername OPTIONAL,
    IN  DWORD     level,
    IN  LPBYTE    buf,
    OUT LPDWORD   parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUserChangePassword (
    __in_opt IN  LPCWSTR   domainname OPTIONAL,
    __in_opt IN  LPCWSTR   username OPTIONAL,
    __in IN  LPCWSTR   oldpassword,
    __in IN  LPCWSTR   newpassword
    );


//
//  Data Structures - User
//

typedef struct _USER_INFO_0 {
    LPWSTR   usri0_name;
}USER_INFO_0, *PUSER_INFO_0, *LPUSER_INFO_0;

typedef struct _USER_INFO_1 {
    LPWSTR   usri1_name;
    LPWSTR   usri1_password;
    DWORD    usri1_password_age;
    DWORD    usri1_priv;
    LPWSTR   usri1_home_dir;
    LPWSTR   usri1_comment;
    DWORD    usri1_flags;
    LPWSTR   usri1_script_path;
}USER_INFO_1, *PUSER_INFO_1, *LPUSER_INFO_1;

typedef struct _USER_INFO_2 {
    LPWSTR   usri2_name;
    LPWSTR   usri2_password;
    DWORD    usri2_password_age;
    DWORD    usri2_priv;
    LPWSTR   usri2_home_dir;
    LPWSTR   usri2_comment;
    DWORD    usri2_flags;
    LPWSTR   usri2_script_path;
    DWORD    usri2_auth_flags;
    LPWSTR   usri2_full_name;
    LPWSTR   usri2_usr_comment;
    LPWSTR   usri2_parms;
    LPWSTR   usri2_workstations;
    DWORD    usri2_last_logon;
    DWORD    usri2_last_logoff;
    DWORD    usri2_acct_expires;
    DWORD    usri2_max_storage;
    DWORD    usri2_units_per_week;
    PBYTE    usri2_logon_hours;
    DWORD    usri2_bad_pw_count;
    DWORD    usri2_num_logons;
    LPWSTR   usri2_logon_server;
    DWORD    usri2_country_code;
    DWORD    usri2_code_page;
}USER_INFO_2, *PUSER_INFO_2, *LPUSER_INFO_2;

typedef struct _USER_INFO_3 {
    LPWSTR   usri3_name;
    LPWSTR   usri3_password;
    DWORD    usri3_password_age;
    DWORD    usri3_priv;
    LPWSTR   usri3_home_dir;
    LPWSTR   usri3_comment;
    DWORD    usri3_flags;
    LPWSTR   usri3_script_path;
    DWORD    usri3_auth_flags;
    LPWSTR   usri3_full_name;
    LPWSTR   usri3_usr_comment;
    LPWSTR   usri3_parms;
    LPWSTR   usri3_workstations;
    DWORD    usri3_last_logon;
    DWORD    usri3_last_logoff;
    DWORD    usri3_acct_expires;
    DWORD    usri3_max_storage;
    DWORD    usri3_units_per_week;
    PBYTE    usri3_logon_hours;
    DWORD    usri3_bad_pw_count;
    DWORD    usri3_num_logons;
    LPWSTR   usri3_logon_server;
    DWORD    usri3_country_code;
    DWORD    usri3_code_page;
    DWORD    usri3_user_id;
    DWORD    usri3_primary_group_id;
    LPWSTR   usri3_profile;
    LPWSTR   usri3_home_dir_drive;
    DWORD    usri3_password_expired;
}USER_INFO_3, *PUSER_INFO_3, *LPUSER_INFO_3;

typedef struct _USER_INFO_4 {
    LPWSTR   usri4_name;
    LPWSTR   usri4_password;
    DWORD    usri4_password_age;
    DWORD    usri4_priv;
    LPWSTR   usri4_home_dir;
    LPWSTR   usri4_comment;
    DWORD    usri4_flags;
    LPWSTR   usri4_script_path;
    DWORD    usri4_auth_flags;
    LPWSTR   usri4_full_name;
    LPWSTR   usri4_usr_comment;
    LPWSTR   usri4_parms;
    LPWSTR   usri4_workstations;
    DWORD    usri4_last_logon;
    DWORD    usri4_last_logoff;
    DWORD    usri4_acct_expires;
    DWORD    usri4_max_storage;
    DWORD    usri4_units_per_week;
    PBYTE    usri4_logon_hours;
    DWORD    usri4_bad_pw_count;
    DWORD    usri4_num_logons;
    LPWSTR   usri4_logon_server;
    DWORD    usri4_country_code;
    DWORD    usri4_code_page;
    PSID     usri4_user_sid;
    DWORD    usri4_primary_group_id;
    LPWSTR   usri4_profile;
    LPWSTR   usri4_home_dir_drive;
    DWORD    usri4_password_expired;
}USER_INFO_4, *PUSER_INFO_4, *LPUSER_INFO_4;

typedef struct _USER_INFO_10 {
    LPWSTR   usri10_name;
    LPWSTR   usri10_comment;
    LPWSTR   usri10_usr_comment;
    LPWSTR   usri10_full_name;
}USER_INFO_10, *PUSER_INFO_10, *LPUSER_INFO_10;

typedef struct _USER_INFO_11 {
    LPWSTR   usri11_name;
    LPWSTR   usri11_comment;
    LPWSTR   usri11_usr_comment;
    LPWSTR   usri11_full_name;
    DWORD    usri11_priv;
    DWORD    usri11_auth_flags;
    DWORD    usri11_password_age;
    LPWSTR   usri11_home_dir;
    LPWSTR   usri11_parms;
    DWORD    usri11_last_logon;
    DWORD    usri11_last_logoff;
    DWORD    usri11_bad_pw_count;
    DWORD    usri11_num_logons;
    LPWSTR   usri11_logon_server;
    DWORD    usri11_country_code;
    LPWSTR   usri11_workstations;
    DWORD    usri11_max_storage;
    DWORD    usri11_units_per_week;
    PBYTE    usri11_logon_hours;
    DWORD    usri11_code_page;
}USER_INFO_11, *PUSER_INFO_11, *LPUSER_INFO_11;

typedef struct _USER_INFO_20 {
    LPWSTR   usri20_name;
    LPWSTR   usri20_full_name;
    LPWSTR   usri20_comment;
    DWORD    usri20_flags;
    DWORD    usri20_user_id;
}USER_INFO_20, *PUSER_INFO_20, *LPUSER_INFO_20;

typedef struct _USER_INFO_21 {
    BYTE     usri21_password[ENCRYPTED_PWLEN];
}USER_INFO_21, *PUSER_INFO_21, *LPUSER_INFO_21;

typedef struct _USER_INFO_22 {
    LPWSTR   usri22_name;
    BYTE     usri22_password[ENCRYPTED_PWLEN];
    DWORD    usri22_password_age;
    DWORD    usri22_priv;
    LPWSTR   usri22_home_dir;
    LPWSTR   usri22_comment;
    DWORD    usri22_flags;
    LPWSTR   usri22_script_path;
    DWORD    usri22_auth_flags;
    LPWSTR   usri22_full_name;
    LPWSTR   usri22_usr_comment;
    LPWSTR   usri22_parms;
    LPWSTR   usri22_workstations;
    DWORD    usri22_last_logon;
    DWORD    usri22_last_logoff;
    DWORD    usri22_acct_expires;
    DWORD    usri22_max_storage;
    DWORD    usri22_units_per_week;
    PBYTE    usri22_logon_hours;
    DWORD    usri22_bad_pw_count;
    DWORD    usri22_num_logons;
    LPWSTR   usri22_logon_server;
    DWORD    usri22_country_code;
    DWORD    usri22_code_page;
}USER_INFO_22, *PUSER_INFO_22, *LPUSER_INFO_22;

typedef struct _USER_INFO_23 {
    LPWSTR   usri23_name;
    LPWSTR   usri23_full_name;
    LPWSTR   usri23_comment;
    DWORD    usri23_flags;
    PSID     usri23_user_sid;
}USER_INFO_23, *PUSER_INFO_23, *LPUSER_INFO_23;

typedef struct _USER_INFO_1003 {
     LPWSTR  usri1003_password;
} USER_INFO_1003, *PUSER_INFO_1003, *LPUSER_INFO_1003;

typedef struct _USER_INFO_1005 {
     DWORD   usri1005_priv;
} USER_INFO_1005, *PUSER_INFO_1005, *LPUSER_INFO_1005;

typedef struct _USER_INFO_1006 {
     LPWSTR  usri1006_home_dir;
} USER_INFO_1006, *PUSER_INFO_1006, *LPUSER_INFO_1006;

typedef struct _USER_INFO_1007 {
     LPWSTR  usri1007_comment;
} USER_INFO_1007, *PUSER_INFO_1007, *LPUSER_INFO_1007;

typedef struct _USER_INFO_1008 {
     DWORD   usri1008_flags;
} USER_INFO_1008, *PUSER_INFO_1008, *LPUSER_INFO_1008;

typedef struct _USER_INFO_1009 {
     LPWSTR  usri1009_script_path;
} USER_INFO_1009, *PUSER_INFO_1009, *LPUSER_INFO_1009;

typedef struct _USER_INFO_1010 {
     DWORD   usri1010_auth_flags;
} USER_INFO_1010, *PUSER_INFO_1010, *LPUSER_INFO_1010;

typedef struct _USER_INFO_1011 {
     LPWSTR  usri1011_full_name;
} USER_INFO_1011, *PUSER_INFO_1011, *LPUSER_INFO_1011;

typedef struct _USER_INFO_1012 {
     LPWSTR  usri1012_usr_comment;
} USER_INFO_1012, *PUSER_INFO_1012, *LPUSER_INFO_1012;

typedef struct _USER_INFO_1013 {
     LPWSTR  usri1013_parms;
} USER_INFO_1013, *PUSER_INFO_1013, *LPUSER_INFO_1013;

typedef struct _USER_INFO_1014 {
     LPWSTR  usri1014_workstations;
} USER_INFO_1014, *PUSER_INFO_1014, *LPUSER_INFO_1014;

typedef struct _USER_INFO_1017 {
     DWORD   usri1017_acct_expires;
} USER_INFO_1017, *PUSER_INFO_1017, *LPUSER_INFO_1017;

typedef struct _USER_INFO_1018 {
     DWORD   usri1018_max_storage;
} USER_INFO_1018, *PUSER_INFO_1018, *LPUSER_INFO_1018;

typedef struct _USER_INFO_1020 {
    DWORD   usri1020_units_per_week;
    LPBYTE  usri1020_logon_hours;
} USER_INFO_1020, *PUSER_INFO_1020, *LPUSER_INFO_1020;

typedef struct _USER_INFO_1023 {
     LPWSTR  usri1023_logon_server;
} USER_INFO_1023, *PUSER_INFO_1023, *LPUSER_INFO_1023;

typedef struct _USER_INFO_1024 {
     DWORD   usri1024_country_code;
} USER_INFO_1024, *PUSER_INFO_1024, *LPUSER_INFO_1024;

typedef struct _USER_INFO_1025 {
     DWORD   usri1025_code_page;
} USER_INFO_1025, *PUSER_INFO_1025, *LPUSER_INFO_1025;

typedef struct _USER_INFO_1051 {
     DWORD   usri1051_primary_group_id;
} USER_INFO_1051, *PUSER_INFO_1051, *LPUSER_INFO_1051;

typedef struct _USER_INFO_1052 {
     LPWSTR  usri1052_profile;
} USER_INFO_1052, *PUSER_INFO_1052, *LPUSER_INFO_1052;

typedef struct _USER_INFO_1053 {
     LPWSTR  usri1053_home_dir_drive;
} USER_INFO_1053, *PUSER_INFO_1053, *LPUSER_INFO_1053;


//
//  Data Structures - User Modals
//

typedef struct _USER_MODALS_INFO_0 {
    DWORD    usrmod0_min_passwd_len;
    DWORD    usrmod0_max_passwd_age;
    DWORD    usrmod0_min_passwd_age;
    DWORD    usrmod0_force_logoff;
    DWORD    usrmod0_password_hist_len;
}USER_MODALS_INFO_0, *PUSER_MODALS_INFO_0, *LPUSER_MODALS_INFO_0;

typedef struct _USER_MODALS_INFO_1 {
    DWORD    usrmod1_role;
    LPWSTR   usrmod1_primary;
}USER_MODALS_INFO_1, *PUSER_MODALS_INFO_1, *LPUSER_MODALS_INFO_1;

typedef struct _USER_MODALS_INFO_2 {
    LPWSTR  usrmod2_domain_name;
    PSID    usrmod2_domain_id;
}USER_MODALS_INFO_2, *PUSER_MODALS_INFO_2, *LPUSER_MODALS_INFO_2;

typedef struct _USER_MODALS_INFO_3 {
    DWORD   usrmod3_lockout_duration;
    DWORD   usrmod3_lockout_observation_window;
    DWORD   usrmod3_lockout_threshold;
}USER_MODALS_INFO_3, *PUSER_MODALS_INFO_3, *LPUSER_MODALS_INFO_3;

typedef struct _USER_MODALS_INFO_1001 {
     DWORD   usrmod1001_min_passwd_len;
} USER_MODALS_INFO_1001, *PUSER_MODALS_INFO_1001, *LPUSER_MODALS_INFO_1001;

typedef struct _USER_MODALS_INFO_1002 {
     DWORD   usrmod1002_max_passwd_age;
} USER_MODALS_INFO_1002, *PUSER_MODALS_INFO_1002, *LPUSER_MODALS_INFO_1002;

typedef struct _USER_MODALS_INFO_1003 {
     DWORD   usrmod1003_min_passwd_age;
} USER_MODALS_INFO_1003, *PUSER_MODALS_INFO_1003, *LPUSER_MODALS_INFO_1003;

typedef struct _USER_MODALS_INFO_1004 {
     DWORD   usrmod1004_force_logoff;
} USER_MODALS_INFO_1004, *PUSER_MODALS_INFO_1004, *LPUSER_MODALS_INFO_1004;

typedef struct _USER_MODALS_INFO_1005 {
     DWORD   usrmod1005_password_hist_len;
} USER_MODALS_INFO_1005, *PUSER_MODALS_INFO_1005, *LPUSER_MODALS_INFO_1005;

typedef struct _USER_MODALS_INFO_1006 {
     DWORD   usrmod1006_role;
} USER_MODALS_INFO_1006, *PUSER_MODALS_INFO_1006, *LPUSER_MODALS_INFO_1006;

typedef struct _USER_MODALS_INFO_1007 {
     LPWSTR  usrmod1007_primary;
} USER_MODALS_INFO_1007, *PUSER_MODALS_INFO_1007, *LPUSER_MODALS_INFO_1007;


//
// Special Values and Constants - User
//

//
//  Bit masks for field usriX_flags of USER_INFO_X (X = 0/1).
//

#define UF_SCRIPT                          0x0001
#define UF_ACCOUNTDISABLE                  0x0002
#define UF_HOMEDIR_REQUIRED                0x0008
#define UF_LOCKOUT                         0x0010
#define UF_PASSWD_NOTREQD                  0x0020
#define UF_PASSWD_CANT_CHANGE              0x0040
#define UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED 0x0080

//
// Account type bits as part of usri_flags.
//

#define UF_TEMP_DUPLICATE_ACCOUNT       0x0100
#define UF_NORMAL_ACCOUNT               0x0200
#define UF_INTERDOMAIN_TRUST_ACCOUNT    0x0800
#define UF_WORKSTATION_TRUST_ACCOUNT    0x1000
#define UF_SERVER_TRUST_ACCOUNT         0x2000

#define UF_MACHINE_ACCOUNT_MASK ( UF_INTERDOMAIN_TRUST_ACCOUNT | \
                                  UF_WORKSTATION_TRUST_ACCOUNT | \
                                  UF_SERVER_TRUST_ACCOUNT )

#define UF_ACCOUNT_TYPE_MASK         ( \
                    UF_TEMP_DUPLICATE_ACCOUNT | \
                    UF_NORMAL_ACCOUNT | \
                    UF_INTERDOMAIN_TRUST_ACCOUNT | \
                    UF_WORKSTATION_TRUST_ACCOUNT | \
                    UF_SERVER_TRUST_ACCOUNT \
                )


#define UF_DONT_EXPIRE_PASSWD                         0x10000
#define UF_MNS_LOGON_ACCOUNT                          0x20000
#define UF_SMARTCARD_REQUIRED                         0x40000
#define UF_TRUSTED_FOR_DELEGATION                     0x80000
#define UF_NOT_DELEGATED                             0x100000
#define UF_USE_DES_KEY_ONLY                          0x200000
#define UF_DONT_REQUIRE_PREAUTH                      0x400000
#define UF_PASSWORD_EXPIRED                          0x800000
#define UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION   0x1000000
#define UF_NO_AUTH_DATA_REQUIRED                    0x2000000
#define UF_PARTIAL_SECRETS_ACCOUNT                  0x4000000
#define UF_USE_AES_KEYS                             0x8000000

#define UF_SETTABLE_BITS        ( \
                    UF_SCRIPT | \
                    UF_ACCOUNTDISABLE | \
                    UF_LOCKOUT | \
                    UF_HOMEDIR_REQUIRED  | \
                    UF_PASSWD_NOTREQD | \
                    UF_PASSWD_CANT_CHANGE | \
                    UF_ACCOUNT_TYPE_MASK | \
                    UF_DONT_EXPIRE_PASSWD | \
                    UF_MNS_LOGON_ACCOUNT |\
                    UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED |\
                    UF_SMARTCARD_REQUIRED | \
                    UF_TRUSTED_FOR_DELEGATION | \
                    UF_NOT_DELEGATED | \
                    UF_USE_DES_KEY_ONLY  | \
                    UF_DONT_REQUIRE_PREAUTH |\
                    UF_PASSWORD_EXPIRED |\
                    UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION |\
                    UF_NO_AUTH_DATA_REQUIRED |\
                    UF_USE_AES_KEYS |\
                    UF_PARTIAL_SECRETS_ACCOUNT \
                )

//
// bit masks for the NetUserEnum filter parameter.
//

#define FILTER_TEMP_DUPLICATE_ACCOUNT       (0x0001)
#define FILTER_NORMAL_ACCOUNT               (0x0002)
// #define FILTER_PROXY_ACCOUNT                (0x0004)
#define FILTER_INTERDOMAIN_TRUST_ACCOUNT    (0x0008)
#define FILTER_WORKSTATION_TRUST_ACCOUNT    (0x0010)
#define FILTER_SERVER_TRUST_ACCOUNT         (0x0020)

//
// bit masks for the NetUserGetLocalGroups flags
//
#define LG_INCLUDE_INDIRECT         (0x0001)

//
//  Bit masks for field usri2_auth_flags of USER_INFO_2.
//

#define AF_OP_PRINT             0x1
#define AF_OP_COMM              0x2
#define AF_OP_SERVER            0x4
#define AF_OP_ACCOUNTS          0x8
#define AF_SETTABLE_BITS        (AF_OP_PRINT | AF_OP_COMM | \
                                AF_OP_SERVER | AF_OP_ACCOUNTS)

//
//  UAS role manifests under NETLOGON
//

#define UAS_ROLE_STANDALONE     0
#define UAS_ROLE_MEMBER         1
#define UAS_ROLE_BACKUP         2
#define UAS_ROLE_PRIMARY        3

//
//  Values for ParmError for NetUserSetInfo.
//

#define USER_NAME_PARMNUM               1
#define USER_PASSWORD_PARMNUM           3
#define USER_PASSWORD_AGE_PARMNUM       4
#define USER_PRIV_PARMNUM               5
#define USER_HOME_DIR_PARMNUM           6
#define USER_COMMENT_PARMNUM            7
#define USER_FLAGS_PARMNUM              8
#define USER_SCRIPT_PATH_PARMNUM        9
#define USER_AUTH_FLAGS_PARMNUM         10
#define USER_FULL_NAME_PARMNUM          11
#define USER_USR_COMMENT_PARMNUM        12
#define USER_PARMS_PARMNUM              13
#define USER_WORKSTATIONS_PARMNUM       14
#define USER_LAST_LOGON_PARMNUM         15
#define USER_LAST_LOGOFF_PARMNUM        16
#define USER_ACCT_EXPIRES_PARMNUM       17
#define USER_MAX_STORAGE_PARMNUM        18
#define USER_UNITS_PER_WEEK_PARMNUM     19
#define USER_LOGON_HOURS_PARMNUM        20
#define USER_PAD_PW_COUNT_PARMNUM       21
#define USER_NUM_LOGONS_PARMNUM         22
#define USER_LOGON_SERVER_PARMNUM       23
#define USER_COUNTRY_CODE_PARMNUM       24
#define USER_CODE_PAGE_PARMNUM          25
#define USER_PRIMARY_GROUP_PARMNUM      51
#define USER_PROFILE                    52 // ?? Delete when convenient
#define USER_PROFILE_PARMNUM            52
#define USER_HOME_DIR_DRIVE_PARMNUM     53

//
// the new infolevel counterparts of the old info level + parmnum
//

#define USER_NAME_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + USER_NAME_PARMNUM)
#define USER_PASSWORD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_PASSWORD_PARMNUM)
#define USER_PASSWORD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_PASSWORD_AGE_PARMNUM)
#define USER_PRIV_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + USER_PRIV_PARMNUM)
#define USER_HOME_DIR_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_HOME_DIR_PARMNUM)
#define USER_COMMENT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + USER_COMMENT_PARMNUM)
#define USER_FLAGS_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + USER_FLAGS_PARMNUM)
#define USER_SCRIPT_PATH_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_SCRIPT_PATH_PARMNUM)
#define USER_AUTH_FLAGS_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_AUTH_FLAGS_PARMNUM)
#define USER_FULL_NAME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + USER_FULL_NAME_PARMNUM)
#define USER_USR_COMMENT_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_USR_COMMENT_PARMNUM)
#define USER_PARMS_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + USER_PARMS_PARMNUM)
#define USER_WORKSTATIONS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_WORKSTATIONS_PARMNUM)
#define USER_LAST_LOGON_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_LAST_LOGON_PARMNUM)
#define USER_LAST_LOGOFF_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_LAST_LOGOFF_PARMNUM)
#define USER_ACCT_EXPIRES_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_ACCT_EXPIRES_PARMNUM)
#define USER_MAX_STORAGE_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_MAX_STORAGE_PARMNUM)
#define USER_UNITS_PER_WEEK_INFOLEVEL   \
            (PARMNUM_BASE_INFOLEVEL + USER_UNITS_PER_WEEK_PARMNUM)
#define USER_LOGON_HOURS_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + USER_LOGON_HOURS_PARMNUM)
#define USER_PAD_PW_COUNT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_PAD_PW_COUNT_PARMNUM)
#define USER_NUM_LOGONS_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + USER_NUM_LOGONS_PARMNUM)
#define USER_LOGON_SERVER_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_LOGON_SERVER_PARMNUM)
#define USER_COUNTRY_CODE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + USER_COUNTRY_CODE_PARMNUM)
#define USER_CODE_PAGE_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + USER_CODE_PAGE_PARMNUM)
#define USER_PRIMARY_GROUP_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + USER_PRIMARY_GROUP_PARMNUM)
#define USER_POSIX_ID_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_POSIX_ID_PARMNUM)
#define USER_HOME_DIR_DRIVE_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + USER_HOME_DIR_DRIVE_PARMNUM)

//
//  For SetInfo call (parmnum 0) when password change not required
//

#define NULL_USERSETINFO_PASSWD     "              "

#define TIMEQ_FOREVER               ((unsigned long) -1L)
#define USER_MAXSTORAGE_UNLIMITED   ((unsigned long) -1L)
#define USER_NO_LOGOFF              ((unsigned long) -1L)
#define UNITS_PER_DAY               24
#define UNITS_PER_WEEK              UNITS_PER_DAY * 7

//
// Privilege levels (USER_INFO_X field usriX_priv (X = 0/1)).
//

#define USER_PRIV_MASK      0x3
#define USER_PRIV_GUEST     0
#define USER_PRIV_USER      1
#define USER_PRIV_ADMIN     2

//
// user modals related defaults
//

#define MAX_PASSWD_LEN      PWLEN
#define DEF_MIN_PWLEN       6
#define DEF_PWUNIQUENESS    5
#define DEF_MAX_PWHIST      8

#define DEF_MAX_PWAGE       TIMEQ_FOREVER               // forever
#define DEF_MIN_PWAGE       (unsigned long) 0L          // 0 days
#define DEF_FORCE_LOGOFF    (unsigned long) 0xffffffff  // never
#define DEF_MAX_BADPW       0                           // no limit
#define ONE_DAY             (unsigned long) 01*24*3600  // 01 day

//
// User Logon Validation (codes returned)
//

#define VALIDATED_LOGON         0
#define PASSWORD_EXPIRED        2
#define NON_VALIDATED_LOGON     3

#define VALID_LOGOFF            1

//
// parmnum manifests for user modals
//

#define MODALS_MIN_PASSWD_LEN_PARMNUM       1
#define MODALS_MAX_PASSWD_AGE_PARMNUM       2
#define MODALS_MIN_PASSWD_AGE_PARMNUM       3
#define MODALS_FORCE_LOGOFF_PARMNUM         4
#define MODALS_PASSWD_HIST_LEN_PARMNUM      5
#define MODALS_ROLE_PARMNUM                 6
#define MODALS_PRIMARY_PARMNUM              7
#define MODALS_DOMAIN_NAME_PARMNUM          8
#define MODALS_DOMAIN_ID_PARMNUM            9
#define MODALS_LOCKOUT_DURATION_PARMNUM     10
#define MODALS_LOCKOUT_OBSERVATION_WINDOW_PARMNUM 11
#define MODALS_LOCKOUT_THRESHOLD_PARMNUM    12

//
// the new infolevel counterparts of the old info level + parmnum
//

#define MODALS_MIN_PASSWD_LEN_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MIN_PASSWD_LEN_PARMNUM)
#define MODALS_MAX_PASSWD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MAX_PASSWD_AGE_PARMNUM)
#define MODALS_MIN_PASSWD_AGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + MODALS_MIN_PASSWD_AGE_PARMNUM)
#define MODALS_FORCE_LOGOFF_INFOLEVEL       \
            (PARMNUM_BASE_INFOLEVEL + MODALS_FORCE_LOGOFF_PARMNUM)
#define MODALS_PASSWD_HIST_LEN_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + MODALS_PASSWD_HIST_LEN_PARMNUM)
#define MODALS_ROLE_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + MODALS_ROLE_PARMNUM)
#define MODALS_PRIMARY_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + MODALS_PRIMARY_PARMNUM)
#define MODALS_DOMAIN_NAME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + MODALS_DOMAIN_NAME_PARMNUM)
#define MODALS_DOMAIN_ID_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + MODALS_DOMAIN_ID_PARMNUM)

#endif // _LMUSER_

//
// Group Class
//

#ifndef _LMGROUP_
#define _LMGROUP_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetGroupAdd (
    IN  LPCWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupAddUser (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   GroupName,
    IN  LPCWSTR   username
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupEnum (
    IN  LPCWSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT PDWORD_PTR resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupGetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupSetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupDel (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupDelUser (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   GroupName,
    IN  LPCWSTR   Username
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupGetUsers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT PDWORD_PTR ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetGroupSetUsers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

//
//  Data Structures - Group
//

typedef struct _GROUP_INFO_0 {
    LPWSTR   grpi0_name;
}GROUP_INFO_0, *PGROUP_INFO_0, *LPGROUP_INFO_0;

typedef struct _GROUP_INFO_1 {
    LPWSTR   grpi1_name;
    LPWSTR   grpi1_comment;
}GROUP_INFO_1, *PGROUP_INFO_1, *LPGROUP_INFO_1;

typedef struct _GROUP_INFO_2 {
    LPWSTR   grpi2_name;
    LPWSTR   grpi2_comment;
    DWORD    grpi2_group_id;
    DWORD    grpi2_attributes;
}GROUP_INFO_2, *PGROUP_INFO_2;

typedef struct _GROUP_INFO_3 {
    LPWSTR   grpi3_name;
    LPWSTR   grpi3_comment;
    PSID     grpi3_group_sid;
    DWORD    grpi3_attributes;
}GROUP_INFO_3, *PGROUP_INFO_3;

typedef struct _GROUP_INFO_1002 {
     LPWSTR  grpi1002_comment;
} GROUP_INFO_1002, *PGROUP_INFO_1002, *LPGROUP_INFO_1002;

typedef struct _GROUP_INFO_1005 {
     DWORD  grpi1005_attributes;
} GROUP_INFO_1005, *PGROUP_INFO_1005, *LPGROUP_INFO_1005;


typedef struct _GROUP_USERS_INFO_0 {
     LPWSTR  grui0_name;
} GROUP_USERS_INFO_0, *PGROUP_USERS_INFO_0, *LPGROUP_USERS_INFO_0;

typedef struct _GROUP_USERS_INFO_1 {
     LPWSTR  grui1_name;
     DWORD   grui1_attributes;
} GROUP_USERS_INFO_1, *PGROUP_USERS_INFO_1, *LPGROUP_USERS_INFO_1;

//
// Special Values and Constants - Group
//

#define GROUPIDMASK                 0x8000      // MSB set if uid refers
                                                // to a group

//
// Predefined group for all normal users, administrators and guests
// LOCAL is a special group for pinball local security.
//

#define GROUP_SPECIALGRP_USERS      L"USERS"
#define GROUP_SPECIALGRP_ADMINS     L"ADMINS"
#define GROUP_SPECIALGRP_GUESTS     L"GUESTS"
#define GROUP_SPECIALGRP_LOCAL      L"LOCAL"

//
// parmnum manifests for SetInfo calls (only comment is settable)
//

#define GROUP_ALL_PARMNUM           0
#define GROUP_NAME_PARMNUM          1
#define GROUP_COMMENT_PARMNUM       2
#define GROUP_ATTRIBUTES_PARMNUM    3

//
// the new infolevel counterparts of the old info level + parmnum
//

#define GROUP_ALL_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + GROUP_ALL_PARMNUM)
#define GROUP_NAME_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + GROUP_NAME_PARMNUM)
#define GROUP_COMMENT_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + GROUP_COMMENT_PARMNUM)
#define GROUP_ATTRIBUTES_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + GROUP_ATTRIBUTES_PARMNUM)
#define GROUP_POSIX_ID_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + GROUP_POSIX_ID_PARMNUM)

#endif  // _LMGROUP_

//
// LocalGroup Class
//

#ifndef _LMLOCALGROUP_
#define _LMLOCALGROUP_

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAdd (
    IN  LPCWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAddMember (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  PSID     membersid
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupEnum (
    IN  LPCWSTR      servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN OUT PDWORD_PTR resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupGetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupSetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDel (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDelMember (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   groupname,
    IN  PSID     membersid
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupGetMembers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     localgroupname,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT PDWORD_PTR resumehandle
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupSetMembers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupAddMembers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

NET_API_STATUS NET_API_FUNCTION
NetLocalGroupDelMembers (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     groupname,
    IN  DWORD      level,
    IN  LPBYTE     buf,
    IN  DWORD      totalentries
    );

//
//  Data Structures - LocalGroup
//

typedef struct _LOCALGROUP_INFO_0 {
    LPWSTR   lgrpi0_name;
}LOCALGROUP_INFO_0, *PLOCALGROUP_INFO_0, *LPLOCALGROUP_INFO_0;

typedef struct _LOCALGROUP_INFO_1 {
    LPWSTR   lgrpi1_name;
    LPWSTR   lgrpi1_comment;
}LOCALGROUP_INFO_1, *PLOCALGROUP_INFO_1, *LPLOCALGROUP_INFO_1;

typedef struct _LOCALGROUP_INFO_1002 {
     LPWSTR  lgrpi1002_comment;
}LOCALGROUP_INFO_1002, *PLOCALGROUP_INFO_1002, *LPLOCALGROUP_INFO_1002;

typedef struct _LOCALGROUP_MEMBERS_INFO_0 {
     PSID    lgrmi0_sid;
} LOCALGROUP_MEMBERS_INFO_0, *PLOCALGROUP_MEMBERS_INFO_0,
  *LPLOCALGROUP_MEMBERS_INFO_0;

typedef struct _LOCALGROUP_MEMBERS_INFO_1 {
     PSID         lgrmi1_sid;
     SID_NAME_USE lgrmi1_sidusage;
     LPWSTR       lgrmi1_name;
} LOCALGROUP_MEMBERS_INFO_1, *PLOCALGROUP_MEMBERS_INFO_1,
  *LPLOCALGROUP_MEMBERS_INFO_1;

typedef struct _LOCALGROUP_MEMBERS_INFO_2 {
     PSID         lgrmi2_sid;
     SID_NAME_USE lgrmi2_sidusage;
     LPWSTR       lgrmi2_domainandname;
} LOCALGROUP_MEMBERS_INFO_2, *PLOCALGROUP_MEMBERS_INFO_2,
  *LPLOCALGROUP_MEMBERS_INFO_2;

typedef struct _LOCALGROUP_MEMBERS_INFO_3 {
     LPWSTR       lgrmi3_domainandname;
} LOCALGROUP_MEMBERS_INFO_3, *PLOCALGROUP_MEMBERS_INFO_3,
  *LPLOCALGROUP_MEMBERS_INFO_3;

typedef struct _LOCALGROUP_USERS_INFO_0 {
     LPWSTR  lgrui0_name;
} LOCALGROUP_USERS_INFO_0, *PLOCALGROUP_USERS_INFO_0,
  *LPLOCALGROUP_USERS_INFO_0;


#define LOCALGROUP_NAME_PARMNUM          1
#define LOCALGROUP_COMMENT_PARMNUM       2

//
// Display Information APIs
//

NET_API_STATUS NET_API_FUNCTION
NetQueryDisplayInformation(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN DWORD Index,
    IN DWORD EntriesRequested,
    IN DWORD PreferredMaximumLength,
    OUT LPDWORD ReturnedEntryCount,
    OUT PVOID   *SortedBuffer );

NET_API_STATUS NET_API_FUNCTION
NetGetDisplayInformationIndex(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD Level,
    IN LPCWSTR Prefix,
    OUT LPDWORD Index );

//
// QueryDisplayInformation levels

typedef struct _NET_DISPLAY_USER {
    LPWSTR   usri1_name;
    LPWSTR   usri1_comment;
    DWORD    usri1_flags;
    LPWSTR   usri1_full_name;
    DWORD    usri1_user_id;
    DWORD    usri1_next_index;
} NET_DISPLAY_USER, *PNET_DISPLAY_USER;

typedef struct _NET_DISPLAY_MACHINE {
    LPWSTR   usri2_name;
    LPWSTR   usri2_comment;
    DWORD    usri2_flags;
    DWORD    usri2_user_id;
    DWORD    usri2_next_index;
} NET_DISPLAY_MACHINE, *PNET_DISPLAY_MACHINE;

typedef struct _NET_DISPLAY_GROUP {
    LPWSTR   grpi3_name;
    LPWSTR   grpi3_comment;
    DWORD    grpi3_group_id;
    DWORD    grpi3_attributes;
    DWORD    grpi3_next_index;
} NET_DISPLAY_GROUP, *PNET_DISPLAY_GROUP;

#endif  // _LMLOCALGROUP_

//
// Access Class
//

#ifndef _LMACCESS_
#define _LMACCESS_



//
// Function Prototypes - Access
//

NET_API_STATUS NET_API_FUNCTION
NetAccessAdd (
    IN  LPCWSTR   servername OPTIONAL,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetAccessEnum (
    IN  LPCWSTR     servername OPTIONAL,
    IN  LPCWSTR     BasePath,
    IN  DWORD      Recursive,
    IN  DWORD      level,
    OUT LPBYTE     *bufptr,
    IN  DWORD      prefmaxlen,
    OUT LPDWORD    entriesread,
    OUT LPDWORD    totalentries,
    IN OUT LPDWORD resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetAccessGetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   resource,
    IN  DWORD    level,
    OUT LPBYTE   *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetAccessSetInfo (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   resource,
    IN  DWORD    level,
    IN  LPBYTE   buf,
    OUT LPDWORD  parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetAccessDel (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   resource
    );

NET_API_STATUS NET_API_FUNCTION
NetAccessGetUserPerms (
    IN  LPCWSTR   servername OPTIONAL,
    IN  LPCWSTR   UGname,
    IN  LPCWSTR   resource,
    OUT LPDWORD  Perms
    );

//
// Data Structures - Access
//

typedef struct _ACCESS_INFO_0 {
    LPWSTR   acc0_resource_name;
}ACCESS_INFO_0, *PACCESS_INFO_0, *LPACCESS_INFO_0;

typedef struct _ACCESS_INFO_1 {
    LPWSTR   acc1_resource_name;
    DWORD    acc1_attr;
    DWORD    acc1_count;
}ACCESS_INFO_1, *PACCESS_INFO_1, *LPACCESS_INFO_1;

typedef struct _ACCESS_INFO_1002 {
     DWORD   acc1002_attr;
} ACCESS_INFO_1002, *PACCESS_INFO_1002, *LPACCESS_INFO_1002;


typedef struct _ACCESS_LIST {
    LPWSTR   acl_ugname;
    DWORD    acl_access;
}ACCESS_LIST, *PACCESS_LIST, *LPACCESS_LIST;

//
// Special Values and Constants - Access
//

//
// Maximum number of permission entries for each resource.
//

#define MAXPERMENTRIES      64

//
//  Bit values for the access permissions.  ACCESS_ALL is a handy
//  way to specify maximum permissions.  These are used in
//  acl_access field of access_list structures.
//

#define ACCESS_NONE         0
#define ACCESS_ALL          ( ACCESS_READ | \
                                ACCESS_WRITE | \
                                ACCESS_CREATE | \
                                ACCESS_EXEC | \
                                ACCESS_DELETE | \
                                ACCESS_ATRIB | \
                                ACCESS_PERM \
                            )

#define ACCESS_READ         0x01
#define ACCESS_WRITE        0x02
#define ACCESS_CREATE       0x04
#define ACCESS_EXEC         0x08
#define ACCESS_DELETE       0x10
#define ACCESS_ATRIB        0x20
#define ACCESS_PERM         0x40

#define ACCESS_GROUP        0x8000

//
// Bit values for the acc1_attr field of the ACCESS_INFO_1 structure.
//

#define ACCESS_AUDIT        0x1

#define ACCESS_SUCCESS_OPEN         0x10
#define ACCESS_SUCCESS_WRITE        0x20
#define ACCESS_SUCCESS_DELETE       0x40
#define ACCESS_SUCCESS_ACL          0x80
#define ACCESS_SUCCESS_MASK         0xF0

#define ACCESS_FAIL_OPEN            0x100
#define ACCESS_FAIL_WRITE           0x200
#define ACCESS_FAIL_DELETE          0x400
#define ACCESS_FAIL_ACL             0x800
#define ACCESS_FAIL_MASK            0xF00

#define ACCESS_FAIL_SHIFT           4

//
// Parmnum value for NetAccessSetInfo.
//

#define ACCESS_RESOURCE_NAME_PARMNUM    1
#define ACCESS_ATTR_PARMNUM             2
#define ACCESS_COUNT_PARMNUM            3
#define ACCESS_ACCESS_LIST_PARMNUM      4

//
// the new infolevel counterparts of the old info level + parmnum
//

#define ACCESS_RESOURCE_NAME_INFOLEVEL  \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_RESOURCE_NAME_PARMNUM)
#define ACCESS_ATTR_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_ATTR_PARMNUM)
#define ACCESS_COUNT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_COUNT_PARMNUM)
#define ACCESS_ACCESS_LIST_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + ACCESS_ACCESS_LIST_PARMNUM)

//
// ACCESS_LETTERS defines a letter for each bit position in
// the acl_access field of struct access_list.  Note that some
// bits have a corresponding letter of ' ' (space).
//

#define ACCESS_LETTERS      "RWCXDAP         "



//    ********************************
//
//    Password Checking API structures
//
//    ********************************


//
//    What kind of password checking is to be performed?
//        NetValidateAuthentication : Check if the authentication can be done
//        NetValidatePasswordChange: Check if the password can be changed
//        NetValidatePasswordReset: Reset the password to the given value
//
typedef enum _NET_VALIDATE_PASSWORD_TYPE{
    NetValidateAuthentication = 1,
    NetValidatePasswordChange,
    NetValidatePasswordReset
} NET_VALIDATE_PASSWORD_TYPE, *PNET_VALIDATE_PASSWORD_TYPE;

//
//    Structure to keep the password hash
//
typedef struct _NET_VALIDATE_PASSWORD_HASH{
    ULONG Length;
    LPBYTE Hash;
} NET_VALIDATE_PASSWORD_HASH, *PNET_VALIDATE_PASSWORD_HASH;

// To be used with PresentFields member of NET_VALIDATE_PERSISTED_FIELDS
#define NET_VALIDATE_PASSWORD_LAST_SET          0x00000001
#define NET_VALIDATE_BAD_PASSWORD_TIME          0x00000002
#define NET_VALIDATE_LOCKOUT_TIME               0x00000004
#define NET_VALIDATE_BAD_PASSWORD_COUNT         0x00000008
#define NET_VALIDATE_PASSWORD_HISTORY_LENGTH    0x00000010
#define NET_VALIDATE_PASSWORD_HISTORY           0x00000020

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME, *PFILETIME;
#endif

//
//    Structure to keep information about the password and related things.
//        Present Fields: (used only in output args) which fields are changed.
//            See the constants above.
//        PasswordLastSet: When the password is last set.
//        BadPasswordTime: When the password was incorrect for the last time.
//        LockoutTime: When the account is locked out. If the account is not locked out
//            it is 0.
//        BadPasswordCount: How many times the password has given incorrectly in the
//            Observation Window.
//        PasswordHistoryLength: How many passwords are kept in the history
//        PasswordHistory: Password hashes that are in the history
//
typedef struct _NET_VALIDATE_PERSISTED_FIELDS{
    ULONG   PresentFields;
    FILETIME PasswordLastSet;
    FILETIME BadPasswordTime;
    FILETIME LockoutTime;
    ULONG   BadPasswordCount;
    ULONG   PasswordHistoryLength;
    PNET_VALIDATE_PASSWORD_HASH PasswordHistory;
} NET_VALIDATE_PERSISTED_FIELDS, *PNET_VALIDATE_PERSISTED_FIELDS;

//
//    Output Arg
//        ChangedPersistedFields: Any changes to the password related info
//        ValidationStatus: Shows the result of the request
//
typedef struct _NET_VALIDATE_OUTPUT_ARG{
    NET_VALIDATE_PERSISTED_FIELDS ChangedPersistedFields;
    NET_API_STATUS ValidationStatus;
} NET_VALIDATE_OUTPUT_ARG, *PNET_VALIDATE_OUTPUT_ARG;

//
//    If authentication type of password check is to be made,
//        this kind of input must be used
//
//    InputPersistedFields: Information about the account to be logged into
//    PasswordMatched: Indicates the result of the application's authentication of the supplied password
//
typedef struct _NET_VALIDATE_AUTHENTICATION_INPUT_ARG{
    NET_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    BOOLEAN PasswordMatched;
} NET_VALIDATE_AUTHENTICATION_INPUT_ARG, *PNET_VALIDATE_AUTHENTICATION_INPUT_ARG;

//
//    If password change type of check is to be made,
//        this kind of input must be used
//
//    InputPersistedFields: Information about the account to be logged into
//    ClearPassword: The string which password is going to be
//    UserAccountName: Name of the user account
//    HashedPassword: Hash of the string that the password is going to be
//    PasswordMatch: denotes if the old password supplied by user matched or not
//
typedef struct  _NET_VALIDATE_PASSWORD_CHANGE_INPUT_ARG{
    NET_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    LPWSTR ClearPassword;
    LPWSTR UserAccountName;
    NET_VALIDATE_PASSWORD_HASH HashedPassword;
    BOOLEAN PasswordMatch;
} NET_VALIDATE_PASSWORD_CHANGE_INPUT_ARG, *PNET_VALIDATE_PASSWORD_CHANGE_INPUT_ARG;

//
//    If password reset type of check is to be made,
//        this kind of input must be used
//
//    InputPersistedFields: Information about the account to be logged into
//    ClearPassword: The string which password is going to be
//    UserAccountName: Name of the user account
//    HashedPassword: Hash of the string that the password is going to be
//    PasswordMustChangeAtNextLogon: Password must change for the user to be logged in
//    ClearLockout: If the account was locked out, this field can be used to clear lockout
//
typedef struct _NET_VALIDATE_PASSWORD_RESET_INPUT_ARG{
    NET_VALIDATE_PERSISTED_FIELDS InputPersistedFields;
    LPWSTR ClearPassword;
    LPWSTR UserAccountName;
    NET_VALIDATE_PASSWORD_HASH HashedPassword;
    BOOLEAN  PasswordMustChangeAtNextLogon;
    BOOLEAN  ClearLockout;
} NET_VALIDATE_PASSWORD_RESET_INPUT_ARG, *PNET_VALIDATE_PASSWORD_RESET_INPUT_ARG;

//
//    Password Checking API structures end here
//

NET_API_STATUS NET_API_FUNCTION
NetValidatePasswordPolicy(
    IN LPCWSTR ServerName,
    IN LPVOID Qualifier,
    IN NET_VALIDATE_PASSWORD_TYPE ValidationType,
    IN LPVOID InputArg,
    OUT LPVOID *OutputArg
    );

NET_API_STATUS NET_API_FUNCTION
NetValidatePasswordPolicyFree(
    IN LPVOID *OutputArg
    );

#endif // _LMACCESS_

//
// Domain Class
//

#ifndef _LMDOMAIN_
#define _LMDOMAIN_

//
// Function Prototypes - Domain
//

NET_API_STATUS NET_API_FUNCTION
NetGetDCName (
    __in_opt IN  LPCWSTR   servername OPTIONAL,
    __in_opt IN  LPCWSTR   domainname OPTIONAL,
    OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetGetAnyDCName (
    __in_opt IN  LPCWSTR   servername OPTIONAL,
    __in_opt IN  LPCWSTR   domainname OPTIONAL,
    OUT LPBYTE  *bufptr
    );


NET_API_STATUS NET_API_FUNCTION
I_NetLogonControl(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    OUT LPBYTE *Buffer
    );

NET_API_STATUS NET_API_FUNCTION
I_NetLogonControl2(
    IN LPCWSTR ServerName OPTIONAL,
    IN DWORD FunctionCode,
    IN DWORD QueryLevel,
    IN LPBYTE Data,
    OUT LPBYTE *Buffer
    );

#ifndef _NTDEF_
typedef LONG NTSTATUS, *PNTSTATUS;
#endif

NTSTATUS NET_API_FUNCTION
NetEnumerateTrustedDomains (
    __in_opt IN LPWSTR ServerName OPTIONAL,
    __deref_out OUT LPWSTR *DomainNames
    );



//
// Special Values and Constants - Domain
//

//
// FunctionCode values for I_NetLogonControl.
//
// NOTE : if you change the following NETLOGON_CONTROL_* values,
// change them in net\svcdlls\logonsrv\logon.idl file also.
//

#define NETLOGON_CONTROL_QUERY         1    // No-op: just query
#define NETLOGON_CONTROL_REPLICATE     2    // Force replicate on BDC
#define NETLOGON_CONTROL_SYNCHRONIZE   3    // Force synchronize on BDC
#define NETLOGON_CONTROL_PDC_REPLICATE 4    // Force PDC to broadcast change
#define NETLOGON_CONTROL_REDISCOVER    5    // Force to re-discover trusted domain DCs
#define NETLOGON_CONTROL_TC_QUERY      6    // Query status of specified trusted channel status
#define NETLOGON_CONTROL_TRANSPORT_NOTIFY 7 // Notify netlogon that a new transport has come online
#define NETLOGON_CONTROL_FIND_USER     8    // Find named user in a trusted domain
#define NETLOGON_CONTROL_CHANGE_PASSWORD 9  // Change machine password on a secure channel to a trusted domain
#define NETLOGON_CONTROL_TC_VERIFY     10   // Verify status of specified trusted channel
#define NETLOGON_CONTROL_FORCE_DNS_REG 11   // Force DNS re-registration of all registered records
#define NETLOGON_CONTROL_QUERY_DNS_REG 12   // Query the status of DNS updates

// Debug function codes

#define NETLOGON_CONTROL_UNLOAD_NETLOGON_DLL 0xFFFB
#define NETLOGON_CONTROL_BACKUP_CHANGE_LOG  0xFFFC
#define NETLOGON_CONTROL_TRUNCATE_LOG       0xFFFD
#define NETLOGON_CONTROL_SET_DBFLAG         0xFFFE
#define NETLOGON_CONTROL_BREAKPOINT         0xFFFF

//
// Query level 1 for I_NetLogonControl
//

typedef struct _NETLOGON_INFO_1 {
        DWORD netlog1_flags;
        NET_API_STATUS netlog1_pdc_connection_status;
} NETLOGON_INFO_1, *PNETLOGON_INFO_1;

typedef struct _NETLOGON_INFO_2 {
        DWORD netlog2_flags;

        //
        // If NETLOGON_VERIFY_STATUS_RETURNED bit is set in
        //  netlog2_flags, the following field will return
        //  the status of trust verification. Otherwise,
        //  the field will return the status of the secure
        //  channel to the primary domain of the machine
        //  (useful for BDCs only).
        //
        NET_API_STATUS netlog2_pdc_connection_status;
#ifdef MIDL_PASS
        [string] wchar_t * netlog2_trusted_dc_name;
#else
        LPWSTR netlog2_trusted_dc_name;
#endif // MIDL_PASS
        NET_API_STATUS netlog2_tc_connection_status;
} NETLOGON_INFO_2, *PNETLOGON_INFO_2;

typedef struct _NETLOGON_INFO_3 {
        DWORD netlog3_flags;
        DWORD netlog3_logon_attempts;
        DWORD netlog3_reserved1;
        DWORD netlog3_reserved2;
        DWORD netlog3_reserved3;
        DWORD netlog3_reserved4;
        DWORD netlog3_reserved5;
} NETLOGON_INFO_3, *PNETLOGON_INFO_3;

typedef struct _NETLOGON_INFO_4 {
#ifdef MIDL_PASS
        [string] wchar_t * netlog4_trusted_dc_name;
        [string] wchar_t * netlog4_trusted_domain_name;
#else
        LPWSTR netlog4_trusted_dc_name;
        LPWSTR netlog4_trusted_domain_name;
#endif // MIDL_PASS
} NETLOGON_INFO_4, *PNETLOGON_INFO_4;

//
// Values of netlog1_flags
//

#define NETLOGON_REPLICATION_NEEDED       0x01  // Database is out of date
#define NETLOGON_REPLICATION_IN_PROGRESS  0x02  // Replication is happening now
#define NETLOGON_FULL_SYNC_REPLICATION    0x04  // full sync replication required/progress
#define NETLOGON_REDO_NEEDED              0x08  // Redo of previous replication needed
#define NETLOGON_HAS_IP                   0x10  // The trusted domain DC has an IP address
#define NETLOGON_HAS_TIMESERV             0x20  // The trusted domain DC runs the Windows Time Service
#define NETLOGON_DNS_UPDATE_FAILURE       0x40  // There was a failure in the last update for one of the DNS records
#define NETLOGON_VERIFY_STATUS_RETURNED   0x80  // Trust verification status returned in netlog2_pdc_connection_status

#define SERVICE_ACCOUNT_PASSWORD TEXT("_SA_{262E99C9-6160-4871-ACEC-4E61736B6F21}")
#define SERVICE_ACCOUNT_SECRET_PREFIX TEXT("_SC_{262E99C9-6160-4871-ACEC-4E61736B6F21}_")

DEFINE_GUID( //262e99c9-6160-4871-acec-4e61736b6f21
    ServiceAccountPasswordGUID,
    0x262E99C9,
    0x6160,
    0x4871,
    0xAC, 0xEC, 0x4E, 0x61, 0x73, 0x6B, 0x6F, 0x21 );

NTSTATUS
NetAddServiceAccount(
    __in_opt LPWSTR ServerName,
    __in LPWSTR AccountName,
    __in LPWSTR Reserved,
    __in DWORD Flags);
    
// Do not create an account by this name
// Only link this account to my computer if it exists
#define SERVICE_ACCOUNT_FLAG_LINK_TO_HOST_ONLY    0x00000001L

// Do not delete the service account object from AD
// Simply unlink it from this computer and delete the local secret
#define SERVICE_ACCOUNT_FLAG_UNLINK_FROM_HOST_ONLY    0x00000001L

NTSTATUS
NetRemoveServiceAccount(
    __in_opt LPWSTR ServerName,
    __in LPWSTR AccountName,
    __in DWORD Flags);

NTSTATUS
NetEnumerateServiceAccounts(
    __in_opt LPWSTR ServerName,
    __in DWORD Flags,
    __out DWORD* AccountsCount,
    __deref_out_ecount(*AccountsCount) PZPWSTR* Accounts);
    
NTSTATUS
NetIsServiceAccount(
    __in_opt LPWSTR ServerName,
    __in LPWSTR AccountName,
    __out BOOL *IsService);

NTSTATUS
NetQueryServiceAccount(
    __in_opt LPWSTR ServerName,
    __in LPWSTR AccountName,
    __in DWORD InfoLevel,
    __deref_out PBYTE* Buffer);

//
//  Data Structures - Service
//

typedef enum _MSA_INFO_LEVEL {
    MsaInfoLevel0 = 0,
    MsaInfoLevelMax
} MSA_INFO_LEVEL, *PMSA_INFO_LEVEL;

typedef enum _MSA_INFO_STATE {
    MsaInfoNotExist = 1,
    MsaInfoNotService,
    MsaInfoCannotInstall,
    MsaInfoCanInstall,
    MsaInfoInstalled
}MSA_INFO_STATE, *PMSA_INFO_STATE;

typedef struct _MSA_INFO_0 {
    MSA_INFO_STATE State;
}MSA_INFO_0, *PMSA_INFO_0, *LPMSA_INFO_0;

#ifdef __cplusplus
}
#endif

#endif // _LMDOMAIN_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMat.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1992-1999  Microsoft Corporation

Module Name:

    lmat.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the schedule service API-s.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

Revision History:

--*/

#ifndef _LMAT_
#define _LMAT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
//  The following bits are used with Flags field in structures below.
//

//
//  Do we exec programs for this job periodically (/EVERY switch)
//  or one time (/NEXT switch).
//
#define JOB_RUN_PERIODICALLY            0x01    //  set if EVERY


//
//  Was there an error last time we tried to exec a program on behalf of
//  this job.
//  This flag is meaningfull on output only!
//
#define JOB_EXEC_ERROR                  0x02    //  set if error

//
//  Will this job run today or tomorrow.
//  This flag is meaningfull on output only!
//
#define JOB_RUNS_TODAY                  0x04    //  set if today

//
//  Add current day of the month to DaysOfMonth input.
//  This flag is meaningfull on input only!
//
#define JOB_ADD_CURRENT_DATE            0x08    // set if to add current date


//
//  Will this job be run interactively or not.  Windows NT 3.1 do not
//  know about this bit, i.e. they submit interactive jobs only.
//
#define JOB_NONINTERACTIVE              0x10    // set for noninteractive


#define JOB_INPUT_FLAGS     (   JOB_RUN_PERIODICALLY        |   \
                                JOB_ADD_CURRENT_DATE        |   \
                                JOB_NONINTERACTIVE  )

#define JOB_OUTPUT_FLAGS    (   JOB_RUN_PERIODICALLY        |   \
                                JOB_EXEC_ERROR              |   \
                                JOB_RUNS_TODAY              |   \
                                JOB_NONINTERACTIVE  )



typedef struct _AT_INFO {
    DWORD_PTR   JobTime;
    DWORD   DaysOfMonth;
    UCHAR   DaysOfWeek;
    UCHAR   Flags;
    LPWSTR  Command;
} AT_INFO, *PAT_INFO, *LPAT_INFO;

typedef struct _AT_ENUM {
    DWORD   JobId;
    DWORD_PTR   JobTime;
    DWORD   DaysOfMonth;
    UCHAR   DaysOfWeek;
    UCHAR   Flags;
    LPWSTR  Command;
} AT_ENUM, *PAT_ENUM, *LPAT_ENUM;

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobAdd(
    IN      LPCWSTR         Servername  OPTIONAL,
    IN      LPBYTE          Buffer,
    OUT     LPDWORD         JobId
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobDel(
    IN      LPCWSTR         Servername  OPTIONAL,
    IN      DWORD           MinJobId,
    IN      DWORD           MaxJobId
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobEnum(
    IN      LPCWSTR         Servername              OPTIONAL,
    OUT     LPBYTE *        PointerToBuffer,
    IN      DWORD           PrefferedMaximumLength,
    OUT     LPDWORD         EntriesRead,
    OUT     LPDWORD         TotalEntries,
    IN OUT  LPDWORD         ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetScheduleJobGetInfo(
    IN      LPCWSTR         Servername              OPTIONAL,
    IN      DWORD           JobId,
    OUT     LPBYTE *        PointerToBuffer
    );

#ifdef __cplusplus
}
#endif

#endif // _LMAT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMaudit.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmaudit.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetAudit

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMAUDIT_
#define _LMAUDIT_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef _LMHLOGDEFINED_
#define _LMHLOGDEFINED_

typedef struct _HLOG {
     DWORD          time;
     DWORD          last_flags;
     DWORD          offset;
     DWORD          rec_offset;
} HLOG, *PHLOG, *LPHLOG;

#define LOGFLAGS_FORWARD	0
#define LOGFLAGS_BACKWARD	0x1
#define LOGFLAGS_SEEK		0x2

#endif

//
// Function Prototypes - Audit
//

NET_API_STATUS NET_API_FUNCTION
NetAuditClear (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  backupfile OPTIONAL,
    IN  LPCWSTR  service OPTIONAL  // WARNING: buggy support before LM 2.0C!!
    );

NET_API_STATUS NET_API_FUNCTION
NetAuditRead (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  service OPTIONAL,  // WARNING: buggy support before LM 2.0C!!
    IN  LPHLOG   auditloghandle,
    IN  DWORD    offset,
    IN  LPDWORD  reserved1 OPTIONAL,
    IN  DWORD   reserved2,
    IN  DWORD   offsetflag,
    OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    OUT LPDWORD bytesread,
    OUT LPDWORD totalavailable
    );

NET_API_STATUS NET_API_FUNCTION
NetAuditWrite (
    IN  DWORD    type,
    IN  LPBYTE   buf,
    IN  DWORD    numbytes,
    IN  LPCWSTR  service OPTIONAL,
    IN  LPBYTE   reserved OPTIONAL
    );


//
// Data Structures - Audit
//

typedef struct _AUDIT_ENTRY {
     DWORD          ae_len;
     DWORD          ae_reserved;
     DWORD          ae_time;
     DWORD          ae_type;
     DWORD          ae_data_offset;  /* Offset from beginning
                              address of audit_entry */
     DWORD          ae_data_size;  // byte count of ae_data area (not incl pad).
} AUDIT_ENTRY, *PAUDIT_ENTRY, *LPAUDIT_ENTRY;

#define REVISED_AUDIT_ENTRY_STRUCT


typedef struct _AE_SRVSTATUS {
     DWORD	    ae_sv_status;
} AE_SRVSTATUS, *PAE_SRVSTATUS, *LPAE_SRVSTATUS;

typedef struct _AE_SESSLOGON {
     DWORD          ae_so_compname;
     DWORD          ae_so_username;
     DWORD          ae_so_privilege;
} AE_SESSLOGON, *PAE_SESSLOGON, *LPAE_SESSLOGON;

typedef struct _AE_SESSLOGOFF {
     DWORD          ae_sf_compname;
     DWORD          ae_sf_username;
     DWORD          ae_sf_reason;
} AE_SESSLOGOFF, *PAE_SESSLOGOFF, *LPAE_SESSLOGOFF;

typedef struct _AE_SESSPWERR {
     DWORD          ae_sp_compname;
     DWORD          ae_sp_username;
} AE_SESSPWERR, *PAE_SESSPWERR, *LPAE_SESSPWERR;

typedef struct _AE_CONNSTART {
     DWORD          ae_ct_compname;
     DWORD          ae_ct_username;
     DWORD          ae_ct_netname;
     DWORD          ae_ct_connid;
} AE_CONNSTART, *PAE_CONNSTART, *LPAE_CONNSTART;

typedef struct _AE_CONNSTOP {
     DWORD          ae_cp_compname;
     DWORD          ae_cp_username;
     DWORD          ae_cp_netname;
     DWORD          ae_cp_connid;
     DWORD          ae_cp_reason;
} AE_CONNSTOP, *PAE_CONNSTOP, *LPAE_CONNSTOP;

typedef struct _AE_CONNREJ {
     DWORD          ae_cr_compname;
     DWORD          ae_cr_username;
     DWORD          ae_cr_netname;
     DWORD          ae_cr_reason;
} AE_CONNREJ, *PAE_CONNREJ, *LPAE_CONNREJ;

typedef struct _AE_RESACCESS {
     DWORD          ae_ra_compname;
     DWORD          ae_ra_username;
     DWORD          ae_ra_resname;
     DWORD          ae_ra_operation;
     DWORD          ae_ra_returncode;
     DWORD          ae_ra_restype;
     DWORD          ae_ra_fileid;
} AE_RESACCESS, *PAE_RESACCESS, *LPAE_RESACCESS;

typedef struct _AE_RESACCESSREJ {
     DWORD          ae_rr_compname;
     DWORD          ae_rr_username;
     DWORD          ae_rr_resname;
     DWORD          ae_rr_operation;
} AE_RESACCESSREJ, *PAE_RESACCESSREJ, *LPAE_RESACCESSREJ;

typedef struct _AE_CLOSEFILE {
     DWORD          ae_cf_compname;
     DWORD          ae_cf_username;
     DWORD          ae_cf_resname;
     DWORD          ae_cf_fileid;
     DWORD          ae_cf_duration;
     DWORD          ae_cf_reason;
} AE_CLOSEFILE, *PAE_CLOSEFILE, *LPAE_CLOSEFILE;

typedef struct _AE_SERVICESTAT {
     DWORD          ae_ss_compname;
     DWORD          ae_ss_username;
     DWORD          ae_ss_svcname;
     DWORD          ae_ss_status;
     DWORD          ae_ss_code;
     DWORD          ae_ss_text;
     DWORD          ae_ss_returnval;
} AE_SERVICESTAT, *PAE_SERVICESTAT, *LPAE_SERVICESTAT;

typedef struct _AE_ACLMOD {
     DWORD          ae_am_compname;
     DWORD          ae_am_username;
     DWORD          ae_am_resname;
     DWORD          ae_am_action;
     DWORD          ae_am_datalen;
} AE_ACLMOD, *PAE_ACLMOD, *LPAE_ACLMOD;

typedef struct _AE_UASMOD {
     DWORD          ae_um_compname;
     DWORD          ae_um_username;
     DWORD          ae_um_resname;
     DWORD          ae_um_rectype;
     DWORD          ae_um_action;
     DWORD          ae_um_datalen;
} AE_UASMOD, *PAE_UASMOD, *LPAE_UASMOD;

typedef struct _AE_NETLOGON {
     DWORD          ae_no_compname;
     DWORD          ae_no_username;
     DWORD          ae_no_privilege;
     DWORD          ae_no_authflags;
} AE_NETLOGON, *PAE_NETLOGON, *LPAE_NETLOGON;

typedef struct _AE_NETLOGOFF {
     DWORD          ae_nf_compname;
     DWORD          ae_nf_username;
     DWORD          ae_nf_reserved1;
     DWORD          ae_nf_reserved2;
} AE_NETLOGOFF, *PAE_NETLOGOFF, *LPAE_NETLOGOFF;

typedef struct _AE_ACCLIM {
     DWORD          ae_al_compname;
     DWORD          ae_al_username;
     DWORD          ae_al_resname;
     DWORD          ae_al_limit;
} AE_ACCLIM, *PAE_ACCLIM, *LPAE_ACCLIM;

#define ACTION_LOCKOUT          00
#define ACTION_ADMINUNLOCK      01

typedef struct _AE_LOCKOUT {
    DWORD           ae_lk_compname;     // Ptr to computername of client.
    DWORD           ae_lk_username;     // Ptr to username of client (NULL
                                        //  if same as computername).
    DWORD           ae_lk_action;       // Action taken on account:
                                        // 0 means locked out, 1 means not.
    DWORD           ae_lk_bad_pw_count; // Bad password count at the time
                                        // of lockout.
} AE_LOCKOUT, *PAE_LOCKOUT, *LPAE_LOCKOUT;

typedef struct _AE_GENERIC {
     DWORD          ae_ge_msgfile;
     DWORD          ae_ge_msgnum;
     DWORD          ae_ge_params;
     DWORD          ae_ge_param1;
     DWORD          ae_ge_param2;
     DWORD          ae_ge_param3;
     DWORD          ae_ge_param4;
     DWORD          ae_ge_param5;
     DWORD          ae_ge_param6;
     DWORD          ae_ge_param7;
     DWORD          ae_ge_param8;
     DWORD          ae_ge_param9;
} AE_GENERIC, *PAE_GENERIC, *LPAE_GENERIC;

//
// Special Values and Constants - Audit
//

//
// 	Audit entry types (field ae_type in audit_entry).
//

#define AE_SRVSTATUS	0
#define AE_SESSLOGON	1
#define AE_SESSLOGOFF	2
#define AE_SESSPWERR	3
#define AE_CONNSTART	4
#define AE_CONNSTOP	5
#define AE_CONNREJ	6
#define AE_RESACCESS	7
#define AE_RESACCESSREJ	8
#define AE_CLOSEFILE	9
#define AE_SERVICESTAT	11
#define AE_ACLMOD	12
#define AE_UASMOD	13
#define AE_NETLOGON	14
#define AE_NETLOGOFF	15
#define AE_NETLOGDENIED 16
#define AE_ACCLIMITEXCD 17
#define AE_RESACCESS2	18
#define AE_ACLMODFAIL	19
#define AE_LOCKOUT      20
#define AE_GENERIC_TYPE 21
//
//	Values for ae_ss_status field of ae_srvstatus.
//

#define AE_SRVSTART	0
#define AE_SRVPAUSED	1
#define AE_SRVCONT	2
#define AE_SRVSTOP	3

//
// 	Values for ae_so_privilege field of ae_sesslogon.
//

#define AE_GUEST	0		
#define AE_USER		1
#define AE_ADMIN	2

//
//	Values for various ae_XX_reason fields.
//

#define AE_NORMAL	0		
#define AE_USERLIMIT	0
#define AE_GENERAL	0
#define AE_ERROR	1
#define AE_SESSDIS	1
#define AE_BADPW	1
#define AE_AUTODIS	2
#define AE_UNSHARE	2
#define AE_ADMINPRIVREQD 2
#define AE_ADMINDIS	3
#define AE_NOACCESSPERM 3
#define AE_ACCRESTRICT	4

#define	AE_NORMAL_CLOSE	0
#define	AE_SES_CLOSE	1
#define	AE_ADMIN_CLOSE	2

//
// Values for xx_subreason fields.
//

#define AE_LIM_UNKNOWN	    0
#define AE_LIM_LOGONHOURS   1
#define AE_LIM_EXPIRED	    2
#define AE_LIM_INVAL_WKSTA  3
#define AE_LIM_DISABLED     4
#define AE_LIM_DELETED	    5

//
// Values for xx_action fields
//

#define AE_MOD		0
#define AE_DELETE	1
#define AE_ADD		2

//
// Types of UAS record for um_rectype field
//

#define AE_UAS_USER	    0
#define AE_UAS_GROUP	    1
#define AE_UAS_MODALS	    2

//
// Bitmasks for auditing events
//
// The parentheses around the hex constants broke h_to_inc
// and have been purged from the face of the earth.
//

#define SVAUD_SERVICE           0x1
#define SVAUD_GOODSESSLOGON     0x6
#define SVAUD_BADSESSLOGON      0x18
#define SVAUD_SESSLOGON         (SVAUD_GOODSESSLOGON | SVAUD_BADSESSLOGON)
#define SVAUD_GOODNETLOGON      0x60
#define SVAUD_BADNETLOGON       0x180
#define SVAUD_NETLOGON          (SVAUD_GOODNETLOGON | SVAUD_BADNETLOGON)
#define SVAUD_LOGON             (SVAUD_NETLOGON | SVAUD_SESSLOGON)
#define SVAUD_GOODUSE           0x600
#define SVAUD_BADUSE            0x1800
#define SVAUD_USE               (SVAUD_GOODUSE | SVAUD_BADUSE)
#define SVAUD_USERLIST          0x2000
#define SVAUD_PERMISSIONS       0x4000
#define SVAUD_RESOURCE          0x8000
#define SVAUD_LOGONLIM		0x00010000

//
// Resource access audit bitmasks.
//

#define AA_AUDIT_ALL	    0x0001
#define AA_A_OWNER	    0x0004
#define AA_CLOSE	    0x0008
#define AA_S_OPEN	    0x0010
#define AA_S_WRITE	    0x0020
#define AA_S_CREATE	    0x0020
#define AA_S_DELETE	    0x0040
#define AA_S_ACL	    0x0080
#define AA_S_ALL	    ( AA_S_OPEN | AA_S_WRITE | AA_S_DELETE | AA_S_ACL)
#define AA_F_OPEN	    0x0100
#define AA_F_WRITE	    0x0200
#define AA_F_CREATE	    0x0200
#define AA_F_DELETE	    0x0400
#define AA_F_ACL	    0x0800
#define AA_F_ALL	    ( AA_F_OPEN | AA_F_WRITE | AA_F_DELETE | AA_F_ACL)

// Pinball-specific
#define AA_A_OPEN	    0x1000
#define AA_A_WRITE	    0x2000
#define AA_A_CREATE	    0x2000
#define AA_A_DELETE	    0x4000
#define AA_A_ACL	    0x8000
#define AA_A_ALL	    ( AA_F_OPEN | AA_F_WRITE | AA_F_DELETE | AA_F_ACL)


#ifdef __cplusplus
}
#endif

#endif  // _LMAUDIT_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMConfig.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmconfig.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetConfig

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMCONFIG_
#define _LMCONFIG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#define REVISED_CONFIG_APIS

//
// Function Prototypes - Config
//

NET_API_STATUS NET_API_FUNCTION
NetConfigGet (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  component,
    IN  LPCWSTR  parameter,
#ifdef REVISED_CONFIG_APIS
    OUT LPBYTE  *bufptr
#else
    OUT LPBYTE  *bufptr,
    OUT LPDWORD totalavailable
#endif
    );

NET_API_STATUS NET_API_FUNCTION
NetConfigGetAll (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  component,
#ifdef REVISED_CONFIG_APIS
    OUT LPBYTE  *bufptr
#else
    OUT LPBYTE  *bufptr,
    OUT LPDWORD totalavailable
#endif
    );


NET_API_STATUS NET_API_FUNCTION
NetConfigSet (
    IN  LPCWSTR  server OPTIONAL,
    IN  LPCWSTR  reserved1 OPTIONAL,
    IN  LPCWSTR  component,
    IN  DWORD   level,
    IN  DWORD   reserved2,
    IN  LPBYTE  buf,
    IN  DWORD   reserved3
    );


//
// Data Structures - Config
//

typedef struct _CONFIG_INFO_0 {
     LPWSTR         cfgi0_key;
     LPWSTR         cfgi0_data;
} CONFIG_INFO_0, *PCONFIG_INFO_0, *LPCONFIG_INFO_0;


#ifdef __cplusplus
}
#endif

#endif  // _LMCONFIG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMErr.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects
*/
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1999          **/
/********************************************************************/

/***    lmerr.h - network error definitions
 *
 */


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in lmcons.h for  *
 *info on the allocation of errors *
 ***********************************/

/**END_INTERNAL**/

/*NOINC*/
#ifndef NETERR_INCLUDED
#define NETERR_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif

/*INC*/


#define NERR_Success            0       /* Success */

// ERROR_ equates can be intermixed with NERR_ equates.
#include <winerror.h>



/***    NERR_BASE is the base of error codes from network utilities,
 *      chosen to avoid conflict with system and redirector error codes.
 *      2100 is a value that has been assigned to us by system.
 */
#define NERR_BASE       2100


/**INTERNAL_ONLY**/

/***********WARNING ****************
 *See the comment in lmcons.h for  *
 *info on the allocation of errors *
 ***********************************/

/***********WARNING ****************
 *The range 2750-2799 has been     *
 *allocated to the IBM LAN Server  *
 ***********************************/

/***********WARNING ****************
 *The range 2900-2999 has been     *
 *reserved for Microsoft OEMs      *
 ***********************************/

/**END_INTERNAL**/

/* UNUSED BASE+0 */
/* UNUSED BASE+1 */
#define NERR_NetNotStarted      (NERR_BASE+2)   /* The workstation driver is not installed. */
#define NERR_UnknownServer      (NERR_BASE+3)   /* The server could not be located. */
#define NERR_ShareMem           (NERR_BASE+4)   /* An internal error occurred.  The network cannot access a shared memory segment. */

#define NERR_NoNetworkResource  (NERR_BASE+5)   /* A network resource shortage occurred . */
#define NERR_RemoteOnly         (NERR_BASE+6)   /* This operation is not supported on workstations. */
#define NERR_DevNotRedirected   (NERR_BASE+7)   /* The device is not connected. */
/* NERR_BASE+8 is used for ERROR_CONNECTED_OTHER_PASSWORD */
/* NERR_BASE+9 is used for ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT */
/* UNUSED BASE+10 */
/* UNUSED BASE+11 */
/* UNUSED BASE+12 */
/* UNUSED BASE+13 */
#define NERR_ServerNotStarted   (NERR_BASE+14)  /* The Server service is not started. */
#define NERR_ItemNotFound       (NERR_BASE+15)  /* The queue is empty. */
#define NERR_UnknownDevDir      (NERR_BASE+16)  /* The device or directory does not exist. */
#define NERR_RedirectedPath     (NERR_BASE+17)  /* The operation is invalid on a redirected resource. */
#define NERR_DuplicateShare     (NERR_BASE+18)  /* The name has already been shared. */
#define NERR_NoRoom             (NERR_BASE+19)  /* The server is currently out of the requested resource. */
/* UNUSED BASE+20 */
#define NERR_TooManyItems       (NERR_BASE+21)  /* Requested addition of items exceeds the maximum allowed. */
#define NERR_InvalidMaxUsers    (NERR_BASE+22)  /* The Peer service supports only two simultaneous users. */
#define NERR_BufTooSmall        (NERR_BASE+23)  /* The API return buffer is too small. */
/* UNUSED BASE+24 */
/* UNUSED BASE+25 */
/* UNUSED BASE+26 */
#define NERR_RemoteErr          (NERR_BASE+27)  /* A remote API error occurred.  */
/* UNUSED BASE+28 */
/* UNUSED BASE+29 */
/* UNUSED BASE+30 */
#define NERR_LanmanIniError     (NERR_BASE+31)  /* An error occurred when opening or reading the configuration file. */
/* UNUSED BASE+32 */
/* UNUSED BASE+33 */
/* UNUSED BASE+34 */
/* UNUSED BASE+35 */
#define NERR_NetworkError       (NERR_BASE+36)  /* A general network error occurred. */
#define NERR_WkstaInconsistentState (NERR_BASE+37)
    /* The Workstation service is in an inconsistent state. Restart the computer before restarting the Workstation service. */
#define NERR_WkstaNotStarted    (NERR_BASE+38)  /* The Workstation service has not been started. */
#define NERR_BrowserNotStarted  (NERR_BASE+39)  /* The requested information is not available. */
#define NERR_InternalError      (NERR_BASE+40)  /* An internal Windows error occurred.*/
#define NERR_BadTransactConfig  (NERR_BASE+41)  /* The server is not configured for transactions. */
#define NERR_InvalidAPI         (NERR_BASE+42)  /* The requested API is not supported on the remote server. */
#define NERR_BadEventName       (NERR_BASE+43)  /* The event name is invalid. */
#define NERR_DupNameReboot      (NERR_BASE+44)  /* The computer name already exists on the network. Change it and restart the computer. */
/*
 *      Config API related
 *              Error codes from BASE+45 to BASE+49
 */

/* UNUSED BASE+45 */
#define NERR_CfgCompNotFound    (NERR_BASE+46)  /* The specified component could not be found in the configuration information. */
#define NERR_CfgParamNotFound   (NERR_BASE+47)  /* The specified parameter could not be found in the configuration information. */
#define NERR_LineTooLong        (NERR_BASE+49)  /* A line in the configuration file is too long. */

/*
 *      Spooler API related
 *              Error codes from BASE+50 to BASE+79
 */

#define NERR_QNotFound          (NERR_BASE+50)  /* The printer does not exist. */
#define NERR_JobNotFound        (NERR_BASE+51)  /* The print job does not exist. */
#define NERR_DestNotFound       (NERR_BASE+52)  /* The printer destination cannot be found. */
#define NERR_DestExists         (NERR_BASE+53)  /* The printer destination already exists. */
#define NERR_QExists            (NERR_BASE+54)  /* The printer queue already exists. */
#define NERR_QNoRoom            (NERR_BASE+55)  /* No more printers can be added. */
#define NERR_JobNoRoom          (NERR_BASE+56)  /* No more print jobs can be added.  */
#define NERR_DestNoRoom         (NERR_BASE+57)  /* No more printer destinations can be added. */
#define NERR_DestIdle           (NERR_BASE+58)  /* This printer destination is idle and cannot accept control operations. */
#define NERR_DestInvalidOp      (NERR_BASE+59)  /* This printer destination request contains an invalid control function. */
#define NERR_ProcNoRespond      (NERR_BASE+60)  /* The print processor is not responding. */
#define NERR_SpoolerNotLoaded   (NERR_BASE+61)  /* The spooler is not running. */
#define NERR_DestInvalidState   (NERR_BASE+62)  /* This operation cannot be performed on the print destination in its current state. */
#define NERR_QInvalidState      (NERR_BASE+63)  /* This operation cannot be performed on the printer queue in its current state. */
#define NERR_JobInvalidState    (NERR_BASE+64)  /* This operation cannot be performed on the print job in its current state. */
#define NERR_SpoolNoMemory      (NERR_BASE+65)  /* A spooler memory allocation failure occurred. */
#define NERR_DriverNotFound     (NERR_BASE+66)  /* The device driver does not exist. */
#define NERR_DataTypeInvalid    (NERR_BASE+67)  /* The data type is not supported by the print processor. */
#define NERR_ProcNotFound       (NERR_BASE+68)  /* The print processor is not installed. */

/*
 *      Service API related
 *              Error codes from BASE+80 to BASE+99
 */

#define NERR_ServiceTableLocked (NERR_BASE+80)  /* The service database is locked. */
#define NERR_ServiceTableFull   (NERR_BASE+81)  /* The service table is full. */
#define NERR_ServiceInstalled   (NERR_BASE+82)  /* The requested service has already been started. */
#define NERR_ServiceEntryLocked (NERR_BASE+83)  /* The service does not respond to control actions. */
#define NERR_ServiceNotInstalled (NERR_BASE+84) /* The service has not been started. */
#define NERR_BadServiceName     (NERR_BASE+85)  /* The service name is invalid. */
#define NERR_ServiceCtlTimeout  (NERR_BASE+86)  /* The service is not responding to the control function. */
#define NERR_ServiceCtlBusy     (NERR_BASE+87)  /* The service control is busy. */
#define NERR_BadServiceProgName (NERR_BASE+88)  /* The configuration file contains an invalid service program name. */
#define NERR_ServiceNotCtrl     (NERR_BASE+89)  /* The service could not be controlled in its present state. */
#define NERR_ServiceKillProc    (NERR_BASE+90)  /* The service ended abnormally. */
#define NERR_ServiceCtlNotValid (NERR_BASE+91)  /* The requested pause, continue, or stop is not valid for this service. */
#define NERR_NotInDispatchTbl   (NERR_BASE+92)  /* The service control dispatcher could not find the service name in the dispatch table. */
#define NERR_BadControlRecv     (NERR_BASE+93)  /* The service control dispatcher pipe read failed. */
#define NERR_ServiceNotStarting (NERR_BASE+94)  /* A thread for the new service could not be created. */

/*
 *      Wksta and Logon API related
 *              Error codes from BASE+100 to BASE+118
 */

#define NERR_AlreadyLoggedOn    (NERR_BASE+100) /* This workstation is already logged on to the local-area network. */
#define NERR_NotLoggedOn        (NERR_BASE+101) /* The workstation is not logged on to the local-area network. */
#define NERR_BadUsername        (NERR_BASE+102) /* The user name or group name parameter is invalid.  */
#define NERR_BadPassword        (NERR_BASE+103) /* The password parameter is invalid. */
#define NERR_UnableToAddName_W  (NERR_BASE+104) /* @W The logon processor did not add the message alias. */
#define NERR_UnableToAddName_F  (NERR_BASE+105) /* The logon processor did not add the message alias. */
#define NERR_UnableToDelName_W  (NERR_BASE+106) /* @W The logoff processor did not delete the message alias. */
#define NERR_UnableToDelName_F  (NERR_BASE+107) /* The logoff processor did not delete the message alias. */
/* UNUSED BASE+108 */
#define NERR_LogonsPaused       (NERR_BASE+109) /* Network logons are paused. */
#define NERR_LogonServerConflict (NERR_BASE+110)/* A centralized logon-server conflict occurred. */
#define NERR_LogonNoUserPath    (NERR_BASE+111) /* The server is configured without a valid user path. */
#define NERR_LogonScriptError   (NERR_BASE+112) /* An error occurred while loading or running the logon script. */
/* UNUSED BASE+113 */
#define NERR_StandaloneLogon    (NERR_BASE+114) /* The logon server was not specified.  Your computer will be logged on as STANDALONE. */
#define NERR_LogonServerNotFound (NERR_BASE+115) /* The logon server could not be found.  */
#define NERR_LogonDomainExists  (NERR_BASE+116) /* There is already a logon domain for this computer.  */
#define NERR_NonValidatedLogon  (NERR_BASE+117) /* The logon server could not validate the logon. */

/*
 *      ACF API related (access, user, group)
 *              Error codes from BASE+119 to BASE+149
 */

#define NERR_ACFNotFound        (NERR_BASE+119) /* The security database could not be found. */
#define NERR_GroupNotFound      (NERR_BASE+120) /* The group name could not be found. */
#define NERR_UserNotFound       (NERR_BASE+121) /* The user name could not be found. */
#define NERR_ResourceNotFound   (NERR_BASE+122) /* The resource name could not be found.  */
#define NERR_GroupExists        (NERR_BASE+123) /* The group already exists. */
#define NERR_UserExists         (NERR_BASE+124) /* The account already exists. */
#define NERR_ResourceExists     (NERR_BASE+125) /* The resource permission list already exists. */
#define NERR_NotPrimary         (NERR_BASE+126) /* This operation is only allowed on the primary domain controller of the domain. */
#define NERR_ACFNotLoaded       (NERR_BASE+127) /* The security database has not been started. */
#define NERR_ACFNoRoom          (NERR_BASE+128) /* There are too many names in the user accounts database. */
#define NERR_ACFFileIOFail      (NERR_BASE+129) /* A disk I/O failure occurred.*/
#define NERR_ACFTooManyLists    (NERR_BASE+130) /* The limit of 64 entries per resource was exceeded. */
#define NERR_UserLogon          (NERR_BASE+131) /* Deleting a user with a session is not allowed. */
#define NERR_ACFNoParent        (NERR_BASE+132) /* The parent directory could not be located. */
#define NERR_CanNotGrowSegment  (NERR_BASE+133) /* Unable to add to the security database session cache segment. */
#define NERR_SpeGroupOp         (NERR_BASE+134) /* This operation is not allowed on this special group. */
#define NERR_NotInCache         (NERR_BASE+135) /* This user is not cached in user accounts database session cache. */
#define NERR_UserInGroup        (NERR_BASE+136) /* The user already belongs to this group. */
#define NERR_UserNotInGroup     (NERR_BASE+137) /* The user does not belong to this group. */
#define NERR_AccountUndefined   (NERR_BASE+138) /* This user account is undefined. */
#define NERR_AccountExpired     (NERR_BASE+139) /* This user account has expired. */
#define NERR_InvalidWorkstation (NERR_BASE+140) /* The user is not allowed to log on from this workstation. */
#define NERR_InvalidLogonHours  (NERR_BASE+141) /* The user is not allowed to log on at this time.  */
#define NERR_PasswordExpired    (NERR_BASE+142) /* The password of this user has expired. */
#define NERR_PasswordCantChange (NERR_BASE+143) /* The password of this user cannot change. */
#define NERR_PasswordHistConflict (NERR_BASE+144) /* This password cannot be used now. */
#define NERR_PasswordTooShort   (NERR_BASE+145) /* The password does not meet the password policy requirements. Check the minimum password length, password complexity and password history requirements. */
#define NERR_PasswordTooRecent  (NERR_BASE+146) /* The password of this user is too recent to change.  */
#define NERR_InvalidDatabase    (NERR_BASE+147) /* The security database is corrupted. */
#define NERR_DatabaseUpToDate   (NERR_BASE+148) /* No updates are necessary to this replicant network/local security database. */
#define NERR_SyncRequired       (NERR_BASE+149) /* This replicant database is outdated; synchronization is required. */

/*
 *      Use API related
 *              Error codes from BASE+150 to BASE+169
 */

#define NERR_UseNotFound        (NERR_BASE+150) /* The network connection could not be found. */
#define NERR_BadAsgType         (NERR_BASE+151) /* This asg_type is invalid. */
#define NERR_DeviceIsShared     (NERR_BASE+152) /* This device is currently being shared. */
#define NERR_SameAsComputerName (NERR_BASE+153) /* The user name may not be same as computer name. */


/*
 *      Message Server related
 *              Error codes BASE+170 to BASE+209
 */

#define NERR_NoComputerName     (NERR_BASE+170) /* The computer name could not be added as a message alias.  The name may already exist on the network. */
#define NERR_MsgAlreadyStarted  (NERR_BASE+171) /* The Messenger service is already started. */
#define NERR_MsgInitFailed      (NERR_BASE+172) /* The Messenger service failed to start.  */
#define NERR_NameNotFound       (NERR_BASE+173) /* The message alias could not be found on the network. */
#define NERR_AlreadyForwarded   (NERR_BASE+174) /* This message alias has already been forwarded. */
#define NERR_AddForwarded       (NERR_BASE+175) /* This message alias has been added but is still forwarded. */
#define NERR_AlreadyExists      (NERR_BASE+176) /* This message alias already exists locally. */
#define NERR_TooManyNames       (NERR_BASE+177) /* The maximum number of added message aliases has been exceeded. */
#define NERR_DelComputerName    (NERR_BASE+178) /* The computer name could not be deleted.*/
#define NERR_LocalForward       (NERR_BASE+179) /* Messages cannot be forwarded back to the same workstation. */
#define NERR_GrpMsgProcessor    (NERR_BASE+180) /* An error occurred in the domain message processor. */
#define NERR_PausedRemote       (NERR_BASE+181) /* The message was sent, but the recipient has paused the Messenger service. */
#define NERR_BadReceive         (NERR_BASE+182) /* The message was sent but not received. */
#define NERR_NameInUse          (NERR_BASE+183) /* The message alias is currently in use. Try again later. */
#define NERR_MsgNotStarted      (NERR_BASE+184) /* The Messenger service has not been started. */
#define NERR_NotLocalName       (NERR_BASE+185) /* The name is not on the local computer. */
#define NERR_NoForwardName      (NERR_BASE+186) /* The forwarded message alias could not be found on the network. */
#define NERR_RemoteFull         (NERR_BASE+187) /* The message alias table on the remote station is full. */
#define NERR_NameNotForwarded   (NERR_BASE+188) /* Messages for this alias are not currently being forwarded. */
#define NERR_TruncatedBroadcast (NERR_BASE+189) /* The broadcast message was truncated. */
#define NERR_InvalidDevice      (NERR_BASE+194) /* This is an invalid device name. */
#define NERR_WriteFault         (NERR_BASE+195) /* A write fault occurred. */
/* UNUSED BASE+196 */
#define NERR_DuplicateName      (NERR_BASE+197) /* A duplicate message alias exists on the network. */
#define NERR_DeleteLater        (NERR_BASE+198) /* @W This message alias will be deleted later. */
#define NERR_IncompleteDel      (NERR_BASE+199) /* The message alias was not successfully deleted from all networks. */
#define NERR_MultipleNets       (NERR_BASE+200) /* This operation is not supported on computers with multiple networks. */

/*
 *      Server API related
 *              Error codes BASE+210 to BASE+229
 */

#define NERR_NetNameNotFound    (NERR_BASE+210) /* This shared resource does not exist.*/
#define NERR_DeviceNotShared    (NERR_BASE+211) /* This device is not shared. */
#define NERR_ClientNameNotFound (NERR_BASE+212) /* A session does not exist with that computer name. */
#define NERR_FileIdNotFound     (NERR_BASE+214) /* There is not an open file with that identification number. */
#define NERR_ExecFailure        (NERR_BASE+215) /* A failure occurred when executing a remote administration command. */
#define NERR_TmpFile            (NERR_BASE+216) /* A failure occurred when opening a remote temporary file. */
#define NERR_TooMuchData        (NERR_BASE+217) /* The data returned from a remote administration command has been truncated to 64K. */
#define NERR_DeviceShareConflict (NERR_BASE+218) /* This device cannot be shared as both a spooled and a non-spooled resource. */
#define NERR_BrowserTableIncomplete (NERR_BASE+219)  /* The information in the list of servers may be incorrect. */
#define NERR_NotLocalDomain     (NERR_BASE+220) /* The computer is not active in this domain. */
#define NERR_IsDfsShare         (NERR_BASE+221) /* The share must be removed from the Distributed File System before it can be deleted. */

/*
 *      CharDev API related
 *              Error codes BASE+230 to BASE+249
 */

/* UNUSED BASE+230 */
#define NERR_DevInvalidOpCode   (NERR_BASE+231) /* The operation is invalid for this device. */
#define NERR_DevNotFound        (NERR_BASE+232) /* This device cannot be shared. */
#define NERR_DevNotOpen         (NERR_BASE+233) /* This device was not open. */
#define NERR_BadQueueDevString  (NERR_BASE+234) /* This device name list is invalid. */
#define NERR_BadQueuePriority   (NERR_BASE+235) /* The queue priority is invalid. */
#define NERR_NoCommDevs         (NERR_BASE+237) /* There are no shared communication devices. */
#define NERR_QueueNotFound      (NERR_BASE+238) /* The queue you specified does not exist. */
#define NERR_BadDevString       (NERR_BASE+240) /* This list of devices is invalid. */
#define NERR_BadDev             (NERR_BASE+241) /* The requested device is invalid. */
#define NERR_InUseBySpooler     (NERR_BASE+242) /* This device is already in use by the spooler. */
#define NERR_CommDevInUse       (NERR_BASE+243) /* This device is already in use as a communication device. */

/*
 *      NetICanonicalize and NetIType and NetIMakeLMFileName
 *      NetIListCanon and NetINameCheck
 *              Error codes BASE+250 to BASE+269
 */

#define NERR_InvalidComputer   (NERR_BASE+251) /* This computer name is invalid. */
/* UNUSED BASE+252 */
/* UNUSED BASE+253 */
#define NERR_MaxLenExceeded    (NERR_BASE+254) /* The string and prefix specified are too long. */
/* UNUSED BASE+255 */
#define NERR_BadComponent      (NERR_BASE+256) /* This path component is invalid. */
#define NERR_CantType          (NERR_BASE+257) /* Could not determine the type of input. */
/* UNUSED BASE+258 */
/* UNUSED BASE+259 */
#define NERR_TooManyEntries    (NERR_BASE+262) /* The buffer for types is not big enough. */

/*
 *      NetProfile
 *              Error codes BASE+270 to BASE+276
 */

#define NERR_ProfileFileTooBig  (NERR_BASE+270) /* Profile files cannot exceed 64K. */
#define NERR_ProfileOffset      (NERR_BASE+271) /* The start offset is out of range. */
#define NERR_ProfileCleanup     (NERR_BASE+272) /* The system cannot delete current connections to network resources. */
#define NERR_ProfileUnknownCmd  (NERR_BASE+273) /* The system was unable to parse the command line in this file.*/
#define NERR_ProfileLoadErr     (NERR_BASE+274) /* An error occurred while loading the profile file. */
#define NERR_ProfileSaveErr     (NERR_BASE+275) /* @W Errors occurred while saving the profile file.  The profile was partially saved. */


/*
 *      NetAudit and NetErrorLog
 *              Error codes BASE+277 to BASE+279
 */

#define NERR_LogOverflow           (NERR_BASE+277)      /* Log file %1 is full. */
#define NERR_LogFileChanged        (NERR_BASE+278)      /* This log file has changed between reads. */
#define NERR_LogFileCorrupt        (NERR_BASE+279)      /* Log file %1 is corrupt. */


/*
 *      NetRemote
 *              Error codes BASE+280 to BASE+299
 */
#define NERR_SourceIsDir   (NERR_BASE+280) /* The source path cannot be a directory. */
#define NERR_BadSource     (NERR_BASE+281) /* The source path is illegal. */
#define NERR_BadDest       (NERR_BASE+282) /* The destination path is illegal. */
#define NERR_DifferentServers   (NERR_BASE+283) /* The source and destination paths are on different servers. */
/* UNUSED BASE+284 */
#define NERR_RunSrvPaused       (NERR_BASE+285) /* The Run server you requested is paused. */
/* UNUSED BASE+286 */
/* UNUSED BASE+287 */
/* UNUSED BASE+288 */
#define NERR_ErrCommRunSrv      (NERR_BASE+289) /* An error occurred when communicating with a Run server. */
/* UNUSED BASE+290 */
#define NERR_ErrorExecingGhost  (NERR_BASE+291) /* An error occurred when starting a background process. */
#define NERR_ShareNotFound      (NERR_BASE+292) /* The shared resource you are connected to could not be found.*/
/* UNUSED BASE+293 */
/* UNUSED BASE+294 */


/*
 *  NetWksta.sys (redir) returned error codes.
 *
 *          NERR_BASE + (300-329)
 */

#define NERR_InvalidLana        (NERR_BASE+300) /* The LAN adapter number is invalid.  */
#define NERR_OpenFiles          (NERR_BASE+301) /* There are open files on the connection.    */
#define NERR_ActiveConns        (NERR_BASE+302) /* Active connections still exist. */
#define NERR_BadPasswordCore    (NERR_BASE+303) /* This share name or password is invalid. */
#define NERR_DevInUse           (NERR_BASE+304) /* The device is being accessed by an active process. */
#define NERR_LocalDrive         (NERR_BASE+305) /* The drive letter is in use locally. */

/*
 *  Alert error codes.
 *
 *          NERR_BASE + (330-339)
 */
#define NERR_AlertExists        (NERR_BASE+330) /* The specified client is already registered for the specified event. */
#define NERR_TooManyAlerts      (NERR_BASE+331) /* The alert table is full. */
#define NERR_NoSuchAlert        (NERR_BASE+332) /* An invalid or nonexistent alert name was raised. */
#define NERR_BadRecipient       (NERR_BASE+333) /* The alert recipient is invalid.*/
#define NERR_AcctLimitExceeded  (NERR_BASE+334) /* A user's session with this server has been deleted
                                                 * because the user's logon hours are no longer valid. */

/*
 *  Additional Error and Audit log codes.
 *
 *          NERR_BASE +(340-343)
 */
#define NERR_InvalidLogSeek     (NERR_BASE+340) /* The log file does not contain the requested record number. */
/* UNUSED BASE+341 */
/* UNUSED BASE+342 */
/* UNUSED BASE+343 */

/*
 *  Additional UAS and NETLOGON codes
 *
 *          NERR_BASE +(350-359)
 */
#define NERR_BadUasConfig       (NERR_BASE+350) /* The user accounts database is not configured correctly. */
#define NERR_InvalidUASOp       (NERR_BASE+351) /* This operation is not permitted when the Netlogon service is running. */
#define NERR_LastAdmin          (NERR_BASE+352) /* This operation is not allowed on the last administrative account. */
#define NERR_DCNotFound         (NERR_BASE+353) /* Could not find domain controller for this domain. */
#define NERR_LogonTrackingError (NERR_BASE+354) /* Could not set logon information for this user. */
#define NERR_NetlogonNotStarted (NERR_BASE+355) /* The Netlogon service has not been started. */
#define NERR_CanNotGrowUASFile  (NERR_BASE+356) /* Unable to add to the user accounts database. */
#define NERR_TimeDiffAtDC       (NERR_BASE+357) /* This server's clock is not synchronized with the primary domain controller's clock. */
#define NERR_PasswordMismatch   (NERR_BASE+358) /* A password mismatch has been detected. */


/*
 *  Server Integration error codes.
 *
 *          NERR_BASE +(360-369)
 */
#define NERR_NoSuchServer       (NERR_BASE+360) /* The server identification does not specify a valid server. */
#define NERR_NoSuchSession      (NERR_BASE+361) /* The session identification does not specify a valid session. */
#define NERR_NoSuchConnection   (NERR_BASE+362) /* The connection identification does not specify a valid connection. */
#define NERR_TooManyServers     (NERR_BASE+363) /* There is no space for another entry in the table of available servers. */
#define NERR_TooManySessions    (NERR_BASE+364) /* The server has reached the maximum number of sessions it supports. */
#define NERR_TooManyConnections (NERR_BASE+365) /* The server has reached the maximum number of connections it supports. */
#define NERR_TooManyFiles       (NERR_BASE+366) /* The server cannot open more files because it has reached its maximum number. */
#define NERR_NoAlternateServers (NERR_BASE+367) /* There are no alternate servers registered on this server. */
/* UNUSED BASE+368 */
/* UNUSED BASE+369 */

#define NERR_TryDownLevel       (NERR_BASE+370) /* Try down-level (remote admin protocol) version of API instead. */

/*
 *  UPS error codes.
 *
 *          NERR_BASE + (380-384)
 */
#define NERR_UPSDriverNotStarted    (NERR_BASE+380) /* The UPS driver could not be accessed by the UPS service. */
#define NERR_UPSInvalidConfig       (NERR_BASE+381) /* The UPS service is not configured correctly. */
#define NERR_UPSInvalidCommPort     (NERR_BASE+382) /* The UPS service could not access the specified Comm Port. */
#define NERR_UPSSignalAsserted      (NERR_BASE+383) /* The UPS indicated a line fail or low battery situation. Service not started. */
#define NERR_UPSShutdownFailed      (NERR_BASE+384) /* The UPS service failed to perform a system shut down. */

/*
 *  Remoteboot error codes.
 *
 *          NERR_BASE + (400-419)
 *          Error codes 400 - 405 are used by RPLBOOT.SYS.
 *          Error codes 403, 407 - 416 are used by RPLLOADR.COM,
 *          Error code 417 is the alerter message of REMOTEBOOT (RPLSERVR.EXE).
 *          Error code 418 is for when REMOTEBOOT can't start
 *          Error code 419 is for a disallowed 2nd rpl connection
 *
 */
#define NERR_BadDosRetCode      (NERR_BASE+400) /* The program below returned an MS-DOS error code:*/
#define NERR_ProgNeedsExtraMem  (NERR_BASE+401) /* The program below needs more memory:*/
#define NERR_BadDosFunction     (NERR_BASE+402) /* The program below called an unsupported MS-DOS function:*/
#define NERR_RemoteBootFailed   (NERR_BASE+403) /* The workstation failed to boot.*/
#define NERR_BadFileCheckSum    (NERR_BASE+404) /* The file below is corrupt.*/
#define NERR_NoRplBootSystem    (NERR_BASE+405) /* No loader is specified in the boot-block definition file.*/
#define NERR_RplLoadrNetBiosErr (NERR_BASE+406) /* NetBIOS returned an error: The NCB and SMB are dumped above.*/
#define NERR_RplLoadrDiskErr    (NERR_BASE+407) /* A disk I/O error occurred.*/
#define NERR_ImageParamErr      (NERR_BASE+408) /* Image parameter substitution failed.*/
#define NERR_TooManyImageParams (NERR_BASE+409) /* Too many image parameters cross disk sector boundaries.*/
#define NERR_NonDosFloppyUsed   (NERR_BASE+410) /* The image was not generated from an MS-DOS diskette formatted with /S.*/
#define NERR_RplBootRestart     (NERR_BASE+411) /* Remote boot will be restarted later.*/
#define NERR_RplSrvrCallFailed  (NERR_BASE+412) /* The call to the Remoteboot server failed.*/
#define NERR_CantConnectRplSrvr (NERR_BASE+413) /* Cannot connect to the Remoteboot server.*/
#define NERR_CantOpenImageFile  (NERR_BASE+414) /* Cannot open image file on the Remoteboot server.*/
#define NERR_CallingRplSrvr     (NERR_BASE+415) /* Connecting to the Remoteboot server...*/
#define NERR_StartingRplBoot    (NERR_BASE+416) /* Connecting to the Remoteboot server...*/
#define NERR_RplBootServiceTerm (NERR_BASE+417) /* Remote boot service was stopped; check the error log for the cause of the problem.*/
#define NERR_RplBootStartFailed (NERR_BASE+418) /* Remote boot startup failed; check the error log for the cause of the problem.*/
#define NERR_RPL_CONNECTED      (NERR_BASE+419) /* A second connection to a Remoteboot resource is not allowed.*/

/*
 *  FTADMIN API error codes
 *
 *       NERR_BASE + (425-434)
 *
 *       (Currently not used in NT)
 *
 */

/*
 *  Browser service API error codes
 *
 *       NERR_BASE + (450-475)
 *
 */
#define NERR_BrowserConfiguredToNotRun     (NERR_BASE+450) /* The browser service was configured with MaintainServerList=No. */

/*
 *  Additional Remoteboot error codes.
 *
 *          NERR_BASE + (510-550)
 */
#define NERR_RplNoAdaptersStarted          (NERR_BASE+510) /*Service failed to start since none of the network adapters started with this service.*/
#define NERR_RplBadRegistry                (NERR_BASE+511) /*Service failed to start due to bad startup information in the registry.*/
#define NERR_RplBadDatabase                (NERR_BASE+512) /*Service failed to start because its database is absent or corrupt.*/
#define NERR_RplRplfilesShare              (NERR_BASE+513) /*Service failed to start because RPLFILES share is absent.*/
#define NERR_RplNotRplServer               (NERR_BASE+514) /*Service failed to start because RPLUSER group is absent.*/
#define NERR_RplCannotEnum                 (NERR_BASE+515) /*Cannot enumerate service records.*/
#define NERR_RplWkstaInfoCorrupted         (NERR_BASE+516) /*Workstation record information has been corrupted.*/
#define NERR_RplWkstaNotFound              (NERR_BASE+517) /*Workstation record was not found.*/
#define NERR_RplWkstaNameUnavailable       (NERR_BASE+518) /*Workstation name is in use by some other workstation.*/
#define NERR_RplProfileInfoCorrupted       (NERR_BASE+519) /*Profile record information has been corrupted.*/
#define NERR_RplProfileNotFound            (NERR_BASE+520) /*Profile record was not found.*/
#define NERR_RplProfileNameUnavailable     (NERR_BASE+521) /*Profile name is in use by some other profile.*/
#define NERR_RplProfileNotEmpty            (NERR_BASE+522) /*There are workstations using this profile.*/
#define NERR_RplConfigInfoCorrupted        (NERR_BASE+523) /*Configuration record information has been corrupted.*/
#define NERR_RplConfigNotFound             (NERR_BASE+524) /*Configuration record was not found.*/
#define NERR_RplAdapterInfoCorrupted       (NERR_BASE+525) /*Adapter id record information has been corrupted.*/
#define NERR_RplInternal                   (NERR_BASE+526) /*An internal service error has occurred.*/
#define NERR_RplVendorInfoCorrupted        (NERR_BASE+527) /*Vendor id record information has been corrupted.*/
#define NERR_RplBootInfoCorrupted          (NERR_BASE+528) /*Boot block record information has been corrupted.*/
#define NERR_RplWkstaNeedsUserAcct         (NERR_BASE+529) /*The user account for this workstation record is missing.*/
#define NERR_RplNeedsRPLUSERAcct           (NERR_BASE+530) /*The RPLUSER local group could not be found.*/
#define NERR_RplBootNotFound               (NERR_BASE+531) /*Boot block record was not found.*/
#define NERR_RplIncompatibleProfile        (NERR_BASE+532) /*Chosen profile is incompatible with this workstation.*/
#define NERR_RplAdapterNameUnavailable     (NERR_BASE+533) /*Chosen network adapter id is in use by some other workstation.*/
#define NERR_RplConfigNotEmpty             (NERR_BASE+534) /*There are profiles using this configuration.*/
#define NERR_RplBootInUse                  (NERR_BASE+535) /*There are workstations, profiles or configurations using this boot block.*/
#define NERR_RplBackupDatabase             (NERR_BASE+536) /*Service failed to backup Remoteboot database.*/
#define NERR_RplAdapterNotFound            (NERR_BASE+537) /*Adapter record was not found.*/
#define NERR_RplVendorNotFound             (NERR_BASE+538) /*Vendor record was not found.*/
#define NERR_RplVendorNameUnavailable      (NERR_BASE+539) /*Vendor name is in use by some other vendor record.*/
#define NERR_RplBootNameUnavailable        (NERR_BASE+540) /*(boot name, vendor id) is in use by some other boot block record.*/
#define NERR_RplConfigNameUnavailable      (NERR_BASE+541) /*Configuration name is in use by some other configuration.*/

/**INTERNAL_ONLY**/

/*
 *  Dfs API error codes.
 *
 *          NERR_BASE + (560-590)
 */

#define NERR_DfsInternalCorruption         (NERR_BASE+560) /*The internal database maintained by the DFS service is corrupt*/
#define NERR_DfsVolumeDataCorrupt          (NERR_BASE+561) /*One of the records in the internal DFS database is corrupt*/
#define NERR_DfsNoSuchVolume               (NERR_BASE+562) /*There is no DFS name whose entry path matches the input Entry Path*/
#define NERR_DfsVolumeAlreadyExists        (NERR_BASE+563) /*A root or link with the given name already exists*/
#define NERR_DfsAlreadyShared              (NERR_BASE+564) /*The server share specified is already shared in the DFS*/
#define NERR_DfsNoSuchShare                (NERR_BASE+565) /*The indicated server share does not support the indicated DFS namespace*/
#define NERR_DfsNotALeafVolume             (NERR_BASE+566) /*The operation is not valid on this portion of the namespace*/
#define NERR_DfsLeafVolume                 (NERR_BASE+567) /*The operation is not valid on this portion of the namespace*/
#define NERR_DfsVolumeHasMultipleServers   (NERR_BASE+568) /*The operation is ambiguous because the link has multiple servers*/
#define NERR_DfsCantCreateJunctionPoint    (NERR_BASE+569) /*Unable to create a link*/
#define NERR_DfsServerNotDfsAware          (NERR_BASE+570) /*The server is not DFS Aware*/
#define NERR_DfsBadRenamePath              (NERR_BASE+571) /*The specified rename target path is invalid*/
#define NERR_DfsVolumeIsOffline            (NERR_BASE+572) /*The specified DFS link is offline*/
#define NERR_DfsNoSuchServer               (NERR_BASE+573) /*The specified server is not a server for this link*/
#define NERR_DfsCyclicalName               (NERR_BASE+574) /*A cycle in the DFS name was detected*/
#define NERR_DfsNotSupportedInServerDfs    (NERR_BASE+575) /*The operation is not supported on a server-based DFS*/
#define NERR_DfsDuplicateService           (NERR_BASE+576) /*This link is already supported by the specified server-share*/
#define NERR_DfsCantRemoveLastServerShare  (NERR_BASE+577) /*Can't remove the last server-share supporting this root or link*/
#define NERR_DfsVolumeIsInterDfs           (NERR_BASE+578) /*The operation is not supported for an Inter-DFS link*/
#define NERR_DfsInconsistent               (NERR_BASE+579) /*The internal state of the DFS Service has become inconsistent*/
#define NERR_DfsServerUpgraded             (NERR_BASE+580) /*The DFS Service has been installed on the specified server*/
#define NERR_DfsDataIsIdentical            (NERR_BASE+581) /*The DFS data being reconciled is identical*/
#define NERR_DfsCantRemoveDfsRoot          (NERR_BASE+582) /*The DFS root cannot be deleted - Uninstall DFS if required*/
#define NERR_DfsChildOrParentInDfs         (NERR_BASE+583) /*A child or parent directory of the share is already in a DFS*/
#define NERR_DfsInternalError              (NERR_BASE+590) /*DFS internal error*/

/*
 *  Net setup error codes.
 *
 *          NERR_BASE + (591-600)
 */
#define NERR_SetupAlreadyJoined            (NERR_BASE+591) /*This machine is already joined to a domain.*/
#define NERR_SetupNotJoined                (NERR_BASE+592) /*This machine is not currently joined to a domain.*/
#define NERR_SetupDomainController         (NERR_BASE+593) /*This machine is a domain controller and cannot be unjoined from a domain.*/
#define NERR_DefaultJoinRequired           (NERR_BASE+594) /*The destination domain controller does not support creating machine accounts in OUs.*/
#define NERR_InvalidWorkgroupName          (NERR_BASE+595) /*The specified workgroup name is invalid.*/
#define NERR_NameUsesIncompatibleCodePage  (NERR_BASE+596) /*The specified computer name is incompatible with the default language used on the domain controller.*/
#define NERR_ComputerAccountNotFound       (NERR_BASE+597) /*The specified computer account could not be found. Contact an administrator to verify the account is in the domain. If the account has been deleted unjoin, reboot, and rejoin the domain.*/
#define NERR_PersonalSku                   (NERR_BASE+598) /*This version of Windows cannot be joined to a domain.*/
#define NERR_SetupCheckDNSConfig           (NERR_BASE+599) /*An attempt to resolve the DNS name of a domain controller in the domain being joined has failed.  Please verify this client is configured to reach a DNS server that can resolve DNS names in the target domain. For information about network troubleshooting, see Windows Help.*/

/*
 *  Some Password and account error results
 *
 *          NERR_BASE + (601 - 608)
*/
#define NERR_PasswordMustChange            (NERR_BASE + 601)   /* Password must change at next logon */
#define NERR_AccountLockedOut              (NERR_BASE + 602)   /* Account is locked out */
#define NERR_PasswordTooLong               (NERR_BASE + 603)   /* Password is too long */
#define NERR_PasswordNotComplexEnough      (NERR_BASE + 604)   /* Password doesn't meet the complexity policy */ 
#define NERR_PasswordFilterError           (NERR_BASE + 605)   /* Password doesn't meet the requirements of the filter dll's */

/*
 *  Error codes used for offline domain join and completion
 *
 *          NERR_BASE + (609 - 619)
 */
#define NERR_NoOfflineJoinInfo             (NERR_BASE + 609)   /* Offline join completion information was not found. */
#define NERR_BadOfflineJoinInfo            (NERR_BASE + 610)   /* The offline join completion information was bad. */
#define NERR_CantCreateJoinInfo            (NERR_BASE + 611)   /* Unable to create offline join information. Please ensure you have access to the specified path location and permissions to modify its contents. Running as an elevated administrator may be required. */ 
#define NERR_BadDomainJoinInfo             (NERR_BASE + 612)   /* The domain join info being saved was incomplete or bad. */ 
#define NERR_JoinPerformedMustRestart      (NERR_BASE + 613)   /* Offline join operation successfully completed but a restart is needed. */ 
#define NERR_NoJoinPending                 (NERR_BASE + 614)   /* There was no offline join operation pending. */ 
#define NERR_ValuesNotSet                  (NERR_BASE + 615)   /* Unable to set one or more requested machine or domain name values on the local computer. */
#define NERR_CantVerifyHostname            (NERR_BASE + 616)   /* Could not verify the current machine's hostname against the saved value in the join completion information. */
#define NERR_CantLoadOfflineHive           (NERR_BASE + 617)   /* Unable to load the specified offline registry hive. Please ensure you have access to the specified path location and permissions to modify its contents. Running as an elevated administrator may be required. */
#define NERR_ConnectionInsecure            (NERR_BASE + 618)   /* The minimum session security requirements for this operation were not met. */
#define NERR_ProvisioningBlobUnsupported   (NERR_BASE + 619)   /* Computer account provisioning blob version is not supported. */


/***********WARNING ****************
 *The range 2750-2799 has been     *
 *allocated to the IBM LAN Server  *
 ***********************************/

/***********WARNING ****************
 *The range 2900-2999 has been     *
 *reserved for Microsoft OEMs      *
 ***********************************/

/**END_INTERNAL**/

#define MAX_NERR                (NERR_BASE+899) /* This is the last error in NERR range. */

/*
 * end of list
 *
 *    WARNING:  Do not exceed MAX_NERR; values above this are used by
 *              other error code ranges (errlog.h, service.h, apperr.h).
 */


/*NOINC*/
#endif /* NETERR_INCLUDED */
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMCons.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation


    LMCONS.H (was NETCONS.H in LM 2.x)

Abstract:

    This file contains constants used throughout the LAN Manager
    API header files.  It should be included in any source file
    that is going to include other LAN Manager API header files or
    call a LAN Manager API.

    NOTE:  Lengths of strings are given as the maximum lengths of the
    string in characters (not bytes).  This does not include space for the
    terminating 0-characters.  When allocating space for such an item,
    use the form:

        TCHAR username[UNLEN+1];

    Definitions of the form LN20_* define those values in effect for
    LanMan 2.0.



--*/

/*NOINC*/
#ifndef NETCONS_INCLUDED

#define NETCONS_INCLUDED
#if _MSC_VER > 1000
#pragma once
#endif

/*INC*/

#ifndef PASCAL
#define PASCAL                          // pascal on OS/2
#endif

#ifndef FAR
#define FAR                             // far on OS/2
#endif

//
// String Lengths for various LanMan names
//

#define CNLEN       15                  // Computer name length
#define LM20_CNLEN  15                  // LM 2.0 Computer name length
#define DNLEN       CNLEN               // Maximum domain name length
#define LM20_DNLEN  LM20_CNLEN          // LM 2.0 Maximum domain name length

#if (CNLEN != DNLEN)
#error CNLEN and DNLEN are not equal
#endif

#define UNCLEN      (CNLEN+2)           // UNC computer name length
#define LM20_UNCLEN (LM20_CNLEN+2)      // LM 2.0 UNC computer name length

#define NNLEN       80                  // Net name length (share name)
#define LM20_NNLEN  12                  // LM 2.0 Net name length

#define RMLEN       (UNCLEN+1+NNLEN)    // Max remote name length
#define LM20_RMLEN  (LM20_UNCLEN+1+LM20_NNLEN) // LM 2.0 Max remote name length

#define SNLEN       80                  // Service name length
#define LM20_SNLEN  15                  // LM 2.0 Service name length
#define STXTLEN     256                 // Service text length
#define LM20_STXTLEN 63                 // LM 2.0 Service text length

#define PATHLEN     256                 // Max. path (not including drive name)
#define LM20_PATHLEN 256                // LM 2.0 Max. path

#define DEVLEN      80                  // Device name length
#define LM20_DEVLEN 8                   // LM 2.0 Device name length

#define EVLEN       16                  // Event name length

//
// User, Group and Password lengths
//

#define UNLEN       256                 // Maximum user name length
#define LM20_UNLEN  20                  // LM 2.0 Maximum user name length

#define GNLEN       UNLEN               // Group name
#define LM20_GNLEN  LM20_UNLEN          // LM 2.0 Group name

#define PWLEN       256                 // Maximum password length
#define LM20_PWLEN  14                  // LM 2.0 Maximum password length

#define SHPWLEN     8                   // Share password length (bytes)


#define CLTYPE_LEN  12                  // Length of client type string


#define MAXCOMMENTSZ 256                // Multipurpose comment length
#define LM20_MAXCOMMENTSZ 48            // LM 2.0 Multipurpose comment length

#define QNLEN       NNLEN               // Queue name maximum length
#define LM20_QNLEN  LM20_NNLEN          // LM 2.0 Queue name maximum length
#if (QNLEN != NNLEN)
# error QNLEN and NNLEN are not equal
#endif

//
// The ALERTSZ and MAXDEVENTRIES defines have not yet been NT'ized.
// Whoever ports these components should change these values appropriately.
//

#define ALERTSZ     128                 // size of alert string in server
#define MAXDEVENTRIES (sizeof (int)*8)  // Max number of device entries

                                        //
                                        // We use int bitmap to represent
                                        //

#define NETBIOS_NAME_LEN  16            // NetBIOS net name (bytes)

//
// Value to be used with APIs which have a "preferred maximum length"
// parameter.  This value indicates that the API should just allocate
// "as much as it takes."
//

#define MAX_PREFERRED_LENGTH    ((DWORD) -1)

//
//        Constants used with encryption
//

#define CRYPT_KEY_LEN           7
#define CRYPT_TXT_LEN           8
#define ENCRYPTED_PWLEN         16
#define SESSION_PWLEN           24
#define SESSION_CRYPT_KLEN      21

//
//  Value to be used with SetInfo calls to allow setting of all
//  settable parameters (parmnum zero option)
//
#ifndef PARMNUM_ALL
#define PARMNUM_ALL             0
#endif

#define PARM_ERROR_UNKNOWN      ( (DWORD) (-1) )
#define PARM_ERROR_NONE         0
#define PARMNUM_BASE_INFOLEVEL  1000

//
// Only the UNICODE version of the LM APIs are available on NT.
// Non-UNICODE version on other platforms
//
#if defined( _WIN32_WINNT ) || defined( WINNT ) || defined( __midl ) \
    || defined( FORCE_UNICODE )
#define LMSTR   LPWSTR
#define LMCSTR  LPCWSTR
#else
#define LMSTR   LPSTR
#define LMCSTR  LPCSTR
#endif

//
//        Message File Names
//

#define MESSAGE_FILENAME        TEXT("NETMSG")
#define OS2MSG_FILENAME         TEXT("BASE")
#define HELP_MSG_FILENAME       TEXT("NETH")

/**INTERNAL_ONLY**/

// The backup message file named here is a duplicate of net.msg. It
// is not shipped with the product, but is used at buildtime to
// msgbind certain messages to netapi.dll and some of the services.
// This allows for OEMs to modify the message text in net.msg and
// have those changes show up.        Only in case there is an error in
// retrieving the messages from net.msg do we then get the bound
// messages out of bak.msg (really out of the message segment).

#define BACKUP_MSG_FILENAME     TEXT("BAK.MSG")

/**END_INTERNAL**/

#ifndef NULL
#ifdef __cplusplus
#define NULL	0
#else
#define NULL	((void *)0)
#endif
#endif

//
// Keywords used in Function Prototypes
//

#define NET_API_STATUS          DWORD
#define API_RET_TYPE            NET_API_STATUS      // Old value: do not use
#if (_MSC_VER >= 800) || defined(_STDCALL_SUPPORTED)
#define NET_API_FUNCTION    __stdcall
#else
#define NET_API_FUNCTION
#endif

// Define pseudo-keywords.
#ifndef IN
#define IN
#endif

#ifndef OPTIONAL
#define OPTIONAL
#endif

#ifndef OUT
#define OUT
#endif
/*INC*/



//
// The platform ID indicates the levels to use for platform-specific
// information.
//

#define PLATFORM_ID_DOS 300
#define PLATFORM_ID_OS2 400
#define PLATFORM_ID_NT  500
#define PLATFORM_ID_OSF 600
#define PLATFORM_ID_VMS 700

//
//      There message numbers assigned to different LANMAN components
//      are as defined below.
//
//      lmerr.h:        2100 - 2999     NERR_BASE
//      alertmsg.h:     3000 - 3049     ALERT_BASE
//      lmsvc.h:        3050 - 3099     SERVICE_BASE
//      lmerrlog.h:     3100 - 3299     ERRLOG_BASE
//      msgtext.h:      3300 - 3499     MTXT_BASE
//      apperr.h:       3500 - 3999     APPERR_BASE
//      apperrfs.h:     4000 - 4299     APPERRFS_BASE
//      apperr2.h:      4300 - 5299     APPERR2_BASE
//      ncberr.h:       5300 - 5499     NRCERR_BASE
//      alertmsg.h:     5500 - 5599     ALERT2_BASE
//      lmsvc.h:        5600 - 5699     SERVICE2_BASE
//      lmerrlog.h      5700 - 5899     ERRLOG2_BASE
//

#define MIN_LANMAN_MESSAGE_ID  NERR_BASE
#define MAX_LANMAN_MESSAGE_ID  5899

/*NOINC*/
#endif // NETCONS_INCLUDED
/*INC*/
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMDFS.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmdfs.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetDfs API

Environment:

    User Mode - Win32

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

--*/

#ifndef _LMDFS_
#define _LMDFS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// DFS Volume state
//

#define DFS_VOLUME_STATES              0xF

#define DFS_VOLUME_STATE_OK            1
#define DFS_VOLUME_STATE_INCONSISTENT  2
#define DFS_VOLUME_STATE_OFFLINE       3
#define DFS_VOLUME_STATE_ONLINE        4

//
// These are valid for setting the volume state on the root
// These are available to force a resynchronize on the root
// volume or to put it in a standby mode.
//
#define DFS_VOLUME_STATE_RESYNCHRONIZE 0x10
#define DFS_VOLUME_STATE_STANDBY       0x20

//
//  When supported by a DFS namespace, the local state on
//  the DFS root target is refreshed with information from
//  the master state in the DFS metadata forcibly.
//

#define DFS_VOLUME_STATE_FORCE_SYNC  0x40

//
// These are valid on getting the volume state on the root
// These are available to determine the flavor of DFS
// A few bits are reserved to determine the flavor of the DFS root.
// To get the flavor, and the state with DFS_VOLUME_FLAVORS.
//
// (_state & DFS_VOLUME_FLAVORS) will tell you the flavor of the dfs root.
//
//

#define DFS_VOLUME_FLAVORS           0x0300


#define DFS_VOLUME_FLAVOR_UNUSED1    0x0000
#define DFS_VOLUME_FLAVOR_STANDALONE 0x0100
#define DFS_VOLUME_FLAVOR_AD_BLOB    0x0200
#define DFS_STORAGE_FLAVOR_UNUSED2   0x0300

//
// DFS Storage State
//

#define DFS_STORAGE_STATES            0xF
#define DFS_STORAGE_STATE_OFFLINE      1
#define DFS_STORAGE_STATE_ONLINE       2
#define DFS_STORAGE_STATE_ACTIVE       4


//
// Priority of a DFS target consists of the
// tuple <priority class, priority rank>. Priority
// ranks are valid only within a priority class and
// not across priority classes.
// Priority rank is 0-n, where 0 is highest rank.
//
// We have consciously chosen 0 to indicate the
// "normal" priority class, i.e. one that would
// be used if target priorities aren't used.
//
// The members of the enumeration have been explicitly
// set in a specific order (in the enumeration).
//
// We need the MIDL_PASS decoration to force sending
// the enums as 32-bit values instead of the default
// 16-bit values for enums. 
//

#ifdef  MIDL_PASS
typedef [v1_enum] enum _DFS_TARGET_PRIORITY_CLASS {
#else
typedef enum _DFS_TARGET_PRIORITY_CLASS {
#endif
    DfsInvalidPriorityClass = -1,
    DfsSiteCostNormalPriorityClass = 0,
    DfsGlobalHighPriorityClass,
    DfsSiteCostHighPriorityClass,
    DfsSiteCostLowPriorityClass,
    DfsGlobalLowPriorityClass
} DFS_TARGET_PRIORITY_CLASS;

typedef struct _DFS_TARGET_PRIORITY {
    DFS_TARGET_PRIORITY_CLASS   TargetPriorityClass;    // Priority class of target.
    USHORT                      TargetPriorityRank;     // Priority rank of target.
    USHORT                      Reserved;               // Must be set to 0.
} DFS_TARGET_PRIORITY, *PDFS_TARGET_PRIORITY;

//
// Level 1:
//
typedef struct _DFS_INFO_1 {
    LPWSTR  EntryPath;              // Dfs name for the top of this piece of storage
} DFS_INFO_1, *PDFS_INFO_1, *LPDFS_INFO_1;

#if defined(_WIN64)

//
// WOW64 support: Permit 32-bit callers to use 64-bit
// driver.
//

typedef struct _DFS_INFO_1_32 {
    ULONG   EntryPath;              // Dfs name for the top of this volume
} DFS_INFO_1_32, *PDFS_INFO_1_32, *LPDFS_INFO_1_32;

#endif  /* _WIN64   */

//
// Level 2:
//
typedef struct _DFS_INFO_2 {
    LPWSTR  EntryPath;              // Dfs name for the top of this volume
    LPWSTR  Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    DWORD   NumberOfStorages;       // Number of storages for this volume
} DFS_INFO_2, *PDFS_INFO_2, *LPDFS_INFO_2;

#if defined(_WIN64)

//
// WOW64 support: Permit 32-bit callers to use 64-bit
// driver.
//

typedef struct _DFS_INFO_2_32 {
    ULONG   EntryPath;              // Dfs name for the top of this volume
    ULONG   Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
} DFS_INFO_2_32, *PDFS_INFO_2_32, *LPDFS_INFO_2_32;

#endif  /* _WIN64   */

typedef struct _DFS_STORAGE_INFO {
    ULONG   State;                  // State of this storage, one of DFS_STORAGE_STATE_*
                                    // possibly OR'd with DFS_STORAGE_STATE_ACTIVE
    LPWSTR  ServerName;             // Name of server hosting this storage
    LPWSTR  ShareName;              // Name of share hosting this storage
} DFS_STORAGE_INFO, *PDFS_STORAGE_INFO, *LPDFS_STORAGE_INFO;

#if defined(_WIN64)

//
// We should be calling this structure DFS_STORAGE_INFO_32 as per
// convention. However, we don't want to pollute the namespace of new
// types that have been defined (for example, DFS_STORAGE_INFO_1) as
// enhancements to the "base" DFS_STORAGE_INFO structure. Hence,
// we define the WOW64 support structure as DFS_STORAGE_INFO_0_32.
//

typedef struct _DFS_STORAGE_INFO_0_32 {
    ULONG   State;                  // State of this storage, one of DFS_STORAGE_STATE_*
                                    // possibly OR'd with DFS_STORAGE_STATE_ACTIVE
    ULONG   ServerName;             // Name of server hosting this storage
    ULONG   ShareName;              // Name of share hosting this storage
} DFS_STORAGE_INFO_0_32, *PDFS_STORAGE_INFO_0_32, *LPDFS_STORAGE_INFO_0_32;

#endif  // _WIN64.

//
// WOW64 support: Permit 32-bit callers to use 64-bit
// driver.
//

typedef struct _DFS_STORAGE_INFO_1 {
    ULONG                   State;          // State of this target, one of DFS_TARGET_STATE_*
                                            // possibly OR'd with DFS_STORAGE_STATE_ACTIVE
    LPWSTR                  ServerName;     // Name of server hosting this target
    LPWSTR                  ShareName;      // Name of share hosting this target
    DFS_TARGET_PRIORITY     TargetPriority; // Priority of this target.
} DFS_STORAGE_INFO_1, *PDFS_STORAGE_INFO_1, *LPDFS_STORAGE_INFO_1;

//
// Level 3:
//
typedef struct _DFS_INFO_3 {
    LPWSTR  EntryPath;              // Dfs name for the top of this volume
    LPWSTR  Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
#ifdef MIDL_PASS
    [size_is(NumberOfStorages)] LPDFS_STORAGE_INFO Storage;
#else
    LPDFS_STORAGE_INFO   Storage;   // An array (of NumberOfStorages elements) of
                                    //      storage-specific information.
#endif // MIDL_PASS
} DFS_INFO_3, *PDFS_INFO_3, *LPDFS_INFO_3;

#if defined(_WIN64)

//
// WOW64 support: Permit 32-bit callers to use 64-bit
// driver.
//

typedef struct _DFS_INFO_3_32 {
    ULONG   EntryPath;              // Dfs name for the top of this volume
    ULONG   Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
    ULONG   Storage;                // An array (of NumberOfStorages elements) of
                                    //      storage-specific information. Each element
                                    //      is of type DFS_STORAGE_INFO_0_32.
} DFS_INFO_3_32, *PDFS_INFO_3_32, *LPDFS_INFO_3_32;

#endif  /* _WIN64   */

//
// Level 4:
//
typedef struct _DFS_INFO_4 {
    LPWSTR  EntryPath;              // Dfs name for the top of this volume
    LPWSTR  Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    ULONG   Timeout;                // Timeout, in seconds, of this junction point
    GUID    Guid;                   // Guid of this junction point
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
#ifdef MIDL_PASS
    [size_is(NumberOfStorages)] LPDFS_STORAGE_INFO Storage;
#else
    LPDFS_STORAGE_INFO   Storage;   // An array (of NumberOfStorages elements) of
                                    //      storage-specific information.
#endif // MIDL_PASS
} DFS_INFO_4, *PDFS_INFO_4, *LPDFS_INFO_4;


#if defined(_WIN64)

//
// WOW64 support: Permit 32-bit callers to use 64-bit
// driver.
//

typedef struct _DFS_INFO_4_32 {
    ULONG   EntryPath;              // Dfs name for the top of this volume
    ULONG   Comment;                // Comment for this volume
    DWORD   State;                  // State of this volume, one of DFS_VOLUME_STATE_*
    ULONG   Timeout;                // Timeout, in seconds, of this junction point
    GUID    Guid;                   // Guid of this junction point
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
    ULONG   Storage;                // An array (of NumberOfStorages elements) of
                                    //      storage-specific information. Each element
                                    //      is of type DFS_STORAGE_INFO_0_32.
} DFS_INFO_4_32, *PDFS_INFO_4_32, *LPDFS_INFO_4_32;

#endif  /* _WIN64   */


//
// Level 5:
//
typedef struct _DFS_INFO_5 {
    LPWSTR  EntryPath;              // Name of DFS namespace, DFS root name.
    LPWSTR  Comment;                // Comment for root/link.
    DWORD   State;                  // State of the root/link, one of DFS_VOLUME_STATE_*
                                    //      Also has DFS_VOLUME_FLAVOR_* information.
    ULONG   Timeout;                // Referral TTL, in seconds, of root/link.
    GUID    Guid;                   // GUID of this root/link.
    ULONG   PropertyFlags;          // Properties of root/link. One of DFS_PROPERTY_FLAG_*
    ULONG   MetadataSize;           // Size of Active Directory BLOB for a domain-based
                                    //      DFS namespace; size of metadata stored in registry
                                    //      for stand-alone DFS. Valid for DFS roots only.
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
} DFS_INFO_5, *PDFS_INFO_5, *LPDFS_INFO_5;

//
// Level 6:
//
typedef struct _DFS_INFO_6 {
    LPWSTR  EntryPath;              // Name of DFS namespace, DFS root name.
    LPWSTR  Comment;                // Comment for root/link.
    DWORD   State;                  // State of the root/link, one of DFS_VOLUME_STATE_*
                                    //      Also has DFS_VOLUME_FLAVOR_* information.
    ULONG   Timeout;                // Referral TTL, in seconds, of root/link.
    GUID    Guid;                   // GUID of this root/link.
    ULONG   PropertyFlags;          // Properties of root/link. One of DFS_PROPERTY_FLAG_*
    ULONG   MetadataSize;           // Size of Active Directory BLOB for a domain-based
                                    //      DFS namespace; size of metadata stored in registry
                                    //      for stand-alone DFS. Valid for DFS roots only.
    DWORD   NumberOfStorages;       // Number of targets for this root/link.
#ifdef MIDL_PASS
    [size_is(NumberOfStorages)] LPDFS_STORAGE_INFO_1    Storage;
#else
    LPDFS_STORAGE_INFO_1    Storage;    // An array (of NumberOfStorages elements) of
                                        // storage-specific information.
#endif // MIDL_PASS
} DFS_INFO_6, *PDFS_INFO_6, *LPDFS_INFO_6;

//
// Level 7:
//
typedef struct _DFS_INFO_7 {
    GUID        GenerationGuid;     // Guid representation of the version/generation
                                    // number of the DFS root.
} DFS_INFO_7, *PDFS_INFO_7, *LPDFS_INFO_7;

//
// Level 8:
//
typedef struct _DFS_INFO_8 {
    LPWSTR  EntryPath;              // Name of DFS namespace, DFS root name.
    LPWSTR  Comment;                // Comment for root/link.
    DWORD   State;                  // State of the root/link, one of DFS_VOLUME_STATE_*
                                    //      Also has DFS_VOLUME_FLAVOR_* information.
    ULONG   Timeout;                // Referral TTL, in seconds, of root/link.
    GUID    Guid;                   // GUID of this root/link.
    ULONG   PropertyFlags;          // Properties of root/link. One of DFS_PROPERTY_FLAG_*
    ULONG   MetadataSize;           // Size of Active Directory BLOB for a domain-based
                                    //      DFS namespace; size of metadata stored in registry
                                    //      for stand-alone DFS. Valid for DFS roots only.
#ifdef  MIDL_PASS

    //
    //  For use by the RPC marshalling code only.
    //
    
    ULONG   SecurityDescriptorLength;

    //
    //  Self-relative security descriptor to be associated
    //  with DFS link (and stamped on the reparse-point
    //  on disk).
    //

    [size_is(SecurityDescriptorLength)] PUCHAR  pSecurityDescriptor;
#else
    ULONG   SdLengthReserved;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
#endif
    DWORD   NumberOfStorages;       // Number of storage servers for this volume
} DFS_INFO_8, *PDFS_INFO_8, *LPDFS_INFO_8;

//
// Level 9:
//
typedef struct _DFS_INFO_9 {
    LPWSTR  EntryPath;              // Name of DFS namespace, DFS root name.
    LPWSTR  Comment;                // Comment for root/link.
    DWORD   State;                  // State of the root/link, one of DFS_VOLUME_STATE_*
                                    //      Also has DFS_VOLUME_FLAVOR_* information.
    ULONG   Timeout;                // Referral TTL, in seconds, of root/link.
    GUID    Guid;                   // GUID of this root/link.
    ULONG   PropertyFlags;          // Properties of root/link. One of DFS_PROPERTY_FLAG_*
    ULONG   MetadataSize;           // Size of Active Directory BLOB for a domain-based
                                    //      DFS namespace; size of metadata stored in registry
                                    //      for stand-alone DFS. Valid for DFS roots only.
#ifdef  MIDL_PASS

    //
    //  For use by the RPC marshalling code only.
    //
    
    ULONG   SecurityDescriptorLength;

    //
    //  Self-relative security descriptor to be associated
    //  with DFS link (and stamped on the reparse-point
    //  on disk).
    //

    [size_is(SecurityDescriptorLength)] PUCHAR  pSecurityDescriptor;
#else
    ULONG   SdLengthReserved;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
#endif
    DWORD   NumberOfStorages;       // Number of targets for this root/link.
#ifdef MIDL_PASS
    [size_is(NumberOfStorages)] LPDFS_STORAGE_INFO_1    Storage;
#else
    LPDFS_STORAGE_INFO_1    Storage;    // An array (of NumberOfStorages elements) of
                                        // storage-specific information.
#endif // MIDL_PASS
} DFS_INFO_9, *PDFS_INFO_9, *LPDFS_INFO_9;

//
// The PropertyFlags field of DFS_INFO_5, DFS_INFO_6,
// DFS_INFO_103, DFS_INFO_105 & DFS_INFO_107.
//

#define  DFS_VALID_PROPERTY_FLAGS    (DFS_PROPERTY_FLAG_INSITE_REFERRALS | \
                                        DFS_PROPERTY_FLAG_ROOT_SCALABILITY | \
                                        DFS_PROPERTY_FLAG_SITE_COSTING | \
                                        DFS_PROPERTY_FLAG_TARGET_FAILBACK | \
                                        DFS_PROPERTY_FLAG_CLUSTER_ENABLED | \
                                        DFS_PROPERTY_FLAG_ABDE)
                

//
// The "insite" flag. When set, only targets in the same
// site as the client are returned.
//
// Valid for domain/standalone roots/links
//

#define DFS_PROPERTY_FLAG_INSITE_REFERRALS  0x00000001

//
// "Root scalability" mode. When set, DFS server polls
// the nearest DC instead of PDC to check for DFS namespace
// changes. Valid only for domain roots.
//

#define DFS_PROPERTY_FLAG_ROOT_SCALABILITY  0x00000002

//
// Enables Active Directory site costing of targets. When enabled,
// targets are grouped into sets of increasing site costs from
// DFS client to target. Each set has targets of same cost.
// If not set, there are only two sets: set of targets in same
// site as client and set of targets not in the same site as the client.
// The latter is called "site awareness".
// Valid only domain/standalone roots
//

#define DFS_PROPERTY_FLAG_SITE_COSTING      0x00000004

//
// Should the DFS client attempt to failback to a closer target
// when it is available after failing over to a non-optimal target?
// Valid for domain/standalone roots/links.
//

#define DFS_PROPERTY_FLAG_TARGET_FAILBACK   0x00000008

//
// Bit will be 1 if the DFS root is clustered. Cannot be set
// using the NetDfsSetInfo() API.
//

#define DFS_PROPERTY_FLAG_CLUSTER_ENABLED   0x00000010

//
//  When set by the caller, Access-Based Directory Enumeration support
//  is enabled on all the DFS root target share of the DFS namespace.
//  Valid only for DFS namespaces which support the capability
//  DFS_NAMESPACE_CAPABILITY_ABDE. Valid only on the DFS namespace root
//  and not on root targets, link or link targets.
//  This property must be enabled to associate security descriptor
//  with a DFS link.
//

#define DFS_PROPERTY_FLAG_ABDE  0x00000020

//
//  Level 50:
//

//
//  DFS metadata version and capabilities of an existing
//  DFS namespace.
//

typedef struct _DFS_INFO_50 {
    ULONG       NamespaceMajorVersion;
    ULONG       NamespaceMinorVersion;
    ULONGLONG   NamespaceCapabilities;
} DFS_INFO_50, *PDFS_INFO_50, *LPDFS_INFO_50;


//
// Level 100:
//
typedef struct _DFS_INFO_100 {
    LPWSTR  Comment;                // Comment for this volume or storage
} DFS_INFO_100, *PDFS_INFO_100, *LPDFS_INFO_100;

//
// Level 101:
//
typedef struct _DFS_INFO_101 {
    DWORD   State;                  // State of this storage, one of DFS_STORAGE_STATE_*
                                    // possibly OR'd with DFS_STORAGE_STATE_ACTIVE
} DFS_INFO_101, *PDFS_INFO_101, *LPDFS_INFO_101;

//
// Level 102:
//
typedef struct _DFS_INFO_102 {
    ULONG   Timeout;                // Timeout, in seconds, of the junction
} DFS_INFO_102, *PDFS_INFO_102, *LPDFS_INFO_102;

//
// Level 103:
//
typedef struct _DFS_INFO_103 {
    ULONG       PropertyFlagMask;   // Indicates which flags in PropertyFlags are valid.
    ULONG       PropertyFlags;      // Flag meaningful only if corresponding bit set in
                                    // PropertyFlagMask above.
} DFS_INFO_103, *PDFS_INFO_103, *LPDFS_INFO_103;


//
// Level 104:
//
typedef struct _DFS_INFO_104 {
    DFS_TARGET_PRIORITY     TargetPriority;     // Priority of target.
} DFS_INFO_104, *PDFS_INFO_104, *LPDFS_INFO_104;

//
// Level 105:
//
typedef struct _DFS_INFO_105 {
    LPWSTR      Comment;            // Comment for this root/link.
    DWORD       State;              // State of this root/link. One of DFS_VOLUME_STATE_*
    ULONG       Timeout;            // Referral TTL, in seconds, of root/link.
    ULONG       PropertyFlagMask;   // Indicates which flags in PropertyFlags are valid.
    ULONG       PropertyFlags;      // One of DFS_PROPERTY_FLAG_*
} DFS_INFO_105, *PDFS_INFO_105, *LPDFS_INFO_105;

//
// Level 106:
//
typedef struct _DFS_INFO_106 {
    DWORD               State;              // State of this root/link target.
                                            //      One of DFS_TARGET_STATE_*
    DFS_TARGET_PRIORITY TargetPriority;     // Priority of this target.
} DFS_INFO_106, *PDFS_INFO_106, *LPDFS_INFO_106;

//
// Level 107:
//
typedef struct _DFS_INFO_107 {
    LPWSTR      Comment;            // Comment for this root/link.
    DWORD       State;              // State of this root/link. One of DFS_VOLUME_STATE_*
    ULONG       Timeout;            // Referral TTL, in seconds, of root/link.
    ULONG       PropertyFlagMask;   // Indicates which flags in PropertyFlags are valid.
    ULONG       PropertyFlags;      // One of DFS_PROPERTY_FLAG_*

#ifdef  MIDL_PASS

    //
    //  For use by the RPC marshalling code only.
    //
    
    ULONG   SecurityDescriptorLength;

    //
    //  Self-relative security descriptor to be associated
    //  with DFS link (and stamped on the reparse-point
    //  on disk).
    //

    [size_is(SecurityDescriptorLength)] PUCHAR  pSecurityDescriptor;
#else
    ULONG   SdLengthReserved;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
#endif
} DFS_INFO_107, *PDFS_INFO_107, *LPDFS_INFO_107;

//
// Level 150:
//
typedef struct _DFS_INFO_150 {

#ifdef  MIDL_PASS

    //
    //  For use by the RPC marshalling code only.
    //
    
    ULONG   SecurityDescriptorLength;

    //
    //  Self-relative security descriptor to be associated
    //  with DFS link (and stamped on the reparse-point
    //  on disk).
    //

    [size_is(SecurityDescriptorLength)] PUCHAR  pSecurityDescriptor;
#else
    ULONG   SdLengthReserved;
    PSECURITY_DESCRIPTOR    pSecurityDescriptor;
#endif
} DFS_INFO_150, *PDFS_INFO_150, *LPDFS_INFO_150;

//

// Level 200:
//
typedef struct _DFS_INFO_200 {
    LPWSTR  FtDfsName;              // FtDfs name
} DFS_INFO_200, *PDFS_INFO_200, *LPDFS_INFO_200;


//
// Level 300:
//
typedef struct _DFS_INFO_300 {
    DWORD   Flags;
    LPWSTR  DfsName;              // Dfs name
} DFS_INFO_300, *PDFS_INFO_300, *LPDFS_INFO_300;


//
// Add a new volume or additional storage for an existing volume at
// DfsEntryPath.
//
NET_API_STATUS NET_API_FUNCTION
NetDfsAdd(
    __in LPWSTR     DfsEntryPath,   // DFS entry path for this added volume or storage
    __in LPWSTR     ServerName,     // Name of server hosting the storage
    __in LPWSTR     ShareName,      // Existing share name for the storage
    __in_opt LPWSTR Comment,        // Optional comment for this volume or storage
    __in  DWORD     Flags           // See below. Zero for no flags.
);

//
// Flags:
//
#define DFS_ADD_VOLUME          1   // Add a new volume to the DFS if not already there
#define DFS_RESTORE_VOLUME      2   // Volume/Replica is being restored - do not verify share etc.

//
// Setup/teardown API's for standard and FtDfs roots.
//

NET_API_STATUS NET_API_FUNCTION
NetDfsAddStdRoot(
    __in LPWSTR     ServerName,     // Server to remote to
    __in LPWSTR     RootShare,      // Share to make Dfs root
    __in_opt LPWSTR Comment,        // Comment
    __in  DWORD     Flags           // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsRemoveStdRoot(
    __in  LPWSTR ServerName,        // Server to remote to
    __in  LPWSTR RootShare,         // Share that host Dfs root
    __reserved  DWORD  Flags        // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsAddFtRoot(
    __in LPWSTR         ServerName,     // Server to remote to
    __in LPWSTR         RootShare,      // Share to make Dfs root
    __in  LPWSTR        FtDfsName,      // Name of FtDfs to create/join
    __in_opt LPWSTR     Comment,        // Comment
    __in DWORD          Flags           // Flags for operation.  Zero for no flags.
);


NET_API_STATUS NET_API_FUNCTION
NetDfsRemoveFtRoot(
    __in LPWSTR         ServerName,     // Server to remote to
    __in LPWSTR         RootShare,      // Share that host Dfs root
    __in LPWSTR         FtDfsName,      // Name of FtDfs to remove or unjoin from.
    __reserved DWORD    Flags           // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsRemoveFtRootForced(
    __in  LPWSTR        DomainName,     // Name of domain the server is in
    __in  LPWSTR        ServerName,     // Server to remote to
    __in  LPWSTR        RootShare,      // Share that host Dfs root
    __in  LPWSTR        FtDfsName,      // Name of FtDfs to remove or unjoin from.
    __reserved DWORD    Flags           // Flags for operation.  Zero for no flags.
);

//
// Call to reinitialize the dfsmanager on a machine
//

NET_API_STATUS NET_API_FUNCTION
NetDfsManagerInitialize(
    __in LPWSTR         ServerName,     // Server to remote to
    __reserved DWORD    Flags           // Flags for operation.  Zero for no flags.
);

NET_API_STATUS NET_API_FUNCTION
NetDfsAddStdRootForced(
    __in  LPWSTR        ServerName,     // Server to remote to
    __in  LPWSTR        RootShare,      // Share to make Dfs root
    __in_opt  LPWSTR    Comment,        // Comment
    __in LPWSTR         Store           // Drive:\dir backing the share
);

NET_API_STATUS NET_API_FUNCTION
NetDfsGetDcAddress(
    __in LPWSTR         ServerName,     // Server to remote to
    __deref_out LPWSTR  *DcIpAddress,   // The IP address of the DC to use
    __out PBOOLEAN      IsRoot,         // TRUE if server is a Dfs root, FALSE otherwise
    __out PULONG        Timeout         // Time, in sec, that we stay with this DC
);


//
// Flags for NetDfsSetDcAddress()
//

#define NET_DFS_SETDC_FLAGS                 0x00000000
#define NET_DFS_SETDC_TIMEOUT               0x00000001
#define NET_DFS_SETDC_INITPKT               0x00000002

//
// Structures used for site reporting.  Last used in Windows 2000, maintained for
// the obsolete SRVSVC RPC API NetrDfsManagerReportSiteInfo.
//

typedef struct {
    ULONG SiteFlags;    // Below
#ifdef  MIDL_PASS
    [string,unique] LPWSTR SiteName;
#else
    LPWSTR SiteName;
#endif
} DFS_SITENAME_INFO, *PDFS_SITENAME_INFO, *LPDFS_SITENAME_INFO;

// SiteFlags

#define DFS_SITE_PRIMARY    0x1     // This site returned by DsGetSiteName()

typedef struct {
    ULONG cSites;
#ifdef  MIDL_PASS
    [size_is(cSites)] DFS_SITENAME_INFO Site[];
#else
    DFS_SITENAME_INFO Site[1];
#endif
} DFS_SITELIST_INFO, *PDFS_SITELIST_INFO, *LPDFS_SITELIST_INFO;

//
// Remove a volume or additional storage for volume from the Dfs at
// DfsEntryPath. When applied to the last storage in a volume, removes
// the volume from the DFS.
//
NET_API_STATUS NET_API_FUNCTION
NetDfsRemove(
    __in LPWSTR     DfsEntryPath,       // DFS entry path for this added volume or storage
    __in_opt LPWSTR ServerName,         // Name of server hosting the storage
    __in_opt LPWSTR ShareName           // Name of share hosting the storage
);

//
// Get information about all of the volumes in the Dfs. DfsName is
// the "server" part of the UNC name used to refer to this particular Dfs.
//
// Valid levels are 1-5, 200, 300
//
NET_API_STATUS NET_API_FUNCTION
NetDfsEnum(
    __in LPWSTR         DfsName,        // Name of the Dfs for enumeration
    __in DWORD          Level,          // Level of information requested
    __in DWORD          PrefMaxLen,     // Advisory, but -1 means "get it all"
    __out LPBYTE        *Buffer,        // API allocates and returns buffer with requested info
    __out LPDWORD       EntriesRead,    // Number of entries returned
    __inout LPDWORD     ResumeHandle    // Must be 0 on first call, reused on subsequent calls
);

//
// Get information about the volume or storage.
// If ServerName and ShareName are specified, the information returned
// is specific to that server and share, else the information is specific
// to the volume as a whole.
//
// Valid levels are 1-5, 100
//
NET_API_STATUS NET_API_FUNCTION
NetDfsGetInfo(
    __in LPWSTR         DfsEntryPath,   // DFS entry path for the volume
    __in_opt LPWSTR     ServerName,     // Name of server hosting a storage
    __in_opt LPWSTR     ShareName,      // Name of share on server serving the volume
    __in DWORD          Level,          // Level of information requested
    __out LPBYTE        *Buffer         // API allocates and returns buffer with requested info
);

//
// Set info about the volume or storage.
// If ServerName and ShareName are specified, the information set is
// specific to that server and share, else the information is specific
// to the volume as a whole.
//
// Valid levels are 100, 101 and 102
//
NET_API_STATUS NET_API_FUNCTION
NetDfsSetInfo(
    __in LPWSTR         DfsEntryPath,   // DFS entry path for the volume
    __in_opt LPWSTR     ServerName,     // Name of server hosting a storage
    __in_opt LPWSTR     ShareName,      // Name of share hosting a storage
    __in DWORD          Level,          // Level of information to be set
    __in LPBYTE         Buffer          // Buffer holding information
);

//
// Get client's cached information about the volume or storage.
// If ServerName and ShareName are specified, the information returned
// is specific to that server and share, else the information is specific
// to the volume as a whole.
//
// Valid levels are 1-4
//
NET_API_STATUS NET_API_FUNCTION
NetDfsGetClientInfo(
    __in LPWSTR         DfsEntryPath,   // DFS entry path for the volume
    __in_opt LPWSTR     ServerName,     // Name of server hosting a storage
    __in_opt LPWSTR     ShareName,      // Name of share on server serving the volume
    __in DWORD          Level,          // Level of information requested
    __out LPBYTE        *Buffer         // API allocates and returns buffer with requested info
);

//
// Set client's cached info about the volume or storage.
// If ServerName and ShareName are specified, the information set is
// specific to that server and share, else the information is specific
// to the volume as a whole.
//
// Valid levels are 101 and 102.
//
NET_API_STATUS NET_API_FUNCTION
NetDfsSetClientInfo(
    __in LPWSTR         DfsEntryPath,   // DFS entry path for the volume
    __in_opt LPWSTR     ServerName,     // Name of server hosting a storage
    __in_opt LPWSTR     ShareName,      // Name of share hosting a storage
    __in DWORD          Level,          // Level of information to be set
    __in LPBYTE         Buffer          // Buffer holding information
);

//
// Move a DFS volume and all subordinate volumes from one place in the
// DFS to another place in the DFS.
//


NET_API_STATUS NET_API_FUNCTION
NetDfsMove(
    __in LPWSTR     OldDfsEntryPath,    // Current DFS entry path for this volume
    __in LPWSTR     NewDfsEntryPath,    // New DFS entry path for this volume
    __in ULONG      Flags
);

//
//  Flags accepted by NetDfsMove
//

//
//  This  indicates that if a colliding link is found it should be replaced
//

#define  DFS_MOVE_FLAG_REPLACE_IF_EXISTS  0x00000001


NET_API_STATUS NET_API_FUNCTION
NetDfsRename(
    __in LPWSTR     Path,               // Current Win32 path in a Dfs
    __in LPWSTR     NewPath             // New Win32 path in the same Dfs
);

NET_API_STATUS NET_API_FUNCTION
NetDfsAddRootTarget(
    __in        LPWSTR  pDfsPath,
    __in_opt    LPWSTR  pTargetPath,
    __in        ULONG   MajorVersion,
    __in_opt    LPWSTR  pComment,
    __in        ULONG   Flags
    );

//
//  Reuse existing definition used by NetrDfsRemoveFtRoot().
//

#ifndef DFS_FORCE_REMOVE
#define DFS_FORCE_REMOVE    0x80000000
#endif

NET_API_STATUS NET_API_FUNCTION
NetDfsRemoveRootTarget(
    __in        LPWSTR  pDfsPath,
    __in_opt    LPWSTR  pTargetPath,
    __in        ULONG   Flags
    );

NET_API_STATUS NET_API_FUNCTION
NetDfsGetSecurity(
    __in LPWSTR                                                         DfsEntryPath,
    __in SECURITY_INFORMATION                                           SecurityInformation,
    __deref_out_bcount(*lpcbSecurityDescriptor) PSECURITY_DESCRIPTOR    *ppSecurityDescriptor,
    __out LPDWORD                                                       lpcbSecurityDescriptor
);

NET_API_STATUS NET_API_FUNCTION
NetDfsSetSecurity(
    __in LPWSTR                 DfsEntryPath,
    __in SECURITY_INFORMATION   SecurityInformation,
    __in PSECURITY_DESCRIPTOR   pSecurityDescriptor
);

NET_API_STATUS NET_API_FUNCTION
NetDfsGetStdContainerSecurity(
    __in LPWSTR                                                         MachineName,
    __in SECURITY_INFORMATION                                           SecurityInformation,
    __deref_out_bcount(*lpcbSecurityDescriptor) PSECURITY_DESCRIPTOR    *ppSecurityDescriptor,
    __out LPDWORD                                                       lpcbSecurityDescriptor
);

NET_API_STATUS NET_API_FUNCTION
NetDfsSetStdContainerSecurity(
    __in LPWSTR                 MachineName,
    __in SECURITY_INFORMATION   SecurityInformation,
    __in PSECURITY_DESCRIPTOR   pSecurityDescriptor
);
    
NET_API_STATUS NET_API_FUNCTION
NetDfsGetFtContainerSecurity(
    __in LPWSTR                                                         DomainName,
    __in SECURITY_INFORMATION                                           SecurityInformation,
    __deref_out_bcount(*lpcbSecurityDescriptor) PSECURITY_DESCRIPTOR    *ppSecurityDescriptor,
    __out LPDWORD                                                       lpcbSecurityDescriptor
);

NET_API_STATUS NET_API_FUNCTION
NetDfsSetFtContainerSecurity(
    __in LPWSTR                 DomainName,
    __in SECURITY_INFORMATION   SecurityInformation,
    __in PSECURITY_DESCRIPTOR   pSecurityDescriptor
);

//
//  Origin of DFS namespace version information.
//

typedef enum {
    DFS_NAMESPACE_VERSION_ORIGIN_COMBINED = 0,  //  Max version {server, AD DS domain}
                                                //      can support.
    DFS_NAMESPACE_VERSION_ORIGIN_SERVER,        //  Max version server can support.
    DFS_NAMESPACE_VERSION_ORIGIN_DOMAIN         //  Max version AD DS domain can support.
} DFS_NAMESPACE_VERSION_ORIGIN, *PDFS_NAMESPACE_VERSION_ORIGIN;

//
//  Capabilities:
//      Set of bit flags which indicates support for a specific capability.
//

//
//  DFS namespace supports associating a security descriptor with DFS link
//  for Access-Based Directory Enumeration purposes.
//

#define DFS_NAMESPACE_CAPABILITY_ABDE           ((ULONGLONG) 0x0000000000000001)


typedef struct _DFS_SUPPORTED_NAMESPACE_VERSION_INFO {

    //
    //  Domain-based DFS information.
    //  Valid only if DomainDfsMajorVersion != 0.
    //

    ULONG       DomainDfsMajorVersion;
    ULONG       DomainDfsMinorVersion;
    ULONGLONG   DomainDfsCapabilities;

    //
    //  Standalone DFS information.
    //  Valid only if StandaloneDfsMajorVersion != 0.
    //

    ULONG       StandaloneDfsMajorVersion;
    ULONG       StandaloneDfsMinorVersion;
    ULONGLONG   StandaloneDfsCapabilities;
} DFS_SUPPORTED_NAMESPACE_VERSION_INFO, *PDFS_SUPPORTED_NAMESPACE_VERSION_INFO;


NET_API_STATUS NET_API_FUNCTION
NetDfsGetSupportedNamespaceVersion(
    __in        DFS_NAMESPACE_VERSION_ORIGIN            Origin,
    __in_opt    PWSTR                                   pName,
    __deref_out PDFS_SUPPORTED_NAMESPACE_VERSION_INFO   *ppVersionInfo
    );

#ifdef __cplusplus
}
#endif

#endif // _LMDFS_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMErrlog.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmerrlog.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetErrorLog

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMERRLOG_
#define _LMERRLOG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Data Structures - Config
//

typedef struct _ERROR_LOG {
     DWORD         el_len;
     DWORD         el_reserved;
     DWORD         el_time;
     DWORD         el_error;
     LPWSTR        el_name;             // pointer to service name
     LPWSTR        el_text;             // pointer to string array
     LPBYTE        el_data;             // pointer to BYTE array
     DWORD         el_data_size;        // byte count of el_data area
     DWORD         el_nstrings;         // number of strings in el_text.
} ERROR_LOG, *PERROR_LOG, *LPERROR_LOG;


#define REVISED_ERROR_LOG_STRUCT


#ifndef _LMHLOGDEFINED_
#define _LMHLOGDEFINED_

typedef struct _HLOG {
     DWORD          time;
     DWORD          last_flags;
     DWORD          offset;
     DWORD          rec_offset;
} HLOG, *PHLOG, *LPHLOG;

#define LOGFLAGS_FORWARD    0
#define LOGFLAGS_BACKWARD   0x1
#define LOGFLAGS_SEEK       0x2

#endif

//
// Function Prototypes - ErrorLog
//

NET_API_STATUS NET_API_FUNCTION
NetErrorLogClear (
    __in_opt LPCWSTR UncServerName,
    __in_opt LPCWSTR BackupFile,
    __in_opt LPBYTE  Reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetErrorLogRead (
    __in_opt    LPCWSTR   UncServerName,
    __in_opt    LPWSTR    Reserved1,
    __in        LPHLOG    ErrorLogHandle,
    __in        DWORD     Offset,
    __in_opt    LPDWORD   Reserved2,
    __in        DWORD     Reserved3,
    __in        DWORD     OffsetFlag,
    __deref_out LPBYTE   *BufPtr,
    __in        DWORD     PrefMaxSize,
    __out       LPDWORD   BytesRead,
    __out       LPDWORD   TotalAvailable
    );

NET_API_STATUS NET_API_FUNCTION
NetErrorLogWrite (
    __in_opt LPBYTE  Reserved1,
    __in     DWORD   Code,
    __in     LPCWSTR Component,
    __in     LPBYTE  Buffer,
    __in     DWORD   NumBytes,
    __in     LPBYTE  MsgBuf,
    __in     DWORD   StrCount,
    __in_opt LPBYTE  Reserved2
    );

//
// Special Values and Constants
//


//
//  Generic (could be used by more than one service)
//   error log messages from 0 to 25
//
// Do not change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define ERRLOG_BASE 3100        /* NELOG errors start here */

#define NELOG_Internal_Error        (ERRLOG_BASE + 0)
    /*
    * The operation failed because a network software error occurred.
    */

#define NELOG_Resource_Shortage     (ERRLOG_BASE + 1)
    /*
    * The system ran out of a resource controlled by the %1 option.
    */

#define NELOG_Unable_To_Lock_Segment    (ERRLOG_BASE + 2)
    /*
    * The service failed to obtain a long-term lock on the
    *  segment for network control blocks (NCBs). The error code is the data.
    */

#define NELOG_Unable_To_Unlock_Segment  (ERRLOG_BASE + 3)
    /*
    * The service failed to release the long-term lock on the
    *  segment for network control blocks (NCBs). The error code is the data.
    */

#define NELOG_Uninstall_Service     (ERRLOG_BASE + 4)
    /*
    * There was an error stopping service %1.
    *  The error code from NetServiceControl is the data.
    */

#define NELOG_Init_Exec_Fail        (ERRLOG_BASE + 5)
    /*
    * Initialization failed because of a system execution failure on
    *  path %1. The system error code is the data.
    */

#define NELOG_Ncb_Error         (ERRLOG_BASE + 6)
    /*
    * An unexpected network control block (NCB) was received. The NCB is the data.
    */

#define NELOG_Net_Not_Started       (ERRLOG_BASE + 7)
    /*
    * The network is not started.
    */

#define NELOG_Ioctl_Error       (ERRLOG_BASE + 8)
    /*
    * A DosDevIoctl or DosFsCtl to NETWKSTA.SYS failed.
    * The data shown is in this format:
    *     DWORD  approx CS:IP of call to ioctl or fsctl
    *     WORD   error code
    *     WORD   ioctl or fsctl number
    */

#define NELOG_System_Semaphore      (ERRLOG_BASE + 9)
    /*
    * Unable to create or open system semaphore %1.
    *  The error code is the data.
    */

#define NELOG_Init_OpenCreate_Err   (ERRLOG_BASE + 10)
    /*
    * Initialization failed because of an open/create error on the
    *  file %1. The system error code is the data.
    */

#define NELOG_NetBios           (ERRLOG_BASE + 11)
    /*
    * An unexpected NetBIOS error occurred.
    *  The error code is the data.
    */

#define NELOG_SMB_Illegal       (ERRLOG_BASE + 12)
    /*
    * An illegal server message block (SMB) was received.
    *  The SMB is the data.
    */

#define NELOG_Service_Fail      (ERRLOG_BASE + 13)
    /*
    * Initialization failed because the requested service %1
    *  could not be started.
   */

#define NELOG_Entries_Lost      (ERRLOG_BASE + 14)
    /*
    * Some entries in the error log were lost because of a buffer
    * overflow.
    */


//
//  Server specific error log messages from 20 to 40
//

#define NELOG_Init_Seg_Overflow     (ERRLOG_BASE + 20)
    /*
    * Initialization parameters controlling resource usage other
    *  than net buffers are sized so that too much memory is needed.
    */

#define NELOG_Srv_No_Mem_Grow       (ERRLOG_BASE + 21)
    /*
    * The server cannot increase the size of a memory segment.
    */

#define NELOG_Access_File_Bad       (ERRLOG_BASE + 22)
    /*
    * Initialization failed because account file %1 is either incorrect
    * or not present.
    */

#define NELOG_Srvnet_Not_Started    (ERRLOG_BASE + 23)
    /*
    * Initialization failed because network %1 was not started.
    */

#define NELOG_Init_Chardev_Err      (ERRLOG_BASE + 24)
    /*
    * The server failed to start. Either all three chdev
    *  parameters must be zero or all three must be nonzero.
    */

#define NELOG_Remote_API        (ERRLOG_BASE + 25)
    /* A remote API request was halted due to the following
    * invalid description string: %1.
    */

#define NELOG_Ncb_TooManyErr        (ERRLOG_BASE + 26)
    /* The network %1 ran out of network control blocks (NCBs).  You may need to increase NCBs
    * for this network.  The following information includes the
    * number of NCBs submitted by the server when this error occurred:
    */

#define NELOG_Mailslot_err      (ERRLOG_BASE + 27)
    /* The server cannot create the %1 mailslot needed to send
    * the ReleaseMemory alert message.  The error received is:
    */

#define NELOG_ReleaseMem_Alert      (ERRLOG_BASE + 28)
    /* The server failed to register for the ReleaseMemory alert,
    * with recipient %1. The error code from
    * NetAlertStart is the data.
    */

#define NELOG_AT_cannot_write       (ERRLOG_BASE + 29)
    /* The server cannot update the AT schedule file. The file
    * is corrupted.
    */

#define NELOG_Cant_Make_Msg_File    (ERRLOG_BASE + 30)
    /* The server encountered an error when calling
    * NetIMakeLMFileName. The error code is the data.
    */

#define NELOG_Exec_Netservr_NoMem   (ERRLOG_BASE + 31)
    /* Initialization failed because of a system execution failure on
    * path %1. There is not enough memory to start the process.
    * The system error code is the data.
    */

#define NELOG_Server_Lock_Failure   (ERRLOG_BASE + 32)
    /* Longterm lock of the server buffers failed.
    * Check swap disk's free space and restart the system to start the server.
    */

//
//  Message service and POPUP specific error log messages from 40 to 55
//

#define NELOG_Msg_Shutdown      (ERRLOG_BASE + 40)
    /*
    * The service has stopped due to repeated consecutive
    *  occurrences of a network control block (NCB) error.  The last bad NCB follows
    *  in raw data.
    */

#define NELOG_Msg_Sem_Shutdown      (ERRLOG_BASE + 41)
    /*
    * The Message server has stopped due to a lock on the
    *  Message server shared data segment.
    */

#define NELOG_Msg_Log_Err       (ERRLOG_BASE + 50)
    /*
    * A file system error occurred while opening or writing to the
    *  system message log file %1. Message logging has been
    *  switched off due to the error. The error code is the data.
    */



#define NELOG_VIO_POPUP_ERR     (ERRLOG_BASE + 51)
    /*
    * Unable to display message POPUP due to system VIO call error.
    *  The error code is the data.
    */

#define NELOG_Msg_Unexpected_SMB_Type   (ERRLOG_BASE + 52)
    /*
    * An illegal server message block (SMB) was received.  The SMB is the data.
    */

//
//  Workstation specific error log messages from 60 to 75
//


#define NELOG_Wksta_Infoseg     (ERRLOG_BASE + 60)
    /*
    * The workstation information segment is bigger than 64K.
    *  The size follows, in DWORD format:
    */

#define NELOG_Wksta_Compname        (ERRLOG_BASE + 61)
    /*
    * The workstation was unable to get the name-number of the computer.
    */

#define NELOG_Wksta_BiosThreadFailure   (ERRLOG_BASE + 62)
    /*
    * The workstation could not initialize the Async NetBIOS Thread.
    *  The error code is the data.
    */

#define NELOG_Wksta_IniSeg      (ERRLOG_BASE + 63)
    /*
    * The workstation could not open the initial shared segment.
    *  The error code is the data.
    */

#define NELOG_Wksta_HostTab_Full    (ERRLOG_BASE + 64)
    /*
    * The workstation host table is full.
    */

#define NELOG_Wksta_Bad_Mailslot_SMB    (ERRLOG_BASE + 65)
    /*
    * A bad mailslot server message block (SMB) was received.  The SMB is the data.
    */

#define NELOG_Wksta_UASInit     (ERRLOG_BASE + 66)
    /*
    * The workstation encountered an error while trying to start the user accounts database.
    *  The error code is the data.
    */

#define NELOG_Wksta_SSIRelogon      (ERRLOG_BASE + 67)
    /*
    * The workstation encountered an error while responding to an SSI revalidation request.
    *  The function code and the error codes are the data.
    */

//
//  Alerter service specific error log messages from 70 to 79
//


#define NELOG_Build_Name        (ERRLOG_BASE + 70)
    /*
    * The Alerter service had a problem creating the list of
    * alert recipients.  The error code is %1.
    */

#define NELOG_Name_Expansion        (ERRLOG_BASE + 71)
    /*
    * There was an error expanding %1 as a group name. Try
    *  splitting the group into two or more smaller groups.
    */

#define NELOG_Message_Send      (ERRLOG_BASE + 72)
    /*
    * There was an error sending %2 the alert message -
    *  (
    *  %3 )
    *  The error code is %1.
    */

#define NELOG_Mail_Slt_Err      (ERRLOG_BASE + 73)
    /*
    * There was an error in creating or reading the alerter mailslot.
    *  The error code is %1.
    */

#define NELOG_AT_cannot_read        (ERRLOG_BASE + 74)
    /*
    * The server could not read the AT schedule file.
    */

#define NELOG_AT_sched_err      (ERRLOG_BASE + 75)
    /*
    * The server found an invalid AT schedule record.
    */

#define NELOG_AT_schedule_file_created  (ERRLOG_BASE + 76)
    /*
    * The server could not find an AT schedule file so it created one.
    */

#define NELOG_Srvnet_NB_Open        (ERRLOG_BASE + 77)
    /*
    * The server could not access the %1 network with NetBiosOpen.
    */

#define NELOG_AT_Exec_Err       (ERRLOG_BASE + 78)
    /*
    * The AT command processor could not run %1.
   */

//
//      Cache Lazy Write and HPFS386 specific error log messages from 80 to 89
//

#define NELOG_Lazy_Write_Err            (ERRLOG_BASE + 80)
        /*
        * WARNING:  Because of a lazy-write error, drive %1 now
        *  contains some corrupted data.  The cache is stopped.
        */

#define NELOG_HotFix            (ERRLOG_BASE + 81)
    /*
    * A defective sector on drive %1 has been replaced (hotfixed).
    * No data was lost.  You should run CHKDSK soon to restore full
    * performance and replenish the volume's spare sector pool.
    *
    * The hotfix occurred while processing a remote request.
    */

#define NELOG_HardErr_From_Server   (ERRLOG_BASE + 82)
    /*
    * A disk error occurred on the HPFS volume in drive %1.
    * The error occurred while processing a remote request.
    */

#define NELOG_LocalSecFail1 (ERRLOG_BASE + 83)
    /*
    * The user accounts database (NET.ACC) is corrupted.  The local security
    * system is replacing the corrupted NET.ACC with the backup
    * made at %1.
    * Any updates made to the database after this time are lost.
    *
    */

#define NELOG_LocalSecFail2 (ERRLOG_BASE + 84)
    /*
    * The user accounts database (NET.ACC) is missing.  The local
    * security system is restoring the backup database
    * made at %1.
    * Any updates made to the database made after this time are lost.
    *
    */

#define NELOG_LocalSecFail3 (ERRLOG_BASE + 85)
    /*
    * Local security could not be started because the user accounts database
    * (NET.ACC) was missing or corrupted, and no usable backup
    * database was present.
    *
    * THE SYSTEM IS NOT SECURE.
    */

#define NELOG_LocalSecGeneralFail   (ERRLOG_BASE + 86)
    /*
    * Local security could not be started because an error
    * occurred during initialization. The error code returned is %1.
    *
    * THE SYSTEM IS NOT SECURE.
    *
    */

//
//  NETWKSTA.SYS specific error log messages from 90 to 99
//

#define NELOG_NetWkSta_Internal_Error   (ERRLOG_BASE + 90)
    /*
    * A NetWksta internal error has occurred:
    *  %1
    */

#define NELOG_NetWkSta_No_Resource  (ERRLOG_BASE + 91)
    /*
    * The redirector is out of a resource: %1.
    */

#define NELOG_NetWkSta_SMB_Err      (ERRLOG_BASE + 92)
    /*
    * A server message block (SMB) error occurred on the connection to %1.
    *  The SMB header is the data.
    */

#define NELOG_NetWkSta_VC_Err       (ERRLOG_BASE + 93)
    /*
    * A virtual circuit error occurred on the session to %1.
    *  The network control block (NCB) command and return code is the data.
    */

#define NELOG_NetWkSta_Stuck_VC_Err (ERRLOG_BASE + 94)
    /*
    * Hanging up a stuck session to %1.
    */

#define NELOG_NetWkSta_NCB_Err      (ERRLOG_BASE + 95)
    /*
    * A network control block (NCB) error occurred (%1).
    *  The NCB is the data.
    */

#define NELOG_NetWkSta_Write_Behind_Err (ERRLOG_BASE + 96)
    /*
    * A write operation to %1 failed.
    *  Data may have been lost.
    */

#define NELOG_NetWkSta_Reset_Err    (ERRLOG_BASE + 97)
    /*
    * Reset of driver %1 failed to complete the network control block (NCB).
    *  The NCB is the data.
    */

#define NELOG_NetWkSta_Too_Many     (ERRLOG_BASE + 98)
    /*
    * The amount of resource %1 requested was more
    *  than the maximum. The maximum amount was allocated.
    */

//
//  Spooler specific error log messages from 100 to 103
//

#define NELOG_Srv_Thread_Failure        (ERRLOG_BASE + 104)
    /*
    * The server could not create a thread.
    *  The THREADS parameter in the CONFIG.SYS file should be increased.
    */

#define NELOG_Srv_Close_Failure         (ERRLOG_BASE + 105)
    /*
    * The server could not close %1.
    *  The file is probably corrupted.
    */

#define NELOG_ReplUserCurDir               (ERRLOG_BASE + 106)
    /*
    *The replicator cannot update directory %1. It has tree integrity
    * and is the current directory for some process.
    */

#define NELOG_ReplCannotMasterDir       (ERRLOG_BASE + 107)
    /*
    *The server cannot export directory %1 to client %2.
    * It is exported from another server.
    */

#define NELOG_ReplUpdateError           (ERRLOG_BASE + 108)
    /*
    *The replication server could not update directory %2 from the source
    * on %3 due to error %1.
    */

#define NELOG_ReplLostMaster            (ERRLOG_BASE + 109)
    /*
    *Master %1 did not send an update notice for directory %2 at the expected
    * time.
    */

#define NELOG_NetlogonAuthDCFail        (ERRLOG_BASE + 110)
    /*
    *This computer could not authenticate with %2, a Windows domain controller
    * for domain %1, and therefore this computer might deny logon requests.
    * This inability to authenticate might be caused by another computer on the
    * same network using the same name or the password for this computer account
    * is not recognized. If this message appears again, contact your system
    * administrator.
    */

#define NELOG_ReplLogonFailed           (ERRLOG_BASE + 111)
    /*
    *The replicator attempted to log on at %2 as %1 and failed.
    */

#define NELOG_ReplNetErr            (ERRLOG_BASE + 112)
    /*
    *  Network error %1 occurred.
    */

#define NELOG_ReplMaxFiles            (ERRLOG_BASE + 113)
    /*
    *  Replicator limit for files in a directory has been exceeded.
    */


#define NELOG_ReplMaxTreeDepth            (ERRLOG_BASE + 114)
    /*
    *  Replicator limit for tree depth has been exceeded.
    */

#define NELOG_ReplBadMsg             (ERRLOG_BASE + 115)
    /*
    *  Unrecognized message received in mailslot.
    */

#define NELOG_ReplSysErr            (ERRLOG_BASE + 116)
    /*
    *  System error %1 occurred.
    */

#define NELOG_ReplUserLoged          (ERRLOG_BASE + 117)
    /*
    *  Cannot log on. User is currently logged on and argument TRYUSER
    *  is set to NO.
    */

#define NELOG_ReplBadImport           (ERRLOG_BASE + 118)
    /*
    *  IMPORT path %1 cannot be found.
    */

#define NELOG_ReplBadExport           (ERRLOG_BASE + 119)
    /*
    *  EXPORT path %1 cannot be found.
    */

#define NELOG_ReplSignalFileErr           (ERRLOG_BASE + 120)
    /*
    *  Replicator failed to update signal file in directory %2 due to
    *  %1 system error.
    */

#define NELOG_DiskFT                (ERRLOG_BASE+121)
    /*
    * Disk Fault Tolerance Error
    *
    * %1
    */

#define NELOG_ReplAccessDenied           (ERRLOG_BASE + 122)
    /*
    *  Replicator could not access %2
    *  on %3 due to system error %1.
    */

#define NELOG_NetlogonFailedPrimary      (ERRLOG_BASE + 123)
    /*
    *The primary domain controller for domain %1 has apparently failed.
    */

#define NELOG_NetlogonPasswdSetFailed (ERRLOG_BASE + 124)
    /*
    * Changing machine account password for account %1 failed with
    * the following error: %n%2
    */

#define NELOG_NetlogonTrackingError      (ERRLOG_BASE + 125)
    /*
    *An error occurred while updating the logon or logoff information for %1.
    */

#define NELOG_NetlogonSyncError          (ERRLOG_BASE + 126)
    /*
    *An error occurred while synchronizing with primary domain controller %1
    */

#define NELOG_NetlogonRequireSignOrSealError (ERRLOG_BASE + 127)
    /*
    * The session setup to the Windows NT or Windows 2000 Domain Controller %1 for the domain %2
    * failed because %1 does not support signing or sealing the Netlogon
    * session.
    *
    * Either upgrade the Domain controller or set the RequireSignOrSeal
    * registry entry on this machine to 0.
    */

//
//  UPS service specific error log messages from 130 to 135
//

#define NELOG_UPS_PowerOut      (ERRLOG_BASE + 130)
    /*
    * A power failure was detected at the server.
    */

#define NELOG_UPS_Shutdown      (ERRLOG_BASE + 131)
    /*
    * The UPS service performed server shut down.
    */

#define NELOG_UPS_CmdFileError      (ERRLOG_BASE + 132)
    /*
    * The UPS service did not complete execution of the
    * user specified shut down command file.
    */

#define NELOG_UPS_CannotOpenDriver  (ERRLOG_BASE+133)
    /*
    * The UPS driver could not be opened.  The error code is
    * the data.
    */

#define NELOG_UPS_PowerBack     (ERRLOG_BASE + 134)
    /*
    * Power has been restored.
    */

#define NELOG_UPS_CmdFileConfig     (ERRLOG_BASE + 135)
    /*
    * There is a problem with a configuration of user specified
    * shut down command file.
    */

#define NELOG_UPS_CmdFileExec       (ERRLOG_BASE + 136)
    /*
    * The UPS service failed to execute a user specified shutdown
    * command file %1.  The error code is the data.
    */

//
//  Remoteboot server specific error log messages are from 150 to 157
//

#define NELOG_Missing_Parameter     (ERRLOG_BASE + 150)
    /*
    * Initialization failed because of an invalid or missing
    *  parameter in the configuration file %1.
    */

#define NELOG_Invalid_Config_Line   (ERRLOG_BASE + 151)
    /*
    * Initialization failed because of an invalid line in the
    *  configuration file %1. The invalid line is the data.
    */

#define NELOG_Invalid_Config_File   (ERRLOG_BASE + 152)
    /*
    * Initialization failed because of an error in the configuration
    *  file %1.
    */

#define NELOG_File_Changed      (ERRLOG_BASE + 153)
    /*
    * The file %1 has been changed after initialization.
    *  The boot-block loading was temporarily terminated.
    */

#define NELOG_Files_Dont_Fit        (ERRLOG_BASE + 154)
    /*
    * The files do not fit to the boot-block configuration
    * file %1. Change the BASE and ORG definitions or the order
    * of the files.
    */

#define NELOG_Wrong_DLL_Version     (ERRLOG_BASE + 155)
    /*
    * Initialization failed because the dynamic-link
    *  library %1 returned an incorrect version number.
    */

#define NELOG_Error_in_DLL      (ERRLOG_BASE + 156)
    /*
    * There was an unrecoverable error in the dynamic-
    *  link library of the service.
    */

#define NELOG_System_Error      (ERRLOG_BASE + 157)
    /*
    * The system returned an unexpected error code.
    *  The error code is the data.
    */

#define NELOG_FT_ErrLog_Too_Large (ERRLOG_BASE + 158)
    /*
    * The fault-tolerance error log file, LANROOT\LOGS\FT.LOG,
    *  is more than 64K.
    */

#define NELOG_FT_Update_In_Progress (ERRLOG_BASE + 159)
    /*
    * The fault-tolerance error-log file, LANROOT\LOGS\FT.LOG, had the
    * update in progress bit set upon opening, which means that the
    * system crashed while working on the error log.
    */

#define NELOG_Joined_Domain         (ERRLOG_BASE + 160)
    /*
    * This computer has been successfully joined to domain '%1'.
    */

#define NELOG_Joined_Workgroup      (ERRLOG_BASE + 161)
    /*
    * This computer has been successfully joined to workgroup '%1'.
    */


//
// Microsoft has created a generic error log entry for OEMs to use to
// log errors from OEM value added services.  The code, which is the
// 2nd arg to NetErrorLogWrite, is 3299.  This value is manifest in
// NET/H/ERRLOG.H as NELOG_OEM_Code.  The text for error log entry
// NELOG_OEM_Code is:  "%1 %2 %3 %4 %5 %6 %7 %8 %9.".
//
// Microsoft suggests that OEMs use the insertion strings as follows:
// %1:  OEM System Name (e.g. 3+Open)
// %2:  OEM Service Name (e.g. 3+Mail)
// %3:  Severity level (e.g.  error, warning, etc.)
// %4:  OEM error log entry sub-identifier  (e.g. error code #)
// %5 - % 9:  Text.
//
// The call to NetErrorWrite must set nstrings = 9, and provide 9
// ASCIIZ strings.  If the caller does not have 9 insertion strings,
// provide null strings for the empty insertion strings.
//

#define NELOG_OEM_Code              (ERRLOG_BASE + 199)
    /*
    * %1 %2 %3 %4 %5 %6 %7 %8 %9.
    */

//
// another error log range defined for NT Lanman.
//

#define ERRLOG2_BASE 5700        /* New NT NELOG errors start here */

#define NELOG_NetlogonSSIInitError              (ERRLOG2_BASE + 0)
    /*
     * The Netlogon service could not initialize the replication data
     * structures successfully. The service was terminated.  The following
     * error occurred: %n%1
     */

#define NELOG_NetlogonFailedToUpdateTrustList   (ERRLOG2_BASE + 1)
    /*
     * The Netlogon service failed to update the domain trust list.  The
     * following error occurred: %n%1
     */

#define NELOG_NetlogonFailedToAddRpcInterface   (ERRLOG2_BASE + 2)
    /*
     * The Netlogon service could not add the RPC interface.  The
     * service was terminated. The following error occurred: %n%1
     */

#define NELOG_NetlogonFailedToReadMailslot      (ERRLOG2_BASE + 3)
    /*
     * The Netlogon service could not read a mailslot message from %1 due
     * to the following error: %n%2
     */

#define NELOG_NetlogonFailedToRegisterSC        (ERRLOG2_BASE + 4)
    /*
     * The Netlogon service failed to register the service with the
     * service controller. The service was terminated. The following
     * error occurred: %n%1
     */

#define NELOG_NetlogonChangeLogCorrupt          (ERRLOG2_BASE + 5)
    /*
     * The change log cache maintained by the Netlogon service for %1
     * database changes is inconsistent. The Netlogon service is resetting
     * the change log.
     */

#define NELOG_NetlogonFailedToCreateShare       (ERRLOG2_BASE + 6)
    /*
     * The Netlogon service could not create server share %1.  The following
     * error occurred: %n%2
     */

#define NELOG_NetlogonDownLevelLogonFailed      (ERRLOG2_BASE + 7)
    /*
     * The down-level logon request for the user %1 from %2 failed.
     */

#define NELOG_NetlogonDownLevelLogoffFailed     (ERRLOG2_BASE + 8)
    /*
     * The down-level logoff request for the user %1 from %2 failed.
     */

#define NELOG_NetlogonNTLogonFailed             (ERRLOG2_BASE + 9)
    /*
     * The Windows NT or Windows 2000 %1 logon request for the user %2\%3 from %4 (via %5)
     * failed.
     */

#define NELOG_NetlogonNTLogoffFailed            (ERRLOG2_BASE + 10)
    /*
     * The Windows NT or Windows 2000 %1 logoff request for the user %2\%3 from %4
     * failed.
     */

#define NELOG_NetlogonPartialSyncCallSuccess    (ERRLOG2_BASE + 11)
    /*
     * The partial synchronization request from the server %1 completed
     * successfully. %2 changes(s) has(have) been returned to the
     * caller.
     */

#define NELOG_NetlogonPartialSyncCallFailed     (ERRLOG2_BASE + 12)
    /*
     * The partial synchronization request from the server %1 failed with
     * the following error: %n%2
     */

#define NELOG_NetlogonFullSyncCallSuccess       (ERRLOG2_BASE + 13)
    /*
     * The full synchronization request from the server %1 completed
     * successfully. %2 object(s) has(have) been returned to
     * the caller.
     */

#define NELOG_NetlogonFullSyncCallFailed        (ERRLOG2_BASE + 14)
    /*
     * The full synchronization request from the server %1 failed with
     * the following error: %n%2
     */

#define NELOG_NetlogonPartialSyncSuccess        (ERRLOG2_BASE + 15)
    /*
     * The partial synchronization replication of the %1 database from the
     * primary domain controller %2 completed successfully. %3 change(s) is(are)
     * applied to the database.
     */


#define NELOG_NetlogonPartialSyncFailed         (ERRLOG2_BASE + 16)
    /*
     * The partial synchronization replication of the %1 database from the
     * primary domain controller %2 failed with the following error: %n%3
     */

#define NELOG_NetlogonFullSyncSuccess           (ERRLOG2_BASE + 17)
    /*
     * The full synchronization replication of the %1 database from the
     * primary domain controller %2 completed successfully.
     */


#define NELOG_NetlogonFullSyncFailed            (ERRLOG2_BASE + 18)
    /*
     * The full synchronization replication of the %1 database from the
     * primary domain controller %2 failed with the following error: %n%3
     */

#define NELOG_NetlogonAuthNoDomainController    (ERRLOG2_BASE + 19)
    /*
     * This computer was not able to set up a secure session with a domain
     * controller in domain %1 due to the following: %n%2
     * %nThis may lead to authentication problems. Make sure that this
     * computer is connected to the network. If the problem persists,
     * please contact your domain administrator.
     *
     * %n%nADDITIONAL INFO
     * %nIf this computer is a domain controller for the specified domain, it
     * sets up the secure session to the primary domain controller emulator in the specified
     * domain. Otherwise, this computer sets up the secure session to any domain controller
     * in the specified domain.
     */

#define NELOG_NetlogonAuthNoTrustLsaSecret      (ERRLOG2_BASE + 20)
    /*
     * The session setup to the Windows NT or Windows 2000 Domain Controller %1 for the domain %2
     * failed because the computer %3 does not have a local security database account.
     */

#define NELOG_NetlogonAuthNoTrustSamAccount     (ERRLOG2_BASE + 21)
    /*
     * The session setup to the Windows NT or Windows 2000 Domain Controller %1 for the domain %2
     * failed because the Domain Controller did not have an account %4
     * needed to set up the session by this computer %3.
     *
     * %n%nADDITIONAL DATA
     * %nIf this computer is a member of or a Domain Controller in the specified domain, the
     * aforementioned account is a computer account for this computer in the specified domain.
     * Otherwise, the account is an interdomain trust account with the specified domain.
     */

#define NELOG_NetlogonServerAuthFailed          (ERRLOG2_BASE + 22)
    /*
     * The session setup from the computer %1 failed to authenticate.
     * The name(s) of the account(s) referenced in the security database is
     * %2.  The following error occurred: %n%3
     */

#define NELOG_NetlogonServerAuthNoTrustSamAccount (ERRLOG2_BASE + 23)
    /*
     * The session setup from computer '%1' failed because the security database
     * does not contain a trust account '%2' referenced by the specified computer.
     *
     * %n%nUSER ACTION
     *
     * %nIf this is the first occurrence of this event for the specified computer
     * and account, this may be a transient issue that doesn't require any action
     * at this time.
     *      
     * If this is a Read-Only Domain Controller and '%2' is a legitimate machine
     * account for the computer '%1' then '%1' should be marked cacheable for this
     * location if appropriate or otherwise ensure connectivity to a domain controller 
     * capable of servicing the request (for example a writable domain controller).
     *      
     * Otherwise, the following steps may be taken to resolve this problem:
     *
     * %n%nIf '%2' is a legitimate machine account for the computer '%1', then '%1'
     * should be rejoined to the domain.
     *
     * %n%nIf '%2' is a legitimate interdomain trust account, then the trust should
     * be recreated.
     *
     * %n%nOtherwise, assuming that '%2' is not a legitimate account, the following
     * action should be taken on '%1':
     *
     * %n%nIf '%1' is a Domain Controller, then the trust associated with '%2' should be deleted.
     *
     * %n%nIf '%1' is not a Domain Controller, it should be disjoined from the domain.
     */

//
// General log messages for NT services.
//

#define NELOG_FailedToRegisterSC                  (ERRLOG2_BASE + 24)
    /*
     * Could not register control handler with service controller %1.
     */

#define NELOG_FailedToSetServiceStatus            (ERRLOG2_BASE + 25)
    /*
     * Could not set service status with service controller %1.
     */

#define NELOG_FailedToGetComputerName             (ERRLOG2_BASE + 26)
    /*
     * Could not find the computer name %1.
     */

#define NELOG_DriverNotLoaded                     (ERRLOG2_BASE + 27)
    /*
     * Could not load %1 device driver.
     */

#define NELOG_NoTranportLoaded                    (ERRLOG2_BASE + 28)
    /*
     * Could not load any transport.
     */

//
// More Netlogon service events
//

#define NELOG_NetlogonFailedDomainDelta           (ERRLOG2_BASE + 29)
    /*
     * Replication of the %1 Domain Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedGlobalGroupDelta      (ERRLOG2_BASE + 30)
    /*
     * Replication of the %1 Global Group "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedLocalGroupDelta       (ERRLOG2_BASE + 31)
    /*
     * Replication of the %1 Local Group "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedUserDelta             (ERRLOG2_BASE + 32)
    /*
     * Replication of the %1 User "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedPolicyDelta           (ERRLOG2_BASE + 33)
    /*
     * Replication of the %1 Policy Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedTrustedDomainDelta    (ERRLOG2_BASE + 34)
    /*
     * Replication of the %1 Trusted Domain Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedAccountDelta          (ERRLOG2_BASE + 35)
    /*
     * Replication of the %1 Account Object "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonFailedSecretDelta           (ERRLOG2_BASE + 36)
    /*
     * Replication of the %1 Secret "%2" from primary domain controller
     * %3 failed with the following error: %n%4
     */

#define NELOG_NetlogonSystemError                 (ERRLOG2_BASE + 37)
    /*
    * The system returned the following unexpected error code: %n%1
    */

#define NELOG_NetlogonDuplicateMachineAccounts    (ERRLOG2_BASE + 38)
    /*
    * Netlogon has detected two machine accounts for server "%1".
    * The server can be either a Windows 2000 Server that is a member of the
    * domain or the server can be a LAN Manager server with an account in the
    * SERVERS global group.  It cannot be both.
    */

#define NELOG_NetlogonTooManyGlobalGroups         (ERRLOG2_BASE + 39)
    /*
    * This domain has more global groups than can be replicated to a LanMan
    * BDC.  Either delete some of your global groups or remove the LanMan
    * BDCs from the domain.
    */

#define NELOG_NetlogonBrowserDriver               (ERRLOG2_BASE + 40)
    /*
    * The Browser driver returned the following error to Netlogon: %n%1
    */

#define NELOG_NetlogonAddNameFailure              (ERRLOG2_BASE + 41)
    /*
    * Netlogon could not register the %1<1B> name for the following reason: %n%2
    */

//
//  More Remoteboot service events.
//
#define NELOG_RplMessages                         (ERRLOG2_BASE + 42)
    /*
    * Service failed to retrieve messages needed to boot remote boot clients.
    */

#define NELOG_RplXnsBoot                          (ERRLOG2_BASE + 43)
    /*
    * Service experienced a severe error and can no longer provide remote boot
    * for 3Com 3Start remote boot clients.
    */

#define NELOG_RplSystem                           (ERRLOG2_BASE + 44)
    /*
    * Service experienced a severe system error and will shut itself down.
    */

#define NELOG_RplWkstaTimeout                     (ERRLOG2_BASE + 45)
    /*
    * Client with computer name %1 failed to acknowledge receipt of the
    * boot data.  Remote boot of this client was not completed.
    */

#define NELOG_RplWkstaFileOpen                    (ERRLOG2_BASE + 46)
    /*
    * Client with computer name %1 was not booted due to an error in opening
    * file %2.
    */

#define NELOG_RplWkstaFileRead                    (ERRLOG2_BASE + 47)
    /*
    * Client with computer name %1 was not booted due to an error in reading
    * file %2.
    */

#define NELOG_RplWkstaMemory                      (ERRLOG2_BASE + 48)
    /*
    * Client with computer name %1 was not booted due to insufficient memory
    * at the remote boot server.
    */

#define NELOG_RplWkstaFileChecksum                (ERRLOG2_BASE + 49)
    /*
    * Client with computer name %1 will be booted without using checksums
    * because checksum for file %2 could not be calculated.
    */

#define NELOG_RplWkstaFileLineCount               (ERRLOG2_BASE + 50)
    /*
    * Client with computer name %1 was not booted due to too many lines in
    * file %2.
    */

#define NELOG_RplWkstaBbcFile                     (ERRLOG2_BASE + 51)
    /*
    * Client with computer name %1 was not booted because the boot block
    * configuration file %2 for this client does not contain boot block
    * line and/or loader line.
    */

#define NELOG_RplWkstaFileSize                    (ERRLOG2_BASE + 52)
    /*
    * Client with computer name %1 was not booted due to a bad size of
    * file %2.
    */

#define NELOG_RplWkstaInternal                    (ERRLOG2_BASE + 53)
    /*
    * Client with computer name %1 was not booted due to remote boot
    * service internal error.
    */

#define NELOG_RplWkstaWrongVersion                (ERRLOG2_BASE + 54)
    /*
    * Client with computer name %1 was not booted because file %2 has an
    * invalid boot header.
    */

#define NELOG_RplWkstaNetwork                     (ERRLOG2_BASE + 55)
    /*
    * Client with computer name %1 was not booted due to network error.
    */

#define NELOG_RplAdapterResource                  (ERRLOG2_BASE + 56)
    /*
    * Client with adapter id %1 was not booted due to lack of resources.
    */

#define NELOG_RplFileCopy                         (ERRLOG2_BASE + 57)
    /*
    * Service experienced error copying file or directory %1.
    */

#define NELOG_RplFileDelete                       (ERRLOG2_BASE + 58)
    /*
    * Service experienced error deleting file or directory %1.
    */

#define NELOG_RplFilePerms                        (ERRLOG2_BASE + 59)
    /*
    * Service experienced error setting permissions on file or directory %1.
    */
#define NELOG_RplCheckConfigs                     (ERRLOG2_BASE + 60)
    /*
    * Service experienced error evaluating RPL configurations.
    */
#define NELOG_RplCreateProfiles                   (ERRLOG2_BASE + 61)
    /*
    * Service experienced error creating RPL profiles for all configurations.
    */
#define NELOG_RplRegistry                         (ERRLOG2_BASE + 62)
    /*
    * Service experienced error accessing registry.
    */
#define NELOG_RplReplaceRPLDISK                   (ERRLOG2_BASE + 63)
    /*
    * Service experienced error replacing possibly outdated RPLDISK.SYS.
    */
#define NELOG_RplCheckSecurity                    (ERRLOG2_BASE + 64)
    /*
    * Service experienced error adding security accounts or setting
    * file permissions.  These accounts are the RPLUSER local group
    * and the user accounts for the individual RPL workstations.
    */
#define NELOG_RplBackupDatabase                   (ERRLOG2_BASE + 65)
    /*
    * Service failed to back up its database.
    */
#define NELOG_RplInitDatabase                     (ERRLOG2_BASE + 66)
    /*
    * Service failed to initialize from its database.  The database may be
    * missing or corrupted.  Service will attempt restoring the database
    * from the backup.
    */
#define NELOG_RplRestoreDatabaseFailure           (ERRLOG2_BASE + 67)
    /*
    * Service failed to restore its database from the backup.  Service
    * will not start.
    */
#define NELOG_RplRestoreDatabaseSuccess           (ERRLOG2_BASE + 68)
    /*
    * Service successfully restored its database from the backup.
    */
#define NELOG_RplInitRestoredDatabase             (ERRLOG2_BASE + 69)
    /*
    * Service failed to initialize from its restored database.  Service
    * will not start.
    */

//
// More Netlogon and RPL service events
//
#define NELOG_NetlogonSessionTypeWrong            (ERRLOG2_BASE + 70)
    /*
     * The session setup to the Windows NT or Windows 2000 Domain Controller %1 from computer
     * %2 using account %4 failed.  %2 is declared to be a BDC in domain %3.
     * However, %2 tried to connect as either a DC in a trusted domain,
     * a member workstation in domain %3, or as a server in domain %3.
     * Use the Active Directory Users and Computers tool or Server Manager to remove the BDC account for %2.
     */
#define NELOG_RplUpgradeDBTo40                    (ERRLOG2_BASE + 71)
    /*
    * The Remoteboot database was in NT 3.5 / NT 3.51 format and NT is
    * attempting to convert it to NT 4.0 format. The JETCONV converter
    * will write to the Application event log when it is finished.
    */
#define NELOG_NetlogonLanmanBdcsNotAllowed        (ERRLOG2_BASE + 72)
    /*
     * Global group SERVERS exists in domain %1 and has members.
     * This group defines Lan Manager BDCs in the domain.
     * Lan Manager BDCs are not permitted in NT domains.
     */
#define NELOG_NetlogonNoDynamicDns                (ERRLOG2_BASE + 73)
    /*
     * The following DNS server that is authoritative for the DNS domain controller
     * locator records of this domain controller does not support dynamic DNS updates:
     *
     * %n%nDNS server IP address: %1
     * %nReturned Response Code (RCODE): %2
     * %nReturned Status Code: %3
     *
     * %n%nUSER ACTION
     *
     * %nConfigure the DNS server to allow dynamic DNS updates or manually add the DNS
     * records from the file '%SystemRoot%\System32\Config\Netlogon.dns' to the DNS database.
     */

#define NELOG_NetlogonDynamicDnsRegisterFailure   (ERRLOG2_BASE + 74)
     /*
      * The dynamic registration of the DNS record '%1' failed on the following DNS server:
      *
      * %n%nDNS server IP address: %3
      * %nReturned Response Code (RCODE): %4
      * %nReturned Status Code: %5
      *
      * %n%nFor computers and users to locate this domain controller, this record must be
      * registered in DNS.
      *
      * %n%nUSER ACTION
      *
      * %nDetermine what might have caused this failure, resolve the problem, and initiate
      * registration of the DNS records by the domain controller. To determine what might
      * have caused this failure, run DCDiag.exe. To learn more about DCDiag.exe, see Help
      * and Support Center. To initiate registration of the DNS records by this domain 
      * controller, run 'nltest.exe /dsregdns' from the command prompt on the domain controller
      * or restart Net Logon service. %n  Or, you can manually add this record to DNS, but it
      * is not recommended.
      *
      * %n%nADDITIONAL DATA
      * %nError Value: %2
      */

#define NELOG_NetlogonDynamicDnsDeregisterFailure (ERRLOG2_BASE + 75)
     /*
      * The dynamic deletion of the DNS record '%1' failed on the following DNS server:
      *
      * %n%nDNS server IP address: %3
      * %nReturned Response Code (RCODE): %4
      * %nReturned Status Code: %5
      *
      * %n%nUSER ACTION
      *
      * %nTo prevent remote computers from connecting unnecessarily to the domain controller,
      * delete the record manually or troubleshoot the failure to dynamically delete the
      * record. To learn more about debugging DNS, see Help and Support Center.
      *
      * %n%nADDITIONAL DATA
      * %nError Value: %2
      */

#define NELOG_NetlogonFailedFileCreate            (ERRLOG2_BASE + 76)
    /*
     * Failed to create/open file %1 with the following error: %n%2
     */

#define NELOG_NetlogonGetSubnetToSite             (ERRLOG2_BASE + 77)
    /*
     * Netlogon got the following error while trying to get the subnet to site
     * mapping information from the DS: %n%1
     */

#define NELOG_NetlogonNoSiteForClient              (ERRLOG2_BASE + 78)
   /*
    * '%1' tried to determine its site by looking up its IP address ('%2')
    * in the Configuration\Sites\Subnets container in the DS.  No subnet matched
    * the IP address.  Consider adding a subnet object for this IP address.
    */

#define NELOG_NetlogonBadSiteName                  (ERRLOG2_BASE + 79)
    /*
     * The site name for this computer is '%1'.  That site name is not a valid
     * site name.  A site name must be a valid DNS label.
     * Rename the site to be a valid name.
     */

#define NELOG_NetlogonBadSubnetName                (ERRLOG2_BASE + 80)
    /*
     * The subnet object '%1' appears in the Configuration\Sites\Subnets
     * container in the DS.  The name is not syntactically valid.  The valid
     * syntax is xx.xx.xx.xx/yy where xx.xx.xx.xx is a valid IP subnet number
     * and yy is the number of bits in the subnet mask.
     *
     * Correct the name of the subnet object.
     */

#define NELOG_NetlogonDynamicDnsServerFailure      (ERRLOG2_BASE + 81)
    /*
     * Dynamic registration or deletion of one or more DNS records associated with DNS
     * domain '%1' failed.  These records are used by other computers to locate this
     * server as a domain controller (if the specified domain is an Active Directory
     * domain) or as an LDAP server (if the specified domain is an application partition).
     *
     * %n%nPossible causes of failure include:
     *
     * %n- TCP/IP properties of the network connections of this computer contain wrong IP address(es) of the preferred and alternate DNS servers
     * %n- Specified preferred and alternate DNS servers are not running
     * %n- DNS server(s) primary for the records to be registered is not running
     * %n- Preferred or alternate DNS servers are configured with wrong root hints
     * %n- Parent DNS zone contains incorrect delegation to the child zone authoritative for the DNS records that failed registration
     *
     * %n%nUSER ACTION
     *
     * %nFix possible misconfiguration(s) specified above and initiate registration or deletion of
     * the DNS records by running 'nltest.exe /dsregdns' from the command prompt on the domain
     * controller or by restarting Net Logon service on the domain controller.
     */

#define NELOG_NetlogonDynamicDnsFailure            (ERRLOG2_BASE + 82)
    /*
     * Dynamic registration or deregistration of one or more DNS records failed with the following error: %n%1
     */

#define NELOG_NetlogonRpcCallCancelled             (ERRLOG2_BASE + 83)
    /*
     * The session setup to the Windows NT or Windows 2000 Domain Controller %1 for the domain %2
     * is not responsive.  The current RPC call from Netlogon on \\%3 to %1 has been cancelled.
     */

#define NELOG_NetlogonDcSiteCovered                (ERRLOG2_BASE + 84)
    /*
     * Site '%2' does not have any Domain Controllers for domain '%3'.
     * Domain Controllers in site '%1' have been automatically
     * selected to cover site '%2' for domain '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonDcSiteNotCovered             (ERRLOG2_BASE + 85)
    /*
     * This Domain Controller no longer automatically covers site '%1' for domain '%2'.
     */

#define NELOG_NetlogonGcSiteCovered                (ERRLOG2_BASE + 86)
    /*
     * Site '%2' does not have any Global Catalog servers for forest '%3'.
     * Global Catalog servers in site '%1' have been automatically
     * selected to cover site '%2' for forest '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonGcSiteNotCovered             (ERRLOG2_BASE + 87)
    /*
     * This Global Catalog server no longer automatically covers site '%1' for forest '%2'.
     */

#define NELOG_NetlogonFailedSpnUpdate              (ERRLOG2_BASE + 88)
    /*
     * Attempt to update HOST Service Principal Names (SPNs) of the computer
     * object in Active Directory failed. The updated values were '%1' and '%2'.
     * The following error occurred: %n%3
     */

#define NELOG_NetlogonFailedDnsHostNameUpdate      (ERRLOG2_BASE + 89)
    /*
     * Attempt to update DNS Host Name of the computer object
     * in Active Directory failed. The updated value was '%1'.
     * The following error occurred: %n%2
     */

#define NELOG_NetlogonAuthNoUplevelDomainController (ERRLOG2_BASE + 90)
    /*
     * No suitable Domain Controller is available for domain %1.
     * An NT4 or older domain controller is available but it cannot
     * be used for authentication purposes in the Windows 2000 or newer
     * domain that this computer is a member of.
     * The following error occurred:%n%2
     */

#define NELOG_NetlogonAuthDomainDowngraded         (ERRLOG2_BASE + 91)
    /*
     * The domain of this computer, %1 has been downgraded from Windows 2000
     * or newer to Windows NT4 or older. The computer cannot function properly
     * in this case for authentication purposes. This computer needs to rejoin
     * the domain.
     * The following error occurred:%n%2
     */

#define NELOG_NetlogonNdncSiteCovered                (ERRLOG2_BASE + 92)
    /*
     * Site '%2' does not have any LDAP servers for non-domain NC '%3'.
     * LDAP servers in site '%1' have been automatically selected to
     * cover site '%2' for non-domain NC '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonNdncSiteNotCovered             (ERRLOG2_BASE + 93)
    /*
     * This LDAP server no longer automatically covers site '%1' for non-domain NC '%2'.
     */

#define NELOG_NetlogonDcOldSiteCovered               (ERRLOG2_BASE + 94)
    /*
     * Site '%2' is no longer manually configured in the registry as
     * covered by this Domain Controller for domain '%3'. As a result,
     * site '%2' does not have any Domain Controllers for domain '%3'.
     * Domain Controllers in site '%1' have been automatically
     * selected to cover site '%2' for domain '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonDcSiteNotCoveredAuto           (ERRLOG2_BASE + 95)
    /*
     * This Domain Controller no longer automatically covers site '%1' for domain '%2'.
     * However, site '%1' is still (manually) covered by this Domain Controller for
     * domain '%2' since this site has been manually configured in the registry.
     */

#define NELOG_NetlogonGcOldSiteCovered               (ERRLOG2_BASE + 96)
    /*
     * Site '%2' is no longer manually configured in the registry as
     * covered by this Global Catalog server for forest '%3'. As a result,
     * site '%2' does not have any Global Catalog servers for forest '%3'.
     * Global Catalog servers in site '%1' have been automatically
     * selected to cover site '%2' for forest '%3' based on configured
     * Directory Server replication costs.
     */

#define NELOG_NetlogonGcSiteNotCoveredAuto           (ERRLOG2_BASE + 97)
    /*
     * This Global Catalog server no longer automatically covers site '%1' for forest '%2'.
     * However, site '%1' is still (manually) covered by this Global catalog for
     * forest '%2' since this site has been manually configured in the registry.
     */

#define NELOG_NetlogonNdncOldSiteCovered             (ERRLOG2_BASE + 98)
    /*
     * Site '%2' is no longer manually configured in the registry as
     * covered by this LDAP server for non-domain NC '%3'. As a result,
     * site '%2' does not have any LDAP servers for non-domain NC '%3'.
     * LDAP servers in site '%1' have been automatically
     * selected to cover site '%2' for non-domain NC '%3' based on
     * configured Directory Server replication costs.
     */

#define NELOG_NetlogonNdncSiteNotCoveredAuto         (ERRLOG2_BASE + 99)
    /*
     * This LDAP server no longer automatically covers site '%1' for non-domain NC '%2'.
     * However, site '%1' is still (manually) covered by this LDAP server for
     * non-domain NC '%2' since this site has been manually configured in the registry.
     */

#define NELOG_NetlogonSpnMultipleSamAccountNames     (ERRLOG2_BASE + 100)
    /*
     * Attempt to update DnsHostName and HOST Service Principal Name (SPN) attributes
     * of the computer object in Active Directory failed because the Domain Controller
     * '%1' had more than one account with the name '%2' corresponding to this computer.
     * Not having SPNs registered may result in authentication failures for this computer.
     * Contact your domain administrator who may need to manually resolve the account name
     * collision.
     */

#define NELOG_NetlogonSpnCrackNamesFailure           (ERRLOG2_BASE + 101)
    /*
     * Attempt to update DnsHostName and HOST Service Principal Name (SPN) attributes
     * of the computer object in Active Directory failed because this computer account
     * name, '%2' could not be mapped to the computer object on Domain Controller '%1'.
     * Not having SPNs registered may result in authentication failures for this computer.
     * Contact your domain administrator. The following technical information may be
     * useful for the resolution of this failure:%n
     * DsCrackNames status = 0x%3, crack error = 0x%4.
     */

#define NELOG_NetlogonNoAddressToSiteMapping         (ERRLOG2_BASE + 102)
    /*
     * None of the IP addresses (%2) of this Domain Controller map to the configured site '%1'.
     * While this may be a temporary situation due to IP address changes, it is generally
     * recommended that the IP address of the Domain Controller (accessible to machines in
     * its domain) maps to the Site which it services. If the above list of IP addresses is
     * stable, consider moving this server to a site (or create one if it does not already
     * exist) such that the above IP address maps to the selected site. This may require the
     * creation of a new subnet object (whose range includes the above IP address) which maps
     * to the selected site object.
     */

#define NELOG_NetlogonInvalidGenericParameterValue   (ERRLOG2_BASE + 103)
    /*
     * The following error occurred while reading a parameter '%2' in the
     * Netlogon %1 registry section:%n%3
     */

#define NELOG_NetlogonInvalidDwordParameterValue     (ERRLOG2_BASE + 104)
    /*
     * The Netlogon %1 registry key contains an invalid value 0x%2 for parameter '%3'.
     * The minimum and maximum values allowed for this parameter are 0x%4 and 0x%5, respectively.
     * The value of 0x%6 has been assigned to this parameter.
     */

#define NELOG_NetlogonServerAuthFailedNoAccount      (ERRLOG2_BASE + 105)
    /*
     * The session setup from the computer %1 failed to authenticate.
     * The following error occurred: %n%2
     */

#define NELOG_NetlogonNoDynamicDnsManual             (ERRLOG2_BASE + 106)
    /*
     * Dynamic DNS updates have been manually disabled on this domain controller.
     *
     * %n%nUSER ACTION
     *
     * %nReconfigure this domain controller to use dynamic DNS updates or manually add the DNS
     * records from the file '%SystemRoot%\System32\Config\Netlogon.dns' to the DNS database.
     */

#define NELOG_NetlogonNoSiteForClients               (ERRLOG2_BASE + 107)
    /*
     * During the past %1 hours there have been %2 connections to this Domain
     * Controller from client machines whose IP addresses don't map to any of
     * the existing sites in the enterprise. Those clients, therefore, have
     * undefined sites and may connect to any Domain Controller including
     * those that are in far distant locations from the clients. A client's site
     * is determined by the mapping of its subnet to one of the existing sites.
     * To move the above clients to one of the sites, please consider creating
     * subnet object(s) covering the above IP addresses with mapping to one of the
     * existing sites.  The names and IP addresses of the clients in question have
     * been logged on this computer in the following log file
     * '%SystemRoot%\debug\netlogon.log' and, potentially, in the log file
     * '%SystemRoot%\debug\netlogon.bak' created if the former log becomes full.
     * The log(s) may contain additional unrelated debugging information. To filter
     * out the needed information, please search for lines which contain text
     * 'NO_CLIENT_SITE:'. The first word after this string is the client name and
     * the second word is the client IP address. The maximum size of the log(s) is
     * controlled by the following registry DWORD value
     * 'HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters\LogFileMaxSize';
     * the default is %3 bytes.  The current maximum size is %4 bytes.  To set a
     * different maximum size, create the above registry value and set the desired
     * maximum size in bytes.
     */

#define NELOG_NetlogonDnsDeregAborted                (ERRLOG2_BASE + 108)
    /*
     * The deregistration of some DNS domain controller locator records was aborted
     * at the time of this domain controller demotion because the DNS deregistrations
     * took too long.
     *
     * %n%nUSER ACTION
     *
     * %nManually delete the DNS records listed in the file
     * '%SystemRoot%\System32\Config\Netlogon.dns' from the DNS database.
     */

#define NELOG_NetlogonRpcPortRequestFailure          (ERRLOG2_BASE + 109)
    /*
     * The NetLogon service on this domain controller has been configured to use port %1
     * for incoming RPC connections over TCP/IP from remote machines. However, the
     * following error occurred when Netlogon attempted to register this port with the RPC
     * endpoint mapper service: %n%2 %nThis will prevent the NetLogon service on remote
     * machines from connecting to this domain controller over TCP/IP that may result in
     * authentication problems.
     *
     * %n%nUSER ACTION
     *
     * %nThe specified port is configured via the Group Policy or via a registry value 'DcTcpipPort'
     * under the 'HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters'
     * registry key; the value configured through the Group Policy takes precedence. If the
     * port specified is in error, reset it to a correct value. You can also remove this
     * configuration for the port in which case the port will be assigned dynamically by
     * the endpoint mapper at the time the NetLogon service on remote machines makes RPC connections
     * to this domain controller. After the misconfiguration is corrected, restart the NetLogon
     * service on this machine and verify that this event log no longer appears.
     */

#define NELOG_NetlogonPartialSiteMappingForClients   (ERRLOG2_BASE + 110)
    /*
     * During the past %1 hours, this domain controller has received %2 connections
     * from dual-stack IPv4/IPv6 clients with partial subnet-site mappings. A client
     * has a partial subnet-site mapping if its IPv4 address is mapped to a site but
     * its global IPv6 address is not mapped to a site, or vice versa. To ensure correct
     * behavior for applications running on member computers and servers that rely on
     * subnet-site mappings, dual-stack IPv4/IPv6 clients must have both IPv4 and global
     * IPv6 addresses mapped to the same site. If a partially mapped client attempts
     * to connect to this domain controller using its unmapped IP address, its mapped
     * address is used for the client's site mapping.
     *
     * %n%nThe log files %SystemRoot%\debug\netlogon.log or %SystemRoot%\debug\netlogon.bak
     * contain the name, unmapped IP address and mapped IP address for each partially
     * mapped client. The log files may also contain unrelated debugging information.
     * To locate the information pertaining to partial-subnet mappings, search for
     * lines that contain the text 'PARTIAL_CLIENT_SITE_MAPPING:'. The first word after
     * this text is the client name. Following the client name is the client's unmapped
     * IP address (the IP address that does not have a subnet-site mapping) and the
     * client's mapped IP address, which was used to return site information.
     *
     * %n%nUSER ACTION
     *
     * %nUse the Active Directory Sites and Services management console (MMC) snap-in
     * to add the subnet mapping for the unmapped IP addresses to the same site being
     * used by the mapped IP addresses. When adding site mappings for IPv6 addresses,
     * you should use global IPv6 addresses and not for instance temporary, link-local
     * or site-local IPv6 addresses.
     *
     * %n%nThe default maximum size of the log files is %3 bytes. The current maximum
     * size is %4 bytes. To set a different maximum size, create the following registry
     * DWORD value to specify the maximum size in bytes:
     *
     * %nHKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Netlogon\Parameters\LogFileMaxSize
     */

#define NELOG_NetlogonRemoteDynamicDnsRegisterFailure   (ERRLOG2_BASE + 111)
     /*
      * The dynamic registration of the DNS record '%1' for the remote domain controller '%3'
      * failed on the following DNS server:
      *
      * %n%nDNS server IP address: %4
      * %nReturned Response Code (RCODE): %5
      * %nReturned Status Code: %6
      *
      * %n%nFor computers and users to locate the domain controller '%3', this record must be
      * registered in DNS.
      *
      * %n%nUSER ACTION
      *
      * %nDetermine what might have caused this failure, resolve the problem, and initiate
      * registration of the DNS records by the domain controller '%3'. For help with determining
      * and resolving the problem, see Help and Support for information about troubleshooting
      * DNS. To initiate registration of the DNS records by the domain controller '%3', run
      * 'nltest.exe /dsregdns' from the command prompt on the domain controller '%3' or restart
      * the Net Logon service on the domain controller '%3'. Nltest.exe is a command line tool
      * that is built into Windows Server.
      * %n As a workaround, you can manually add this record to DNS, but it is not recommended
      * because you then must manually update any changes it requires hereafter.
      *
      * %n%nADDITIONAL DATA
      * %nError Value: %2
      */

#define NELOG_NetlogonRemoteDynamicDnsDeregisterFailure (ERRLOG2_BASE + 112)
     /*
      * The dynamic deregistration of the DNS record '%1' for the remote domain controller
      * '%3' failed on the following DNS server:
      *
      * %n%nDNS server IP address: %4
      * %nReturned Response Code (RCODE): %5
      * %nReturned Status Code: %6
      *
      * %n%nUSER ACTION
      *
      * %nTo prevent remote computers from attempting to connect to the domain controller '%3'
      * using an invalid record, delete the record '%1' manually or troubleshoot the root cause
      * behind the dynamic deregistration failure. To learn more about troubleshooting DNS, see
      * Help and Support.
      *
      * %n%nADDITIONAL DATA
      * %nError Value: %2
      */

#define NELOG_NetlogonRejectedRemoteDynamicDnsRegister   (ERRLOG2_BASE + 113)
     /*
      * The dynamic registration request for the DNS record '%1' has been rejected by the
      * remote domain controller '%2'. Error: '%3'
      *
      * %n%nFor computers and users to locate this domain controller, this record must be
      * registered in DNS. If the problem persists, please contact your domain administrator.
      */

#define NELOG_NetlogonRejectedRemoteDynamicDnsDeregister (ERRLOG2_BASE + 114)
     /*
      * The dynamic deregistration request of the DNS record '%1' has been rejected by the
      * remote domain controller '%2'. Error: '%3'
      *
      * %n%nTo prevent remote computers from connecting unnecessarily to this domain controller,
      * an administrator with sufficient privileges must manually delete the record on the DNS
      * server that hosts it.
      */

#define NELOG_NetlogonRemoteDynamicDnsUpdateRequestFailure   (ERRLOG2_BASE + 115)
     /*
      * The remoting of the dynamic update request for the local domain controller's DNS records
      * through a secure session has failed with error '%1'.
      *
      * %n%nFor other computers and member servers to locate this domain controller, the appropriate
      * records must be registered in DNS. On this domain controller, look for events related to
      * failure to set up a secure session to determine why the request is failing. If the problem
      * persists, please contact your domain administrator.
      */

#ifdef __cplusplus
}
#endif

#endif // _LMERRLOG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMMsg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmmsg.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetMessage API.

[Environment:]

    User Mode - Win32

[Notes:]

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMMSG_
#define _LMMSG_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetMessageNameAdd (
    __in_opt  LPCWSTR  servername,
    __in      LPCWSTR  msgname
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameEnum (
    __in_opt  LPCWSTR  servername,
    __in      DWORD    level,
    __in      LPBYTE  *bufptr,
    __in      DWORD    prefmaxlen,
    __out     LPDWORD  entriesread,
    __out     LPDWORD  totalentries,
    __out     LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameGetInfo (
    __in_opt  LPCWSTR  servername,
    __in      LPCWSTR  msgname,
    __in      DWORD    level,
    __in      LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageNameDel (
    __in_opt  LPCWSTR  servername,
    __in      LPCWSTR  msgname
    );

NET_API_STATUS NET_API_FUNCTION
NetMessageBufferSend (
    __in_opt  LPCWSTR servername,
    __in      LPCWSTR msgname,
    __in      LPCWSTR fromname,
    __in      LPBYTE  buf,
    __in      DWORD   buflen
    );

//
//  Data Structures
//

typedef struct _MSG_INFO_0 {
    LPWSTR  msgi0_name;
}MSG_INFO_0, *PMSG_INFO_0, *LPMSG_INFO_0;

typedef struct _MSG_INFO_1 {
    LPWSTR  msgi1_name;
    DWORD   msgi1_forward_flag;
    LPWSTR  msgi1_forward;
}MSG_INFO_1, *PMSG_INFO_1, *LPMSG_INFO_1;

//
// Special Values and Constants
//

//
// Values for msgi1_forward_flag.
//

#define MSGNAME_NOT_FORWARDED   0       // Name not forwarded
#define MSGNAME_FORWARDED_TO    0x04    // Name forward to remote station
#define MSGNAME_FORWARDED_FROM  0x10    // Name forwarded from remote station

#ifdef __cplusplus
}
#endif

#endif //_LMMSG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMRemUtl.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmremutl.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetRemote API.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

--*/

#ifndef _LMREMUTL_
#define _LMREMUTL_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Type Definitions
//

#ifndef DESC_CHAR_UNICODE

typedef CHAR DESC_CHAR;
typedef LPSTR LPDESC;

#else // DESC_CHAR_UNICODE is defined

typedef WCHAR DESC_CHAR;
typedef LPWSTR LPDESC;

#endif // DESC_CHAR_UNICODE is defined



//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetRemoteTOD (
    IN LPCWSTR UncServerName,
    __out OUT LPBYTE *BufferPtr
    );

NET_API_STATUS NET_API_FUNCTION
NetRemoteComputerSupports(
    IN LPCWSTR UncServerName OPTIONAL,   // Must start with "\\".
    IN DWORD OptionsWanted,             // Set SUPPORTS_ bits wanted.
    OUT LPDWORD OptionsSupported        // Supported features, masked.
    );

NET_API_STATUS
__cdecl
RxRemoteApi(
    IN DWORD ApiNumber,
    __in IN LPCWSTR UncServerName,                    // Required, with \\name.
    __in IN LPDESC ParmDescString,
    __in_opt IN LPDESC DataDesc16 OPTIONAL,
    __in_opt IN LPDESC DataDesc32 OPTIONAL,
    __in_opt IN LPDESC DataDescSmb OPTIONAL,
    __in_opt IN LPDESC AuxDesc16 OPTIONAL,
    __in_opt IN LPDESC AuxDesc32 OPTIONAL,
    __in_opt IN LPDESC AuxDescSmb OPTIONAL,
    IN DWORD  Flags,
    ...                                         // rest of API's arguments
    );



//
//  Data Structures
//

typedef struct _TIME_OF_DAY_INFO {
    DWORD      tod_elapsedt;
    DWORD      tod_msecs;
    DWORD      tod_hours;
    DWORD      tod_mins;
    DWORD      tod_secs;
    DWORD      tod_hunds;
    LONG       tod_timezone;
    DWORD      tod_tinterval;
    DWORD      tod_day;
    DWORD      tod_month;
    DWORD      tod_year;
    DWORD      tod_weekday;
} TIME_OF_DAY_INFO, *PTIME_OF_DAY_INFO, *LPTIME_OF_DAY_INFO;

//
// Special Values and Constants
//

//
// Mask bits for use with NetRemoteComputerSupports:
//

#define SUPPORTS_REMOTE_ADMIN_PROTOCOL  0x00000002L
#define SUPPORTS_RPC                    0x00000004L
#define SUPPORTS_SAM_PROTOCOL           0x00000008L
#define SUPPORTS_UNICODE                0x00000010L
#define SUPPORTS_LOCAL                  0x00000020L
#define SUPPORTS_ANY                    0xFFFFFFFFL

//
// Flag bits for RxRemoteApi:
//

#define NO_PERMISSION_REQUIRED  0x00000001      // set if use NULL session
#define ALLOCATE_RESPONSE       0x00000002      // set if RxRemoteApi allocates response buffer
#define USE_SPECIFIC_TRANSPORT  0x80000000

#ifdef __cplusplus
}
#endif

#endif //_LMREMUTL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMJoin.h ===
/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    netsetup.h

Abstract:

    Definitions and prototypes for the Net setup apis, for joining/unjoinging
    domains and promoting/demoting servers

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

--*/

#ifndef __LMJOIN_H__
#define __LMJOIN_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Types of name that can be validated
//
typedef enum  _NETSETUP_NAME_TYPE {

    NetSetupUnknown = 0,
    NetSetupMachine,
    NetSetupWorkgroup,
    NetSetupDomain,
    NetSetupNonExistentDomain,
#if(_WIN32_WINNT >= 0x0500)
    NetSetupDnsMachine
#endif

} NETSETUP_NAME_TYPE, *PNETSETUP_NAME_TYPE;


//
// Status of a workstation
//
typedef enum _NETSETUP_JOIN_STATUS {

    NetSetupUnknownStatus = 0,
    NetSetupUnjoined,
    NetSetupWorkgroupName,
    NetSetupDomainName

} NETSETUP_JOIN_STATUS, *PNETSETUP_JOIN_STATUS;

//
// Flags to determine the behavior of the join/unjoin APIs
//
#define NETSETUP_JOIN_DOMAIN    0x00000001      // If not present, workgroup is joined
#define NETSETUP_ACCT_CREATE    0x00000002      // Do the server side account creation/rename
#define NETSETUP_ACCT_DELETE    0x00000004      // Delete the account when a domain is left
#define NETSETUP_WIN9X_UPGRADE  0x00000010      // Invoked during upgrade of Windows 9x to
                                                // Windows NT
#define NETSETUP_DOMAIN_JOIN_IF_JOINED  0x00000020  // Allow the client to join a new domain
                                                // even if it is already joined to a domain
#define NETSETUP_JOIN_UNSECURE  0x00000040      // Performs an unsecure join
#define NETSETUP_MACHINE_PWD_PASSED 0x00000080  // Indicates that the machine (not user) password
                                                //  is passed. Valid only for unsecure joins
#define NETSETUP_DEFER_SPN_SET  0x00000100      // Specifies that writting SPN and DnsHostName
                                                //  attributes on the computer object should be
                                                //  defered until rename that will follow join
                                                
#define NETSETUP_JOIN_DC_ACCOUNT    0x00000200  // Allow join if existing account is a DC
#define NETSETUP_JOIN_WITH_NEW_NAME 0x00000400  // Check for computer name change
#define NETSETUP_JOIN_READONLY      0x00000800  // Perform join using a pre-created account w/o requiring a writable DC
#define NETSETUP_DNS_NAME_CHANGES_ONLY 0x00001000      // When performing machine rename only update DNS based names 

#define NETSETUP_INSTALL_INVOCATION 0x00040000  // The APIs were invoked during install

#define NETSETUP_AMBIGUOUS_DC       0x00001000  // When joiing the domain don't try to set the
                                                // preferred DC in the registry.
#define NETSETUP_NO_NETLOGON_CACHE  0x00002000  // Don't create the netlogon cache
#define NETSETUP_DONT_CONTROL_SERVICES 0x00004000 // Don't force netlogon to start
#define NETSETUP_SET_MACHINE_NAME   0x00008000  // For offline join only, set target machine hostname and NB name.
#define NETSETUP_FORCE_SPN_SET      0x00010000  // Override other settings during domain join
                                                // and attempt to set the SPN.
#define NETSETUP_NO_ACCT_REUSE      0x00020000  // Do not reuse an existing account

#define NETSETUP_IGNORE_UNSUPPORTED_FLAGS  0x10000000  // If this bit is set, unrecognized flags
                                                       //  will be ignored by the NetJoin API and
                                                       //  the API will behave as if the flags
                                                       //  were not set.

#define NETSETUP_VALID_UNJOIN_FLAGS (NETSETUP_ACCT_DELETE | NETSETUP_IGNORE_UNSUPPORTED_FLAGS | NETSETUP_JOIN_DC_ACCOUNT)

// The following flags are used when the system is processing information left from a prior offline
// join.  We want to force DC discovery and we don't want to create the netlogon cache.  We also
// don't want to immediately force netlogon to start, let it start on its own.
#define NETSETUP_PROCESS_OFFLINE_FLAGS ( NETSETUP_JOIN_DOMAIN |                     \
                                         NETSETUP_DOMAIN_JOIN_IF_JOINED |           \
                                         NETSETUP_JOIN_WITH_NEW_NAME |              \
                                         NETSETUP_DONT_CONTROL_SERVICES |           \
                                         NETSETUP_MACHINE_PWD_PASSED)  

//
// 0x80000000 is reserved for internal use only
//


//
// Joins a machine to the domain.
//
NET_API_STATUS
NET_API_FUNCTION
NetJoinDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpDomain,
    IN  LPCWSTR lpAccountOU, OPTIONAL
    IN  LPCWSTR lpAccount OPTIONAL,
    __in_opt IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fJoinOptions
    );
    

#if(_WIN32_WINNT >= 0x0601)  

//
// Flags to determine the behavior of NetProvisionComputerAccount
//

// The caller requires account creation by privilege, this option will cause a retry 
// on failure using down level account creation APIs.
//
#define NETSETUP_PROVISION_DOWNLEVEL_PRIV_SUPPORT 0x00000001 

// If the named account already exists an attempt will be made to reuse. Requires 
// sufficient credentials i.e. Domain Administrator or the object owner.
//
#define NETSETUP_PROVISION_REUSE_ACCOUNT          0x00000002 
                                                    
// Use the default machine account password which is the machine name in lowercase.
//
#define NETSETUP_PROVISION_USE_DEFAULT_PASSWORD   0x00000004 
                                                 
// Do not try to find the account on any DC in the domain. This is faster but 
// should only be used when the caller is certain that an account by the same 
// name hasn't recently been created. Only valid when specifying the target DC. 
// When the pre-requisites are met, this option allows for must faster provisioning 
// useful for scenarios such as batch processing.         
//
#define NETSETUP_PROVISION_SKIP_ACCOUNT_SEARCH    0x00000008   

//
// The following are reserved for internal use.
//

// The operation is online.
// This is an internal option not available through the API.
//
#define NETSETUP_PROVISION_ONLINE_CALLER          0x40000000          

// Validate the machine password only. This is an internal option not available
// through the API.          
//
#define NETSETUP_PROVISION_CHECK_PWD_ONLY         0x80000000



NET_API_STATUS
NET_API_FUNCTION
NetProvisionComputerAccount( 
   __in            LPCWSTR lpDomain,
   __in            LPCWSTR lpMachineName,
   __in_opt        LPCWSTR lpMachineAccountOU,
   __in_opt        LPCWSTR lpDcName,  
   __in            DWORD   dwOptions,
   __deref_opt_out PBYTE  *pProvisionBinData,
   __out_opt       DWORD  *pdwProvisionBinDataSize,
   __deref_opt_out LPWSTR *pProvisionTextData
);

NET_API_STATUS
NET_API_FUNCTION
NetRequestOfflineDomainJoin(
    __in_bcount(cbProvisionBinDataSize) BYTE *pProvisionBinData,
    __in DWORD   cbProvisionBinDataSize,
    __in DWORD   dwOptions,
    __in LPCWSTR lpWindowsPath
);

#endif // (_WIN32_WINNT >= 0x0601)  

NET_API_STATUS
NET_API_FUNCTION
NetUnjoinDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    __in_opt IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fUnjoinOptions
    );

NET_API_STATUS
NET_API_FUNCTION
NetRenameMachineInDomain(
    IN  LPCWSTR lpServer OPTIONAL,
    IN  LPCWSTR lpNewMachineName OPTIONAL,
    IN  LPCWSTR lpAccount OPTIONAL,
    __in_opt IN  LPCWSTR lpPassword OPTIONAL,
    IN  DWORD   fRenameOptions
    );


//
// Determine the validity of a name
//
NET_API_STATUS
NET_API_FUNCTION
NetValidateName(
    IN  LPCWSTR             lpServer OPTIONAL,
    IN  LPCWSTR             lpName,
    IN  LPCWSTR             lpAccount OPTIONAL,
    __in_opt IN  LPCWSTR             lpPassword OPTIONAL,
    IN  NETSETUP_NAME_TYPE  NameType
    );

//
// Determines whether a workstation is joined to a domain or not
//
NET_API_STATUS
NET_API_FUNCTION
NetGetJoinInformation(
    __in_opt IN   LPCWSTR                lpServer OPTIONAL,
    __out_opt OUT  LPWSTR                *lpNameBuffer,
    OUT  PNETSETUP_JOIN_STATUS  BufferType
    );


//
// Determines the list of OUs that the client can create a machine account in
//
NET_API_STATUS
NET_API_FUNCTION
NetGetJoinableOUs(
    IN  LPCWSTR     lpServer OPTIONAL,
    IN  LPCWSTR     lpDomain,
    IN  LPCWSTR     lpAccount OPTIONAL,
    __in_opt IN  LPCWSTR     lpPassword OPTIONAL,
    __out_opt OUT DWORD      *OUCount,
    __deref_out OUT LPWSTR    **OUs
    );
    
#if(_WIN32_WINNT >= 0x0501)

//
// Computer rename preparation APIs
//

#define NET_IGNORE_UNSUPPORTED_FLAGS  0x01

NET_API_STATUS
NET_API_FUNCTION
NetAddAlternateComputerName(
    IN  LPCWSTR Server OPTIONAL,
    IN  LPCWSTR AlternateName,
    IN  LPCWSTR DomainAccount OPTIONAL,
    __in_opt IN  LPCWSTR DomainAccountPassword OPTIONAL,
    IN  ULONG Reserved
    );

NET_API_STATUS
NET_API_FUNCTION
NetRemoveAlternateComputerName(
    IN  LPCWSTR Server OPTIONAL,
    IN  LPCWSTR AlternateName,
    IN  LPCWSTR DomainAccount OPTIONAL,
    __in_opt IN  LPCWSTR DomainAccountPassword OPTIONAL,
    IN  ULONG Reserved
    );

NET_API_STATUS
NET_API_FUNCTION
NetSetPrimaryComputerName(
    IN  LPCWSTR Server OPTIONAL,
    IN  LPCWSTR PrimaryName,
    IN  LPCWSTR DomainAccount OPTIONAL,
    __in_opt IN  LPCWSTR DomainAccountPassword OPTIONAL,
    IN  ULONG Reserved
    );

//
// The following enumeration must be kept
// in sync with COMPUTER_NAME_TYPE defined
// in winbase.h
//

typedef enum _NET_COMPUTER_NAME_TYPE {
    NetPrimaryComputerName,
    NetAlternateComputerNames,
    NetAllComputerNames,
    NetComputerNameTypeMax
} NET_COMPUTER_NAME_TYPE, *PNET_COMPUTER_NAME_TYPE;

NET_API_STATUS
NET_API_FUNCTION
NetEnumerateComputerNames(
    IN  LPCWSTR Server OPTIONAL,
    IN  NET_COMPUTER_NAME_TYPE NameType,
    IN  ULONG Reserved,
    __out OUT PDWORD EntryCount,
    __deref_out OUT LPWSTR **ComputerNames
    );
    
#endif // (_WIN32_WINNT >= 0x0501) 

#ifdef __cplusplus
}
#endif

#endif // __LMJOIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMStats.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmstats.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetStatistics

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMSTATS_
#define _LMSTATS_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>

//
// Function Prototypes - Statistics
//

NET_API_STATUS NET_API_FUNCTION
NetStatisticsGet (
    __in        LPTSTR  ServerName,
    __in        LPTSTR  Service,
    __in        DWORD   Level,
    __in        DWORD   Options,
    __deref_out LPBYTE *Buffer
    );

//
// Data Structures - Statistics
//

#ifdef LM20_WORKSTATION_STATISTICS
typedef struct _STAT_WORKSTATION_0 {
     DWORD          stw0_start;
     DWORD          stw0_numNCB_r;
     DWORD          stw0_numNCB_s;
     DWORD          stw0_numNCB_a;
     DWORD          stw0_fiNCB_r;
     DWORD          stw0_fiNCB_s;
     DWORD          stw0_fiNCB_a;
     DWORD          stw0_fcNCB_r;
     DWORD          stw0_fcNCB_s;
     DWORD          stw0_fcNCB_a;
     DWORD          stw0_sesstart;
     DWORD          stw0_sessfailcon;
     DWORD          stw0_sessbroke;
     DWORD          stw0_uses;
     DWORD          stw0_usefail;
     DWORD          stw0_autorec;
     DWORD          stw0_bytessent_r_lo;
     DWORD          stw0_bytessent_r_hi;
     DWORD          stw0_bytesrcvd_r_lo;
     DWORD          stw0_bytesrcvd_r_hi;
     DWORD          stw0_bytessent_s_lo;
     DWORD          stw0_bytessent_s_hi;
     DWORD          stw0_bytesrcvd_s_lo;
     DWORD          stw0_bytesrcvd_s_hi;
     DWORD          stw0_bytessent_a_lo;
     DWORD          stw0_bytessent_a_hi;
     DWORD          stw0_bytesrcvd_a_lo;
     DWORD          stw0_bytesrcvd_a_hi;
     DWORD          stw0_reqbufneed;
     DWORD          stw0_bigbufneed;
} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
#else

//
// NB: The following structure is REDIR_STATISTICS in sdk\inc\ntddnfs.h. If you
//     change the structure, change it in both places
//

typedef struct _STAT_WORKSTATION_0 {
    LARGE_INTEGER   StatisticsStartTime;

    LARGE_INTEGER   BytesReceived;
    LARGE_INTEGER   SmbsReceived;
    LARGE_INTEGER   PagingReadBytesRequested;
    LARGE_INTEGER   NonPagingReadBytesRequested;
    LARGE_INTEGER   CacheReadBytesRequested;
    LARGE_INTEGER   NetworkReadBytesRequested;

    LARGE_INTEGER   BytesTransmitted;
    LARGE_INTEGER   SmbsTransmitted;
    LARGE_INTEGER   PagingWriteBytesRequested;
    LARGE_INTEGER   NonPagingWriteBytesRequested;
    LARGE_INTEGER   CacheWriteBytesRequested;
    LARGE_INTEGER   NetworkWriteBytesRequested;

    DWORD           InitiallyFailedOperations;
    DWORD           FailedCompletionOperations;

    DWORD           ReadOperations;
    DWORD           RandomReadOperations;
    DWORD           ReadSmbs;
    DWORD           LargeReadSmbs;
    DWORD           SmallReadSmbs;

    DWORD           WriteOperations;
    DWORD           RandomWriteOperations;
    DWORD           WriteSmbs;
    DWORD           LargeWriteSmbs;
    DWORD           SmallWriteSmbs;

    DWORD           RawReadsDenied;
    DWORD           RawWritesDenied;

    DWORD           NetworkErrors;

    //  Connection/Session counts
    DWORD           Sessions;
    DWORD           FailedSessions;
    DWORD           Reconnects;
    DWORD           CoreConnects;
    DWORD           Lanman20Connects;
    DWORD           Lanman21Connects;
    DWORD           LanmanNtConnects;
    DWORD           ServerDisconnects;
    DWORD           HungSessions;
    DWORD           UseCount;
    DWORD           FailedUseCount;

    //
    //  Queue Lengths (updates protected by RdrMpxTableSpinLock NOT
    //  RdrStatisticsSpinlock)
    //

    DWORD           CurrentCommands;

} STAT_WORKSTATION_0, *PSTAT_WORKSTATION_0, *LPSTAT_WORKSTATION_0;
#endif

typedef struct _STAT_SERVER_0 {
     DWORD          sts0_start;
     DWORD          sts0_fopens;
     DWORD          sts0_devopens;
     DWORD          sts0_jobsqueued;
     DWORD          sts0_sopens;
     DWORD          sts0_stimedout;
     DWORD          sts0_serrorout;
     DWORD          sts0_pwerrors;
     DWORD          sts0_permerrors;
     DWORD          sts0_syserrors;
     DWORD          sts0_bytessent_low;
     DWORD          sts0_bytessent_high;
     DWORD          sts0_bytesrcvd_low;
     DWORD          sts0_bytesrcvd_high;
     DWORD          sts0_avresponse;
     DWORD          sts0_reqbufneed;
     DWORD          sts0_bigbufneed;
} STAT_SERVER_0, *PSTAT_SERVER_0, *LPSTAT_SERVER_0;


//
// Special Values and Constants
//

#define STATSOPT_CLR    1
#define STATS_NO_VALUE  ((unsigned long) -1L)
#define STATS_OVERFLOW  ((unsigned long) -2L)


#ifdef __cplusplus
}
#endif

#endif // _LMSTATS.H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMUseFlg.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmuseflg.h

Abstract:

    This file contains deletion force levels for deleting a connection.

Environment:

    User Mode - Win32

Notes:

    This file has no dependencies.  It is included by lmwksta.h and
    lmuse.h.

Revision History:

--*/

#ifndef _LMUSEFLG_
#define _LMUSEFLG_

#if _MSC_VER > 1000
#pragma once
#endif

//
// Definition for NetWkstaTransportDel and NetUseDel deletion force levels
//

#define USE_NOFORCE             0
#define USE_FORCE               1
#define USE_LOTS_OF_FORCE       2


#endif // _LMUSEFLG_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMSName.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmsname.h

Abstract:

    This file contains service name strings.  It is included by lmsvc.h.

Environment:

    User Mode -Win32


--*/

#ifndef _LMSNAME_
#define _LMSNAME_

#if _MSC_VER > 1000
#pragma once
#endif

//
//  Standard LAN Manager service names.
//

#define SERVICE_WORKSTATION       TEXT("LanmanWorkstation")
#define SERVICE_LM20_WORKSTATION  TEXT("WORKSTATION")
#define WORKSTATION_DISPLAY_NAME  TEXT("Workstation")

#define SERVICE_SERVER            TEXT("LanmanServer")
#define SERVICE_LM20_SERVER       TEXT("SERVER")
#define SERVER_DISPLAY_NAME       TEXT("Server")

#define SERVICE_BROWSER           TEXT("BROWSER")
#define SERVICE_LM20_BROWSER      SERVICE_BROWSER

#define SERVICE_MESSENGER         TEXT("MESSENGER")
#define SERVICE_LM20_MESSENGER    SERVICE_MESSENGER

#define SERVICE_NETRUN            TEXT("NETRUN")
#define SERVICE_LM20_NETRUN       SERVICE_NETRUN

#define SERVICE_SPOOLER           TEXT("SPOOLER")
#define SERVICE_LM20_SPOOLER      SERVICE_SPOOLER

#define SERVICE_ALERTER           TEXT("ALERTER")
#define SERVICE_LM20_ALERTER      SERVICE_ALERTER

#define SERVICE_NETLOGON          TEXT("NETLOGON")
#define SERVICE_LM20_NETLOGON     SERVICE_NETLOGON

#define SERVICE_NETPOPUP          TEXT("NETPOPUP")
#define SERVICE_LM20_NETPOPUP     SERVICE_NETPOPUP

#define SERVICE_SQLSERVER         TEXT("SQLSERVER")
#define SERVICE_LM20_SQLSERVER    SERVICE_SQLSERVER

#define SERVICE_REPL              TEXT("REPLICATOR")
#define SERVICE_LM20_REPL         SERVICE_REPL

#define SERVICE_RIPL              TEXT("REMOTEBOOT")
#define SERVICE_LM20_RIPL         SERVICE_RIPL

#define SERVICE_TIMESOURCE        TEXT("TIMESOURCE")
#define SERVICE_LM20_TIMESOURCE   SERVICE_TIMESOURCE

#define SERVICE_AFP               TEXT("AFP")
#define SERVICE_LM20_AFP          SERVICE_AFP

#define SERVICE_UPS               TEXT("UPS")
#define SERVICE_LM20_UPS          SERVICE_UPS

#define SERVICE_XACTSRV           TEXT("XACTSRV")
#define SERVICE_LM20_XACTSRV      SERVICE_XACTSRV

#define SERVICE_TCPIP             TEXT("TCPIP")
#define SERVICE_LM20_TCPIP        SERVICE_TCPIP

#define SERVICE_NBT               TEXT("NBT")
#define SERVICE_LM20_NBT          SERVICE_NBT

#define SERVICE_LMHOSTS           TEXT("LMHOSTS")
#define SERVICE_LM20_LMHOSTS      SERVICE_LMHOSTS

#define SERVICE_TELNET            TEXT("Telnet")
#define SERVICE_LM20_TELNET       SERVICE_TELNET

#define SERVICE_SCHEDULE          TEXT("Schedule")
#define SERVICE_LM20_SCHEDULE     SERVICE_SCHEDULE

#define SERVICE_NTLMSSP           TEXT("NtLmSsp")

#define SERVICE_DHCP              TEXT("DHCP")
#define SERVICE_LM20_DHCP         SERVICE_DHCP

#define SERVICE_NWSAP             TEXT("NwSapAgent")
#define SERVICE_LM20_NWSAP        SERVICE_NWSAP
#define NWSAP_DISPLAY_NAME        TEXT("NW Sap Agent")

#define SERVICE_NWCS              TEXT("NWCWorkstation")
#define SERVICE_DNS_CACHE         TEXT("DnsCache")

#define SERVICE_W32TIME           TEXT("w32time")
#define SERVCE_LM20_W32TIME       SERVICE_W32TIME

#define SERVICE_KDC               TEXT("kdc")
#define SERVICE_LM20_KDC          SERVICE_KDC

#define SERVICE_RPCLOCATOR        TEXT("RPCLOCATOR")
#define SERVICE_LM20_RPCLOCATOR   SERVICE_RPCLOCATOR

#define SERVICE_TRKSVR            TEXT("TrkSvr")
#define SERVICE_LM20_TRKSVR       SERVICE_TRKSVR

#define SERVICE_TRKWKS            TEXT("TrkWks")
#define SERVICE_LM20_TRKWKS       SERVICE_TRKWKS

#define SERVICE_NTFRS             TEXT("NtFrs")
#define SERVICE_LM20_NTFRS        SERVICE_NTFRS

#define SERVICE_ISMSERV           TEXT("IsmServ")
#define SERVICE_LM20_ISMSERV      SERVICE_ISMSERV

#define SERVICE_NTDS              TEXT("NTDS")
#define SERVICE_LM20_NTDS         SERVICE_NTDS

#define SERVICE_ADWS              TEXT("ADWS")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMUse.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmuse.c

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetUse API.


Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.


--*/

#ifndef _LMUSE_
#define _LMUSE_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>
#include <lmuseflg.h>                   // Deletion force level flags

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetUseAdd (
    __in_opt IN LMSTR  UncServerName OPTIONAL,
    IN DWORD Level,
    __inout IN LPBYTE Buf,
    __out_opt OUT LPDWORD ParmError OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetUseDel (
    __in_opt IN LMSTR  UncServerName OPTIONAL,
    __in IN LMSTR  UseName,
    IN DWORD ForceCond
    );

NET_API_STATUS NET_API_FUNCTION
NetUseEnum (
    __in_opt LMSTR  UncServerName,
    __in DWORD Level,
    __out_opt LPBYTE *BufPtr,
    __in DWORD PreferedMaximumSize,
    __out_opt LPDWORD EntriesRead,
    __out LPDWORD TotalEntries,
    __inout_opt LPDWORD ResumeHandle
    );

NET_API_STATUS NET_API_FUNCTION
NetUseGetInfo (
    __in_opt IN LMSTR  UncServerName OPTIONAL,
    __in IN LMSTR  UseName,
    IN DWORD Level,
    __out_opt OUT LPBYTE *BufPtr
    );

//
//  Data Structures
//

typedef struct _USE_INFO_0 {
    LMSTR   ui0_local;
    LMSTR   ui0_remote;
}USE_INFO_0, *PUSE_INFO_0, *LPUSE_INFO_0;

typedef struct _USE_INFO_1 {
    LMSTR   ui1_local;
    LMSTR   ui1_remote;
    LMSTR   ui1_password;
    DWORD   ui1_status;
    DWORD   ui1_asg_type;
    DWORD   ui1_refcount;
    DWORD   ui1_usecount;
}USE_INFO_1, *PUSE_INFO_1, *LPUSE_INFO_1;

typedef struct _USE_INFO_2 {
    LMSTR    ui2_local;
    LMSTR    ui2_remote;
    LMSTR    ui2_password;
    DWORD    ui2_status;
    DWORD    ui2_asg_type;
    DWORD    ui2_refcount;
    DWORD    ui2_usecount;
    LMSTR    ui2_username;
    LMSTR    ui2_domainname;
}USE_INFO_2, *PUSE_INFO_2, *LPUSE_INFO_2;

typedef struct _USE_INFO_3 {
    USE_INFO_2 ui3_ui2;
    ULONG      ui3_flags;
} USE_INFO_3, *PUSE_INFO_3, *LPUSE_INFO_3;

typedef struct _USE_INFO_4 {
    USE_INFO_3 ui4_ui3;
    DWORD      ui4_auth_identity_length;
    PBYTE      ui4_auth_identity;
} USE_INFO_4, *PUSE_INFO_4, *LPUSE_INFO_4;

//
// Special Values and Constants
//

//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetUseAdd.
//

#define USE_LOCAL_PARMNUM       1
#define USE_REMOTE_PARMNUM      2
#define USE_PASSWORD_PARMNUM    3
#define USE_ASGTYPE_PARMNUM     4
#define USE_USERNAME_PARMNUM    5
#define USE_DOMAINNAME_PARMNUM  6

//
// Values appearing in the ui1_status field of use_info_1 structure.
// Note that USE_SESSLOST and USE_DISCONN are synonyms.
//

#define USE_OK                  0
#define USE_PAUSED              1
#define USE_SESSLOST            2
#define USE_DISCONN             2
#define USE_NETERR              3
#define USE_CONN                4
#define USE_RECONN              5


//
// Values of the ui1_asg_type field of use_info_1 structure
//

#define USE_WILDCARD            ( (DWORD) (-1) )
#define USE_DISKDEV             0
#define USE_SPOOLDEV            1
#define USE_CHARDEV             2
#define USE_IPC                 3

//
// Flags defined in the use_info_3 structure
//

#define CREATE_NO_CONNECT 0x1        // creation flags
#define CREATE_BYPASS_CSC 0x2        // force connection to server, bypassing CSC
                                     //  all ops on this connection go to the server,
                                     //  never to the cache
#define CREATE_CRED_RESET 0x4	     // Create a connection with credentials passed in 
				     //  this netuse if none exist. If connection already 
				     //  exists then update credentials after issuing remote
				     //  tree connection. This is needed as CSC cannot verify 
				     //  credentials while offline.

#define USE_DEFAULT_CREDENTIALS 0x4  // No explicit credentials passed to NetUseAdd

#ifdef __cplusplus
}
#endif

#endif // _LMUSE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMSvc.h ===
/*++ BUILD Version: 0002    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmsvc.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetService API.

[Environment:]

    User Mode -Win32

[Notes:]

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMSVC_
#define _LMSVC_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Include the file which contains all the service name strings.
//
#include <lmsname.h>

//
//  Data Structures
//

typedef struct _SERVICE_INFO_0 {
    LPWSTR  svci0_name;
} SERVICE_INFO_0, *PSERVICE_INFO_0, * LPSERVICE_INFO_0;

typedef struct _SERVICE_INFO_1 {
    LPWSTR  svci1_name;
    DWORD   svci1_status;
    DWORD   svci1_code;
    DWORD   svci1_pid;
} SERVICE_INFO_1, *PSERVICE_INFO_1, * LPSERVICE_INFO_1;

typedef struct _SERVICE_INFO_2 {
    LPWSTR  svci2_name;
    DWORD   svci2_status;
    DWORD   svci2_code;
    DWORD   svci2_pid;
    LPWSTR  svci2_text;
    DWORD   svci2_specific_error;
    LPWSTR  svci2_display_name;
} SERVICE_INFO_2, *PSERVICE_INFO_2, * LPSERVICE_INFO_2;

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetServiceControl (
    __in_opt    LPCWSTR servername,
    __in        LPCWSTR service,
    __in        DWORD   opcode,
    __in        DWORD   arg,
    __deref_out LPBYTE *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServiceEnum (
    __in_opt    LPCWSTR  servername,
    __in        DWORD    level,
    __deref_out LPBYTE  *bufptr,
    __in        DWORD    prefmaxlen,
    __out       LPDWORD  entriesread,
    __out       LPDWORD  totalentries,
    __inout_opt LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetServiceGetInfo (
    __in_opt    LPCWSTR  servername,
    __in        LPCWSTR  service,
    __in        DWORD    level,
    __deref_out LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServiceInstall (
    __in_opt          LPCWSTR  servername,
    __in              LPCWSTR  service,
    __in              DWORD    argc,
    __in_ecount(argc) LPCWSTR  argv[],
    __deref_out       LPBYTE  *bufptr
    );

//
// Special Values and Constants
//

//
//  Bitmask and bit values for svci1_status, and svci2_status
//  fields.  For each "subfield", there is a mask defined,
//  and a number of constants representing the value
//  obtained by doing (status & mask).
//

// Bits 0,1 -- general status

#define SERVICE_INSTALL_STATE       0x03
#define SERVICE_UNINSTALLED         0x00
#define SERVICE_INSTALL_PENDING     0x01
#define SERVICE_UNINSTALL_PENDING   0x02
#define SERVICE_INSTALLED           0x03

// Bits 2,3 -- paused/active status

#define SERVICE_PAUSE_STATE              0x0C
#define LM20_SERVICE_ACTIVE              0x00
#define LM20_SERVICE_CONTINUE_PENDING    0x04
#define LM20_SERVICE_PAUSE_PENDING       0x08
#define LM20_SERVICE_PAUSED              0x0C

// Bit 4 -- uninstallable indication

#define SERVICE_NOT_UNINSTALLABLE   0x00
#define SERVICE_UNINSTALLABLE       0x10

// Bit 5 -- pausable indication

#define SERVICE_NOT_PAUSABLE        0x00
#define SERVICE_PAUSABLE            0x20

// Workstation service only:
// Bits 8,9,10 -- redirection paused/active

#define SERVICE_REDIR_PAUSED        0x700
#define SERVICE_REDIR_DISK_PAUSED   0x100
#define SERVICE_REDIR_PRINT_PAUSED  0x200
#define SERVICE_REDIR_COMM_PAUSED   0x400

//
//  Additional standard LAN Manager for MS-DOS services
//

#define SERVICE_DOS_ENCRYPTION  L"ENCRYPT"

//
//  NetServiceControl opcodes.
//

#define SERVICE_CTRL_INTERROGATE    0
#define SERVICE_CTRL_PAUSE          1
#define SERVICE_CTRL_CONTINUE       2
#define SERVICE_CTRL_UNINSTALL      3

//
//  Workstation service only:  Bits used in the "arg" parameter
//  to NetServiceControl in conjunction with the opcode
//  SERVICE_CTRL_PAUSE or SERVICE_CTRL_CONTINUE, to pause or
//  continue redirection.
//

#define SERVICE_CTRL_REDIR_DISK     0x1
#define SERVICE_CTRL_REDIR_PRINT    0x2
#define SERVICE_CTRL_REDIR_COMM     0x4

//
//  Values for svci1_code, and svci2_code when status
//  of the service is SERVICE_INSTALL_PENDING or
//  SERVICE_UNINSTALL_PENDING.
//  A service can optionally provide a hint to the installer
//  that the install is proceeding and how long to wait
//  (in 0.1 second increments) before querying status again.
//

#define SERVICE_IP_NO_HINT          0x0
#define SERVICE_CCP_NO_HINT         0x0

#define SERVICE_IP_QUERY_HINT       0x10000
#define SERVICE_CCP_QUERY_HINT      0x10000

//
// Mask for install proceeding checkpoint number
//

#define SERVICE_IP_CHKPT_NUM        0x0FF
#define SERVICE_CCP_CHKPT_NUM       0x0FF

//
// Mask for wait time hint before querying again
//

#define SERVICE_IP_WAIT_TIME        0x0FF00
#define SERVICE_CCP_WAIT_TIME       0x0FF00

//
// Shift count for building wait time _code values
//

#define SERVICE_IP_WAITTIME_SHIFT   8
#define SERVICE_NTIP_WAITTIME_SHIFT 12

//
// Mask used for upper and lower portions of wait hint time.
//
#define UPPER_HINT_MASK     0x0000FF00
#define LOWER_HINT_MASK     0x000000FF
#define UPPER_GET_HINT_MASK 0x0FF00000
#define LOWER_GET_HINT_MASK 0x0000FF00
#define SERVICE_NT_MAXTIME  0x0000FFFF
#define SERVICE_RESRV_MASK  0x0001FFFF
#define SERVICE_MAXTIME     0x000000FF

//
//  SERVICE_BASE is the base of service error codes,
//  chosen to avoid conflict with OS, redirector,
//  netapi, and errlog codes.
//
// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define SERVICE_BASE                3050
#define SERVICE_UIC_NORMAL          0
/*
 *  Uninstall codes, to be used in high byte of 'code' on final NetStatus,
 *  which sets the status to UNINSTALLED.
 */

#define SERVICE_UIC_BADPARMVAL          (SERVICE_BASE + 1)
/*
 * The Registry or the information you just typed includes an illegal
 * value for "%1".
 */

#define SERVICE_UIC_MISSPARM            (SERVICE_BASE + 2)
/*
 * The required parameter was not provided on the command
 * line or in the configuration file.
 */

#define SERVICE_UIC_UNKPARM             (SERVICE_BASE + 3)
/*
 * LAN Manager does not recognize "%1" as a valid option.
 */

#define SERVICE_UIC_RESOURCE            (SERVICE_BASE + 4)
/*
 * A request for resource could not be satisfied.
 */

#define SERVICE_UIC_CONFIG              (SERVICE_BASE + 5)
/*
 * A problem exists with the system configuration.
 */

#define SERVICE_UIC_SYSTEM              (SERVICE_BASE + 6)
/*
 * A system error has occurred.
 */

#define SERVICE_UIC_INTERNAL            (SERVICE_BASE + 7)
/*
 * An internal consistency error has occurred.
 */

#define SERVICE_UIC_AMBIGPARM           (SERVICE_BASE + 8)
/*
 * The configuration file or the command line has an ambiguous option.
 */

#define SERVICE_UIC_DUPPARM             (SERVICE_BASE + 9)
/*
 * The configuration file or the command line has a duplicate parameter.
 */

#define SERVICE_UIC_KILL                (SERVICE_BASE + 10)
/*
 * The service did not respond to control and was stopped with
 * the DosKillProc function.
 */

#define SERVICE_UIC_EXEC                (SERVICE_BASE + 11)
/*
 * An error occurred when attempting to run the service program.
 */

#define SERVICE_UIC_SUBSERV             (SERVICE_BASE + 12)
/*
 * The sub-service failed to start.
 */

#define SERVICE_UIC_CONFLPARM           (SERVICE_BASE + 13)
/*
 * There is a conflict in the value or use of these options: %1.
 */

#define SERVICE_UIC_FILE                (SERVICE_BASE + 14)
/*
 * There is a problem with the file.
 */



//
//  The modifiers
//

//
// General:
//

#define SERVICE_UIC_M_NULL  0

//
//  RESOURCE:
//

#define SERVICE_UIC_M_MEMORY    (SERVICE_BASE + 20)     /* memory */
#define SERVICE_UIC_M_DISK      (SERVICE_BASE + 21)     /* disk space */
#define SERVICE_UIC_M_THREADS   (SERVICE_BASE + 22)     /* thread */
#define SERVICE_UIC_M_PROCESSES (SERVICE_BASE + 23)     /* process */

//
//  CONFIG:
//

//
// Security failure
//

#define SERVICE_UIC_M_SECURITY          (SERVICE_BASE + 24)
/* Security Failure. %0 */

#define SERVICE_UIC_M_LANROOT           (SERVICE_BASE + 25)
/*
 * Bad or missing LAN Manager root directory.
 */

#define SERVICE_UIC_M_REDIR             (SERVICE_BASE + 26)
/*
 * The network software is not installed.
 */

#define SERVICE_UIC_M_SERVER            (SERVICE_BASE + 27)
/*
 * The server is not started.
 */

#define SERVICE_UIC_M_SEC_FILE_ERR      (SERVICE_BASE + 28)
/*
 * The server cannot access the user accounts database (NET.ACC).
 */

#define SERVICE_UIC_M_FILES             (SERVICE_BASE + 29)
/*
 * Incompatible files are installed in the LANMAN tree.
 */

#define SERVICE_UIC_M_LOGS              (SERVICE_BASE + 30)
/*
 * The LANMAN\LOGS directory is invalid.
 */

#define SERVICE_UIC_M_LANGROUP          (SERVICE_BASE + 31)
/*
 * The domain specified could not be used.
 */

#define SERVICE_UIC_M_MSGNAME           (SERVICE_BASE + 32)
/*
 * The computer name is being used as a message alias on another computer.
 */

#define SERVICE_UIC_M_ANNOUNCE          (SERVICE_BASE + 33)
/*
 * The announcement of the server name failed.
 */

#define SERVICE_UIC_M_UAS               (SERVICE_BASE + 34)
/*
 * The user accounts database is not configured correctly.
 */

#define SERVICE_UIC_M_SERVER_SEC_ERR    (SERVICE_BASE + 35)
/*
 * The server is not running with user-level security.
 */

#define SERVICE_UIC_M_WKSTA             (SERVICE_BASE + 37)
/*
 * The workstation is not configured properly.
 */

#define SERVICE_UIC_M_ERRLOG            (SERVICE_BASE + 38)
/*
 * View your error log for details.
 */

#define SERVICE_UIC_M_FILE_UW           (SERVICE_BASE + 39)
/*
 * Unable to write to this file.
 */

#define SERVICE_UIC_M_ADDPAK            (SERVICE_BASE + 40)
/*
 * ADDPAK file is corrupted.  Delete LANMAN\NETPROG\ADDPAK.SER
 * and reapply all ADDPAKs.
 */

#define SERVICE_UIC_M_LAZY              (SERVICE_BASE + 41)
/*
 * The LM386 server cannot be started because CACHE.EXE is not running.
 */

#define SERVICE_UIC_M_UAS_MACHINE_ACCT  (SERVICE_BASE + 42)
/*
 * There is no account for this computer in the security database.
 */

#define SERVICE_UIC_M_UAS_SERVERS_NMEMB (SERVICE_BASE + 43)
/*
 * This computer is not a member of the group SERVERS.
 */

#define SERVICE_UIC_M_UAS_SERVERS_NOGRP (SERVICE_BASE + 44)
/*
 * The group SERVERS is not present in the local security database.
 */

#define SERVICE_UIC_M_UAS_INVALID_ROLE  (SERVICE_BASE + 45)
/*
 * This computer is configured as a member of a workgroup, not as
 * a member of a domain. The Netlogon service does not need to run in this
 * configuration.
 */

#define SERVICE_UIC_M_NETLOGON_NO_DC    (SERVICE_BASE + 46)
/*
 * The primary Domain Controller for this domain could not be located.
 */

#define SERVICE_UIC_M_NETLOGON_DC_CFLCT (SERVICE_BASE + 47)
/*
 * This computer is configured to be the primary domain controller of its domain.
 * However, the computer %1 is currently claiming to be the primary domain controller
 * of the domain.
 */

#define SERVICE_UIC_M_NETLOGON_AUTH     (SERVICE_BASE + 48)
/*
 * The service failed to authenticate with the primary domain controller.
 */

#define SERVICE_UIC_M_UAS_PROLOG        (SERVICE_BASE + 49)
/*
 * There is a problem with the security database creation date or serial number.
 */


#define SERVICE2_BASE    5600
/* new SEVICE_UIC messages go here */

#define SERVICE_UIC_M_NETLOGON_MPATH    (SERVICE2_BASE + 0)
/*
 * Could not share the User or Script path.
 */

#define SERVICE_UIC_M_LSA_MACHINE_ACCT  (SERVICE2_BASE + 1)
/*
 * The password for this computer is not found in the local security
 * database.
 */

#define SERVICE_UIC_M_DATABASE_ERROR    (SERVICE2_BASE + 2)
/*
 * An internal error occurred while accessing the computer's
 * local or network security database.
 */


//
//  End modifiers
//

//
// Commonly used Macros:
//

#define SERVICE_IP_CODE(tt,nn) \
  ((long)SERVICE_IP_QUERY_HINT|(long)(nn|(tt<<SERVICE_IP_WAITTIME_SHIFT)))

#define SERVICE_CCP_CODE(tt,nn) \
  ((long)SERVICE_CCP_QUERY_HINT|(long)(nn|(tt<<SERVICE_IP_WAITTIME_SHIFT)))

#define SERVICE_UIC_CODE(cc,mm) \
  ((long)(((long)cc<<16)|(long)(unsigned short)mm))

//
// This macro takes a wait hint (tt) which can have a maximum value of
// 0xFFFF and puts it into the service status code field.
// 0x0FF1FFnn  (where nn is the checkpoint information).
//
#define SERVICE_NT_CCP_CODE(tt,nn)  \
  (  \
    ((long)SERVICE_CCP_QUERY_HINT)   | \
    ((long)(nn))   | \
    (((tt)&LOWER_HINT_MASK) << SERVICE_IP_WAITTIME_SHIFT)   | \
    (((tt)&UPPER_HINT_MASK) << SERVICE_NTIP_WAITTIME_SHIFT)   \
  )

//
// This macro takes a status code field, and strips out the wait hint
// from the upper and lower sections.
// 0x0FF1FFnn results in 0x0000FFFF.
//
#define SERVICE_NT_WAIT_GET(code) \
    (   \
      (((code) & UPPER_GET_HINT_MASK) >> SERVICE_NTIP_WAITTIME_SHIFT)  |  \
      (((code) & LOWER_GET_HINT_MASK) >> SERVICE_IP_WAITTIME_SHIFT)  \
    )

#ifdef __cplusplus
}
#endif

#endif // _LMSVC_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMRepl.h ===
/*++ BUILD Version: 0004    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    LmRepl.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the replicator APIs.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include LmCons.h before this file.


--*/

#ifndef _LMREPL_
#define _LMREPL_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Replicator Configuration APIs
//

#define REPL_ROLE_EXPORT        1
#define REPL_ROLE_IMPORT        2
#define REPL_ROLE_BOTH          3


#define REPL_INTERVAL_INFOLEVEL         (PARMNUM_BASE_INFOLEVEL + 0)
#define REPL_PULSE_INFOLEVEL            (PARMNUM_BASE_INFOLEVEL + 1)
#define REPL_GUARDTIME_INFOLEVEL        (PARMNUM_BASE_INFOLEVEL + 2)
#define REPL_RANDOM_INFOLEVEL           (PARMNUM_BASE_INFOLEVEL + 3)


typedef struct _REPL_INFO_0 {
    DWORD          rp0_role;
    LPWSTR         rp0_exportpath;
    LPWSTR         rp0_exportlist;
    LPWSTR         rp0_importpath;
    LPWSTR         rp0_importlist;
    LPWSTR         rp0_logonusername;
    DWORD          rp0_interval;
    DWORD          rp0_pulse;
    DWORD          rp0_guardtime;
    DWORD          rp0_random;
} REPL_INFO_0, *PREPL_INFO_0, *LPREPL_INFO_0;

typedef struct _REPL_INFO_1000 {
    DWORD          rp1000_interval;
} REPL_INFO_1000, *PREPL_INFO_1000, *LPREPL_INFO_1000;

typedef struct _REPL_INFO_1001 {
    DWORD          rp1001_pulse;
} REPL_INFO_1001, *PREPL_INFO_1001, *LPREPL_INFO_1001;

typedef struct _REPL_INFO_1002 {
    DWORD          rp1002_guardtime;
} REPL_INFO_1002, *PREPL_INFO_1002, *LPREPL_INFO_1002;

typedef struct _REPL_INFO_1003 {
    DWORD          rp1003_random;
} REPL_INFO_1003, *PREPL_INFO_1003, *LPREPL_INFO_1003;


NET_API_STATUS NET_API_FUNCTION
NetReplGetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplSetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    IN const LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );


//
// Replicator Export Directory APIs
//

#define REPL_INTEGRITY_FILE     1
#define REPL_INTEGRITY_TREE     2


#define REPL_EXTENT_FILE        1
#define REPL_EXTENT_TREE        2


#define REPL_EXPORT_INTEGRITY_INFOLEVEL (PARMNUM_BASE_INFOLEVEL + 0)
#define REPL_EXPORT_EXTENT_INFOLEVEL    (PARMNUM_BASE_INFOLEVEL + 1)


typedef struct _REPL_EDIR_INFO_0 {
    LPWSTR         rped0_dirname;
} REPL_EDIR_INFO_0, *PREPL_EDIR_INFO_0, *LPREPL_EDIR_INFO_0;

typedef struct _REPL_EDIR_INFO_1 {
    LPWSTR         rped1_dirname;
    DWORD          rped1_integrity;
    DWORD          rped1_extent;
} REPL_EDIR_INFO_1, *PREPL_EDIR_INFO_1, *LPREPL_EDIR_INFO_1;

typedef struct _REPL_EDIR_INFO_2 {
    LPWSTR         rped2_dirname;
    DWORD          rped2_integrity;
    DWORD          rped2_extent;
    DWORD          rped2_lockcount;
    DWORD          rped2_locktime;
} REPL_EDIR_INFO_2, *PREPL_EDIR_INFO_2, *LPREPL_EDIR_INFO_2;

typedef struct _REPL_EDIR_INFO_1000 {
    DWORD          rped1000_integrity;
} REPL_EDIR_INFO_1000, *PREPL_EDIR_INFO_1000, *LPREPL_EDIR_INFO_1000;

typedef struct _REPL_EDIR_INFO_1001 {
    DWORD          rped1001_extent;
} REPL_EDIR_INFO_1001, *PREPL_EDIR_INFO_1001, *LPREPL_EDIR_INFO_1001;


NET_API_STATUS NET_API_FUNCTION
NetReplExportDirAdd (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    IN const LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirDel (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirEnum (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirGetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirSetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD level,
    IN const LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirLock (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplExportDirUnlock (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD unlockforce
    );


#define REPL_UNLOCK_NOFORCE     0
#define REPL_UNLOCK_FORCE       1


//
// Replicator Import Directory APIs
//


typedef struct _REPL_IDIR_INFO_0 {
    LPWSTR         rpid0_dirname;
} REPL_IDIR_INFO_0, *PREPL_IDIR_INFO_0, *LPREPL_IDIR_INFO_0;

typedef struct _REPL_IDIR_INFO_1 {
    LPWSTR         rpid1_dirname;
    DWORD          rpid1_state;
    LPWSTR         rpid1_mastername;
    DWORD          rpid1_last_update_time;
    DWORD          rpid1_lockcount;
    DWORD          rpid1_locktime;
} REPL_IDIR_INFO_1, *PREPL_IDIR_INFO_1, *LPREPL_IDIR_INFO_1;


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirAdd (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    IN const LPBYTE buf,
    OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirDel (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirEnum (
    IN LPCWSTR servername OPTIONAL,
    IN DWORD level,
    OUT LPBYTE * bufptr,
    IN DWORD prefmaxlen,
    OUT LPDWORD entriesread,
    OUT LPDWORD totalentries,
    IN OUT LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirGetInfo (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD level,
    OUT LPBYTE * bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetReplImportDirLock (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname
    );


NET_API_STATUS NET_API_FUNCTION
NetReplImportDirUnlock (
    IN LPCWSTR servername OPTIONAL,
    IN LPCWSTR dirname,
    IN DWORD unlockforce
    );


#define REPL_STATE_OK                   0
#define REPL_STATE_NO_MASTER            1
#define REPL_STATE_NO_SYNC              2
#define REPL_STATE_NEVER_REPLICATED     3


#ifdef __cplusplus
}
#endif

#endif //_LMREPL_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMServer.h ===
/*++ BUILD VERSION: 0007    // INCREMENT THIS IF A CHANGE HAS GLOBAL EFFECTS

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    lmserver.h

Abstract:

    This file contains information about NetServer APIs.
        Function Prototypes
        Data Structures
        Definition of special values

Environment:

    User Mode - Win32

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMSERVER_
#define _LMSERVER_

#if _MSC_VER > 1000
#pragma once
#endif

#include <winsvc.h>     // SERVICE_STATUS_HANDLE

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>

//
// Function Prototypes - SERVER
//

NET_API_STATUS NET_API_FUNCTION
NetServerEnum (
    __in_opt IN  LMCSTR      servername OPTIONAL,
    __in IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    __in IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    __in IN  DWORD       servertype,
    __in_opt IN  LMCSTR      domain OPTIONAL,
    __out_opt IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetServerEnumEx (
    __in_opt IN  LMCSTR      ServerName OPTIONAL,
    __in IN  DWORD       Level,
    __deref_out OUT LPBYTE      *Bufptr,
    __in IN  DWORD       PrefMaxlen,
    __out OUT LPDWORD     EntriesRead,
    __out OUT LPDWORD     totalentries,
    __in IN  DWORD       servertype,
    __in_opt IN  LMCSTR      domain OPTIONAL,
    __in_opt IN  LMCSTR      FirstNameToReturn OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetServerGetInfo (
    __in_opt IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    __out OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerSetInfo (
    __in_opt IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buf,
    __out_opt OUT LPDWORD ParmError OPTIONAL
    );

//
// Temporary hack function.
//

NET_API_STATUS
NetServerSetInfoCommandLine (
    __in WORD argc,
    __in_ecount(argc) LMSTR  argv[]
    );

NET_API_STATUS NET_API_FUNCTION
NetServerDiskEnum (
    __in_opt IN  LMSTR       servername OPTIONAL,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetServerComputerNameAdd(
    __in_opt IN LMSTR  ServerName         OPTIONAL,
    __in_opt IN LMSTR  EmulatedDomainName OPTIONAL,
    __in IN LMSTR  EmulatedServerName
);

NET_API_STATUS NET_API_FUNCTION
NetServerComputerNameDel (
    __in_opt IN LMSTR  ServerName        OPTIONAL,
    __in IN LMSTR  EmulatedServerName
);

NET_API_STATUS NET_API_FUNCTION
NetServerTransportAdd (
    __in_opt IN  LMSTR   servername,
    IN  DWORD   level,
    __in_bcount(sizeof(SERVER_TRANSPORT_INFO_0)) IN  LPBYTE  bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerTransportAddEx (
    __in_opt IN  LMSTR   servername      OPTIONAL,
    IN  DWORD   level,
    __in IN  LPBYTE  bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerTransportDel (
    __in_opt LMSTR   servername,
    __in  DWORD   level,
    __in_xcount(level == 0 ? sizeof(SERVER_TRANSPORT_INFO_0) : sizeof(SERVER_TRANSPORT_INFO_1)) LPBYTE  bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetServerTransportEnum (
    __in_opt IN  LMSTR       servername,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    __inout_opt IN OUT LPDWORD  resumehandle
    );

//
// The following function can be called by Win NT services to register
// their service type.  This function is exported from advapi32.dll.
// Therefore, if this is the only function called by that service, then
// it is not necessary to link to netapi32.lib.
//
BOOL NET_API_FUNCTION
SetServiceBits(
    IN SERVICE_STATUS_HANDLE    hServiceStatus,
    IN DWORD                    dwServiceBits,
    IN BOOL                     bSetBitsOn,
    IN BOOL                     bUpdateImmediately
    );

//
// Data Structures - SERVER
//

typedef struct _SERVER_INFO_100 {
    DWORD           sv100_platform_id;
    LMSTR           sv100_name;
} SERVER_INFO_100, *PSERVER_INFO_100, *LPSERVER_INFO_100;

typedef struct _SERVER_INFO_101 {
    DWORD           sv101_platform_id;
    LMSTR           sv101_name;
    DWORD           sv101_version_major;
    DWORD           sv101_version_minor;
    DWORD           sv101_type;
    LMSTR           sv101_comment;
} SERVER_INFO_101, *PSERVER_INFO_101, *LPSERVER_INFO_101;

typedef struct _SERVER_INFO_102 {
     DWORD          sv102_platform_id;
     LMSTR          sv102_name;
     DWORD          sv102_version_major;
     DWORD          sv102_version_minor;
     DWORD          sv102_type;
     LMSTR          sv102_comment;
     DWORD          sv102_users;
     LONG           sv102_disc;
     BOOL           sv102_hidden;
     DWORD          sv102_announce;
     DWORD          sv102_anndelta;
     DWORD          sv102_licenses;
     LMSTR          sv102_userpath;
} SERVER_INFO_102, *PSERVER_INFO_102, *LPSERVER_INFO_102;

typedef struct _SERVER_INFO_103 {
     DWORD          sv103_platform_id;
     LMSTR          sv103_name;
     DWORD          sv103_version_major;
     DWORD          sv103_version_minor;
     DWORD          sv103_type;
     LMSTR          sv103_comment;
     DWORD          sv103_users;
     LONG           sv103_disc;
     BOOL           sv103_hidden;
     DWORD          sv103_announce;
     DWORD          sv103_anndelta;
     DWORD          sv103_licenses;
     LMSTR          sv103_userpath;
     DWORD          sv103_capabilities;
} SERVER_INFO_103, *PSERVER_INFO_103, *LPSERVER_INFO_103;

typedef struct _SERVER_INFO_402 {
     DWORD          sv402_ulist_mtime;
     DWORD          sv402_glist_mtime;
     DWORD          sv402_alist_mtime;
     LMSTR          sv402_alerts;
     DWORD          sv402_security;
     DWORD          sv402_numadmin;
     DWORD          sv402_lanmask;
     LMSTR          sv402_guestacct;
     DWORD          sv402_chdevs;
     DWORD          sv402_chdevq;
     DWORD          sv402_chdevjobs;
     DWORD          sv402_connections;
     DWORD          sv402_shares;
     DWORD          sv402_openfiles;
     DWORD          sv402_sessopens;
     DWORD          sv402_sessvcs;
     DWORD          sv402_sessreqs;
     DWORD          sv402_opensearch;
     DWORD          sv402_activelocks;
     DWORD          sv402_numreqbuf;
     DWORD          sv402_sizreqbuf;
     DWORD          sv402_numbigbuf;
     DWORD          sv402_numfiletasks;
     DWORD          sv402_alertsched;
     DWORD          sv402_erroralert;
     DWORD          sv402_logonalert;
     DWORD          sv402_accessalert;
     DWORD          sv402_diskalert;
     DWORD          sv402_netioalert;
     DWORD          sv402_maxauditsz;
     LMSTR          sv402_srvheuristics;
} SERVER_INFO_402, *PSERVER_INFO_402, *LPSERVER_INFO_402;

typedef struct _SERVER_INFO_403 {
     DWORD          sv403_ulist_mtime;
     DWORD          sv403_glist_mtime;
     DWORD          sv403_alist_mtime;
     LMSTR          sv403_alerts;
     DWORD          sv403_security;
     DWORD          sv403_numadmin;
     DWORD          sv403_lanmask;
     LMSTR          sv403_guestacct;
     DWORD          sv403_chdevs;
     DWORD          sv403_chdevq;
     DWORD          sv403_chdevjobs;
     DWORD          sv403_connections;
     DWORD          sv403_shares;
     DWORD          sv403_openfiles;
     DWORD          sv403_sessopens;
     DWORD          sv403_sessvcs;
     DWORD          sv403_sessreqs;
     DWORD          sv403_opensearch;
     DWORD          sv403_activelocks;
     DWORD          sv403_numreqbuf;
     DWORD          sv403_sizreqbuf;
     DWORD          sv403_numbigbuf;
     DWORD          sv403_numfiletasks;
     DWORD          sv403_alertsched;
     DWORD          sv403_erroralert;
     DWORD          sv403_logonalert;
     DWORD          sv403_accessalert;
     DWORD          sv403_diskalert;
     DWORD          sv403_netioalert;
     DWORD          sv403_maxauditsz;
     LMSTR          sv403_srvheuristics;
     DWORD          sv403_auditedevents;
     DWORD          sv403_autoprofile;
     LMSTR          sv403_autopath;
} SERVER_INFO_403, *PSERVER_INFO_403, *LPSERVER_INFO_403;

typedef struct _SERVER_INFO_502 {
    DWORD           sv502_sessopens;
    DWORD           sv502_sessvcs;
    DWORD           sv502_opensearch;
    DWORD           sv502_sizreqbuf;
    DWORD           sv502_initworkitems;
    DWORD           sv502_maxworkitems;
    DWORD           sv502_rawworkitems;
    DWORD           sv502_irpstacksize;
    DWORD           sv502_maxrawbuflen;
    DWORD           sv502_sessusers;
    DWORD           sv502_sessconns;
    DWORD           sv502_maxpagedmemoryusage;
    DWORD           sv502_maxnonpagedmemoryusage;
    BOOL            sv502_enablesoftcompat;
    BOOL            sv502_enableforcedlogoff;
    BOOL            sv502_timesource;
    BOOL            sv502_acceptdownlevelapis;
    BOOL            sv502_lmannounce;
} SERVER_INFO_502, *PSERVER_INFO_502, *LPSERVER_INFO_502;

typedef struct _SERVER_INFO_503 {
    DWORD           sv503_sessopens;
    DWORD           sv503_sessvcs;
    DWORD           sv503_opensearch;
    DWORD           sv503_sizreqbuf;
    DWORD           sv503_initworkitems;
    DWORD           sv503_maxworkitems;
    DWORD           sv503_rawworkitems;
    DWORD           sv503_irpstacksize;
    DWORD           sv503_maxrawbuflen;
    DWORD           sv503_sessusers;
    DWORD           sv503_sessconns;
    DWORD           sv503_maxpagedmemoryusage;
    DWORD           sv503_maxnonpagedmemoryusage;
    BOOL            sv503_enablesoftcompat;
    BOOL            sv503_enableforcedlogoff;
    BOOL            sv503_timesource;
    BOOL            sv503_acceptdownlevelapis;
    BOOL            sv503_lmannounce;
    LMSTR           sv503_domain;
    DWORD           sv503_maxcopyreadlen;
    DWORD           sv503_maxcopywritelen;
    DWORD           sv503_minkeepsearch;
    DWORD           sv503_maxkeepsearch;
    DWORD           sv503_minkeepcomplsearch;
    DWORD           sv503_maxkeepcomplsearch;
    DWORD           sv503_threadcountadd;
    DWORD           sv503_numblockthreads;
    DWORD           sv503_scavtimeout;
    DWORD           sv503_minrcvqueue;
    DWORD           sv503_minfreeworkitems;
    DWORD           sv503_xactmemsize;
    DWORD           sv503_threadpriority;
    DWORD           sv503_maxmpxct;
    DWORD           sv503_oplockbreakwait;
    DWORD           sv503_oplockbreakresponsewait;
    BOOL            sv503_enableoplocks;
    BOOL            sv503_enableoplockforceclose;
    BOOL            sv503_enablefcbopens;
    BOOL            sv503_enableraw;
    BOOL            sv503_enablesharednetdrives;
    DWORD           sv503_minfreeconnections;
    DWORD           sv503_maxfreeconnections;
} SERVER_INFO_503, *PSERVER_INFO_503, *LPSERVER_INFO_503;

typedef struct _SERVER_INFO_599 {
    DWORD           sv599_sessopens;
    DWORD           sv599_sessvcs;
    DWORD           sv599_opensearch;
    DWORD           sv599_sizreqbuf;
    DWORD           sv599_initworkitems;
    DWORD           sv599_maxworkitems;
    DWORD           sv599_rawworkitems;
    DWORD           sv599_irpstacksize;
    DWORD           sv599_maxrawbuflen;
    DWORD           sv599_sessusers;
    DWORD           sv599_sessconns;
    DWORD           sv599_maxpagedmemoryusage;
    DWORD           sv599_maxnonpagedmemoryusage;
    BOOL            sv599_enablesoftcompat;
    BOOL            sv599_enableforcedlogoff;
    BOOL            sv599_timesource;
    BOOL            sv599_acceptdownlevelapis;
    BOOL            sv599_lmannounce;
    LMSTR           sv599_domain;
    DWORD           sv599_maxcopyreadlen;
    DWORD           sv599_maxcopywritelen;
    DWORD           sv599_minkeepsearch;
    DWORD           sv599_maxkeepsearch;
    DWORD           sv599_minkeepcomplsearch;
    DWORD           sv599_maxkeepcomplsearch;
    DWORD           sv599_threadcountadd;
    DWORD           sv599_numblockthreads;
    DWORD           sv599_scavtimeout;
    DWORD           sv599_minrcvqueue;
    DWORD           sv599_minfreeworkitems;
    DWORD           sv599_xactmemsize;
    DWORD           sv599_threadpriority;
    DWORD           sv599_maxmpxct;
    DWORD           sv599_oplockbreakwait;
    DWORD           sv599_oplockbreakresponsewait;
    BOOL            sv599_enableoplocks;
    BOOL            sv599_enableoplockforceclose;
    BOOL            sv599_enablefcbopens;
    BOOL            sv599_enableraw;
    BOOL            sv599_enablesharednetdrives;
    DWORD           sv599_minfreeconnections;
    DWORD           sv599_maxfreeconnections;
    DWORD           sv599_initsesstable;
    DWORD           sv599_initconntable;
    DWORD           sv599_initfiletable;
    DWORD           sv599_initsearchtable;
    DWORD           sv599_alertschedule;
    DWORD           sv599_errorthreshold;
    DWORD           sv599_networkerrorthreshold;
    DWORD           sv599_diskspacethreshold;
    DWORD           sv599_reserved;
    DWORD           sv599_maxlinkdelay;
    DWORD           sv599_minlinkthroughput;
    DWORD           sv599_linkinfovalidtime;
    DWORD           sv599_scavqosinfoupdatetime;
    DWORD           sv599_maxworkitemidletime;
} SERVER_INFO_599, *PSERVER_INFO_599, *LPSERVER_INFO_599;

typedef struct _SERVER_INFO_598 {
    DWORD           sv598_maxrawworkitems;
    DWORD           sv598_maxthreadsperqueue;
    DWORD           sv598_producttype;
    DWORD           sv598_serversize;
    DWORD           sv598_connectionlessautodisc;
    DWORD           sv598_sharingviolationretries;
    DWORD           sv598_sharingviolationdelay;
    DWORD           sv598_maxglobalopensearch;
    DWORD           sv598_removeduplicatesearches;
    DWORD           sv598_lockviolationoffset;
    DWORD           sv598_lockviolationdelay;
    DWORD           sv598_mdlreadswitchover;
    DWORD           sv598_cachedopenlimit;
    DWORD           sv598_otherqueueaffinity;
    BOOL            sv598_restrictnullsessaccess;
    BOOL            sv598_enablewfw311directipx;
    DWORD           sv598_queuesamplesecs;
    DWORD           sv598_balancecount;
    DWORD           sv598_preferredaffinity;
    DWORD           sv598_maxfreerfcbs;
    DWORD           sv598_maxfreemfcbs;
    DWORD           sv598_maxfreelfcbs;
    DWORD           sv598_maxfreepagedpoolchunks;
    DWORD           sv598_minpagedpoolchunksize;
    DWORD           sv598_maxpagedpoolchunksize;
    BOOL            sv598_sendsfrompreferredprocessor;
    DWORD           sv598_cacheddirectorylimit;
    DWORD           sv598_maxcopylength;
    BOOL            sv598_enablecompression;
    BOOL            sv598_autosharewks;
    BOOL            sv598_autoshareserver;
    BOOL            sv598_enablesecuritysignature;
    BOOL            sv598_requiresecuritysignature;
    DWORD           sv598_minclientbuffersize;
    GUID            sv598_serverguid;
    DWORD           sv598_ConnectionNoSessionsTimeout;
    DWORD           sv598_IdleThreadTimeOut;
    BOOL            sv598_enableW9xsecuritysignature;
    BOOL            sv598_enforcekerberosreauthentication;
    BOOL            sv598_disabledos;
    DWORD           sv598_lowdiskspaceminimum;
    BOOL            sv598_disablestrictnamechecking;
    BOOL            sv598_enableauthenticateusersharing;
} SERVER_INFO_598, *PSERVER_INFO_598, *LPSERVER_INFO_598;

typedef struct _SERVER_INFO_1005 {
    LMSTR           sv1005_comment;
} SERVER_INFO_1005, *PSERVER_INFO_1005, *LPSERVER_INFO_1005;

typedef struct _SERVER_INFO_1107 {
    DWORD           sv1107_users;
} SERVER_INFO_1107, *PSERVER_INFO_1107, *LPSERVER_INFO_1107;

typedef struct _SERVER_INFO_1010 {
    LONG            sv1010_disc;
} SERVER_INFO_1010, *PSERVER_INFO_1010, *LPSERVER_INFO_1010;

typedef struct _SERVER_INFO_1016 {
    BOOL            sv1016_hidden;
} SERVER_INFO_1016, *PSERVER_INFO_1016, *LPSERVER_INFO_1016;

typedef struct _SERVER_INFO_1017 {
    DWORD           sv1017_announce;
} SERVER_INFO_1017, *PSERVER_INFO_1017, *LPSERVER_INFO_1017;

typedef struct _SERVER_INFO_1018 {
    DWORD           sv1018_anndelta;
} SERVER_INFO_1018, *PSERVER_INFO_1018, *LPSERVER_INFO_1018;

typedef struct _SERVER_INFO_1501 {
    DWORD           sv1501_sessopens;
} SERVER_INFO_1501, *PSERVER_INFO_1501, *LPSERVER_INFO_1501;

typedef struct _SERVER_INFO_1502 {
    DWORD           sv1502_sessvcs;
} SERVER_INFO_1502, *PSERVER_INFO_1502, *LPSERVER_INFO_1502;

typedef struct _SERVER_INFO_1503 {
    DWORD           sv1503_opensearch;
} SERVER_INFO_1503, *PSERVER_INFO_1503, *LPSERVER_INFO_1503;

typedef struct _SERVER_INFO_1506 {
    DWORD           sv1506_maxworkitems;
} SERVER_INFO_1506, *PSERVER_INFO_1506, *LPSERVER_INFO_1506;

typedef struct _SERVER_INFO_1509 {
    DWORD           sv1509_maxrawbuflen;
} SERVER_INFO_1509, *PSERVER_INFO_1509, *LPSERVER_INFO_1509;

typedef struct _SERVER_INFO_1510 {
    DWORD           sv1510_sessusers;
} SERVER_INFO_1510, *PSERVER_INFO_1510, *LPSERVER_INFO_1510;

typedef struct _SERVER_INFO_1511 {
    DWORD           sv1511_sessconns;
} SERVER_INFO_1511, *PSERVER_INFO_1511, *LPSERVER_INFO_1511;

typedef struct _SERVER_INFO_1512 {
    DWORD           sv1512_maxnonpagedmemoryusage;
} SERVER_INFO_1512, *PSERVER_INFO_1512, *LPSERVER_INFO_1512;

typedef struct _SERVER_INFO_1513 {
    DWORD           sv1513_maxpagedmemoryusage;
} SERVER_INFO_1513, *PSERVER_INFO_1513, *LPSERVER_INFO_1513;

typedef struct _SERVER_INFO_1514 {
    BOOL            sv1514_enablesoftcompat;
} SERVER_INFO_1514, *PSERVER_INFO_1514, *LPSERVER_INFO_1514;

typedef struct _SERVER_INFO_1515 {
    BOOL            sv1515_enableforcedlogoff;
} SERVER_INFO_1515, *PSERVER_INFO_1515, *LPSERVER_INFO_1515;

typedef struct _SERVER_INFO_1516 {
    BOOL            sv1516_timesource;
} SERVER_INFO_1516, *PSERVER_INFO_1516, *LPSERVER_INFO_1516;

typedef struct _SERVER_INFO_1518 {
    BOOL            sv1518_lmannounce;
} SERVER_INFO_1518, *PSERVER_INFO_1518, *LPSERVER_INFO_1518;

typedef struct _SERVER_INFO_1520 {
    DWORD           sv1520_maxcopyreadlen;
} SERVER_INFO_1520, *PSERVER_INFO_1520, *LPSERVER_INFO_1520;

typedef struct _SERVER_INFO_1521 {
    DWORD           sv1521_maxcopywritelen;
} SERVER_INFO_1521, *PSERVER_INFO_1521, *LPSERVER_INFO_1521;

typedef struct _SERVER_INFO_1522 {
    DWORD           sv1522_minkeepsearch;
} SERVER_INFO_1522, *PSERVER_INFO_1522, *LPSERVER_INFO_1522;

typedef struct _SERVER_INFO_1523 {
    DWORD           sv1523_maxkeepsearch;
} SERVER_INFO_1523, *PSERVER_INFO_1523, *LPSERVER_INFO_1523;

typedef struct _SERVER_INFO_1524 {
    DWORD           sv1524_minkeepcomplsearch;
} SERVER_INFO_1524, *PSERVER_INFO_1524, *LPSERVER_INFO_1524;

typedef struct _SERVER_INFO_1525 {
    DWORD           sv1525_maxkeepcomplsearch;
} SERVER_INFO_1525, *PSERVER_INFO_1525, *LPSERVER_INFO_1525;

typedef struct _SERVER_INFO_1528 {
    DWORD           sv1528_scavtimeout;
} SERVER_INFO_1528, *PSERVER_INFO_1528, *LPSERVER_INFO_1528;

typedef struct _SERVER_INFO_1529 {
    DWORD           sv1529_minrcvqueue;
} SERVER_INFO_1529, *PSERVER_INFO_1529, *LPSERVER_INFO_1529;

typedef struct _SERVER_INFO_1530 {
    DWORD           sv1530_minfreeworkitems;
} SERVER_INFO_1530, *PSERVER_INFO_1530, *LPSERVER_INFO_1530;

typedef struct _SERVER_INFO_1533 {
    DWORD           sv1533_maxmpxct;
} SERVER_INFO_1533, *PSERVER_INFO_1533, *LPSERVER_INFO_1533;

typedef struct _SERVER_INFO_1534 {
    DWORD           sv1534_oplockbreakwait;
} SERVER_INFO_1534, *PSERVER_INFO_1534, *LPSERVER_INFO_1534;

typedef struct _SERVER_INFO_1535 {
    DWORD           sv1535_oplockbreakresponsewait;
} SERVER_INFO_1535, *PSERVER_INFO_1535, *LPSERVER_INFO_1535;

typedef struct _SERVER_INFO_1536 {
    BOOL            sv1536_enableoplocks;
} SERVER_INFO_1536, *PSERVER_INFO_1536, *LPSERVER_INFO_1536;

typedef struct _SERVER_INFO_1537 {
    BOOL            sv1537_enableoplockforceclose;
} SERVER_INFO_1537, *PSERVER_INFO_1537, *LPSERVER_INFO_1537;

typedef struct _SERVER_INFO_1538 {
    BOOL            sv1538_enablefcbopens;
} SERVER_INFO_1538, *PSERVER_INFO_1538, *LPSERVER_INFO_1538;

typedef struct _SERVER_INFO_1539 {
    BOOL            sv1539_enableraw;
} SERVER_INFO_1539, *PSERVER_INFO_1539, *LPSERVER_INFO_1539;

typedef struct _SERVER_INFO_1540 {
    BOOL            sv1540_enablesharednetdrives;
} SERVER_INFO_1540, *PSERVER_INFO_1540, *LPSERVER_INFO_1540;

typedef struct _SERVER_INFO_1541 {
    BOOL            sv1541_minfreeconnections;
} SERVER_INFO_1541, *PSERVER_INFO_1541, *LPSERVER_INFO_1541;

typedef struct _SERVER_INFO_1542 {
    BOOL            sv1542_maxfreeconnections;
} SERVER_INFO_1542, *PSERVER_INFO_1542, *LPSERVER_INFO_1542;

typedef struct _SERVER_INFO_1543 {
    DWORD           sv1543_initsesstable;
} SERVER_INFO_1543, *PSERVER_INFO_1543, *LPSERVER_INFO_1543;

typedef struct _SERVER_INFO_1544 {
    DWORD           sv1544_initconntable;
} SERVER_INFO_1544, *PSERVER_INFO_1544, *LPSERVER_INFO_1544;

typedef struct _SERVER_INFO_1545 {
    DWORD           sv1545_initfiletable;
} SERVER_INFO_1545, *PSERVER_INFO_1545, *LPSERVER_INFO_1545;

typedef struct _SERVER_INFO_1546 {
    DWORD           sv1546_initsearchtable;
} SERVER_INFO_1546, *PSERVER_INFO_1546, *LPSERVER_INFO_1546;

typedef struct _SERVER_INFO_1547 {
    DWORD           sv1547_alertschedule;
} SERVER_INFO_1547, *PSERVER_INFO_1547, *LPSERVER_INFO_1547;

typedef struct _SERVER_INFO_1548 {
    DWORD           sv1548_errorthreshold;
} SERVER_INFO_1548, *PSERVER_INFO_1548, *LPSERVER_INFO_1548;

typedef struct _SERVER_INFO_1549 {
    DWORD           sv1549_networkerrorthreshold;
} SERVER_INFO_1549, *PSERVER_INFO_1549, *LPSERVER_INFO_1549;

typedef struct _SERVER_INFO_1550 {
    DWORD           sv1550_diskspacethreshold;
} SERVER_INFO_1550, *PSERVER_INFO_1550, *LPSERVER_INFO_1550;

typedef struct _SERVER_INFO_1552 {
    DWORD           sv1552_maxlinkdelay;
} SERVER_INFO_1552, *PSERVER_INFO_1552, *LPSERVER_INFO_1552;

typedef struct _SERVER_INFO_1553 {
    DWORD           sv1553_minlinkthroughput;
} SERVER_INFO_1553, *PSERVER_INFO_1553, *LPSERVER_INFO_1553;

typedef struct _SERVER_INFO_1554 {
    DWORD           sv1554_linkinfovalidtime;
} SERVER_INFO_1554, *PSERVER_INFO_1554, *LPSERVER_INFO_1554;

typedef struct _SERVER_INFO_1555 {
    DWORD           sv1555_scavqosinfoupdatetime;
} SERVER_INFO_1555, *PSERVER_INFO_1555, *LPSERVER_INFO_1555;

typedef struct _SERVER_INFO_1556 {
    DWORD           sv1556_maxworkitemidletime;
} SERVER_INFO_1556, *PSERVER_INFO_1556, *LPSERVER_INFO_1556;

typedef struct _SERVER_INFO_1557 {
    DWORD           sv1557_maxrawworkitems;
} SERVER_INFO_1557, *PSERVER_INFO_1557, *LPSERVER_INFO_1557;

typedef struct _SERVER_INFO_1560 {
    DWORD           sv1560_producttype;
} SERVER_INFO_1560, *PSERVER_INFO_1560, *LPSERVER_INFO_1560;

typedef struct _SERVER_INFO_1561 {
    DWORD           sv1561_serversize;
} SERVER_INFO_1561, *PSERVER_INFO_1561, *LPSERVER_INFO_1561;

typedef struct _SERVER_INFO_1562 {
    DWORD           sv1562_connectionlessautodisc;
} SERVER_INFO_1562, *PSERVER_INFO_1562, *LPSERVER_INFO_1562;

typedef struct _SERVER_INFO_1563 {
    DWORD           sv1563_sharingviolationretries;
} SERVER_INFO_1563, *PSERVER_INFO_1563, *LPSERVER_INFO_1563;

typedef struct _SERVER_INFO_1564 {
    DWORD           sv1564_sharingviolationdelay;
} SERVER_INFO_1564, *PSERVER_INFO_1564, *LPSERVER_INFO_1564;

typedef struct _SERVER_INFO_1565 {
    DWORD           sv1565_maxglobalopensearch;
} SERVER_INFO_1565, *PSERVER_INFO_1565, *LPSERVER_INFO_1565;

typedef struct _SERVER_INFO_1566 {
    BOOL           sv1566_removeduplicatesearches;
} SERVER_INFO_1566, *PSERVER_INFO_1566, *LPSERVER_INFO_1566;

typedef struct _SERVER_INFO_1567 {
    DWORD           sv1567_lockviolationretries;
} SERVER_INFO_1567, *PSERVER_INFO_1567, *LPSERVER_INFO_1567;

typedef struct _SERVER_INFO_1568 {
    DWORD           sv1568_lockviolationoffset;
} SERVER_INFO_1568, *PSERVER_INFO_1568, *LPSERVER_INFO_1568;

typedef struct _SERVER_INFO_1569 {
    DWORD           sv1569_lockviolationdelay;
} SERVER_INFO_1569, *PSERVER_INFO_1569, *LPSERVER_INFO_1569;

typedef struct _SERVER_INFO_1570 {
    DWORD           sv1570_mdlreadswitchover;
} SERVER_INFO_1570, *PSERVER_INFO_1570, *LPSERVER_INFO_1570;

typedef struct _SERVER_INFO_1571 {
    DWORD           sv1571_cachedopenlimit;
} SERVER_INFO_1571, *PSERVER_INFO_1571, *LPSERVER_INFO_1571;

typedef struct _SERVER_INFO_1572 {
    DWORD           sv1572_criticalthreads;
} SERVER_INFO_1572, *PSERVER_INFO_1572, *LPSERVER_INFO_1572;

typedef struct _SERVER_INFO_1573 {
    DWORD           sv1573_restrictnullsessaccess;
} SERVER_INFO_1573, *PSERVER_INFO_1573, *LPSERVER_INFO_1573;

typedef struct _SERVER_INFO_1574 {
    DWORD           sv1574_enablewfw311directipx;
} SERVER_INFO_1574, *PSERVER_INFO_1574, *LPSERVER_INFO_1574;

typedef struct _SERVER_INFO_1575 {
    DWORD           sv1575_otherqueueaffinity;
} SERVER_INFO_1575, *PSERVER_INFO_1575, *LPSERVER_INFO_1575;

typedef struct _SERVER_INFO_1576 {
    DWORD           sv1576_queuesamplesecs;
} SERVER_INFO_1576, *PSERVER_INFO_1576, *LPSERVER_INFO_1576;

typedef struct _SERVER_INFO_1577 {
    DWORD           sv1577_balancecount;
} SERVER_INFO_1577, *PSERVER_INFO_1577, *LPSERVER_INFO_1577;

typedef struct _SERVER_INFO_1578 {
    DWORD           sv1578_preferredaffinity;
} SERVER_INFO_1578, *PSERVER_INFO_1578, *LPSERVER_INFO_1578;

typedef struct _SERVER_INFO_1579 {
    DWORD           sv1579_maxfreerfcbs;
} SERVER_INFO_1579, *PSERVER_INFO_1579, *LPSERVER_INFO_1579;

typedef struct _SERVER_INFO_1580 {
    DWORD           sv1580_maxfreemfcbs;
} SERVER_INFO_1580, *PSERVER_INFO_1580, *LPSERVER_INFO_1580;

typedef struct _SERVER_INFO_1581 {
    DWORD           sv1581_maxfreemlcbs;
} SERVER_INFO_1581, *PSERVER_INFO_1581, *LPSERVER_INFO_1581;

typedef struct _SERVER_INFO_1582 {
    DWORD           sv1582_maxfreepagedpoolchunks;
} SERVER_INFO_1582, *PSERVER_INFO_1582, *LPSERVER_INFO_1582;

typedef struct _SERVER_INFO_1583 {
    DWORD           sv1583_minpagedpoolchunksize;
} SERVER_INFO_1583, *PSERVER_INFO_1583, *LPSERVER_INFO_1583;

typedef struct _SERVER_INFO_1584 {
    DWORD           sv1584_maxpagedpoolchunksize;
} SERVER_INFO_1584, *PSERVER_INFO_1584, *LPSERVER_INFO_1584;

typedef struct _SERVER_INFO_1585 {
    BOOL           sv1585_sendsfrompreferredprocessor;
} SERVER_INFO_1585, *PSERVER_INFO_1585, *LPSERVER_INFO_1585;

typedef struct _SERVER_INFO_1586 {
    DWORD          sv1586_maxthreadsperqueue;
} SERVER_INFO_1586, *PSERVER_INFO_1586, *LPSERVER_INFO_1586;

typedef struct _SERVER_INFO_1587 {
    DWORD          sv1587_cacheddirectorylimit;
} SERVER_INFO_1587, *PSERVER_INFO_1587, *LPSERVER_INFO_1587;

typedef struct _SERVER_INFO_1588 {
    DWORD          sv1588_maxcopylength;
} SERVER_INFO_1588, *PSERVER_INFO_1588, *LPSERVER_INFO_1588;

typedef struct _SERVER_INFO_1590 {
    DWORD          sv1590_enablecompression;
} SERVER_INFO_1590, *PSERVER_INFO_1590, *LPSERVER_INFO_1590;

typedef struct _SERVER_INFO_1591 {
    DWORD          sv1591_autosharewks;
} SERVER_INFO_1591, *PSERVER_INFO_1591, *LPSERVER_INFO_1591;

typedef struct _SERVER_INFO_1592 {
    DWORD          sv1592_autosharewks;
} SERVER_INFO_1592, *PSERVER_INFO_1592, *LPSERVER_INFO_1592;

typedef struct _SERVER_INFO_1593 {
    DWORD          sv1593_enablesecuritysignature;
} SERVER_INFO_1593, *PSERVER_INFO_1593, *LPSERVER_INFO_1593;

typedef struct _SERVER_INFO_1594 {
    DWORD          sv1594_requiresecuritysignature;
} SERVER_INFO_1594, *PSERVER_INFO_1594, *LPSERVER_INFO_1594;

typedef struct _SERVER_INFO_1595 {
    DWORD          sv1595_minclientbuffersize;
} SERVER_INFO_1595, *PSERVER_INFO_1595, *LPSERVER_INFO_1595;

typedef struct _SERVER_INFO_1596 {
    DWORD          sv1596_ConnectionNoSessionsTimeout;
} SERVER_INFO_1596, *PSERVER_INFO_1596, *LPSERVER_INFO_1596;

typedef struct _SERVER_INFO_1597 {
    DWORD          sv1597_IdleThreadTimeOut;
} SERVER_INFO_1597, *PSERVER_INFO_1597, *LPSERVER_INFO_1597;

typedef struct _SERVER_INFO_1598 {
    DWORD          sv1598_enableW9xsecuritysignature;
} SERVER_INFO_1598, *PSERVER_INFO_1598, *LPSERVER_INFO_1598;

typedef struct _SERVER_INFO_1599 {
    BOOLEAN        sv1598_enforcekerberosreauthentication;
} SERVER_INFO_1599, *PSERVER_INFO_1599, *LPSERVER_INFO_1599;

typedef struct _SERVER_INFO_1600 {
    BOOLEAN        sv1598_disabledos;
} SERVER_INFO_1600, *PSERVER_INFO_1600, *LPSERVER_INFO_1600;

typedef struct _SERVER_INFO_1601 {
    DWORD          sv1598_lowdiskspaceminimum;
} SERVER_INFO_1601, *PSERVER_INFO_1601, *LPSERVER_INFO_1601;

typedef struct _SERVER_INFO_1602 {
    BOOL           sv_1598_disablestrictnamechecking;
} SERVER_INFO_1602, *PSERVER_INFO_1602, *LPSERVER_INFO_1602;

//
// A special structure definition is required in order for this
// structure to work with RPC.  The problem is that having addresslength
// indicate the number of bytes in address means that RPC must know the
// link between the two.
//

#ifdef MIDL_PASS

typedef struct _SERVER_TRANSPORT_INFO_0 {
    DWORD           svti0_numberofvcs;
    LMSTR           svti0_transportname;
    [size_is(svti0_transportaddresslength)]  LPBYTE svti0_transportaddress;
    DWORD           svti0_transportaddresslength;
    LMSTR           svti0_networkaddress;
} SERVER_TRANSPORT_INFO_0, *PSERVER_TRANSPORT_INFO_0, *LPSERVER_TRANSPORT_INFO_0;

typedef struct _SERVER_TRANSPORT_INFO_1 {
    DWORD           svti1_numberofvcs;
    LMSTR           svti1_transportname;
    [size_is(svti1_transportaddresslength)]  LPBYTE svti1_transportaddress;
    DWORD           svti1_transportaddresslength;
    LMSTR           svti1_networkaddress;
    LMSTR           svti1_domain;
} SERVER_TRANSPORT_INFO_1, *PSERVER_TRANSPORT_INFO_1, *LPSERVER_TRANSPORT_INFO_1;

typedef struct _SERVER_TRANSPORT_INFO_2 {
    DWORD           svti2_numberofvcs;
    LMSTR           svti2_transportname;
    [size_is(svti2_transportaddresslength)] LPBYTE svti2_transportaddress;
    DWORD           svti2_transportaddresslength;
    LMSTR           svti2_networkaddress;
    LMSTR           svti2_domain;
    ULONG           svti2_flags;
} SERVER_TRANSPORT_INFO_2, *PSERVER_TRANSPORT_INFO_2, *LPSERVER_TRANSPORT_INFO_2;

typedef struct _SERVER_TRANSPORT_INFO_3 {
    DWORD           svti3_numberofvcs;
    LMSTR           svti3_transportname;
    [size_is(svti3_transportaddresslength)]  LPBYTE svti3_transportaddress;
    DWORD           svti3_transportaddresslength;
    LMSTR           svti3_networkaddress;
    LMSTR           svti3_domain;
    ULONG           svti3_flags;
    DWORD           svti3_passwordlength;
    BYTE            svti3_password[ 256 ];
} SERVER_TRANSPORT_INFO_3, *PSERVER_TRANSPORT_INFO_3, *LPSERVER_TRANSPORT_INFO_3;

#else

typedef struct _SERVER_TRANSPORT_INFO_0 {
    DWORD           svti0_numberofvcs;
    LMSTR           svti0_transportname;
    LPBYTE          svti0_transportaddress;
    DWORD           svti0_transportaddresslength;
    LMSTR           svti0_networkaddress;
} SERVER_TRANSPORT_INFO_0, *PSERVER_TRANSPORT_INFO_0, *LPSERVER_TRANSPORT_INFO_0;

typedef struct _SERVER_TRANSPORT_INFO_1 {
    DWORD           svti1_numberofvcs;
    LMSTR           svti1_transportname;
    LPBYTE          svti1_transportaddress;
    DWORD           svti1_transportaddresslength;
    LMSTR           svti1_networkaddress;
    LMSTR           svti1_domain;
} SERVER_TRANSPORT_INFO_1, *PSERVER_TRANSPORT_INFO_1, *LPSERVER_TRANSPORT_INFO_1;

typedef struct _SERVER_TRANSPORT_INFO_2 {
    DWORD           svti2_numberofvcs;
    LMSTR           svti2_transportname;
    LPBYTE          svti2_transportaddress;
    DWORD           svti2_transportaddresslength;
    LMSTR           svti2_networkaddress;
    LMSTR           svti2_domain;
    ULONG           svti2_flags;
} SERVER_TRANSPORT_INFO_2, *PSERVER_TRANSPORT_INFO_2, *LPSERVER_TRANSPORT_INFO_2;

typedef struct _SERVER_TRANSPORT_INFO_3 {
    DWORD           svti3_numberofvcs;
    LMSTR           svti3_transportname;
    LPBYTE          svti3_transportaddress;
    DWORD           svti3_transportaddresslength;
    LMSTR           svti3_networkaddress;
    LMSTR           svti3_domain;
    ULONG           svti3_flags;
    DWORD           svti3_passwordlength;
    BYTE            svti3_password[ 256 ];
} SERVER_TRANSPORT_INFO_3, *PSERVER_TRANSPORT_INFO_3, *LPSERVER_TRANSPORT_INFO_3;

#endif

//
// Defines - SERVER
//

//
// The platform ID indicates the levels to use for platform-specific
// information.
//

#define SV_PLATFORM_ID_OS2 400
#define SV_PLATFORM_ID_NT  500

//
//      Mask to be applied to svX_version_major in order to obtain
//      the major version number.
//

#define MAJOR_VERSION_MASK  0x0F

//
//      Bit-mapped values for svX_type fields. X = 1, 2 or 3.
//

#define SV_TYPE_WORKSTATION         0x00000001
#define SV_TYPE_SERVER              0x00000002
#define SV_TYPE_SQLSERVER           0x00000004
#define SV_TYPE_DOMAIN_CTRL         0x00000008
#define SV_TYPE_DOMAIN_BAKCTRL      0x00000010
#define SV_TYPE_TIME_SOURCE         0x00000020
#define SV_TYPE_AFP                 0x00000040
#define SV_TYPE_NOVELL              0x00000080
#define SV_TYPE_DOMAIN_MEMBER       0x00000100
#define SV_TYPE_PRINTQ_SERVER       0x00000200
#define SV_TYPE_DIALIN_SERVER       0x00000400
#define SV_TYPE_XENIX_SERVER        0x00000800
#define SV_TYPE_SERVER_UNIX         SV_TYPE_XENIX_SERVER
#define SV_TYPE_NT                  0x00001000
#define SV_TYPE_WFW                 0x00002000
#define SV_TYPE_SERVER_MFPN         0x00004000
#define SV_TYPE_SERVER_NT           0x00008000
#define SV_TYPE_POTENTIAL_BROWSER   0x00010000
#define SV_TYPE_BACKUP_BROWSER      0x00020000
#define SV_TYPE_MASTER_BROWSER      0x00040000
#define SV_TYPE_DOMAIN_MASTER       0x00080000
#define SV_TYPE_SERVER_OSF          0x00100000
#define SV_TYPE_SERVER_VMS          0x00200000
#define SV_TYPE_WINDOWS             0x00400000  /* Windows95 and above */
#define SV_TYPE_DFS                 0x00800000  /* Root of a DFS tree */
#define SV_TYPE_CLUSTER_NT          0x01000000  /* NT Cluster */
#define SV_TYPE_TERMINALSERVER      0x02000000  /* Terminal Server(Hydra) */
#define SV_TYPE_CLUSTER_VS_NT       0x04000000  /* NT Cluster Virtual Server Name */
#define SV_TYPE_DCE                 0x10000000  /* IBM DSS (Directory and Security Services) or equivalent */
#define SV_TYPE_ALTERNATE_XPORT     0x20000000  /* return list for alternate transport */
#define SV_TYPE_LOCAL_LIST_ONLY     0x40000000  /* Return local list only */
#define SV_TYPE_DOMAIN_ENUM         0x80000000
#define SV_TYPE_ALL                 0xFFFFFFFF  /* handy for NetServerEnum2 */

//
//      Special value for sv102_disc that specifies infinite disconnect
//      time.
//

#define SV_NODISC           (-1L)  /* No autodisconnect timeout enforced */

//
//      Values of svX_security field. X = 2 or 3.
//

#define SV_USERSECURITY     1
#define SV_SHARESECURITY    0

//
//      Values of svX_hidden field. X = 2 or 3.
//

#define SV_HIDDEN       1
#define SV_VISIBLE      0

//
//      Values for ParmError parameter to NetServerSetInfo.
//

#define SV_PLATFORM_ID_PARMNUM          101
#define SV_NAME_PARMNUM                 102
#define SV_VERSION_MAJOR_PARMNUM        103
#define SV_VERSION_MINOR_PARMNUM        104
#define SV_TYPE_PARMNUM                 105
#define SV_COMMENT_PARMNUM              5
#define SV_USERS_PARMNUM                107
#define SV_DISC_PARMNUM                 10
#define SV_HIDDEN_PARMNUM               16
#define SV_ANNOUNCE_PARMNUM             17
#define SV_ANNDELTA_PARMNUM             18
#define SV_USERPATH_PARMNUM             112

#define SV_ULIST_MTIME_PARMNUM          401
#define SV_GLIST_MTIME_PARMNUM          402
#define SV_ALIST_MTIME_PARMNUM          403
#define SV_ALERTS_PARMNUM               11
#define SV_SECURITY_PARMNUM             405
#define SV_NUMADMIN_PARMNUM             406
#define SV_LANMASK_PARMNUM              407
#define SV_GUESTACC_PARMNUM             408
#define SV_CHDEVQ_PARMNUM               410
#define SV_CHDEVJOBS_PARMNUM            411
#define SV_CONNECTIONS_PARMNUM          412
#define SV_SHARES_PARMNUM               413
#define SV_OPENFILES_PARMNUM            414
#define SV_SESSREQS_PARMNUM             417
#define SV_ACTIVELOCKS_PARMNUM          419
#define SV_NUMREQBUF_PARMNUM            420
#define SV_NUMBIGBUF_PARMNUM            422
#define SV_NUMFILETASKS_PARMNUM         423
#define SV_ALERTSCHED_PARMNUM           37
#define SV_ERRORALERT_PARMNUM           38
#define SV_LOGONALERT_PARMNUM           39
#define SV_ACCESSALERT_PARMNUM          40
#define SV_DISKALERT_PARMNUM            41
#define SV_NETIOALERT_PARMNUM           42
#define SV_MAXAUDITSZ_PARMNUM           43
#define SV_SRVHEURISTICS_PARMNUM        431

#define SV_SESSOPENS_PARMNUM                501
#define SV_SESSVCS_PARMNUM                  502
#define SV_OPENSEARCH_PARMNUM               503
#define SV_SIZREQBUF_PARMNUM                504
#define SV_INITWORKITEMS_PARMNUM            505
#define SV_MAXWORKITEMS_PARMNUM             506
#define SV_RAWWORKITEMS_PARMNUM             507
#define SV_IRPSTACKSIZE_PARMNUM             508
#define SV_MAXRAWBUFLEN_PARMNUM             509
#define SV_SESSUSERS_PARMNUM                510
#define SV_SESSCONNS_PARMNUM                511
#define SV_MAXNONPAGEDMEMORYUSAGE_PARMNUM   512
#define SV_MAXPAGEDMEMORYUSAGE_PARMNUM      513
#define SV_ENABLESOFTCOMPAT_PARMNUM         514
#define SV_ENABLEFORCEDLOGOFF_PARMNUM       515
#define SV_TIMESOURCE_PARMNUM               516
#define SV_ACCEPTDOWNLEVELAPIS_PARMNUM      517
#define SV_LMANNOUNCE_PARMNUM               518
#define SV_DOMAIN_PARMNUM                   519
#define SV_MAXCOPYREADLEN_PARMNUM           520
#define SV_MAXCOPYWRITELEN_PARMNUM          521
#define SV_MINKEEPSEARCH_PARMNUM            522
#define SV_MAXKEEPSEARCH_PARMNUM            523
#define SV_MINKEEPCOMPLSEARCH_PARMNUM       524
#define SV_MAXKEEPCOMPLSEARCH_PARMNUM       525
#define SV_THREADCOUNTADD_PARMNUM           526
#define SV_NUMBLOCKTHREADS_PARMNUM          527
#define SV_SCAVTIMEOUT_PARMNUM              528
#define SV_MINRCVQUEUE_PARMNUM              529
#define SV_MINFREEWORKITEMS_PARMNUM         530
#define SV_XACTMEMSIZE_PARMNUM              531
#define SV_THREADPRIORITY_PARMNUM           532
#define SV_MAXMPXCT_PARMNUM                 533
#define SV_OPLOCKBREAKWAIT_PARMNUM          534
#define SV_OPLOCKBREAKRESPONSEWAIT_PARMNUM  535
#define SV_ENABLEOPLOCKS_PARMNUM            536
#define SV_ENABLEOPLOCKFORCECLOSE_PARMNUM   537
#define SV_ENABLEFCBOPENS_PARMNUM           538
#define SV_ENABLERAW_PARMNUM                539
#define SV_ENABLESHAREDNETDRIVES_PARMNUM    540
#define SV_MINFREECONNECTIONS_PARMNUM       541
#define SV_MAXFREECONNECTIONS_PARMNUM       542
#define SV_INITSESSTABLE_PARMNUM            543
#define SV_INITCONNTABLE_PARMNUM            544
#define SV_INITFILETABLE_PARMNUM            545
#define SV_INITSEARCHTABLE_PARMNUM          546
#define SV_ALERTSCHEDULE_PARMNUM            547
#define SV_ERRORTHRESHOLD_PARMNUM           548
#define SV_NETWORKERRORTHRESHOLD_PARMNUM    549
#define SV_DISKSPACETHRESHOLD_PARMNUM       550
#define SV_MAXLINKDELAY_PARMNUM             552
#define SV_MINLINKTHROUGHPUT_PARMNUM        553
#define SV_LINKINFOVALIDTIME_PARMNUM        554
#define SV_SCAVQOSINFOUPDATETIME_PARMNUM    555
#define SV_MAXWORKITEMIDLETIME_PARMNUM      556
#define SV_MAXRAWWORKITEMS_PARMNUM          557
#define SV_PRODUCTTYPE_PARMNUM              560
#define SV_SERVERSIZE_PARMNUM               561
#define SV_CONNECTIONLESSAUTODISC_PARMNUM   562
#define SV_SHARINGVIOLATIONRETRIES_PARMNUM  563
#define SV_SHARINGVIOLATIONDELAY_PARMNUM    564
#define SV_MAXGLOBALOPENSEARCH_PARMNUM      565
#define SV_REMOVEDUPLICATESEARCHES_PARMNUM  566
#define SV_LOCKVIOLATIONRETRIES_PARMNUM     567
#define SV_LOCKVIOLATIONOFFSET_PARMNUM      568
#define SV_LOCKVIOLATIONDELAY_PARMNUM       569
#define SV_MDLREADSWITCHOVER_PARMNUM        570
#define SV_CACHEDOPENLIMIT_PARMNUM          571
#define SV_CRITICALTHREADS_PARMNUM          572
#define SV_RESTRICTNULLSESSACCESS_PARMNUM   573
#define SV_ENABLEWFW311DIRECTIPX_PARMNUM    574
#define SV_OTHERQUEUEAFFINITY_PARMNUM       575
#define SV_QUEUESAMPLESECS_PARMNUM          576
#define SV_BALANCECOUNT_PARMNUM             577
#define SV_PREFERREDAFFINITY_PARMNUM        578
#define SV_MAXFREERFCBS_PARMNUM             579
#define SV_MAXFREEMFCBS_PARMNUM             580
#define SV_MAXFREELFCBS_PARMNUM             581
#define SV_MAXFREEPAGEDPOOLCHUNKS_PARMNUM   582
#define SV_MINPAGEDPOOLCHUNKSIZE_PARMNUM    583
#define SV_MAXPAGEDPOOLCHUNKSIZE_PARMNUM    584
#define SV_SENDSFROMPREFERREDPROCESSOR_PARMNUM    585
#define SV_MAXTHREADSPERQUEUE_PARMNUM       586
#define SV_CACHEDDIRECTORYLIMIT_PARMNUM     587
#define SV_MAXCOPYLENGTH_PARMNUM            588
#define SV_ENABLECOMPRESSION_PARMNUM        590
#define SV_AUTOSHAREWKS_PARMNUM             591
#define SV_AUTOSHARESERVER_PARMNUM          592
#define SV_ENABLESECURITYSIGNATURE_PARMNUM  593
#define SV_REQUIRESECURITYSIGNATURE_PARMNUM 594
#define SV_MINCLIENTBUFFERSIZE_PARMNUM      595
#define SV_CONNECTIONNOSESSIONSTIMEOUT_PARMNUM 596
#define SV_IDLETHREADTIMEOUT_PARMNUM        597
#define SV_ENABLEW9XSECURITYSIGNATURE_PARMNUM        598
#define SV_ENFORCEKERBEROSREAUTHENTICATION_PARMNUM   599
#define SV_DISABLEDOS_PARMNUM                        600
#define SV_LOWDISKSPACEMINIMUM_PARMNUM               601
#define SV_DISABLESTRICTNAMECHECKING_PARMNUM         602
#define SV_ENABLEAUTHENTICATEUSERSHARING_PARMNUM     603

//
// Single-field infolevels for NetServerSetInfo.
//

#define SV_COMMENT_INFOLEVEL                    \
            (PARMNUM_BASE_INFOLEVEL + SV_COMMENT_PARMNUM)
#define SV_USERS_INFOLEVEL                      \
            (PARMNUM_BASE_INFOLEVEL + SV_USERS_PARMNUM)
#define SV_DISC_INFOLEVEL                       \
            (PARMNUM_BASE_INFOLEVEL + SV_DISC_PARMNUM)
#define SV_HIDDEN_INFOLEVEL                     \
            (PARMNUM_BASE_INFOLEVEL + SV_HIDDEN_PARMNUM)
#define SV_ANNOUNCE_INFOLEVEL                   \
            (PARMNUM_BASE_INFOLEVEL + SV_ANNOUNCE_PARMNUM)
#define SV_ANNDELTA_INFOLEVEL                   \
            (PARMNUM_BASE_INFOLEVEL + SV_ANNDELTA_PARMNUM)
#define SV_SESSOPENS_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSOPENS_PARMNUM)
#define SV_SESSVCS_INFOLEVEL                    \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSVCS_PARMNUM)
#define SV_OPENSEARCH_INFOLEVEL                 \
            (PARMNUM_BASE_INFOLEVEL + SV_OPENSEARCH_PARMNUM)
#define SV_MAXWORKITEMS_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXWORKITEMS_PARMNUM)
#define SV_MAXRAWBUFLEN_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXRAWBUFLEN_PARMNUM)
#define SV_SESSUSERS_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSUSERS_PARMNUM)
#define SV_SESSCONNS_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_SESSCONNS_PARMNUM)
#define SV_MAXNONPAGEDMEMORYUSAGE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXNONPAGEDMEMORYUSAGE_PARMNUM)
#define SV_MAXPAGEDMEMORYUSAGE_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXPAGEDMEMORYUSAGE_PARMNUM)
#define SV_ENABLESOFTCOMPAT_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLESOFTCOMPAT_PARMNUM)
#define SV_ENABLEFORCEDLOGOFF_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEFORCEDLOGOFF_PARMNUM)
#define SV_TIMESOURCE_INFOLEVEL                 \
            (PARMNUM_BASE_INFOLEVEL + SV_TIMESOURCE_PARMNUM)
#define SV_LMANNOUNCE_INFOLEVEL                 \
            (PARMNUM_BASE_INFOLEVEL + SV_LMANNOUNCE_PARMNUM)
#define SV_MAXCOPYREADLEN_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXCOPYREADLEN_PARMNUM)
#define SV_MAXCOPYWRITELEN_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXCOPYWRITELEN_PARMNUM)
#define SV_MINKEEPSEARCH_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_MINKEEPSEARCH_PARMNUM)
#define SV_MAXKEEPSEARCH_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXKEEPSEARCH_PARMNUM)
#define SV_MINKEEPCOMPLSEARCH_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MINKEEPCOMPLSEARCH_PARMNUM)
#define SV_MAXKEEPCOMPLSEARCH_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXKEEPCOMPLSEARCH_PARMNUM)
#define SV_SCAVTIMEOUT_INFOLEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_SCAVTIMEOUT_PARMNUM)
#define SV_MINRCVQUEUE_INFOLEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_MINRCVQUEUE_PARMNUM)
#define SV_MINFREEWORKITEMS_INFOLEVEL           \
            (PARMNUM_BASE_INFOLEVEL + SV_MINFREEWORKITEMS_PARMNUM)
#define SV_MAXMPXCT_INFOLEVEL                   \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXMPXCT_PARMNUM)
#define SV_OPLOCKBREAKWAIT_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + SV_OPLOCKBREAKWAIT_PARMNUM)
#define SV_OPLOCKBREAKRESPONSEWAIT_INFOLEVEL    \
            (PARMNUM_BASE_INFOLEVEL + SV_OPLOCKBREAKRESPONSEWAIT_PARMNUM)
#define SV_ENABLEOPLOCKS_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEOPLOCKS_PARMNUM)
#define SV_ENABLEOPLOCKFORCECLOSE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEOPLOCKFORCECLOSE_PARMNUM)
#define SV_ENABLEFCBOPENS_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEFCBOPENS_PARMNUM)
#define SV_ENABLERAW_INFOLEVEL                  \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLERAW_PARMNUM)
#define SV_ENABLESHAREDNETDRIVES_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLESHAREDNETDRIVES_PARMNUM)
#define SV_MINFREECONNECTIONS_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MINFREECONNECTIONS_PARMNUM)
#define SV_MAXFREECONNECTIONS_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREECONNECTIONS_PARMNUM)
#define SV_INITSESSTABLE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_INITSESSTABLE_PARMNUM)
#define SV_INITCONNTABLE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_INITCONNTABLE_PARMNUM)
#define SV_INITFILETABLE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_INITFILETABLE_PARMNUM)
#define SV_INITSEARCHTABLE_INFOLEVEL            \
            (PARMNUM_BASE_INFOLEVEL + SV_INITSEARCHTABLE_PARMNUM)
#define SV_ALERTSCHEDULE_INFOLEVEL              \
            (PARMNUM_BASE_INFOLEVEL + SV_ALERTSCHEDULE_PARMNUM)
#define SV_ERRORTHRESHOLD_INFOLEVEL             \
            (PARMNUM_BASE_INFOLEVEL + SV_ERRORTHRESHOLD_PARMNUM)
#define SV_NETWORKERRORTHRESHOLD_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + SV_NETWORKERRORTHRESHOLD_PARMNUM)
#define SV_DISKSPACETHRESHOLD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SV_DISKSPACETHRESHOLD_PARMNUM)
#define SV_MAXLINKDELAY_INFOLEVEL               \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXLINKDELAY_PARMNUM)
#define SV_MINLINKTHROUGHPUT_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + SV_MINLINKTHROUGHPUT_PARMNUM)
#define SV_LINKINFOVALIDTIME_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + SV_LINKINFOVALIDTIME_PARMNUM)
#define SV_SCAVQOSINFOUPDATETIME_INFOLEVEL      \
            (PARMNUM_BASE_INFOLEVEL + SV_SCAVQOSINFOUPDATETIME_PARMNUM)
#define SV_MAXWORKITEMIDLETIME_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXWORKITEMIDLETIME_PARMNUM)
#define SV_MAXRAWWORKITEMS_INFOLOEVEL           \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXRAWWORKITEMS_PARMNUM)
#define SV_PRODUCTTYPE_INFOLOEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_PRODUCTTYPE_PARMNUM)
#define SV_SERVERSIZE_INFOLOEVEL                \
            (PARMNUM_BASE_INFOLEVEL + SV_SERVERSIZE_PARMNUM)
#define SV_CONNECTIONLESSAUTODISC_INFOLOEVEL    \
            (PARMNUM_BASE_INFOLEVEL + SV_CONNECTIONLESSAUTODISC_PARMNUM)
#define SV_SHARINGVIOLATIONRETRIES_INFOLOEVEL   \
            (PARMNUM_BASE_INFOLEVEL + SV_SHARINGVIOLATIONRETRIES_PARMNUM)
#define SV_SHARINGVIOLATIONDELAY_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_SHARINGVIOLATIONDELAY_PARMNUM)
#define SV_MAXGLOBALOPENSEARCH_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXGLOBALOPENSEARCH_PARMNUM)
#define SV_REMOVEDUPLICATESEARCHES_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_REMOVEDUPLICATESEARCHES_PARMNUM)
#define SV_LOCKVIOLATIONRETRIES_INFOLOEVEL   \
            (PARMNUM_BASE_INFOLEVEL + SV_LOCKVIOLATIONRETRIES_PARMNUM)
#define SV_LOCKVIOLATIONOFFSET_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_LOCKVIOLATIONOFFSET_PARMNUM)
#define SV_LOCKVIOLATIONDELAY_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_LOCKVIOLATIONDELAY_PARMNUM)
#define SV_MDLREADSWITCHOVER_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MDLREADSWITCHOVER_PARMNUM)
#define SV_CACHEDOPENLIMIT_INFOLOEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_CACHEDOPENLIMIT_PARMNUM)
#define SV_CRITICALTHREADS_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_CRITICALTHREADS_PARMNUM)
#define SV_RESTRICTNULLSESSACCESS_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_RESTRICTNULLSESSACCESS_PARMNUM)
#define SV_ENABLEWFW311DIRECTIPX_INFOLOEVEL       \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEWFW311DIRECTIPX_PARMNUM)
#define SV_OTHERQUEUEAFFINITY_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_OTHERQUEUEAFFINITY_PARMNUM)
#define SV_QUEUESAMPLESECS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_QUEUESAMPLESECS_PARMNUM)
#define SV_BALANCECOUNT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_BALANCECOUNT_PARMNUM)
#define SV_PREFERREDAFFINITY_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_PREFERREDAFFINITY_PARMNUM)
#define SV_MAXFREERFCBS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREERFCBS_PARMNUM)
#define SV_MAXFREEMFCBS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREEMFCBS_PARMNUM)
#define SV_MAXFREELFCBS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREELFCBS_PARMNUM)
#define SV_MAXFREEPAGEDPOOLCHUNKS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXFREEPAGEDPOOLCHUNKS_PARMNUM)
#define SV_MINPAGEDPOOLCHUNKSIZE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MINPAGEDPOOLCHUNKSIZE_PARMNUM)
#define SV_MAXPAGEDPOOLCHUNKSIZE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXPAGEDPOOLCHUNKSIZE_PARMNUM)
#define SV_SENDSFROMPREFERREDPROCESSOR_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_SENDSFROMPREFERREDPROCESSOR_PARMNUM)
#define SV_MAXTHREADSPERQUEUE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXTHREADSPERQUEUE_PARMNUM)
#define SV_CACHEDDIRECTORYLIMIT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_CACHEDDIRECTORYLIMIT_PARMNUM)
#define SV_MAXCOPYLENGTH_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MAXCOPYLENGTH_PARMNUM)
#define SV_ENABLECOMPRESSION_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLECOMPRESSION_PARMNUM)
#define SV_AUTOSHAREWKS_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_AUTOSHAREWKS_PARMNUM)
#define SV_AUTOSHARESERVER_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_AUTOSHARESERVER_PARMNUM)
#define SV_ENABLESECURITYSIGNATURE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLESECURITYSIGNATURE_PARMNUM)
#define SV_REQUIRESECURITYSIGNATURE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_REQUIRESECURITYSIGNATURE_PARMNUM)
#define SV_MINCLIENTBUFFERSIZE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_MINCLIENTBUFFERSIZE_PARMNUM)
#define SV_CONNECTIONNOSESSIONSTIMEOUT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_CONNECTIONNOSESSIONSTIMEOUT_PARMNUM)
#define SV_IDLETHREADTIMEOUT_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_IDLETHREADTIMEOUT_PARMNUM)
#define SV_ENABLEW9XSECURITYSIGNATURE_INFOLEVEL     \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEW9XSECURITYSIGNATURE_PARMNUM)
#define SV_ENFORCEKERBEROSREAUTHENTICATION_INFOLEVEL \
            (PARMNUM_BASE_INFOLEVEL + SV_ENFORCEKERBEROSREAUTHENTICATION_PARMNUM)
#define SV_DISABLEDOS_INFOLEVEL \
            (PARMNUM_BASE_INFOLEVEL + SV_DISABLEDOS_PARMNUM)
#define SV_LOWDISKSPACEMINIMUM_INFOLEVEL \
            (PARMNUM_BASE_INFOLEVEL + SV_LOWDISKSPACEMINIMUM_PARMNUM)
#define SV_DISABLESTRICTNAMECHECKING_INFOLEVEL \
            (PARMNUM_BASE_INFOLEVEL + SV_DISABLESTRICTNAMECHECKING_PARMNUM)
#define SV_ENABLEAUTHENTICATEUSERSHARING_INFOLEVEL \
            (PARMNUM_BASE_INFOLEVEL + SV_ENABLEAUTHENTICATEUSERSHARING_PARMNUM)

#define SVI1_NUM_ELEMENTS       5
#define SVI2_NUM_ELEMENTS       40
#define SVI3_NUM_ELEMENTS       44

//
//      Maxmimum length for command string to NetServerAdminCommand.
//

#define SV_MAX_CMD_LEN          PATHLEN

//
//      Masks describing AUTOPROFILE parameters
//

#define SW_AUTOPROF_LOAD_MASK   0x1
#define SW_AUTOPROF_SAVE_MASK   0x2

//
//      Max size of svX_srvheuristics.
//

#define SV_MAX_SRV_HEUR_LEN     32      // Max heuristics info string length.

//
//      Equate for use with sv102_licenses.
//

#define SV_USERS_PER_LICENSE    5

//
// Equate for use with svti2_flags in NetServerTransportAddEx.
//

#define SVTI2_REMAP_PIPE_NAMES  0x2
#define SVTI2_SCOPED_NAME       0x4
#define SVTI2_VALID_FLAGS (SVTI2_REMAP_PIPE_NAMES|SVTI2_SCOPED_NAME)

//
// Server capability information
//

#define SRV_SUPPORT_HASH_GENERATION       0x0001
#define SRV_HASH_GENERATION_ACTIVE        0x0002

#ifdef __cplusplus
}
#endif

#endif // _LMSERVER_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMShare.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1990-1999  Microsoft Corporation

Module Name:

    lmshare.h

Abstract:

    This module defines the API function prototypes and data structures
    for the following groups of NT API functions:
        NetShare
        NetSession
        NetFile
        NetConnection

Environment:

    User Mode - Win32

Notes:

    You must include <windef.h> and <lmcons.h> before this file.

--*/

//
// SHARE API
//

#ifndef _LMSHARE_
#define _LMSHARE_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>

//
// Function Prototypes - Share
//

NET_API_STATUS NET_API_FUNCTION
NetShareAdd (
    __in_opt IN  LMSTR   servername,
    IN  DWORD   level,
    __inout IN  LPBYTE  buf,
    __out_opt OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetShareEnum (
    __in_opt IN  LMSTR       servername,
    __in IN  DWORD       level,
    __deref_out_xcount("size varies with level") OUT LPBYTE      *bufptr,
    __in IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    __inout_opt IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetShareEnumSticky (
    __in_opt IN  LMSTR       servername,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    __inout_opt IN OUT LPDWORD  resume_handle
    );

NET_API_STATUS NET_API_FUNCTION
NetShareGetInfo (
    __in_opt IN  LMSTR   servername,
    __in_opt IN  LMSTR   netname,
    __in IN  DWORD   level,
    __deref_opt_out_xcount("size varies with level") OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetShareSetInfo (
    __in_opt IN  LMSTR   servername,
    __in_opt IN  LMSTR   netname,
    IN  DWORD   level,
    __inout_opt IN  LPBYTE  buf,
    __out_opt OUT LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetShareDel     (
    __in_opt IN  LMSTR   servername,
    __in_opt IN  LMSTR   netname,
    IN  DWORD   reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetShareDelSticky (
    __in_opt IN  LMSTR   servername,
    __in_opt IN  LMSTR   netname,
    IN  DWORD   reserved
    );

NET_API_STATUS NET_API_FUNCTION
NetShareCheck   (
    __in_opt IN  LMSTR   servername,
    __in_opt IN  LMSTR   device,
    __out_opt OUT LPDWORD type
    );

NET_API_STATUS NET_API_FUNCTION
NetShareDelEx (
    __in_opt IN  LMSTR   servername,
    IN  DWORD   level,
    __in IN  LPBYTE  buf
    );

//
// Data Structures - Share
//

typedef struct _SHARE_INFO_0 {
    LMSTR   shi0_netname;
} SHARE_INFO_0, *PSHARE_INFO_0, *LPSHARE_INFO_0;

typedef struct _SHARE_INFO_1 {
    LMSTR   shi1_netname;
    DWORD   shi1_type;
    LMSTR   shi1_remark;
} SHARE_INFO_1, *PSHARE_INFO_1, *LPSHARE_INFO_1;

typedef struct _SHARE_INFO_2 {
    LMSTR   shi2_netname;
    DWORD   shi2_type;
    LMSTR   shi2_remark;
    DWORD   shi2_permissions;
    DWORD   shi2_max_uses;
    DWORD   shi2_current_uses;
    LMSTR   shi2_path;
    LMSTR   shi2_passwd;
} SHARE_INFO_2, *PSHARE_INFO_2, *LPSHARE_INFO_2;

typedef struct _SHARE_INFO_501 {
    LMSTR   shi501_netname;
    DWORD   shi501_type;
    LMSTR   shi501_remark;
    DWORD   shi501_flags;
} SHARE_INFO_501, *PSHARE_INFO_501, *LPSHARE_INFO_501;

typedef struct _SHARE_INFO_502 {
    LMSTR     shi502_netname;
    DWORD     shi502_type;
    LMSTR     shi502_remark;
    DWORD     shi502_permissions;
    DWORD     shi502_max_uses;
    DWORD     shi502_current_uses;
    LMSTR     shi502_path;
    LMSTR     shi502_passwd;
    DWORD     shi502_reserved;
    PSECURITY_DESCRIPTOR  shi502_security_descriptor;
} SHARE_INFO_502, *PSHARE_INFO_502, *LPSHARE_INFO_502;

typedef struct _SHARE_INFO_503 {
    LMSTR     shi503_netname;
    DWORD     shi503_type;
    LMSTR     shi503_remark;
    DWORD     shi503_permissions;
    DWORD     shi503_max_uses;
    DWORD     shi503_current_uses;
    LMSTR     shi503_path;
    LMSTR     shi503_passwd;
    LMSTR     shi503_servername;
    DWORD     shi503_reserved;
    PSECURITY_DESCRIPTOR  shi503_security_descriptor;
} SHARE_INFO_503, *PSHARE_INFO_503, *LPSHARE_INFO_503;

typedef struct _SHARE_INFO_1004 {
    LMSTR   shi1004_remark;
} SHARE_INFO_1004, *PSHARE_INFO_1004, *LPSHARE_INFO_1004;

typedef struct _SHARE_INFO_1005 {
    DWORD  shi1005_flags;
} SHARE_INFO_1005, *PSHARE_INFO_1005, *LPSHARE_INFO_1005;

typedef struct _SHARE_INFO_1006 {
    DWORD   shi1006_max_uses;
} SHARE_INFO_1006, *PSHARE_INFO_1006, *LPSHARE_INFO_1006;

typedef struct _SHARE_INFO_1501 {
    DWORD   shi1501_reserved;
    PSECURITY_DESCRIPTOR  shi1501_security_descriptor;
} SHARE_INFO_1501, *PSHARE_INFO_1501, *LPSHARE_INFO_1501;

typedef struct _SHARE_INFO_1503 {
    GUID       shi1503_sharefilter;
} SHARE_INFO_1503, *PSHARE_INFO_1503, *LPSHARE_INFO_1503;

//
// NetShareAlias functions
//
NET_API_STATUS NET_API_FUNCTION
NetServerAliasAdd(
    __in_opt IN  LMSTR   servername,
    IN  DWORD   level,
    __out_bcount(sizeof(SERVER_ALIAS_INFO_0)) IN  LPBYTE  buf
    );

NET_API_STATUS NET_API_FUNCTION
NetServerAliasDel(
    __in_opt IN  LMSTR   servername,
    IN  DWORD   level,
    IN  LPBYTE  buf
    );

NET_API_STATUS NET_API_FUNCTION
NetServerAliasEnum(
    __in_opt IN  LMSTR       servername,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    __inout_opt IN OUT LPDWORD  resumehandle
    );

typedef struct _SERVER_ALIAS_INFO_0 {
    LMSTR      srvai0_alias;
    LMSTR      srvai0_target;
    BOOLEAN    srvai0_default;
    ULONG      srvai0_reserved;
} SERVER_ALIAS_INFO_0, *PSERVER_ALIAS_INFO_0, *LPSERVER_ALIAS_INFO_0;

//
// Special Values and Constants - Share
//

//
// Values for parm_err parameter.
//

#define SHARE_NETNAME_PARMNUM         1
#define SHARE_TYPE_PARMNUM            3
#define SHARE_REMARK_PARMNUM          4
#define SHARE_PERMISSIONS_PARMNUM     5
#define SHARE_MAX_USES_PARMNUM        6
#define SHARE_CURRENT_USES_PARMNUM    7
#define SHARE_PATH_PARMNUM            8
#define SHARE_PASSWD_PARMNUM          9
#define SHARE_FILE_SD_PARMNUM       501
#define SHARE_SERVER_PARMNUM        503

//
// Single-field infolevels for NetShareSetInfo.
//

#define SHARE_REMARK_INFOLEVEL          \
            (PARMNUM_BASE_INFOLEVEL + SHARE_REMARK_PARMNUM)
#define SHARE_MAX_USES_INFOLEVEL        \
            (PARMNUM_BASE_INFOLEVEL + SHARE_MAX_USES_PARMNUM)
#define SHARE_FILE_SD_INFOLEVEL         \
            (PARMNUM_BASE_INFOLEVEL + SHARE_FILE_SD_PARMNUM)

#define SHI1_NUM_ELEMENTS       4
#define SHI2_NUM_ELEMENTS       10


//
// Share types (shi1_type and shi2_type fields).
//

#define STYPE_DISKTREE          0
#define STYPE_PRINTQ            1
#define STYPE_DEVICE            2
#define STYPE_IPC               3

#define STYPE_TEMPORARY         0x40000000
#define STYPE_SPECIAL           0x80000000

#define SHI_USES_UNLIMITED      (DWORD)-1

//
// Flags values for the 501 and 1005 levels
//
#define SHI1005_FLAGS_DFS       0x0001    // Share is in the DFS
#define SHI1005_FLAGS_DFS_ROOT  0x0002    // Share is root of DFS

#define CSC_MASK_EXT            0x2030    // Used to mask off the following states (including SHI1005_FLAGS_ENABLE_HASH)
#define CSC_MASK                0x0030    // Used to mask off the following states

#define CSC_CACHE_MANUAL_REINT  0x0000    // No automatic file by file reintegration
#define CSC_CACHE_AUTO_REINT    0x0010    // File by file reintegration is OK
#define CSC_CACHE_VDO           0x0020    // no need to flow opens
#define CSC_CACHE_NONE          0x0030    // no CSC for this share

#define SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS  0x0100          // Used to disallow read-deny read behavior
#define SHI1005_FLAGS_FORCE_SHARED_DELETE       0x0200          // Used to allows force shared delete
#define SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING   0x0400          // The clients may cache the namespace
#define SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM 0x0800        // Trim visible files in enumerations based on access
#define SHI1005_FLAGS_FORCE_LEVELII_OPLOCK      0x1000          // Only issue level2 oplock
#define SHI1005_FLAGS_ENABLE_HASH               0x2000          // Enable hash generation and retrieval requests from share

//
// The subset of 1005 infolevel flags that can be set via the API
//

#define SHI1005_VALID_FLAGS_SET    (CSC_MASK|                                   \
                                    SHI1005_FLAGS_RESTRICT_EXCLUSIVE_OPENS|     \
                                    SHI1005_FLAGS_FORCE_SHARED_DELETE|          \
                                    SHI1005_FLAGS_ALLOW_NAMESPACE_CACHING|      \
                                    SHI1005_FLAGS_ACCESS_BASED_DIRECTORY_ENUM|  \
                                    SHI1005_FLAGS_FORCE_LEVELII_OPLOCK|         \
                                    SHI1005_FLAGS_ENABLE_HASH)

#endif // _LMSHARE_

//
// SESSION API
//

#ifndef _LMSESSION_
#define _LMSESSION_

//
// Function Prototypes Session
//

NET_API_STATUS NET_API_FUNCTION
NetSessionEnum (
    __in_opt IN  LMSTR       servername OPTIONAL,
    __in_opt IN  LMSTR       UncClientName OPTIONAL,
    __in_opt IN  LMSTR       username OPTIONAL,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out_opt OUT LPDWORD     totalentries,
    __inout_opt IN OUT LPDWORD  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetSessionDel (
    __in_opt IN  LMSTR       servername OPTIONAL,
    __in_opt IN  LMSTR       UncClientName,
    __in_opt IN  LMSTR       username
    );

NET_API_STATUS NET_API_FUNCTION
NetSessionGetInfo (
    __in_opt IN  LMSTR       servername OPTIONAL,
    __in_opt IN  LMSTR       UncClientName,
    __in_opt IN  LMSTR       username,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr
    );


//
// Data Structures - Session
//

typedef struct _SESSION_INFO_0 {
    LMSTR     sesi0_cname;              // client name (no backslashes)
} SESSION_INFO_0, *PSESSION_INFO_0, *LPSESSION_INFO_0;

typedef struct _SESSION_INFO_1 {
    LMSTR     sesi1_cname;              // client name (no backslashes)
    LMSTR     sesi1_username;
    DWORD     sesi1_num_opens;
    DWORD     sesi1_time;
    DWORD     sesi1_idle_time;
    DWORD     sesi1_user_flags;
} SESSION_INFO_1, *PSESSION_INFO_1, *LPSESSION_INFO_1;

typedef struct _SESSION_INFO_2 {
    LMSTR     sesi2_cname;              // client name (no backslashes)
    LMSTR     sesi2_username;
    DWORD     sesi2_num_opens;
    DWORD     sesi2_time;
    DWORD     sesi2_idle_time;
    DWORD     sesi2_user_flags;
    LMSTR     sesi2_cltype_name;
} SESSION_INFO_2, *PSESSION_INFO_2, *LPSESSION_INFO_2;

typedef struct _SESSION_INFO_10 {
    LMSTR     sesi10_cname;             // client name (no backslashes)
    LMSTR     sesi10_username;
    DWORD     sesi10_time;
    DWORD     sesi10_idle_time;
} SESSION_INFO_10, *PSESSION_INFO_10, *LPSESSION_INFO_10;

typedef struct _SESSION_INFO_502 {
    LMSTR     sesi502_cname;             // client name (no backslashes)
    LMSTR     sesi502_username;
    DWORD     sesi502_num_opens;
    DWORD     sesi502_time;
    DWORD     sesi502_idle_time;
    DWORD     sesi502_user_flags;
    LMSTR     sesi502_cltype_name;
    LMSTR     sesi502_transport;
} SESSION_INFO_502, *PSESSION_INFO_502, *LPSESSION_INFO_502;


//
// Special Values and Constants - Session
//


//
// Bits defined in sesi1_user_flags.
//

#define SESS_GUEST          0x00000001  // session is logged on as a guest
#define SESS_NOENCRYPTION   0x00000002  // session is not using encryption

#define SESI1_NUM_ELEMENTS  8
#define SESI2_NUM_ELEMENTS  9

#endif // _LMSESSION_

//
// CONNECTION API
//

#ifndef _LMCONNECTION_

#define _LMCONNECTION_

//
// Function Prototypes - CONNECTION
//

NET_API_STATUS NET_API_FUNCTION
NetConnectionEnum (
    __in_opt IN  LMSTR   servername OPTIONAL,
    __in_opt IN  LMSTR   qualifier,
    IN  DWORD   level,
    __out OUT LPBYTE  *bufptr,
    IN  DWORD   prefmaxlen,
    __out OUT LPDWORD entriesread,
    __out OUT LPDWORD totalentries,
    __inout_opt IN OUT LPDWORD resume_handle OPTIONAL
    );

//
// Data Structures - CONNECTION
//

typedef struct _CONNECTION_INFO_0 {
    DWORD   coni0_id;
} CONNECTION_INFO_0, *PCONNECTION_INFO_0, *LPCONNECTION_INFO_0;

typedef struct _CONNECTION_INFO_1 {
    DWORD   coni1_id;
    DWORD   coni1_type;
    DWORD   coni1_num_opens;
    DWORD   coni1_num_users;
    DWORD   coni1_time;
    LMSTR   coni1_username;
    LMSTR   coni1_netname;
} CONNECTION_INFO_1, *PCONNECTION_INFO_1, *LPCONNECTION_INFO_1;

#endif // _LMCONNECTION_




//
// FILE API
//

#ifndef _LMFILE_
#define _LMFILE_

//
// Function Prototypes - FILE
//

NET_API_STATUS NET_API_FUNCTION
NetFileClose (
    __in_opt IN LMSTR    servername OPTIONAL,
    IN DWORD    fileid
    );

NET_API_STATUS NET_API_FUNCTION
NetFileEnum (
    __in_opt IN  LMSTR       servername OPTIONAL,
    __in_opt IN  LMSTR       basepath OPTIONAL,
    __in_opt IN  LMSTR       username OPTIONAL,
    IN  DWORD       level,
    __out OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out OUT LPDWORD     entriesread,
    __out OUT LPDWORD     totalentries,
    __inout_opt IN OUT PDWORD_PTR  resume_handle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetFileGetInfo (
    __in_opt IN  LMSTR   servername OPTIONAL,
    IN  DWORD   fileid,
    IN  DWORD   level,
    __out OUT LPBYTE  *bufptr
    );

//
// Data Structures - File
//

//  File APIs are available at information levels 2 & 3 only. Levels 0 &
//  1 are not supported.
//

typedef struct _FILE_INFO_2 {
    DWORD     fi2_id;
} FILE_INFO_2, *PFILE_INFO_2, *LPFILE_INFO_2;

typedef struct _FILE_INFO_3 {
    DWORD     fi3_id;
    DWORD     fi3_permissions;
    DWORD     fi3_num_locks;
    LMSTR     fi3_pathname;
    LMSTR     fi3_username;
} FILE_INFO_3, *PFILE_INFO_3, *LPFILE_INFO_3;

//
// Special Values and Constants - File
//

//
// bit values for permissions
//

#define PERM_FILE_READ      0x1 // user has read access
#define PERM_FILE_WRITE     0x2 // user has write access
#define PERM_FILE_CREATE    0x4 // user has create access


#ifdef __cplusplus
}
#endif

#endif // _LMFILE_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LpmApi.h ===
//$TAG BIZDEV
//  $IPCategory:     
//  $DealPointID:    46490
//  $AgreementName:  public license reservation protocol daemon
//  $AgreementType:  oss license
//  $ExternalOrigin: university of southern california
//$ENDTAG

//$TAG ENGR 
//  $Owner:    osmaner
//  $Module:   published_inc
//
//$ENDTAG

/*++

Copyright (c) 1998-1999  Microsoft Corporation

Module Name:

    LPMAPI.H - Include file for Local Policy Module

Abstract:

    This module defines the LPM structures and types.

Revision History:

    There is no support for ACS in Windows XP or later versions of Windows.

--*/

/****************************************************************************

            RSVPD -- ReSerVation Protocol Daemon

                USC Information Sciences Institute
                Marina del Rey, California

        Original Version: Shai Herzog, Nov. 1993.
        Current Version:  Steven Berson & Bob Braden, may 1996.

  Copyright (c) 1996 by the University of Southern California
  All rights reserved.

  Permission to use, copy, modify, and distribute this software and its
  documentation in source and binary forms for any purpose and without
  fee is hereby granted, provided that both the above copyright notice
  and this permission notice appear in all copies, and that any
  documentation, advertising materials, and other materials related to
  such distribution and use acknowledge that the software was developed
  in part by the University of Southern California, Information
  Sciences Institute.  The name of the University may not be used to
  endorse or promote products derived from this software without
  specific prior written permission.

  THE UNIVERSITY OF SOUTHERN CALIFORNIA makes no representations about
  the suitability of this software for any purpose.  THIS SOFTWARE IS
  PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED WARRANTIES,
  INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

  Other copyrights might apply to parts of this software and are so
  noted when applicable.

********************************************************************/

#ifndef __LPMAPI_H_
#define __LPMAPI_H_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C"
{
#endif


#ifndef CALLBACK
#define CALLBACK __stdcall
#endif

#ifndef APIENTRY
#define APIENTRY FAR __stdcall
#endif

/*
 *  Standard format of an RSVP object header
 */
typedef struct {

    USHORT  obj_length; /* Length in bytes */
    UCHAR   obj_class;  /* Class (values defined below) */
    UCHAR   obj_ctype;  /* C-Type (values defined below) */

} RsvpObjHdr;

#define ObjLength(x)   ((RsvpObjHdr *)x)->obj_length
#define ObjCType(x)    ((RsvpObjHdr *)x)->obj_ctype
#define ObjClass(x)    ((RsvpObjHdr *)x)->obj_class
#define ObjData(x)     ((RsvpObjHdr *)(x)+1)

/*
 *  Define object classes: Class-Num values
 */
#define class_NULL              0
#define class_SESSION           1
#define class_SESSION_GROUP     2
#define class_RSVP_HOP          3
#define class_INTEGRITY         4
#define class_TIME_VALUES       5
#define class_ERROR_SPEC        6
#define class_SCOPE             7
#define class_STYLE             8
#define class_FLOWSPEC          9   // these two are the same
#define class_IS_FLOWSPEC       9  // since we added IS in front of the name
#define class_FILTER_SPEC       10
#define class_SENDER_TEMPLATE   11
#define class_SENDER_TSPEC      12
#define class_ADSPEC            13
#define class_POLICY_DATA       14
#define class_CONFIRM           15
#define class_MAX               15

/*
 *  RSVP SESSION object
 */
#define ctype_SESSION_ipv4      1
#define ctype_SESSION_ipv4GPI   3   /* IPSEC: Generalized Port Id */

#define SESSFLG_E_Police    0x01    /* E_Police: Entry policing flag*/

typedef struct {

    IN_ADDR sess_destaddr;  // DestAddress
    UCHAR   sess_protid;    // Protocol Id
    UCHAR   sess_flags;     // Use the flags defined above
    USHORT  sess_destport;  // DestPort

} Session_IPv4;

/*    GPI versions have virtual dest port instead of dest port; this
 *    changes the interpretation but not the format, so we do not
 *    define new structs for GPI.
 */

typedef struct {

    RsvpObjHdr          sess_header;

    union {

        Session_IPv4    sess_ipv4;

    }       sess_u;

} RSVP_SESSION;

// Useful defines to access components of SESSION obect
#define Sess4Addr       sess_u.sess_ipv4.sess_destaddr
#define Sess4Port       sess_u.sess_ipv4.sess_destport
#define Sess4Protocol   sess_u.sess_ipv4.sess_protid
#define Sess4Flags      sess_u.sess_ipv4.sess_flags

/*
 *  RSVP HOP object
 */
#define ctype_RSVP_HOP_ipv4 1

typedef struct {

    IN_ADDR     hop_ipaddr; // Next/Previous Hop Address
    ULONG       hop_LIH;        // Logical Interface Handle

} Rsvp_Hop_IPv4;

typedef struct {

    RsvpObjHdr          hop_header;

    union {

        Rsvp_Hop_IPv4   hop_ipv4;

    } hop_u;

} RSVP_HOP;

#define Hop4LIH    hop_u.hop_ipv4.hop_LIH
#define Hop4Addr   hop_u.hop_ipv4.hop_ipaddr

/*
 *  RSVP STYLE object
 */

//  Define values for option vector

#define Opt_Share_mask  0x00000018  // 2 bits: Sharing control
#define Opt_Distinct    0x00000008  // Distinct reservations
#define Opt_Shared      0x00000010  // Shared reservations

#define Opt_SndSel_mask 0x00000007  // 3 bits: Sender selection
#define Opt_Wildcard    0x00000001  // Wildcard scope
#define Opt_Explicit    0x00000002  // Explicit scope

#define Style_is_Wildcard(p)    (((p)&Opt_SndSel_mask) == Opt_Wildcard)
#define Style_is_Shared(p)      (((p)&Opt_Share_mask) == Opt_Shared)

//  Define style values
#define STYLE_WF    Opt_Shared + Opt_Wildcard
#define STYLE_FF    Opt_Distinct + Opt_Explicit
#define STYLE_SE    Opt_Shared + Opt_Explicit

#define ctype_STYLE 1

typedef struct {

    RsvpObjHdr  style_header;

    ULONG       style_word;

} RESV_STYLE;

/*
 *  RSVP FILTER SPEC object
 */
#define ctype_FILTER_SPEC_ipv4      1   // IPv4 FILTER_SPEC
#define ctype_FILTER_SPEC_ipv4GPI   4   // IPv4/GPI FILTER_SPEC

typedef struct {

    IN_ADDR filt_ipaddr;    // IPv4 SrcAddress
    USHORT  filt_unused;
    USHORT  filt_port;      // SrcPort

} Filter_Spec_IPv4;

typedef struct {

    IN_ADDR filt_ipaddr;    // IPv4 SrcAddress
    ULONG   filt_gpi;       // Generalized Port Id

} Filter_Spec_IPv4GPI;

typedef struct {

    RsvpObjHdr              filt_header;

    union {

        Filter_Spec_IPv4    filt_ipv4;
        Filter_Spec_IPv4GPI filt_ipv4gpi;

    } filt_u;

} FILTER_SPEC;

#define FilterSrcaddr   filt_u.filt_ipv4.filt_ipaddr
#define FilterSrcport   filt_u.filt_ipv4.filt_port

/*
 *  RSVP SENDER_TEMPLATE object
 */
#define ctype_SENDER_TEMPLATE_ipv4      1   // IPv4 SENDER_TEMPLATE
#define ctype_SENDER_TEMPLATE_ipv4GPI   4   // IPv4/GPI SENDER_TEMPLATE

typedef FILTER_SPEC  SENDER_TEMPLATE;       // Identical to FILTER_SPEC

/*
 *  RSVP SCOPE object class
 */
#define ctype_SCOPE_list_ipv4       1

typedef struct {

    IN_ADDR     scopl_ipaddr[1];        // var-len list of IP sender addrs

} Scope_list_ipv4;

typedef struct {

    RsvpObjHdr          scopl_header;

    union {

        Scope_list_ipv4 scopl_ipv4;

    } scope_u;

} RSVP_SCOPE;

#define Scope4Addr      scope_u.scopl_ipv4.scopl_ipaddr
#define ScopeCnt(scp)   ((ObjLength(scp)-sizeof(RsvpObjHdr))/sizeof(struct in_addr))
#define ScopeLen(cnt)   (cnt*sizeof(struct in_addr)+sizeof(RsvpObjHdr))


/*
 *  ERROR_SPEC object class
 */
#define ctype_ERROR_SPEC_ipv4   1

typedef struct {
    struct in_addr  errs_errnode;   /* Error Node Address       */
    u_char      errs_flags; /* Flags:           */
#define ERROR_SPECF_InPlace 0x01    /*   Left resv in place     */
#define ERROR_SPECF_NotGuilty   0x02    /*   This rcvr not guilty   */

    UCHAR       errs_code;  /* Error Code (def'd below) */
    USHORT      errs_value; /* Error Value      */
#define ERR_FORWARD_OK  0x8000      /* Flag: OK to forward state */
#define Error_Usage(x)  (((x)>>12)&3)
#define ERR_Usage_globl 0x00        /* Globally-defined sub-code */
#define ERR_Usage_local 0x10        /* Locally-defined sub-code */
#define ERR_Usage_serv  0x11        /* Service-defined sub-code */
#define ERR_global_mask 0x0fff      /* Sub-code bits in Error Val */

}    Error_Spec_IPv4;


typedef struct {

    RsvpObjHdr  errs_header;

    union {

        Error_Spec_IPv4 errs_ipv4;

    } errs_u;

}    ERROR_SPEC;

#define errspec4_enode  errs_u.errs_ipv4.errs_errnode
#define errspec4_code   errs_u.errs_ipv4.errs_code
#define errspec4_value  errs_u.errs_ipv4.errs_value
#define errspec4_flags  errs_u.errs_ipv4.errs_flags


/*
 *  POLICY_DATA object class
 *
 *      Contents are Opaque RSVP/SBM
 */
#define ctype_POLICY_DATA   1

typedef struct {

    RsvpObjHdr      PolicyObjHdr;

    USHORT          usPeOffset;     // Offset to the start of Policy Elements
                                    // from the begining of Policy Data

    USHORT          usReserved;

} POLICY_DATA;

#define PD_HDR_LEN  sizeof(POLICY_DATA)

typedef struct {

    USHORT      usPeLength;     // Policy Element length

    USHORT      usPeType;       // Policy Element type

    UCHAR       ucPeData[4];    // Just a place holder to the start of
                                // Policy Element data
} POLICY_ELEMENT;

#define PE_HDR_LEN  (2 * sizeof(USHORT))

/**************************************************************************
 *
 *  Int-Serv Data Structures
 *
 **************************************************************************/

/*
 *  Service numbers
 */
#define GENERAL_INFO            1
#define GUARANTEED_SERV         2
#define PREDICTIVE_SERV         3
#define CONTROLLED_DELAY_SERV   4
#define CONTROLLED_LOAD_SERV    5
#define QUALITATIVE_SERV        6

/*
 *  Well-known parameter IDs
 */
enum  int_serv_wkp {
    IS_WKP_HOP_CNT =        4,
    IS_WKP_PATH_BW =        6,
    IS_WKP_MIN_LATENCY =    8,
    IS_WKP_COMPOSED_MTU =   10,
    IS_WKP_TB_TSPEC =       127, /* Token-bucket TSPEC parm */
    IS_WKP_Q_TSPEC =        128
};


/*
 *  Int-serv Main header
 */
typedef struct {

    UCHAR   ismh_version;   // Version
    UCHAR   ismh_unused;
    USHORT  ismh_len32b;    // # 32-bit words excluding this hdr

} IntServMainHdr;

#define INTSERV_VERS_MASK   0xf0
#define INTSERV_VERSION0    0
#define Intserv_Version(x)      (((x)&INTSERV_VERS_MASK)>>4)
#define Intserv_Version_OK(x)   (((x)->ismh_version&INTSERV_VERS_MASK)== \
                                INTSERV_VERSION0)

// Convert ishm_length to equivalent RSVP object size, for checking
#define Intserv_Obj_size(x) (((IntServMainHdr *)(x))->ismh_len32b * 4 + \
                            sizeof(IntServMainHdr) + sizeof(RsvpObjHdr))

/*
 *  Int-serv Service Element Header
 */

// Flag: Break bit
#define ISSH_BREAK_BIT    0x80

typedef struct {

    UCHAR       issh_service;   // Service number
    UCHAR       issh_flags;     // Flag byte
    USHORT      issh_len32b;    // #32-bit words excluding this hdr

}  IntServServiceHdr;

#define Issh_len32b(p)  ((p)->issh_len32b)

/*
 *  Int-serv Parameter Element Header
 */
#define ISPH_FLG_INV    0x80        // Flag: Invalid

typedef struct {

    UCHAR       isph_parm_num;  // Parameter number
    UCHAR       isph_flags;     // Flags
    USHORT      isph_len32b;    // #32-bit words excluding this hdr

}  IntServParmHdr;

#define Next_Main_Hdr(p)   (IntServMainHdr *)((ULONG *)(p)+1+(p)->ismh_len32b)
#define Next_Serv_Hdr(p)   (IntServServiceHdr *)((ULONG *)(p)+1+(p)->issh_len32b)
#define Next_Parm_Hdr(p)   (IntServParmHdr *)((ULONG *)(p)+1+(p)->isph_len32b)

/*
 *  Generic Tspec Parameters
 */
typedef struct {

    FLOAT       TB_Tspec_r;     // Token bucket rate (B/sec)
    FLOAT       TB_Tspec_b;     // Token bucket depth (B)
    FLOAT       TB_Tspec_p;     // Peak data rate (B/sec)
    ULONG       TB_Tspec_m;     // Min Policed Unit (B)
    ULONG       TB_Tspec_M;     // Max pkt size (B)

} GenTspecParms;

/*
 *  Generic Tspec
 */
typedef struct {

    IntServServiceHdr   gen_Tspec_serv_hdr; // (GENERAL_INFO, length)

    IntServParmHdr      gen_Tspec_parm_hdr; // (IS_WKP_TB_TSPEC)

    GenTspecParms       gen_Tspec_parms;

} GenTspec;

#define gtspec_r        gen_Tspec_parms.TB_Tspec_r
#define gtspec_b        gen_Tspec_parms.TB_Tspec_b
#define gtspec_m        gen_Tspec_parms.TB_Tspec_m
#define gtspec_M        gen_Tspec_parms.TB_Tspec_M
#define gtspec_p        gen_Tspec_parms.TB_Tspec_p
#define gtspec_parmno   gen_Tspec_parm_hdr.isph_parm_num
#define gtspec_flags    gen_Tspec_parm_hdr.isph_flags

#define gtspec_len      (sizeof(GenTspec) - sizeof(IntServServiceHdr))


/* contents of qualitative tspec */

typedef struct {

    ULONG       TB_Tspec_M;     // Max pkt size (M)

} QualTspecParms;


typedef struct {

    IntServServiceHdr   qual_Tspec_serv_hdr; // (QUALITATIVE_SERV, length)

    IntServParmHdr      qual_Tspec_parm_hdr; // (IS_WKP_Q_TSPEC)

    QualTspecParms      qual_Tspec_parms;

} QualTspec;

typedef struct {

    IntServServiceHdr   Q_spec_serv_hdr;    // (QUALITATIVE_SERV,0,len)

    IntServParmHdr      Q_spec_parm_hdr;    // (IS_WKP_Q_TSPEC)

    QualTspecParms      Q_spec_parms;       // QUALITATIVE Tspec parameters

}  QualAppFlowSpec;

#define QAspec_M        Q_spec_parms.TB_Tspec_M

/*
 *  Contents of int-serv Tspec
 */
typedef struct {

    IntServMainHdr  st_mh;

    union {

        GenTspec    gen_stspec; // Generic Tspec
        QualTspec   qual_stspec;

    } tspec_u;

} IntServTspecBody;

/*
 *  SENDER_TSPEC class object
 */
#define ctype_SENDER_TSPEC  2

typedef struct {

    RsvpObjHdr          stspec_header;

    IntServTspecBody    stspec_body;

} SENDER_TSPEC;

/*
 *  Controlled-Load Flowspec
 */
typedef struct {

    IntServServiceHdr   CL_spec_serv_hdr;    // (CONTROLLED_LOAD_SERV,0,len)

    IntServParmHdr      CL_spec_parm_hdr;    // (IS_WKP_TB_TSPEC)

    GenTspecParms       CL_spec_parms;       // GENERIC Tspec parameters

}  CtrlLoadFlowspec;

#define CLspec_r        CL_spec_parms.TB_Tspec_r
#define CLspec_b        CL_spec_parms.TB_Tspec_b
#define CLspec_p        CL_spec_parms.TB_Tspec_p
#define CLspec_m        CL_spec_parms.TB_Tspec_m
#define CLspec_M        CL_spec_parms.TB_Tspec_M
#define CLspec_parmno   CL_spec_parm_hdr.isph_parm_num
#define CLspec_flags    CL_spec_parm_hdr.isph_flags
#define CLspec_len32b   CL_spec_parm_hdr.isph_len32b

#define CLspec_len      (sizeof(CtrlLoadFlowspec) - sizeof(IntServServiceHdr))

/*  Service-specific Parameter IDs
 */
enum    {

    IS_GUAR_RSPEC =     130,

    GUAR_ADSPARM_C  =   131,
    GUAR_ADSPARM_D  =   132,
    GUAR_ADSPARM_Ctot = 133,
    GUAR_ADSPARM_Dtot = 134,
    GUAR_ADSPARM_Csum = 135,
    GUAR_ADSPARM_Dsum = 136

};

/*
 *  Guaranteed Rspec parameters
 */
typedef struct {

    FLOAT       Guar_R;         //  Guaranteed Rate B/s
    ULONG       Guar_S;         //  Slack term secs

} GuarRspec;

/*
 *  Guaranteed Flowspec
 */
typedef struct {

    IntServServiceHdr   Guar_serv_hdr;      // (GUARANTEED, 0, length)

    IntServParmHdr      Guar_Tspec_hdr;     // (IS_WKP_TB_TSPEC,)
    GenTspecParms       Guar_Tspec_parms;   // GENERIC Tspec parms

    IntServParmHdr      Guar_Rspec_hdr;     // (IS_GUAR_RSPEC)
    GuarRspec           Guar_Rspec;         // Guaranteed rate (B/sec)

}   GuarFlowSpec;

#define Gspec_r         Guar_Tspec_parms.TB_Tspec_r
#define Gspec_b         Guar_Tspec_parms.TB_Tspec_b
#define Gspec_p         Guar_Tspec_parms.TB_Tspec_p
#define Gspec_m         Guar_Tspec_parms.TB_Tspec_m
#define Gspec_M         Guar_Tspec_parms.TB_Tspec_M
#define Gspec_R         Guar_Rspec.Guar_R
#define Gspec_S         Guar_Rspec.Guar_S
#define Gspec_T_parmno  Guar_Tspec_hdr.isph_parm_num
#define Gspec_T_flags   Guar_Tspec_hdr.isph_flags
#define Gspec_R_parmno  Guar_Rspec_hdr.isph_parm_num
#define Gspec_R_flags   Guar_Rspec_hdr.isph_flags

#define Gspec_len       (sizeof(GuarFlowSpec) - sizeof(IntServServiceHdr))

/*
 *  Contents of int-serv flowspec
 */
typedef struct {

    IntServMainHdr          spec_mh;

    union {

        CtrlLoadFlowspec    CL_spec;   // Controlled-Load service

        GuarFlowSpec        G_spec;    // Guaranteed service
        
        QualAppFlowSpec     Q_spec;
        
    } spec_u;

}   IntServFlowSpec;

#define ISmh_len32b     spec_mh.ismh_len32b
#define ISmh_version    spec_mh.ismh_version
#define ISmh_unused     spec_mh.ismh_unused

/*
 *  Int-Serv FLOWSPEC object
 */
#define ctype_FLOWSPEC_Intserv0  2  // The int-serv flowspec (v.0)

typedef struct {

    RsvpObjHdr          flow_header;

    IntServFlowSpec     flow_body;

}IS_FLOWSPEC;


/*
 *  FLOW DESCRIPTOR
 */

typedef struct flow_desc {

    union {
        SENDER_TSPEC   *stspec;
        IS_FLOWSPEC    *isflow;
    } u1;

    union {
       SENDER_TEMPLATE *stemp;
       FILTER_SPEC     *fspec;
    } u2;

} FLOW_DESC;

#define FdSenderTspec       u1.stspec
#define FdIsFlowSpec        u1.isflow

#define FdSenderTemplate    u2.stemp
#define FdFilterSpec        u2.fspec

/*
 *  ADSPEC class object
 *
 *      Opaque to RSVP -- Contents defined in rapi_lib.h
 */
#define ctype_ADSPEC_INTSERV    2

/*
 *  Guaranteed service Adspec parameters -- fixed part
 */
typedef struct {

    IntServServiceHdr   Gads_serv_hdr;  // GUARANTEED, x, len
    
    IntServParmHdr      Gads_Ctot_hdr;  // GUAR_ADSPARM_Ctot
    ULONG               Gads_Ctot;
    
    IntServParmHdr      Gads_Dtot_hdr;  // (GUAR_ADSPARM_Dtot
    ULONG               Gads_Dtot;
    
    IntServParmHdr      Gads_Csum_hdr;  // GUAR_ADSPARM_Csum
    ULONG               Gads_Csum;
    
    IntServParmHdr      Gads_Dsum_hdr;  // GUAR_ADSPARM_Dsum
    ULONG               Gads_Dsum;
    
    /*
     *  May be followed by override general param values
     */
} Gads_parms_t;


/*
 *  General Path Characterization Parameters
 */
typedef struct {

    IntServServiceHdr   gen_parm_hdr;           // GENERAL_INFO, len

    IntServParmHdr      gen_parm_hopcnt_hdr;    // (IS_WKP_HOP_CNT
    ULONG               gen_parm_hopcnt;

    IntServParmHdr      gen_parm_pathbw_hdr;    // IS_WKP_PATH_BW
    FLOAT               gen_parm_path_bw;

    IntServParmHdr      gen_parm_minlat_hdr;    // IS_WKP_MIN_LATENCY
    ULONG               gen_parm_min_latency;

    IntServParmHdr      gen_parm_compmtu_hdr;   // IS_WKP_COMPOSED_MTU 
    ULONG               gen_parm_composed_MTU;
    
} GenAdspecParams;

/*
 *  Contents of (minimal) int-serv Adspec
 */
typedef struct {
    IntServMainHdr      adspec_mh;      // Main header
    
    GenAdspecParams     adspec_genparms;// General char parm fragment
    
    /*
     *  Followed by variable-length fragments for some or all
     *  services.  These can be minimal length fragments.
     */
     
} IS_ADSPEC_BODY;


#define GEN_ADSPEC_LEN (sizeof(Object_header) + sizeof(IS_adsbody_t ) )

typedef struct {

    RsvpObjHdr      adspec_header;
    
    IS_ADSPEC_BODY  adspec_body;    /* Defined in rapi_lib.h */

} ADSPEC;


// RSVP message types

#define RSVP_PATH       1
#define RSVP_RESV       2
#define RSVP_PATH_ERR   3
#define RSVP_RESV_ERR   4
#define RSVP_PATH_TEAR  5
#define RSVP_RESV_TEAR  6

/*  RSVP error codes
 */
#define RSVP_Err_NONE       0   /* No error (CONFIRM)       */
#define RSVP_Erv_Nonev      0   /*    No-error Error Value  */

/* Admission Control failure    */
#define RSVP_Err_ADMISSION  1

/* Globally-defined sub-codes for : Admission Control failure */
#define RSVP_Erv_Other      0   /* Unspecified cause        */
#define RSVP_Erv_DelayBnd   1   /* Cannot meet delay bound req  */
#define RSVP_Erv_Bandwidth  2   /* Insufficient bandwidth   */
#define RSVP_Erv_MTU        3   /* MTU in flowspec too large    */

// Microsoft specific error values
#define RSVP_Erv_Flow_Rate          0x8001
#define RSVP_Erv_Bucket_szie        0x8002
#define RSVP_Erv_Peak_Rate          0x8003
#define RSVP_Erv_Min_Policied_size  0x8004

/* Policy control failure   */
#define RSVP_Err_POLICY     2

// Policy error values from Identity draft
#define POLICY_ERRV_NO_MORE_INFO                1
#define POLICY_ERRV_UNSUPPORTED_CREDENTIAL_TYPE 2
#define POLICY_ERRV_INSUFFICIENT_PRIVILEGES     3
#define POLICY_ERRV_EXPIRED_CREDENTIALS         4
#define POLICY_ERRV_IDENTITY_CHANGED            5

// Microsoft specific policy error values

#define POLICY_ERRV_UNKNOWN                         0

#define POLICY_ERRV_GLOBAL_DEF_FLOW_COUNT           1
#define POLICY_ERRV_GLOBAL_GRP_FLOW_COUNT           2
#define POLICY_ERRV_GLOBAL_USER_FLOW_COUNT          3
#define POLICY_ERRV_GLOBAL_UNAUTH_USER_FLOW_COUNT   4
#define POLICY_ERRV_SUBNET_DEF_FLOW_COUNT           5
#define POLICY_ERRV_SUBNET_GRP_FLOW_COUNT           6
#define POLICY_ERRV_SUBNET_USER_FLOW_COUNT          7
#define POLICY_ERRV_SUBNET_UNAUTH_USER_FLOW_COUNT   8

#define POLICY_ERRV_GLOBAL_DEF_FLOW_DURATION        9
#define POLICY_ERRV_GLOBAL_GRP_FLOW_DURATION        10
#define POLICY_ERRV_GLOBAL_USER_FLOW_DURATION       11
#define POLICY_ERRV_GLOBAL_UNAUTH_USER_FLOW_DURATION 12
#define POLICY_ERRV_SUBNET_DEF_FLOW_DURATION        13
#define POLICY_ERRV_SUBNET_GRP_FLOW_DURATION        14
#define POLICY_ERRV_SUBNET_USER_FLOW_DURATION       15
#define POLICY_ERRV_SUBNET_UNAUTH_USER_FLOW_DURATION   16

#define POLICY_ERRV_GLOBAL_DEF_FLOW_RATE            17
#define POLICY_ERRV_GLOBAL_GRP_FLOW_RATE            18
#define POLICY_ERRV_GLOBAL_USER_FLOW_RATE           19
#define POLICY_ERRV_GLOBAL_UNAUTH_USER_FLOW_RATE    20
#define POLICY_ERRV_SUBNET_DEF_FLOW_RATE            21
#define POLICY_ERRV_SUBNET_GRP_FLOW_RATE            22
#define POLICY_ERRV_SUBNET_USER_FLOW_RATE           23
#define POLICY_ERRV_SUBNET_UNAUTH_USER_FLOW_RATE    24

#define POLICY_ERRV_GLOBAL_DEF_PEAK_RATE            25
#define POLICY_ERRV_GLOBAL_GRP_PEAK_RATE            26
#define POLICY_ERRV_GLOBAL_USER_PEAK_RATE           27
#define POLICY_ERRV_GLOBAL_UNAUTH_USER_PEAK_RATE    28
#define POLICY_ERRV_SUBNET_DEF_PEAK_RATE            29
#define POLICY_ERRV_SUBNET_GRP_PEAK_RATE            30
#define POLICY_ERRV_SUBNET_USER_PEAK_RATE           31
#define POLICY_ERRV_SUBNET_UNAUTH_USER_PEAK_RATE    32

#define POLICY_ERRV_GLOBAL_DEF_SUM_FLOW_RATE        33
#define POLICY_ERRV_GLOBAL_GRP_SUM_FLOW_RATE        34
#define POLICY_ERRV_GLOBAL_USER_SUM_FLOW_RATE       35
#define POLICY_ERRV_GLOBAL_UNAUTH_USER_SUM_FLOW_RATE 36
#define POLICY_ERRV_SUBNET_DEF_SUM_FLOW_RATE        37
#define POLICY_ERRV_SUBNET_GRP_SUM_FLOW_RATE        38
#define POLICY_ERRV_SUBNET_USER_SUM_FLOW_RATE       39
#define POLICY_ERRV_SUBNET_UNAUTH_USER_SUM_FLOW_RATE 40

#define POLICY_ERRV_GLOBAL_DEF_SUM_PEAK_RATE        41
#define POLICY_ERRV_GLOBAL_GRP_SUM_PEAK_RATE        42
#define POLICY_ERRV_GLOBAL_USER_SUM_PEAK_RATE       43
#define POLICY_ERRV_GLOBAL_UNAUTH_USER_SUM_PEAK_RATE 44
#define POLICY_ERRV_SUBNET_DEF_SUM_PEAK_RATE        45
#define POLICY_ERRV_SUBNET_GRP_SUM_PEAK_RATE        46
#define POLICY_ERRV_SUBNET_USER_SUM_PEAK_RATE       47
#define POLICY_ERRV_SUBNET_UNAUTH_USER_SUM_PEAK_RATE 48

#define POLICY_ERRV_UNKNOWN_USER                    49
#define POLICY_ERRV_NO_PRIVILEGES                   50
#define POLICY_ERRV_EXPIRED_USER_TOKEN              51
#define POLICY_ERRV_NO_RESOURCES                    52
#define POLICY_ERRV_PRE_EMPTED                      53
#define POLICY_ERRV_USER_CHANGED                    54
#define POLICY_ERRV_NO_ACCEPTS                      55
#define POLICY_ERRV_NO_MEMORY                       56
#define POLICY_ERRV_CRAZY_FLOWSPEC                  57


// Other RSVP defined Error codes
#define RSVP_Err_NO_PATH        3   /* No path state for Resv   */
#define RSVP_Err_NO_SENDER      4   /* No sender info for Resv  */
#define RSVP_Err_BAD_STYLE      5   /* Conflicting style        */
#define RSVP_Err_UNKNOWN_STYLE  6   /* Unknown reservation style    */
#define RSVP_Err_BAD_DSTPORT    7   /* Conflicting DstPort in Sess  */
#define RSVP_Err_BAD_SNDPORT    8   /* Conflicting Sender port  */
#define RSVP_Err_AMBIG_FILTER   9   /* Ambiguous Filter spec in Resv*/

#define RSVP_Err_PREEMPTED      12  /* Service Preempted        */

/* Unknown object Class-Num */
#define RSVP_Err_UNKN_OBJ_CLASS 13
/*   ErrVal = Class_num, CType  */

 /* Unknown object C-Type    */
#define RSVP_Err_UNKNOWN_CTYPE  14
/*   ErrVal = Class_num, CType  */

#define RSVP_Err_API_ERROR      20  /* API client error     */
/*   ErrVal = API error code    */

/* Traffic Control error    */
#define RSVP_Err_TC_ERROR       21

/* Globally-defined sub-codes for : Traffic Control errors */

#define RSVP_Erv_Conflict_Serv  01  /* Service Conflict     */
#define RSVP_Erv_No_Serv        02  /* Unknown Service      */
#define RSVP_Erv_Crazy_Flowspec 03  /* Unreasonable Flowspec    */
#define RSVP_Erv_Crazy_Tspec    04  /* Unreasonable Tspec       */

#define RSVP_Err_TC_SYS_ERROR   22  /* Traffic control system error */
      /* ErrVal = kernel error code   */


/* RSVP System error      */
#define RSVP_Err_RSVP_SYS_ERROR 23

/* Globally-defined sub-codes for : RSVP system errors */
#define RSVP_Erv_MEMORY         1   /* Out of memory */
#define RSVP_Erv_API            2   /* API logic error */

// Identity Policy elements related defines

// Reseved Identity PE types
#define LPM_PE_USER_IDENTITY    2
#define LPM_PE_APP_IDENTITY     3

// Defines for Identity error values
#define ERROR_NO_MORE_INFO          1
#define UNSUPPORTED_CREDENTIAL_TYPE 2
#define INSUFFICIENT_PRIVILEGES     3
#define EXPIRED_CREDENTIAL          4
#define IDENTITY_CHANGED            5


typedef struct {

    USHORT      usIdErrLength;

    UCHAR       ucAType;

    UCHAR       ucSubType;

    USHORT      usReserved;

    USHORT      usIdErrorValue;

    UCHAR       ucIdErrData[4];

} ID_ERROR_OBJECT;

    
#define ID_ERR_OBJ_HDR_LEN     (sizeof(ID_ERROR_OBJECT) - 4 * sizeof(UCHAR) )


/*

    LPM API specific definitions

*/

/**************************************

    LPM_Initialize

***************************************/

DECLARE_HANDLE(LPM_HANDLE);

DECLARE_HANDLE(RHANDLE);

typedef ULONG   LPV;

typedef USHORT  PETYPE;

#define LPM_OK  0

typedef int     MSG_TYPE;

typedef struct rsvpmsgobjs {

    MSG_TYPE        RsvpMsgType;
    
    RSVP_SESSION    *pRsvpSession;
    
    RSVP_HOP        *pRsvpFromHop;
    
    RSVP_HOP        *pRsvpToHop;
    
    RESV_STYLE      *pResvStyle;
    
    RSVP_SCOPE      *pRsvpScope;
    
    int             FlowDescCount;
    
    FLOW_DESC       *pFlowDescs;
    
    int             PdObjectCount;
    
    POLICY_DATA     **ppPdObjects;
    
    ERROR_SPEC      *pErrorSpec;

    ADSPEC          *pAdspec;
    
} RSVP_MSG_OBJS;

#if DBG
typedef void *
(APIENTRY * PALLOCMEM) ( DWORD Size, char *szFileName, DWORD nLine );
#else
typedef void *
(APIENTRY * PALLOCMEM) ( DWORD Size );
#endif

#if DBG
typedef void
(APIENTRY * PFREEMEM) ( void *pv, char *szFileName, DWORD nLine );
#else
typedef void
(APIENTRY * PFREEMEM) ( void *pv );
#endif

typedef struct policy_decision
{
    LPV             lpvResult;        // Use the LPV values from above
    
    WORD            wPolicyErrCode;   // RSVP defined error codes
    
    WORD            wPolicyErrValue;  // RSVP defined error values
    
} POLICY_DECISION;

typedef
ULONG *
(CALLBACK * CBADMITRESULT) (    
        LPM_HANDLE      LpmHandle,
        
        RHANDLE         RequestHandle,

        ULONG           ulPcmActionFlags,
    
        int             LpmError,
        
        int             PolicyDecisionsCount,
        
        POLICY_DECISION *pPolicyDecisions );

typedef
ULONG *
(CALLBACK * CBGETRSVPOBJECTS) (  

        LPM_HANDLE  LpmHandle,
        
        RHANDLE     RequestHandle,
        
        int         LpmError,
        
        int         RsvpObjectsCount,

        RsvpObjHdr  **ppRsvpObjects );

// The above 2 call backs can return the following errors

#define INV_LPM_HANDLE      1       // Supplied LpmHandle is invalid
#define LPM_TIME_OUT        2       // LPM has returned results after the time limit
#define INV_REQ_HANDLE      3       // Supplied Request handle is invalid
#define DUP_RESULTS         4       // LPM has already returned results for this request
#define INV_RESULTS         5       // Results supplied are invalid

typedef struct lpminitinfo {

    DWORD           PcmVersionNumber;
    
    DWORD           ResultTimeLimit;
    
    int             ConfiguredLpmCount;
    
    PALLOCMEM       AllocMemory;
    
    PFREEMEM        FreeMemory;
    
    CBADMITRESULT   PcmAdmitResultCallback;
    
    CBGETRSVPOBJECTS GetRsvpObjectsCallback;
    
} LPM_INIT_INFO;

// Valid PE types
// XXX ISSUE - Is 0xFFFF a better choice?
#define LPM_PE_ALL_TYPES        0

// Current LPM API version number
#define LPM_API_VERSION_1        1

// Current PCM version number
#define PCM_VERSION_1    1

ULONG
APIENTRY
LPM_Initialize (

    IN  LPM_HANDLE      LpmHandle,
    
    IN  LPM_INIT_INFO   *pLpmInitInfo,
    
    OUT DWORD           *pLpmVersionNumber,
    
    OUT PETYPE          *pSupportedPeType,
    
    OUT VOID            *Reserved );

/**************************************

    LPM_Deiitialize
    
***************************************/

ULONG
APIENTRY
LPM_Deinitialize (    
    IN  LPM_HANDLE      LpmHandle );
            

/**************************************

    LPM_AdmitRsvpMsg

***************************************/

// Valid LPV - LPM Priority Values
#define LPV_RESERVED        0
#define LPV_MIN_PRIORITY    1
#define LPV_MAX_PRIORITY    0xFF00
#define LPV_DROP_MSG        0xFFFD
#define LPV_DONT_CARE       0xFFFE
#define LPV_REJECT          0xFFFF

// Valid values for PcmActionFlags
#define FORCE_IMMEDIATE_REFRESH         1

// Function return values for LPM_AdmitResvMsg
#define LPM_RESULT_READY    0
#define LPM_RESULT_DEFER    1

ULONG
APIENTRY
LPM_AdmitRsvpMsg (

    IN  RHANDLE         PcmReqHandle,
    
    IN  RSVP_HOP        *pRecvdIntf,
    
    IN  RSVP_MSG_OBJS   *pRsvpMsgObjs,
    
    IN  int             RcvdRsvpMsgLength,
    
    IN  UCHAR           *RcvdRsvpMsg,

    OUT ULONG           *pulPcmActionFlags,
    
    OUT POLICY_DECISION *pPolicyDecisions,
    
    OUT void            *Reserved );


/**************************************

    LPM_GetRsvpObjects

***************************************/

// Function return values are defined in LPM_AdmitResvMsg section

ULONG
APIENTRY
LPM_GetRsvpObjects (

    IN  RHANDLE         PcmReqHandle,
    
    IN  ULONG           MaxPdSize,
    
    IN  RSVP_HOP        *SendingIntfAddr,
    
    IN  RSVP_MSG_OBJS   *pRsvpMsgObjs,
    
    OUT int             *pRsvpObjectsCount,

    OUT RsvpObjHdr      ***pppRsvpObjects,
    
    OUT void            *Reserved );


/**************************************

    LPM_DeleteState

***************************************/

// TearDown reasons

#define RCVD_PATH_TEAR      1
#define RCVD_RESV_TEAR      2
#define ADM_CTRL_FAILED     3
#define STATE_TIMEOUT       4
#define FLOW_DURATION       5


VOID
APIENTRY
LPM_DeleteState(

    IN  RSVP_HOP        *pRcvdIfAddr,
    
    IN  MSG_TYPE        RsvpMsgType,
    
    IN  RSVP_SESSION    *pRsvpSession,
    
    IN  RSVP_HOP        *pRsvpFromHop,
    
    IN  RESV_STYLE      *pResvStyle,
    
    IN  int             FilterSpecCount,
    
    IN  FILTER_SPEC     **ppFilterSpecList,
    
    IN  int             TearDownReason );

/**************************************

    LPM_IpAddrTable

***************************************/

typedef struct lpmiptable {

    ULONG       ulIfIndex;  // SNMP index for this interface

    ULONG       MediaType;  // As defined in IPIFCONS.H

    IN_ADDR     IfIpAddr;   // Interface IP address

    IN_ADDR     IfNetMask;  // Interface subnet mask

} LPMIPTABLE;

BOOL
APIENTRY
LPM_IpAddressTable (

    IN  ULONG       cIpAddrTable,
    
    IN  LPMIPTABLE  *pIpAddrTable );


/**************************************

    LPM_CommitResv

***************************************/

// CommitDecision values

#define RESOURCES_ALLOCATED             1
#define RESOURCES_MODIFIED              2

VOID
APIENTRY
LPM_CommitResv (

    IN  RSVP_SESSION    *RsvpSession,
    
    IN  RSVP_HOP        *FlowInstalledIntf,
    
    IN  RESV_STYLE      *RsvpStyle,
    
    IN  int             FilterSpecCount,
    
    IN  FILTER_SPEC     **ppFilterSpecList,
    
    IN  IS_FLOWSPEC     *pMergedFlowSpec,
    
    IN  ULONG           CommitDecision );


#ifdef __cplusplus
}
#endif


#endif // __LPMAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\lowlevelmonitorconfigurationapi.h ===
#ifndef LowLevelMonitorConfigurationAPI_h
#define LowLevelMonitorConfigurationAPI_h

#include <PhysicalMonitorEnumerationAPI.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus 

#pragma pack( push, 1  )

typedef struct _MC_TIMING_REPORT
{
    DWORD dwHorizontalFrequencyInHZ;
    DWORD dwVerticalFrequencyInHZ;
    BYTE bTimingStatusByte;

} MC_TIMING_REPORT, *LPMC_TIMING_REPORT;

typedef enum _MC_VCP_CODE_TYPE
{
    MC_MOMENTARY,
    MC_SET_PARAMETER

} MC_VCP_CODE_TYPE, *LPMC_VCP_CODE_TYPE;

_BOOL WINAPI GetVCPFeatureAndVCPFeatureReply
    (
    HANDLE hMonitor,
    BYTE bVCPCode,
    __out_opt LPMC_VCP_CODE_TYPE pvct,
    __out LPDWORD pdwCurrentValue, 
    __out_opt LPDWORD pdwMaximumValue
    );

_BOOL WINAPI SetVCPFeature( HANDLE hMonitor, BYTE bVCPCode, DWORD dwNewValue );

_BOOL WINAPI SaveCurrentSettings( HANDLE hMonitor );

_BOOL WINAPI GetCapabilitiesStringLength( HANDLE hMonitor, __out LPDWORD pdwCapabilitiesStringLengthInCharacters );

_BOOL WINAPI CapabilitiesRequestAndCapabilitiesReply 
    (
    HANDLE hMonitor, 
    __out_ecount(dwCapabilitiesStringLengthInCharacters) LPSTR pszASCIICapabilitiesString, 
    DWORD dwCapabilitiesStringLengthInCharacters
    );

_BOOL WINAPI GetTimingReport( HANDLE hMonitor, __out LPMC_TIMING_REPORT pmtrMonitorTimingReport );

#pragma pack( pop )

#ifdef __cplusplus
}
#endif // __cplusplus 

#endif // LowLevelMonitorConfigurationAPI_h
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LZExpand.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    lzexpand.h

Abstract:

    Public interface to LZEXP?.LIB.

Author:


Revision History:

--*/

#ifndef _LZEXPAND_
#define _LZEXPAND_

#ifdef __cplusplus
extern "C" {
#endif

/*
** Error Return Codes
*/

#define LZERROR_BADINHANDLE   (-1)  /* invalid input handle */
#define LZERROR_BADOUTHANDLE  (-2)  /* invalid output handle */
#define LZERROR_READ          (-3)  /* corrupt compressed file format */
#define LZERROR_WRITE         (-4)  /* out of space for output file */
#define LZERROR_GLOBALLOC     (-5)  /* insufficient memory for LZFile struct */
#define LZERROR_GLOBLOCK      (-6)  /* bad global handle */
#define LZERROR_BADVALUE      (-7)  /* input parameter out of acceptable range*/
#define LZERROR_UNKNOWNALG    (-8)  /* compression algorithm not recognized */


/*
** Prototypes
*/

__success(return >= 0)
__checkReturn
INT
APIENTRY
LZStart(
    VOID
    );

VOID
APIENTRY
LZDone(
    VOID
    );


__success(return >= 0)
__checkReturn
LONG
APIENTRY
CopyLZFile(
    __in INT hfSource,
    __in INT hfDest
    );

__success(return >= 0)
__checkReturn
LONG
APIENTRY
LZCopy(
    __in INT hfSource,
    __in INT hfDest
    );

__success(return >= 0)
__checkReturn
INT
APIENTRY
LZInit(
    __in INT hfSource
    );

__success(return >= 0)
__checkReturn
INT
APIENTRY
GetExpandedNameA(
    __in LPSTR lpszSource,
    __out_ecount(MAX_PATH) LPSTR lpszBuffer
    );
__success(return >= 0)
__checkReturn
INT
APIENTRY
GetExpandedNameW(
    __in LPWSTR lpszSource,
    __out_ecount(MAX_PATH) LPWSTR lpszBuffer
    );
#ifdef UNICODE
#define GetExpandedName  GetExpandedNameW
#else
#define GetExpandedName  GetExpandedNameA
#endif // !UNICODE

__success(return >= 0)
__checkReturn
INT
APIENTRY
LZOpenFileA(
    __in LPSTR lpFileName,
    __inout LPOFSTRUCT lpReOpenBuf,
    __in WORD wStyle
    );
__success(return >= 0)
__checkReturn
INT
APIENTRY
LZOpenFileW(
    __in LPWSTR lpFileName,
    __inout LPOFSTRUCT lpReOpenBuf,
    __in WORD wStyle
    );
#ifdef UNICODE
#define LZOpenFile  LZOpenFileW
#else
#define LZOpenFile  LZOpenFileA
#endif // !UNICODE

__success(return >= 0)
__checkReturn
LONG
APIENTRY
LZSeek(
    __in INT hFile,
    __in LONG lOffset,
    __in INT iOrigin
    );

__success(return >= 0)
__checkReturn
INT
APIENTRY
LZRead(
    __in INT hFile,
    __out_bcount_part(cbRead, return) CHAR* lpBuffer,
    __in INT cbRead
    );

VOID
APIENTRY
LZClose(
    __in INT hFile
    );

#ifdef __cplusplus
}
#endif


#endif // _LZEXPAND_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\locationapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for locationapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __locationapi_h__
#define __locationapi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ILocationReport_FWD_DEFINED__
#define __ILocationReport_FWD_DEFINED__
typedef interface ILocationReport ILocationReport;
#endif 	/* __ILocationReport_FWD_DEFINED__ */


#ifndef __ILatLongReport_FWD_DEFINED__
#define __ILatLongReport_FWD_DEFINED__
typedef interface ILatLongReport ILatLongReport;
#endif 	/* __ILatLongReport_FWD_DEFINED__ */


#ifndef __ICivicAddressReport_FWD_DEFINED__
#define __ICivicAddressReport_FWD_DEFINED__
typedef interface ICivicAddressReport ICivicAddressReport;
#endif 	/* __ICivicAddressReport_FWD_DEFINED__ */


#ifndef __ILocation_FWD_DEFINED__
#define __ILocation_FWD_DEFINED__
typedef interface ILocation ILocation;
#endif 	/* __ILocation_FWD_DEFINED__ */


#ifndef __IDefaultLocation_FWD_DEFINED__
#define __IDefaultLocation_FWD_DEFINED__
typedef interface IDefaultLocation IDefaultLocation;
#endif 	/* __IDefaultLocation_FWD_DEFINED__ */


#ifndef __ILocationEvents_FWD_DEFINED__
#define __ILocationEvents_FWD_DEFINED__
typedef interface ILocationEvents ILocationEvents;
#endif 	/* __ILocationEvents_FWD_DEFINED__ */


#ifndef __IDispLatLongReport_FWD_DEFINED__
#define __IDispLatLongReport_FWD_DEFINED__
typedef interface IDispLatLongReport IDispLatLongReport;
#endif 	/* __IDispLatLongReport_FWD_DEFINED__ */


#ifndef __IDispCivicAddressReport_FWD_DEFINED__
#define __IDispCivicAddressReport_FWD_DEFINED__
typedef interface IDispCivicAddressReport IDispCivicAddressReport;
#endif 	/* __IDispCivicAddressReport_FWD_DEFINED__ */


#ifndef __ILocationReportFactory_FWD_DEFINED__
#define __ILocationReportFactory_FWD_DEFINED__
typedef interface ILocationReportFactory ILocationReportFactory;
#endif 	/* __ILocationReportFactory_FWD_DEFINED__ */


#ifndef __ILatLongReportFactory_FWD_DEFINED__
#define __ILatLongReportFactory_FWD_DEFINED__
typedef interface ILatLongReportFactory ILatLongReportFactory;
#endif 	/* __ILatLongReportFactory_FWD_DEFINED__ */


#ifndef __ICivicAddressReportFactory_FWD_DEFINED__
#define __ICivicAddressReportFactory_FWD_DEFINED__
typedef interface ICivicAddressReportFactory ICivicAddressReportFactory;
#endif 	/* __ICivicAddressReportFactory_FWD_DEFINED__ */


#ifndef __Location_FWD_DEFINED__
#define __Location_FWD_DEFINED__

#ifdef __cplusplus
typedef class Location Location;
#else
typedef struct Location Location;
#endif /* __cplusplus */

#endif 	/* __Location_FWD_DEFINED__ */


#ifndef __DefaultLocation_FWD_DEFINED__
#define __DefaultLocation_FWD_DEFINED__

#ifdef __cplusplus
typedef class DefaultLocation DefaultLocation;
#else
typedef struct DefaultLocation DefaultLocation;
#endif /* __cplusplus */

#endif 	/* __DefaultLocation_FWD_DEFINED__ */


#ifndef __LatLongReport_FWD_DEFINED__
#define __LatLongReport_FWD_DEFINED__

#ifdef __cplusplus
typedef class LatLongReport LatLongReport;
#else
typedef struct LatLongReport LatLongReport;
#endif /* __cplusplus */

#endif 	/* __LatLongReport_FWD_DEFINED__ */


#ifndef __CivicAddressReport_FWD_DEFINED__
#define __CivicAddressReport_FWD_DEFINED__

#ifdef __cplusplus
typedef class CivicAddressReport CivicAddressReport;
#else
typedef struct CivicAddressReport CivicAddressReport;
#endif /* __cplusplus */

#endif 	/* __CivicAddressReport_FWD_DEFINED__ */


#ifndef ___ILatLongReportFactoryEvents_FWD_DEFINED__
#define ___ILatLongReportFactoryEvents_FWD_DEFINED__
typedef interface _ILatLongReportFactoryEvents _ILatLongReportFactoryEvents;
#endif 	/* ___ILatLongReportFactoryEvents_FWD_DEFINED__ */


#ifndef ___ICivicAddressReportFactoryEvents_FWD_DEFINED__
#define ___ICivicAddressReportFactoryEvents_FWD_DEFINED__
typedef interface _ICivicAddressReportFactoryEvents _ICivicAddressReportFactoryEvents;
#endif 	/* ___ICivicAddressReportFactoryEvents_FWD_DEFINED__ */


#ifndef __LatLongReportFactory_FWD_DEFINED__
#define __LatLongReportFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class LatLongReportFactory LatLongReportFactory;
#else
typedef struct LatLongReportFactory LatLongReportFactory;
#endif /* __cplusplus */

#endif 	/* __LatLongReportFactory_FWD_DEFINED__ */


#ifndef __CivicAddressReportFactory_FWD_DEFINED__
#define __CivicAddressReportFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class CivicAddressReportFactory CivicAddressReportFactory;
#else
typedef struct CivicAddressReportFactory CivicAddressReportFactory;
#endif /* __cplusplus */

#endif 	/* __CivicAddressReportFactory_FWD_DEFINED__ */


#ifndef __DispLatLongReport_FWD_DEFINED__
#define __DispLatLongReport_FWD_DEFINED__

#ifdef __cplusplus
typedef class DispLatLongReport DispLatLongReport;
#else
typedef struct DispLatLongReport DispLatLongReport;
#endif /* __cplusplus */

#endif 	/* __DispLatLongReport_FWD_DEFINED__ */


#ifndef __DispCivicAddressReport_FWD_DEFINED__
#define __DispCivicAddressReport_FWD_DEFINED__

#ifdef __cplusplus
typedef class DispCivicAddressReport DispCivicAddressReport;
#else
typedef struct DispCivicAddressReport DispCivicAddressReport;
#endif /* __cplusplus */

#endif 	/* __DispCivicAddressReport_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "SensorsApi.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_locationapi_0000_0000 */
/* [local] */ 

#include <SensorsApi.h>
#include <initguid.h>
#include <propkeydef.h>
#define LOCATION_API_VERSION    1
typedef 
enum LOCATION_REPORT_STATUS
    {	REPORT_NOT_SUPPORTED	= 0,
	REPORT_ERROR	= 1,
	REPORT_ACCESS_DENIED	= 2,
	REPORT_INITIALIZING	= 3,
	REPORT_RUNNING	= 4
    } 	LOCATION_REPORT_STATUS;






extern RPC_IF_HANDLE __MIDL_itf_locationapi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_locationapi_0000_0000_v0_0_s_ifspec;

#ifndef __ILocationReport_INTERFACE_DEFINED__
#define __ILocationReport_INTERFACE_DEFINED__

/* interface ILocationReport */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILocationReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C8B7F7EE-75D0-4db9-B62D-7A0F369CA456")
    ILocationReport : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetSensorID( 
            /* [retval][out] */ __RPC__out SENSOR_ID *pSensorID) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTimestamp( 
            /* [retval][out] */ __RPC__out SYSTEMTIME *pCreationTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetValue( 
            /* [in] */ __RPC__in REFPROPERTYKEY pKey,
            /* [retval][out] */ __RPC__out PROPVARIANT *pValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocationReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILocationReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILocationReport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILocationReport * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSensorID )( 
            __RPC__in ILocationReport * This,
            /* [retval][out] */ __RPC__out SENSOR_ID *pSensorID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTimestamp )( 
            __RPC__in ILocationReport * This,
            /* [retval][out] */ __RPC__out SYSTEMTIME *pCreationTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in ILocationReport * This,
            /* [in] */ __RPC__in REFPROPERTYKEY pKey,
            /* [retval][out] */ __RPC__out PROPVARIANT *pValue);
        
        END_INTERFACE
    } ILocationReportVtbl;

    interface ILocationReport
    {
        CONST_VTBL struct ILocationReportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocationReport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILocationReport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILocationReport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILocationReport_GetSensorID(This,pSensorID)	\
    ( (This)->lpVtbl -> GetSensorID(This,pSensorID) ) 

#define ILocationReport_GetTimestamp(This,pCreationTime)	\
    ( (This)->lpVtbl -> GetTimestamp(This,pCreationTime) ) 

#define ILocationReport_GetValue(This,pKey,pValue)	\
    ( (This)->lpVtbl -> GetValue(This,pKey,pValue) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILocationReport_INTERFACE_DEFINED__ */


#ifndef __ILatLongReport_INTERFACE_DEFINED__
#define __ILatLongReport_INTERFACE_DEFINED__

/* interface ILatLongReport */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILatLongReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FED806D-0EF8-4f07-80AC-36A0BEAE3134")
    ILatLongReport : public ILocationReport
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLatitude( 
            /* [retval][out] */ __RPC__out DOUBLE *pLatitude) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetLongitude( 
            /* [retval][out] */ __RPC__out DOUBLE *pLongitude) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetErrorRadius( 
            /* [retval][out] */ __RPC__out DOUBLE *pErrorRadius) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAltitude( 
            /* [retval][out] */ __RPC__out DOUBLE *pAltitude) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAltitudeError( 
            /* [retval][out] */ __RPC__out DOUBLE *pAltitudeError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILatLongReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILatLongReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILatLongReport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILatLongReport * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSensorID )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out SENSOR_ID *pSensorID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTimestamp )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out SYSTEMTIME *pCreationTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in ILatLongReport * This,
            /* [in] */ __RPC__in REFPROPERTYKEY pKey,
            /* [retval][out] */ __RPC__out PROPVARIANT *pValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLatitude )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pLatitude);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetLongitude )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pLongitude);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetErrorRadius )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pErrorRadius);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAltitude )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pAltitude);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAltitudeError )( 
            __RPC__in ILatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pAltitudeError);
        
        END_INTERFACE
    } ILatLongReportVtbl;

    interface ILatLongReport
    {
        CONST_VTBL struct ILatLongReportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILatLongReport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILatLongReport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILatLongReport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILatLongReport_GetSensorID(This,pSensorID)	\
    ( (This)->lpVtbl -> GetSensorID(This,pSensorID) ) 

#define ILatLongReport_GetTimestamp(This,pCreationTime)	\
    ( (This)->lpVtbl -> GetTimestamp(This,pCreationTime) ) 

#define ILatLongReport_GetValue(This,pKey,pValue)	\
    ( (This)->lpVtbl -> GetValue(This,pKey,pValue) ) 


#define ILatLongReport_GetLatitude(This,pLatitude)	\
    ( (This)->lpVtbl -> GetLatitude(This,pLatitude) ) 

#define ILatLongReport_GetLongitude(This,pLongitude)	\
    ( (This)->lpVtbl -> GetLongitude(This,pLongitude) ) 

#define ILatLongReport_GetErrorRadius(This,pErrorRadius)	\
    ( (This)->lpVtbl -> GetErrorRadius(This,pErrorRadius) ) 

#define ILatLongReport_GetAltitude(This,pAltitude)	\
    ( (This)->lpVtbl -> GetAltitude(This,pAltitude) ) 

#define ILatLongReport_GetAltitudeError(This,pAltitudeError)	\
    ( (This)->lpVtbl -> GetAltitudeError(This,pAltitudeError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILatLongReport_INTERFACE_DEFINED__ */


#ifndef __ICivicAddressReport_INTERFACE_DEFINED__
#define __ICivicAddressReport_INTERFACE_DEFINED__

/* interface ICivicAddressReport */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICivicAddressReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0B19F70-4ADF-445d-87F2-CAD8FD711792")
    ICivicAddressReport : public ILocationReport
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAddressLine1( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrAddress1) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetAddressLine2( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrAddress2) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCity( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCity) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetStateProvince( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStateProvince) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetPostalCode( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPostalCode) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCountryRegion( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCountryRegion) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDetailLevel( 
            /* [retval][out] */ __RPC__out DWORD *pDetailLevel) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICivicAddressReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICivicAddressReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICivicAddressReport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICivicAddressReport * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetSensorID )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__out SENSOR_ID *pSensorID);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetTimestamp )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__out SYSTEMTIME *pCreationTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            __RPC__in ICivicAddressReport * This,
            /* [in] */ __RPC__in REFPROPERTYKEY pKey,
            /* [retval][out] */ __RPC__out PROPVARIANT *pValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAddressLine1 )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrAddress1);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetAddressLine2 )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrAddress2);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCity )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCity);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetStateProvince )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrStateProvince);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetPostalCode )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrPostalCode);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCountryRegion )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pbstrCountryRegion);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDetailLevel )( 
            __RPC__in ICivicAddressReport * This,
            /* [retval][out] */ __RPC__out DWORD *pDetailLevel);
        
        END_INTERFACE
    } ICivicAddressReportVtbl;

    interface ICivicAddressReport
    {
        CONST_VTBL struct ICivicAddressReportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICivicAddressReport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICivicAddressReport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICivicAddressReport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICivicAddressReport_GetSensorID(This,pSensorID)	\
    ( (This)->lpVtbl -> GetSensorID(This,pSensorID) ) 

#define ICivicAddressReport_GetTimestamp(This,pCreationTime)	\
    ( (This)->lpVtbl -> GetTimestamp(This,pCreationTime) ) 

#define ICivicAddressReport_GetValue(This,pKey,pValue)	\
    ( (This)->lpVtbl -> GetValue(This,pKey,pValue) ) 


#define ICivicAddressReport_GetAddressLine1(This,pbstrAddress1)	\
    ( (This)->lpVtbl -> GetAddressLine1(This,pbstrAddress1) ) 

#define ICivicAddressReport_GetAddressLine2(This,pbstrAddress2)	\
    ( (This)->lpVtbl -> GetAddressLine2(This,pbstrAddress2) ) 

#define ICivicAddressReport_GetCity(This,pbstrCity)	\
    ( (This)->lpVtbl -> GetCity(This,pbstrCity) ) 

#define ICivicAddressReport_GetStateProvince(This,pbstrStateProvince)	\
    ( (This)->lpVtbl -> GetStateProvince(This,pbstrStateProvince) ) 

#define ICivicAddressReport_GetPostalCode(This,pbstrPostalCode)	\
    ( (This)->lpVtbl -> GetPostalCode(This,pbstrPostalCode) ) 

#define ICivicAddressReport_GetCountryRegion(This,pbstrCountryRegion)	\
    ( (This)->lpVtbl -> GetCountryRegion(This,pbstrCountryRegion) ) 

#define ICivicAddressReport_GetDetailLevel(This,pDetailLevel)	\
    ( (This)->lpVtbl -> GetDetailLevel(This,pDetailLevel) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICivicAddressReport_INTERFACE_DEFINED__ */


#ifndef __ILocation_INTERFACE_DEFINED__
#define __ILocation_INTERFACE_DEFINED__

/* interface ILocation */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ILocation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AB2ECE69-56D9-4F28-B525-DE1B0EE44237")
    ILocation : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterForReport( 
            /* [in] */ __RPC__in_opt ILocationEvents *pEvents,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ DWORD dwRequestedReportInterval) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnregisterForReport( 
            /* [in] */ __RPC__in REFIID reportType) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetReport( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__deref_out_opt ILocationReport **ppLocationReport) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetReportStatus( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__out enum LOCATION_REPORT_STATUS *pStatus) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetReportInterval( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__out DWORD *pMilliseconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetReportInterval( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ DWORD millisecondsRequested) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDesiredAccuracy( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__out enum LOCATION_DESIRED_ACCURACY *pDesiredAccuracy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetDesiredAccuracy( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ enum LOCATION_DESIRED_ACCURACY desiredAccuracy) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RequestPermissions( 
            /* [in] */ __RPC__in HWND hParent,
            /* [size_is][in] */ __RPC__in_ecount_full(count) IID *pReportTypes,
            /* [in] */ ULONG count,
            /* [in] */ BOOL fModal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILocation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILocation * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterForReport )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in_opt ILocationEvents *pEvents,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ DWORD dwRequestedReportInterval);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *UnregisterForReport )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetReport )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__deref_out_opt ILocationReport **ppLocationReport);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetReportStatus )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__out enum LOCATION_REPORT_STATUS *pStatus);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetReportInterval )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__out DWORD *pMilliseconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetReportInterval )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ DWORD millisecondsRequested);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetDesiredAccuracy )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__out enum LOCATION_DESIRED_ACCURACY *pDesiredAccuracy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetDesiredAccuracy )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ enum LOCATION_DESIRED_ACCURACY desiredAccuracy);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RequestPermissions )( 
            __RPC__in ILocation * This,
            /* [in] */ __RPC__in HWND hParent,
            /* [size_is][in] */ __RPC__in_ecount_full(count) IID *pReportTypes,
            /* [in] */ ULONG count,
            /* [in] */ BOOL fModal);
        
        END_INTERFACE
    } ILocationVtbl;

    interface ILocation
    {
        CONST_VTBL struct ILocationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILocation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILocation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILocation_RegisterForReport(This,pEvents,reportType,dwRequestedReportInterval)	\
    ( (This)->lpVtbl -> RegisterForReport(This,pEvents,reportType,dwRequestedReportInterval) ) 

#define ILocation_UnregisterForReport(This,reportType)	\
    ( (This)->lpVtbl -> UnregisterForReport(This,reportType) ) 

#define ILocation_GetReport(This,reportType,ppLocationReport)	\
    ( (This)->lpVtbl -> GetReport(This,reportType,ppLocationReport) ) 

#define ILocation_GetReportStatus(This,reportType,pStatus)	\
    ( (This)->lpVtbl -> GetReportStatus(This,reportType,pStatus) ) 

#define ILocation_GetReportInterval(This,reportType,pMilliseconds)	\
    ( (This)->lpVtbl -> GetReportInterval(This,reportType,pMilliseconds) ) 

#define ILocation_SetReportInterval(This,reportType,millisecondsRequested)	\
    ( (This)->lpVtbl -> SetReportInterval(This,reportType,millisecondsRequested) ) 

#define ILocation_GetDesiredAccuracy(This,reportType,pDesiredAccuracy)	\
    ( (This)->lpVtbl -> GetDesiredAccuracy(This,reportType,pDesiredAccuracy) ) 

#define ILocation_SetDesiredAccuracy(This,reportType,desiredAccuracy)	\
    ( (This)->lpVtbl -> SetDesiredAccuracy(This,reportType,desiredAccuracy) ) 

#define ILocation_RequestPermissions(This,hParent,pReportTypes,count,fModal)	\
    ( (This)->lpVtbl -> RequestPermissions(This,hParent,pReportTypes,count,fModal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILocation_INTERFACE_DEFINED__ */


#ifndef __IDefaultLocation_INTERFACE_DEFINED__
#define __IDefaultLocation_INTERFACE_DEFINED__

/* interface IDefaultLocation */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDefaultLocation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A65AF77E-969A-4a2e-8ACA-33BB7CBB1235")
    IDefaultLocation : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetReport( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ __RPC__in_opt ILocationReport *pLocationReport) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetReport( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__deref_out_opt ILocationReport **ppLocationReport) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDefaultLocationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDefaultLocation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDefaultLocation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDefaultLocation * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetReport )( 
            __RPC__in IDefaultLocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ __RPC__in_opt ILocationReport *pLocationReport);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetReport )( 
            __RPC__in IDefaultLocation * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [retval][out] */ __RPC__deref_out_opt ILocationReport **ppLocationReport);
        
        END_INTERFACE
    } IDefaultLocationVtbl;

    interface IDefaultLocation
    {
        CONST_VTBL struct IDefaultLocationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDefaultLocation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDefaultLocation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDefaultLocation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDefaultLocation_SetReport(This,reportType,pLocationReport)	\
    ( (This)->lpVtbl -> SetReport(This,reportType,pLocationReport) ) 

#define IDefaultLocation_GetReport(This,reportType,ppLocationReport)	\
    ( (This)->lpVtbl -> GetReport(This,reportType,ppLocationReport) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDefaultLocation_INTERFACE_DEFINED__ */


#ifndef __ILocationEvents_INTERFACE_DEFINED__
#define __ILocationEvents_INTERFACE_DEFINED__

/* interface ILocationEvents */
/* [object][helpstring][uuid] */ 


EXTERN_C const IID IID_ILocationEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CAE02BBF-798B-4508-A207-35A7906DC73D")
    ILocationEvents : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnLocationChanged( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ __RPC__in_opt ILocationReport *pLocationReport) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE OnStatusChanged( 
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ LOCATION_REPORT_STATUS newStatus) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocationEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILocationEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILocationEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILocationEvents * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnLocationChanged )( 
            __RPC__in ILocationEvents * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ __RPC__in_opt ILocationReport *pLocationReport);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *OnStatusChanged )( 
            __RPC__in ILocationEvents * This,
            /* [in] */ __RPC__in REFIID reportType,
            /* [in] */ LOCATION_REPORT_STATUS newStatus);
        
        END_INTERFACE
    } ILocationEventsVtbl;

    interface ILocationEvents
    {
        CONST_VTBL struct ILocationEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocationEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILocationEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILocationEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILocationEvents_OnLocationChanged(This,reportType,pLocationReport)	\
    ( (This)->lpVtbl -> OnLocationChanged(This,reportType,pLocationReport) ) 

#define ILocationEvents_OnStatusChanged(This,reportType,newStatus)	\
    ( (This)->lpVtbl -> OnStatusChanged(This,reportType,newStatus) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILocationEvents_INTERFACE_DEFINED__ */


#ifndef __IDispLatLongReport_INTERFACE_DEFINED__
#define __IDispLatLongReport_INTERFACE_DEFINED__

/* interface IDispLatLongReport */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IDispLatLongReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8AE32723-389B-4A11-9957-5BDD48FC9617")
    IDispLatLongReport : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Latitude( 
            /* [retval][out] */ __RPC__out DOUBLE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Longitude( 
            /* [retval][out] */ __RPC__out DOUBLE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ErrorRadius( 
            /* [retval][out] */ __RPC__out DOUBLE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Altitude( 
            /* [retval][out] */ __RPC__out DOUBLE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AltitudeError( 
            /* [retval][out] */ __RPC__out DOUBLE *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Timestamp( 
            /* [retval][out] */ __RPC__out DATE *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispLatLongReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDispLatLongReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDispLatLongReport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDispLatLongReport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDispLatLongReport * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDispLatLongReport * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDispLatLongReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDispLatLongReport * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Latitude )( 
            __RPC__in IDispLatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Longitude )( 
            __RPC__in IDispLatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ErrorRadius )( 
            __RPC__in IDispLatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Altitude )( 
            __RPC__in IDispLatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AltitudeError )( 
            __RPC__in IDispLatLongReport * This,
            /* [retval][out] */ __RPC__out DOUBLE *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Timestamp )( 
            __RPC__in IDispLatLongReport * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        END_INTERFACE
    } IDispLatLongReportVtbl;

    interface IDispLatLongReport
    {
        CONST_VTBL struct IDispLatLongReportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispLatLongReport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDispLatLongReport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDispLatLongReport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDispLatLongReport_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDispLatLongReport_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDispLatLongReport_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDispLatLongReport_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDispLatLongReport_get_Latitude(This,pVal)	\
    ( (This)->lpVtbl -> get_Latitude(This,pVal) ) 

#define IDispLatLongReport_get_Longitude(This,pVal)	\
    ( (This)->lpVtbl -> get_Longitude(This,pVal) ) 

#define IDispLatLongReport_get_ErrorRadius(This,pVal)	\
    ( (This)->lpVtbl -> get_ErrorRadius(This,pVal) ) 

#define IDispLatLongReport_get_Altitude(This,pVal)	\
    ( (This)->lpVtbl -> get_Altitude(This,pVal) ) 

#define IDispLatLongReport_get_AltitudeError(This,pVal)	\
    ( (This)->lpVtbl -> get_AltitudeError(This,pVal) ) 

#define IDispLatLongReport_get_Timestamp(This,pVal)	\
    ( (This)->lpVtbl -> get_Timestamp(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDispLatLongReport_INTERFACE_DEFINED__ */


#ifndef __IDispCivicAddressReport_INTERFACE_DEFINED__
#define __IDispCivicAddressReport_INTERFACE_DEFINED__

/* interface IDispCivicAddressReport */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_IDispCivicAddressReport;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("16FF1A34-9E30-42c3-B44D-E22513B5767A")
    IDispCivicAddressReport : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressLine1( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pAddress1) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressLine2( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pAddress2) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_City( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCity) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_StateProvince( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pStateProvince) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PostalCode( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPostalCode) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CountryRegion( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCountryRegion) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DetailLevel( 
            /* [retval][out] */ __RPC__out ULONG *pDetailLevel) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Timestamp( 
            /* [retval][out] */ __RPC__out DATE *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDispCivicAddressReportVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDispCivicAddressReport * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDispCivicAddressReport * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDispCivicAddressReport * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddressLine1 )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pAddress1);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddressLine2 )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pAddress2);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_City )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCity);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_StateProvince )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pStateProvince);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PostalCode )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pPostalCode);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CountryRegion )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *pCountryRegion);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DetailLevel )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__out ULONG *pDetailLevel);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Timestamp )( 
            __RPC__in IDispCivicAddressReport * This,
            /* [retval][out] */ __RPC__out DATE *pVal);
        
        END_INTERFACE
    } IDispCivicAddressReportVtbl;

    interface IDispCivicAddressReport
    {
        CONST_VTBL struct IDispCivicAddressReportVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDispCivicAddressReport_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDispCivicAddressReport_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDispCivicAddressReport_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDispCivicAddressReport_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDispCivicAddressReport_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDispCivicAddressReport_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDispCivicAddressReport_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IDispCivicAddressReport_get_AddressLine1(This,pAddress1)	\
    ( (This)->lpVtbl -> get_AddressLine1(This,pAddress1) ) 

#define IDispCivicAddressReport_get_AddressLine2(This,pAddress2)	\
    ( (This)->lpVtbl -> get_AddressLine2(This,pAddress2) ) 

#define IDispCivicAddressReport_get_City(This,pCity)	\
    ( (This)->lpVtbl -> get_City(This,pCity) ) 

#define IDispCivicAddressReport_get_StateProvince(This,pStateProvince)	\
    ( (This)->lpVtbl -> get_StateProvince(This,pStateProvince) ) 

#define IDispCivicAddressReport_get_PostalCode(This,pPostalCode)	\
    ( (This)->lpVtbl -> get_PostalCode(This,pPostalCode) ) 

#define IDispCivicAddressReport_get_CountryRegion(This,pCountryRegion)	\
    ( (This)->lpVtbl -> get_CountryRegion(This,pCountryRegion) ) 

#define IDispCivicAddressReport_get_DetailLevel(This,pDetailLevel)	\
    ( (This)->lpVtbl -> get_DetailLevel(This,pDetailLevel) ) 

#define IDispCivicAddressReport_get_Timestamp(This,pVal)	\
    ( (This)->lpVtbl -> get_Timestamp(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDispCivicAddressReport_INTERFACE_DEFINED__ */


#ifndef __ILocationReportFactory_INTERFACE_DEFINED__
#define __ILocationReportFactory_INTERFACE_DEFINED__

/* interface ILocationReportFactory */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_ILocationReportFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2DAEC322-90B2-47e4-BB08-0DA841935A6B")
    ILocationReportFactory : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ListenForReports( 
            /* [defaultvalue][in] */ ULONG requestedReportInterval = 0) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StopListeningForReports( void) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ __RPC__out ULONG *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ReportInterval( 
            /* [retval][out] */ __RPC__out ULONG *pMilliseconds) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ReportInterval( 
            /* [in] */ ULONG millisecondsRequested) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DesiredAccuracy( 
            /* [retval][out] */ __RPC__out ULONG *pDesiredAccuracy) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_DesiredAccuracy( 
            /* [in] */ ULONG desiredAccuracy) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RequestPermissions( 
            /* [in] */ __RPC__in ULONG *hWnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILocationReportFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILocationReportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILocationReportFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILocationReportFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ILocationReportFactory * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ILocationReportFactory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ILocationReportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILocationReportFactory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ListenForReports )( 
            __RPC__in ILocationReportFactory * This,
            /* [defaultvalue][in] */ ULONG requestedReportInterval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopListeningForReports )( 
            __RPC__in ILocationReportFactory * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in ILocationReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReportInterval )( 
            __RPC__in ILocationReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pMilliseconds);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReportInterval )( 
            __RPC__in ILocationReportFactory * This,
            /* [in] */ ULONG millisecondsRequested);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DesiredAccuracy )( 
            __RPC__in ILocationReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pDesiredAccuracy);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DesiredAccuracy )( 
            __RPC__in ILocationReportFactory * This,
            /* [in] */ ULONG desiredAccuracy);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RequestPermissions )( 
            __RPC__in ILocationReportFactory * This,
            /* [in] */ __RPC__in ULONG *hWnd);
        
        END_INTERFACE
    } ILocationReportFactoryVtbl;

    interface ILocationReportFactory
    {
        CONST_VTBL struct ILocationReportFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILocationReportFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILocationReportFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILocationReportFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILocationReportFactory_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ILocationReportFactory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ILocationReportFactory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ILocationReportFactory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ILocationReportFactory_ListenForReports(This,requestedReportInterval)	\
    ( (This)->lpVtbl -> ListenForReports(This,requestedReportInterval) ) 

#define ILocationReportFactory_StopListeningForReports(This)	\
    ( (This)->lpVtbl -> StopListeningForReports(This) ) 

#define ILocationReportFactory_get_Status(This,pVal)	\
    ( (This)->lpVtbl -> get_Status(This,pVal) ) 

#define ILocationReportFactory_get_ReportInterval(This,pMilliseconds)	\
    ( (This)->lpVtbl -> get_ReportInterval(This,pMilliseconds) ) 

#define ILocationReportFactory_put_ReportInterval(This,millisecondsRequested)	\
    ( (This)->lpVtbl -> put_ReportInterval(This,millisecondsRequested) ) 

#define ILocationReportFactory_get_DesiredAccuracy(This,pDesiredAccuracy)	\
    ( (This)->lpVtbl -> get_DesiredAccuracy(This,pDesiredAccuracy) ) 

#define ILocationReportFactory_put_DesiredAccuracy(This,desiredAccuracy)	\
    ( (This)->lpVtbl -> put_DesiredAccuracy(This,desiredAccuracy) ) 

#define ILocationReportFactory_RequestPermissions(This,hWnd)	\
    ( (This)->lpVtbl -> RequestPermissions(This,hWnd) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILocationReportFactory_INTERFACE_DEFINED__ */


#ifndef __ILatLongReportFactory_INTERFACE_DEFINED__
#define __ILatLongReportFactory_INTERFACE_DEFINED__

/* interface ILatLongReportFactory */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_ILatLongReportFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3F0804CB-B114-447D-83DD-390174EBB082")
    ILatLongReportFactory : public ILocationReportFactory
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LatLongReport( 
            /* [retval][out] */ __RPC__deref_out_opt IDispLatLongReport **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILatLongReportFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ILatLongReportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ILatLongReportFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ILatLongReportFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ILatLongReportFactory * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ILatLongReportFactory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ILatLongReportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILatLongReportFactory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ListenForReports )( 
            __RPC__in ILatLongReportFactory * This,
            /* [defaultvalue][in] */ ULONG requestedReportInterval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopListeningForReports )( 
            __RPC__in ILatLongReportFactory * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in ILatLongReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReportInterval )( 
            __RPC__in ILatLongReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pMilliseconds);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReportInterval )( 
            __RPC__in ILatLongReportFactory * This,
            /* [in] */ ULONG millisecondsRequested);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DesiredAccuracy )( 
            __RPC__in ILatLongReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pDesiredAccuracy);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DesiredAccuracy )( 
            __RPC__in ILatLongReportFactory * This,
            /* [in] */ ULONG desiredAccuracy);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RequestPermissions )( 
            __RPC__in ILatLongReportFactory * This,
            /* [in] */ __RPC__in ULONG *hWnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LatLongReport )( 
            __RPC__in ILatLongReportFactory * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispLatLongReport **pVal);
        
        END_INTERFACE
    } ILatLongReportFactoryVtbl;

    interface ILatLongReportFactory
    {
        CONST_VTBL struct ILatLongReportFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILatLongReportFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ILatLongReportFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ILatLongReportFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ILatLongReportFactory_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ILatLongReportFactory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ILatLongReportFactory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ILatLongReportFactory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ILatLongReportFactory_ListenForReports(This,requestedReportInterval)	\
    ( (This)->lpVtbl -> ListenForReports(This,requestedReportInterval) ) 

#define ILatLongReportFactory_StopListeningForReports(This)	\
    ( (This)->lpVtbl -> StopListeningForReports(This) ) 

#define ILatLongReportFactory_get_Status(This,pVal)	\
    ( (This)->lpVtbl -> get_Status(This,pVal) ) 

#define ILatLongReportFactory_get_ReportInterval(This,pMilliseconds)	\
    ( (This)->lpVtbl -> get_ReportInterval(This,pMilliseconds) ) 

#define ILatLongReportFactory_put_ReportInterval(This,millisecondsRequested)	\
    ( (This)->lpVtbl -> put_ReportInterval(This,millisecondsRequested) ) 

#define ILatLongReportFactory_get_DesiredAccuracy(This,pDesiredAccuracy)	\
    ( (This)->lpVtbl -> get_DesiredAccuracy(This,pDesiredAccuracy) ) 

#define ILatLongReportFactory_put_DesiredAccuracy(This,desiredAccuracy)	\
    ( (This)->lpVtbl -> put_DesiredAccuracy(This,desiredAccuracy) ) 

#define ILatLongReportFactory_RequestPermissions(This,hWnd)	\
    ( (This)->lpVtbl -> RequestPermissions(This,hWnd) ) 


#define ILatLongReportFactory_get_LatLongReport(This,pVal)	\
    ( (This)->lpVtbl -> get_LatLongReport(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ILatLongReportFactory_INTERFACE_DEFINED__ */


#ifndef __ICivicAddressReportFactory_INTERFACE_DEFINED__
#define __ICivicAddressReportFactory_INTERFACE_DEFINED__

/* interface ICivicAddressReportFactory */
/* [unique][helpstring][nonextensible][dual][uuid][object] */ 


EXTERN_C const IID IID_ICivicAddressReportFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BF773B93-C64F-4bee-BEB2-67C0B8DF66E0")
    ICivicAddressReportFactory : public ILocationReportFactory
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CivicAddressReport( 
            /* [retval][out] */ __RPC__deref_out_opt IDispCivicAddressReport **pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICivicAddressReportFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in ICivicAddressReportFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in ICivicAddressReportFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICivicAddressReportFactory * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ListenForReports )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [defaultvalue][in] */ ULONG requestedReportInterval);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *StopListeningForReports )( 
            __RPC__in ICivicAddressReportFactory * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ReportInterval )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pMilliseconds);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ReportInterval )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [in] */ ULONG millisecondsRequested);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_DesiredAccuracy )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [retval][out] */ __RPC__out ULONG *pDesiredAccuracy);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_DesiredAccuracy )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [in] */ ULONG desiredAccuracy);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RequestPermissions )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [in] */ __RPC__in ULONG *hWnd);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CivicAddressReport )( 
            __RPC__in ICivicAddressReportFactory * This,
            /* [retval][out] */ __RPC__deref_out_opt IDispCivicAddressReport **pVal);
        
        END_INTERFACE
    } ICivicAddressReportFactoryVtbl;

    interface ICivicAddressReportFactory
    {
        CONST_VTBL struct ICivicAddressReportFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICivicAddressReportFactory_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICivicAddressReportFactory_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICivicAddressReportFactory_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICivicAddressReportFactory_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define ICivicAddressReportFactory_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define ICivicAddressReportFactory_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define ICivicAddressReportFactory_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define ICivicAddressReportFactory_ListenForReports(This,requestedReportInterval)	\
    ( (This)->lpVtbl -> ListenForReports(This,requestedReportInterval) ) 

#define ICivicAddressReportFactory_StopListeningForReports(This)	\
    ( (This)->lpVtbl -> StopListeningForReports(This) ) 

#define ICivicAddressReportFactory_get_Status(This,pVal)	\
    ( (This)->lpVtbl -> get_Status(This,pVal) ) 

#define ICivicAddressReportFactory_get_ReportInterval(This,pMilliseconds)	\
    ( (This)->lpVtbl -> get_ReportInterval(This,pMilliseconds) ) 

#define ICivicAddressReportFactory_put_ReportInterval(This,millisecondsRequested)	\
    ( (This)->lpVtbl -> put_ReportInterval(This,millisecondsRequested) ) 

#define ICivicAddressReportFactory_get_DesiredAccuracy(This,pDesiredAccuracy)	\
    ( (This)->lpVtbl -> get_DesiredAccuracy(This,pDesiredAccuracy) ) 

#define ICivicAddressReportFactory_put_DesiredAccuracy(This,desiredAccuracy)	\
    ( (This)->lpVtbl -> put_DesiredAccuracy(This,desiredAccuracy) ) 

#define ICivicAddressReportFactory_RequestPermissions(This,hWnd)	\
    ( (This)->lpVtbl -> RequestPermissions(This,hWnd) ) 


#define ICivicAddressReportFactory_get_CivicAddressReport(This,pVal)	\
    ( (This)->lpVtbl -> get_CivicAddressReport(This,pVal) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICivicAddressReportFactory_INTERFACE_DEFINED__ */



#ifndef __LocationApiLib_LIBRARY_DEFINED__
#define __LocationApiLib_LIBRARY_DEFINED__

/* library LocationApiLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_LocationApiLib;

EXTERN_C const CLSID CLSID_Location;

#ifdef __cplusplus

class DECLSPEC_UUID("E5B8E079-EE6D-4E33-A438-C87F2E959254")
Location;
#endif

EXTERN_C const CLSID CLSID_DefaultLocation;

#ifdef __cplusplus

class DECLSPEC_UUID("8B7FBFE0-5CD7-494a-AF8C-283A65707506")
DefaultLocation;
#endif

EXTERN_C const CLSID CLSID_LatLongReport;

#ifdef __cplusplus

class DECLSPEC_UUID("ED81C073-1F84-4ca8-A161-183C776BC651")
LatLongReport;
#endif

EXTERN_C const CLSID CLSID_CivicAddressReport;

#ifdef __cplusplus

class DECLSPEC_UUID("D39E7BDD-7D05-46b8-8721-80CF035F57D7")
CivicAddressReport;
#endif

#ifndef ___ILatLongReportFactoryEvents_DISPINTERFACE_DEFINED__
#define ___ILatLongReportFactoryEvents_DISPINTERFACE_DEFINED__

/* dispinterface _ILatLongReportFactoryEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__ILatLongReportFactoryEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("16EE6CB7-AB3C-424B-849F-269BE551FCBC")
    _ILatLongReportFactoryEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _ILatLongReportFactoryEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _ILatLongReportFactoryEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _ILatLongReportFactoryEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _ILatLongReportFactoryEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in _ILatLongReportFactoryEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in _ILatLongReportFactoryEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in _ILatLongReportFactoryEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _ILatLongReportFactoryEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _ILatLongReportFactoryEventsVtbl;

    interface _ILatLongReportFactoryEvents
    {
        CONST_VTBL struct _ILatLongReportFactoryEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ILatLongReportFactoryEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _ILatLongReportFactoryEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _ILatLongReportFactoryEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _ILatLongReportFactoryEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define _ILatLongReportFactoryEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define _ILatLongReportFactoryEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define _ILatLongReportFactoryEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___ILatLongReportFactoryEvents_DISPINTERFACE_DEFINED__ */


#ifndef ___ICivicAddressReportFactoryEvents_DISPINTERFACE_DEFINED__
#define ___ICivicAddressReportFactoryEvents_DISPINTERFACE_DEFINED__

/* dispinterface _ICivicAddressReportFactoryEvents */
/* [helpstring][uuid] */ 


EXTERN_C const IID DIID__ICivicAddressReportFactoryEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)

    MIDL_INTERFACE("C96039FF-72EC-4617-89BD-84D88BEDC722")
    _ICivicAddressReportFactoryEvents : public IDispatch
    {
    };
    
#else 	/* C style interface */

    typedef struct _ICivicAddressReportFactoryEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _ICivicAddressReportFactoryEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _ICivicAddressReportFactoryEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _ICivicAddressReportFactoryEvents * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in _ICivicAddressReportFactoryEvents * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in _ICivicAddressReportFactoryEvents * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in _ICivicAddressReportFactoryEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            _ICivicAddressReportFactoryEvents * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } _ICivicAddressReportFactoryEventsVtbl;

    interface _ICivicAddressReportFactoryEvents
    {
        CONST_VTBL struct _ICivicAddressReportFactoryEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _ICivicAddressReportFactoryEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _ICivicAddressReportFactoryEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _ICivicAddressReportFactoryEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _ICivicAddressReportFactoryEvents_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define _ICivicAddressReportFactoryEvents_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define _ICivicAddressReportFactoryEvents_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define _ICivicAddressReportFactoryEvents_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */


#endif 	/* ___ICivicAddressReportFactoryEvents_DISPINTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_LatLongReportFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("9DCC3CC8-8609-4863-BAD4-03601F4C65E8")
LatLongReportFactory;
#endif

EXTERN_C const CLSID CLSID_CivicAddressReportFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("2A11F42C-3E81-4ad4-9CBE-45579D89671A")
CivicAddressReportFactory;
#endif

EXTERN_C const CLSID CLSID_DispLatLongReport;

#ifdef __cplusplus

class DECLSPEC_UUID("7A7C3277-8F84-4636-95B2-EBB5507FF77E")
DispLatLongReport;
#endif

EXTERN_C const CLSID CLSID_DispCivicAddressReport;

#ifdef __cplusplus

class DECLSPEC_UUID("4C596AEC-8544-4082-BA9F-EB0A7D8E65C6")
DispCivicAddressReport;
#endif
#endif /* __LocationApiLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

unsigned long             __RPC_USER  BSTR_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out BSTR * ); 
void                      __RPC_USER  BSTR_UserFree64(     __RPC__in unsigned long *, __RPC__in BSTR * ); 

unsigned long             __RPC_USER  HWND_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in HWND * ); 
unsigned char * __RPC_USER  HWND_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out HWND * ); 
void                      __RPC_USER  HWND_UserFree64(     __RPC__in unsigned long *, __RPC__in HWND * ); 

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize64(     __RPC__in unsigned long *, unsigned long            , __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal64(  __RPC__in unsigned long *, __RPC__inout_xcount(0) unsigned char *, __RPC__in LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal64(__RPC__in unsigned long *, __RPC__in_xcount(0) unsigned char *, __RPC__out LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree64(     __RPC__in unsigned long *, __RPC__in LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LsaLookup.h ===
/*++

Copyright (c) Microsoft Corporation, 1992 -

Module Name:

    lsalookup.h

Abstract:

    LSA Policy Lookup API

--*/

#ifndef _LSALOOKUP_
#define _LSALOOKUP_

#ifdef __cplusplus
extern "C" {
#endif

#ifdef _NTDEF_

typedef UNICODE_STRING LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;
typedef STRING LSA_STRING, *PLSA_STRING;
typedef OBJECT_ATTRIBUTES LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;

#else // _NTDEF_

typedef struct _LSA_UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
#ifdef MIDL_PASS
    [size_is(MaximumLength/2), length_is(Length/2)]
#endif // MIDL_PASS
    PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING;

typedef struct _LSA_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} LSA_STRING, *PLSA_STRING;

typedef struct _LSA_OBJECT_ATTRIBUTES {
    ULONG Length;
    HANDLE RootDirectory;
    PLSA_UNICODE_STRING ObjectName;
    ULONG Attributes;
    PVOID SecurityDescriptor;        // Points to type SECURITY_DESCRIPTOR
    PVOID SecurityQualityOfService;  // Points to type SECURITY_QUALITY_OF_SERVICE
} LSA_OBJECT_ATTRIBUTES, *PLSA_OBJECT_ATTRIBUTES;

#endif // _NTDEF_

//
// The following data type is used to identify a domain
//

typedef struct _LSA_TRUST_INFORMATION {

    LSA_UNICODE_STRING Name;
    PSID Sid;

} LSA_TRUST_INFORMATION, *PLSA_TRUST_INFORMATION;

// where members have the following usage:
//
//     Name - The name of the domain.
//
//     Sid - A pointer to the Sid of the Domain
//

//
// The following data type is used in name and SID lookup services to
// describe the domains referenced in the lookup operation.
//

typedef struct _LSA_REFERENCED_DOMAIN_LIST {

    ULONG Entries;
    PLSA_TRUST_INFORMATION Domains;

} LSA_REFERENCED_DOMAIN_LIST, *PLSA_REFERENCED_DOMAIN_LIST;

// where members have the following usage:
//
//     Entries - Is a count of the number of domains described in the
//         Domains array.
//
//     Domains - Is a pointer to an array of Entries LSA_TRUST_INFORMATION data
//         structures.
//

//
// The following data type is used in name to SID lookup services to describe
// the domains referenced in the lookup operation.
//

#if (_WIN32_WINNT >= 0x0501)
typedef struct _LSA_TRANSLATED_SID2 {

    SID_NAME_USE Use;
    PSID         Sid;
    LONG         DomainIndex;
    ULONG        Flags;

} LSA_TRANSLATED_SID2, *PLSA_TRANSLATED_SID2;

// where members have the following usage:
//
//     Use - identifies the use of the SID.  If this value is SidUnknown or
//         SidInvalid, then the remainder of the record is not set and
//         should be ignored.
//
//     Sid - Contains the complete Sid of the tranlated SID
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the
//         domain in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//
#endif

//
// The following data type is used in SID to name lookup services to
// describe the domains referenced in the lookup operation.
//

typedef struct _LSA_TRANSLATED_NAME {

    SID_NAME_USE Use;
    LSA_UNICODE_STRING Name;
    LONG DomainIndex;

} LSA_TRANSLATED_NAME, *PLSA_TRANSLATED_NAME;

// where the members have the following usage:
//
//     Use - Identifies the use of the name.  If this value is SidUnknown
//         or SidInvalid, then the remainder of the record is not set and
//         should be ignored.  If this value is SidWellKnownGroup then the
//         Name field is invalid, but the DomainIndex field is not.
//
//     Name - Contains the isolated name of the translated SID.
//
//     DomainIndex - Is the index of an entry in a related
//         LSA_REFERENCED_DOMAIN_LIST data structure describing the domain
//         in which the account was found.
//
//         If there is no corresponding reference domain for an entry, then
//         this field will contain a negative value.
//

//
// The following structure specifies the account domain info
// (corresponds to the PolicyAccountDomainInformation information class).
//

typedef struct _POLICY_ACCOUNT_DOMAIN_INFO {

    LSA_UNICODE_STRING DomainName;
    PSID DomainSid;

} POLICY_ACCOUNT_DOMAIN_INFO, *PPOLICY_ACCOUNT_DOMAIN_INFO;

// where the members have the following usage:
//
//     DomainName - Is the name of the domain
//
//     DomainSid - Is the Sid of the domain
//

//
// The following structure corresponds to the PolicyDnsDomainInformation
// information class
//

typedef struct _POLICY_DNS_DOMAIN_INFO
{
    LSA_UNICODE_STRING Name;
    LSA_UNICODE_STRING DnsDomainName;
    LSA_UNICODE_STRING DnsForestName;
    GUID DomainGuid;
    PSID Sid;

} POLICY_DNS_DOMAIN_INFO, *PPOLICY_DNS_DOMAIN_INFO;

// where the members have the following usage:
//
//      Name - Is the name of the Domain
//
//      DnsDomainName - Is the DNS name of the domain
//
//      DnsForestName - Is the DNS forest name of the domain
//
//      DomainGuid - Is the GUID of the domain
//
//      Sid - Is the Sid of the domain


//
// Access types for the Lookup Policy object
//
// Choose values to correspond to the POLICY_* access types
//

#define LOOKUP_VIEW_LOCAL_INFORMATION       0x00000001
#define LOOKUP_TRANSLATE_NAMES              0x00000800

//
// The following data type defines the classes of Lookup Policy
// Domain Information that may be queried. The values are chosen
// to match corresponding POLICY_INFORMATION_CLASS values.
//

typedef enum _LSA_LOOKUP_DOMAIN_INFO_CLASS {

    AccountDomainInformation = 5,
    DnsDomainInformation     = 12

} LSA_LOOKUP_DOMAIN_INFO_CLASS, *PLSA_LOOKUP_DOMAIN_INFO_CLASS;

//
// Lookup handle
//

typedef PVOID LSA_LOOKUP_HANDLE, *PLSA_LOOKUP_HANDLE;

NTSTATUS
LsaLookupOpenLocalPolicy(
    __in     PLSA_OBJECT_ATTRIBUTES ObjectAttributes,
    __in     ACCESS_MASK AccessMask,
    __inout  PLSA_LOOKUP_HANDLE PolicyHandle
    );

NTSTATUS
LsaLookupClose(
    __in LSA_LOOKUP_HANDLE ObjectHandle
    );

NTSTATUS
LsaLookupTranslateSids(
    __in  LSA_LOOKUP_HANDLE PolicyHandle,
    __in  ULONG Count,
    __in  PSID *Sids,
    __out PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    __out PLSA_TRANSLATED_NAME *Names
    );

#if (_WIN32_WINNT >= 0x0501)
NTSTATUS
LsaLookupTranslateNames(
    __in  LSA_LOOKUP_HANDLE PolicyHandle,
    __in  ULONG Flags,
    __in  ULONG Count,
    __in  PLSA_UNICODE_STRING Names,
    __out PLSA_REFERENCED_DOMAIN_LIST *ReferencedDomains,
    __out PLSA_TRANSLATED_SID2 *Sids
    );
#endif

NTSTATUS
LsaLookupGetDomainInfo(
    __in  LSA_LOOKUP_HANDLE PolicyHandle,
    __in  LSA_LOOKUP_DOMAIN_INFO_CLASS DomainInfoClass,
    __out PVOID *DomainInfo
    );

NTSTATUS
LsaLookupFreeMemory(
    __in PVOID Buffer
    );

#ifdef __cplusplus
}
#endif

#endif // _LSALOOKUP_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LMWksta.h ===
/*++ BUILD Version: 0006    // Increment this if a change has global effects

Copyright (c) 1991-1999  Microsoft Corporation

Module Name:

    lmwksta.h

Abstract:

    This file contains structures, function prototypes, and definitions
    for the NetWorkstation and NetWkstaTransport API.

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Notes:

    You must include NETCONS.H before this file, since this file depends
    on values defined in NETCONS.H.

--*/

#ifndef _LMWKSTA_
#define _LMWKSTA_

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#include <lmcons.h>
#include <lmuseflg.h>                   // Deletion force level flags

//
// Function Prototypes
//

NET_API_STATUS NET_API_FUNCTION
NetWkstaGetInfo (
    __in_opt IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    __deref_opt_out_xcount("size varies with level") OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaSetInfo (
    __in_opt IN  LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    IN  LPBYTE  buffer,
    __out_opt OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserGetInfo (
    __in_opt IN  LMSTR  reserved,
    IN  DWORD   level,
    __out_opt OUT LPBYTE  *bufptr
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserSetInfo (
    __in_opt IN  LMSTR  reserved,
    IN  DWORD   level,
    OUT LPBYTE  buf,
    __out_opt OUT LPDWORD parm_err OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaUserEnum (
    __in_opt LMSTR       servername OPTIONAL,
    IN  DWORD       level,
    __out_opt LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out_opt LPDWORD     entriesread,
    __out LPDWORD     totalentries,
    __inout_opt LPDWORD resumehandle OPTIONAL
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportAdd (
    __in_opt LMSTR   servername OPTIONAL,
    IN  DWORD   level,
    __in LPBYTE  buf,
    __out_opt LPDWORD parm_err
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportDel (
    __in_opt IN  LMSTR   servername OPTIONAL,
    __in_opt IN  LMSTR   transportname,
    IN  DWORD   ucond
    );

NET_API_STATUS NET_API_FUNCTION
NetWkstaTransportEnum (
    __in_opt LMSTR       servername OPTIONAL,
    IN  DWORD       level,
    __out_opt LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    __out_opt LPDWORD     entriesread,
    __out LPDWORD     totalentries,
    __inout_opt LPDWORD resumehandle OPTIONAL
    );

//
//  Data Structures
//

//
// NetWkstaGetInfo and NetWkstaSetInfo
//

//
// NetWkstaGetInfo only.  System information - guest access
//
typedef struct _WKSTA_INFO_100 {
    DWORD   wki100_platform_id;
    LMSTR   wki100_computername;
    LMSTR   wki100_langroup;
    DWORD   wki100_ver_major;
    DWORD   wki100_ver_minor;
}WKSTA_INFO_100, *PWKSTA_INFO_100, *LPWKSTA_INFO_100;

//
// NetWkstaGetInfo only.  System information - user access
//
typedef struct _WKSTA_INFO_101 {
    DWORD   wki101_platform_id;
    LMSTR   wki101_computername;
    LMSTR   wki101_langroup;
    DWORD   wki101_ver_major;
    DWORD   wki101_ver_minor;
    LMSTR   wki101_lanroot;
}WKSTA_INFO_101, *PWKSTA_INFO_101, *LPWKSTA_INFO_101;

//
// NetWkstaGetInfo only.  System information - admin or operator access
//
typedef struct _WKSTA_INFO_102 {
    DWORD   wki102_platform_id;
    LMSTR   wki102_computername;
    LMSTR   wki102_langroup;
    DWORD   wki102_ver_major;
    DWORD   wki102_ver_minor;
    LMSTR   wki102_lanroot;
    DWORD   wki102_logged_on_users;
}WKSTA_INFO_102, *PWKSTA_INFO_102, *LPWKSTA_INFO_102;

//
// Down-level NetWkstaGetInfo and NetWkstaSetInfo.
//
// DOS specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_302{
    DWORD   wki302_char_wait;
    DWORD   wki302_collection_time;
    DWORD   wki302_maximum_collection_count;
    DWORD   wki302_keep_conn;
    DWORD   wki302_keep_search;
    DWORD   wki302_max_cmds;
    DWORD   wki302_num_work_buf;
    DWORD   wki302_siz_work_buf;
    DWORD   wki302_max_wrk_cache;
    DWORD   wki302_sess_timeout;
    DWORD   wki302_siz_error;
    DWORD   wki302_num_alerts;
    DWORD   wki302_num_services;
    DWORD   wki302_errlog_sz;
    DWORD   wki302_print_buf_time;
    DWORD   wki302_num_char_buf;
    DWORD   wki302_siz_char_buf;
    LMSTR   wki302_wrk_heuristics;
    DWORD   wki302_mailslots;
    DWORD   wki302_num_dgram_buf;
}WKSTA_INFO_302, *PWKSTA_INFO_302, *LPWKSTA_INFO_302;

//
// Down-level NetWkstaGetInfo and NetWkstaSetInfo
//
// OS/2 specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_402{
    DWORD   wki402_char_wait;
    DWORD   wki402_collection_time;
    DWORD   wki402_maximum_collection_count;
    DWORD   wki402_keep_conn;
    DWORD   wki402_keep_search;
    DWORD   wki402_max_cmds;
    DWORD   wki402_num_work_buf;
    DWORD   wki402_siz_work_buf;
    DWORD   wki402_max_wrk_cache;
    DWORD   wki402_sess_timeout;
    DWORD   wki402_siz_error;
    DWORD   wki402_num_alerts;
    DWORD   wki402_num_services;
    DWORD   wki402_errlog_sz;
    DWORD   wki402_print_buf_time;
    DWORD   wki402_num_char_buf;
    DWORD   wki402_siz_char_buf;
    LMSTR   wki402_wrk_heuristics;
    DWORD   wki402_mailslots;
    DWORD   wki402_num_dgram_buf;
    DWORD   wki402_max_threads;
}WKSTA_INFO_402, *PWKSTA_INFO_402, *LPWKSTA_INFO_402;

//
// Same-level NetWkstaGetInfo and NetWkstaSetInfo.
//
// NT specific workstation information -
//    admin or domain operator access
//
typedef struct _WKSTA_INFO_502{
    DWORD   wki502_char_wait;
    DWORD   wki502_collection_time;
    DWORD   wki502_maximum_collection_count;
    DWORD   wki502_keep_conn;
    DWORD   wki502_max_cmds;
    DWORD   wki502_sess_timeout;
    DWORD   wki502_siz_char_buf;
    DWORD   wki502_max_threads;

    DWORD   wki502_lock_quota;
    DWORD   wki502_lock_increment;
    DWORD   wki502_lock_maximum;
    DWORD   wki502_pipe_increment;
    DWORD   wki502_pipe_maximum;
    DWORD   wki502_cache_file_timeout;
    DWORD   wki502_dormant_file_limit;
    DWORD   wki502_read_ahead_throughput;

    DWORD   wki502_num_mailslot_buffers;
    DWORD   wki502_num_srv_announce_buffers;
    DWORD   wki502_max_illegal_datagram_events;
    DWORD   wki502_illegal_datagram_event_reset_frequency;
    BOOL    wki502_log_election_packets;

    BOOL    wki502_use_opportunistic_locking;
    BOOL    wki502_use_unlock_behind;
    BOOL    wki502_use_close_behind;
    BOOL    wki502_buf_named_pipes;
    BOOL    wki502_use_lock_read_unlock;
    BOOL    wki502_utilize_nt_caching;
    BOOL    wki502_use_raw_read;
    BOOL    wki502_use_raw_write;
    BOOL    wki502_use_write_raw_data;
    BOOL    wki502_use_encryption;
    BOOL    wki502_buf_files_deny_write;
    BOOL    wki502_buf_read_only_files;
    BOOL    wki502_force_core_create_mode;
    BOOL    wki502_use_512_byte_max_transfer;
}WKSTA_INFO_502, *PWKSTA_INFO_502, *LPWKSTA_INFO_502;


//
// The following info-levels are only valid for NetWkstaSetInfo
//

//
// The following levels are supported on down-level systems (LAN Man 2.x)
// as well as NT systems:
//
typedef struct _WKSTA_INFO_1010 {
     DWORD  wki1010_char_wait;
} WKSTA_INFO_1010, *PWKSTA_INFO_1010, *LPWKSTA_INFO_1010;

typedef struct _WKSTA_INFO_1011 {
     DWORD  wki1011_collection_time;
} WKSTA_INFO_1011, *PWKSTA_INFO_1011, *LPWKSTA_INFO_1011;

typedef struct _WKSTA_INFO_1012 {
     DWORD  wki1012_maximum_collection_count;
} WKSTA_INFO_1012, *PWKSTA_INFO_1012, *LPWKSTA_INFO_1012;

//
// The following level are supported on down-level systems (LAN Man 2.x)
// only:
//
typedef struct _WKSTA_INFO_1027 {
     DWORD  wki1027_errlog_sz;
} WKSTA_INFO_1027, *PWKSTA_INFO_1027, *LPWKSTA_INFO_1027;

typedef struct _WKSTA_INFO_1028 {
     DWORD  wki1028_print_buf_time;
} WKSTA_INFO_1028, *PWKSTA_INFO_1028, *LPWKSTA_INFO_1028;

typedef struct _WKSTA_INFO_1032 {
     DWORD  wki1032_wrk_heuristics;
} WKSTA_INFO_1032, *PWKSTA_INFO_1032, *LPWKSTA_INFO_1032;

//
// The following levels are settable on NT systems, and have no
// effect on down-level systems (i.e. LANMan 2.x) since these
// fields cannot be set on them:
//
typedef struct _WKSTA_INFO_1013 {
     DWORD  wki1013_keep_conn;
} WKSTA_INFO_1013, *PWKSTA_INFO_1013, *LPWKSTA_INFO_1013;

typedef struct _WKSTA_INFO_1018 {
     DWORD  wki1018_sess_timeout;
} WKSTA_INFO_1018, *PWKSTA_INFO_1018, *LPWKSTA_INFO_1018;

typedef struct _WKSTA_INFO_1023 {
     DWORD  wki1023_siz_char_buf;
} WKSTA_INFO_1023, *PWKSTA_INFO_1023, *LPWKSTA_INFO_1023;

typedef struct _WKSTA_INFO_1033 {
     DWORD  wki1033_max_threads;
} WKSTA_INFO_1033, *PWKSTA_INFO_1033, *LPWKSTA_INFO_1033;

//
// The following levels are only supported on NT systems:
//
typedef struct _WKSTA_INFO_1041 {
    DWORD   wki1041_lock_quota;
} WKSTA_INFO_1041, *PWKSTA_INFO_1041, *LPWKSTA_INFO_1041;

typedef struct _WKSTA_INFO_1042 {
    DWORD   wki1042_lock_increment;
} WKSTA_INFO_1042, *PWKSTA_INFO_1042, *LPWKSTA_INFO_1042;

typedef struct _WKSTA_INFO_1043 {
    DWORD   wki1043_lock_maximum;
} WKSTA_INFO_1043, *PWKSTA_INFO_1043, *LPWKSTA_INFO_1043;

typedef struct _WKSTA_INFO_1044 {
    DWORD   wki1044_pipe_increment;
} WKSTA_INFO_1044, *PWKSTA_INFO_1044, *LPWKSTA_INFO_1044;

typedef struct _WKSTA_INFO_1045 {
    DWORD   wki1045_pipe_maximum;
} WKSTA_INFO_1045, *PWKSTA_INFO_1045, *LPWKSTA_INFO_1045;

typedef struct _WKSTA_INFO_1046 {
    DWORD   wki1046_dormant_file_limit;
} WKSTA_INFO_1046, *PWKSTA_INFO_1046, *LPWKSTA_INFO_1046;

typedef struct _WKSTA_INFO_1047 {
    DWORD    wki1047_cache_file_timeout;
} WKSTA_INFO_1047, *PWKSTA_INFO_1047, *LPWKSTA_INFO_1047;

typedef struct _WKSTA_INFO_1048 {
    BOOL     wki1048_use_opportunistic_locking;
} WKSTA_INFO_1048, *PWKSTA_INFO_1048, *LPWKSTA_INFO_1048;

typedef struct _WKSTA_INFO_1049 {
    BOOL     wki1049_use_unlock_behind;
} WKSTA_INFO_1049, *PWKSTA_INFO_1049, *LPWKSTA_INFO_1049;

typedef struct _WKSTA_INFO_1050 {
    BOOL     wki1050_use_close_behind;
} WKSTA_INFO_1050, *PWKSTA_INFO_1050, *LPWKSTA_INFO_1050;

typedef struct _WKSTA_INFO_1051 {
    BOOL     wki1051_buf_named_pipes;
} WKSTA_INFO_1051, *PWKSTA_INFO_1051, *LPWKSTA_INFO_1051;

typedef struct _WKSTA_INFO_1052 {
    BOOL     wki1052_use_lock_read_unlock;
} WKSTA_INFO_1052, *PWKSTA_INFO_1052, *LPWKSTA_INFO_1052;

typedef struct _WKSTA_INFO_1053 {
    BOOL     wki1053_utilize_nt_caching;
} WKSTA_INFO_1053, *PWKSTA_INFO_1053, *LPWKSTA_INFO_1053;

typedef struct _WKSTA_INFO_1054 {
    BOOL     wki1054_use_raw_read;
} WKSTA_INFO_1054, *PWKSTA_INFO_1054, *LPWKSTA_INFO_1054;

typedef struct _WKSTA_INFO_1055 {
    BOOL     wki1055_use_raw_write;
} WKSTA_INFO_1055, *PWKSTA_INFO_1055, *LPWKSTA_INFO_1055;

typedef struct _WKSTA_INFO_1056 {
    BOOL     wki1056_use_write_raw_data;
} WKSTA_INFO_1056, *PWKSTA_INFO_1056, *LPWKSTA_INFO_1056;

typedef struct _WKSTA_INFO_1057 {
    BOOL     wki1057_use_encryption;
} WKSTA_INFO_1057, *PWKSTA_INFO_1057, *LPWKSTA_INFO_1057;

typedef struct _WKSTA_INFO_1058 {
    BOOL     wki1058_buf_files_deny_write;
} WKSTA_INFO_1058, *PWKSTA_INFO_1058, *LPWKSTA_INFO_1058;

typedef struct _WKSTA_INFO_1059 {
    BOOL     wki1059_buf_read_only_files;
} WKSTA_INFO_1059, *PWKSTA_INFO_1059, *LPWKSTA_INFO_1059;

typedef struct _WKSTA_INFO_1060 {
    BOOL     wki1060_force_core_create_mode;
} WKSTA_INFO_1060, *PWKSTA_INFO_1060, *LPWKSTA_INFO_1060;

typedef struct _WKSTA_INFO_1061 {
    BOOL     wki1061_use_512_byte_max_transfer;
} WKSTA_INFO_1061, *PWKSTA_INFO_1061, *LPWKSTA_INFO_1061;

typedef struct _WKSTA_INFO_1062 {
    DWORD   wki1062_read_ahead_throughput;
} WKSTA_INFO_1062, *PWKSTA_INFO_1062, *LPWKSTA_INFO_1062;


//
// NetWkstaUserGetInfo (local only) and NetWkstaUserEnum -
//     no access restrictions.
//
typedef struct _WKSTA_USER_INFO_0 {
    LMSTR   wkui0_username;
}WKSTA_USER_INFO_0, *PWKSTA_USER_INFO_0, *LPWKSTA_USER_INFO_0;

//
// NetWkstaUserGetInfo (local only) and NetWkstaUserEnum -
//     no access restrictions.
//
typedef struct _WKSTA_USER_INFO_1 {
    LMSTR   wkui1_username;
    LMSTR   wkui1_logon_domain;
    LMSTR   wkui1_oth_domains;
    LMSTR   wkui1_logon_server;
}WKSTA_USER_INFO_1, *PWKSTA_USER_INFO_1, *LPWKSTA_USER_INFO_1;

//
// NetWkstaUserSetInfo - local access.
//
typedef struct _WKSTA_USER_INFO_1101 {
     LMSTR   wkui1101_oth_domains;
} WKSTA_USER_INFO_1101, *PWKSTA_USER_INFO_1101,
  *LPWKSTA_USER_INFO_1101;


//
// NetWkstaTransportAdd - admin access
//
typedef struct _WKSTA_TRANSPORT_INFO_0 {
    DWORD   wkti0_quality_of_service;
    DWORD   wkti0_number_of_vcs;
    LMSTR   wkti0_transport_name;
    LMSTR   wkti0_transport_address;
    BOOL    wkti0_wan_ish;
}WKSTA_TRANSPORT_INFO_0, *PWKSTA_TRANSPORT_INFO_0,
 *LPWKSTA_TRANSPORT_INFO_0;


//
// Special Values and Constants
//

//
//  Identifiers for use as NetWkstaSetInfo parmnum parameter
//

//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaSetInfo.
//

#define WKSTA_PLATFORM_ID_PARMNUM               100
#define WKSTA_COMPUTERNAME_PARMNUM              1
#define WKSTA_LANGROUP_PARMNUM                  2
#define WKSTA_VER_MAJOR_PARMNUM                 4
#define WKSTA_VER_MINOR_PARMNUM                 5
#define WKSTA_LOGGED_ON_USERS_PARMNUM           6
#define WKSTA_LANROOT_PARMNUM                   7
#define WKSTA_LOGON_DOMAIN_PARMNUM              8
#define WKSTA_LOGON_SERVER_PARMNUM              9
#define WKSTA_CHARWAIT_PARMNUM                  10  // Supported by down-level.
#define WKSTA_CHARTIME_PARMNUM                  11  // Supported by down-level.
#define WKSTA_CHARCOUNT_PARMNUM                 12  // Supported by down-level.
#define WKSTA_KEEPCONN_PARMNUM                  13
#define WKSTA_KEEPSEARCH_PARMNUM                14
#define WKSTA_MAXCMDS_PARMNUM                   15
#define WKSTA_NUMWORKBUF_PARMNUM                16
#define WKSTA_MAXWRKCACHE_PARMNUM               17
#define WKSTA_SESSTIMEOUT_PARMNUM               18
#define WKSTA_SIZERROR_PARMNUM                  19
#define WKSTA_NUMALERTS_PARMNUM                 20
#define WKSTA_NUMSERVICES_PARMNUM               21
#define WKSTA_NUMCHARBUF_PARMNUM                22
#define WKSTA_SIZCHARBUF_PARMNUM                23
#define WKSTA_ERRLOGSZ_PARMNUM                  27  // Supported by down-level.
#define WKSTA_PRINTBUFTIME_PARMNUM              28  // Supported by down-level.
#define WKSTA_SIZWORKBUF_PARMNUM                29
#define WKSTA_MAILSLOTS_PARMNUM                 30
#define WKSTA_NUMDGRAMBUF_PARMNUM               31
#define WKSTA_WRKHEURISTICS_PARMNUM             32  // Supported by down-level.
#define WKSTA_MAXTHREADS_PARMNUM                33

#define WKSTA_LOCKQUOTA_PARMNUM                 41
#define WKSTA_LOCKINCREMENT_PARMNUM             42
#define WKSTA_LOCKMAXIMUM_PARMNUM               43
#define WKSTA_PIPEINCREMENT_PARMNUM             44
#define WKSTA_PIPEMAXIMUM_PARMNUM               45
#define WKSTA_DORMANTFILELIMIT_PARMNUM          46
#define WKSTA_CACHEFILETIMEOUT_PARMNUM          47
#define WKSTA_USEOPPORTUNISTICLOCKING_PARMNUM   48
#define WKSTA_USEUNLOCKBEHIND_PARMNUM           49
#define WKSTA_USECLOSEBEHIND_PARMNUM            50
#define WKSTA_BUFFERNAMEDPIPES_PARMNUM          51
#define WKSTA_USELOCKANDREADANDUNLOCK_PARMNUM   52
#define WKSTA_UTILIZENTCACHING_PARMNUM          53
#define WKSTA_USERAWREAD_PARMNUM                54
#define WKSTA_USERAWWRITE_PARMNUM               55
#define WKSTA_USEWRITERAWWITHDATA_PARMNUM       56
#define WKSTA_USEENCRYPTION_PARMNUM             57
#define WKSTA_BUFFILESWITHDENYWRITE_PARMNUM     58
#define WKSTA_BUFFERREADONLYFILES_PARMNUM       59
#define WKSTA_FORCECORECREATEMODE_PARMNUM       60
#define WKSTA_USE512BYTESMAXTRANSFER_PARMNUM    61
#define WKSTA_READAHEADTHRUPUT_PARMNUM          62


//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaUserSetInfo.
//

#define WKSTA_OTH_DOMAINS_PARMNUM              101


//
// One of these values indicates the parameter within an information
// structure that is invalid when ERROR_INVALID_PARAMETER is returned by
// NetWkstaTransportAdd.
//

#define TRANSPORT_QUALITYOFSERVICE_PARMNUM     201
#define TRANSPORT_NAME_PARMNUM                 202

#ifdef __cplusplus
}
#endif

#endif // _LMWKSTA_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\LoadPerf.h ===
/*++
Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:
    loadperf.h

Abstract:
    Header file for the Performance Monitor counter string installation
    and removal functions.

Revision History
    16-Nov-95   Created (a-robw)
--*/

#ifndef _LOADPERF_H_
#define _LOADPERF_H_

#if _MSC_VER > 1000
#pragma once
#endif

// function prototypes for perf counter name string load & unload functions
// provided in LOADPERF.DLL

#ifdef __cplusplus
extern "C" {
#endif

#ifdef __LOADPERF__
#define LOADPERF_FUNCTION   DWORD __stdcall
#else
#define LOADPERF_FUNCTION   __declspec(dllimport) DWORD __stdcall
#endif

// flags for dwFlags Argument
#define LOADPERF_FLAGS_DELETE_MOF_ON_EXIT   ((ULONG_PTR) 1)
#define LOADPERF_FLAGS_LOAD_REGISTRY_ONLY   ((ULONG_PTR) 2)
#define LOADPERF_FLAGS_CREATE_MOF_ONLY      ((ULONG_PTR) 4)
#define LOADPERF_FLAGS_DISPLAY_USER_MSGS    ((ULONG_PTR) 8)

LOADPERF_FUNCTION
InstallPerfDllW(
    __in_opt LPCWSTR   szComputerName,
    __in     LPCWSTR   lpIniFile,
    __in     ULONG_PTR dwFlags         
);

LOADPERF_FUNCTION
InstallPerfDllA(
    __in_opt LPCSTR    szComputerName,
    __in     LPCSTR    lpIniFile,
    __in     ULONG_PTR dwFlags         
);

LOADPERF_FUNCTION
LoadPerfCounterTextStringsA(
    __in LPSTR     lpCommandLine,
    __in BOOL      bQuietModeArg
);

LOADPERF_FUNCTION
LoadPerfCounterTextStringsW(
    __in LPWSTR    lpCommandLine,
    __in BOOL      bQuietModeArg
);

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsW(
    __in LPWSTR    lpCommandLine,
    __in BOOL      bQuietModeArg
);

LOADPERF_FUNCTION
UnloadPerfCounterTextStringsA(
    __in LPSTR     lpCommandLine,
    __in BOOL      bQuietModeArg
);

LOADPERF_FUNCTION
UpdatePerfNameFilesA(
    __in     LPCSTR    szNewCtrFilePath,
    __in_opt LPCSTR    szNewHlpFilePath,
    __in     LPSTR     szLanguageID,
    __in     ULONG_PTR dwFlags
);

LOADPERF_FUNCTION
UpdatePerfNameFilesW(
    __in     LPCWSTR   szNewCtrFilePath,
    __in_opt LPCWSTR   szNewHlpFilePath,
    __in     LPWSTR    szLanguageID,
    __in     ULONG_PTR dwFlags
);

LOADPERF_FUNCTION
SetServiceAsTrustedA(
    __in_opt LPCSTR    szReserved,
    __in     LPCSTR    szServiceName
);

LOADPERF_FUNCTION
SetServiceAsTrustedW(
    __in_opt LPCWSTR   szReserved,
    __in     LPCWSTR   szServiceName
);

DWORD
BackupPerfRegistryToFileW(
    __in     LPCWSTR   szFileName,
    __in_opt LPCWSTR   szCommentString
);

DWORD
RestorePerfRegistryFromFileW(
    __in_opt LPCWSTR   szFileName,
    __in_opt LPCWSTR   szLangId
);

#ifdef UNICODE
#define InstallPerfDll                  InstallPerfDllW
#define LoadPerfCounterTextStrings      LoadPerfCounterTextStringsW
#define UnloadPerfCounterTextStrings    UnloadPerfCounterTextStringsW
#define UpdatePerfNameFiles             UpdatePerfNameFilesW 
#define SetServiceAsTrusted             SetServiceAsTrustedW
#else
#define InstallPerfDll                  InstallPerfDllA
#define LoadPerfCounterTextStrings      LoadPerfCounterTextStringsA
#define UnloadPerfCounterTextStrings    UnloadPerfCounterTextStringsA
#define UpdatePerfNameFiles             UpdatePerfNameFilesA
#define SetServiceAsTrusted             SetServiceAsTrustedA
#endif

#ifdef __cplusplus
}
#endif


#endif // _LOADPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\macamd64.inc ===
;++
;
; Copyright (c) Microsoft Corporation.  All rights reserved.
;
;
; Module:
;
;   macamd64.w
;
; Astract:
;
;   Contains AMD64 public architecture constants and assembly macros.
;
; Author:
;--

;++
;
; push_reg <reg>
;
; Macro Description:
;
;   This macro emits a single-byte push <reg> instruction in a
;   nested prologue, as well as the associated unwind code.
;
; Arguments:
;
;   reg - supplies the integer register to push
;
;--

push_reg macro Reg

        push    Reg
        .pushreg Reg

        endm

;++
;
; rex_push_reg <reg>
;
; Macro Description:
;
;   This macro emits a single-byte push <reg> instruction in a
;   nested prologue, as well as the associated unwind code.
;
;   This differs from push_reg only in that a redundant rex prefix
;   is added.  rex_push_reg must be used in lieu of push_reg when it
;   appears as the first instruction in a function, as the calling
;   standard dictates that functions must not begin with a single
;   byte instruction.
;
; Arguments:
;
;   reg - supplies the integer register to push
;
;--

rex_push_reg macro Reg

        db      048h
        push    Reg
        .pushreg Reg

        endm

;++
;
; push_eflags
;
; Macro Description:
;
;   This macro emits a single-byte pushfq instruction in a
;   nested prologue, as well as the associated unwind code.
;
; Arguments:
;
;   none
;
;--

push_eflags macro

        pushfq
        .allocstack 8

        endm

;++
;
; rex_push_eflags
;
; Macro Description:
;
;   This macro emits a single-byte pushfq instruction in a
;   nested prologue, as well as the associated unwind code.
;
;   This differs from push_eflags only in that a redundant rex prefix
;   is added.  rex_push_eflags must be used in lieu of push_eflags when it
;   appears as the first instruction in a function, as the calling
;   standard dictates that functions must not begin with a single
;   byte instruction.
;
; Arguments:
;
;   none
;
;--

rex_push_eflags macro

        db      048h
        pushfq
        .allocstack 8

        endm

;++
;
; ret_zero
;
; Macro Description:
;
;   This macro emits a three byte return instruction.
;
;   This differs from the typical ret in that it adds additional padding bytes
;   that prevent branch misprediction problems when the ret is the target of
;   a (un)conditional branch, or is immediately preceded by a conditional branch.
;
; Arguments:
;
;   none
;
;--

ret_zero macro

        db      0c2h, 0, 0

        endm

;++
;
; alloc_stack <Size>
;
; Macro Description:
;
;   This macro emits an opcode to subtract <Size> from rsp, as well
;   as the associated unwind code.
;
; Arguments:
;
;   Size - The number of bytes to subtract from rsp.
;
;--

alloc_stack macro Size

        sub     rsp, Size
        .allocstack Size

        endm

;++
;
; save_reg   <Reg>, <Offset>
;
; Macro Description:
;
;   This macro emits an opcode to save the non-volatile 64-bit general purpose
;   register indicated by <Reg> at offset <Offset> relative to the current
;   position of the stack pointer.  It also generates the associated unwind
;   code.
;
; Arguments:
;
;   Reg - Supplies the integer register to save
;
;   Offset - Supplies the offset relative to the current position of the stack
;            pointer.
;
;--

save_reg macro Reg, Offset

        mov     Offset[rsp], Reg
        .savereg Reg, Offset

        endm

;++
;
; save_xmm128   <Reg>, <Offset>
;
; Macro Description:
;
;   This macro emits an opcode to save the 128-bit non-volatile xmm register
;   indicated by <Reg> at offset <Offset> relative to the current position
;   of the stack pointer.  It also generates the associated unwind code.
;
; Arguments:
;
;   Reg - Supplies the xmm register register to save
;
;   Offset - Supplies the offset relative to the current position of the stack
;            pointer.
;
;--

save_xmm128 macro Reg, Offset

        movaps  Offset[rsp], Reg
        .savexmm128 Reg, Offset

        endm

;++
;
; push_frame
;
; Macro Description:
;
;   This macro emits unwind data indicating that a machine frame has been
;   pushed on the stack (usually by the CPU in response to a trap or fault).
;
; Arguments:
;
;   None.
;
;--

push_frame macro Code

        .pushframe Code

        endm

;++
;
; set_frame <Reg>, <Offset>
;
; Macro Description:
;
;   This macro emits an opcode and unwind data establishing the use of <Reg>
;   as the current stack frame pointer.
;
; Arguments:
;
;   Reg - Supplies the integer register to use as the current stack frame
;         pointer.
;
;   Offset - Supplies the optional offset of the frame pointer relative to
;            the stack frame.  In stack frames greater than 080h bytes,
;            a non-zero offset can help reduce the size of subsequent opcodes
;            that access portions of the stack frame by facilitating the use of
;            positive and negative single-byte displacements.
;
;            If not supplied, no offset is assumed.
;
;--

set_frame macro Reg, Offset

if Offset

        lea     Reg, Offset[rsp]

else

        mov     Reg, rsp

endif

        .setframe Reg, Offset

        endm

;++
;
; END_PROLOGUE
;
; Macro Description:
;
;   This macro marks the end of the prologue.  This must appear after all
;   of the prologue directives in a nested function.
;
; Arguments:
;
;   None.
;
;--

END_PROLOGUE macro

        .endprolog

        endm

;++
;
; LEAF_ENTRY <Name>, <Section>, <NoPad>
;
; Macro Description:
;
;   This macro indicates the beginning of a leaf function.
;
;   A leaf function is one that DOES NOT:
;
;   - manipulate non-volatile registers
;   - manipulate the stack pointer
;   - call other functions
;   - reference an exception handler
;   - contain a prologue
;   - have any unwind data associated with it
;
; Arguments:
;
;   Name - Supplies the name of the function
;
;   Section - Supplies the name of the section within which the function
;             is to appear
;
;   NoPad - If present, indicates that the function should not be prefixed
;           with 6 bytes of padding.  This is for internal use only - the
;           calling standard dictates that functions (nested and leaf) must
;           be prefixed with padding.
;
;--

LEAF_ENTRY macro Name, Section, NoPad

Section segment para 'CODE'

ifb <NoPad>

        db      6 dup (0cch)

endif

        align   16

        public  Name
Name    proc    frame

        END_PROLOGUE

        endm

;++
;
;  LEAF_ENTRY_ARG1 <Name>, <Section>, <Arg1>, <NoPad>
;
; Macro Description:
;
; Indicates the beginning of a leaf function, as LEAF_ENTRY above,
; and declares one input parameter so that debug info will be
; generated for it. The other forms, LEAF_ENTRY_ARG2 and LEAF_ENTRY_ARG3,
; are similar.
;
;--

LEAF_ENTRY_ARG1 macro Name, Section, Arg1, NoPad

Section segment para 'CODE'

ifb <NoPad>

        db      6 dup (0cch)

endif

        align   16

        public  Name
Name    proc    frame

        END_PROLOGUE

        endm

;++
;
; LEAF_ENTRY_ARG2 <Name>, <Section>, <Arg1>, <Arg2>, <NoPad>
;
; Macro Description:
;
; As LEAF_ENTRY_ARG1 above, marks the entry to a leaf function
; and defines 2 input parameters.
;
;--

LEAF_ENTRY_ARG2 macro Name, Section, Arg1, Arg2, NoPad

Section segment para 'CODE'

ifb <NoPad>

        db      6 dup (0cch)

endif

        align   16

        public  Name
Name    proc    frame

        END_PROLOGUE

        endm

;++
;
; LEAF_ENTRY_ARG3 <Name>, <Section>, <Arg1>, <Arg2>, <Arg3>, <NoPad>
;
; Macro Description:
;
; As LEAF_ENTRY_ARG1 above, marks the entry to a leaf function
; and defines 3 input parameters.
;
;--

LEAF_ENTRY_ARG3 macro Name, Section, Arg1, Arg2, Arg3, NoPad

Section segment para 'CODE'

ifb <NoPad>

        db      6 dup (0cch)

endif

        align   16

        public  Name
Name    proc    frame

        END_PROLOGUE

        endm

;++
;
; LEAF_END <Name>, <Section>
;
; Macro Description:
;
;   This macro indicates the end of a leaf function.  It must be paired
;   with a LEAF_ENTRY macro that includes matching Name and Section
;   parameters.
;
; Arguments:
;
;   Name - Supplies the name of the function.  Must match that supplied to
;          the corresponding LEAF_ENTRY macro.
;
;   Section - Supplies the name of the section within which the function
;             is to appear.  Must match that supplied to the corresponding
;             LEAF_ENTRY macro.
;
;--

LEAF_END macro Name, section

Name    endp

Section ends

        endm

;++
;
; NESTED_ENTRY <Name>, <Section>, <Handler>, <NoPad>
;
; Macro Description:
;
;   This macro indicates the beginning of a nested function.
;
;   A nested function is one that does any of the following:
;
;   - manipulates non-volatile registers
;   - manipulates the stack pointer
;   - references an exception handler
;   - calls other functions
;
;   A nested function must include a prologue with unwind data.
;
; Arguments:
;
;   Name - Supplies the name of the function.
;
;   Section - Supplies the name of the section within which the function
;             is to appear.
;
;   Handler - Supplies the name of the handler for exceptions raised
;             within the scope of this function.
;
;   NoPad - If present, indicates that the function should not be prefixed
;           with 6 bytes of padding.  This is for internal use only - the
;           calling standard dictates that functions (nested and leaf) must
;           be prefixed with padding.
;
;--

NESTED_ENTRY macro Name, Section, Handler, NoPad

ifdef _CurrentSection_

ifdif <Section>, _CurrentSection_

.err <NESTED_ENTRY invoked for different sections within same module>

endif

endif

_CurrentSection_ EQU <Section>

Section segment para 'CODE'

ifb <NoPad>

        db      6 dup (0cch)

endif

        align   16

        public  Name

ifb <Handler>

Name    proc    frame

else

Name    proc    frame:Handler

endif

        endm

;++
;
; NESTED_END <Name>, <Section>
;
; Macro Description:
;
;   This macro indicates the end of a nested function.  It must be paired
;   with a NESTED_ENTRY macro that includes matching Name and Section
;   parameters.
;
; Arguments:
;
;   Name - Supplies the name of the function.  Must match that supplied to
;          the corresponding NESTED_ENTRY macro.
;
;   Section - Supplies the name of the section within which the function
;             is to appear.  Must match that supplied to the corresponding
;             NESTED_ENTRY macro.
;
;--

NESTED_END macro Name, section

Name    endp

Section ends

        endm

;++
;
; ALTERNATE_ENTRY <Name>
;
; Macro Description:
;
;   This macro indicates an alternate entry point in a function, or
;   a synonymous name for an existing function.
;
; Arguments:
;
;   Name - Supplies the name of the alternate entry point.
;
;--

ALTERNATE_ENTRY macro Name

Name:
        endm

;++
;
; Yield
;
; Macro Description:
;
;   This macro generates a yield instruction, interpreted by SMT processors
;   as an indication of a stall or idle condition.
;
; Arguments:
;
;   None.
;
;--

Yield   macro

        pause                           ; yield execution on SMT processors

        endm
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\madcapcl.h ===
// Copyright (c) 1990-1999  Microsoft Corporation
#ifndef _MADCAPCL_H_
#define _MADCAPCL_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <time.h>

#if _MSC_VER > 1000
#pragma once
#endif

#define MCAST_CLIENT_ID_LEN 17

enum {
    MCAST_API_VERSION_0 = 0,
    MCAST_API_VERSION_1
};

#define MCAST_API_CURRENT_VERSION MCAST_API_VERSION_1

typedef unsigned short IP_ADDR_FAMILY;

typedef union _IPNG_ADDRESS {
    DWORD   IpAddrV4;
    BYTE    IpAddrV6[16];
} IPNG_ADDRESS, *PIPNG_ADDRESS;


/*++
Description:

    This union is used to pass both IPv4 and IPv6 style address.

Members:

    IpAddrV4 - IPv4 style address

    IpAddrV6 - IPv6 style address

--*/

typedef struct _MCAST_CLIENT_UID {
    LPBYTE ClientUID;
    DWORD ClientUIDLength;
} MCAST_CLIENT_UID, *LPMCAST_CLIENT_UID;

/*++
Description:

    This describes the unique clientID for each request.

Members:

    ClientUID - Buffer containing the clientID

    ClientUIDLength - The size of the above buffer in bytes.

--*/


typedef struct _MCAST_SCOPE_CTX {
    IPNG_ADDRESS      ScopeID;
    IPNG_ADDRESS      Interface;
    IPNG_ADDRESS      ServerID;
} MCAST_SCOPE_CTX, *PMCAST_SCOPE_CTX;

/*++
Description:

    This defines the handle of the scope from which the address
    is to be allocated/renewed/released.

Members:

    ScopeID - Scope ID is essentially first ip of the scope

    Interface - Interface on which this scope was found

    ServerID - IPAddress of the MADCAP server

--*/


typedef struct _MCAST_SCOPE_ENTRY {
    MCAST_SCOPE_CTX ScopeCtx;
    IPNG_ADDRESS      LastAddr;
    DWORD       TTL;
    UNICODE_STRING  ScopeDesc;
} MCAST_SCOPE_ENTRY, *PMCAST_SCOPE_ENTRY;

/*++
Description:

    This structure contains all the info pertaining to a given multicast
    scope.

Members:

    ScopeCtx - the handle for this scope

    LastAddr - last addr of the scope

    TTL - TTL value of this scope.

    ScopeDesc - user friendly description of scope

--*/



typedef struct _MCAST_LEASE_REQUEST {
    LONG        LeaseStartTime;
    LONG        MaxLeaseStartTime;
    DWORD       LeaseDuration;
    DWORD       MinLeaseDuration;
    IPNG_ADDRESS  ServerAddress;
    WORD        MinAddrCount;
    WORD        AddrCount;
    PBYTE       pAddrBuf;
} MCAST_LEASE_REQUEST, *PMCAST_LEASE_REQUEST;

/*++
Description:

    This structure is used to describe the request parameters for
    requesting/renewing/releasing multicast addresses

Members:

    LeaseStartTime - desired start time of the lease, pass 0 if desired start time
                     is current time. The desired time is specified in the number of seconds elapsed
                     since midnight (00:00:00), January 1, 1970, coordinated universal time.

    MaxLeaseStartTime - the maximum start time that the client is willing to accept.
                        Where time is the number of seconds elapsed since midnight (00:00:00),
                        January 1, 1970, coordinated universal time.

    LeaseDuration - desired lease time for the request, pass 0 if default
                    lease time is requested.

    MinLeaseDuration - the minimum lease time that the client is willing
                       to accept

    ServerAddress - server's ip address where this lease whas renewed/requested.
                    pass 0 if unknown (e.g in McastRequestAddress)

    MinAddrCount - minimum number of addresses that the client is willing
                   to accept

    AddrCount - the desired number of addresses requested/allocated/renewed.
                This also specifies the size of the array specified by Addr.

    pAddrBuf - buffer containing specific addresses being requested/renewed/released.
                For IPv4 it is a pointer to 4 byte addresses and for IPv6 it
                points to 16 byte chunks. Pass NULL if no specific addresses
                are requested.

Remarks:

    In MCAST_API_VERSION_1 version, the MaxLeaseStartTime, MinLeaseDuration and
    MinAddrCount are ignored by the API implementation. However, the clients should
    set appropriate desired values for these members so as when the OS update brings
    new implementation of the APIs then the clients can take advantage of it.

--*/


typedef struct _MCAST_LEASE_RESPONSE {
    LONG        LeaseStartTime;
    LONG        LeaseEndTime;
    IPNG_ADDRESS  ServerAddress;
    WORD        AddrCount;
    PBYTE       pAddrBuf;
} MCAST_LEASE_RESPONSE, *PMCAST_LEASE_RESPONSE;

/*++

Description:

    This structure is used to pass the response of the operation of
    requesting/renewing/releasing multicast addresses.

Members:

    LeaseStartTime - start time of the lease in number of seconds elapsed since
                     midnight (00:00:00), January 1, 1970, coordinated universal time.

    LeaseEndTime - time when lease ends, where time is the number of seconds elapsed
                   since midnight (00:00:00), January 1, 1970, coordinated universal time.

    ServerAddress - server's ip address where this lease is renewed/requested.

    AddrCount - number of addresses requested/allocated/renewed.
                This also specifies the size of the array specified by Addr.

    Addr - buffer containing addresses being requested/renewed/released. For IPv4
            it is a pointer to 4 byte addresses and for IPv6 it points to 16 byte chunks

--*/

DWORD
APIENTRY
McastApiStartup(
    IN  OUT  PDWORD   Version
    );

VOID
APIENTRY
McastApiCleanup(
    VOID
    );

DWORD
APIENTRY
McastGenUID(
    IN OUT LPMCAST_CLIENT_UID    pRequestID
    );

DWORD
APIENTRY
McastEnumerateScopes(
    IN     IP_ADDR_FAMILY       AddrFamily,
    IN     BOOL                 ReQuery,
    IN OUT PMCAST_SCOPE_ENTRY   pScopeList,
    IN OUT PDWORD               pScopeLen,
    OUT    PDWORD               pScopeCount
    );

DWORD
APIENTRY
McastRequestAddress(
    IN     IP_ADDR_FAMILY           AddrFamily,
    IN     LPMCAST_CLIENT_UID       pRequestID,
    IN     PMCAST_SCOPE_CTX         pScopeCtx,
    IN     PMCAST_LEASE_REQUEST     pAddrRequest,
    IN OUT PMCAST_LEASE_RESPONSE    pAddrResponse
    );

DWORD
APIENTRY
McastRenewAddress(
    IN     IP_ADDR_FAMILY           AddrFamily,
    IN     LPMCAST_CLIENT_UID       pRequestID,
    IN     PMCAST_LEASE_REQUEST     pRenewRequest,
    IN OUT PMCAST_LEASE_RESPONSE    pRenewResponse
    );

DWORD
APIENTRY
McastReleaseAddress(
    IN     IP_ADDR_FAMILY          AddrFamily,
    IN     LPMCAST_CLIENT_UID      pRequestID,
    IN     PMCAST_LEASE_REQUEST    pReleaseRequest
    );

#ifdef __cplusplus
}
#endif 
#endif _MADCAPCL_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\magnification.h ===
// -------------------------------------------------------------
// magnification.h
//
// Magnification Control API
//
// Copyright (c) Microsoft Corporation. All rights reserved.
// -------------------------------------------------------------


#ifndef _INC_MAGNIFIER
#define _INC_MAGNIFIER

#ifndef __wincodec_h__
#include <wincodec.h>
#endif

#ifdef __cplusplus    // If used by C++ code, 
extern "C" {          // we need to export the C interface
#endif

#ifdef _WIN32

// Magnifier Class Name
#define WC_MAGNIFIERA             "Magnifier"
#define WC_MAGNIFIERW             L"Magnifier"

#ifdef UNICODE
#define WC_MAGNIFIER              WC_MAGNIFIERW
#else
#define WC_MAGNIFIER              WC_MAGNIFIERA
#endif

#else
#define WC_MAGNIFIER              "Magnifier"
#endif

// Magnifier Window Styles
#define MS_SHOWMAGNIFIEDCURSOR      0x0001L
#define MS_CLIPAROUNDCURSOR         0x0002L
#define MS_INVERTCOLORS             0x0004L


// Filter Modes
#define MW_FILTERMODE_EXCLUDE   0
#define MW_FILTERMODE_INCLUDE   1

typedef struct tagMAGTRANSFORM
{
    float v[3][3];
} MAGTRANSFORM, *PMAGTRANSFORM;

typedef struct tagMAGIMAGEHEADER
{
    UINT width;
    UINT height;
    WICPixelFormatGUID format;
    UINT stride;
    UINT offset;
    SIZE_T cbSize;
} MAGIMAGEHEADER, *PMAGIMAGEHEADER;

typedef struct tagMAGCOLOREFFECT
{
    float transform[5][5];
} MAGCOLOREFFECT, *PMAGCOLOREFFECT;

typedef BOOL (CALLBACK* MagImageScalingCallback)(HWND hwnd, void * srcdata, MAGIMAGEHEADER srcheader, void * destdata, MAGIMAGEHEADER destheader, RECT unclipped, RECT clipped, HRGN dirty );

// Public Functions
BOOL WINAPI MagInitialize();
BOOL WINAPI MagUninitialize();

BOOL WINAPI MagSetWindowSource(HWND hwnd, RECT rect);
BOOL WINAPI MagGetWindowSource(HWND hwnd, RECT *pRect);
BOOL WINAPI MagSetWindowTransform(HWND hwnd, PMAGTRANSFORM pTransform);
BOOL WINAPI MagGetWindowTransform(HWND hwnd, PMAGTRANSFORM pTransform);
BOOL WINAPI MagSetWindowFilterList(HWND hwnd, DWORD dwFilterMode, int count, HWND *pHWND );
int  WINAPI MagGetWindowFilterList(HWND hwnd, DWORD *pdwFilterMode, int count, HWND *pHWND );
BOOL WINAPI MagSetImageScalingCallback(HWND hwnd, MagImageScalingCallback callback );
MagImageScalingCallback WINAPI MagGetImageScalingCallback(HWND hwnd );
BOOL WINAPI MagSetColorEffect(HWND hwnd, PMAGCOLOREFFECT pEffect);
BOOL WINAPI MagGetColorEffect(HWND hwnd, PMAGCOLOREFFECT pEffect);


#ifdef __cplusplus
}
#endif

#endif // !_INC_MAGNIFIER
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Make.Inc ===
#----------------------------------------------------------------------------
#
# Descriptions:
#   Generic Make File Header for EDK
#
# Copyright:
#   Copyright (C) Microsoft Corp. 1993-1999.  All Rights Reserved.
#
#----------------------------------------------------------------------------


#*********************************************
# Check Component Name
#*********************************************

!ifndef COMP
!     ERROR Component name (COMP) has not been defined.
!endif


#*********************************************
# Parameter Defaults
#*********************************************

!ifndef BKOFFICE
BKOFFICE=c:\BkOffice
!endif

!if [DIR $(BKOFFICE) >NUL] != 0
!   ERROR Cannot find project root at $(BKOFFICE), set BKOFFICE variable
!endif

!ifndef INCLUDE
!   ERROR INCLUDE variable is empty; must include at least system include directory
!endif

!ifndef LIB
!   ERROR LIB variable is empty; must include at least system lib directory
!endif

!ifndef BLDTYPE
BLDTYPE=DBG
!endif

!ifndef CALL
CALL=C
!endif

!ifndef PACK
PACK=YES
!endif

!ifndef OUTERR
OUTERR=NO
!endif

!ifndef WARNING_LEVEL
WARNING_LEVEL=3
!endif

OSTARG=NTx86
OSTAG=WIN32
WINTAG=32
CPUTARG=IX86


#*********************************************
# Tools
#*********************************************

MAKEEXE = nmake
IMPLIB  = implib
CC      = cl
LIBU    = lib
LINK    = link
RC      = rc
MC      = mc
HC      = hc


#*********************************************
#
# Directories
#
# DIRINC   - project level include
# DIRBIN   - project level executables
# DIRLIB   - project level libraries
# DIRMAKE  - project makefiles
#
# DIRSRC   - component source directory
# DIRH     - component headers
# DIRRES   - component resources
# DIRBLD   - component build directory
# DIRPCHSRC- Pre-compiled header source directory
# DIRPCH   - Pre-compiled header output directory
#
#*********************************************

# Project directories
DIRINC=$(BKOFFICE)\include
DIRLIB=$(BKOFFICE)\lib
DIRBIN=$(BKOFFICE)\bin
DIRMAKE=$(BKOFFICE)\include

# Component directories
DIRBLD=.
DIRSRC=.
DIRH=.;$(DIRBLD)
DIRRES=.

# Pre-compiled header directories
DIRPCHSRC=$(BKOFFICE)\Samples\Exchange\Tools\PreCompH
DIRPCH=$(BKOFFICE)\Samples\Exchange\Tools\PreCompH

#*********************************************
# Paths
#*********************************************

PATH    = $(DIRBIN);$(PATH)
LIB     = $(DIRLIB);$(LIB)
INCLUDE = $(DIRH);$(DIRINC);$(INCLUDE)


#*********************************************
# Output Redirection
#*********************************************

!if "$(OUTERR)" == "NO"
ERRFILE=
OSYM=
!else
ERRFILE=$(DIRBLD)\$(COMP).err
OSYM= >>
!endif


#*********************************************
# Basic Compile Flags
#*********************************************

# CL is for all C and C++ files
CL= -I. -c -G3s -MT -W$(WARNING_LEVEL) -WX -J -Zp -Fo$(DIRBLD)^\ -nologo $(CL)

# NT/CPU specific flags
CL= -DWIN32 -D_X86_ $(CL)

# CFLAGS is for C files
#CFLAGS=$(CFLAGS)

# CPPFLAGS is for C++ files
#CPPFLAGS=$(CPPFLAGS)

# LFLAGS is for linking
LFLAGS=/NOD /NOLOGO -machine:$(CPUTARG) -out:$@ $(LFLAGS)

# DLLFLAGS is for linking DLLs
DLLFLAGS=$(LFLAGS) -dll -def:$(@B).def -map:$(DIRBLD)\$(COMP).map $(DLLFLAGS)

# LIBFLAGS is for building libraries
LIBFLAGS=-nologo -machine:$(CPUTARG) -out:$@ $(LIBFLAGS)

# RFLAGS is for Windows resources
RFLAGS=/r -I$(DIRRES) -fo$@ $(RFLAGS)

# MFLAGS is for the message compiler
MFLAGS=-v -s -h $(DIRBLD) -r $(DIRBLD) -x $(DIRBLD) $(MFLAGS)

# MRFLAGS is for the resource compiler when used after the message compiler
MRFLAGS=-l 409 -r -x -i$(DIRBLD) $(MRFLAGS)

#*********************************************
# Pre-compiled header macros
# NOPCH     - Define this to disable use and creation of precompiled headers.
# PCHUSE    - The default pre-compiled header for .C source files.
# PCUSECPP  - The default pre-compiled header for .CPP source files.
#
# PCHCR1    - To create the PCH file most .C sources depend upon.   (edk.h)
# PCHUSE1   - To use the PCH file most .C sources depend upon.      (edk.h)
# PCHCR2    - To create the PCH file most .CPP sources depend upon. (edk.h)
# PCHUSE2   - To use the PCH file most .CPP sources depend upon.    (edk.h)
# PCHCR3    - To create MFC PCH.                                 (edkafx.h)
# PCHUSE3   - To use MFC PCH.                                    (edkafx.h)
# PCHCR4    - To create the UNICODE PCH file for .C sources.        (edk.h)
# PCHUSE4   - To use the UNICODE PCH file for .C sources.           (edk.h)
#*********************************************

!ifndef NOPCH
# We are using precompiled headers.

PCHCR1  =  /Fp$(DIRPCH)\edk.pch    /Yc"edk.h"    -Fo$(DIRPCH)\ /Yd
PCHUSE1 =  /Fp$(DIRPCH)\edk.pch    /Yu"edk.h"
PCHCR2  =  /Fp$(DIRPCH)\edkx.pch   /Yc"edk.h"    -Fo$(DIRPCH)\ /Yd
PCHUSE2 =  /Fp$(DIRPCH)\edkx.pch   /Yu"edk.h"
PCHCR3  =  /Fp$(DIRPCH)\edkafx.pch /Yc"edkafx.h" -Fo$(DIRPCH)\ /Yd
PCHUSE3 =  /Fp$(DIRPCH)\edkafx.pch /Yu"edkafx.h"
PCHCR4  =  /Fp$(DIRPCH)\edku.pch   /Yc"edk.h"    -Fo$(DIRPCH)\ /Yd
PCHUSE4 =  /Fp$(DIRPCH)\edku.pch   /Yu"edk.h"

# Overide this to change the default pre-compiled header.
# You can also blank this if not using pre-compiled headers.
!ifndef PCHUSE
PCHUSE=$(PCHUSE1)
!endif
!ifndef PCHUSECPP
PCHUSECPP=$(PCHUSE2)
!endif

PCHOBJ1 = $(DIRPCH)\edk.obj
PCHOBJ2 = $(DIRPCH)\edkx.obj
PCHOBJ3 = $(DIRPCH)\edkafx.obj
PCHOBJ4 = $(DIRPCH)\edku.obj

!else
# NOT using precompiled headers.
!include "nopch.inc"
!endif

#*********************************************
# Calling convention Flag
#*********************************************

# Pascal Calling convention
!if "$(CALL)"=="PASCAL"
CL=-Gc $(CL)
!endif


#*********************************************
# Function Packaging Flag
#*********************************************

# Function packaging flag
!if "$(PACK)" == "YES"
CL=-Gy $(CL)
!endif


#*********************************************
# Optimization Flags
#*********************************************

!if "$(BLDTYPE)"=="SHP"
CL=-Ob1 -Og -Os $(CL)
!endif

!if "$(BLDTYPE)"=="DBG"
CL=-Od -Z7 $(CL)
!endif

!if "$(BLDTYPE)"=="TST"
CL=-Ob1 -Og -Os $(CL)
!endif


#*********************************************
# Build Type Flags
#*********************************************

!if "$(BLDTYPE)"=="SHP"
CL=-DSHIP $(CL)
LFLAGS=-debug:none -nodefaultlib:libc $(LFLAGS)
!endif

!if "$(BLDTYPE)"=="DBG"
CL=-DDEBUG -DTEST $(CL) 
LFLAGS=-debug:full -debugtype:cv -nodefaultlib:libc -incremental:no -pdb:none $(LFLAGS) 
!endif

!if "$(BLDTYPE)"=="TST"
CL=-DTEST $(CL)
LFLAGS=-debug:none  -nodefaultlib:libc $(LFLAGS)
!endif


#*********************************************
# Default Libraries
#*********************************************

# C Libraries 
CLIBS =  libcmt.lib \
         oldnames.lib

# NT Libraries
NTLIBS = kernel32.lib \
         user32.lib   \
         shell32.lib  \
         gdi32.lib    \
         ole32.lib    \
         uuid.lib     \
         winspool.lib \
         comdlg32.lib \
         advapi32.lib \
         netapi32.lib \
         imagehlp.lib \
         wsock32.lib  \
         rpcdce4.lib  \
         rpcndr.lib   \
         rpcns4.lib   \
         rpcrt4.lib
        
# MAPI Libraries
MAPILIBS = MAPI32.LIB

# Library List
# Components should either add to this list with a line like:
#      LIBLIST = $(LIBLIST) mylibs
# or, if they don't need all the default libs, (e.g. if don't need MAPI):
#      LIBLIST = $(CLIBS) $(NTLIBS) mylibs
LIBLIST = $(LIBLIST) $(CLIBS) $(NTLIBS) $(MAPILIBS)

# Objects
# This is just a default setting, expect most make files to 
# overide this (i.e. if they have more than one object or their
# one object is not named $(COMP).obj
!ifndef OBJLIST
OBJLIST=$(DIRBLD)\$(@B).OBJ
!endif


#*********************************************
# Inference Rules
#*********************************************

# C Targets
{$(DIRSRC)\}.c{$(DIRBLD)\}.obj:
!if "$(OUTERR)"=="YES"
    @echo $(CC) $(CL) $(PCHUSE) $(CFLAGS) $< $(OSYM) $(ERRFILE)
!endif
    $(CC) $(CL) $(PCHUSE) $(CFLAGS) $< $(OSYM) $(ERRFILE)

# C++ Targets
{$(DIRSRC)\}.cpp{$(DIRBLD)\}.obj:
!if "$(OUTERR)"=="YES"
    @echo $(CC) $(CL) $(PCHUSECPP) $(CPPFLAGS) $< $(OSYM) $(ERRFILE)
!endif
    $(CC) $(CL) $(PCHUSECPP) $(CPPFLAGS) $< $(OSYM) $(ERRFILE)

# Resource Targets from .RC files
{$(DIRRES)\}.rc{$(DIRBLD)\}.res:
!if "$(OUTERR)"=="YES"
    @echo $(RC) $(RFLAGS) $(DIRRES)\$(@B).rc $(OSYM) $(ERRFILE)
!endif
    $(RC) $(RFLAGS) $(DIRRES)\$(@B).rc $(OSYM) $(ERRFILE)

# Resource Targets from .MC files
.SUFFIXES: .mc
{$(DIRSRC)\}.mc{$(DIRBLD)\}.res:
!if "$(OUTERR)"=="YES"
    @echo $(MC) $(MFLAGS) $< $(OSYM) $(ERRFILE)
!endif
    $(MC) $(MFLAGS) $< $(OSYM) $(ERRFILE)
!if "$(OUTERR)"=="YES"
    @echo $(RC) $(MRFLAGS) -fo$(DIRBLD)\$(@B).res $(DIRBLD)\$(@B).rc $(OSYM) $(ERRFILE)
!endif
    $(RC) $(MRFLAGS) -fo$(DIRBLD)\$(@B).res $(DIRBLD)\$(@B).rc $(OSYM) $(ERRFILE)
!if "$(OUTERR)"=="YES"
    @echo del $(DIRBLD)\$(@B).rc $(OSYM) $(ERRFILE)
!endif
        del $(DIRBLD)\$(@B).rc $(OSYM) $(ERRFILE)

# Import Libraries
{$(DIRSRC)\}.def{$(DIRBLD)\}.lib:
!if "$(OUTERR)"=="YES"
    @echo $(IMPLIB) -DEF:$(@B).DEF -OUT:$@ $(OSYM) $(ERRFILE)
!endif
    @echo $(IMPLIB) -DEF:$(@B).DEF -OUT:$@ $(OSYM) $(ERRFILE)
    xcopy $@ $(DIRLIB) $(OSYM) $(ERRFILE)

# Static Libraries
{$(DIRBLD)\}.obj{$(DIRBLD)\}.lib:
!if "$(OUTERR)"=="YES"
    @echo $(LIBU) $(LIBFLAGS) $** $(OSYM) $(ERRFILE)
!endif
    $(LIBU) $(LIBFLAGS) $** $(OSYM) $(ERRFILE)
    xcopy $@ $(DIRLIB) $(OSYM) $(ERRFILE)

# DLLs
{$(DIRBLD)\}.obj{$(DIRBLD)\}.dll:
    @echo $** > $(DIRBLD)\objfiles.lst
    @echo $(LIBLIST) > $(DIRBLD)\libfiles.lst
!if "$(OUTERR)"=="YES"
    @echo   $(LINK) $(DLLFLAGS) @$(DIRBLD)\objfiles.lst @$(DIRBLD)\libfiles.lst $(OSYM) $(ERRFILE)
!endif
    $(LINK) $(DLLFLAGS) @$(DIRBLD)\objfiles.lst @$(DIRBLD)\libfiles.lst $(OSYM) $(ERRFILE)
!if "$(OUTERR)"=="YES"
    @echo xcopy $(DIRBLD)\$(@B).lib $(DIRLIB) $(OSYM) $(ERRFILE)
!endif
    -xcopy $(DIRBLD)\$(@B).lib $(DIRLIB) $(OSYM) $(ERRFILE)

# EXEs
{$(DIRBLD)\}.obj{$(DIRBLD)\}.exe:
    @echo $(OBJLIST) > $(DIRBLD)\objfiles.lst
    @echo $(LIBLIST) > $(DIRBLD)\libfiles.lst
!if "$(OUTERR)"=="YES"
    @echo   $(LINK) $(LFLAGS) @$(DIRBLD)\objfiles.lst @$(DIRBLD)\libfiles.lst $(OSYM) $(ERRFILE)
!endif
    $(LINK) $(LFLAGS) @$(DIRBLD)\objfiles.lst @$(DIRBLD)\libfiles.lst $(OSYM) $(ERRFILE)


#*********************************************
# Define the post-include file
#*********************************************

#ifndef POSTINCL
POSTINCL=$(BKOFFICE)\Include\postmake.inc
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\manipulations_i.c ===
/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for manipulations.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_ManipulationsLib,0x935610b3,0x6f81,0x450f,0x85,0xd5,0x42,0xd3,0xd2,0x6c,0x5c,0x11);


MIDL_DEFINE_GUID(IID, IID__IManipulationEvents,0x4f62c8da,0x9c53,0x4b22,0x93,0xdf,0x92,0x7a,0x86,0x2b,0xbb,0x03);


MIDL_DEFINE_GUID(IID, IID_IInertiaProcessor,0x18b00c6d,0xc5ee,0x41b1,0x90,0xa9,0x9d,0x4a,0x92,0x90,0x95,0xad);


MIDL_DEFINE_GUID(IID, IID_IManipulationProcessor,0xA22AC519,0x8300,0x48a0,0xBE,0xF4,0xF1,0xBE,0x87,0x37,0xDB,0xA4);


MIDL_DEFINE_GUID(CLSID, CLSID_InertiaProcessor,0xabb27087,0x4ce0,0x4e58,0xa0,0xcb,0xe2,0x4d,0xf9,0x68,0x14,0xbe);


MIDL_DEFINE_GUID(CLSID, CLSID_ManipulationProcessor,0x597D4FB0,0x47FD,0x4aff,0x89,0xB9,0xC6,0xCF,0xAE,0x8C,0xF0,0x8E);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MailMsgProps.h ===
/*
        @doc MAILMSG PROPERTIES
        @module mailmsgprops.h | MailMsg Properties for SMTP and NNTP
*/

/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    mailmsgprops.h

Abstract:

    This module contains the definitions for the MailMsg 
    Object property ID's.


--*/

#ifndef __MAILMSGPROPS_H__
#define __MAILMSGPROPS_H__

/*=======================================================================*/
// These macros are used to define the tables of property ID's.


#define IMMPID_START_LIST(name,start,guid)    struct __declspec(uuid(guid)) tagIMMPID_##name##_STRUCT;\
                                            typedef enum tagIMMPID_##name##_ENUM {\
                                                IMMPID_##name##_BEFORE__ = (start)-1,
#define IMMPID_END_LIST(name)                    IMMPID_##name##_AFTER__\
                                            } IMMPID_##name##_ENUM;


/*=======================================================================*/


// These are the per-message properties.

IMMPID_START_LIST(MP,0x1000,"13384CF0-B3C4-11d1-AA92-00AA006BC80B")

    // @const IMMPID | IMMPID_MP_RECIPIENT_LIST | 
    //   *** OBSOLETE ***
    IMMPID_MP_RECIPIENT_LIST,

    // @const IMMPID | IMMPID_MP_CONTENT_FILE_NAME | 
    //   *** OBSOLETE ***
    IMMPID_MP_CONTENT_FILE_NAME,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_SMTP | 
    //  ANSI String - SMTP Address of sender
    IMMPID_MP_SENDER_ADDRESS_SMTP,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_X500 | 
    //  ANSI String - X500 Address of sender
    IMMPID_MP_SENDER_ADDRESS_X500,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_X400 | 
    //  String - X400 Address of sender
    IMMPID_MP_SENDER_ADDRESS_X400,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN | 
    //  String - Legacy DN Address of sender
    IMMPID_MP_SENDER_ADDRESS_LEGACY_EX_DN,

    // @const IMMPID | IMMPID_MP_DOMAIN_LIST | 
    //   *** OBSOLETE ***
    IMMPID_MP_DOMAIN_LIST,

    // @const IMMPID | IMMPID_MP_PICKUP_FILE_NAME | 
    //  ANSI String - Filename of msg file in pickup directory
    IMMPID_MP_PICKUP_FILE_NAME,

    // @const IMMPID | IMMPID_MP_AUTHENTICATED_USER_NAME | 
    //   *** OBSOLETE ***
    IMMPID_MP_AUTHENTICATED_USER_NAME,

    // @const IMMPID | IMMPID_MP_CONNECTION_IP_ADDRESS | 
    //  ANSI String - IP address of MTA or client that submitted this message
    IMMPID_MP_CONNECTION_IP_ADDRESS,

    // @const IMMPID | IMMPID_MP_HELO_DOMAIN | 
    //  ANSI String - Domain name used in HELO/EHLO when message was submitted
    IMMPID_MP_HELO_DOMAIN,

    // @const IMMPID | IMMPID_MP_EIGHTBIT_MIME_OPTION | 
    //  BOOL - TRUE if message body is 8-bit MIME
    IMMPID_MP_EIGHTBIT_MIME_OPTION,

    // @const IMMPID | IMMPID_MP_CHUNKING_OPTION | 
    //   *** OBSOLETE ***
    IMMPID_MP_CHUNKING_OPTION,

    // @const IMMPID | IMMPID_MP_BINARYMIME_OPTION | 
    //  BOOL - TRUE if message body is binary MIME
    IMMPID_MP_BINARYMIME_OPTION,

    // @const IMMPID | IMMPID_MP_REMOTE_AUTHENTICATION_TYPE | 
    //   *** OBSOLETE ***
    IMMPID_MP_REMOTE_AUTHENTICATION_TYPE,

    // @const IMMPID | IMMPID_MP_ERROR_CODE | 
    //   *** OBSOLETE ***
    IMMPID_MP_ERROR_CODE,

    // @const IMMPID | IMMPID_MP_DSN_ENVID_VALUE | 
    //  Value of RFC1891 ENVID of submitted message
    IMMPID_MP_DSN_ENVID_VALUE,

    // @const IMMPID | IMMPID_MP_DSN_RET_VALUE | 
    //  ANSI String of what follows ESMTP RET
    IMMPID_MP_DSN_RET_VALUE,                

    // @const IMMPID | IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE | 
    //   *** OBSOLETE ***
    IMMPID_MP_REMOTE_SERVER_DSN_CAPABLE,    

    // @const IMMPID | IMMPID_MP_ARRIVAL_TIME | 
    //  FILETIME that message arrived in system
    IMMPID_MP_ARRIVAL_TIME,

    // @const IMMPID | IMMPID_MP_MESSAGE_STATUS | 
    // MP_STATUS_* value describing status of message system 
    IMMPID_MP_MESSAGE_STATUS,

    // @const IMMPID | IMMPID_MP_EXPIRE_DELAY | 
    //  FILETIME of Delay DSN Expiration
    IMMPID_MP_EXPIRE_DELAY,         

    // @const IMMPID | IMMPID_MP_EXPIRE_NDR | 
    //  FILETIME of NDR DSN Expiration
    IMMPID_MP_EXPIRE_NDR,           

    // @const IMMPID | IMMPID_MP_LOCAL_EXPIRE_DELAY | 
    //  FILETIME of Delay DSN Expiration for local recips
    IMMPID_MP_LOCAL_EXPIRE_DELAY,   

    // @const IMMPID | IMMPID_MP_LOCAL_EXPIRE_NDR | 
    //  FILETIME of NDR DSN Expiration for local recips
    IMMPID_MP_LOCAL_EXPIRE_NDR,     

    // @const IMMPID | IMMPID_MP_ARRIVAL_FILETIME | 
    //  FILETIME when message was submitted to queue
    IMMPID_MP_ARRIVAL_FILETIME,     

    // @const IMMPID | IMMPID_MP_HR_CAT_STATUS | 
    //  HRESULT MsgCat status (ie CAT_W_SOME_UNDELIVERABLE_MSGS)
    IMMPID_MP_HR_CAT_STATUS,        

    // @const IMMPID | IMMPID_MP_MSG_GUID | 
    //  String GUID ID which is only used if you want need to be able to replace 
    //  this message with another newer version.  This property is only 
    //  effective when used for a small amount of mail on the server, and is
    //  best suited for versioned mail (like DS replication).
    IMMPID_MP_MSG_GUID,        

    // @const IMMPID | IMMPID_MP_SUPERSEDES_MSG_GUID | 
    //  String GUID ID which this message superscedes.  If a message with with a 
    //  IMMPID_MP_MSG_GUID equal to this property is still on the server, then
    //  that message will not be sent out.

    IMMPID_MP_SUPERSEDES_MSG_GUID,

    // @const IMMPID | IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF | 
    //  Boolean which tells if the input was scanned for <CRLF>.<CRLF> in the msg
    // body
    IMMPID_MP_SCANNED_FOR_CRLF_DOT_CRLF,

    // @const IMMPID | IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF | 
    //  Boolean which tells if the input had any <CRLF>.<CRLF>
    //
    IMMPID_MP_FOUND_EMBEDDED_CRLF_DOT_CRLF, 

    // @const IMMPID | IMMPID_MP_MSG_SIZE_HINT | 
    //  Provides an approximate size of the message content.  Does not convert
    //  message, or guarantee accuracy. For an accurate message size (but at 
    //  a higher performance cost) use IMailMsgProperties::GetContentSize.
    //
    IMMPID_MP_MSG_SIZE_HINT, 

    // @const IMMPID | IMMPID_MP_RFC822_MSG_ID | 
    //  String -- RFC 822 Message Id header.
    IMMPID_MP_RFC822_MSG_ID,

    // @const IMMPID | IMMPID_MP_RFC822_MSG_SUBJECT | 
    //  String -- RFC822 subject header
    IMMPID_MP_RFC822_MSG_SUBJECT,

    // @const IMMPID | IMMPID_MP_RFC822_FROM_ADDRESS | 
    //  String -- RFC822 from address
    IMMPID_MP_RFC822_FROM_ADDRESS,

    // @const IMMPID | IMMPID_MP_RFC822_TO_ADDRESS | 
    //  String -- RFC822 To address
    IMMPID_MP_RFC822_TO_ADDRESS,

    // @const IMMPID | IMMPID_MP_RFC822_CC_ADDRESS | 
    //  String -- RFC822 Cc address
    IMMPID_MP_RFC822_CC_ADDRESS,

    // @const IMMPID | IMMPID_MP_RFC822_BCC_ADDRESS | 
    //  String -- RFC822 Bcc address
    IMMPID_MP_RFC822_BCC_ADDRESS,

    // @const IMMPID | IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS | 
    //  String -- server IP Address
    IMMPID_MP_CONNECTION_SERVER_IP_ADDRESS,

    // @const IMMPID | IMMPID_MP_SERVER_NAME | 
    //  String -- server name
    IMMPID_MP_SERVER_NAME,

    // @const IMMPID | IMMPID_MP_SERVER_VERSION | 
    //  String -- server version
    IMMPID_MP_SERVER_VERSION,

    // @const IMMPID | IMMPID_MP_NUM_RECIPIENTS | 
    //  DWORD -- number of recipients
    IMMPID_MP_NUM_RECIPIENTS,


    // @const IMMPID | IMMPID_MP_X_PRIORITY | 
    //  DWORD -- the priority of message
    IMMPID_MP_X_PRIORITY,

    // @const IMMPID | IMMPID_MP_FROM_ADDRESS | 
    //  String -- From: address, in form format:address 
    //  (ie, smtp:foo@microsoft.com).  RFC822 address comments are stripped
    IMMPID_MP_FROM_ADDRESS,
    
    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS | 
    //  String -- Sender: address, in form format:address 
    //  (ie, smtp:foo@microsoft.com).  RFC822 address comments are stripped
    IMMPID_MP_SENDER_ADDRESS,

    // @const IMMPID | IMMPID_MP_DEFERRED_DELIVERY_FILETIME | 
    //  FILETIME -- Universal time to wait until before allowing
    //  message to be delivered.
    IMMPID_MP_DEFERRED_DELIVERY_FILETIME,

    // @const IMMPID | IMMPID_MP_SENDER_ADDRESS_OTHER | 
    //  ANSI String - with the format "type:address"
    IMMPID_MP_SENDER_ADDRESS_OTHER,

    // @const IMMPID | IMMPID_MP_ORIGINAL_ARRIVAL_TIME | 
    //  FILETIME that message arrived in first exchange system
    IMMPID_MP_ORIGINAL_ARRIVAL_TIME,

    // @const IMMPID | IMMPID_MP_MSG_CLASS | 
    //  The Message class of the mail, e.g. syste, replication, etc...
    IMMPID_MP_MSGCLASS,

    // @const IMMPID | IMMPID_MP_CONTENT_TYPE | 
    //  The content type of message.
    //  ANSI STRING.
    IMMPID_MP_CONTENT_TYPE,

    //@const IMMPID | IMMPID_MP_ENCRYPTION_TYPE |
    // DWORD - 0, no encryption
    //         1, signed only
    //         2, encrypted
    IMMPID_MP_ENCRYPTION_TYPE,

    //@const IMMPID | IMMPID_MP_CONNECTION_SERVER_PORT | 
    // DWORD - Port (if any) that this message was submitted on 
    IMMPID_MP_CONNECTION_SERVER_PORT,

    //@const IMMPID | IMMPID_MP_CLIENT_AUTH_USER | 
    // ASCII STRING - Name of authenticated user
    IMMPID_MP_CLIENT_AUTH_USER,

    //@const IMMPID | IMMPID_MP_CLIENT_AUTH_TYPE | 
    // ASCII STRING - Type of authentication used (AUTH keyword)
    IMMPID_MP_CLIENT_AUTH_TYPE,

    //@const IMMPID | IMMPID_MP_CRC_GLOBAL |
    // DWORD - Checksum for global properties (excluding the checksum properties!)
    IMMPID_MP_CRC_GLOBAL,

    //@const IMMPID | IMMPID_MP_CRC_RECIPS |
    // DWORD - Checksum for recipient properties
    IMMPID_MP_CRC_RECIPS,

    // @const IMMPID | IMMPID_MP_INBOUND_MAIL_FROM_AUTH | 
    //  ANSI String - Contents of the RFC2554 AUTH= string on a MAIL FROM on inbound messages
    IMMPID_MP_INBOUND_MAIL_FROM_AUTH,


    // Add new per-message properties above this line.
IMMPID_END_LIST(MP)


// Message classes
// @const DWORD | MP_MSGCLASS_SYSTEM
// for msgs of type -- system
#define MP_MSGCLASS_SYSTEM       1

// @const DWORD | MP_MSGCLASS_REPLICATION
// for msgs of type -- replication
#define MP_MSGCLASS_REPLICATION  2

// @const DWORD | MP_MSGCLASS_DELIVERY_REPORT
// for msgs of type -- delivery report
#define MP_MSGCLASS_DELIVERY_REPORT     3

// @const DWORD | MP_MSGCLASS_DELIVERY_REPORT
// for msgs of type -- non-delivery report
#define MP_MSGCLASS_NONDELIVERY_REPORT  4


// Message status property values defined:

// @const DWORD | MP_STATUS_SUCCESS | 
//  Initial status of message
#define MP_STATUS_SUCCESS                    0

// @const DWORD | MP_STATUS_RETRY | 
//  Status indicating retry.
#define MP_STATUS_RETRY                      1

// @const DWORD | MP_STATUS_ABORT_DELIVERY | 
//  Delivery of this message should be aborted and the message deleted.
#define MP_STATUS_ABORT_DELIVERY             2

// @const DWORD | MP_STATUS_BAD_MAIL | 
//  This message should be moved to badmail.
#define MP_STATUS_BAD_MAIL                   3

// @const DWORD | MP_STATUS_SUBMITTED | 
//  Message has been submitted for delivery.
#define MP_STATUS_SUBMITTED                  4

// @const DWORD | MP_STATUS_CATEGORIZED | 
//  Message has been categorized.
#define MP_STATUS_CATEGORIZED                5

// @const DWORD | MP_STATUS_ABANDON_DELIVERY | 
//  Delivery of this message should be abandoned until the service restarts
#define MP_STATUS_ABANDON_DELIVERY           6

//Per recipient flags for IMMPID_RP_RECIPIENT_FLAGS

// @const DWORD | RP_RECIP_FLAGS_RESERVED | 
//  You should not modify / use these bits
#define RP_RECIP_FLAGS_RESERVED     0x0000000F 

// @const DWORD | RP_DSN_NOTIFY_SUCCESS | 
//  Notify on success - set if RFC1891 NOTIFY=SUCCESS is used
#define RP_DSN_NOTIFY_SUCCESS       0x01000000 

// @const DWORD | RP_DSN_NOTIFY_FAILURE | 
//  Notify on failure - set if RFC1891 NOTIFY=FAILURE is used
#define RP_DSN_NOTIFY_FAILURE       0x02000000 

// @const DWORD | RP_DSN_NOTIFY_DELAY | 
//  Notify on delay - set if RFC1891 NOTIFY=DELAY is used
#define RP_DSN_NOTIFY_DELAY         0x04000000 

// @const DWORD | RP_DSN_NOTIFY_NEVER | 
//  Never notify - set if RFC1891 NOTIFY=NEVER is used
#define RP_DSN_NOTIFY_NEVER         0x08000000 

// @const DWORD | RP_DSN_NOTIFY_MASK | 
//  Mask of all notify parameters
#define RP_DSN_NOTIFY_MASK          0x0F000000

//The following flags can be used in searches, but should not be set directly

// @const DWORD | RP_HANDLED | 
//  Recipient has either been delivered or should not be delivered
//  (this flag is provided to check status of recipient... it should never be used
//  directly)
#define RP_HANDLED                  0x00000010 

// @const DWORD | RP_GENERAL_FAILURE | 
//  some form of hard failure happend
//  (this flag is provided to check status of recipient... it should never be used
//  directly)
#define RP_GENERAL_FAILURE          0x00000020 

// @const DWORD | RP_DSN_HANDLED | 
//  Final DSN has been sent (or no DSN needs to be sent)
//  (this flag is provided to check status of recipient... it should never be used
//  directly)
#define RP_DSN_HANDLED              0x00000040 

//The following constants define how a message can be RP_HANDLED

// @const DWORD | RP_DELIVERED | 
//  The recipient has been delivered successfully
#define RP_DELIVERED                0x00000110 

// @const DWORD | RP_DSN_SENT_NDR | 
//  NDR (FAILED DSN) for this recipient has been sent
#define RP_DSN_SENT_NDR             0x00000450 

// @const DWORD | RP_FAILED | 
//  Recipient has a hard failure
#define RP_FAILED                   0x00000830 

// @const DWORD | RP_UNRESOLVED | 
//  This recipient was not resolved by categorization
#define RP_UNRESOLVED               0x00001030 

// @const DWORD | RP_ENPANDED | 
//  ***OBSOLETE*** (replaced by RP_EXPANDED)
#define RP_ENPANDED                 0x00002010 

// @const DWORD | RP_EXPANDED | 
//  This recipient is an expanded DL
#define RP_EXPANDED                 0x00002010 

// @const DWORD | RP_DSN_SENT_DELAYED | 
//  At least one Delay DSN sent
#define RP_DSN_SENT_DELAYED         0x00004000 

// @const DWORD | RP_DSN_SENT_EXPANDED | 
//  Expanded DSN has been sent
#define RP_DSN_SENT_EXPANDED        0x00008040 

// @const DWORD | RP_DSN_SENT_RELAYED | 
//  Relayed DSN has been sent
#define RP_DSN_SENT_RELAYED         0x00010040 

// @const DWORD | RP_DSN_SENT_DELIVERED | 
//  Delivered DSN has been sent
#define RP_DSN_SENT_DELIVERED       0x00020040 


// @const DWORD | RP_REMOTE_MTA_NO_DSN | 
//  Remote MTA does not advertise DSN support (relay might be needed)
#define RP_REMOTE_MTA_NO_DSN        0x00080000 


// @const DWORD | RP_ERROR_CONTEXT_STORE | 
//  Error happened in store driver
#define RP_ERROR_CONTEXT_STORE      0x00100000 

// @const DWORD | RP_ERROR_CONTEXT_CAT | 
//  Error happened during categorization
#define RP_ERROR_CONTEXT_CAT        0x00200000 

// @const DWORD | RP_ERROR_CONTEXT_MTA | 
//  Error happened in a MTA (eg SMTP stack)
#define RP_ERROR_CONTEXT_MTA        0x00400000 


// @const DWORD | RP_VOLATILE_FLAGS_MASK | 
//  Flags that can be used for temp storage
#define RP_VOLATILE_FLAGS_MASK      0xF0000000 
                                               //while a component has access to recipients
                                               //Once control of recipients is passed, value
                                               //is un-defined.

// @const DWORD | RP_DSN_NOTIFY_INVALID | 
//  *** OBSOLETE ***
#define RP_DSN_NOTIFY_INVALID       0x00000000 

/*=======================================================================*/


// These are the per-recipient properties.

IMMPID_START_LIST(RP,0x2000,"79E82048-D320-11d1-9FF4-00C04FA37348")


    // @const IMMPID | IMMPID_RP_DSN_NOTIFY_SUCCESS | 
    //   *** OBSOLETE ***
    IMMPID_RP_DSN_NOTIFY_SUCCESS,

    // @const IMMPID | IMMPID_RP_DSN_NOTIFY_INVALID | 
    //   *** OBSOLETE ***
    IMMPID_RP_DSN_NOTIFY_INVALID,    

    // @const IMMPID | IMMPID_RP_ADDRESS_TYPE | 
    //   *** OBSOLETE ***
    IMMPID_RP_ADDRESS_TYPE,            

    // @const IMMPID | IMMPID_RP_ADDRESS | 
    //   *** OBSOLETE ***
    IMMPID_RP_ADDRESS,                

    // @const IMMPID | IMMPID_RP_ADDRESS_TYPE_SMTP | 
    //   *** OBSOLETE ***
    IMMPID_RP_ADDRESS_TYPE_SMTP,    

    // @const IMMPID | IMMPID_RP_ERROR_CODE | 
    //   HRESULT status code
    IMMPID_RP_ERROR_CODE,            

    // @const IMMPID | IMMPID_RP_ERROR_STRING | 
    //   *** OBSOLETE ***
    IMMPID_RP_ERROR_STRING,            

    // @const IMMPID | IMMPID_RP_DSN_NOTIFY_VALUE | 
    //   *** OBSOLETE ***
    IMMPID_RP_DSN_NOTIFY_VALUE,        

    // @const IMMPID | IMMPID_RP_DSN_ORCPT_VALUE | 
    //   ANSI string - \<address type\>;\<address\>
    IMMPID_RP_DSN_ORCPT_VALUE,        

    // @const IMMPID | IMMPID_RP_ADDRESS_SMTP | 
    //   ANSI string - SMTP address
    IMMPID_RP_ADDRESS_SMTP,            

    // @const IMMPID | IMMPID_RP_ADDRESS_X400 | 
    //   ANSI string - X.400 address
    IMMPID_RP_ADDRESS_X400,            

    // @const IMMPID | IMMPID_RP_ADDRESS_X500 | 
    //   ANSI string - X.500 address
    IMMPID_RP_ADDRESS_X500,            

    // @const IMMPID | IMMPID_RP_LEGACY_EX_DN | 
    //   ANSI string - DN for Exchange 5.5 and prev
    IMMPID_RP_LEGACY_EX_DN,            

    // @const IMMPID | IMMPID_RP_RECIPIENT_FLAGS | 
    //   Per-recipient DSN/delivery flags. Flag constansts start with RP_.
    IMMPID_RP_RECIPIENT_FLAGS,      

    // @const IMMPID | IMMPID_RP_SMTP_STATUS_STRING | 
    //   ANSI string - SMTP status string... if defined
    IMMPID_RP_SMTP_STATUS_STRING,   
                                    // *must* start with 3-digit status code

    // @const IMMPID | IMMPID_RP_DSN_PRE_CAT_ADDRESS | 
    //   Original address as received by MTA in
    IMMPID_RP_DSN_PRE_CAT_ADDRESS,  
                                    // IMMPID_RP_DSN_ORCPT_VALUE format

    // @const IMMPID | IMMPID_RP_MDB_GUID | 
    //   Categorizer stamps the MDB guid
    IMMPID_RP_MDB_GUID,             
                                    // for this recipient here

    // @const IMMPID | IMMPID_RP_USER_GUID | 
    //   Categorizer stamps the
    IMMPID_RP_USER_GUID,            
                                    // objectGUID of the user object here
    // @const IMMPID | IMMPID_RP_DOMAIN | 
    //   Alternate SMTP domain for categorization
    IMMPID_RP_DOMAIN,            

    // @const IMMPID | IMMPID_RP_ADDRESS_OTHER | 
    //   ANSI string - other address type
    IMMPID_RP_ADDRESS_OTHER,            

    // @const IMMPID | IMMPID_RP_DISPLAY_NAME |
    //   Unicode string - recipient display name
    IMMPID_RP_DISPLAY_NAME,

    // Add new per-recipient properties above this line.
IMMPID_END_LIST(RP)


/*=======================================================================*/


// These are per-message volatile properties - they are not persisted to
// the property stream.

IMMPID_START_LIST(MPV,0x3000,"CBE69706-C9BD-11d1-9FF2-00C04FA37348")

    // @const IMMPID | IMMPID_MPV_STORE_DRIVER_HANDLE | 
    //  Store driver context for this message.
    IMMPID_MPV_STORE_DRIVER_HANDLE,

    // @const IMMPID | IMMPID_MPV_MESSAGE_CREATION_FLAGS | 
    //  Flags set at creation of mailmsg.
    IMMPID_MPV_MESSAGE_CREATION_FLAGS,

    // @const IMMPID | IMMPID_MPV_MESSAGE_OPEN_HANDLES | 
    // The number of handles (property and content) open for this message.
    //   0 means no handles open.
    //   1 means property or content open.
    //   2 means both property and content open.
    IMMPID_MPV_MESSAGE_OPEN_HANDLES,

    // @const IMMPID | IMMPID_MPV_TOTAL_OPEN_HANDLES | 
    // The current total number of open message handles (of any type) 
    // on this server. 
    IMMPID_MPV_TOTAL_OPEN_HANDLES,

    // @const IMMPID | IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES | 
    // The current total number of open property streams on this server. 
    IMMPID_MPV_TOTAL_OPEN_PROPERTY_STREAM_HANDLES,

    // @const IMMPID | IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES | 
    // The current total number of open content handles on this server. 
    IMMPID_MPV_TOTAL_OPEN_CONTENT_HANDLES,

    // Add new per-message volatile properties above this line.
IMMPID_END_LIST(MPV)

// This is the structure for the IMMPID_MPV_STORE_DRIVER_HANDLE property.
typedef struct tagIMMP_MPV_STORE_DRIVER_HANDLE {
    GUID guidSignature;    // signature of the store driver whose handle this is
} IMMP_MPV_STORE_DRIVER_HANDLE;

// Define message object creation flags

// @const DWORD | MPV_INBOUND_CUTOFF_EXCEEDED | 
//  Mailmsg configured cutoff has been exceeded... if this is an external 
//  delivery attempt, we should indicate that we do not have sufficient 
//  resources to accept the mail.
#define MPV_INBOUND_CUTOFF_EXCEEDED            0x00000001

// @const DWORD | MPV_WRITE_CONTENT |
//  Indicates that the content of this message can be modified.
#define MPV_WRITE_CONTENT                      0x00000002

/*=======================================================================*/


// These are per-recipient volatile properties - they are not persisted to
// the property stream.

IMMPID_START_LIST(RPV,0x4000,"79E82049-D320-11d1-9FF4-00C04FA37348")

    // @const IMMPID | IMMPID_RPV_DONT_DELIVER | 
    //  IMMPID_RPV_DONT_DELIVER is a boolean.  If set to TRUE, mailmsg 
    //  ignores this recipient when doing WriteList() (the recipient will 
    //  not exist in the new list).

    IMMPID_RPV_DONT_DELIVER,

    // @const IMMPID | IMMPID_RPV_NO_NAME_COLLISIONS | 
    //  IMMPID_RPV_NO_NAME_COLLISIONS is a boolean.  If set to TRUE, mailmsg 
    //  does not detect duplicates with this recipient on future calls to 
    //  AddSecondary().

    IMMPID_RPV_NO_NAME_COLLISIONS,
    // Add new per-recipient volatile properties above this line.
IMMPID_END_LIST(RPV)


// These are defined for backwards-compatability.  They will be removed
// ASAP...

// @const DWORD | IMMPID_RP_DONT_DELIVER | 
//   *** OBSOLETE ***
#define IMMPID_RP_DONT_DELIVER            IMMPID_RPV_DONT_DELIVER

// @const DWORD | IMMPID_RP_NO_NAME_COLLISIONS | 
//   *** OBSOLETE ***
#define IMMPID_RP_NO_NAME_COLLISIONS    IMMPID_RPV_NO_NAME_COLLISIONS


/*=======================================================================*/

// These are the per-message properties for NNTP

IMMPID_START_LIST(NMP,0x6000,"7433a9aa-20e2-11d2-94d6-00c04fa379f1")

    // @const IMMPID | IMMPID_NMP_SECONDARY_GROUPS | 
    //  An array of pointers to INNTPPropertyBag objects for each of
    //  the newsgroups that the article is being posted into for the
    //  current driver.
    IMMPID_NMP_SECONDARY_GROUPS,        

    // @const IMMPID | IMMPID_NMP_SECONDARY_ARTNUM | 
    //  An array of article numbers for each of the newsgroups that
    //  the article is being posted into for the current driver.
    IMMPID_NMP_SECONDARY_ARTNUM,

    // @const IMMPID | IMMPID_NMP_PRIMARY_GROUP | 
    //  A pointer to the INNTPPropertyBag object which represents the
    //  primary group for the current driver.
    IMMPID_NMP_PRIMARY_GROUP,

    // @const IMMPID | IMMPID_NMP_PRIMARY_ARTID | 
    //  The primary article number for the primary group.
    IMMPID_NMP_PRIMARY_ARTID,

    // @const IMMPID | IMMPID_NMP_POST_TOKEN | 
    //   The HTOKEN representing the client context.
    IMMPID_NMP_POST_TOKEN,                

    // @const IMMPID | IMMPID_NMP_NEWSGROUP_LIST | 
    //   The string of newsgroups which this article is being stored in.
    IMMPID_NMP_NEWSGROUP_LIST,            

    // @const IMMPID | IMMPID_NMP_HEADERS | 
    //   A string containing the headers of the message.
    IMMPID_NMP_HEADERS,                    

    // @const IMMPID | IMMPID_NMP_NNTP_PROCESSING | 
    //   Flags which describe how the message should be processed.  The 
    //   possible values are: NMP_PROCESS_POST, NMP_PROCESS_CONTROL, 
    //   and NMP_PROCESS_MODERATOR.  
    IMMPID_NMP_NNTP_PROCESSING,            

    // @const IMMPID | IMMPID_NMP_NNTP_APPROVED_HEADER | 
    //   A string containing the Approved: header of the message  
    IMMPID_NMP_NNTP_APPROVED_HEADER,            

    // Add new per-message properties above this line.
IMMPID_END_LIST(NMP)

// flags for IMMPID_NMP_NNTP_PROCESSING

// @const DWORD | NMP_PROCESS_POST | 
//  Set this flag to allow the NNTP server to post this message.
#define NMP_PROCESS_POST            0x00000001

// @const DWORD | NMP_PROCESS_CONTROL | 
//  Set this flag to allow the NNTP server to process control headers in this
//  message.
#define NMP_PROCESS_CONTROL            0x00000002

// @const DWORD | NMP_PROCESS_MODERATOR | 
//  Set this flag to allow the NNTP server to run this message through the
//  default moderated posting path.
#define NMP_PROCESS_MODERATOR        0x00000004

/*=======================================================================*/


// This is the starting range for user-reserved properties

IMMPID_START_LIST(CPV,0x8000,"A2A76B2A-E52D-11d1-AA64-00C04FA35B82")

    // @const IMMPID | IMMPID_CP_START | 
    //  Start of range
    IMMPID_CP_START,
IMMPID_END_LIST(CPV)


/*=======================================================================*/

// This table collects the data about the properties so that range-
// checking can be performed.  If any new property ranges are
// defined, they must be added to this structure.


#define IMMPID_DECLARE_ENTRY(name)    {&_uuidof(tagIMMPID_##name##_STRUCT),\
                                     IMMPID_##name##_BEFORE__+1,\
                                     IMMPID_##name##_AFTER__-1}

extern const __declspec(selectany) struct tagIMMPID_GUIDLIST_ITEM {
                                       const GUID *pguid;
                                       DWORD dwStart;
                                       DWORD dwLast;
                                   } IMMPID_GUIDS[] = {IMMPID_DECLARE_ENTRY(MP),
                                                       IMMPID_DECLARE_ENTRY(RP),
                                                       IMMPID_DECLARE_ENTRY(MPV),
                                                       IMMPID_DECLARE_ENTRY(RPV),
                                                       {&GUID_NULL,0,0}};

#endif // _MAILMSGPROPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPI.h ===
/*
 *	M A P I . H
 *
 *  Messaging Applications Programming Interface.
 *
 *  Copyright 1993-1999 Microsoft Corporation. All Rights Reserved.
 *
 *  Purpose:
 *
 *    This file defines the structures and constants used by that
 *    subset of the Messaging Applications Programming Interface
 *    which is supported under Windows by Microsoft Mail for PC
 *    Networks version 3.x.
 */


#ifndef MAPI_H
#define MAPI_H

#if _MSC_VER > 1000
#pragma once
#endif

/*
 *  Types.
 */


#ifdef __cplusplus
extern "C" {
#endif


#ifndef EXPORT
#ifdef WIN16
#define EXPORT __export
#else
/* Additional special definitions here */
#define EXPORT
#endif
#endif

typedef unsigned long FAR * LPULONG;
typedef unsigned long       FLAGS;

#ifndef __LHANDLE
#define __LHANDLE
typedef ULONG_PTR       LHANDLE, FAR * LPLHANDLE;
#endif

typedef unsigned char FAR * LPBYTE;

#define    lhSessionNull    ((LHANDLE)0)

typedef struct
{
    ULONG ulReserved;            /* Reserved for future use (must be 0)     */
    ULONG flFlags;               /* Flags                                   */
    ULONG nPosition;             /* character in text to be replaced by attachment */
    LPSTR lpszPathName;          /* Full path name of attachment file       */
    LPSTR lpszFileName;          /* Original file name (optional)           */
    LPVOID lpFileType;           /* Attachment file type (can be lpMapiFileTagExt) */
} MapiFileDesc, FAR * lpMapiFileDesc;

#define MAPI_OLE                0x00000001
#define MAPI_OLE_STATIC         0x00000002


typedef struct
{
    ULONG ulReserved;           /* Reserved, must be zero.                  */
    ULONG cbTag;                /* Size (in bytes) of                       */
    LPBYTE lpTag;               /* X.400 OID for this attachment type       */
    ULONG cbEncoding;           /* Size (in bytes) of                       */
    LPBYTE lpEncoding;          /* X.400 OID for this attachment's encoding */
} MapiFileTagExt, FAR *lpMapiFileTagExt;


typedef struct
{
    ULONG ulReserved;           /* Reserved for future use                  */
    ULONG ulRecipClass;         /* Recipient class                          */
                                /* MAPI_TO, MAPI_CC, MAPI_BCC, MAPI_ORIG    */
    LPSTR lpszName;             /* Recipient name                           */
    LPSTR lpszAddress;          /* Recipient address (optional)             */
    ULONG ulEIDSize;            /* Count in bytes of size of pEntryID       */
    LPVOID lpEntryID;           /* System-specific recipient reference      */
} MapiRecipDesc, FAR * lpMapiRecipDesc;

#ifndef MAPI_ORIG				/* also defined in mapix.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#endif

typedef struct
{
    ULONG ulReserved;             /* Reserved for future use (M.B. 0)       */
    LPSTR lpszSubject;            /* Message Subject                        */
    LPSTR lpszNoteText;           /* Message Text                           */
    LPSTR lpszMessageType;        /* Message Class                          */
    LPSTR lpszDateReceived;       /* in YYYY/MM/DD HH:MM format             */
    LPSTR lpszConversationID;     /* conversation thread ID                 */
    FLAGS flFlags;                /* unread,return receipt                  */
    lpMapiRecipDesc lpOriginator; /* Originator descriptor                  */
    ULONG nRecipCount;            /* Number of recipients                   */
    lpMapiRecipDesc lpRecips;     /* Recipient descriptors                  */
    ULONG nFileCount;             /* # of file attachments                  */
    lpMapiFileDesc lpFiles;       /* Attachment descriptors                 */
} MapiMessage, FAR * lpMapiMessage;

#define MAPI_UNREAD             0x00000001
#define MAPI_RECEIPT_REQUESTED  0x00000002
#define MAPI_SENT               0x00000004


/*
 *  Entry points.
 */

/*
 *  flFlags values for Simple MAPI entry points. All documented flags are
 *  shown for each call. Duplicates are commented out but remain present
 *  for every call.
 */

/* MAPILogon() flags.       */

#define MAPI_LOGON_UI           0x00000001  /* Display logon UI             */
#ifndef MAPI_PASSWORD_UI
#define MAPI_PASSWORD_UI		0x00020000	/* prompt for password only     */
#endif
#define MAPI_NEW_SESSION        0x00000002  /* Don't use shared session     */
#define MAPI_FORCE_DOWNLOAD     0x00001000  /* Get new mail before return   */
#define MAPI_EXTENDED           0x00000020  /* Extended MAPI Logon          */

/* MAPISendMail() flags.    */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */

#ifndef MAPI_DIALOG				/* also defined in property.h */
#define MAPI_DIALOG             0x00000008  /* Display a send note UI       */
#endif
/*# define MAPI_USE_DEFAULT		0x00000040	   Use default profile in logon */

/* MAPIFindNext() flags.    */

#define MAPI_UNREAD_ONLY        0x00000020  /* Only unread messages         */
#define MAPI_GUARANTEE_FIFO     0x00000100  /* use date order               */
#define MAPI_LONG_MSGID			0x00004000	/* allow 512 char returned ID	*/

/* MAPIReadMail() flags.    */

#define MAPI_PEEK               0x00000080  /* Do not mark as read.         */
#define MAPI_SUPPRESS_ATTACH    0x00000800  /* header + body, no files      */
#define MAPI_ENVELOPE_ONLY      0x00000040  /* Only header information      */
#define MAPI_BODY_AS_FILE       0x00000200

/* MAPISaveMail() flags.    */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
/* #define MAPI_LONG_MSGID		0x00004000	/* allow 512 char returned ID	*/

/* MAPIAddress() flags.     */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */

/* MAPIDetails() flags.     */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
#define MAPI_AB_NOMODIFY        0x00000400  /* Don't allow mods of AB entries */

/* MAPIResolveName() flags. */

/* #define MAPI_LOGON_UI        0x00000001     Display logon UI             */
/* #define MAPI_NEW_SESSION     0x00000002     Don't use shared session     */
/* #define MAPI_DIALOG          0x00000008     Prompt for choices if ambiguous */
/* #define MAPI_AB_NOMODIFY     0x00000400     Don't allow mods of AB entries */

typedef ULONG (FAR PASCAL MAPILOGON)(
	ULONG_PTR ulUIParam,
	__in LPSTR lpszProfileName,
	__in LPSTR lpszPassword,
	FLAGS flFlags,
	ULONG ulReserved,
	LPLHANDLE lplhSession
);
typedef MAPILOGON FAR *LPMAPILOGON;
DECLSPEC_DEPRECATED MAPILOGON MAPILogon;

typedef ULONG (FAR PASCAL MAPILOGOFF)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPILOGOFF FAR *LPMAPILOGOFF;
DECLSPEC_DEPRECATED MAPILOGOFF MAPILogoff;


typedef ULONG (FAR PASCAL MAPISENDMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	lpMapiMessage lpMessage,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPISENDMAIL FAR *LPMAPISENDMAIL;
MAPISENDMAIL MAPISendMail;


typedef ULONG (FAR PASCAL MAPISENDDOCUMENTS)(
	ULONG_PTR ulUIParam,
	__in LPSTR lpszDelimChar,
	__in LPSTR lpszFilePaths,
	__in LPSTR lpszFileNames,
	ULONG ulReserved
);
typedef MAPISENDDOCUMENTS FAR *LPMAPISENDDOCUMENTS;
DECLSPEC_DEPRECATED MAPISENDDOCUMENTS MAPISendDocuments;


typedef ULONG (FAR PASCAL MAPIFINDNEXT)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszMessageType,
	__in LPSTR lpszSeedMessageID,
	FLAGS flFlags,
	ULONG ulReserved,
	__in LPSTR lpszMessageID
);
typedef MAPIFINDNEXT FAR *LPMAPIFINDNEXT;
DECLSPEC_DEPRECATED MAPIFINDNEXT MAPIFindNext;

typedef ULONG (FAR PASCAL MAPIREADMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszMessageID,
	FLAGS flFlags,
	ULONG ulReserved,
	lpMapiMessage FAR *lppMessage
);
typedef MAPIREADMAIL FAR *LPMAPIREADMAIL;
DECLSPEC_DEPRECATED MAPIREADMAIL MAPIReadMail;

typedef ULONG (FAR PASCAL MAPISAVEMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	lpMapiMessage lpMessage,
	FLAGS flFlags,
	ULONG ulReserved,
	__in LPSTR lpszMessageID
);
typedef MAPISAVEMAIL FAR *LPMAPISAVEMAIL;
DECLSPEC_DEPRECATED MAPISAVEMAIL MAPISaveMail;

typedef ULONG (FAR PASCAL MAPIDELETEMAIL)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszMessageID,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPIDELETEMAIL FAR *LPMAPIDELETEMAIL;
DECLSPEC_DEPRECATED MAPIDELETEMAIL MAPIDeleteMail;

typedef ULONG (EXPORT FAR PASCAL *LPMAPIFREEBUFFER)(LPVOID pv);
ULONG FAR PASCAL MAPIFreeBuffer(LPVOID pv);

typedef ULONG (FAR PASCAL MAPIADDRESS)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszCaption,
	ULONG nEditFields,
	__in LPSTR lpszLabels,
	ULONG nRecips,
	lpMapiRecipDesc lpRecips,
	FLAGS flFlags,
	ULONG ulReserved,
	LPULONG lpnNewRecips,
	lpMapiRecipDesc FAR *lppNewRecips
);
typedef MAPIADDRESS FAR *LPMAPIADDRESS;
DECLSPEC_DEPRECATED MAPIADDRESS MAPIAddress;

typedef ULONG (FAR PASCAL MAPIDETAILS)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	lpMapiRecipDesc lpRecip,
	FLAGS flFlags,
	ULONG ulReserved
);
typedef MAPIDETAILS FAR *LPMAPIDETAILS;
DECLSPEC_DEPRECATED MAPIDETAILS MAPIDetails;

typedef ULONG (FAR PASCAL MAPIRESOLVENAME)(
	LHANDLE lhSession,
	ULONG_PTR ulUIParam,
	__in LPSTR lpszName,
	FLAGS flFlags,
	ULONG ulReserved,
	lpMapiRecipDesc FAR *lppRecip
);
typedef MAPIRESOLVENAME FAR *LPMAPIRESOLVENAME;
DECLSPEC_DEPRECATED MAPIRESOLVENAME MAPIResolveName;

#ifndef SUCCESS_SUCCESS
#define SUCCESS_SUCCESS                 0
#endif
#define MAPI_USER_ABORT                 1
#define MAPI_E_USER_ABORT               MAPI_USER_ABORT
#define MAPI_E_FAILURE                  2
#define MAPI_E_LOGON_FAILURE            3
#define MAPI_E_LOGIN_FAILURE            MAPI_E_LOGON_FAILURE
#define MAPI_E_DISK_FULL                4
#define MAPI_E_INSUFFICIENT_MEMORY      5
#define MAPI_E_ACCESS_DENIED            6
#define MAPI_E_TOO_MANY_SESSIONS        8
#define MAPI_E_TOO_MANY_FILES           9
#define MAPI_E_TOO_MANY_RECIPIENTS      10
#define MAPI_E_ATTACHMENT_NOT_FOUND     11
#define MAPI_E_ATTACHMENT_OPEN_FAILURE  12
#define MAPI_E_ATTACHMENT_WRITE_FAILURE 13
#define MAPI_E_UNKNOWN_RECIPIENT        14
#define MAPI_E_BAD_RECIPTYPE            15
#define MAPI_E_NO_MESSAGES              16
#define MAPI_E_INVALID_MESSAGE          17
#define MAPI_E_TEXT_TOO_LARGE           18
#define MAPI_E_INVALID_SESSION          19
#define MAPI_E_TYPE_NOT_SUPPORTED       20
#define MAPI_E_AMBIGUOUS_RECIPIENT      21
#define MAPI_E_AMBIG_RECIP              MAPI_E_AMBIGUOUS_RECIPIENT
#define MAPI_E_MESSAGE_IN_USE           22
#define MAPI_E_NETWORK_FAILURE          23
#define MAPI_E_INVALID_EDITFIELDS       24
#define MAPI_E_INVALID_RECIPS           25
#define MAPI_E_NOT_SUPPORTED            26



#ifdef MAPIX_H
/*  Maps from a simple mapi session to a MAPI 1.0 extended mapi session */

STDMETHODIMP_(SCODE)
ScMAPIXFromSMAPI(LHANDLE lhSimpleSession,
				ULONG ulFlags,
				LPCIID lpInterface,
				LPMAPISESSION FAR * lppMAPISession);
#endif /* MAPIX_H */


#ifdef	__cplusplus
}		/*	extern "C" */
#endif

#endif /* MAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\manipulations.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for manipulations.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __manipulations_h__
#define __manipulations_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef ___IManipulationEvents_FWD_DEFINED__
#define ___IManipulationEvents_FWD_DEFINED__
typedef interface _IManipulationEvents _IManipulationEvents;
#endif 	/* ___IManipulationEvents_FWD_DEFINED__ */


#ifndef __IInertiaProcessor_FWD_DEFINED__
#define __IInertiaProcessor_FWD_DEFINED__
typedef interface IInertiaProcessor IInertiaProcessor;
#endif 	/* __IInertiaProcessor_FWD_DEFINED__ */


#ifndef __IManipulationProcessor_FWD_DEFINED__
#define __IManipulationProcessor_FWD_DEFINED__
typedef interface IManipulationProcessor IManipulationProcessor;
#endif 	/* __IManipulationProcessor_FWD_DEFINED__ */


#ifndef __InertiaProcessor_FWD_DEFINED__
#define __InertiaProcessor_FWD_DEFINED__

#ifdef __cplusplus
typedef class InertiaProcessor InertiaProcessor;
#else
typedef struct InertiaProcessor InertiaProcessor;
#endif /* __cplusplus */

#endif 	/* __InertiaProcessor_FWD_DEFINED__ */


#ifndef __ManipulationProcessor_FWD_DEFINED__
#define __ManipulationProcessor_FWD_DEFINED__

#ifdef __cplusplus
typedef class ManipulationProcessor ManipulationProcessor;
#else
typedef struct ManipulationProcessor ManipulationProcessor;
#endif /* __cplusplus */

#endif 	/* __ManipulationProcessor_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_manipulations_0000_0000 */
/* [local] */ 

typedef /* [v1_enum] */ 
enum MANIPULATION_PROCESSOR_MANIPULATIONS
    {	MANIPULATION_NONE	= 0,
	MANIPULATION_TRANSLATE_X	= 0x1,
	MANIPULATION_TRANSLATE_Y	= 0x2,
	MANIPULATION_SCALE	= 0x4,
	MANIPULATION_ROTATE	= 0x8,
	MANIPULATION_ALL	= 0xf
    } 	MANIPULATION_PROCESSOR_MANIPULATIONS;

DEFINE_ENUM_FLAG_OPERATORS(MANIPULATION_PROCESSOR_MANIPULATIONS)
// Floating point constants.
DECLSPEC_SELECTANY extern const float POSITIVE_INFINITY = ((float)(1e308 * 10));
DECLSPEC_SELECTANY extern const float NEGATIVE_INFINITY = ((float)(-1e308 * 10));
DECLSPEC_SELECTANY extern const float NaN = ((float)((1e308 * 10)*0.));
typedef unsigned long MANIPULATOR_ID;



extern RPC_IF_HANDLE __MIDL_itf_manipulations_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_manipulations_0000_0000_v0_0_s_ifspec;


#ifndef __ManipulationsLib_LIBRARY_DEFINED__
#define __ManipulationsLib_LIBRARY_DEFINED__

/* library ManipulationsLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_ManipulationsLib;

#ifndef ___IManipulationEvents_INTERFACE_DEFINED__
#define ___IManipulationEvents_INTERFACE_DEFINED__

/* interface _IManipulationEvents */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID__IManipulationEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4f62c8da-9c53-4b22-93df-927a862bbb03")
    _IManipulationEvents : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ManipulationStarted( 
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ManipulationDelta( 
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ FLOAT translationDeltaX,
            /* [in] */ FLOAT translationDeltaY,
            /* [in] */ FLOAT scaleDelta,
            /* [in] */ FLOAT expansionDelta,
            /* [in] */ FLOAT rotationDelta,
            /* [in] */ FLOAT cumulativeTranslationX,
            /* [in] */ FLOAT cumulativeTranslationY,
            /* [in] */ FLOAT cumulativeScale,
            /* [in] */ FLOAT cumulativeExpansion,
            /* [in] */ FLOAT cumulativeRotation) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ManipulationCompleted( 
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ FLOAT cumulativeTranslationX,
            /* [in] */ FLOAT cumulativeTranslationY,
            /* [in] */ FLOAT cumulativeScale,
            /* [in] */ FLOAT cumulativeExpansion,
            /* [in] */ FLOAT cumulativeRotation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct _IManipulationEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in _IManipulationEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in _IManipulationEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in _IManipulationEvents * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ManipulationStarted )( 
            __RPC__in _IManipulationEvents * This,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ManipulationDelta )( 
            __RPC__in _IManipulationEvents * This,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ FLOAT translationDeltaX,
            /* [in] */ FLOAT translationDeltaY,
            /* [in] */ FLOAT scaleDelta,
            /* [in] */ FLOAT expansionDelta,
            /* [in] */ FLOAT rotationDelta,
            /* [in] */ FLOAT cumulativeTranslationX,
            /* [in] */ FLOAT cumulativeTranslationY,
            /* [in] */ FLOAT cumulativeScale,
            /* [in] */ FLOAT cumulativeExpansion,
            /* [in] */ FLOAT cumulativeRotation);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *ManipulationCompleted )( 
            __RPC__in _IManipulationEvents * This,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ FLOAT cumulativeTranslationX,
            /* [in] */ FLOAT cumulativeTranslationY,
            /* [in] */ FLOAT cumulativeScale,
            /* [in] */ FLOAT cumulativeExpansion,
            /* [in] */ FLOAT cumulativeRotation);
        
        END_INTERFACE
    } _IManipulationEventsVtbl;

    interface _IManipulationEvents
    {
        CONST_VTBL struct _IManipulationEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define _IManipulationEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define _IManipulationEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define _IManipulationEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define _IManipulationEvents_ManipulationStarted(This,x,y)	\
    ( (This)->lpVtbl -> ManipulationStarted(This,x,y) ) 

#define _IManipulationEvents_ManipulationDelta(This,x,y,translationDeltaX,translationDeltaY,scaleDelta,expansionDelta,rotationDelta,cumulativeTranslationX,cumulativeTranslationY,cumulativeScale,cumulativeExpansion,cumulativeRotation)	\
    ( (This)->lpVtbl -> ManipulationDelta(This,x,y,translationDeltaX,translationDeltaY,scaleDelta,expansionDelta,rotationDelta,cumulativeTranslationX,cumulativeTranslationY,cumulativeScale,cumulativeExpansion,cumulativeRotation) ) 

#define _IManipulationEvents_ManipulationCompleted(This,x,y,cumulativeTranslationX,cumulativeTranslationY,cumulativeScale,cumulativeExpansion,cumulativeRotation)	\
    ( (This)->lpVtbl -> ManipulationCompleted(This,x,y,cumulativeTranslationX,cumulativeTranslationY,cumulativeScale,cumulativeExpansion,cumulativeRotation) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* ___IManipulationEvents_INTERFACE_DEFINED__ */


#ifndef __IInertiaProcessor_INTERFACE_DEFINED__
#define __IInertiaProcessor_INTERFACE_DEFINED__

/* interface IInertiaProcessor */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IInertiaProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18b00c6d-c5ee-41b1-90a9-9d4a929095ad")
    IInertiaProcessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_InitialOriginX( 
            /* [out] */ __RPC__out FLOAT *x) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialOriginX( 
            /* [in] */ FLOAT x) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialOriginY( 
            /* [out] */ __RPC__out FLOAT *y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialOriginY( 
            /* [in] */ FLOAT y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialVelocityX( 
            /* [out] */ __RPC__out FLOAT *x) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialVelocityX( 
            /* [in] */ FLOAT x) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialVelocityY( 
            /* [out] */ __RPC__out FLOAT *y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialVelocityY( 
            /* [in] */ FLOAT y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialAngularVelocity( 
            /* [out] */ __RPC__out FLOAT *velocity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialAngularVelocity( 
            /* [in] */ FLOAT velocity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialExpansionVelocity( 
            /* [out] */ __RPC__out FLOAT *velocity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialExpansionVelocity( 
            /* [in] */ FLOAT velocity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialRadius( 
            /* [out] */ __RPC__out FLOAT *radius) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialRadius( 
            /* [in] */ FLOAT radius) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_BoundaryLeft( 
            /* [out] */ __RPC__out FLOAT *left) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_BoundaryLeft( 
            /* [in] */ FLOAT left) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_BoundaryTop( 
            /* [out] */ __RPC__out FLOAT *top) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_BoundaryTop( 
            /* [in] */ FLOAT top) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_BoundaryRight( 
            /* [out] */ __RPC__out FLOAT *right) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_BoundaryRight( 
            /* [in] */ FLOAT right) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_BoundaryBottom( 
            /* [out] */ __RPC__out FLOAT *bottom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_BoundaryBottom( 
            /* [in] */ FLOAT bottom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ElasticMarginLeft( 
            /* [out] */ __RPC__out FLOAT *left) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ElasticMarginLeft( 
            /* [in] */ FLOAT left) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ElasticMarginTop( 
            /* [out] */ __RPC__out FLOAT *top) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ElasticMarginTop( 
            /* [in] */ FLOAT top) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ElasticMarginRight( 
            /* [out] */ __RPC__out FLOAT *right) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ElasticMarginRight( 
            /* [in] */ FLOAT right) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_ElasticMarginBottom( 
            /* [out] */ __RPC__out FLOAT *bottom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_ElasticMarginBottom( 
            /* [in] */ FLOAT bottom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DesiredDisplacement( 
            /* [out] */ __RPC__out FLOAT *displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DesiredDisplacement( 
            /* [in] */ FLOAT displacement) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DesiredRotation( 
            /* [out] */ __RPC__out FLOAT *rotation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DesiredRotation( 
            /* [in] */ FLOAT rotation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DesiredExpansion( 
            /* [out] */ __RPC__out FLOAT *expansion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DesiredExpansion( 
            /* [in] */ FLOAT expansion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DesiredDeceleration( 
            /* [out] */ __RPC__out FLOAT *deceleration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DesiredDeceleration( 
            /* [in] */ FLOAT deceleration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DesiredAngularDeceleration( 
            /* [out] */ __RPC__out FLOAT *deceleration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DesiredAngularDeceleration( 
            /* [in] */ FLOAT deceleration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_DesiredExpansionDeceleration( 
            /* [out] */ __RPC__out FLOAT *deceleration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_DesiredExpansionDeceleration( 
            /* [in] */ FLOAT deceleration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_InitialTimestamp( 
            /* [out] */ __RPC__out DWORD *timestamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_InitialTimestamp( 
            /* [in] */ DWORD timestamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Process( 
            /* [out] */ __RPC__out BOOL *completed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessTime( 
            /* [in] */ DWORD timestamp,
            /* [out] */ __RPC__out BOOL *completed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Complete( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompleteTime( 
            /* [in] */ DWORD timestamp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInertiaProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IInertiaProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IInertiaProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialOriginX )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *x);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialOriginX )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT x);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialOriginY )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *y);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialOriginY )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT y);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialVelocityX )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *x);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialVelocityX )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT x);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialVelocityY )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *y);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialVelocityY )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT y);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialAngularVelocity )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *velocity);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialAngularVelocity )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT velocity);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialExpansionVelocity )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *velocity);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialExpansionVelocity )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT velocity);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialRadius )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *radius);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialRadius )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT radius);
        
        HRESULT ( STDMETHODCALLTYPE *get_BoundaryLeft )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *left);
        
        HRESULT ( STDMETHODCALLTYPE *put_BoundaryLeft )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT left);
        
        HRESULT ( STDMETHODCALLTYPE *get_BoundaryTop )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *top);
        
        HRESULT ( STDMETHODCALLTYPE *put_BoundaryTop )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT top);
        
        HRESULT ( STDMETHODCALLTYPE *get_BoundaryRight )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *right);
        
        HRESULT ( STDMETHODCALLTYPE *put_BoundaryRight )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT right);
        
        HRESULT ( STDMETHODCALLTYPE *get_BoundaryBottom )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *bottom);
        
        HRESULT ( STDMETHODCALLTYPE *put_BoundaryBottom )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT bottom);
        
        HRESULT ( STDMETHODCALLTYPE *get_ElasticMarginLeft )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *left);
        
        HRESULT ( STDMETHODCALLTYPE *put_ElasticMarginLeft )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT left);
        
        HRESULT ( STDMETHODCALLTYPE *get_ElasticMarginTop )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *top);
        
        HRESULT ( STDMETHODCALLTYPE *put_ElasticMarginTop )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT top);
        
        HRESULT ( STDMETHODCALLTYPE *get_ElasticMarginRight )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *right);
        
        HRESULT ( STDMETHODCALLTYPE *put_ElasticMarginRight )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT right);
        
        HRESULT ( STDMETHODCALLTYPE *get_ElasticMarginBottom )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *bottom);
        
        HRESULT ( STDMETHODCALLTYPE *put_ElasticMarginBottom )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT bottom);
        
        HRESULT ( STDMETHODCALLTYPE *get_DesiredDisplacement )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *displacement);
        
        HRESULT ( STDMETHODCALLTYPE *put_DesiredDisplacement )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT displacement);
        
        HRESULT ( STDMETHODCALLTYPE *get_DesiredRotation )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *rotation);
        
        HRESULT ( STDMETHODCALLTYPE *put_DesiredRotation )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT rotation);
        
        HRESULT ( STDMETHODCALLTYPE *get_DesiredExpansion )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *expansion);
        
        HRESULT ( STDMETHODCALLTYPE *put_DesiredExpansion )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT expansion);
        
        HRESULT ( STDMETHODCALLTYPE *get_DesiredDeceleration )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *deceleration);
        
        HRESULT ( STDMETHODCALLTYPE *put_DesiredDeceleration )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT deceleration);
        
        HRESULT ( STDMETHODCALLTYPE *get_DesiredAngularDeceleration )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *deceleration);
        
        HRESULT ( STDMETHODCALLTYPE *put_DesiredAngularDeceleration )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT deceleration);
        
        HRESULT ( STDMETHODCALLTYPE *get_DesiredExpansionDeceleration )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out FLOAT *deceleration);
        
        HRESULT ( STDMETHODCALLTYPE *put_DesiredExpansionDeceleration )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ FLOAT deceleration);
        
        HRESULT ( STDMETHODCALLTYPE *get_InitialTimestamp )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out DWORD *timestamp);
        
        HRESULT ( STDMETHODCALLTYPE *put_InitialTimestamp )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ DWORD timestamp);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            __RPC__in IInertiaProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *Process )( 
            __RPC__in IInertiaProcessor * This,
            /* [out] */ __RPC__out BOOL *completed);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessTime )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ DWORD timestamp,
            /* [out] */ __RPC__out BOOL *completed);
        
        HRESULT ( STDMETHODCALLTYPE *Complete )( 
            __RPC__in IInertiaProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *CompleteTime )( 
            __RPC__in IInertiaProcessor * This,
            /* [in] */ DWORD timestamp);
        
        END_INTERFACE
    } IInertiaProcessorVtbl;

    interface IInertiaProcessor
    {
        CONST_VTBL struct IInertiaProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInertiaProcessor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IInertiaProcessor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IInertiaProcessor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IInertiaProcessor_get_InitialOriginX(This,x)	\
    ( (This)->lpVtbl -> get_InitialOriginX(This,x) ) 

#define IInertiaProcessor_put_InitialOriginX(This,x)	\
    ( (This)->lpVtbl -> put_InitialOriginX(This,x) ) 

#define IInertiaProcessor_get_InitialOriginY(This,y)	\
    ( (This)->lpVtbl -> get_InitialOriginY(This,y) ) 

#define IInertiaProcessor_put_InitialOriginY(This,y)	\
    ( (This)->lpVtbl -> put_InitialOriginY(This,y) ) 

#define IInertiaProcessor_get_InitialVelocityX(This,x)	\
    ( (This)->lpVtbl -> get_InitialVelocityX(This,x) ) 

#define IInertiaProcessor_put_InitialVelocityX(This,x)	\
    ( (This)->lpVtbl -> put_InitialVelocityX(This,x) ) 

#define IInertiaProcessor_get_InitialVelocityY(This,y)	\
    ( (This)->lpVtbl -> get_InitialVelocityY(This,y) ) 

#define IInertiaProcessor_put_InitialVelocityY(This,y)	\
    ( (This)->lpVtbl -> put_InitialVelocityY(This,y) ) 

#define IInertiaProcessor_get_InitialAngularVelocity(This,velocity)	\
    ( (This)->lpVtbl -> get_InitialAngularVelocity(This,velocity) ) 

#define IInertiaProcessor_put_InitialAngularVelocity(This,velocity)	\
    ( (This)->lpVtbl -> put_InitialAngularVelocity(This,velocity) ) 

#define IInertiaProcessor_get_InitialExpansionVelocity(This,velocity)	\
    ( (This)->lpVtbl -> get_InitialExpansionVelocity(This,velocity) ) 

#define IInertiaProcessor_put_InitialExpansionVelocity(This,velocity)	\
    ( (This)->lpVtbl -> put_InitialExpansionVelocity(This,velocity) ) 

#define IInertiaProcessor_get_InitialRadius(This,radius)	\
    ( (This)->lpVtbl -> get_InitialRadius(This,radius) ) 

#define IInertiaProcessor_put_InitialRadius(This,radius)	\
    ( (This)->lpVtbl -> put_InitialRadius(This,radius) ) 

#define IInertiaProcessor_get_BoundaryLeft(This,left)	\
    ( (This)->lpVtbl -> get_BoundaryLeft(This,left) ) 

#define IInertiaProcessor_put_BoundaryLeft(This,left)	\
    ( (This)->lpVtbl -> put_BoundaryLeft(This,left) ) 

#define IInertiaProcessor_get_BoundaryTop(This,top)	\
    ( (This)->lpVtbl -> get_BoundaryTop(This,top) ) 

#define IInertiaProcessor_put_BoundaryTop(This,top)	\
    ( (This)->lpVtbl -> put_BoundaryTop(This,top) ) 

#define IInertiaProcessor_get_BoundaryRight(This,right)	\
    ( (This)->lpVtbl -> get_BoundaryRight(This,right) ) 

#define IInertiaProcessor_put_BoundaryRight(This,right)	\
    ( (This)->lpVtbl -> put_BoundaryRight(This,right) ) 

#define IInertiaProcessor_get_BoundaryBottom(This,bottom)	\
    ( (This)->lpVtbl -> get_BoundaryBottom(This,bottom) ) 

#define IInertiaProcessor_put_BoundaryBottom(This,bottom)	\
    ( (This)->lpVtbl -> put_BoundaryBottom(This,bottom) ) 

#define IInertiaProcessor_get_ElasticMarginLeft(This,left)	\
    ( (This)->lpVtbl -> get_ElasticMarginLeft(This,left) ) 

#define IInertiaProcessor_put_ElasticMarginLeft(This,left)	\
    ( (This)->lpVtbl -> put_ElasticMarginLeft(This,left) ) 

#define IInertiaProcessor_get_ElasticMarginTop(This,top)	\
    ( (This)->lpVtbl -> get_ElasticMarginTop(This,top) ) 

#define IInertiaProcessor_put_ElasticMarginTop(This,top)	\
    ( (This)->lpVtbl -> put_ElasticMarginTop(This,top) ) 

#define IInertiaProcessor_get_ElasticMarginRight(This,right)	\
    ( (This)->lpVtbl -> get_ElasticMarginRight(This,right) ) 

#define IInertiaProcessor_put_ElasticMarginRight(This,right)	\
    ( (This)->lpVtbl -> put_ElasticMarginRight(This,right) ) 

#define IInertiaProcessor_get_ElasticMarginBottom(This,bottom)	\
    ( (This)->lpVtbl -> get_ElasticMarginBottom(This,bottom) ) 

#define IInertiaProcessor_put_ElasticMarginBottom(This,bottom)	\
    ( (This)->lpVtbl -> put_ElasticMarginBottom(This,bottom) ) 

#define IInertiaProcessor_get_DesiredDisplacement(This,displacement)	\
    ( (This)->lpVtbl -> get_DesiredDisplacement(This,displacement) ) 

#define IInertiaProcessor_put_DesiredDisplacement(This,displacement)	\
    ( (This)->lpVtbl -> put_DesiredDisplacement(This,displacement) ) 

#define IInertiaProcessor_get_DesiredRotation(This,rotation)	\
    ( (This)->lpVtbl -> get_DesiredRotation(This,rotation) ) 

#define IInertiaProcessor_put_DesiredRotation(This,rotation)	\
    ( (This)->lpVtbl -> put_DesiredRotation(This,rotation) ) 

#define IInertiaProcessor_get_DesiredExpansion(This,expansion)	\
    ( (This)->lpVtbl -> get_DesiredExpansion(This,expansion) ) 

#define IInertiaProcessor_put_DesiredExpansion(This,expansion)	\
    ( (This)->lpVtbl -> put_DesiredExpansion(This,expansion) ) 

#define IInertiaProcessor_get_DesiredDeceleration(This,deceleration)	\
    ( (This)->lpVtbl -> get_DesiredDeceleration(This,deceleration) ) 

#define IInertiaProcessor_put_DesiredDeceleration(This,deceleration)	\
    ( (This)->lpVtbl -> put_DesiredDeceleration(This,deceleration) ) 

#define IInertiaProcessor_get_DesiredAngularDeceleration(This,deceleration)	\
    ( (This)->lpVtbl -> get_DesiredAngularDeceleration(This,deceleration) ) 

#define IInertiaProcessor_put_DesiredAngularDeceleration(This,deceleration)	\
    ( (This)->lpVtbl -> put_DesiredAngularDeceleration(This,deceleration) ) 

#define IInertiaProcessor_get_DesiredExpansionDeceleration(This,deceleration)	\
    ( (This)->lpVtbl -> get_DesiredExpansionDeceleration(This,deceleration) ) 

#define IInertiaProcessor_put_DesiredExpansionDeceleration(This,deceleration)	\
    ( (This)->lpVtbl -> put_DesiredExpansionDeceleration(This,deceleration) ) 

#define IInertiaProcessor_get_InitialTimestamp(This,timestamp)	\
    ( (This)->lpVtbl -> get_InitialTimestamp(This,timestamp) ) 

#define IInertiaProcessor_put_InitialTimestamp(This,timestamp)	\
    ( (This)->lpVtbl -> put_InitialTimestamp(This,timestamp) ) 

#define IInertiaProcessor_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IInertiaProcessor_Process(This,completed)	\
    ( (This)->lpVtbl -> Process(This,completed) ) 

#define IInertiaProcessor_ProcessTime(This,timestamp,completed)	\
    ( (This)->lpVtbl -> ProcessTime(This,timestamp,completed) ) 

#define IInertiaProcessor_Complete(This)	\
    ( (This)->lpVtbl -> Complete(This) ) 

#define IInertiaProcessor_CompleteTime(This,timestamp)	\
    ( (This)->lpVtbl -> CompleteTime(This,timestamp) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IInertiaProcessor_INTERFACE_DEFINED__ */


#ifndef __IManipulationProcessor_INTERFACE_DEFINED__
#define __IManipulationProcessor_INTERFACE_DEFINED__

/* interface IManipulationProcessor */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IManipulationProcessor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A22AC519-8300-48a0-BEF4-F1BE8737DBA4")
    IManipulationProcessor : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE get_SupportedManipulations( 
            /* [out] */ __RPC__out MANIPULATION_PROCESSOR_MANIPULATIONS *manipulations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_SupportedManipulations( 
            /* [in] */ MANIPULATION_PROCESSOR_MANIPULATIONS manipulations) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PivotPointX( 
            /* [out] */ __RPC__out FLOAT *pivotPointX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PivotPointX( 
            /* [in] */ FLOAT pivotPointX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PivotPointY( 
            /* [out] */ __RPC__out FLOAT *pivotPointY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PivotPointY( 
            /* [in] */ FLOAT pivotPointY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_PivotRadius( 
            /* [out] */ __RPC__out FLOAT *pivotRadius) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_PivotRadius( 
            /* [in] */ FLOAT pivotRadius) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CompleteManipulation( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessDown( 
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessMove( 
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUp( 
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessDownWithTime( 
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ DWORD timestamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessMoveWithTime( 
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ DWORD timestamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessUpWithTime( 
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ DWORD timestamp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVelocityX( 
            /* [out] */ __RPC__out FLOAT *velocityX) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVelocityY( 
            /* [out] */ __RPC__out FLOAT *velocityY) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExpansionVelocity( 
            /* [out] */ __RPC__out FLOAT *expansionVelocity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAngularVelocity( 
            /* [out] */ __RPC__out FLOAT *angularVelocity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_MinimumScaleRotateRadius( 
            /* [out] */ __RPC__out FLOAT *minRadius) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE put_MinimumScaleRotateRadius( 
            /* [in] */ FLOAT minRadius) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManipulationProcessorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IManipulationProcessor * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IManipulationProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *get_SupportedManipulations )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out MANIPULATION_PROCESSOR_MANIPULATIONS *manipulations);
        
        HRESULT ( STDMETHODCALLTYPE *put_SupportedManipulations )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATION_PROCESSOR_MANIPULATIONS manipulations);
        
        HRESULT ( STDMETHODCALLTYPE *get_PivotPointX )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *pivotPointX);
        
        HRESULT ( STDMETHODCALLTYPE *put_PivotPointX )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ FLOAT pivotPointX);
        
        HRESULT ( STDMETHODCALLTYPE *get_PivotPointY )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *pivotPointY);
        
        HRESULT ( STDMETHODCALLTYPE *put_PivotPointY )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ FLOAT pivotPointY);
        
        HRESULT ( STDMETHODCALLTYPE *get_PivotRadius )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *pivotRadius);
        
        HRESULT ( STDMETHODCALLTYPE *put_PivotRadius )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ FLOAT pivotRadius);
        
        HRESULT ( STDMETHODCALLTYPE *CompleteManipulation )( 
            __RPC__in IManipulationProcessor * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessDown )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessMove )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUp )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessDownWithTime )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ DWORD timestamp);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessMoveWithTime )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ DWORD timestamp);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessUpWithTime )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ MANIPULATOR_ID manipulatorId,
            /* [in] */ FLOAT x,
            /* [in] */ FLOAT y,
            /* [in] */ DWORD timestamp);
        
        HRESULT ( STDMETHODCALLTYPE *GetVelocityX )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *velocityX);
        
        HRESULT ( STDMETHODCALLTYPE *GetVelocityY )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *velocityY);
        
        HRESULT ( STDMETHODCALLTYPE *GetExpansionVelocity )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *expansionVelocity);
        
        HRESULT ( STDMETHODCALLTYPE *GetAngularVelocity )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *angularVelocity);
        
        HRESULT ( STDMETHODCALLTYPE *get_MinimumScaleRotateRadius )( 
            __RPC__in IManipulationProcessor * This,
            /* [out] */ __RPC__out FLOAT *minRadius);
        
        HRESULT ( STDMETHODCALLTYPE *put_MinimumScaleRotateRadius )( 
            __RPC__in IManipulationProcessor * This,
            /* [in] */ FLOAT minRadius);
        
        END_INTERFACE
    } IManipulationProcessorVtbl;

    interface IManipulationProcessor
    {
        CONST_VTBL struct IManipulationProcessorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManipulationProcessor_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IManipulationProcessor_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IManipulationProcessor_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IManipulationProcessor_get_SupportedManipulations(This,manipulations)	\
    ( (This)->lpVtbl -> get_SupportedManipulations(This,manipulations) ) 

#define IManipulationProcessor_put_SupportedManipulations(This,manipulations)	\
    ( (This)->lpVtbl -> put_SupportedManipulations(This,manipulations) ) 

#define IManipulationProcessor_get_PivotPointX(This,pivotPointX)	\
    ( (This)->lpVtbl -> get_PivotPointX(This,pivotPointX) ) 

#define IManipulationProcessor_put_PivotPointX(This,pivotPointX)	\
    ( (This)->lpVtbl -> put_PivotPointX(This,pivotPointX) ) 

#define IManipulationProcessor_get_PivotPointY(This,pivotPointY)	\
    ( (This)->lpVtbl -> get_PivotPointY(This,pivotPointY) ) 

#define IManipulationProcessor_put_PivotPointY(This,pivotPointY)	\
    ( (This)->lpVtbl -> put_PivotPointY(This,pivotPointY) ) 

#define IManipulationProcessor_get_PivotRadius(This,pivotRadius)	\
    ( (This)->lpVtbl -> get_PivotRadius(This,pivotRadius) ) 

#define IManipulationProcessor_put_PivotRadius(This,pivotRadius)	\
    ( (This)->lpVtbl -> put_PivotRadius(This,pivotRadius) ) 

#define IManipulationProcessor_CompleteManipulation(This)	\
    ( (This)->lpVtbl -> CompleteManipulation(This) ) 

#define IManipulationProcessor_ProcessDown(This,manipulatorId,x,y)	\
    ( (This)->lpVtbl -> ProcessDown(This,manipulatorId,x,y) ) 

#define IManipulationProcessor_ProcessMove(This,manipulatorId,x,y)	\
    ( (This)->lpVtbl -> ProcessMove(This,manipulatorId,x,y) ) 

#define IManipulationProcessor_ProcessUp(This,manipulatorId,x,y)	\
    ( (This)->lpVtbl -> ProcessUp(This,manipulatorId,x,y) ) 

#define IManipulationProcessor_ProcessDownWithTime(This,manipulatorId,x,y,timestamp)	\
    ( (This)->lpVtbl -> ProcessDownWithTime(This,manipulatorId,x,y,timestamp) ) 

#define IManipulationProcessor_ProcessMoveWithTime(This,manipulatorId,x,y,timestamp)	\
    ( (This)->lpVtbl -> ProcessMoveWithTime(This,manipulatorId,x,y,timestamp) ) 

#define IManipulationProcessor_ProcessUpWithTime(This,manipulatorId,x,y,timestamp)	\
    ( (This)->lpVtbl -> ProcessUpWithTime(This,manipulatorId,x,y,timestamp) ) 

#define IManipulationProcessor_GetVelocityX(This,velocityX)	\
    ( (This)->lpVtbl -> GetVelocityX(This,velocityX) ) 

#define IManipulationProcessor_GetVelocityY(This,velocityY)	\
    ( (This)->lpVtbl -> GetVelocityY(This,velocityY) ) 

#define IManipulationProcessor_GetExpansionVelocity(This,expansionVelocity)	\
    ( (This)->lpVtbl -> GetExpansionVelocity(This,expansionVelocity) ) 

#define IManipulationProcessor_GetAngularVelocity(This,angularVelocity)	\
    ( (This)->lpVtbl -> GetAngularVelocity(This,angularVelocity) ) 

#define IManipulationProcessor_get_MinimumScaleRotateRadius(This,minRadius)	\
    ( (This)->lpVtbl -> get_MinimumScaleRotateRadius(This,minRadius) ) 

#define IManipulationProcessor_put_MinimumScaleRotateRadius(This,minRadius)	\
    ( (This)->lpVtbl -> put_MinimumScaleRotateRadius(This,minRadius) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IManipulationProcessor_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_InertiaProcessor;

#ifdef __cplusplus

class DECLSPEC_UUID("abb27087-4ce0-4e58-a0cb-e24df96814be")
InertiaProcessor;
#endif

EXTERN_C const CLSID CLSID_ManipulationProcessor;

#ifdef __cplusplus

class DECLSPEC_UUID("597D4FB0-47FD-4aff-89B9-C6CFAE8CF08E")
ManipulationProcessor;
#endif
#endif /* __ManipulationsLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPICode.h ===
/*
 *	M A P I C O D E . H
 *
 *	Status Codes returned by MAPI routines
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPICODE_H
#define MAPICODE_H

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

/* Define S_OK and ITF_* */

#ifdef _WIN32
#include <winerror.h>
#endif

/*
 *	MAPI Status codes follow the style of OLE 2.0 sCodes as defined in the
 *	OLE 2.0 Programmer's Reference and header file scode.h (Windows 3.x)
 *	or winerror.h (Windows NT and Windows 95).
 *
 */

/*  On Windows 3.x, status codes have 32-bit values as follows:
 *
 *   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *  +-+---------------------+-------+-------------------------------+
 *  |S|       Context       | Facil |               Code            |
 *  +-+---------------------+-------+-------------------------------+
 *
 *  where
 *
 *      S - is the severity code
 *
 *          0 - SEVERITY_SUCCESS
 *          1 - SEVERITY_ERROR
 *
 *      Context - context info
 *
 *      Facility - is the facility code
 *
 *			0x0 - FACILITY_NULL		generally useful errors ([SE]_*)
 *			0x1 - FACILITY_RPC		remote procedure call errors (RPC_E_*)
 *			0x2 - FACILITY_DISPATCH late binding dispatch errors
 *			0x3 - FACILITY_STORAGE  storage errors (STG_E_*)
 *			0x4 - FACILITY_ITF		interface-specific errors
 *
 *      Code - is the facility's status code
 *
 *
 */

/*
 *	On Windows NT 3.5 and Windows 95, scodes are 32-bit values
 *	laid out as follows:
 *	
 *	  3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
 *	  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
 *	 +-+-+-+-+-+---------------------+-------------------------------+
 *	 |S|R|C|N|r|    Facility         |               Code            |
 *	 +-+-+-+-+-+---------------------+-------------------------------+
 *	
 *	 where
 *	
 *	    S - Severity - indicates success/fail
 *	
 *	        0 - Success
 *	        1 - Fail (COERROR)
 *	
 *	    R - reserved portion of the facility code, corresponds to NT's
 *	        second severity bit.
 *	
 *	    C - reserved portion of the facility code, corresponds to NT's
 *	        C field.
 *	
 *	    N - reserved portion of the facility code. Used to indicate a
 *	        mapped NT status value.
 *	
 *	    r - reserved portion of the facility code. Reserved for internal
 *	        use. Used to indicate HRESULT values that are not status
 *	        values, but are instead message ids for display strings.
 *	
 *	    Facility - is the facility code
 *			FACILITY_NULL                    0x0
 *			FACILITY_RPC                     0x1
 *			FACILITY_DISPATCH                0x2
 *			FACILITY_STORAGE                 0x3
 *			FACILITY_ITF                     0x4
 *			FACILITY_WIN32                   0x7
 *			FACILITY_WINDOWS                 0x8
 *	
 *	    Code - is the facility's status code
 *	
 */




/*
 * 	We can't use OLE 2.0 macros to build sCodes because the definition has
 *	changed and we wish to conform to the new definition.
 */
#define MAKE_MAPI_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )

/* The following two macros are used to build OLE 2.0 style sCodes */

#define MAKE_MAPI_E( err )	(MAKE_MAPI_SCODE( 1, FACILITY_ITF, err ))
#define MAKE_MAPI_S( warn )	(MAKE_MAPI_SCODE( 0, FACILITY_ITF, warn ))

#ifdef	SUCCESS_SUCCESS
#undef	SUCCESS_SUCCESS
#endif
#define SUCCESS_SUCCESS		0L

/* General errors (used by more than one MAPI object) */

#define MAPI_E_CALL_FAILED								E_FAIL
#define MAPI_E_NOT_ENOUGH_MEMORY						E_OUTOFMEMORY
#define MAPI_E_INVALID_PARAMETER						E_INVALIDARG
#define MAPI_E_INTERFACE_NOT_SUPPORTED					E_NOINTERFACE
#define MAPI_E_NO_ACCESS								E_ACCESSDENIED

#define MAPI_E_NO_SUPPORT								MAKE_MAPI_E( 0x102 )
#define	MAPI_E_BAD_CHARWIDTH							MAKE_MAPI_E( 0x103 )
#define MAPI_E_STRING_TOO_LONG							MAKE_MAPI_E( 0x105 )
#define MAPI_E_UNKNOWN_FLAGS							MAKE_MAPI_E( 0x106 )
#define MAPI_E_INVALID_ENTRYID							MAKE_MAPI_E( 0x107 )
#define MAPI_E_INVALID_OBJECT							MAKE_MAPI_E( 0x108 )
#define MAPI_E_OBJECT_CHANGED							MAKE_MAPI_E( 0x109 )
#define MAPI_E_OBJECT_DELETED							MAKE_MAPI_E( 0x10A )
#define MAPI_E_BUSY			  							MAKE_MAPI_E( 0x10B )
#define MAPI_E_NOT_ENOUGH_DISK							MAKE_MAPI_E( 0x10D )
#define MAPI_E_NOT_ENOUGH_RESOURCES						MAKE_MAPI_E( 0x10E )
#define MAPI_E_NOT_FOUND 								MAKE_MAPI_E( 0x10F )
#define MAPI_E_VERSION				 					MAKE_MAPI_E( 0x110 )
#define MAPI_E_LOGON_FAILED								MAKE_MAPI_E( 0x111 )
#define MAPI_E_SESSION_LIMIT							MAKE_MAPI_E( 0x112 )
#define MAPI_E_USER_CANCEL								MAKE_MAPI_E( 0x113 )
#define MAPI_E_UNABLE_TO_ABORT							MAKE_MAPI_E( 0x114 )
#define MAPI_E_NETWORK_ERROR							MAKE_MAPI_E( 0x115 )
#define MAPI_E_DISK_ERROR								MAKE_MAPI_E( 0x116 )
#define MAPI_E_TOO_COMPLEX			 					MAKE_MAPI_E( 0x117 )
#define MAPI_E_BAD_COLUMN								MAKE_MAPI_E( 0x118 )
#define MAPI_E_EXTENDED_ERROR							MAKE_MAPI_E( 0x119 )
#define MAPI_E_COMPUTED									MAKE_MAPI_E( 0x11A )
#define MAPI_E_CORRUPT_DATA								MAKE_MAPI_E( 0x11B )
#define MAPI_E_UNCONFIGURED								MAKE_MAPI_E( 0x11C )
#define MAPI_E_FAILONEPROVIDER							MAKE_MAPI_E( 0x11D )
#define MAPI_E_UNKNOWN_CPID								MAKE_MAPI_E( 0x11E )
#define MAPI_E_UNKNOWN_LCID								MAKE_MAPI_E( 0x11F )

/* Flavors of E_ACCESSDENIED, used at logon */

#define MAPI_E_PASSWORD_CHANGE_REQUIRED					MAKE_MAPI_E( 0x120 )
#define MAPI_E_PASSWORD_EXPIRED							MAKE_MAPI_E( 0x121 )
#define MAPI_E_INVALID_WORKSTATION_ACCOUNT				MAKE_MAPI_E( 0x122 )
#define MAPI_E_INVALID_ACCESS_TIME						MAKE_MAPI_E( 0x123 )
#define MAPI_E_ACCOUNT_DISABLED							MAKE_MAPI_E( 0x124 )

/* MAPI base function and status object specific errors and warnings */

#define MAPI_E_END_OF_SESSION							MAKE_MAPI_E( 0x200 )
#define MAPI_E_UNKNOWN_ENTRYID							MAKE_MAPI_E( 0x201 )
#define MAPI_E_MISSING_REQUIRED_COLUMN					MAKE_MAPI_E( 0x202 )
#define MAPI_W_NO_SERVICE								MAKE_MAPI_S( 0x203 )

/* Property specific errors and warnings */

#define MAPI_E_BAD_VALUE			 					MAKE_MAPI_E( 0x301 )
#define MAPI_E_INVALID_TYPE								MAKE_MAPI_E( 0x302 )
#define MAPI_E_TYPE_NO_SUPPORT							MAKE_MAPI_E( 0x303 )
#define MAPI_E_UNEXPECTED_TYPE							MAKE_MAPI_E( 0x304 )
#define MAPI_E_TOO_BIG									MAKE_MAPI_E( 0x305 )
#define MAPI_E_DECLINE_COPY								MAKE_MAPI_E( 0x306 )
#define MAPI_E_UNEXPECTED_ID							MAKE_MAPI_E( 0x307 )

#define MAPI_W_ERRORS_RETURNED		 					MAKE_MAPI_S( 0x380 )

/* Table specific errors and warnings */

#define MAPI_E_UNABLE_TO_COMPLETE	 					MAKE_MAPI_E( 0x400 )
#define MAPI_E_TIMEOUT				 					MAKE_MAPI_E( 0x401 )
#define MAPI_E_TABLE_EMPTY			 					MAKE_MAPI_E( 0x402 )
#define MAPI_E_TABLE_TOO_BIG		 					MAKE_MAPI_E( 0x403 )

#define MAPI_E_INVALID_BOOKMARK		 					MAKE_MAPI_E( 0x405 )

#define MAPI_W_POSITION_CHANGED		  					MAKE_MAPI_S( 0x481 )
#define MAPI_W_APPROX_COUNT			  					MAKE_MAPI_S( 0x482 )

/* Transport specific errors and warnings */

#define MAPI_E_WAIT					  					MAKE_MAPI_E( 0x500 )
#define MAPI_E_CANCEL				  					MAKE_MAPI_E( 0x501 )
#define MAPI_E_NOT_ME				  					MAKE_MAPI_E( 0x502 )

#define MAPI_W_CANCEL_MESSAGE		  					MAKE_MAPI_S( 0x580 )

/* Message Store, Folder, and Message specific errors and warnings */

#define MAPI_E_CORRUPT_STORE		  					MAKE_MAPI_E( 0x600 )
#define MAPI_E_NOT_IN_QUEUE			  					MAKE_MAPI_E( 0x601 )
#define MAPI_E_NO_SUPPRESS			  					MAKE_MAPI_E( 0x602 )
#define MAPI_E_COLLISION			  					MAKE_MAPI_E( 0x604 )
#define MAPI_E_NOT_INITIALIZED							MAKE_MAPI_E( 0x605 )
#define MAPI_E_NON_STANDARD								MAKE_MAPI_E( 0x606 )
#define MAPI_E_NO_RECIPIENTS							MAKE_MAPI_E( 0x607 )
#define MAPI_E_SUBMITTED								MAKE_MAPI_E( 0x608 )
#define MAPI_E_HAS_FOLDERS								MAKE_MAPI_E( 0x609 )
#define MAPI_E_HAS_MESSAGES								MAKE_MAPI_E( 0x60A )
#define MAPI_E_FOLDER_CYCLE								MAKE_MAPI_E( 0x60B )

#define MAPI_W_PARTIAL_COMPLETION						MAKE_MAPI_S( 0x680 )

/* Address Book specific errors and warnings */

#define MAPI_E_AMBIGUOUS_RECIP							MAKE_MAPI_E( 0x700 )

/* The range 0x0800 to 0x08FF is reserved */

/* Obsolete typing shortcut that will go away eventually. */
#ifndef MakeResult
#define MakeResult(_s)	ResultFromScode(_s)
#endif

/* We expect these to eventually be defined by OLE, but for now,
 * here they are.  When OLE defines them they can be much more
 * efficient than these, but these are "proper" and don't make
 * use of any hidden tricks.
 */
#ifndef	HR_SUCCEEDED
#define	HR_SUCCEEDED(_hr) SUCCEEDED((SCODE)(_hr))
#define	HR_FAILED(_hr) FAILED((SCODE)(_hr))
#endif

#endif	/* MAPICODE_H */

=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPIForm.h ===
/*
 *	M A P I F O R M . H
 *
 *	Declarations of interfaces for clients and providers of MAPI
 *  forms and form registries.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIFORM_H
#define MAPIFORM_H

#if _MSC_VER > 1000
#pragma once
#endif

/* Include common MAPI header files if they haven't been already. */

#ifndef MAPIDEFS_H
#include <mapidefs.h>
#include <mapicode.h>
#include <mapiguid.h>
#include <mapitags.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifndef _MAC
typedef const RECT FAR *LPCRECT;
#endif

/* HFRMREG is an enumeration which represents a registry container.
 * Microsoft reserves the values from 0 to 0x3FFF for its own use.
 */

typedef ULONG HFRMREG;

#define HFRMREG_DEFAULT  0
#define HFRMREG_LOCAL    1
#define HFRMREG_PERSONAL 2
#define HFRMREG_FOLDER   3

DECLARE_MAPI_INTERFACE_PTR(IPersistMessage, LPPERSISTMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IMAPIMessageSite, LPMAPIMESSAGESITE);
DECLARE_MAPI_INTERFACE_PTR(IMAPISession, LPMAPISESSION);
DECLARE_MAPI_INTERFACE_PTR(IMAPIViewContext, LPMAPIVIEWCONTEXT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIViewAdviseSink, LPMAPIVIEWADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormAdviseSink, LPMAPIFORMADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormInfo, LPMAPIFORMINFO);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormMgr, LPMAPIFORMMGR);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormContainer, LPMAPIFORMCONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIForm, LPMAPIFORM);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormFactory, LPMAPIFORMFACTORY);

typedef const char FAR *FAR * LPPCSTR;
typedef LPMAPIFORMINFO FAR *LPPMAPIFORMINFO;

STDAPI MAPIOpenFormMgr(LPMAPISESSION pSession, LPMAPIFORMMGR FAR * ppmgr);
STDAPI MAPIOpenLocalFormContainer(LPMAPIFORMCONTAINER FAR * ppfcnt);


/*-- GetLastError ----------------------------------------------------------*/
/* This defines the GetLastError method held in common by most mapiform
 * interfaces.  It is defined separately so that an implementor may include
 * more than one mapiform interface in a class.
 */

#define MAPI_GETLASTERROR_METHOD(IPURE)                                 \
    MAPIMETHOD(GetLastError) (THIS_                                     \
        /*in*/  HRESULT hResult,                                        \
	/*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIERROR FAR * lppMAPIError) IPURE;                  \


/*-- IPersistMessage -------------------------------------------------------*/
/* This interface is implemented by forms and is used to save,
 * initialize and load forms to and from messages.
 */

#define MAPI_IPERSISTMESSAGE_METHODS(IPURE)                             \
    MAPIMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) IPURE;             \
    MAPIMETHOD(IsDirty)(THIS) IPURE;                                    \
    MAPIMETHOD(InitNew)(THIS_                                           \
        /*in*/ LPMAPIMESSAGESITE pMessageSite,                          \
        /*in*/ LPMESSAGE pMessage) IPURE;                               \
    MAPIMETHOD(Load)(THIS_                                              \
        /*in*/ LPMAPIMESSAGESITE pMessageSite,                          \
        /*in*/ LPMESSAGE pMessage,                                      \
		/*in*/ ULONG ulMessageStatus,                                   \
		/*in*/ ULONG ulMessageFlags) IPURE;                             \
    MAPIMETHOD(Save)(THIS_                                              \
        /*in*/ LPMESSAGE pMessage,                                      \
        /*in*/ ULONG fSameAsLoad) IPURE;                                \
    MAPIMETHOD(SaveCompleted)(THIS_                                     \
        /*in*/ LPMESSAGE pMessage) IPURE;                               \
    MAPIMETHOD(HandsOffMessage)(THIS) IPURE;                            \

#undef INTERFACE
#define INTERFACE IPersistMessage
DECLARE_MAPI_INTERFACE_(IPersistMessage, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IPERSISTMESSAGE_METHODS(PURE)
};


/*-- IMAPIMessageSite ------------------------------------------------------*/

#define MAPI_IMAPIMESSAGESITE_METHODS(IPURE)                            \
    MAPIMETHOD(GetSession) (THIS_                                       \
        /*out*/ LPMAPISESSION FAR * ppSession) IPURE;                   \
    MAPIMETHOD(GetStore) (THIS_                                         \
        /*out*/ LPMDB FAR * ppStore) IPURE;                             \
    MAPIMETHOD(GetFolder) (THIS_                                        \
        /*out*/ LPMAPIFOLDER FAR * ppFolder) IPURE;                     \
    MAPIMETHOD(GetMessage) (THIS_                                       \
        /*out*/ LPMESSAGE FAR * ppmsg) IPURE;                           \
    MAPIMETHOD(GetFormManager) (THIS_                                   \
        /*out*/ LPMAPIFORMMGR FAR * ppFormMgr) IPURE;                   \
    MAPIMETHOD(NewMessage) (THIS_                                       \
        /*in*/  ULONG fComposeInFolder,                                 \
        /*in*/  LPMAPIFOLDER pFolderFocus,                              \
        /*in*/  LPPERSISTMESSAGE pPersistMessage,                       \
        /*out*/ LPMESSAGE FAR * ppMessage,                              \
        /*out*/ LPMAPIMESSAGESITE FAR * ppMessageSite,                  \
        /*out*/ LPMAPIVIEWCONTEXT FAR * ppViewContext) IPURE;           \
    MAPIMETHOD(CopyMessage) (THIS_                                      \
        /*in*/  LPMAPIFOLDER pFolderDestination) IPURE;                 \
    MAPIMETHOD(MoveMessage) (THIS_                                      \
        /*in*/  LPMAPIFOLDER pFolderDestination,                        \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext,                         \
        /*in*/  LPCRECT prcPosRect) IPURE;                              \
    MAPIMETHOD(DeleteMessage) (THIS_                                    \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext,                         \
        /*in*/  LPCRECT prcPosRect) IPURE;                              \
    MAPIMETHOD(SaveMessage) (THIS) IPURE;                               \
    MAPIMETHOD(SubmitMessage) (THIS_                                    \
		/*in*/ ULONG ulFlags) IPURE;                                    \
    MAPIMETHOD(GetSiteStatus) (THIS_                                    \
		/*out*/ LPULONG lpulStatus) IPURE;                              \

#undef INTERFACE
#define INTERFACE IMAPIMessageSite
DECLARE_MAPI_INTERFACE_(IMAPIMessageSite, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIMESSAGESITE_METHODS(PURE)
};


/*-- IMAPIForm -------------------------------------------------------------*/
/* This interface is implemented by forms for the benefit of viewers.
 * One method (ShutdownForm) is provided such that simple forms implementing
 * only IMAPIForm and IPersistMessage have reasonable embedding behavior.
 */

#define MAPI_IMAPIFORM_METHODS(IPURE)                                   \
    MAPIMETHOD(SetViewContext) (THIS_                                   \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext) IPURE;                  \
    MAPIMETHOD(GetViewContext) (THIS_                                   \
        /*out*/ LPMAPIVIEWCONTEXT FAR * ppViewContext) IPURE;           \
    MAPIMETHOD(ShutdownForm)(THIS_                                             \
        /*in*/  ULONG ulSaveOptions) IPURE;                             \
    MAPIMETHOD(DoVerb) (THIS_                                           \
        /*in*/  LONG iVerb,                                             \
        /*in*/  LPMAPIVIEWCONTEXT lpViewContext, /* can be null */      \
        /*in*/  ULONG hwndParent,                                       \
        /*in*/  LPCRECT lprcPosRect) IPURE;                             \
    MAPIMETHOD(Advise)(THIS_                                            \
        /*in*/  LPMAPIVIEWADVISESINK pAdvise,                           \
        /*out*/ ULONG FAR * pdwStatus) IPURE;                           \
    MAPIMETHOD(Unadvise) (THIS_                                         \
        /*in*/  ULONG ulConnection) IPURE;                              \

#undef INTERFACE
#define INTERFACE IMAPIForm
DECLARE_MAPI_INTERFACE_(IMAPIForm, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORM_METHODS(PURE)
};

typedef enum tagSAVEOPTS
{
	SAVEOPTS_SAVEIFDIRTY = 0,
	SAVEOPTS_NOSAVE = 1,
	SAVEOPTS_PROMPTSAVE = 2
} SAVEOPTS;


/*-- IMAPIViewContext ------------------------------------------------------*/
/* Implemented by viewers to support next/previous in forms.
 */

/* Structure passed in GetPrintSetup  */

typedef struct {
	ULONG ulFlags;  /* MAPI_UNICODE */
	HGLOBAL hDevMode;
	HGLOBAL hDevNames;
	ULONG ulFirstPageNumber;
	ULONG fPrintAttachments;
} FORMPRINTSETUP, FAR * LPFORMPRINTSETUP;

/* Values for pulFormat in GetSaveStream */

#define SAVE_FORMAT_TEXT                1
#define SAVE_FORMAT_RICHTEXT            2

/* Values from 0 to 0x3fff are reserved for future definition by Microsoft */

#define MAPI_IMAPIVIEWCONTEXT_METHODS(IPURE)                            \
    MAPIMETHOD(SetAdviseSink)(THIS_                                     \
        /*in*/  LPMAPIFORMADVISESINK pmvns) IPURE;                      \
    MAPIMETHOD(ActivateNext)(THIS_                                      \
        /*in*/  ULONG ulDir,                                            \
        /*in*/  LPCRECT prcPosRect) IPURE;                              \
    MAPIMETHOD(GetPrintSetup)(THIS_                                     \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPFORMPRINTSETUP FAR * lppFormPrintSetup) IPURE;        \
    MAPIMETHOD(GetSaveStream)(THIS_                                     \
        /*out*/ ULONG FAR * pulFlags,                                   \
        /*out*/ ULONG FAR * pulFormat,                                  \
        /*out*/ LPSTREAM FAR * ppstm) IPURE;                            \
    MAPIMETHOD(GetViewStatus) (THIS_                                    \
		/*out*/ LPULONG lpulStatus) IPURE;                              \

#undef INTERFACE
#define INTERFACE IMAPIViewContext
DECLARE_MAPI_INTERFACE_(IMAPIViewContext, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIVIEWCONTEXT_METHODS(PURE)
};

#define VCSTATUS_NEXT                           0x00000001
#define VCSTATUS_PREV                           0x00000002
#define VCSTATUS_MODAL                          0x00000004
#define VCSTATUS_INTERACTIVE                    0x00000008
#define VCSTATUS_READONLY                       0x00000010
#define VCSTATUS_DELETE                         0x00010000
#define VCSTATUS_COPY                           0x00020000
#define VCSTATUS_MOVE                           0x00040000
#define VCSTATUS_SUBMIT                         0x00080000
#define VCSTATUS_DELETE_IS_MOVE                 0x00100000
#define VCSTATUS_SAVE                           0x00200000
#define VCSTATUS_NEW_MESSAGE                    0x00400000

#define VCDIR_NEXT                              VCSTATUS_NEXT
#define VCDIR_PREV                              VCSTATUS_PREV
#define VCDIR_DELETE                            VCSTATUS_DELETE
#define VCDIR_MOVE                              VCSTATUS_MOVE


/*-- IMAPIFormAdviseSink ---------------------------------------------------*/
/* Part of form server, held by view; receives notifications from the view.
 *
 * This part of the form server, but is not an interface on the form
 * object.  This means that clients should not expect to QueryInterface
 * from an IMAPIForm* or IOleObject* to this interface, or vice versa.
 */

#define MAPI_IMAPIFORMADVISESINK_METHODS(IPURE)                         \
    STDMETHOD(OnChange)(THIS_ ULONG ulDir) IPURE;                       \
    STDMETHOD(OnActivateNext)(THIS_                                     \
        /*in*/  LPCSTR lpszMessageClass,                                \
        /*in*/  ULONG ulMessageStatus,                                  \
        /*in*/  ULONG ulMessageFlags,                                   \
        /*out*/ LPPERSISTMESSAGE FAR * ppPersistMessage) IPURE;         \

#undef INTERFACE
#define INTERFACE IMAPIFormAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIFormAdviseSink, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIFORMADVISESINK_METHODS(PURE)
};


/*-- IMAPIViewAdviseSink ---------------------------------------------------*/
/* Part of view context, held by form; receives notifications from the form.
 */

#define MAPI_IMAPIVIEWADVISESINK_METHODS(IPURE)                         \
    MAPIMETHOD(OnShutdown)(THIS) IPURE;                                    \
    MAPIMETHOD(OnNewMessage)(THIS) IPURE;                               \
    MAPIMETHOD(OnPrint)(THIS_                                           \
        /*in*/ ULONG dwPageNumber,                                      \
        /*in*/ HRESULT hrStatus) IPURE;                                 \
    MAPIMETHOD(OnSubmitted) (THIS) IPURE;                               \
    MAPIMETHOD(OnSaved) (THIS) IPURE;                                   \

#undef INTERFACE
#define INTERFACE IMAPIViewAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIViewAdviseSink, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIVIEWADVISESINK_METHODS(PURE)
};


/*-- IMAPIFormInfo ---------------------------------------------------------*/
/* Is implemented by registries.  Describes the form.
 */

/* Single enum value */

typedef struct
{								/* fpev */
	LPTSTR pszDisplayName;		/* carries the display string */
	ULONG nVal;					/* the value for the above enumeration */
} SMAPIFormPropEnumVal, FAR * LPMAPIFORMPROPENUMVAL;

/* MAPI Form property descriptor */

/*
 * Values for the tag in the SMAPIFormProp structure
 *
 * Microsoft reserves the range from 0 to 0x3FFF for future use in its other
 * forms registry implementations.
 */

typedef ULONG FORMPROPSPECIALTYPE;

#define FPST_VANILLA                    0
#define FPST_ENUM_PROP                  1

typedef struct
{
	ULONG ulFlags;				/* Contains MAPI_UNICODE if strings are UNICODE */
	ULONG nPropType;			/* type of the property, hiword is 0 */
	MAPINAMEID nmid;			/* id of the property */
	LPTSTR pszDisplayName;
	FORMPROPSPECIALTYPE nSpecialType;	/* tag for the following union */
	union
	{
		struct
		{
			MAPINAMEID nmidIdx;
			ULONG cfpevAvailable;	/* # of enums */
			LPMAPIFORMPROPENUMVAL pfpevAvailable;
		} s1;					/* Property String/Number association Enumeration */
	} u;
} SMAPIFormProp, FAR * LPMAPIFORMPROP;

/* Array of form properties */

typedef struct
{
	ULONG cProps;
	ULONG ulPad;				/* Pad to 8-byte alignment for insurance */
	SMAPIFormProp aFormProp[MAPI_DIM];
} SMAPIFormPropArray, FAR * LPMAPIFORMPROPARRAY;

#define CbMAPIFormPropArray(_c) \
         (offsetof(SMAPIFormPropArray, aFormProp) + \
         (_c)*sizeof(SMAPIFormProp))

/* Structure defining the layout of an mapi verb description */

typedef struct
{
	LONG lVerb;
	LPTSTR szVerbname;
	DWORD fuFlags;
	DWORD grfAttribs;
	ULONG ulFlags;				/* Either 0 or MAPI_UNICODE */
} SMAPIVerb, FAR * LPMAPIVERB;

/* Structure used for returning arrays of mapi verbs */

typedef struct
{
	ULONG cMAPIVerb;			/* Number of verbs in the structure */
	SMAPIVerb aMAPIVerb[MAPI_DIM];
} SMAPIVerbArray, FAR * LPMAPIVERBARRAY;

#define CbMAPIVerbArray(_c) \
         (offsetof(SMAPIVerbArray, aMAPIVerb) + \
         (_c)*sizeof(SMAPIVerb))

#define MAPI_IMAPIFORMINFO_METHODS(IPURE)                               \
    MAPIMETHOD(CalcFormPropSet)(THIS_                                   \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMPROPARRAY FAR * ppFormPropArray) IPURE;       \
    MAPIMETHOD(CalcVerbSet)(THIS_                                       \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIVERBARRAY FAR * ppMAPIVerbArray) IPURE;           \
    MAPIMETHOD(MakeIconFromBinary)(THIS_                                \
        /*in*/ ULONG nPropID,                                           \
        /*out*/ HICON FAR* phicon) IPURE;                               \
    MAPIMETHOD(SaveForm)(THIS_                                          \
        /*in*/ LPCTSTR szFileName) IPURE;                               \
    MAPIMETHOD(OpenFormContainer)(THIS_                                 \
        /*out*/ LPMAPIFORMCONTAINER FAR * ppformcontainer) IPURE;       \

#undef INTERFACE
#define INTERFACE IMAPIFormInfo
DECLARE_MAPI_INTERFACE_(IMAPIFormInfo, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE) 	/* note: subsumes getlasterror */
	MAPI_IMAPIFORMINFO_METHODS(PURE)
};


/* Enumeration of permissible values for PR_FORM_MESSAGE_BEHAVIOR */

#define	MAPI_MESSAGE_BEHAVIOR_IPM 0
#define	MAPI_MESSAGE_BEHAVIOR_FOLDER 1


/*-- IMAPIFormMgr ----------------------------------------------------------*/
/* The client-visible interface for form resolution and dispatch.
 */

/* Structure containing an array of message class strings */

typedef struct
{
	ULONG cValues;
	LPCSTR aMessageClass[MAPI_DIM];
} SMessageClassArray, FAR * LPSMESSAGECLASSARRAY;

#define CbMessageClassArray(_c) \
        (offsetof(SMessageClassArray, aMessageClass) + (_c)*sizeof(LPCSTR))

/* Structure containing an array of IMAPIFormInfo interfaces */

typedef struct
{
	ULONG cForms;
	LPMAPIFORMINFO aFormInfo[MAPI_DIM];
} SMAPIFormInfoArray, FAR * LPSMAPIFORMINFOARRAY;

#define CbMAPIFormInfoArray(_c) \
         (offsetof(SMAPIFormInfoArray, aFormInfo) + \
         (_c)*sizeof(LPMAPIFORMINFO))

/* Flags for IMAPIFormMgr::SelectFormContainer */

#define MAPIFORM_SELECT_ALL_REGISTRIES           0
#define MAPIFORM_SELECT_FOLDER_REGISTRY_ONLY     1
#define MAPIFORM_SELECT_NON_FOLDER_REGISTRY_ONLY 2

/* Flags for IMAPIFormMgr::CalcFormPropSet */

#define FORMPROPSET_UNION                 0
#define FORMPROPSET_INTERSECTION          1

/* Flags for IMAPIFormMgr::ResolveMessageClass and
   IMAPIFormMgr::ResolveMultipleMessageClasses */

#define MAPIFORM_EXACTMATCH             0x0020

#define MAPI_IMAPIFORMMGR_METHODS(IPURE)                                \
    MAPIMETHOD(LoadForm)(THIS_                                          \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCSTR lpszMessageClass,                                \
        /*in*/  ULONG ulMessageStatus,                                  \
        /*in*/  ULONG ulMessageFlags,                                   \
        /*in*/  LPMAPIFOLDER pFolderFocus,                              \
        /*in*/  LPMAPIMESSAGESITE pMessageSite,                         \
        /*in*/  LPMESSAGE pmsg,                                         \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext,                         \
        /*in*/  REFIID riid,                                            \
        /*out*/ LPVOID FAR *ppvObj) IPURE;                              \
    MAPIMETHOD(ResolveMessageClass)(THIS_                               \
        /*in*/  LPCSTR szMsgClass,                                      \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFOLDER pFolderFocus, /* can be null */            \
        /*out*/ LPMAPIFORMINFO FAR* ppResult) IPURE;                    \
    MAPIMETHOD(ResolveMultipleMessageClasses)(THIS_                     \
        /*in*/  LPSMESSAGECLASSARRAY pMsgClasses,                       \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFOLDER pFolderFocus, /* can be null */            \
        /*out*/ LPSMAPIFORMINFOARRAY FAR * pfrminfoarray) IPURE;        \
    MAPIMETHOD(CalcFormPropSet)(THIS_                                   \
        /*in*/  LPSMAPIFORMINFOARRAY pfrminfoarray,                     \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMPROPARRAY FAR* ppResults) IPURE;              \
    MAPIMETHOD(CreateForm)(THIS_                                        \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFORMINFO pfrminfoToActivate,                      \
        /*in*/  REFIID refiidToAsk,                                     \
        /*out*/ LPVOID FAR* ppvObj) IPURE;                              \
    MAPIMETHOD(SelectForm)(THIS_                                        \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCTSTR pszTitle,                                       \
        /*in*/  LPMAPIFOLDER pfld,                                      \
        /*out*/ LPMAPIFORMINFO FAR * ppfrminfoReturned) IPURE;          \
    MAPIMETHOD(SelectMultipleForms)(THIS_                               \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCTSTR pszTitle,                                       \
        /*in*/  LPMAPIFOLDER pfld,                                      \
        /*in*/  LPSMAPIFORMINFOARRAY pfrminfoarray,                     \
        /*out*/ LPSMAPIFORMINFOARRAY FAR * ppfrminfoarray) IPURE;       \
    MAPIMETHOD(SelectFormContainer)(THIS_                               \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMCONTAINER FAR * lppfcnt) IPURE;               \
    MAPIMETHOD(OpenFormContainer)(THIS_                                 \
        /*in*/  HFRMREG hfrmreg,                                        \
        /*in*/  LPUNKNOWN lpunk,                                        \
        /*out*/ LPMAPIFORMCONTAINER FAR * lppfcnt) IPURE;               \
    MAPIMETHOD(PrepareForm)(THIS_                                       \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFORMINFO pfrminfo) IPURE;                         \
    MAPIMETHOD(IsInConflict)(THIS_                                      \
        /*in*/  ULONG ulMessageFlags,                                   \
        /*in*/  ULONG ulMessageStatus,                                  \
        /*in*/  LPCSTR szMessageClass,                                  \
        /*in*/  LPMAPIFOLDER pFolderFocus) IPURE;                       \

#undef         INTERFACE
#define         INTERFACE    IMAPIFormMgr
DECLARE_MAPI_INTERFACE_(IMAPIFormMgr, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORMMGR_METHODS(PURE)
};

/* Platform numbers (used in .CFG files for forms) */

#define MAPIFORM_CPU_X86                1
#define MAPIFORM_CPU_MIP                2
#define MAPIFORM_CPU_AXP                3
#define MAPIFORM_CPU_PPC                4
#define MAPIFORM_CPU_M68                5

#define MAPIFORM_OS_WIN_31              1
#define MAPIFORM_OS_WINNT_35            2
#define MAPIFORM_OS_WIN_95              3
#define MAPIFORM_OS_MAC_7x              4
#define MAPIFORM_OS_WINNT_40            5

#define MAPIFORM_PLATFORM(CPU, OS) ((ULONG) ((((ULONG) CPU) << 16) | OS))


/*-- IMAPIFormContainer -------------------------------------------------*/

/*  Flags for IMAPIFormMgr::CalcFormPropSet */

/* #define FORMPROPSET_UNION            0   */
/* #define FORMPROPSET_INTERSECTION     1   */

/*  Flags for IMAPIFormMgr::InstallForm     */

#define MAPIFORM_INSTALL_DIALOG                 MAPI_DIALOG
#define MAPIFORM_INSTALL_OVERWRITEONCONFLICT    0x0010

/*  Flags for IMAPIFormContainer::ResolveMessageClass and
    IMAPIFormContainer::ResolveMultipleMessageClasses */
/* #define MAPIFORM_EXACTIMATCH    0x0020   */

#define MAPI_IMAPIFORMCONTAINER_METHODS(IPURE)                       \
    MAPIMETHOD(InstallForm)(THIS_                                   \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCTSTR szCfgPathName) IPURE;                           \
    MAPIMETHOD(RemoveForm)(THIS_                                        \
        /*in*/  LPCSTR szMessageClass) IPURE;                           \
    MAPIMETHOD(ResolveMessageClass) (THIS_                              \
        /*in*/  LPCSTR szMessageClass,                                  \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMINFO FAR * pforminfo) IPURE;                  \
    MAPIMETHOD(ResolveMultipleMessageClasses) (THIS_                    \
        /*in*/  LPSMESSAGECLASSARRAY pMsgClassArray,                    \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPSMAPIFORMINFOARRAY FAR * ppfrminfoarray) IPURE;       \
    MAPIMETHOD(CalcFormPropSet)(THIS_                                   \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMPROPARRAY FAR * ppResults) IPURE;             \
    MAPIMETHOD(GetDisplay)(THIS_                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPTSTR FAR * pszDisplayName) IPURE;                     \

#undef INTERFACE
#define INTERFACE IMAPIFormContainer
DECLARE_MAPI_INTERFACE_(IMAPIFormContainer, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORMCONTAINER_METHODS(PURE)
};

/*-- IMAPIFormFactory ------------------------------------------------------*/

#define MAPI_IMAPIFORMFACTORY_METHODS(IPURE)                            \
    MAPIMETHOD(CreateClassFactory) (THIS_                               \
        /*in*/  REFCLSID clsidForm,                                     \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPCLASSFACTORY FAR * lppClassFactory) IPURE;            \
    MAPIMETHOD(LockServer) (THIS_                                       \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  ULONG fLockServer) IPURE;                               \

#undef INTERFACE
#define INTERFACE IMAPIFormFactory
DECLARE_MAPI_INTERFACE_(IMAPIFormFactory, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORMFACTORY_METHODS(PURE)
};

#endif							/* MAPIFORM_H */


=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPIHook.h ===
/*
 *  M A P I H O O K . H
 *
 *  Defines the SpoolerMsgHook provider interface.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIHOOK_H
#define MAPIHOOK_H

#ifndef MAPIDEFS_H
#include <mapidefs.h>
#include <mapicode.h>
#include <mapiguid.h>
#include <mapitags.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* ISpoolerHook Interface ------------------------------------------------ */

/* MsgHooks */

#define HOOK_DELETE         ((ULONG) 0x00000001)
#define HOOK_CANCEL         ((ULONG) 0x00000002)

#define MAPI_ISPOOLERHOOK_METHODS(IPURE)                            \
    MAPIMETHOD(InboundMsgHook)                                      \
        (THIS_  LPMESSAGE                   lpMessage,              \
                LPMAPIFOLDER                lpFolder,               \
                LPMDB                       lpMDB,                  \
                ULONG FAR *                 lpulFlags,              \
                ULONG FAR *                 lpcbEntryID,            \
                LPBYTE FAR *                lppEntryID) IPURE;      \
    MAPIMETHOD(OutboundMsgHook)                                     \
        (THIS_  LPMESSAGE                   lpMessage,              \
                LPMAPIFOLDER                lpFolder,               \
                LPMDB                       lpMDB,                  \
                ULONG FAR *                 lpulFlags,              \
                ULONG FAR *                 lpcbEntryID,            \
                LPBYTE FAR *                lppEntryID) IPURE;      \
    
#undef       INTERFACE
#define      INTERFACE  ISpoolerHook
DECLARE_MAPI_INTERFACE_(ISpoolerHook, IUnknown)
{
    BEGIN_INTERFACE 
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_ISPOOLERHOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(ISpoolerHook, LPSPOOLERHOOK);

/* Hook Provider Entry Point */

#define HOOK_INBOUND        ((ULONG) 0x00000200)
#define HOOK_OUTBOUND       ((ULONG) 0x00000400)

typedef HRESULT (STDMAPIINITCALLTYPE HPPROVIDERINIT)(
    LPMAPISESSION           lpSession,
    HINSTANCE               hInstance,
    LPALLOCATEBUFFER        lpAllocateBuffer,
    LPALLOCATEMORE          lpAllocateMore,
    LPFREEBUFFER            lpFreeBuffer,
    LPMAPIUID               lpSectionUID,
    ULONG                   ulFlags,
    LPSPOOLERHOOK FAR *     lppSpoolerHook
);

HPPROVIDERINIT HPProviderInit;

#ifdef __cplusplus
}      /* extern "C"  */
#endif /* __cplusplus */

#endif /* MAPIHOOK_H  */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPINls.h ===
/*
 *	M A P I N L S . H
 *
 *	Internationalization Support Utilities
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPINLS_H_
#define _MAPINLS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* We don't want to include windows.h in case that conflicts with an */
/* earlier inclusion of compobj.h */

#if !defined(WINAPI)
	#if defined(_WIN32) && (_MSC_VER >= 800)
		#define WINAPI				__stdcall
	#elif defined(WIN16)
		#define WINAPI				_far _pascal
	#else
		#define WINAPI				_far _pascal
	#endif
#endif

#if defined(DOS) || defined(_MAC)
#include <string.h>
#endif

#ifndef FAR
#define FAR
#endif

typedef unsigned char				    BYTE;
typedef unsigned short      			WORD;
typedef unsigned long       			DWORD;
typedef unsigned int	 				UINT;
typedef int		 						BOOL;

#ifndef __CHAR_DEFINED__
typedef char							CHAR;
#endif

#ifdef UNICODE
typedef WCHAR							TCHAR;
#else
typedef char							TCHAR;
#endif

#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#endif

typedef WCHAR FAR *						LPWSTR;
typedef const WCHAR FAR *				LPCWSTR;
typedef CHAR FAR *						LPSTR;
typedef const CHAR FAR *				LPCSTR;
typedef TCHAR FAR *						LPTSTR;
typedef const TCHAR FAR *				LPCTSTR;
typedef DWORD 							LCID;
typedef const void FAR *				LPCVOID;

#ifndef _MAC
#ifndef LPOLESTR
#if !defined (_WIN32)

#define LPOLESTR        LPSTR
#define LPCOLESTR       LPCSTR
#define OLECHAR         char
#define OLESTR(str) 	str

#else  /* Win32 */

#define LPOLESTR        LPWSTR
#define LPCOLESTR       LPCWSTR
#define OLECHAR         WCHAR
#define OLESTR(str)     L##str

#endif /* !_WIN32 */
#endif /* LPOLESTR */
#endif /* _MAC */

#define NORM_IGNORECASE      			0x00000001     /* ignore case */
#define NORM_IGNORENONSPACE  			0x00000002     /* ignore diacritics */
#define NORM_IGNORESYMBOLS   			0x00000004     /* ignore symbols */

#if defined (_WIN32) /* from winnls.h */
#define NORM_IGNOREKANATYPE				0x00010000     /* ignore kanatype */
#define NORM_IGNOREWIDTH				0x00020000	   /* ignore width */
#elif defined (WIN16) /* from olenls.h */
#define NORM_IGNOREWIDTH				0x00000008		/* ignore width */
#define NORM_IGNOREKANATYPE				0x00000040		/* ignore kanatype */
#endif

#if defined(WIN16)

#define	lstrcpyA						lstrcpy
#define	lstrlenA						lstrlen
#define	lstrcmpA						lstrcmp
#define lstrcmpiA						lstrcmpi
#define	LoadStringA						LoadString
#define IsBadStringPtrA(a1, a2)			IsBadStringPtr(a1, a2)
#define	wvsprintfA						wvsprintf
#define	MessageBoxA						MessageBox
#define GetModuleHandleA				GetModuleHandle
#define CreateWindowA					CreateWindow
#define RegisterClassA					RegisterClass
#define	CharToOemBuff					AnsiToOemBuff
#define	CharToOem						AnsiToOem
#define	CharUpperBuff					AnsiUpperBuff
#define	CharUpper						AnsiUpper

#elif defined(DOS) || defined(_MAC)

#define	IsBadReadPtr(lp, cb)			(FALSE)
#define IsBadWritePtr(lp, cb)			(FALSE)
#define IsBadHugeReadPtr(lp, cb)		(FALSE)
#define IsBadHugeWritePtr(lp, cb)		(FALSE)
#define IsBadCodePtr(lpfn)				(FALSE)
#ifdef _MAC
#undef IsBadStringPtr
#endif
#define IsBadStringPtr(lpsz, cchMax)	(FALSE)
#define IsBadStringPtrA(lpsz, cchMax)	(FALSE)

#if defined(DOS)

#define	lstrcpyA						strcpy
#define	lstrlenA						strlen
#define	lstrcmpA						strcmp
#define lstrcmp							strcmp
#define lstrcmpi						strcmpi
#define lstrcpy							strcpy
#define lstrcat							strcat
#define lstrlen							strlen
#define wsprintf						sprintf

#endif
#endif

#if defined(DOS) || defined(WIN16)
/* Simulate effect of afx header */
#define __T(x)		x
#define _T(x)		__T(x)
#define TEXT		_T
#endif

#define CP_ACP		0		/* default to ANSI code page */
#define CP_OEMCP	1		/* default to OEM  code page */

LCID	WINAPI	MNLS_GetUserDefaultLCID(void);
UINT	WINAPI	MNLS_GetACP(void);
int		WINAPI	MNLS_CompareStringA(LCID Locale, DWORD dwCmpFlags,
					LPCSTR lpString1, int cchCount1, LPCSTR lpString2,
					int cchCount2);
int		WINAPI	MNLS_CompareStringW(LCID Locale, DWORD dwCmpFlags,
					LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2,
					int cchCount2);
int		WINAPI	MNLS_MultiByteToWideChar(UINT uCodePage, DWORD dwFlags,
					LPCSTR lpMultiByteStr, int cchMultiByte,
					LPWSTR lpWideCharStr, int cchWideChar);
int		WINAPI	MNLS_WideCharToMultiByte(UINT uCodePage, DWORD dwFlags,
					LPCWSTR lpWideCharStr, int cchWideChar,
					LPSTR lpMultiByteStr, int cchMultiByte,
					LPCSTR lpDefaultChar, BOOL FAR *lpfUsedDefaultChar);
int		WINAPI	MNLS_lstrlenW(LPCWSTR lpString);
int		WINAPI	MNLS_lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
LPWSTR	WINAPI	MNLS_lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
BOOL	WINAPI	MNLS_IsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);

#if defined(_WIN32) && !defined(_WINNT) && !defined(_WIN95) && !defined(_MAC)
#define _WINNT
#endif

#if !defined(_WINNT) && !defined(_WIN95)
#define GetUserDefaultLCID		MNLS_GetUserDefaultLCID
#define GetACP					MNLS_GetACP
#define MultiByteToWideChar		MNLS_MultiByteToWideChar
#define WideCharToMultiByte		MNLS_WideCharToMultiByte
#define CompareStringA			MNLS_CompareStringA
#endif

#if !defined(MAPI_NOWIDECHAR)

#define lstrlenW				MNLS_lstrlenW
#define lstrcmpW				MNLS_lstrcmpW
#define lstrcpyW				MNLS_lstrcpyW
#define CompareStringW			MNLS_CompareStringW

#if defined(WIN16) || defined(_WINNT) || defined(_WIN95)
#define IsBadStringPtrW			MNLS_IsBadStringPtrW
#elif defined(_MAC)
#define IsBadStringPtrW(lpsz, cchMax)			(FALSE)
#else
#define IsBadStringPtrW			(FALSE)
#endif

#endif	/* ! MAPI_NOWIDECHAR */

#ifdef __cplusplus
}
#endif

#endif /* _MAPINLS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPIDbg.h ===
/*
 *	M A P I D B G . H
 *
 *	Debugging support for MAPI service providers.
 *	Support functions are implemented in MAPIDBG.C.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef __MAPIDBG_H_
#define __MAPIDBG_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

/*
 * Debugging Macros -------------------------------------------------------
 *
 *		IFDBG(x)		Results in the expression x if DEBUG is defined, or
 *						to nothing if DEBUG is not defined
 *	
 *		IFNDBG(x)		Results in the expression x if DEBUG is not defined,
 *						or to nothing if DEBUG is defined
 *	
 *		Unreferenced(a) Causes a to be referenced so that the compiler
 *						doesn't issue warnings about unused local variables
 *						which exist but are reserved for future use (eg
 *						ulFlags in many cases)
 */

#if defined(DEBUG)
#define IFDBG(x)			x
#define IFNDBG(x)
#else
#define IFDBG(x)
#define IFNDBG(x)			x
#endif

#ifdef __cplusplus
#define EXTERN_C_BEGIN		extern "C" {
#define EXTERN_C_END		}
#else
#define EXTERN_C_BEGIN
#define EXTERN_C_END
#endif

#define dimensionof(a) 		(sizeof(a)/sizeof(*(a)))

#define Unreferenced(a)		((void)(a))

typedef long SCODE;
typedef unsigned long ULONG;
typedef unsigned long DWORD;

/*
 *	 Assert Macros ---------------------------------------------------------
 *	
 *		Assert(a)		Displays a message indicating the file and line number
 *						of this Assert() if a == 0.  OK'ing an assert traps
 *						into the debugger.
 *	
 *		AssertSz(a,sz)	Works like an Assert(), but displays the string sz
 *						along with the file and line number.
 *	
 *		Side asserts	A side assert works like an Assert(), but evaluates
 *						'a' even when asserts are not enabled.
 *	
 *		NF asserts		A NF (Non-Fatal) assert works like an Assert(), but
 *						continues instead of trapping into the debugger when
 *						OK'ed.
 */

#if defined(DEBUG) || defined(ASSERTS_ENABLED)
#define IFTRAP(x)			x
#else
#define IFTRAP(x)			0
#endif

#define Trap()											IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Trap"))
#define TrapSz(psz)										IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz))
#define TrapSz1(psz,a1)									IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1))
#define TrapSz2(psz,a1,a2)								IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2))
#define TrapSz3(psz,a1,a2,a3)							IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3))
#define TrapSz4(psz,a1,a2,a3,a4)						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4))
#define TrapSz5(psz,a1,a2,a3,a4,a5)						IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5))
#define TrapSz6(psz,a1,a2,a3,a4,a5,a6)					IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6))
#define TrapSz7(psz,a1,a2,a3,a4,a5,a6,a7)				IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7))
#define TrapSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)			IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TrapSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)			IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

#define Assert(t)										IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define AssertSz(t,psz)									IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz),0))
#define AssertSz1(t,psz,a1)								IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1),0))
#define AssertSz2(t,psz,a1,a2)							IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2),0))
#define AssertSz3(t,psz,a1,a2,a3)						IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define AssertSz4(t,psz,a1,a2,a3,a4)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define AssertSz5(t,psz,a1,a2,a3,a4,a5)					IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define AssertSz6(t,psz,a1,a2,a3,a4,a5,a6)				IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define AssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)			IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define AssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)		IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define AssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)		IFTRAP(((t) ? 0 : DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define SideAssert(t)									((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define SideAssertSz(t,psz)								((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz)),0)
#define SideAssertSz1(t,psz,a1)							((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1)),0)
#define SideAssertSz2(t,psz,a1,a2)						((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2)),0)
#define SideAssertSz3(t,psz,a1,a2,a3)					((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define SideAssertSz4(t,psz,a1,a2,a3,a4)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define SideAssertSz5(t,psz,a1,a2,a3,a4,a5)				((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define SideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)			((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define SideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)		((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define SideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)	((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define SideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)	((t) ? 0 : IFTRAP(DebugTrapFn(1,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

#define NFAssert(t)										IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t),0))
#define NFAssertSz(t,psz)								IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz),0))
#define NFAssertSz1(t,psz,a1)							IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1),0))
#define NFAssertSz2(t,psz,a1,a2)						IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2),0))
#define NFAssertSz3(t,psz,a1,a2,a3)						IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3),0))
#define NFAssertSz4(t,psz,a1,a2,a3,a4)					IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4),0))
#define NFAssertSz5(t,psz,a1,a2,a3,a4,a5)				IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5),0))
#define NFAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)			IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6),0))
#define NFAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)			IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7),0))
#define NFAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)		IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8),0))
#define NFAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)	IFTRAP(((t) ? 0 : DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9),0))

#define NFSideAssert(t)									((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,"Assertion Failure: " #t)),0)
#define NFSideAssertSz(t,psz)							((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz)),0)
#define NFSideAssertSz1(t,psz,a1)						((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1)),0)
#define NFSideAssertSz2(t,psz,a1,a2)					((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2)),0)
#define NFSideAssertSz3(t,psz,a1,a2,a3)					((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3)),0)
#define NFSideAssertSz4(t,psz,a1,a2,a3,a4)				((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4)),0)
#define NFSideAssertSz5(t,psz,a1,a2,a3,a4,a5)			((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5)),0)
#define NFSideAssertSz6(t,psz,a1,a2,a3,a4,a5,a6)		((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6)),0)
#define NFSideAssertSz7(t,psz,a1,a2,a3,a4,a5,a6,a7)		((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7)),0)
#define NFSideAssertSz8(t,psz,a1,a2,a3,a4,a5,a6,a7,a8)	((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8)),0)
#define NFSideAssertSz9(t,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)	((t) ? 0 : IFTRAP(DebugTrapFn(0,__FILE__,__LINE__,psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)),0)

/*
 *	 Trace Macros ------------------------------------------------------------
 *	
 *		DebugTrace			Use for arbitrary formatted output. It
 *							takes exactly the same arguments as the
 *							Windows wsprintf() function.
 *		DebugTraceResult	Shorthand for error tracing with an
 *							HRESULT. Arguments are the name of the
 *							function (not quoted) and the HRESULT.
 *		DebugTraceSc		Shorthand for error tracing with an
 *							SCODE. Arguments are the name of the
 *							function (not quoted) and the SCODE.
 *		DebugTraceArg		Shorthand for invalid parameter
 *							tracing. Arguments are the name of the
 *							function (not quoted) and a quoted
 *							string describing the bad parameter.
 */

#if defined(DEBUG) || defined(TRACES_ENABLED)
#define IFTRACE(x)			x
#define DebugTrace			DebugTraceFn
#else
#define IFTRACE(x)			0
#define DebugTrace			1?0:DebugTraceFn
#endif

#define DebugTraceResult(f,hr)							IFTRACE(((hr) ? DebugTraceFn(#f " returns 0x%08lX %s\n", GetScode(hr), SzDecodeScode(GetScode(hr))) : 0))
#define DebugTraceSc(f,sc)								IFTRACE(((sc) ? DebugTraceFn(#f " returns 0x%08lX %s\n", sc, SzDecodeScode(sc)) : 0))
#define DebugTraceArg(f,s)								IFTRACE(DebugTraceFn(#f ": bad parameter: " s "\n"))
#define	DebugTraceLine()								IFTRACE(DebugTraceFn("File %s, Line %i	\n",__FILE__,__LINE__))
#define DebugTraceProblems(sz, rgprob)					IFTRACE(DebugTraceProblemsFn(sz, rgprob))

#define TraceSz(psz)									IFTRACE(DebugTraceFn("~" psz))
#define TraceSz1(psz,a1)								IFTRACE(DebugTraceFn("~" psz,a1))
#define TraceSz2(psz,a1,a2)								IFTRACE(DebugTraceFn("~" psz,a1,a2))
#define TraceSz3(psz,a1,a2,a3)							IFTRACE(DebugTraceFn("~" psz,a1,a2,a3))
#define TraceSz4(psz,a1,a2,a3,a4)						IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4))
#define TraceSz5(psz,a1,a2,a3,a4,a5)					IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5))
#define TraceSz6(psz,a1,a2,a3,a4,a5,a6)					IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6))
#define TraceSz7(psz,a1,a2,a3,a4,a5,a6,a7)				IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7))
#define TraceSz8(psz,a1,a2,a3,a4,a5,a6,a7,a8)			IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8))
#define TraceSz9(psz,a1,a2,a3,a4,a5,a6,a7,a8,a9)		IFTRACE(DebugTraceFn("~" psz,a1,a2,a3,a4,a5,a6,a7,a8,a9))

/* Debugging Functions ---------------------------------------------------- */

EXTERN_C_BEGIN

#ifdef WIN16
#define EXPORTDBG	__export
#else
#define EXPORTDBG
#endif

int EXPORTDBG __cdecl		DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...);
int EXPORTDBG __cdecl		DebugTraceFn(char *pszFormat, ...);
void EXPORTDBG __cdecl		DebugTraceProblemsFn(char *sz, void *rgprob);
char * EXPORTDBG __cdecl	SzDecodeScodeFn(SCODE sc);
char * EXPORTDBG __cdecl	SzDecodeUlPropTypeFn(unsigned long ulPropType);
char * EXPORTDBG __cdecl	SzDecodeUlPropTagFn(unsigned long ulPropTag);
unsigned long EXPORTDBG __cdecl UlPropTagFromSzFn(char *psz);
SCODE EXPORTDBG __cdecl		ScodeFromSzFn(char *psz);
void * EXPORTDBG __cdecl	DBGMEM_EncapsulateFn(void * pmalloc, char *pszSubsys, int fCheckOften);
void EXPORTDBG __cdecl		DBGMEM_ShutdownFn(void * pmalloc);
void EXPORTDBG __cdecl		DBGMEM_CheckMemFn(void * pmalloc, int fReportOrphans);
#if defined(_WIN32) && defined(_X86_)
void EXPORTDBG __cdecl		DBGMEM_LeakHook(FARPROC pfn);
void EXPORTDBG __cdecl		GetCallStack(DWORD *, int, int);
#endif
void EXPORTDBG __cdecl		DBGMEM_NoLeakDetectFn(void * pmalloc, void *pv);
void EXPORTDBG __cdecl		DBGMEM_SetFailureAtFn(void * pmalloc, ULONG ulFailureAt);
SCODE EXPORTDBG __cdecl		ScCheckScFn(SCODE, SCODE *, char *, char *, int);
void * EXPORTDBG __cdecl	VMAlloc(ULONG);
void * EXPORTDBG __cdecl	VMAllocEx(ULONG, ULONG);
void * EXPORTDBG __cdecl	VMRealloc(void *, ULONG);
void * EXPORTDBG __cdecl	VMReallocEx(void *, ULONG, ULONG);
ULONG EXPORTDBG __cdecl		VMGetSize(void *);
ULONG EXPORTDBG __cdecl		VMGetSizeEx(void *, ULONG);
void EXPORTDBG __cdecl		VMFree(void *);
void EXPORTDBG __cdecl		VMFreeEx(void *, ULONG);

EXTERN_C_END

/*
 *	Debugging Macros -------------------------------------------------------
 *	
 *		SzDecodeScode			Returns the string name of an SCODE
 *		SzDecodeUlPropTag		Returns the string name of a property
 *								tag
 *		UlPropTagFromSz			Given a property tag's name, returns
 *								its value
 *		ScodeFromSz				Given an SCODE's name, returns its
 *								value
 *	
 *		DBGMEM_Encapsulate		Given an IMalloc interface, adds heap-
 *								checking functionality and returns a
 *								wrapped interface
 *		DBGMEM_Shutdown			Undoes DBGMEM_Encapsulate, and prints
 *								out information on any allocations made
 *								since the interface was encapsulated
 *								that have not yet been released.
 *		DBGMEM_CheckMem			Checks all memory allocated on the heap,
 *								and optionally reports leaked blocks.
 *		DBGMEM_NoLeakDetect		Prevents a block from appearing on the leak
 *								report.  Pass NULL for pv to inhibit leak
 *								reports at all from this heap.
 */

#ifdef DEBUG

#define SzDecodeScode(_sc)				SzDecodeScodeFn(_sc)
#define SzDecodeUlPropType(_ulPropType)	SzDecodeUlPropTypeFn(_ulPropType)
#define SzDecodeUlPropTag(_ulPropTag)	SzDecodeUlPropTagFn(_ulPropTag)
#define UlPropTagFromSz(_sz)			UlPropTagFromSzFn(_sz)
#define ScodeFromSz(_sz)				ScodeFromSzFn(_sz)
#define DBGMEM_Encapsulate(pm, psz, f)	DBGMEM_EncapsulateFn(pm, psz, f)
#define DBGMEM_Shutdown(pm)				DBGMEM_ShutdownFn(pm)
#define DBGMEM_CheckMem(pm, f)			DBGMEM_CheckMemFn(pm, f)
#define DBGMEM_NoLeakDetect(pm,	pv)		DBGMEM_NoLeakDetectFn(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)		DBGMEM_SetFailureAtFn(pm, ul)

#else

#define SzDecodeScode(_sc)				(0)
#define SzDecodeUlPropType(_ulPropType)	(0)
#define SzDecodeUlPropTag(_ulPropTag)	(0)
#define UlPropTagFromSz(_sz)			(0)
#define ScodeFromSz(_sz)				(0)

#if defined(__cplusplus) && !defined(CINTERFACE)
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
	((pmalloc)->AddRef(), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
	((pmalloc)->Release())
#else
#define DBGMEM_Encapsulate(pmalloc, pszSubsys, fCheckOften) \
	((pmalloc)->lpVtbl->AddRef(pmalloc), (pmalloc))
#define DBGMEM_Shutdown(pmalloc) \
	((pmalloc)->lpVtbl->Release(pmalloc))
#endif
#define DBGMEM_CheckMem(pm, f)
#define DBGMEM_NoLeakDetect(pm, pv)
#define DBGMEM_SetFailureAt(pm, ul)

#endif

/*
 *	SCODE maps -------------------------------------------------------------
 *	
 *		ScCheckSc		Given an SCODE and method name, verifies
 *						that the SCODE can legally be returned from
 *						thet method. Prints out a debug string if
 *						it cannot.
 *		HrCheckHr		As ScCheckSc, for functions that return
 *						HRESULT.
 */

#if defined(DEBUG) && !defined(DOS)
#define ScCheckSc(sc,fn)				ScCheckScFn(sc,fn##_Scodes,#fn,__FILE__, __LINE__)
#define HrCheckHr(hr,fn)				HrCheckSc(GetScode(hr),fn)
#else
#define ScCheckSc(sc,fn)				(sc)
#define HrCheckHr(hr,fn)				(hr)
#endif

#define HrCheckSc(sc,fn)				ResultFromScode(ScCheckSc(sc,fn))

#if defined(DEBUG) && !defined(DOS)
extern SCODE Common_Scodes[];
extern SCODE MAPILogon_Scodes[];
extern SCODE MAPIAllocateBuffer_Scodes[];
extern SCODE MAPIAllocateMore_Scodes[];
extern SCODE MAPIFreeBuffer_Scodes[];

extern SCODE IUnknown_QueryInterface_Scodes[];
extern SCODE IUnknown_AddRef_Scodes[];
extern SCODE IUnknown_Release_Scodes[];
extern SCODE IUnknown_GetLastError_Scodes[];

extern SCODE IMAPIProp_CopyTo_Scodes[];
extern SCODE IMAPIProp_CopyProps_Scodes[];
extern SCODE IMAPIProp_DeleteProps_Scodes[];
extern SCODE IMAPIProp_GetIDsFromNames_Scodes[];
extern SCODE IMAPIProp_GetLastError_Scodes[];
extern SCODE IMAPIProp_GetNamesFromIDs_Scodes[];
extern SCODE IMAPIProp_GetPropList_Scodes[];
extern SCODE IMAPIProp_GetProps_Scodes[];
extern SCODE IMAPIProp_OpenProperty_Scodes[];
extern SCODE IMAPIProp_SetProps_Scodes[];
extern SCODE IMAPIProp_SaveChanges_Scodes[];

extern SCODE IStream_Read_Scodes[];
extern SCODE IStream_Write_Scodes[];
extern SCODE IStream_Seek_Scodes[];
extern SCODE IStream_SetSize_Scodes[];
extern SCODE IStream_Tell_Scodes[];
extern SCODE IStream_LockRegion_Scodes[];
extern SCODE IStream_UnlockRegion_Scodes[];
extern SCODE IStream_Clone_Scodes[];
extern SCODE IStream_CopyTo_Scodes[];
extern SCODE IStream_Revert_Scodes[];
extern SCODE IStream_Stat_Scodes[];
extern SCODE IStream_Commit_Scodes[];

extern SCODE IMAPITable_GetLastError_Scodes[];
extern SCODE IMAPITable_Advise_Scodes[];
extern SCODE IMAPITable_Unadvise_Scodes[];
extern SCODE IMAPITable_GetStatus_Scodes[];
extern SCODE IMAPITable_SetColumns_Scodes[];
extern SCODE IMAPITable_QueryColumns_Scodes[];
extern SCODE IMAPITable_GetRowCount_Scodes[];
extern SCODE IMAPITable_SeekRow_Scodes[];
extern SCODE IMAPITable_SeekRowApprox_Scodes[];
extern SCODE IMAPITable_QueryPosition_Scodes[];
extern SCODE IMAPITable_FindRow_Scodes[];
extern SCODE IMAPITable_Restrict_Scodes[];
extern SCODE IMAPITable_CreateBookmark_Scodes[];
extern SCODE IMAPITable_FreeBookmark_Scodes[];
extern SCODE IMAPITable_SortTable_Scodes[];
extern SCODE IMAPITable_QuerySortOrder_Scodes[];
extern SCODE IMAPITable_QueryRows_Scodes[];
extern SCODE IMAPITable_Abort_Scodes[];
extern SCODE IMAPITable_ExpandRow_Scodes[];
extern SCODE IMAPITable_CollapseRow_Scodes[];
extern SCODE IMAPITable_WaitForCompletion_Scodes[];
extern SCODE IMAPITable_GetCollapseState_Scodes[];
extern SCODE IMAPITable_SetCollapseState_Scodes[];

extern SCODE IMAPISession_LogOff_Scodes[];
extern SCODE IMAPISession_Release_Scodes[];
extern SCODE IMAPISession_GetLastError_Scodes[];
extern SCODE IMAPISession_GetMsgStoresTable_Scodes[];
extern SCODE IMAPISession_GetStatusTable_Scodes[];
extern SCODE IMAPISession_OpenMsgStore_Scodes[];
extern SCODE IMAPISession_OpenAddressBook_Scodes[];
extern SCODE IMAPISession_OpenEntry_Scodes[];
extern SCODE IMAPISession_OpenProfileSection_Scodes[];
extern SCODE IMAPISession_Advise_Scodes[];
extern SCODE IMAPISession_Unadvise_Scodes[];
extern SCODE IMAPISession_CompareEntryIDs_Scodes[];
extern SCODE IMAPISession_MessageOptions_Scodes[];
extern SCODE IMAPISession_QueryDefaultMessageOpt_Scodes[];
extern SCODE IMAPISession_EnumAdrTypes_Scodes[];
extern SCODE IMAPISession_QueryIdentity_Scodes[];
extern SCODE IMAPISession_OpenProfileSection_Scodes[];
extern SCODE IMAPISession_GetStatusTable_Scodes[];

extern SCODE IMsgStore_Advise_Scodes[] ;
extern SCODE IMsgStore_Unadvise_Scodes[] ;
extern SCODE IMsgStore_CompareEntryIDs_Scodes[] ;
extern SCODE IMsgStore_OpenEntry_Scodes[] ;
extern SCODE IMsgStore_SetReceiveFolder_Scodes[];
extern SCODE IMsgStore_GetReceiveFolder_Scodes[];
extern SCODE IMsgStore_GetReceiveFolderTable_Scodes[];
extern SCODE IMsgStore_StoreLogoff_Scodes[];
extern SCODE IMsgStore_AbortSubmit_Scodes[];
extern SCODE IMsgStore_GetOutgoingQueue_Scodes[] ;
extern SCODE IMsgStore_SetLockState_Scodes[] ;
extern SCODE IMsgStore_FinishedMsg_Scodes[] ;
extern SCODE IMsgStore_NotifyNewMail_Scodes[];

extern SCODE IMAPIFolder_GetContentsTable_Scodes[];
extern SCODE IMAPIFolder_GetHierarchyTable_Scodes[];
extern SCODE IMAPIFolder_SaveContentsSort_Scodes[];
extern SCODE IMAPIFolder_OpenEntry_Scodes[];
extern SCODE IMAPIFolder_CreateMessage_Scodes[];
extern SCODE IMAPIFolder_CopyMessages_Scodes[];
extern SCODE IMAPIFolder_DeleteMessages_Scodes[];
extern SCODE IMAPIFolder_CreateFolder_Scodes[];
extern SCODE IMAPIFolder_CopyFolder_Scodes[];
extern SCODE IMAPIFolder_DeleteFolder_Scodes[];
extern SCODE IMAPIFolder_SetSearchCriteria_Scodes[];
extern SCODE IMAPIFolder_GetSearchCriteria_Scodes[];
extern SCODE IMAPIFolder_SetReadFlags_Scodes[];
extern SCODE IMAPIFolder_GetMessageStatus_Scodes[];
extern SCODE IMAPIFolder_SetMessageStatus_Scodes[];
extern SCODE IMAPIFolder_EmptyFolder_Scodes[];

extern SCODE IMessage_SaveChanges_Scodes[];
extern SCODE IMessage_GetAttachmentTable_Scodes[];
extern SCODE IMessage_OpenAttach_Scodes[];
extern SCODE IMessage_CreateAttach_Scodes[];
extern SCODE IMessage_DeleteAttach_Scodes[];
extern SCODE IMessage_GetRecipientTable_Scodes[];
extern SCODE IMessage_ModifyRecipients_Scodes[];
extern SCODE IMessage_SubmitMessage_Scodes[];
extern SCODE IMessage_SetReadFlag_Scodes[];

extern SCODE IAttach_SaveChanges_Scodes[];

extern SCODE IAddrBook_OpenEntry_Scodes[];
extern SCODE IAddrBook_CompareEntryIDs_Scodes[];
extern SCODE IAddrBook_CreateOneOff_Scodes[];
extern SCODE IAddrBook_ResolveName_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_Details_Scodes[];
extern SCODE IAddrBook_RecipOptions_Scodes[];
extern SCODE IAddrBook_QueryDefaultRecipOpt_Scodes[];
extern SCODE IAddrBook_Address_Scodes[];
extern SCODE IAddrBook_ButtonPress_Scodes[];

extern SCODE IABContainer_GetContentsTable_Scodes[];
extern SCODE IABContainer_GetHierarchyTable_Scodes[];

extern SCODE INotifObj_ChangeEvMask_Scodes[];

extern SCODE IMAPIStatus_ChangePassword_Scodes[];
extern SCODE IMAPIStatus_FlushQueues_Scodes[];
extern SCODE IMAPIStatus_SettingsDialog_Scodes[];
extern SCODE IMAPIStatus_ValidateState_Scodes[];

extern SCODE IMSProvider_Logon_Scodes[];
extern SCODE IMSProvider_Deinit_Scodes[];
extern SCODE IMSProvider_Init_Scodes[];
extern SCODE IMSProvider_SpoolerLogon_Scodes[];
extern SCODE IMSProvider_Shutdown_Scodes[];

extern SCODE SMAPI_MAPILogon_Scodes[];
extern SCODE SMAPI_MAPILogoff_Scodes[];
extern SCODE SMAPI_MAPIFreeBuffer_Scodes[];
extern SCODE SMAPI_MAPISendMail_Scodes[];
extern SCODE SMAPI_MAPISendDocuments_Scodes[];
extern SCODE SMAPI_MAPIFindNext_Scodes[];
extern SCODE SMAPI_MAPIReadMail_Scodes[];
extern SCODE SMAPI_MAPISaveMail_Scodes[];
extern SCODE SMAPI_MAPIDeleteMail_Scodes[];
extern SCODE SMAPI_MAPIAddress_Scodes[];
extern SCODE SMAPI_MAPIResolveName_Scodes[];
extern SCODE SMAPI_MAPIDetails_Scodes[];

extern SCODE IMSLogon_OpenEntry_Scodes[];
extern SCODE IMSLogon_OpenStatusEntry_Scodes[];
extern SCODE IMSLogon_CompareEntryIDs_Scodes[];
extern SCODE IMSLogon_Advise_Scodes[];
extern SCODE IMSLogon_Unadvise_Scodes[];
extern SCODE IMSLogon_Logoff_Scodes[];
#endif

/* ------------------------------------------------------------------------ */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPIGuid.h ===
/*
 *	M A P I G U I D . H
 *
 *	Master definitions of all GUID's for MAPI.
 *
 *	When included without INITGUID defined, this header file
 *	defines symbols that reference IIDs elsewhere.
 *
 *	When included with INITGUID defined and a "USES_IID_I..."
 *	statement for each IID used by the subsystem, it generates the
 *	bytes for those actual IIDs into the associated object file.
 *
 *	This range of 256 GUIDs reserved by OLE for MAPI use October 5, 1992.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

/*
 *	List of GUIDS allocated by MAPI
 *	
 *	0x00020300	IID_IMAPISession
 *	0x00020301	IID_IMAPITable
 *	0x00020302	IID_IMAPIAdviseSink
 *	0x00020303	IID_IMAPIProp
 *	0x00020304	IID_IProfSect
 *	0x00020305	IID_IMAPIStatus
 *	0x00020306	IID_IMsgStore
 *	0x00020307	IID_IMessage
 *	0x00020308	IID_IAttachment
 *	0x00020309	IID_IAddrBook
 *	0x0002030A	IID_IMailUser
 *	0x0002030B	IID_IMAPIContainer
 *	0x0002030C	IID_IMAPIFolder
 *	0x0002030D	IID_IABContainer
 *	0x0002030E	IID_IDistList
 *	0x0002030F	IID_IMAPISup
 *	0x00020310	IID_IMSProvider
 *	0x00020311	IID_IABProvider
 *	0x00020312	IID_IXPProvider
 *	0x00020313	IID_IMSLogon
 *	0x00020314	IID_IABLogon
 *	0x00020315	IID_IXPLogon
 *	0x00020316	IID_IMAPITableData
 *	0x00020317	IID_IMAPISpoolerInit
 *	0x00020318	IID_IMAPISpoolerSession
 *	0x00020319	IID_ITNEF
 *	0x0002031A	IID_IMAPIPropData
 *	0x0002031B	IID_IMAPIControl
 *	0x0002031C	IID_IProfAdmin
 *	0x0002031D	IID_IMsgServiceAdmin
 *	0x0002031E	IID_IMAPISpoolerService
 *	0x0002031F	IID_IMAPIProgress
 *	0x00020320	IID_ISpoolerHook
 *	0x00020321	IID_IMAPIViewContext
 *	0x00020322	IID_IMAPIFormMgr
 *	0x00020323	IID_IEnumMAPIFormProp
 *	0x00020324	IID_IMAPIFormInfo
 *	0x00020325	IID_IProviderAdmin
 *	0x00020327	IID_IMAPIForm
 *	0x00020328	PS_MAPI
 *	0x00020329	PS_PUBLIC_STRINGS
 *	0x0002032A	IID_IPersistMessage
 *	0x0002032B	IID_IMAPIViewAdviseSink
 *	0x0002032C	IID_IStreamDocfile
 *	0x0002032D	IID_IMAPIFormProp
 *	0x0002032E	IID_IMAPIFormContainer
 *	0x0002032F	IID_IMAPIFormAdviseSink
 *	0x00020330	IID_IStreamTnef
 *	0x00020350	IID_IMAPIFormFactory
 *	0x00020370	IID_IMAPIMessageSite
 *	0x00020380	PS_ROUTING_EMAIL_ADDRESSES
 *	0x00020381	PS_ROUTING_ADDRTYPE
 *	0x00020382	PS_ROUTING_DISPLAY_NAME
 *	0x00020383	PS_ROUTING_ENTRYID
 *	0x00020384	PS_ROUTING_SEARCH_KEY
 *	0x00020385	MUID_PROFILE_INSTANCE
 *	
 *	The remaining GUIDs from 0x00020300 to 0x000203FF are reserved by
 *	MAPI for future use.  The current maximum used by MAPI is 0x00020385
 *
 */

#ifndef MAPIGUID_H
#ifdef  INITGUID
#define MAPIGUID_H
#if _MSC_VER > 1000
#pragma once
#endif
#endif

/* Derive from IUnknown */
#if !defined(INITGUID) || defined(USES_IID_IMAPISession)
DEFINE_OLEGUID(IID_IMAPISession,	0x00020300, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPITable)
DEFINE_OLEGUID(IID_IMAPITable,		0x00020301, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIAdviseSink)
DEFINE_OLEGUID(IID_IMAPIAdviseSink,	0x00020302, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIControl)
DEFINE_OLEGUID(IID_IMAPIControl,	0x0002031B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfAdmin)
DEFINE_OLEGUID(IID_IProfAdmin,		0x0002031C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgServiceAdmin)
DEFINE_OLEGUID(IID_IMsgServiceAdmin,0x0002031D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProviderAdmin)
DEFINE_OLEGUID(IID_IProviderAdmin,	0x00020325, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIProgress)
DEFINE_OLEGUID(IID_IMAPIProgress,	0x0002031F, 0, 0);
#endif

/* MAPIProp or derive from MAPIProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIProp)
DEFINE_OLEGUID(IID_IMAPIProp,		0x00020303, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IProfSect)
DEFINE_OLEGUID(IID_IProfSect,		0x00020304, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIStatus)
DEFINE_OLEGUID(IID_IMAPIStatus,			0x00020305, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMsgStore)
DEFINE_OLEGUID(IID_IMsgStore,		0x00020306, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMessage)
DEFINE_OLEGUID(IID_IMessage,		0x00020307, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAttachment)
DEFINE_OLEGUID(IID_IAttachment,		0x00020308, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IAddrBook)
DEFINE_OLEGUID(IID_IAddrBook,		0x00020309, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMailUser)
DEFINE_OLEGUID(IID_IMailUser,		0x0002030A, 0, 0);
#endif

/* MAPIContainer or derive from MAPIContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIContainer)
DEFINE_OLEGUID(IID_IMAPIContainer,	0x0002030B, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFolder)
DEFINE_OLEGUID(IID_IMAPIFolder,		0x0002030C, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABContainer)
DEFINE_OLEGUID(IID_IABContainer,	0x0002030D, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IDistList)
DEFINE_OLEGUID(IID_IDistList,		0x0002030E, 0, 0);
#endif

/* MAPI Support Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISup)
DEFINE_OLEGUID(IID_IMAPISup,		0x0002030F, 0, 0);
#endif

/* Provider INIT objects */
#if !defined(INITGUID) || defined(USES_IID_IMSProvider)
DEFINE_OLEGUID(IID_IMSProvider,		0x00020310, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABProvider)
DEFINE_OLEGUID(IID_IABProvider,		0x00020311, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPProvider)
DEFINE_OLEGUID(IID_IXPProvider,		0x00020312, 0, 0);
#endif

/* Provider LOGON Objects */
#if !defined(INITGUID) || defined(USES_IID_IMSLogon)
DEFINE_OLEGUID(IID_IMSLogon,		0x00020313, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IABLogon)
DEFINE_OLEGUID(IID_IABLogon,		0x00020314, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IXPLogon)
DEFINE_OLEGUID(IID_IXPLogon,		0x00020315, 0, 0);
#endif

/* IMAPITable-in-memory Table Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPITableData)
DEFINE_OLEGUID(IID_IMAPITableData,	0x00020316, 0, 0);
#endif

/* MAPI Spooler Init Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerInit)
DEFINE_OLEGUID(IID_IMAPISpoolerInit,	0x00020317, 0, 0);
#endif

/* MAPI Spooler Session Object (internal) */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerSession)
DEFINE_OLEGUID(IID_IMAPISpoolerSession,	0x00020318, 0, 0);
#endif

/* MAPI TNEF Object Interface */
#if !defined(INITGUID) || defined(USES_IID_ITNEF)
DEFINE_OLEGUID(IID_ITNEF,			0x00020319, 0, 0);
#endif

/* IMAPIProp-in-memory Property Data Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPIPropData)
DEFINE_OLEGUID(IID_IMAPIPropData,	0x0002031A, 0, 0);
#endif

/* MAPI Spooler Hook Object */
#if !defined(INITGUID) || defined(USES_IID_ISpoolerHook)
DEFINE_OLEGUID(IID_ISpoolerHook,	0x00020320, 0, 0);
#endif

/* MAPI Spooler Service Object */
#if !defined(INITGUID) || defined(USES_IID_IMAPISpoolerService)
DEFINE_OLEGUID(IID_IMAPISpoolerService,	0x0002031E, 0, 0);
#endif

/* MAPI forms, form manager, etc. */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewContext)
DEFINE_OLEGUID(IID_IMAPIViewContext,	0x00020321, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormMgr)
DEFINE_OLEGUID(IID_IMAPIFormMgr,	0x00020322, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IEnumMAPIFormProp)
DEFINE_OLEGUID(IID_IEnumMAPIFormProp,	0x00020323, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormInfo)
DEFINE_OLEGUID(IID_IMAPIFormInfo,	0x00020324, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIForm)
DEFINE_OLEGUID(IID_IMAPIForm,	0x00020327, 0, 0);
#endif


/* Well known guids for name<->id mappings */

/*  The name of MAPI's property set  */
#if !defined(INITGUID) || defined(USES_PS_MAPI)
DEFINE_OLEGUID(PS_MAPI,	0x00020328, 0, 0);
#endif

/*  The name of the set of public strings  */
#if !defined(INITGUID) || defined(USES_PS_PUBLIC_STRINGS)
DEFINE_OLEGUID(PS_PUBLIC_STRINGS,	0x00020329, 0, 0);
#endif




/* MAPI forms, form manager, (cont) */
#if !defined(INITGUID) || defined(USES_IID_IPersistMessage)
DEFINE_OLEGUID(IID_IPersistMessage,	0x0002032A, 0, 0);
#endif

/* IMAPIViewAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIViewAdviseSink)
DEFINE_OLEGUID(IID_IMAPIViewAdviseSink,	0x0002032B, 0, 0);
#endif

/* Message Store OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamDocfile)
DEFINE_OLEGUID(IID_IStreamDocfile, 0x0002032C, 0, 0);
#endif

/* IMAPIFormProp */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormProp)
DEFINE_OLEGUID(IID_IMAPIFormProp,	0x0002032D, 0, 0);
#endif

/* IMAPIFormContainer */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormContainer)
DEFINE_OLEGUID(IID_IMAPIFormContainer, 0x0002032E, 0, 0);
#endif

/* IMAPIFormAdviseSink */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormAdviseSink)
DEFINE_OLEGUID(IID_IMAPIFormAdviseSink, 0x0002032F, 0, 0);
#endif

/* TNEF OpenProperty */
#if !defined(INITGUID) || defined(USES_IID_IStreamTnef)
DEFINE_OLEGUID(IID_IStreamTnef, 0x00020330, 0, 0);
#endif

/* IMAPIFormFactory */
#if !defined(INITGUID) || defined(USES_IID_IMAPIFormFactory)
DEFINE_OLEGUID(IID_IMAPIFormFactory, 0x00020350, 0, 0);
#endif

/* IMAPIMessageSite */
#if !defined(INITGUID) || defined(USES_IID_IMAPIMessageSite)
DEFINE_OLEGUID(IID_IMAPIMessageSite, 0x00020370, 0, 0);
#endif



/* Well known guids routing property sets.
   Usefull when writing applications that route documents
   (i.e. Workflow) across gateways.  Gateways that speak MAPI
   should convert the properties found in the follow property
   sets appropriately. */

/*  PS_ROUTING_EMAIL_ADDRESSES:  Addresses that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_EMAIL_ADDRESSES)
DEFINE_OLEGUID(PS_ROUTING_EMAIL_ADDRESSES,	0x00020380, 0, 0);
#endif

/*  PS_ROUTING_ADDRTYPE:  Address types that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_ADDRTYPE)
DEFINE_OLEGUID(PS_ROUTING_ADDRTYPE,	0x00020381, 0, 0);
#endif

/*  PS_ROUTING_DISPLAY_NAME:  Display Name that corresponds to the other props */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_DISPLAY_NAME)
DEFINE_OLEGUID(PS_ROUTING_DISPLAY_NAME,	0x00020382, 0, 0);
#endif

/*  PS_ROUTING_ENTRYID:  (optional) EntryIDs that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_ENTRYID)
DEFINE_OLEGUID(PS_ROUTING_ENTRYID,	0x00020383, 0, 0);
#endif

/*  PS_ROUTING_SEARCH_KEY:  (optional) search keys that need converting at gateways, etc. */
#if !defined(INITGUID) || defined(USES_PS_ROUTING_SEARCH_KEY)
DEFINE_OLEGUID(PS_ROUTING_SEARCH_KEY,	0x00020384, 0, 0);
#endif

/*	MUID_PROFILE_INSTANCE
	Well known section in a profile which contains a property (PR_SEARCH_KEY) which is unique
	for any given profile.  Applications and providers can depend on this value as being
	different for each unique profile. */
#if !defined(INITGUID) || defined(USES_MUID_PROFILE_INSTANCE)
DEFINE_OLEGUID(MUID_PROFILE_INSTANCE, 0x00020385, 0, 0);
#endif

#endif	/* MAPIGUID_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPIDefS.h ===
/*
 *	M A P I D E F S . H
 *
 *	Definitions used by MAPI clients and service providers.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIDEFS_H
#define MAPIDEFS_H

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#if defined (_WIN32) /* Must include WINDOWS.H on Win32 */
#ifndef _WINDOWS_
#define INC_OLE2 /* Get the OLE2 stuff */
#define INC_RPC  /* harmless on Windows NT; Windows 95 needs it */
#define _INC_OLE /* Windows 95 will include OLE1 without this */
#include <windows.h>
#endif

#ifndef _OLEERROR_H_
#include <winerror.h>
#endif
#ifndef _OBJBASE_H_
#include <objbase.h>
#endif
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16)
#ifndef _COMPOBJ_H_
#include <compobj.h>
#endif
#endif

#ifndef _INC_STDDEF
#include <stddef.h>
#endif

/* Array dimension for structures with variable-sized arrays at the end. */

#ifndef MAPI_DIM
#define MAPI_DIM	1
#endif

/* Provider init type. Force to cdecl always */

#ifndef STDMAPIINITCALLTYPE
#if !defined (_MAC) && defined (_WIN32)
#define STDMAPIINITCALLTYPE		__cdecl
#else
#define STDMAPIINITCALLTYPE		STDMETHODCALLTYPE
#endif
#define	STDINITMETHODIMP		HRESULT STDMAPIINITCALLTYPE
#define STDINITMETHODIMP_(type)	type STDMAPIINITCALLTYPE
#endif


#define MAPI_NT_SERVICE     ((ULONG) 0x00010000)  /* Provider is being loaded in an NT service */


#ifdef	__cplusplus
extern "C" {
#endif

/* Simple data types */

#if !defined (MIDL_PASS) /* MIDL doesn't want to see these */

#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short      WCHAR;
#endif

typedef __nullterminated char FAR *		LPSTR;
typedef __nullterminated const char FAR *	LPCSTR;

typedef __nullterminated WCHAR FAR *		LPWSTR;
typedef __nullterminated const WCHAR FAR *	LPCWSTR;

#ifdef UNICODE
typedef WCHAR				TCHAR;
typedef LPWSTR				LPTSTR;
typedef LPCWSTR				LPCTSTR;
#else
typedef char				TCHAR;
typedef LPSTR				LPTSTR;
typedef LPCSTR				LPCTSTR;
#endif

typedef BYTE FAR *			LPBYTE;
#endif /* defined MIDL_PASS */

typedef ULONG FAR *			LPULONG;

#ifndef __LHANDLE
#define __LHANDLE
typedef ULONG_PTR	LHANDLE, FAR * LPLHANDLE;
#endif

#if !defined(_WINBASE_) && !defined(_FILETIME_)
#define _FILETIME_
typedef struct _FILETIME
{
	DWORD dwLowDateTime;
	DWORD dwHighDateTime;
} FILETIME, FAR * LPFILETIME;
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/*
 *	This flag is used in many different MAPI calls to signify that
 *	the object opened by the call should be modifiable (MAPI_MODIFY).
 *  If the flag MAPI_MAX_ACCESS is set, the object returned should be
 *  returned at the maximum access level allowed.  An additional
 *  property available on the object (PR_ACCESS_LEVEL) uses the same
 *  MAPI_MODIFY flag to say just what this new access level is.
 */

#define MAPI_MODIFY				((ULONG) 0x00000001)

/*
 *	The following flags are used to indicate to the client what access
 *	level is permissible in the object. They appear in PR_ACCESS in
 *	message and folder objects as well as in contents and associated
 *	contents tables
 */

#define	MAPI_ACCESS_MODIFY					((ULONG) 0x00000001)
#define	MAPI_ACCESS_READ					((ULONG) 0x00000002)
#define	MAPI_ACCESS_DELETE					((ULONG) 0x00000004)
#define	MAPI_ACCESS_CREATE_HIERARCHY		((ULONG) 0x00000008)
#define	MAPI_ACCESS_CREATE_CONTENTS			((ULONG) 0x00000010)
#define	MAPI_ACCESS_CREATE_ASSOCIATED		((ULONG) 0x00000020)

/*
 *	The MAPI_UNICODE flag is used in many different MAPI calls to signify
 *	that strings passed through the interface are in Unicode (a 16-bit
 *	character set). The default is an 8-bit character set.
 *
 *	The value fMapiUnicode can be used as the 'normal' value for
 *	that bit, given the application's default character set.
 */

#define MAPI_UNICODE			((ULONG) 0x80000000)

#ifdef UNICODE
#define fMapiUnicode			MAPI_UNICODE
#else
#define fMapiUnicode			0
#endif

/* successful HRESULT */
#define hrSuccess				0



/* Recipient types */
#ifndef MAPI_ORIG				/* also defined in mapi.h */
#define MAPI_ORIG   0           /* Recipient is message originator          */
#define MAPI_TO     1           /* Recipient is a primary recipient         */
#define MAPI_CC     2           /* Recipient is a copy recipient            */
#define MAPI_BCC    3           /* Recipient is blind copy recipient        */
#define MAPI_P1		0x10000000	/* Recipient is a P1 resend recipient       */
#define MAPI_SUBMITTED 0x80000000 /* Recipient is already processed         */
/* #define MAPI_AUTHORIZE 4		   recipient is a CMC authorizing user		*/
/*#define MAPI_DISCRETE 0x10000000 Recipient is a P1 resend recipient       */
#endif

/* Bit definitions for abFlags[0] of ENTRYID */
#define MAPI_SHORTTERM			0x80
#define MAPI_NOTRECIP			0x40
#define MAPI_THISSESSION		0x20
#define MAPI_NOW				0x10
#define MAPI_NOTRESERVED		0x08

/* Bit definitions for abFlags[1] of ENTRYID */
#define MAPI_COMPOUND			0x80

/* ENTRYID */
typedef struct
{
	BYTE	abFlags[4];
	BYTE	ab[MAPI_DIM];
} ENTRYID, FAR *LPENTRYID;

#define CbNewENTRYID(_cb)		(offsetof(ENTRYID,ab) + (_cb))
#define CbENTRYID(_cb)			(offsetof(ENTRYID,ab) + (_cb))
#define SizedENTRYID(_cb, _name) \
	struct _ENTRYID_ ## _name \
{ \
	BYTE	abFlags[4]; \
	BYTE	ab[_cb]; \
} _name

/* Byte-order-independent version of GUID (world-unique identifier) */
typedef struct _MAPIUID
{
	BYTE ab[16];
} MAPIUID, FAR * LPMAPIUID;

/* Note:  need to include C run-times (memory.h) to use this macro */

#define IsEqualMAPIUID(lpuid1, lpuid2)	(!memcmp(lpuid1, lpuid2, sizeof(MAPIUID)))

/*
 * Constants for one-off entry ID:
 * The MAPIUID that identifies the one-off provider;
 * the flag that defines whether the embedded strings are Unicode;
 * the flag that specifies whether the recipient gets TNEF or not.
 */

#define MAPI_ONE_OFF_UID { 0x81, 0x2b, 0x1f, 0xa4, 0xbe, 0xa3, 0x10, 0x19, \
						   0x9d, 0x6e, 0x00, 0xdd, 0x01, 0x0f, 0x54, 0x02 }
#define MAPI_ONE_OFF_UNICODE		0x8000
#define MAPI_ONE_OFF_NO_RICH_INFO	0x0001

/* Object type */

#define MAPI_STORE		((ULONG) 0x00000001)	/* Message Store */
#define MAPI_ADDRBOOK	((ULONG) 0x00000002)	/* Address Book */
#define MAPI_FOLDER		((ULONG) 0x00000003)	/* Folder */
#define MAPI_ABCONT		((ULONG) 0x00000004)	/* Address Book Container */
#define MAPI_MESSAGE	((ULONG) 0x00000005)	/* Message */
#define MAPI_MAILUSER	((ULONG) 0x00000006)	/* Individual Recipient */
#define MAPI_ATTACH		((ULONG) 0x00000007)	/* Attachment */
#define MAPI_DISTLIST	((ULONG) 0x00000008)	/* Distribution List Recipient */
#define MAPI_PROFSECT	((ULONG) 0x00000009)	/* Profile Section */
#define MAPI_STATUS		((ULONG) 0x0000000A)	/* Status Object */
#define MAPI_SESSION	((ULONG) 0x0000000B)	/* Session */
#define MAPI_FORMINFO	((ULONG) 0x0000000C)	/* Form Information */


/*
 *	Maximum length of profile names and passwords, not including
 *	the null termination character.
 */
#ifndef cchProfileNameMax
#define cchProfileNameMax	64
#define cchProfilePassMax	64
#endif


/* Property Types */

#define MV_FLAG			0x1000			/* Multi-value flag */

#define PT_UNSPECIFIED	((ULONG)  0)	/* (Reserved for interface use) type doesn't matter to caller */
#define PT_NULL			((ULONG)  1)	/* NULL property value */
#define	PT_I2			((ULONG)  2)	/* Signed 16-bit value */
#define PT_LONG			((ULONG)  3)	/* Signed 32-bit value */
#define	PT_R4			((ULONG)  4)	/* 4-byte floating point */
#define PT_DOUBLE		((ULONG)  5)	/* Floating point double */
#define PT_CURRENCY		((ULONG)  6)	/* Signed 64-bit int (decimal w/	4 digits right of decimal pt) */
#define	PT_APPTIME		((ULONG)  7)	/* Application time */
#define PT_ERROR		((ULONG) 10)	/* 32-bit error value */
#define PT_BOOLEAN		((ULONG) 11)	/* 16-bit boolean (non-zero true) */
#define PT_OBJECT		((ULONG) 13)	/* Embedded object in a property */
#define	PT_I8			((ULONG) 20)	/* 8-byte signed integer */
#define PT_STRING8		((ULONG) 30)	/* Null terminated 8-bit character string */
#define PT_UNICODE		((ULONG) 31)	/* Null terminated Unicode string */
#define PT_SYSTIME		((ULONG) 64)	/* FILETIME 64-bit int w/ number of 100ns periods since Jan 1,1601 */
#define	PT_CLSID		((ULONG) 72)	/* OLE GUID */
#define PT_BINARY		((ULONG) 258)	/* Uninterpreted (counted byte array) */
/* Changes are likely to these numbers, and to their structures. */

/* Alternate property type names for ease of use */
#define	PT_SHORT	PT_I2
#define	PT_I4		PT_LONG
#define	PT_FLOAT	PT_R4
#define	PT_R8		PT_DOUBLE
#define	PT_LONGLONG	PT_I8

/*
 *	The type of a MAPI-defined string property is indirected, so
 *	that it defaults to Unicode string on a Unicode platform and to
 *	String8 on an ANSI or DBCS platform.
 *
 *	Macros are defined here both for the property type, and for the
 *	field of the property value structure which should be
 *	dereferenced to obtain the string pointer.
 */

#ifdef	UNICODE
#define PT_TSTRING			PT_UNICODE
#define PT_MV_TSTRING		(MV_FLAG|PT_UNICODE)
#define LPSZ				lpszW
#define	LPPSZ				lppszW
#define MVSZ				MVszW
#else
#define PT_TSTRING			PT_STRING8
#define PT_MV_TSTRING		(MV_FLAG|PT_STRING8)
#define LPSZ				lpszA
#define	LPPSZ				lppszA
#define MVSZ				MVszA
#endif


/* Property Tags
 *
 * By convention, MAPI never uses 0 or FFFF as a property ID.
 * Use as null values, initializers, sentinels, or what have you.
 */

#define PROP_TYPE_MASK			((ULONG)0x0000FFFF)	/* Mask for Property type */
#define PROP_TYPE(ulPropTag)	(((ULONG)(ulPropTag))&PROP_TYPE_MASK)
#define PROP_ID(ulPropTag)		(((ULONG)(ulPropTag))>>16)
#define PROP_TAG(ulPropType,ulPropID)	((((ULONG)(ulPropID))<<16)|((ULONG)(ulPropType)))
#define PROP_ID_NULL			0
#define PROP_ID_INVALID			0xFFFF
#define PR_NULL					PROP_TAG( PT_NULL, PROP_ID_NULL)
#define CHANGE_PROP_TYPE(ulPropTag, ulPropType)	\
						(((ULONG)0xFFFF0000 & ulPropTag) | ulPropType)


/* Multi-valued Property Types */

#define	PT_MV_I2		(MV_FLAG|PT_I2)
#define PT_MV_LONG		(MV_FLAG|PT_LONG)
#define	PT_MV_R4		(MV_FLAG|PT_R4)
#define PT_MV_DOUBLE	(MV_FLAG|PT_DOUBLE)
#define PT_MV_CURRENCY	(MV_FLAG|PT_CURRENCY)
#define	PT_MV_APPTIME	(MV_FLAG|PT_APPTIME)
#define PT_MV_SYSTIME	(MV_FLAG|PT_SYSTIME)
#define PT_MV_STRING8	(MV_FLAG|PT_STRING8)
#define PT_MV_BINARY	(MV_FLAG|PT_BINARY)
#define PT_MV_UNICODE	(MV_FLAG|PT_UNICODE)
#define	PT_MV_CLSID		(MV_FLAG|PT_CLSID)
#define PT_MV_I8		(MV_FLAG|PT_I8)

/* Alternate property type names for ease of use */
#define	PT_MV_SHORT		PT_MV_I2
#define	PT_MV_I4		PT_MV_LONG
#define	PT_MV_FLOAT		PT_MV_R4
#define	PT_MV_R8		PT_MV_DOUBLE
#define	PT_MV_LONGLONG	PT_MV_I8

/*
 *	Property type reserved bits
 *
 *	MV_INSTANCE is used as a flag in table operations to request
 *	that a multi-valued property be presented as a single-valued
 *	property appearing in multiple rows.
 */

#define MV_INSTANCE		0x2000
#define MVI_FLAG		(MV_FLAG | MV_INSTANCE)
#define MVI_PROP(tag)	((tag) | MVI_FLAG)

/* --------------- */
/* Data Structures */
/* --------------- */

/* Property Tag Array */

typedef struct _SPropTagArray
{
	ULONG	cValues;
	ULONG	aulPropTag[MAPI_DIM];
} SPropTagArray, FAR * LPSPropTagArray;

#define CbNewSPropTagArray(_ctag) \
	(offsetof(SPropTagArray,aulPropTag) + (_ctag)*sizeof(ULONG))
#define CbSPropTagArray(_lparray) \
	(offsetof(SPropTagArray,aulPropTag) + \
	(UINT)((_lparray)->cValues)*sizeof(ULONG))
/*	SPropTagArray */
#define SizedSPropTagArray(_ctag, _name) \
struct _SPropTagArray_ ## _name \
{ \
	ULONG	cValues; \
	ULONG	aulPropTag[_ctag]; \
} _name

/* -------------- */
/* Property Value */
/* -------------- */

typedef struct _SPropValue	SPropValue;


/* 32-bit CURRENCY definition stolen from oaidl.h */
/* 16-bit CURRENCY definition stolen from variant.h */

#ifndef _tagCY_DEFINED
#define _tagCY_DEFINED
#define _CY_DEFINED
#if (defined (WIN16) || defined (DOS)) && !defined (_VARIANT_H_)
typedef struct FARSTRUCT tagCY {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
} CY;
#elif defined (_WIN32)
/* real definition that makes the C++ compiler happy */
typedef union tagCY {
    struct {
#ifdef _MAC
        long      Hi;
        long Lo;
#else
        unsigned long Lo;
        long      Hi;
#endif
    };
    LONGLONG int64;
} CY;
#endif /* 16-bit vs 32-bit definition */
#endif
			/* size is 8 */
typedef CY CURRENCY;

typedef struct _SBinary
{
	ULONG		cb;
	LPBYTE 		lpb;
} SBinary, FAR *LPSBinary;

typedef	struct _SShortArray
{
	ULONG		cValues;
	short int	FAR *lpi;
} SShortArray;

typedef struct _SGuidArray
{
	ULONG		cValues;
	GUID		FAR *lpguid;
} SGuidArray;

typedef	struct _SRealArray
{
	ULONG		cValues;
	float		FAR *lpflt;
} SRealArray;

typedef struct _SLongArray
{
	ULONG		cValues;
	LONG 		FAR *lpl;
} SLongArray;

typedef struct _SLargeIntegerArray
{
	ULONG		cValues;
	LARGE_INTEGER	FAR *lpli;
} SLargeIntegerArray;

typedef struct _SDateTimeArray
{
	ULONG		cValues;
	FILETIME	FAR *lpft;
} SDateTimeArray;

typedef struct _SAppTimeArray
{
	ULONG		cValues;
	double		FAR *lpat;
} SAppTimeArray;

typedef struct _SCurrencyArray
{
	ULONG		cValues;
	CURRENCY	FAR *lpcur;
} SCurrencyArray;

typedef struct _SBinaryArray
{
	ULONG		cValues;
	SBinary		FAR *lpbin;
} SBinaryArray;

typedef struct _SDoubleArray
{
	ULONG		cValues;
	double		FAR *lpdbl;
} SDoubleArray;

typedef struct _SWStringArray
{
	ULONG		cValues;
	LPWSTR		FAR *lppszW;
} SWStringArray;

typedef struct _SLPSTRArray
{
	ULONG		cValues;
	LPSTR		FAR *lppszA;
} SLPSTRArray;

typedef union _PV
{
	short int			i;			/* case PT_I2 */
	LONG				l;			/* case PT_LONG */
	ULONG				ul;			/* alias for PT_LONG */
	float				flt;		/* case PT_R4 */
	double				dbl;		/* case PT_DOUBLE */
	unsigned short int	b;			/* case PT_BOOLEAN */
	CURRENCY			cur;		/* case PT_CURRENCY */
	double				at;			/* case PT_APPTIME */
	FILETIME			ft;			/* case PT_SYSTIME */
	LPSTR				lpszA;		/* case PT_STRING8 */
	SBinary				bin;		/* case PT_BINARY */
	LPWSTR				lpszW;		/* case PT_UNICODE */
	LPGUID				lpguid;		/* case PT_CLSID */
	LARGE_INTEGER		li;			/* case PT_I8 */
	SShortArray			MVi;		/* case PT_MV_I2 */
	SLongArray			MVl;		/* case PT_MV_LONG */
	SRealArray			MVflt;		/* case PT_MV_R4 */
	SDoubleArray		MVdbl;		/* case PT_MV_DOUBLE */
	SCurrencyArray		MVcur;		/* case PT_MV_CURRENCY */
	SAppTimeArray		MVat;		/* case PT_MV_APPTIME */
	SDateTimeArray		MVft;		/* case PT_MV_SYSTIME */
	SBinaryArray		MVbin;		/* case PT_MV_BINARY */
	SLPSTRArray			MVszA;		/* case PT_MV_STRING8 */
	SWStringArray		MVszW;		/* case PT_MV_UNICODE */
	SGuidArray			MVguid;		/* case PT_MV_CLSID */
	SLargeIntegerArray	MVli;		/* case PT_MV_I8 */
	SCODE				err;		/* case PT_ERROR */
	LONG				x;			/* case PT_NULL, PT_OBJECT (no usable value) */
} __UPV;

typedef struct _SPropValue
{
	ULONG		ulPropTag;
	ULONG		dwAlignPad;
	union _PV	Value;
} SPropValue, FAR * LPSPropValue;


/* --------------------------------------------- */
/* Property Problem and Property Problem Arrays */
/* --------------------------------------------- */

typedef struct _SPropProblem
{
	ULONG	ulIndex;
	ULONG	ulPropTag;
	SCODE	scode;
} SPropProblem, FAR * LPSPropProblem;

typedef struct _SPropProblemArray
{
	ULONG			cProblem;
	SPropProblem	aProblem[MAPI_DIM];
} SPropProblemArray, FAR * LPSPropProblemArray;

#define CbNewSPropProblemArray(_cprob) \
	(offsetof(SPropProblemArray,aProblem) + (_cprob)*sizeof(SPropProblem))
#define CbSPropProblemArray(_lparray) \
	(offsetof(SPropProblemArray,aProblem) + \
	(UINT) ((_lparray)->cProblem*sizeof(SPropProblem)))
#define SizedSPropProblemArray(_cprob, _name) \
struct _SPropProblemArray_ ## _name \
{ \
	ULONG			cProblem; \
	SPropProblem	aProblem[_cprob]; \
} _name

/*
 *	ENTRYLIST
 */

typedef SBinaryArray ENTRYLIST, FAR *LPENTRYLIST;

/*
 *	FLATENTRYLIST
 *	MTSID
 *	FLATMTSIDLIST
 */

typedef struct {
	ULONG cb;
	BYTE abEntry[MAPI_DIM];
} FLATENTRY, FAR *LPFLATENTRY;

typedef struct {
	ULONG		cEntries;
	ULONG		cbEntries;
	BYTE		abEntries[MAPI_DIM];
} FLATENTRYLIST, FAR *LPFLATENTRYLIST;

typedef struct {
	ULONG		cb;
	BYTE		ab[MAPI_DIM];
} MTSID, FAR *LPMTSID;

typedef struct {
	ULONG		cMTSIDs;
	ULONG		cbMTSIDs;
	BYTE		abMTSIDs[MAPI_DIM];
} FLATMTSIDLIST, FAR *LPFLATMTSIDLIST;

#define CbNewFLATENTRY(_cb)		(offsetof(FLATENTRY,abEntry) + (_cb))
#define CbFLATENTRY(_lpentry)	(offsetof(FLATENTRY,abEntry) + (_lpentry)->cb)
#define CbNewFLATENTRYLIST(_cb)	(offsetof(FLATENTRYLIST,abEntries) + (_cb))
#define CbFLATENTRYLIST(_lplist) (offsetof(FLATENTRYLIST,abEntries) + (_lplist)->cbEntries)
#define CbNewMTSID(_cb)			(offsetof(MTSID,ab) + (_cb))
#define CbMTSID(_lpentry)		(offsetof(MTSID,ab) + (_lpentry)->cb)
#define CbNewFLATMTSIDLIST(_cb)	(offsetof(FLATMTSIDLIST,abMTSIDs) + (_cb))
#define CbFLATMTSIDLIST(_lplist) (offsetof(FLATMTSIDLIST,abMTSIDs) + (_lplist)->cbMTSIDs)
/* No SizedXXX macros for these types. */

/* ------------------------------ */
/* ADRENTRY, ADRLIST */

typedef struct _ADRENTRY
{
	ULONG			ulReserved1;	/* Never used */
	ULONG			cValues;
	LPSPropValue	rgPropVals;
} ADRENTRY, FAR * LPADRENTRY;

typedef struct _ADRLIST
{
	ULONG			cEntries;
	ADRENTRY		aEntries[MAPI_DIM];
} ADRLIST, FAR * LPADRLIST;

#define CbNewADRLIST(_centries) \
	(offsetof(ADRLIST,aEntries) + (_centries)*sizeof(ADRENTRY))
#define CbADRLIST(_lpadrlist) \
	(offsetof(ADRLIST,aEntries) + (UINT)(_lpadrlist)->cEntries*sizeof(ADRENTRY))
#define SizedADRLIST(_centries, _name) \
struct _ADRLIST_ ## _name \
{ \
	ULONG			cEntries; \
	ADRENTRY		aEntries[_centries]; \
} _name

/* ------------------------------ */
/* SRow, SRowSet */

typedef struct _SRow
{
	ULONG			ulAdrEntryPad;	/* Pad so SRow's can map to ADRENTRY's */
	ULONG			cValues;		/* Count of property values */
	LPSPropValue	lpProps;		/* Property value array */
} SRow, FAR * LPSRow;

typedef struct _SRowSet
{
	ULONG			cRows;			/* Count of rows */
	SRow			aRow[MAPI_DIM];	/* Array of rows */
} SRowSet, FAR * LPSRowSet;

#define CbNewSRowSet(_crow)		(offsetof(SRowSet,aRow) + (_crow)*sizeof(SRow))
#define CbSRowSet(_lprowset)	(offsetof(SRowSet,aRow) + \
									(UINT)((_lprowset)->cRows*sizeof(SRow)))
#define SizedSRowSet(_crow, _name) \
struct _SRowSet_ ## _name \
{ \
	ULONG			cRows; \
	SRow			aRow[_crow]; \
} _name

/* MAPI Allocation Routines ------------------------------------------------ */

typedef SCODE (STDMETHODCALLTYPE ALLOCATEBUFFER)(
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE ALLOCATEMORE)(
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE FREEBUFFER)(
	LPVOID			lpBuffer
);

typedef ALLOCATEBUFFER FAR *LPALLOCATEBUFFER;
typedef ALLOCATEMORE FAR *	LPALLOCATEMORE;
typedef FREEBUFFER FAR *	LPFREEBUFFER;

/* MAPI Component Object Model Macros -------------------------------------- */

#if defined(MAPI_IF) && (!defined(__cplusplus) || defined(CINTERFACE))
#define DECLARE_MAPI_INTERFACE(iface)                                   \
		typedef struct iface##Vtbl iface##Vtbl, FAR * iface;			\
		struct iface##Vtbl
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
		DECLARE_MAPI_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
		typedef struct iface##Vtbl iface##Vtbl, FAR * iface, FAR * FAR * piface;
#else
#define DECLARE_MAPI_INTERFACE(iface)                                   \
		DECLARE_INTERFACE(iface)
#define DECLARE_MAPI_INTERFACE_(iface, baseiface)                       \
		DECLARE_INTERFACE_(iface, baseiface)
#ifdef __cplusplus
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
		interface iface; typedef iface FAR * piface
#else
#define DECLARE_MAPI_INTERFACE_PTR(iface, piface)                       \
		typedef interface iface iface, FAR * piface
#endif
#endif

#define MAPIMETHOD(method)				MAPIMETHOD_(HRESULT, method)
#define MAPIMETHOD_(type, method)		STDMETHOD_(type, method)
#define MAPIMETHOD_DECLARE(type, method, prefix) \
		STDMETHODIMP_(type) prefix##method
#define MAPIMETHOD_TYPEDEF(type, method, prefix) \
		typedef type (STDMETHODCALLTYPE prefix##method##_METHOD)

#define MAPI_IUNKNOWN_METHODS(IPURE)									\
	MAPIMETHOD(QueryInterface)											\
		(THIS_ __in REFIID riid, __deref_out LPVOID FAR * ppvObj) IPURE;					\
	MAPIMETHOD_(ULONG,AddRef)  (THIS) IPURE;							\
	MAPIMETHOD_(ULONG,Release) (THIS) IPURE;							\

#undef	IMPL
#define IMPL

/* Pointers to MAPI Interfaces --------------------------------------------- */

typedef const IID FAR * LPCIID;

DECLARE_MAPI_INTERFACE_PTR(IMsgStore,		LPMDB);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFolder,		LPMAPIFOLDER);
DECLARE_MAPI_INTERFACE_PTR(IMessage,		LPMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IAttach,			LPATTACH);
DECLARE_MAPI_INTERFACE_PTR(IAddrBook,		LPADRBOOK);
DECLARE_MAPI_INTERFACE_PTR(IABContainer,	LPABCONT);
DECLARE_MAPI_INTERFACE_PTR(IMailUser,		LPMAILUSER);
DECLARE_MAPI_INTERFACE_PTR(IDistList,		LPDISTLIST);
DECLARE_MAPI_INTERFACE_PTR(IMAPIStatus,		LPMAPISTATUS);
DECLARE_MAPI_INTERFACE_PTR(IMAPITable,		LPMAPITABLE);
DECLARE_MAPI_INTERFACE_PTR(IProfSect,		LPPROFSECT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProp,		LPMAPIPROP);
DECLARE_MAPI_INTERFACE_PTR(IMAPIContainer,	LPMAPICONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIAdviseSink, LPMAPIADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIProgress,	LPMAPIPROGRESS);
DECLARE_MAPI_INTERFACE_PTR(IProviderAdmin,	LPPROVIDERADMIN);

/* Extended MAPI Error Information ----------------------------------------- */

typedef struct _MAPIERROR
{
	ULONG	ulVersion;
	LPTSTR	lpszError;
	LPTSTR	lpszComponent;
	ULONG	ulLowLevelError;
	ULONG	ulContext;

} MAPIERROR, FAR * LPMAPIERROR;


/* IMAPIAdviseSink Interface ----------------------------------------------- */

/*
 *	Notification event types. The event types can be combined in a bitmask
 *	for filtering. Each one has a parameter structure associated with it:
 *
 *		fnevCriticalError		ERROR_NOTIFICATION
 *		fnevNewMail				NEWMAIL_NOTIFICATION
 *		fnevObjectCreated		OBJECT_NOTIFICATION
 *		fnevObjectDeleted		OBJECT_NOTIFICATION
 *		fnevObjectModified		OBJECT_NOTIFICATION
 *		fnevObjectCopied		OBJECT_NOTIFICATION
 *		fnevSearchComplete		OBJECT_NOTIFICATION
 *		fnevTableModified		TABLE_NOTIFICATION
 *		fnevStatusObjectModified ?
 *
 *		fnevExtended			EXTENDED_NOTIFICATION
 */

#define fnevCriticalError			((ULONG) 0x00000001)
#define fnevNewMail					((ULONG) 0x00000002)
#define fnevObjectCreated			((ULONG) 0x00000004)
#define fnevObjectDeleted			((ULONG) 0x00000008)
#define fnevObjectModified			((ULONG) 0x00000010)
#define fnevObjectMoved				((ULONG) 0x00000020)
#define fnevObjectCopied			((ULONG) 0x00000040)
#define fnevSearchComplete			((ULONG) 0x00000080)
#define fnevTableModified			((ULONG) 0x00000100)
#define	fnevStatusObjectModified	((ULONG) 0x00000200)
#define	fnevReservedForMapi			((ULONG) 0x40000000)
#define fnevExtended				((ULONG) 0x80000000)

/* TABLE_NOTIFICATION event types passed in ulTableEvent */

#define TABLE_CHANGED		1
#define	TABLE_ERROR			2
#define	TABLE_ROW_ADDED		3
#define	TABLE_ROW_DELETED	4
#define	TABLE_ROW_MODIFIED	5
#define	TABLE_SORT_DONE		6
#define	TABLE_RESTRICT_DONE	7
#define	TABLE_SETCOL_DONE	8
#define TABLE_RELOAD		9

/* Event Structures */

typedef struct _ERROR_NOTIFICATION
{
	ULONG		cbEntryID;
	LPENTRYID	lpEntryID;
	SCODE		scode;
	ULONG		ulFlags;			/* 0 or MAPI_UNICODE */
	LPMAPIERROR	lpMAPIError;		/* Detailed error information */
} ERROR_NOTIFICATION;

typedef struct _NEWMAIL_NOTIFICATION
{
	ULONG		cbEntryID;
	LPENTRYID	lpEntryID;			/* identifies the new message */
	ULONG		cbParentID;
	LPENTRYID	lpParentID;			/* identifies the folder it lives in */
	ULONG		ulFlags;			/* 0 or MAPI_UNICODE */
	LPTSTR		lpszMessageClass;	/* message class (UNICODE or string8) */
	ULONG		ulMessageFlags;		/* copy of PR_MESSAGE_FLAGS */
} NEWMAIL_NOTIFICATION;

typedef struct _OBJECT_NOTIFICATION
{
	ULONG				cbEntryID;
	LPENTRYID			lpEntryID;		/* EntryID of object */
	ULONG				ulObjType;		/* Type of object */
	ULONG				cbParentID;
	LPENTRYID			lpParentID;		/* EntryID of parent object */
	ULONG				cbOldID;
	LPENTRYID			lpOldID;		/* EntryID of old object */
	ULONG				cbOldParentID;
	LPENTRYID			lpOldParentID;	/* EntryID of old parent */
	LPSPropTagArray		lpPropTagArray;
} OBJECT_NOTIFICATION;

typedef struct _TABLE_NOTIFICATION
{
	ULONG				ulTableEvent;	/* Identifies WHICH table event */
	HRESULT				hResult;		/* Value for TABLE_ERROR */
	SPropValue			propIndex;		/* This row's "index property" */
	SPropValue			propPrior;		/* Preceding row's "index property" */
	SRow				row;			/* New data of added/modified row */
	ULONG				ulPad;			/* Force to 8-byte boundary */
} TABLE_NOTIFICATION;

typedef struct _EXTENDED_NOTIFICATION
{
	ULONG		ulEvent;					/* extended event code */
	ULONG		cb;							/* size of event parameters */
	LPBYTE		pbEventParameters;			/* event parameters */
} EXTENDED_NOTIFICATION;

typedef struct
{
	ULONG			cbEntryID;
	LPENTRYID		lpEntryID;
	ULONG			cValues;
	LPSPropValue	lpPropVals;
} STATUS_OBJECT_NOTIFICATION;

typedef struct _NOTIFICATION
{
	ULONG	ulEventType;		/* notification type, i.e. fnevSomething */
	ULONG	ulAlignPad;			/* Force to 8-byte boundary */
	union
	{
		ERROR_NOTIFICATION			err;
		NEWMAIL_NOTIFICATION		newmail;
		OBJECT_NOTIFICATION			obj;
		TABLE_NOTIFICATION			tab;
		EXTENDED_NOTIFICATION		ext;
		STATUS_OBJECT_NOTIFICATION	statobj;
	} info;
} NOTIFICATION, FAR * LPNOTIFICATION;


/* Interface used for registering and issuing notification callbacks. */

#define MAPI_IMAPIADVISESINK_METHODS(IPURE)								\
	MAPIMETHOD_(ULONG, OnNotify)										\
		(THIS_	ULONG						cNotif,						\
				LPNOTIFICATION				lpNotifications) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIAdviseSink, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIADVISESINK_METHODS(PURE)
};

/* Callback function type for MAPIAllocAdviseSink */

typedef long (STDAPICALLTYPE NOTIFCALLBACK) (
	LPVOID			lpvContext,
	ULONG			cNotification,
	LPNOTIFICATION	lpNotifications);
typedef NOTIFCALLBACK FAR * LPNOTIFCALLBACK;

/*
 *	Message name for the 16-bit MAPI notififcation engine.
 *	This can be used in 16-bit applications to force processing
 *	of notification callbacks.
 */

#define szMAPINotificationMsg "MAPI Notify window message"


/* IMAPIProgress Interface ------------------------------------------------- */

/* Flag values for the progress indicator */

#define MAPI_TOP_LEVEL		((ULONG) 0x00000001)

#define MAPI_IMAPIPROGRESS_METHODS(IPURE)								\
	MAPIMETHOD(Progress)												\
		(THIS_	ULONG						ulValue,					\
				ULONG						ulCount,					\
				ULONG						ulTotal) IPURE;				\
	MAPIMETHOD(GetFlags)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(GetMax)													\
		(THIS_	ULONG FAR *					lpulMax) IPURE;				\
	MAPIMETHOD(GetMin)													\
		(THIS_	ULONG FAR *					lpulMin) IPURE;				\
	MAPIMETHOD(SetLimits)												\
		(THIS_	LPULONG						lpulMin,					\
				LPULONG						lpulMax,					\
				LPULONG						lpulFlags) IPURE;			\

#undef		INTERFACE
#define		INTERFACE	IMAPIProgress
DECLARE_MAPI_INTERFACE_(IMAPIProgress, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROGRESS_METHODS(PURE)
};


/* IMAPIProp Interface ----------------------------------------------------- */

/* GetLastError */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/*
 *  Version:
 */
#define MAPI_ERROR_VERSION		0x00000000L

/* GetPropList */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetProps */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* SaveChanges */

#define KEEP_OPEN_READONLY		((ULONG) 0x00000001)
#define KEEP_OPEN_READWRITE		((ULONG) 0x00000002)
#define FORCE_SAVE				((ULONG) 0x00000004)
/* define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* OpenProperty  - ulFlags */
/******	MAPI_MODIFY				((ULONG) 0x00000001) above */
#define	MAPI_CREATE				((ULONG) 0x00000002)
#define STREAM_APPEND			((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* OpenProperty  - ulInterfaceOptions, IID_IMAPITable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* CopyTo, CopyProps */

#define MAPI_MOVE				((ULONG) 0x00000001)
#define MAPI_NOREPLACE			((ULONG) 0x00000002)
#define MAPI_DECLINE_OK			((ULONG) 0x00000004)

#ifndef MAPI_DIALOG				/* also defined in mapi.h */
#define MAPI_DIALOG				((ULONG) 0x00000008)
#endif

#ifndef MAPI_USE_DEFAULT		/* also defined in mapi.h */
#define MAPI_USE_DEFAULT		0x00000040	/* Use default profile in logon */
#endif

/* Flags used in GetIDsFromNames  */
/******	MAPI_CREATE				((ULONG) 0x00000002) above */

/* Flags used in GetNamesFromIDs  (bit fields) */
#define MAPI_NO_STRINGS			((ULONG) 0x00000001)
#define MAPI_NO_IDS				((ULONG) 0x00000002)

/*  Union discriminator  */
#define MNID_ID					0
#define MNID_STRING				1
typedef struct _MAPINAMEID
{
	LPGUID lpguid;
	ULONG ulKind;
	union {
		LONG lID;
		LPWSTR lpwstrName;
	} Kind;

} MAPINAMEID, FAR * LPMAPINAMEID;

#define MAPI_IMAPIPROP_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(SaveChanges)												\
		(THIS_ ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetProps)												\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppPropArray) IPURE;		\
	MAPIMETHOD(GetPropList)												\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray FAR *		lppPropTagArray) IPURE;		\
	MAPIMETHOD(OpenProperty)											\
		(THIS_	ULONG						ulPropTag,					\
				LPCIID						lpiid,						\
				ULONG						ulInterfaceOptions,			\
				ULONG						ulFlags,					\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(SetProps)												\
		(THIS_	ULONG						cValues,					\
				LPSPropValue				lpPropArray,				\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(DeleteProps)												\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(CopyTo)													\
		(THIS_	ULONG						ciidExclude,				\
				LPCIID						rgiidExclude,				\
				LPSPropTagArray				lpExcludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS 				lpProgress,					\
				LPCIID						lpInterface,				\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(CopyProps)												\
		(THIS_	LPSPropTagArray				lpIncludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS 				lpProgress,					\
				LPCIID						lpInterface,				\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(GetNamesFromIDs)											\
		(THIS_	LPSPropTagArray FAR *		lppPropTags,				\
				LPGUID						lpPropSetGuid,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcPropNames,				\
				LPMAPINAMEID FAR * FAR *	lpppPropNames) IPURE;		\
	MAPIMETHOD(GetIDsFromNames)											\
		(THIS_	ULONG						cPropNames,					\
				LPMAPINAMEID FAR *			lppPropNames,				\
				ULONG						ulFlags,					\
				LPSPropTagArray FAR *		lppPropTags) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE	IMAPIProp
DECLARE_MAPI_INTERFACE_(IMAPIProp, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
};

/* IMAPITable Interface ---------------------------------------------------- */

/* Table status */

#define TBLSTAT_COMPLETE			((ULONG) 0)
#define TBLSTAT_QCHANGED			((ULONG) 7)
#define TBLSTAT_SORTING				((ULONG) 9)
#define TBLSTAT_SORT_ERROR			((ULONG) 10)
#define TBLSTAT_SETTING_COLS		((ULONG) 11)
#define TBLSTAT_SETCOL_ERROR		((ULONG) 13)
#define TBLSTAT_RESTRICTING			((ULONG) 14)
#define TBLSTAT_RESTRICT_ERROR		((ULONG) 15)


/* Table Type */

#define TBLTYPE_SNAPSHOT			((ULONG) 0)
#define TBLTYPE_KEYSET				((ULONG) 1)
#define TBLTYPE_DYNAMIC				((ULONG) 2)


/* Sort order */

/* bit 0: set if descending, clear if ascending */

#define TABLE_SORT_ASCEND		((ULONG) 0x00000000)
#define TABLE_SORT_DESCEND		((ULONG) 0x00000001)
#define TABLE_SORT_COMBINE		((ULONG) 0x00000002)


/* Data structures */

typedef struct _SSortOrder
{
	ULONG	ulPropTag;			/* Column to sort on */
	ULONG	ulOrder;			/* Ascending, descending, combine to left */
} SSortOrder, FAR * LPSSortOrder;

typedef struct _SSortOrderSet
{
	ULONG	  		cSorts;		/* Number of sort columns in aSort below*/
	ULONG			cCategories;	/* 0 for non-categorized, up to cSorts */
	ULONG			cExpanded;		/* 0 if no categories start expanded, */
									/*		up to cExpanded */
	SSortOrder		aSort[MAPI_DIM];	/* The sort orders */
} SSortOrderSet, FAR * LPSSortOrderSet;

#define CbNewSSortOrderSet(_csort) \
	(offsetof(SSortOrderSet,aSort) + (_csort)*sizeof(SSortOrder))
#define CbSSortOrderSet(_lpset) \
	(offsetof(SSortOrderSet,aSort) + \
	(UINT)((_lpset)->cSorts*sizeof(SSortOrder)))
#define SizedSSortOrderSet(_csort, _name) \
struct _SSortOrderSet_ ## _name \
{ \
	ULONG	  		cSorts;			\
	ULONG			cCategories;	\
	ULONG			cExpanded;		\
	SSortOrder		aSort[_csort];	\
} _name

typedef ULONG 		BOOKMARK;

#define BOOKMARK_BEGINNING	((BOOKMARK) 0)		/* Before first row */
#define BOOKMARK_CURRENT	((BOOKMARK) 1)		/* Before current row */
#define BOOKMARK_END		((BOOKMARK) 2)		/* After last row */

/* Fuzzy Level */

#define FL_FULLSTRING		((ULONG) 0x00000000)
#define FL_SUBSTRING		((ULONG) 0x00000001)
#define FL_PREFIX			((ULONG) 0x00000002)

#define FL_IGNORECASE		((ULONG) 0x00010000)
#define FL_IGNORENONSPACE	((ULONG) 0x00020000)
#define FL_LOOSE			((ULONG) 0x00040000)

/* Restrictions */

typedef struct _SRestriction	FAR * LPSRestriction;

/* Restriction types */

#define RES_AND				((ULONG) 0x00000000)
#define RES_OR				((ULONG) 0x00000001)
#define RES_NOT				((ULONG) 0x00000002)
#define RES_CONTENT			((ULONG) 0x00000003)
#define RES_PROPERTY		((ULONG) 0x00000004)
#define RES_COMPAREPROPS	((ULONG) 0x00000005)
#define RES_BITMASK			((ULONG) 0x00000006)
#define RES_SIZE			((ULONG) 0x00000007)
#define RES_EXIST			((ULONG) 0x00000008)
#define RES_SUBRESTRICTION	((ULONG) 0x00000009)
#define RES_COMMENT			((ULONG) 0x0000000A)

/* Relational operators. These apply to all property comparison restrictions. */

#define RELOP_LT		((ULONG) 0)		/* <  */
#define RELOP_LE		((ULONG) 1)		/* <= */
#define RELOP_GT		((ULONG) 2)		/* >  */
#define RELOP_GE		((ULONG) 3)		/* >= */
#define RELOP_EQ		((ULONG) 4)		/* == */
#define RELOP_NE		((ULONG) 5)		/* != */
#define RELOP_RE		((ULONG) 6)		/* LIKE (Regular expression) */

/* Bitmask operators, for RES_BITMASK only. */

#define BMR_EQZ		((ULONG) 0)		/* ==0 */
#define BMR_NEZ		((ULONG) 1)		/* !=0 */

/* Subobject identifiers for RES_SUBRESTRICTION only. See MAPITAGS.H. */

/* #define PR_MESSAGE_RECIPIENTS  PROP_TAG(PT_OBJECT,0x0E12) */
/* #define PR_MESSAGE_ATTACHMENTS PROP_TAG(PT_OBJECT,0x0E13) */

typedef struct _SAndRestriction
{
	ULONG			cRes;
	LPSRestriction 	lpRes;
} SAndRestriction;

typedef struct _SOrRestriction
{
	ULONG			cRes;
	LPSRestriction 	lpRes;
} SOrRestriction;

typedef struct _SNotRestriction
{
	ULONG			ulReserved;
	LPSRestriction 	lpRes;
} SNotRestriction;

typedef struct _SContentRestriction
{
	ULONG			ulFuzzyLevel;
	ULONG			ulPropTag;
	LPSPropValue	lpProp;
} SContentRestriction;

typedef struct _SBitMaskRestriction
{
	ULONG			relBMR;
	ULONG			ulPropTag;
	ULONG			ulMask;
} SBitMaskRestriction;

typedef struct _SPropertyRestriction
{
	ULONG			relop;
	ULONG			ulPropTag;
	LPSPropValue	lpProp;
} SPropertyRestriction;

typedef struct _SComparePropsRestriction
{
	ULONG			relop;
	ULONG			ulPropTag1;
	ULONG			ulPropTag2;
} SComparePropsRestriction;

typedef struct _SSizeRestriction
{
	ULONG			relop;
	ULONG			ulPropTag;
	ULONG			cb;
} SSizeRestriction;

typedef struct _SExistRestriction
{
	ULONG			ulReserved1;
	ULONG			ulPropTag;
	ULONG			ulReserved2;
} SExistRestriction;

typedef struct _SSubRestriction
{
	ULONG			ulSubObject;
	LPSRestriction	lpRes;
} SSubRestriction;

typedef struct _SCommentRestriction
{
	ULONG			cValues; /* # of properties in lpProp */
	LPSRestriction	lpRes;
	LPSPropValue	lpProp;
} SCommentRestriction;

typedef struct _SRestriction
{
	ULONG	rt;			/* Restriction type */
	union
	{
		SComparePropsRestriction	resCompareProps;	/* first */
		SAndRestriction				resAnd;
		SOrRestriction				resOr;
		SNotRestriction				resNot;
		SContentRestriction			resContent;
		SPropertyRestriction		resProperty;
		SBitMaskRestriction			resBitMask;
		SSizeRestriction			resSize;
		SExistRestriction			resExist;
		SSubRestriction				resSub;
		SCommentRestriction			resComment;
	} res;
} SRestriction;

/* SComparePropsRestriction is first in the union so that */
/* static initializations of 3-value restriction work.    */

/* Flags of the methods of IMAPITable */

/* QueryColumn */

#define TBL_ALL_COLUMNS		((ULONG) 0x00000001)

/* QueryRows */
/* Possible values for PR_ROW_TYPE (for categorization) */

#define TBL_LEAF_ROW			((ULONG) 1)
#define TBL_EMPTY_CATEGORY		((ULONG) 2)
#define TBL_EXPANDED_CATEGORY	((ULONG) 3)
#define TBL_COLLAPSED_CATEGORY	((ULONG) 4)

/* Table wait flag */

#define TBL_NOWAIT			((ULONG) 0x00000001)
/* alternative name for TBL_NOWAIT */
#define TBL_ASYNC			((ULONG) 0x00000001)
#define TBL_BATCH			((ULONG) 0x00000002)

/* FindRow */

#define DIR_BACKWARD		((ULONG) 0x00000001)

/* Table cursor states */

#define TBL_NOADVANCE		((ULONG) 0x00000001)

#define MAPI_IMAPITABLE_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(GetStatus)												\
		(THIS_	ULONG FAR *					lpulTableStatus,			\
				ULONG FAR *					lpulTableType) IPURE;		\
	MAPIMETHOD(SetColumns)												\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(QueryColumns)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray FAR *		lpPropTagArray) IPURE;		\
	MAPIMETHOD(GetRowCount)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG FAR *					lpulCount) IPURE;			\
	MAPIMETHOD(SeekRow)													\
		(THIS_	BOOKMARK					bkOrigin,					\
				LONG						lRowCount,					\
				LONG FAR *					lplRowsSought) IPURE;		\
	MAPIMETHOD(SeekRowApprox)											\
		(THIS_	ULONG						ulNumerator,				\
				ULONG						ulDenominator) IPURE;		\
	MAPIMETHOD(QueryPosition)											\
		(THIS_	ULONG FAR *					lpulRow,					\
				ULONG FAR *					lpulNumerator,				\
				ULONG FAR *					lpulDenominator) IPURE;		\
	MAPIMETHOD(FindRow)													\
		(THIS_	LPSRestriction				lpRestriction,				\
				BOOKMARK					bkOrigin,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(Restrict)												\
		(THIS_	LPSRestriction				lpRestriction,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CreateBookmark)											\
		(THIS_	BOOKMARK FAR *				lpbkPosition) IPURE;		\
	MAPIMETHOD(FreeBookmark)											\
		(THIS_	BOOKMARK					bkPosition) IPURE;			\
	MAPIMETHOD(SortTable)												\
		(THIS_	LPSSortOrderSet				lpSortCriteria,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(QuerySortOrder)											\
		(THIS_	LPSSortOrderSet FAR *		lppSortCriteria) IPURE;		\
	MAPIMETHOD(QueryRows)												\
		(THIS_	LONG						lRowCount,					\
				ULONG						ulFlags,					\
				LPSRowSet FAR *				lppRows) IPURE;				\
	MAPIMETHOD(Abort) (THIS) IPURE;										\
	MAPIMETHOD(ExpandRow)												\
		(THIS_	ULONG						cbInstanceKey,				\
				LPBYTE						pbInstanceKey,				\
				ULONG						ulRowCount,					\
				ULONG						ulFlags,					\
				LPSRowSet FAR *				lppRows,					\
				ULONG FAR *					lpulMoreRows) IPURE;		\
	MAPIMETHOD(CollapseRow)												\
		(THIS_	ULONG						cbInstanceKey,				\
				LPBYTE						pbInstanceKey,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulRowCount) IPURE;		\
	MAPIMETHOD(WaitForCompletion)										\
		(THIS_	ULONG						ulFlags,					\
				ULONG						ulTimeout,					\
				ULONG FAR *					lpulTableStatus) IPURE;		\
	MAPIMETHOD(GetCollapseState)										\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbInstanceKey,				\
				LPBYTE						lpbInstanceKey,				\
				ULONG FAR *					lpcbCollapseState,			\
				LPBYTE FAR *				lppbCollapseState) IPURE;	\
	MAPIMETHOD(SetCollapseState)										\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbCollapseState,			\
				LPBYTE						pbCollapseState,			\
				BOOKMARK FAR *				lpbkLocation) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPITable
DECLARE_MAPI_INTERFACE_(IMAPITable, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPITABLE_METHODS(PURE)
};

/* IProfSect Interface ----------------------------------------------------- */

/* Standard section for public profile properties */

#define PS_PROFILE_PROPERTIES_INIT \
{ 	0x98, 0x15, 0xAC, 0x08, 0xAA, 0xB0, 0x10, 0x1A, \
	0x8C, 0x93, 0x08, 0x00, 0x2B, 0x2A, 0x56, 0xC2  }


#define MAPI_IPROFSECT_METHODS(IPURE)

#undef		 INTERFACE
#define		 INTERFACE  IProfSect
DECLARE_MAPI_INTERFACE_(IProfSect, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IPROFSECT_METHODS(PURE)
};

/* IMAPIStatus Interface --------------------------------------------------- */

/* Values for PR_RESOURCE_TYPE, _METHODS, _FLAGS */

#define MAPI_STORE_PROVIDER		((ULONG) 33)	/* Message Store */
#define MAPI_AB					((ULONG) 34)	/* Address Book */
#define MAPI_AB_PROVIDER		((ULONG) 35)	/* Address Book Provider */
#define MAPI_TRANSPORT_PROVIDER	((ULONG) 36)	/* Transport Provider */
#define MAPI_SPOOLER			((ULONG) 37)	/* Message Spooler */
#define MAPI_PROFILE_PROVIDER	((ULONG) 38)	/* Profile Provider */
#define MAPI_SUBSYSTEM			((ULONG) 39)	/* Overall Subsystem Status */
#define MAPI_HOOK_PROVIDER		((ULONG) 40)	/* Spooler Hook */

#define STATUS_VALIDATE_STATE	((ULONG) 0x00000001)
#define STATUS_SETTINGS_DIALOG	((ULONG) 0x00000002)
#define STATUS_CHANGE_PASSWORD	((ULONG) 0x00000004)
#define STATUS_FLUSH_QUEUES		((ULONG) 0x00000008)

#define STATUS_DEFAULT_OUTBOUND	((ULONG) 0x00000001)
#define STATUS_DEFAULT_STORE	((ULONG) 0x00000002)
#define STATUS_PRIMARY_IDENTITY	((ULONG) 0x00000004)
#define STATUS_SIMPLE_STORE		((ULONG) 0x00000008)
#define STATUS_XP_PREFER_LAST	((ULONG) 0x00000010)
#define STATUS_NO_PRIMARY_IDENTITY ((ULONG) 0x00000020)
#define STATUS_NO_DEFAULT_STORE	((ULONG) 0x00000040)
#define STATUS_TEMP_SECTION		((ULONG) 0x00000080)
#define STATUS_OWN_STORE		((ULONG) 0x00000100)
/****** HOOK_INBOUND			((ULONG) 0x00000200) Defined in MAPIHOOK.H */
/****** HOOK_OUTBOUND			((ULONG) 0x00000400) Defined in MAPIHOOK.H */
#define STATUS_NEED_IPM_TREE	((ULONG) 0x00000800)
#define	STATUS_PRIMARY_STORE	((ULONG) 0x00001000)
#define	STATUS_SECONDARY_STORE	((ULONG) 0x00002000)


/*
 * PR_STATUS_CODE bit. Low 16 bits for common values; High 16 bits
 * for provider type-specific values. (DCR 304)
 */

#define	STATUS_AVAILABLE		((ULONG) 0x00000001)
#define STATUS_OFFLINE			((ULONG) 0x00000002)
#define STATUS_FAILURE			((ULONG) 0x00000004)

/* Transport values of PR_STATUS_CODE */

#define STATUS_INBOUND_ENABLED	((ULONG) 0x00010000)
#define STATUS_INBOUND_ACTIVE	((ULONG) 0x00020000)
#define STATUS_INBOUND_FLUSH	((ULONG) 0x00040000)
#define STATUS_OUTBOUND_ENABLED	((ULONG) 0x00100000)
#define STATUS_OUTBOUND_ACTIVE	((ULONG) 0x00200000)
#define STATUS_OUTBOUND_FLUSH	((ULONG) 0x00400000)
#define	STATUS_REMOTE_ACCESS	((ULONG) 0x00800000)

/* ValidateState flags */

#define SUPPRESS_UI					((ULONG) 0x00000001)
#define	REFRESH_XP_HEADER_CACHE		((ULONG) 0x00010000)
#define	PROCESS_XP_HEADER_CACHE 	((ULONG) 0x00020000)
#define	FORCE_XP_CONNECT			((ULONG) 0x00040000)
#define FORCE_XP_DISCONNECT			((ULONG) 0x00080000)
#define CONFIG_CHANGED				((ULONG) 0x00100000)
#define ABORT_XP_HEADER_OPERATION	((ULONG) 0x00200000)
#define SHOW_XP_SESSION_UI			((ULONG) 0x00400000)

/* SettingsDialog flags */

#define UI_READONLY		((ULONG) 0x00000001)

/* FlushQueues flags */

#define FLUSH_UPLOAD		((ULONG) 0x00000002)
#define FLUSH_DOWNLOAD		((ULONG) 0x00000004)
#define FLUSH_FORCE			((ULONG) 0x00000008)
#define FLUSH_NO_UI			((ULONG) 0x00000010)
#define FLUSH_ASYNC_OK		((ULONG) 0x00000020)

#define MAPI_IMAPISTATUS_METHODS(IPURE)									\
	MAPIMETHOD(ValidateState)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SettingsDialog)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ChangePassword)											\
		(THIS_	__in LPTSTR						lpOldPass,					\
				__in LPTSTR						lpNewPass,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(FlushQueues)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						cbTargetTransport,			\
				LPENTRYID					lpTargetTransport,			\
				ULONG						ulFlags) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIStatus
DECLARE_MAPI_INTERFACE_(IMAPIStatus, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPISTATUS_METHODS(PURE)
};

/* IMAPIContainer Interface ------------------------------------------------ */

/* Flags for OpenEntry() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
#define MAPI_BEST_ACCESS		((ULONG) 0x00000010)

/* GetContentsTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED			((ULONG) 0x00000040) below */

/* GetHierarchyTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */
#define CONVENIENT_DEPTH		((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* GetSearchCriteria */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */
#define SEARCH_RUNNING			((ULONG) 0x00000001)
#define SEARCH_REBUILD			((ULONG) 0x00000002)
#define SEARCH_RECURSIVE		((ULONG) 0x00000004)
#define SEARCH_FOREGROUND		((ULONG) 0x00000008)

/* SetSearchCriteria */
#define STOP_SEARCH				((ULONG) 0x00000001)
#define RESTART_SEARCH			((ULONG) 0x00000002)
#define RECURSIVE_SEARCH		((ULONG) 0x00000004)
#define SHALLOW_SEARCH			((ULONG) 0x00000008)
#define FOREGROUND_SEARCH		((ULONG) 0x00000010)
#define BACKGROUND_SEARCH		((ULONG) 0x00000020)

#define MAPI_IMAPICONTAINER_METHODS(IPURE)								\
	MAPIMETHOD(GetContentsTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(GetHierarchyTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(SetSearchCriteria)										\
		(THIS_	LPSRestriction				lpRestriction,				\
				LPENTRYLIST					lpContainerList,			\
				ULONG						ulSearchFlags) IPURE;		\
	MAPIMETHOD(GetSearchCriteria)										\
		(THIS_	ULONG						ulFlags,					\
				LPSRestriction FAR *		lppRestriction,				\
				LPENTRYLIST FAR *			lppContainerList,			\
				ULONG FAR *					lpulSearchState)IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIContainer
DECLARE_MAPI_INTERFACE_(IMAPIContainer, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
};

/* IABContainer Interface -------------------------------------------------- */

/*
 *	IABContainer PR_CONTAINER_FLAGS values
 *	If AB_UNMODIFIABLE and AB_MODIFIABLE are both set, it means the container
 *	doesn't know if it's modifiable or not, and the client should
 *  try to modify the contents but we won't expect it to work.
 *	If the AB_RECIPIENTS flag is set and neither AB_MODIFIABLE or AB_UNMODIFIABLE
 *  bits are set, it is an error.
 */

typedef struct _flaglist
{
	ULONG cFlags;
	ULONG ulFlag[MAPI_DIM];
} FlagList, FAR * LPFlagList;


/*
 *  Container flags
 */
#define AB_RECIPIENTS			((ULONG) 0x00000001)
#define AB_SUBCONTAINERS		((ULONG) 0x00000002)
#define AB_MODIFIABLE			((ULONG) 0x00000004)
#define AB_UNMODIFIABLE			((ULONG) 0x00000008)
#define AB_FIND_ON_OPEN			((ULONG) 0x00000010)
#define AB_NOT_DEFAULT			((ULONG) 0x00000020)

/* CreateEntry() */

#define CREATE_CHECK_DUP_STRICT	((ULONG) 0x00000001)
#define CREATE_CHECK_DUP_LOOSE	((ULONG) 0x00000002)
#define CREATE_REPLACE			((ULONG) 0x00000004)

/* ResolveNames() - ulFlags */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* ResolveNames() - rgulFlags */
#define MAPI_UNRESOLVED			((ULONG) 0x00000000)
#define MAPI_AMBIGUOUS			((ULONG) 0x00000001)
#define MAPI_RESOLVED			((ULONG) 0x00000002)


#define MAPI_IABCONTAINER_METHODS(IPURE)								\
	MAPIMETHOD(CreateEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulCreateFlags,				\
				LPMAPIPROP FAR	*			lppMAPIPropEntry) IPURE;	\
	MAPIMETHOD(CopyEntries)												\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteEntries)											\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ResolveNames)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags,					\
				LPADRLIST					lpAdrList,					\
				LPFlagList					lpFlagList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IABContainer
DECLARE_MAPI_INTERFACE_(IABContainer, IMAPIContainer)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
	MAPI_IABCONTAINER_METHODS(PURE)
};

/* IMailUser Interface ----------------------------------------------------- */

/*  Any call which can create a one-off entryID (i.e. MAPISupport::CreateOneOff
    or IAdrBook::CreateOneOff) can encode the value for PR_SEND_RICH_INFO by
	passing in the following flag in the ulFlags parameter.  Setting this flag
	indicates that PR_SEND_RICH_INFO will be FALSE.
*/
#define MAPI_SEND_NO_RICH_INFO		((ULONG) 0x00010000)




/* Values of PR_NDR_DIAG_CODE */

#define MAPI_DIAG(_code)	((LONG) _code)

#define MAPI_DIAG_NO_DIAGNOSTIC						MAPI_DIAG( -1 )
#define MAPI_DIAG_OR_NAME_UNRECOGNIZED				MAPI_DIAG( 0 )
#define MAPI_DIAG_OR_NAME_AMBIGUOUS					MAPI_DIAG( 1 )
#define MAPI_DIAG_MTS_CONGESTED						MAPI_DIAG( 2 )
#define MAPI_DIAG_LOOP_DETECTED						MAPI_DIAG( 3 )
#define MAPI_DIAG_RECIPIENT_UNAVAILABLE				MAPI_DIAG( 4 )
#define MAPI_DIAG_MAXIMUM_TIME_EXPIRED				MAPI_DIAG( 5 )
#define MAPI_DIAG_EITS_UNSUPPORTED					MAPI_DIAG( 6 )
#define MAPI_DIAG_CONTENT_TOO_LONG					MAPI_DIAG( 7 )
#define MAPI_DIAG_IMPRACTICAL_TO_CONVERT			MAPI_DIAG( 8 )
#define MAPI_DIAG_PROHIBITED_TO_CONVERT				MAPI_DIAG( 9 )
#define MAPI_DIAG_CONVERSION_UNSUBSCRIBED			MAPI_DIAG( 10 )
#define MAPI_DIAG_PARAMETERS_INVALID				MAPI_DIAG( 11 )
#define MAPI_DIAG_CONTENT_SYNTAX_IN_ERROR			MAPI_DIAG( 12 )
#define MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD			MAPI_DIAG( 13 )
#define MAPI_DIAG_NUMBER_CONSTRAINT_VIOLATD			MAPI_DIAG( 14 )
#define MAPI_DIAG_CONTENT_TYPE_UNSUPPORTED			MAPI_DIAG( 15 )
#define MAPI_DIAG_TOO_MANY_RECIPIENTS				MAPI_DIAG( 16 )
#define MAPI_DIAG_NO_BILATERAL_AGREEMENT			MAPI_DIAG( 17 )
#define MAPI_DIAG_CRITICAL_FUNC_UNSUPPORTED			MAPI_DIAG( 18 )
#define MAPI_DIAG_CONVERSION_LOSS_PROHIB			MAPI_DIAG( 19 )
#define MAPI_DIAG_LINE_TOO_LONG						MAPI_DIAG( 20 )
#define MAPI_DIAG_PAGE_TOO_LONG						MAPI_DIAG( 21 )
#define MAPI_DIAG_PICTORIAL_SYMBOL_LOST				MAPI_DIAG( 22 )
#define MAPI_DIAG_PUNCTUATION_SYMBOL_LOST			MAPI_DIAG( 23 )
#define MAPI_DIAG_ALPHABETIC_CHARACTER_LOST			MAPI_DIAG( 24 )
#define MAPI_DIAG_MULTIPLE_INFO_LOSSES				MAPI_DIAG( 25 )
#define MAPI_DIAG_REASSIGNMENT_PROHIBITED			MAPI_DIAG( 26 )
#define MAPI_DIAG_REDIRECTION_LOOP_DETECTED			MAPI_DIAG( 27 )
#define MAPI_DIAG_EXPANSION_PROHIBITED				MAPI_DIAG( 28 )
#define MAPI_DIAG_SUBMISSION_PROHIBITED				MAPI_DIAG( 29 )
#define MAPI_DIAG_EXPANSION_FAILED					MAPI_DIAG( 30 )
#define MAPI_DIAG_RENDITION_UNSUPPORTED				MAPI_DIAG( 31 )
#define MAPI_DIAG_MAIL_ADDRESS_INCORRECT			MAPI_DIAG( 32 )
#define MAPI_DIAG_MAIL_OFFICE_INCOR_OR_INVD			MAPI_DIAG( 33 )
#define MAPI_DIAG_MAIL_ADDRESS_INCOMPLETE			MAPI_DIAG( 34 )
#define MAPI_DIAG_MAIL_RECIPIENT_UNKNOWN			MAPI_DIAG( 35 )
#define MAPI_DIAG_MAIL_RECIPIENT_DECEASED			MAPI_DIAG( 36 )
#define MAPI_DIAG_MAIL_ORGANIZATION_EXPIRED			MAPI_DIAG( 37 )
#define MAPI_DIAG_MAIL_REFUSED						MAPI_DIAG( 38 )
#define MAPI_DIAG_MAIL_UNCLAIMED					MAPI_DIAG( 39 )
#define MAPI_DIAG_MAIL_RECIPIENT_MOVED				MAPI_DIAG( 40 )
#define MAPI_DIAG_MAIL_RECIPIENT_TRAVELLING			MAPI_DIAG( 41 )
#define MAPI_DIAG_MAIL_RECIPIENT_DEPARTED			MAPI_DIAG( 42 )
#define MAPI_DIAG_MAIL_NEW_ADDRESS_UNKNOWN			MAPI_DIAG( 43 )
#define MAPI_DIAG_MAIL_FORWARDING_UNWANTED			MAPI_DIAG( 44 )
#define MAPI_DIAG_MAIL_FORWARDING_PROHIB			MAPI_DIAG( 45 )
#define MAPI_DIAG_SECURE_MESSAGING_ERROR			MAPI_DIAG( 46 )
#define MAPI_DIAG_DOWNGRADING_IMPOSSIBLE			MAPI_DIAG( 47 )

/* Values of PR_DELIVERY_POINT (MH_T_DELIVERY_POINT) */

#define MAPI_MH_DP_PUBLIC_UA						((ULONG) 0)
#define MAPI_MH_DP_PRIVATE_UA						((ULONG) 1)
#define MAPI_MH_DP_MS								((ULONG) 2)
#define MAPI_MH_DP_ML								((ULONG) 3)
#define MAPI_MH_DP_PDAU								((ULONG) 4)
#define MAPI_MH_DP_PDS_PATRON						((ULONG) 5)
#define MAPI_MH_DP_OTHER_AU							((ULONG) 6)


#define MAPI_IMAILUSER_METHODS(IPURE)

#undef		 INTERFACE
#define		 INTERFACE  IMailUser
DECLARE_MAPI_INTERFACE_(IMailUser, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAILUSER_METHODS(PURE)
};

/* IDistList Interface ----------------------------------------------------- */

#define MAPI_IDISTLIST_METHODS(IPURE)									\
	MAPIMETHOD(CreateEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulCreateFlags,				\
				LPMAPIPROP FAR	*			lppMAPIPropEntry) IPURE;	\
	MAPIMETHOD(CopyEntries)												\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteEntries)											\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ResolveNames)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags,					\
				LPADRLIST					lpAdrList,					\
				LPFlagList					lpFlagList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IDistList
DECLARE_MAPI_INTERFACE_(IDistList, IMAPIContainer)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
	MAPI_IDISTLIST_METHODS(PURE)
};

/* IMAPIFolder Interface --------------------------------------------------- */

/* IMAPIFolder folder type (enum) */

#define FOLDER_ROOT				((ULONG) 0x00000000)
#define FOLDER_GENERIC			((ULONG) 0x00000001)
#define FOLDER_SEARCH			((ULONG) 0x00000002)

/* CreateMessage */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED			((ULONG) 0x00000040) below */

/* CopyMessages */

#define MESSAGE_MOVE			((ULONG) 0x00000001)
#define MESSAGE_DIALOG			((ULONG) 0x00000002)
/****** MAPI_DECLINE_OK			((ULONG) 0x00000004) above */

/* CreateFolder */

#define OPEN_IF_EXISTS			((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* DeleteFolder */

#define DEL_MESSAGES			((ULONG) 0x00000001)
#define FOLDER_DIALOG			((ULONG) 0x00000002)
#define DEL_FOLDERS				((ULONG) 0x00000004)

/* EmptyFolder */
#define DEL_ASSOCIATED			((ULONG) 0x00000008)

/* CopyFolder */

#define FOLDER_MOVE				((ULONG) 0x00000001)
/****** FOLDER_DIALOG			((ULONG) 0x00000002) above */
/****** MAPI_DECLINE_OK			((ULONG) 0x00000004) above */
#define COPY_SUBFOLDERS			((ULONG) 0x00000010)
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */


/* SetReadFlags */

/****** SUPPRESS_RECEIPT		((ULONG) 0x00000001) below */
/****** FOLDER_DIALOG			((ULONG) 0x00000002) above */
/****** CLEAR_READ_FLAG			((ULONG) 0x00000004) below */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/******	GENERATE_RECEIPT_ONLY	((ULONG) 0x00000010) below */
/****** CLEAR_RN_PENDING		((ULONG) 0x00000020) below */
/****** CLEAR_NRN_PENDING		((ULONG) 0x00000040) below */


/* GetMessageStatus */

#define MSGSTATUS_HIGHLIGHTED	((ULONG) 0x00000001)
#define MSGSTATUS_TAGGED		((ULONG) 0x00000002)
#define MSGSTATUS_HIDDEN		((ULONG) 0x00000004)
#define MSGSTATUS_DELMARKED		((ULONG) 0x00000008)

/* Bits for remote message status */

#define	MSGSTATUS_REMOTE_DOWNLOAD	((ULONG) 0x00001000)
#define	MSGSTATUS_REMOTE_DELETE		((ULONG) 0x00002000)

/* SaveContentsSort */

#define RECURSIVE_SORT			((ULONG) 0x00000002)

/* PR_STATUS property */

#define FLDSTATUS_HIGHLIGHTED	((ULONG) 0x00000001)
#define FLDSTATUS_TAGGED		((ULONG) 0x00000002)
#define FLDSTATUS_HIDDEN		((ULONG) 0x00000004)
#define FLDSTATUS_DELMARKED		((ULONG) 0x00000008)

#define MAPI_IMAPIFOLDER_METHODS(IPURE)									\
	MAPIMETHOD(CreateMessage)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPMESSAGE FAR *				lppMessage) IPURE;			\
	MAPIMETHOD(CopyMessages)											\
		(THIS_	LPENTRYLIST					lpMsgList,					\
			   	LPCIID						lpInterface,				\
				LPVOID						lpDestFolder,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteMessages)											\
		(THIS_	LPENTRYLIST					lpMsgList,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CreateFolder)											\
		(THIS_	ULONG						ulFolderType,				\
				__in LPTSTR					lpszFolderName,				\
				__in LPTSTR					lpszFolderComment,			\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPMAPIFOLDER FAR *			lppFolder) IPURE;			\
	MAPIMETHOD(CopyFolder)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
			   	LPCIID						lpInterface,				\
				LPVOID						lpDestFolder,				\
				__in LPTSTR					lpszNewFolderName,			\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteFolder)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetReadFlags)											\
		(THIS_	LPENTRYLIST					lpMsgList,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetMessageStatus)										\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulMessageStatus) IPURE;	\
	MAPIMETHOD(SetMessageStatus)										\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulNewStatus,				\
				ULONG						ulNewStatusMask,			\
				ULONG FAR *					lpulOldStatus) IPURE;		\
	MAPIMETHOD(SaveContentsSort)										\
		(THIS_	LPSSortOrderSet				lpSortCriteria,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(EmptyFolder)												\
		(THIS_	ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIFolder
DECLARE_MAPI_INTERFACE_(IMAPIFolder, IMAPIContainer)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
	MAPI_IMAPIFOLDER_METHODS(PURE)
};

/* IMsgStore Interface ----------------------------------------------------- */

/*  PR_STORE_SUPPORT_MASK bits */
#define STORE_ENTRYID_UNIQUE	((ULONG) 0x00000001)
#define STORE_READONLY			((ULONG) 0x00000002)
#define STORE_SEARCH_OK			((ULONG) 0x00000004)
#define STORE_MODIFY_OK			((ULONG) 0x00000008)
#define STORE_CREATE_OK			((ULONG) 0x00000010)
#define STORE_ATTACH_OK			((ULONG) 0x00000020)
#define STORE_OLE_OK			((ULONG) 0x00000040)
#define STORE_SUBMIT_OK			((ULONG) 0x00000080)
#define STORE_NOTIFY_OK			((ULONG) 0x00000100)
#define STORE_MV_PROPS_OK		((ULONG) 0x00000200)
#define STORE_CATEGORIZE_OK		((ULONG) 0x00000400)
#define STORE_RTF_OK			((ULONG) 0x00000800)
#define STORE_RESTRICTION_OK	((ULONG) 0x00001000)
#define STORE_SORT_OK			((ULONG) 0x00002000)
#define	STORE_PUBLIC_FOLDERS	((ULONG) 0x00004000)
#define	STORE_UNCOMPRESSED_RTF	((ULONG) 0x00008000)

/* PR_STORE_STATE bits, try not to collide with PR_STORE_SUPPORT_MASK */

#define STORE_HAS_SEARCHES		((ULONG) 0x01000000)


/* OpenEntry() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_BEST_ACCESS		((ULONG) 0x00000010) above */

/* SetReceiveFolder() */

/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetReceiveFolder() */

/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetReceiveFolderTable() */

/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* StoreLogoff() */

#define	LOGOFF_NO_WAIT			((ULONG) 0x00000001)
#define	LOGOFF_ORDERLY			((ULONG) 0x00000002)
#define	LOGOFF_PURGE			((ULONG) 0x00000004)
#define LOGOFF_ABORT			((ULONG) 0x00000008)
#define LOGOFF_QUIET			((ULONG) 0x00000010)

#define LOGOFF_COMPLETE			((ULONG) 0x00010000)
#define	LOGOFF_INBOUND			((ULONG) 0x00020000)
#define LOGOFF_OUTBOUND			((ULONG) 0x00040000)
#define LOGOFF_OUTBOUND_QUEUE	((ULONG) 0x00080000)

/* SetLockState() */

#define MSG_LOCKED				((ULONG) 0x00000001)
#define MSG_UNLOCKED			((ULONG) 0x00000000)

/* Flag bits for PR_VALID_FOLDER_MASK */

#define	FOLDER_IPM_SUBTREE_VALID		((ULONG) 0x00000001)
#define	FOLDER_IPM_INBOX_VALID			((ULONG) 0x00000002)
#define	FOLDER_IPM_OUTBOX_VALID			((ULONG) 0x00000004)
#define	FOLDER_IPM_WASTEBASKET_VALID	((ULONG) 0x00000008)
#define	FOLDER_IPM_SENTMAIL_VALID		((ULONG) 0x00000010)
#define	FOLDER_VIEWS_VALID				((ULONG) 0x00000020)
#define	FOLDER_COMMON_VIEWS_VALID		((ULONG) 0x00000040)
#define	FOLDER_FINDER_VALID				((ULONG) 0x00000080)

#define MAPI_IMSGSTORE_METHODS(IPURE)									\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(SetReceiveFolder)										\
		(THIS_	__in LPTSTR						lpszMessageClass,			\
				ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetReceiveFolder)										\
		(THIS_	__in LPTSTR						lpszMessageClass,			\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID,					\
				__in LPTSTR FAR *				lppszExplicitClass) IPURE;	\
	MAPIMETHOD(GetReceiveFolderTable)									\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(StoreLogoff)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(AbortSubmit)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetOutgoingQueue)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(SetLockState)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				ULONG						ulLockState) IPURE;			\
	MAPIMETHOD(FinishedMsg)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(NotifyNewMail)											\
		(THIS_	LPNOTIFICATION				lpNotification) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMsgStore
DECLARE_MAPI_INTERFACE_(IMsgStore, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMSGSTORE_METHODS(PURE)
};

/* IMessage Interface ------------------------------------------------------ */

/* SubmitMessage */

#define FORCE_SUBMIT				((ULONG) 0x00000001)

/* Flags defined in PR_MESSAGE_FLAGS */

#define MSGFLAG_READ			((ULONG) 0x00000001)
#define MSGFLAG_UNMODIFIED		((ULONG) 0x00000002)
#define MSGFLAG_SUBMIT			((ULONG) 0x00000004)
#define MSGFLAG_UNSENT			((ULONG) 0x00000008)
#define MSGFLAG_HASATTACH		((ULONG) 0x00000010)
#define MSGFLAG_FROMME			((ULONG) 0x00000020)
#define MSGFLAG_ASSOCIATED		((ULONG) 0x00000040)
#define MSGFLAG_RESEND			((ULONG) 0x00000080)
#define MSGFLAG_RN_PENDING		((ULONG) 0x00000100)
#define MSGFLAG_NRN_PENDING		((ULONG) 0x00000200)

/* Flags defined in PR_SUBMIT_FLAGS */

#define SUBMITFLAG_LOCKED		((ULONG) 0x00000001)
#define SUBMITFLAG_PREPROCESS	((ULONG) 0x00000002)

/* GetAttachmentTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetRecipientTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* ModifyRecipients */

/* ((ULONG) 0x00000001 is not a valid flag on ModifyRecipients. */
#define MODRECIP_ADD			((ULONG) 0x00000002)
#define MODRECIP_MODIFY			((ULONG) 0x00000004)
#define MODRECIP_REMOVE			((ULONG) 0x00000008)

/* SetReadFlag */

#define SUPPRESS_RECEIPT		((ULONG) 0x00000001)
#define CLEAR_READ_FLAG			((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
#define	GENERATE_RECEIPT_ONLY	((ULONG) 0x00000010)
#define CLEAR_RN_PENDING		((ULONG) 0x00000020)
#define CLEAR_NRN_PENDING		((ULONG) 0x00000040)

/* DeleteAttach */

#define ATTACH_DIALOG			((ULONG) 0x00000001)

/* PR_SECURITY values */
#define SECURITY_SIGNED			((ULONG) 0x00000001)
#define SECURITY_ENCRYPTED		((ULONG) 0x00000002)

/* PR_PRIORITY values */
#define PRIO_URGENT				((long)  1)
#define PRIO_NORMAL				((long)  0)
#define PRIO_NONURGENT			((long) -1)

/* PR_SENSITIVITY values */
#define SENSITIVITY_NONE					((ULONG) 0x00000000)
#define SENSITIVITY_PERSONAL				((ULONG) 0x00000001)
#define SENSITIVITY_PRIVATE					((ULONG) 0x00000002)
#define SENSITIVITY_COMPANY_CONFIDENTIAL	((ULONG) 0x00000003)

/* PR_IMPORTANCE values */
#define IMPORTANCE_LOW			((long) 0)
#define IMPORTANCE_NORMAL		((long) 1)
#define IMPORTANCE_HIGH			((long) 2)

#define MAPI_IMESSAGE_METHODS(IPURE)									\
	MAPIMETHOD(GetAttachmentTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenAttach)												\
		(THIS_	ULONG						ulAttachmentNum,			\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPATTACH FAR *				lppAttach) IPURE;			\
	MAPIMETHOD(CreateAttach)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulAttachmentNum,			\
				LPATTACH FAR *				lppAttach) IPURE;			\
	MAPIMETHOD(DeleteAttach)											\
		(THIS_	ULONG						ulAttachmentNum,			\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetRecipientTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(ModifyRecipients)										\
		(THIS_	ULONG						ulFlags,					\
				LPADRLIST					lpMods) IPURE;				\
	MAPIMETHOD(SubmitMessage)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetReadFlag)												\
		(THIS_	ULONG						ulFlags) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMessage
DECLARE_MAPI_INTERFACE_(IMessage, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMESSAGE_METHODS(PURE)
};

/* IAttach Interface ------------------------------------------------------- */

/* IAttach attachment methods: PR_ATTACH_METHOD values */

#define NO_ATTACHMENT			((ULONG) 0x00000000)
#define ATTACH_BY_VALUE			((ULONG) 0x00000001)
#define ATTACH_BY_REFERENCE		((ULONG) 0x00000002)
#define ATTACH_BY_REF_RESOLVE	((ULONG) 0x00000003)
#define ATTACH_BY_REF_ONLY		((ULONG) 0x00000004)
#define ATTACH_EMBEDDED_MSG		((ULONG) 0x00000005)
#define ATTACH_OLE				((ULONG) 0x00000006)

#define MAPI_IATTACH_METHODS(IPURE)

#undef		 INTERFACE
#define		 INTERFACE  IAttach
DECLARE_MAPI_INTERFACE_(IAttach, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IATTACH_METHODS(PURE)
};

/* --------------------------------- */
/* Address Book interface definition */

/* ADRPARM ulFlags - top 4 bits used for versioning */

#define GET_ADRPARM_VERSION(ulFlags)  (((ULONG)ulFlags) & 0xF0000000)
#define SET_ADRPARM_VERSION(ulFlags, ulVersion)  (((ULONG)ulVersion) | (((ULONG)ulFlags) & 0x0FFFFFFF))

/*  Current versions of ADRPARM  */
#define ADRPARM_HELP_CTX		((ULONG) 0x00000000)


/*  ulFlags   - bit fields */
#define DIALOG_MODAL			((ULONG) 0x00000001)
#define DIALOG_SDI				((ULONG) 0x00000002)
#define DIALOG_OPTIONS			((ULONG) 0x00000004)
#define ADDRESS_ONE				((ULONG) 0x00000008)
#define AB_SELECTONLY			((ULONG) 0x00000010)
#define AB_RESOLVE				((ULONG) 0x00000020)

/* --------------------------------- */
/*  PR_DISPLAY_TYPEs                 */
/*
 *  These standard display types are
 *  by default handled by MAPI.
 *  They have default icons associated
 *  with them.
 */

/*  For address book contents tables */
#define DT_MAILUSER			((ULONG) 0x00000000)
#define DT_DISTLIST			((ULONG) 0x00000001)
#define DT_FORUM			((ULONG) 0x00000002)
#define DT_AGENT			((ULONG) 0x00000003)
#define DT_ORGANIZATION		((ULONG) 0x00000004)
#define DT_PRIVATE_DISTLIST	((ULONG) 0x00000005)
#define DT_REMOTE_MAILUSER	((ULONG) 0x00000006)

/*  For address book hierarchy tables */
#define DT_MODIFIABLE		((ULONG) 0x00010000)
#define DT_GLOBAL			((ULONG) 0x00020000)
#define DT_LOCAL			((ULONG) 0x00030000)
#define DT_WAN				((ULONG) 0x00040000)
#define DT_NOT_SPECIFIC		((ULONG) 0x00050000)

/*  For folder hierarchy tables */
#define DT_FOLDER			((ULONG) 0x01000000)
#define DT_FOLDER_LINK		((ULONG) 0x02000000)
#define DT_FOLDER_SPECIAL	((ULONG) 0x04000000)

/*  Accelerator callback for DIALOG_SDI form of AB UI */
typedef BOOL (STDMETHODCALLTYPE ACCELERATEABSDI)(ULONG ulUIParam,
												LPVOID lpvmsg);
typedef ACCELERATEABSDI FAR * LPFNABSDI;

/*  Callback to application telling it that the DIALOG_SDI form of the */
/*  AB UI has been dismissed.  This is so that the above LPFNABSDI     */
/*  function doesn't keep being called.                                */
typedef void (STDMETHODCALLTYPE DISMISSMODELESS)(ULONG ulUIParam,
												LPVOID lpvContext);
typedef DISMISSMODELESS FAR * LPFNDISMISS;

/*
 * Prototype for the client function hooked to an optional button on
 * the address book dialog
 */

typedef SCODE (STDMETHODCALLTYPE FAR * LPFNBUTTON)(
	ULONG				ulUIParam,
	LPVOID				lpvContext,
	ULONG				cbEntryID,
	LPENTRYID			lpSelection,
	ULONG				ulFlags
);


/* Parameters for the address book dialog */
typedef struct _ADRPARM
{
	ULONG			cbABContEntryID;
	LPENTRYID		lpABContEntryID;
	ULONG			ulFlags;

	LPVOID			lpReserved;
	ULONG			ulHelpContext;
	LPTSTR			lpszHelpFileName;

	LPFNABSDI		lpfnABSDI;
	LPFNDISMISS		lpfnDismiss;
	LPVOID			lpvDismissContext;
	LPTSTR			lpszCaption;
	LPTSTR			lpszNewEntryTitle;
	LPTSTR			lpszDestWellsTitle;
	ULONG			cDestFields;
	ULONG			nDestFieldFocus;
	LPTSTR FAR *	lppszDestTitles;
	ULONG FAR *		lpulDestComps;
	LPSRestriction	lpContRestriction;
	LPSRestriction	lpHierRestriction;
} ADRPARM, FAR * LPADRPARM;


/* ------------ */
/* Random flags */

/* Flag for deferred error */
#define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008)

/* Flag for creating and using Folder Associated Information Messages */
#define MAPI_ASSOCIATED			((ULONG) 0x00000040)

/* Flags for OpenMessageStore() */

#define MDB_NO_DIALOG			((ULONG) 0x00000001)
#define MDB_WRITE				((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) above */
/****** MAPI_BEST_ACCESS		((ULONG) 0x00000010) above */
#define	MDB_TEMPORARY			((ULONG) 0x00000020)
#define MDB_NO_MAIL				((ULONG) 0x00000080)

/* Flags for OpenAddressBook */

#define AB_NO_DIALOG			((ULONG) 0x00000001)

/* IMAPIControl Interface -------------------------------------------------- */

/* Interface used in controls (particularly the button) defined by */
/* Display Tables. */

/*  Flags for GetState */

#define  MAPI_ENABLED		((ULONG) 0x00000000)
#define  MAPI_DISABLED		((ULONG) 0x00000001)

#define MAPI_IMAPICONTROL_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Activate)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						ulUIParam) IPURE;			\
	MAPIMETHOD(GetState)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG FAR *					lpulState) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIControl
DECLARE_MAPI_INTERFACE_(IMAPIControl, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPICONTROL_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPIControl, LPMAPICONTROL);

/* Display Tables ---------------------------------------------------------- */

/* Flags used in display tables - that is, PR_CONTROL_FLAGS */

#define DT_MULTILINE		((ULONG) 0x00000001)
#define DT_EDITABLE			((ULONG) 0x00000002)
#define DT_REQUIRED			((ULONG) 0x00000004)
#define DT_SET_IMMEDIATE	((ULONG) 0x00000008)
#define DT_PASSWORD_EDIT	((ULONG) 0x00000010)
#define DT_ACCEPT_DBCS		((ULONG) 0x00000020)
#define DT_SET_SELECTION	((ULONG) 0x00000040)

/* Display Table structures */

#define DTCT_LABEL			((ULONG) 0x00000000)
#define DTCT_EDIT			((ULONG) 0x00000001)
#define DTCT_LBX			((ULONG) 0x00000002)
#define DTCT_COMBOBOX		((ULONG) 0x00000003)
#define DTCT_DDLBX			((ULONG) 0x00000004)
#define DTCT_CHECKBOX		((ULONG) 0x00000005)
#define DTCT_GROUPBOX		((ULONG) 0x00000006)
#define DTCT_BUTTON			((ULONG) 0x00000007)
#define DTCT_PAGE			((ULONG) 0x00000008)
#define DTCT_RADIOBUTTON	((ULONG) 0x00000009)
#define DTCT_MVLISTBOX		((ULONG) 0x0000000B)
#define DTCT_MVDDLBX		((ULONG) 0x0000000C)

/* Labels */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLLABEL
{
	ULONG ulbLpszLabelName;
	ULONG ulFlags;
} DTBLLABEL, FAR * LPDTBLLABEL;
#define SizedDtblLabel(n,u) \
struct _DTBLLABEL_ ## u \
{ \
	DTBLLABEL	dtbllabel; \
	TCHAR		lpszLabelName[n]; \
} u


/*  Simple Text Edits  */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLEDIT
{
	ULONG ulbLpszCharsAllowed;
	ULONG ulFlags;
	ULONG ulNumCharsAllowed;
	ULONG ulPropTag;
} DTBLEDIT, FAR * LPDTBLEDIT;
#define SizedDtblEdit(n,u) \
struct _DTBLEDIT_ ## u \
{ \
	DTBLEDIT	dtbledit; \
	TCHAR		lpszCharsAllowed[n]; \
} u

/*  List Box  */
/* Valid ulFlags:
 */
#define MAPI_NO_HBAR		((ULONG) 0x00000001)
#define MAPI_NO_VBAR		((ULONG) 0x00000002)

typedef struct _DTBLLBX
{
	ULONG ulFlags;
	ULONG ulPRSetProperty;
	ULONG ulPRTableName;
} DTBLLBX, FAR * LPDTBLLBX;


/*  Combo Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCOMBOBOX
{
	ULONG ulbLpszCharsAllowed;
	ULONG ulFlags;
	ULONG ulNumCharsAllowed;
	ULONG ulPRPropertyName;
	ULONG ulPRTableName;
} DTBLCOMBOBOX, FAR * LPDTBLCOMBOBOX;
#define SizedDtblComboBox(n,u) \
struct _DTBLCOMBOBOX_ ## u \
{ \
	DTBLCOMBOBOX	dtblcombobox; \
	TCHAR			lpszCharsAllowed[n]; \
} u


/*  Drop Down   */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLDDLBX
{
	ULONG ulFlags;
	ULONG ulPRDisplayProperty;
	ULONG ulPRSetProperty;
	ULONG ulPRTableName;
} DTBLDDLBX, FAR * LPDTBLDDLBX;


/*  Check Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCHECKBOX
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulPRPropertyName;
} DTBLCHECKBOX, FAR * LPDTBLCHECKBOX;
#define SizedDtblCheckBox(n,u) \
struct _DTBLCHECKBOX_ ## u \
{ \
	DTBLCHECKBOX	dtblcheckbox; \
	TCHAR		lpszLabel[n]; \
} u



/*  Group Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLGROUPBOX
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
} DTBLGROUPBOX, FAR * LPDTBLGROUPBOX;
#define SizedDtblGroupBox(n,u) \
struct _DTBLGROUPBOX_ ## u \
{ \
	DTBLGROUPBOX	dtblgroupbox; \
	TCHAR			lpszLabel[n]; \
} u

/*  Button control   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLBUTTON
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulPRControl;
} DTBLBUTTON, FAR * LPDTBLBUTTON;
#define SizedDtblButton(n,u) \
struct _DTBLBUTTON_ ## u \
{ \
	DTBLBUTTON	dtblbutton; \
	TCHAR		lpszLabel[n]; \
} u

/*  Pages   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLPAGE
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulbLpszComponent;
	ULONG ulContext;
} DTBLPAGE, FAR * LPDTBLPAGE;
#define SizedDtblPage(n,n1,u) \
struct _DTBLPAGE_ ## u \
{ \
	DTBLPAGE	dtblpage; \
	TCHAR		lpszLabel[n]; \
	TCHAR		lpszComponent[n1]; \
} u

/*  Radio button   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLRADIOBUTTON
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulcButtons;
	ULONG ulPropTag;
	long lReturnValue;
} DTBLRADIOBUTTON, FAR * LPDTBLRADIOBUTTON;
#define SizedDtblRadioButton(n,u) \
struct _DTBLRADIOBUTTON_ ## u \
{ \
	DTBLRADIOBUTTON dtblradiobutton; \
	TCHAR			lpszLabel[n]; \
} u


/*  MultiValued listbox */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVLISTBOX
{
	ULONG ulFlags;
	ULONG ulMVPropTag;
} DTBLMVLISTBOX, FAR * LPDTBLMVLISTBOX;


/*  MultiValued dropdown */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVDDLBX
{
	ULONG ulFlags;
	ULONG ulMVPropTag;
} DTBLMVDDLBX, FAR * LPDTBLMVDDLBX;





/* IProviderAdmin Interface ---------------------------------------------- */

/* Flags for ConfigureMsgService */

#define UI_SERVICE					0x00000002
#define SERVICE_UI_ALWAYS  			0x00000002		/* Duplicate UI_SERVICE for consistency and compatibility */
#define SERVICE_UI_ALLOWED 			0x00000010
#define UI_CURRENT_PROVIDER_FIRST	0x00000004
/* MSG_SERVICE_UI_READ_ONLY 		0x00000008 - in MAPISPI.H */

/* GetProviderTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define MAPI_IPROVIDERADMIN_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetProviderTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(CreateProvider)											\
		(THIS_	__in LPTSTR						lpszProvider,				\
				ULONG						cValues,					\
				LPSPropValue				lpProps,					\
				ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				MAPIUID FAR *				lpUID) IPURE;				\
	MAPIMETHOD(DeleteProvider)											\
		(THIS_	LPMAPIUID					lpUID) IPURE;				\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUID,						\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfSect) IPURE;			\


#undef 		 INTERFACE
#define 	 INTERFACE	IProviderAdmin
DECLARE_MAPI_INTERFACE_(IProviderAdmin, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IPROVIDERADMIN_METHODS(PURE)
};



#ifdef	__cplusplus
}		/*	extern "C" */
#endif

#endif /* MAPIDEFS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPIOID.h ===
/*
 *  M A P I O I D . H
 *
 *  MAPI OID definition header file
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPIOID_
#define _MAPIOID_

/*
 *  MAPI 1.0 Object Identifiers (OID's)
 *
 *  All MAPI 1.0 OIDs are prefixed by the segment
 *
 *      {iso(1) ansi(2) usa(840) microsoft(113556) mapi(3)}
 *
 *  All MAPI 1.0 tags are also include the addistion segment
 *
 *      {tags(10)}
 *
 *  All MAPI 1.0 encodings are also include the addistion segment
 *
 *      {encodeings(11)}
 *
 *  The set of defined tags are as follows
 *
 *   {{mapiprefix} {tags} {tnef(1)}}                        MAPI 1.0 TNEF encapsulation tag
 *
 *   {{mapiprefix} {tags} {ole(3)}}                         MAPI 1.0 OLE prefix
 *   {{mapiprefix} {tags} {ole(3)} {v1(1)}}                 MAPI 1.0 OLE 1.0 prefix
 *   {{mapiprefix} {tags} {ole(3)} {v1(1)} {storage(1)}}    MAPI 1.0 OLE 1.0 OLESTREAM
 *   {{mapiprefix} {tags} {ole(3)} {v2(2)}}                 MAPI 1.0 OLE 2.0 prefix
 *   {{mapiprefix} {tags} {ole(3)} {v2(2)} {storage(1)}}    MAPI 1.0 OLE 2.0 IStorage
 *
 *  The set of defined encodings are as follows
 *
 *   {{mapiprefix} {encodings} {MacBinary(1)}}              MAPI 1.0 MacBinary
 */

#define OID_TAG         0x0A
#define OID_ENCODING    0x0B

#define DEFINE_OID_1(name, b0, b1) \
    EXTERN_C const BYTE FAR * name

#define DEFINE_OID_2(name, b0, b1, b2) \
    EXTERN_C const BYTE FAR * name

#define DEFINE_OID_3(name, b0, b1, b2, b3) \
    EXTERN_C const BYTE FAR * name

#define DEFINE_OID_4(name, b0, b1, b2, b3, b4) \
    EXTERN_C const BYTE FAR * name

#define CB_OID_1        9
#define CB_OID_2        10
#define CB_OID_3        11
#define CB_OID_4        12

#ifdef INITOID
#include <initoid.h>
#endif

#ifdef  USES_OID_TNEF
DEFINE_OID_1(OID_TNEF, OID_TAG, 0x01);
#define CB_OID_TNEF CB_OID_1
#endif

#ifdef  USES_OID_OLE
DEFINE_OID_1(OID_OLE, OID_TAG, 0x03);
#define CB_OID_OLE CB_OID_1
#endif

#ifdef  USES_OID_OLE1
DEFINE_OID_2(OID_OLE1, OID_TAG, 0x03, 0x01);
#define CB_OID_OLE1 CB_OID_2
#endif

#ifdef  USES_OID_OLE1_STORAGE
DEFINE_OID_3(OID_OLE1_STORAGE, OID_TAG, 0x03, 0x01, 0x01);
#define CB_OID_OLE1_STORAGE CB_OID_3
#endif

#ifdef  USES_OID_OLE2
DEFINE_OID_2(OID_OLE2, OID_TAG, 0x03, 0x02);
#define CB_OID_OLE2 CB_OID_2
#endif

#ifdef  USES_OID_OLE2_STORAGE
DEFINE_OID_3(OID_OLE2_STORAGE, OID_TAG, 0x03, 0x02, 0x01);
#define CB_OID_OLE2_STORAGE CB_OID_3
#endif

#ifdef  USES_OID_MAC_BINARY
DEFINE_OID_1(OID_MAC_BINARY, OID_ENCODING, 0x01);
#define CB_OID_MAC_BINARY CB_OID_1
#endif

#ifdef  USES_OID_MIMETAG
DEFINE_OID_1(OID_MIMETAG, OID_TAG, 0x04);
#define CB_OID_MIMETAG CB_OID_1
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPISPI.h ===
/*
 *	M A P I S P I . H
 *
 *  Defines the calls and structures exchanged between MAPI or the spooler
 *  and the MAPI service providers
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPISPI_H
#define MAPISPI_H
#if _MSC_VER > 1000
#pragma once
#endif

/* Include common MAPI header files if they haven't been already. */
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPICODE_H
#include <mapicode.h>
#endif
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPITAGS_H
#include <mapitags.h>
#endif

#if defined (WIN16) || defined (DOS) || defined (DOS16)
#include <storage.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*	The MAPI SPI has a version number.  MAPIX.DLL knows and supports
 *	one or more versions of the SPI.  Each provider supports one or
 *	more versions of the SPI.  Checks are performed in both MAPIX.DLL
 *	and in the provider to ensure that they agree to use exactly one
 *	version of the MAPI SPI.
 *
 *	The SPI version number is composed of a major (8-bit) version,
 *	minor (8-bit) version, and micro (16-bit) version.  The first
 *	retail ship of MAPI 1.0 is expected to be version 1.0.0.
 *	The major version number changes rarely.
 *	The minor version number changes opon each retail ship of
 *	MAPI if the SPI has been modified.
 *	The micro version number changes internally at Microsoft
 *	during development of MAPI.
 *
 *	The version of the SPI documented by this set of header files
 *	is ALWAYS known as "CURRENT_SPI_VERSION".  If you write a
 *	service provider, and get a new set of header files, and update
 *	your code to the new interface, you'll be at the "current" version.
 */
#define	CURRENT_SPI_VERSION	0x00010010L

/*	Here are some well-known SPI version numbers:
 *	(These will eventually be useful for provider-writers who
 *	might choose to make provider DLLs that support more than
 *	one version of the MAPI SPI.
 */
#define	PDK1_SPI_VERSION	0x00010000L	/* 0.1.0  MAPI PDK1 Spring 1993 */

#define	PDK2_SPI_VERSION	0x00010008L /* 0.1.8  MAPI PDK2 Spring 1994 */

#define PDK3_SPI_VERSION	0x00010010L /* 0.1.16 MAPI PDK3 Fall 1994   */

/*
 * Forward declaration of interface pointers specific to the service
 * provider interface.
 */
DECLARE_MAPI_INTERFACE_PTR(IMAPISupport, LPMAPISUP);

/* IMAPISupport Interface -------------------------------------------------- */

/* Notification key structure for the MAPI notification engine */

typedef struct
{
	ULONG		cb;				/* How big the key is */
	BYTE		ab[MAPI_DIM];	/* Key contents */
} NOTIFKEY, FAR * LPNOTIFKEY;

#define CbNewNOTIFKEY(_cb)		(offsetof(NOTIFKEY,ab) + (_cb))
#define CbNOTIFKEY(_lpkey)		(offsetof(NOTIFKEY,ab) + (_lpkey)->cb)
#define SizedNOTIFKEY(_cb, _name) \
	struct _NOTIFKEY_ ## _name \
{ \
	ULONG		cb; \
	BYTE		ab[_cb]; \
} _name


/* For Subscribe() */

#define NOTIFY_SYNC				((ULONG) 0x40000000)

/* For Notify() */

#define NOTIFY_CANCELED			((ULONG) 0x80000000)


/* From the Notification Callback function (well, this is really a ulResult) */

#define CALLBACK_DISCONTINUE	((ULONG) 0x80000000)

/* For Transport's SpoolerNotify() */

#define NOTIFY_NEWMAIL			((ULONG) 0x00000001)
#define NOTIFY_READYTOSEND		((ULONG) 0x00000002)
#define NOTIFY_SENTDEFERRED		((ULONG) 0x00000004)
#define NOTIFY_CRITSEC			((ULONG) 0x00001000)
#define NOTIFY_NONCRIT			((ULONG) 0x00002000)
#define NOTIFY_CONFIG_CHANGE	((ULONG) 0x00004000)
#define NOTIFY_CRITICAL_ERROR	((ULONG) 0x10000000)

/* For Message Store's SpoolerNotify() */

#define NOTIFY_NEWMAIL_RECEIVED	((ULONG) 0x20000000)

/* For ModifyStatusRow() */

#define	STATUSROW_UPDATE		((ULONG) 0x10000000)

/* For IStorageFromStream() */

#define STGSTRM_RESET			((ULONG) 0x00000000)
#define STGSTRM_CURRENT			((ULONG) 0x10000000)
#define STGSTRM_MODIFY			((ULONG) 0x00000002)
#define STGSTRM_CREATE			((ULONG) 0x00001000)

/* For GetOneOffTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/* For CreateOneOff() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO	((ULONG) 0x00010000) */

/* For ReadReceipt() */
#define MAPI_NON_READ			((ULONG) 0x00000001)

/* For DoConfigPropSheet() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/* Preprocessor calls: */

/* PreprocessMessage, first ordinal in RegisterPreprocessor(). */

typedef HRESULT (STDMETHODCALLTYPE PREPROCESSMESSAGE)(
					LPVOID lpvSession,
					LPMESSAGE lpMessage,
					LPADRBOOK lpAdrBook,
					LPMAPIFOLDER lpFolder,
					LPALLOCATEBUFFER AllocateBuffer,
					LPALLOCATEMORE AllocateMore,
					LPFREEBUFFER FreeBuffer,
					ULONG FAR *lpcOutbound,
					LPMESSAGE FAR * FAR *lpppMessage,
					LPADRLIST FAR *lppRecipList);

/* RemovePreprocessInfo, second ordinal in RegisterPreprocessor(). */

typedef HRESULT (STDMETHODCALLTYPE REMOVEPREPROCESSINFO)(LPMESSAGE lpMessage);

/* Function pointer for GetReleaseInfo */

#define MAPI_IMAPISUPPORT_METHODS1(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetMemAllocRoutines)										\
		(THIS_	LPALLOCATEBUFFER FAR *		lpAllocateBuffer,			\
				LPALLOCATEMORE FAR *		lpAllocateMore,				\
				LPFREEBUFFER FAR *			lpFreeBuffer) IPURE;		\
	MAPIMETHOD(Subscribe)												\
		(THIS_	LPNOTIFKEY					lpKey,						\
				ULONG						ulEventMask,				\
				ULONG						ulFlags,					\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unsubscribe)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(Notify)													\
		(THIS_	LPNOTIFKEY					lpKey,						\
				ULONG						cNotification,				\
				LPNOTIFICATION				lpNotifications,			\
				ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(ModifyStatusRow)											\
		(THIS_	ULONG						cValues,					\
				LPSPropValue				lpColumnVals,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUid,						\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfileObj) IPURE;		\
	MAPIMETHOD(RegisterPreprocessor)									\
		(THIS_	LPMAPIUID					lpMuid,						\
				LPTSTR						lpszAdrType,				\
				LPTSTR						lpszDLLName,				\
				LPSTR	/* String8! */		lpszPreprocess,				\
				LPSTR	/* String8! */		lpszRemovePreprocessInfo,	\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(NewUID)													\
		(THIS_	LPMAPIUID					lpMuid) IPURE;				\
	MAPIMETHOD(MakeInvalid)												\
		(THIS_	ULONG						ulFlags,					\
				LPVOID						lpObject,					\
				ULONG						ulRefCount,					\
				ULONG						cMethods) IPURE;			\

#define MAPI_IMAPISUPPORT_METHODS2(IPURE)								\
	MAPIMETHOD(SpoolerYield)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SpoolerNotify)											\
		(THIS_	ULONG						ulFlags,					\
				LPVOID						lpvData) IPURE;				\
	MAPIMETHOD(CreateOneOff)											\
		(THIS_	LPTSTR						lpszName,					\
				LPTSTR						lpszAdrType,				\
				LPTSTR						lpszAddress,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetProviderUID)											\
		(THIS_	LPMAPIUID					lpProviderID,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntry1,					\
				LPENTRYID					lpEntry1,					\
				ULONG						cbEntry2,					\
				LPENTRYID					lpEntry2,					\
				ULONG						ulCompareFlags,				\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(OpenTemplateID)											\
		(THIS_	ULONG						cbTemplateID,				\
				LPENTRYID					lpTemplateID,				\
				ULONG						ulTemplateFlags,			\
				LPMAPIPROP					lpMAPIPropData,				\
				LPCIID						lpInterface,				\
				LPMAPIPROP FAR *			lppMAPIPropNew,				\
				LPMAPIPROP					lpMAPIPropSibling) IPURE;	\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulOpenFlags,				\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(GetOneOffTable)											\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(Address)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPADRPARM					lpAdrParms,					\
				LPADRLIST FAR *				lppAdrList) IPURE;			\
	MAPIMETHOD(Details)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPFNDISMISS					lpfnDismiss,				\
				LPVOID						lpvDismissContext,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPFNBUTTON					lpfButtonCallback,			\
				LPVOID						lpvButtonContext,			\
				LPTSTR						lpszButtonText,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(NewEntry)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cbEIDContainer,				\
				LPENTRYID					lpEIDContainer,				\
				ULONG						cbEIDNewEntryTpl,			\
				LPENTRYID					lpEIDNewEntryTpl,			\
				ULONG FAR *					lpcbEIDNewEntry,			\
				LPENTRYID FAR *				lppEIDNewEntry) IPURE;		\
	MAPIMETHOD(DoConfigPropsheet)										\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				LPTSTR						lpszTitle,					\
				LPMAPITABLE					lpDisplayTable,				\
				LPMAPIPROP					lpCOnfigData,				\
				ULONG						ulTopPage) IPURE;			\
	MAPIMETHOD(CopyMessages)											\
		(THIS_	LPCIID						lpSrcInterface,				\
				LPVOID						lpSrcFolder,				\
				LPENTRYLIST					lpMsgList,					\
				LPCIID						lpDestInterface,			\
				LPVOID 						lpDestFolder,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CopyFolder)												\
		(THIS_	LPCIID						lpSrcInterface,				\
				LPVOID						lpSrcFolder,				\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpDestInterface,			\
				LPVOID 						lpDestFolder,				\
				LPTSTR 						lszNewFolderName,			\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\

#define MAPI_IMAPISUPPORT_METHODS3(IPURE)								\
	MAPIMETHOD(DoCopyTo)												\
		(THIS_	LPCIID						lpSrcInterface,				\
				LPVOID						lpSrcObj,					\
				ULONG						ciidExclude,				\
				LPCIID						rgiidExclude,				\
				LPSPropTagArray				lpExcludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				LPCIID						lpDestInterface,			\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(DoCopyProps)												\
		(THIS_	LPCIID						lpSrcInterface,				\
				LPVOID						lpSrcObj,					\
				LPSPropTagArray				lpIncludeProps,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				LPCIID						lpDestInterface,			\
				LPVOID						lpDestObj,					\
				ULONG						ulFlags,					\
				LPSPropProblemArray FAR *	lppProblems) IPURE;			\
	MAPIMETHOD(DoProgressDialog)										\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				LPMAPIPROGRESS FAR *		lppProgress) IPURE;			\
	MAPIMETHOD(ReadReceipt)												\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpReadMessage,				\
				LPMESSAGE FAR *				lppEmptyMessage) IPURE;		\
	MAPIMETHOD(PrepareSubmit)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(ExpandRecips)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(UpdatePAB)												\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpMessage) IPURE;			\
	MAPIMETHOD(DoSentMail)												\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpMessage) IPURE;			\
	MAPIMETHOD(OpenAddressBook)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPADRBOOK FAR *				lppAdrBook) IPURE;			\
	MAPIMETHOD(Preprocess)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(CompleteMsg)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(StoreLogoffTransports)									\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(StatusRecips)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				LPADRLIST					lpRecipList) IPURE;			\
	MAPIMETHOD(WrapStoreEntryID)										\
		(THIS_	ULONG						cbOrigEntry,				\
				LPENTRYID					lpOrigEntry,				\
				ULONG FAR *					lpcbWrappedEntry,			\
				LPENTRYID FAR *				lppWrappedEntry) IPURE;		\
	MAPIMETHOD(ModifyProfile)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(IStorageFromStream)										\
		(THIS_	LPUNKNOWN					lpUnkIn,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPSTORAGE FAR *				lppStorageOut) IPURE;		\
	MAPIMETHOD(GetSvcConfigSupportObj)									\
		(THIS_	ULONG						ulFlags,					\
				LPMAPISUP FAR *				lppSvcSupport) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPISupport
DECLARE_MAPI_INTERFACE_(IMAPISupport, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPISUPPORT_METHODS1(PURE)
	MAPI_IMAPISUPPORT_METHODS2(PURE)
	MAPI_IMAPISUPPORT_METHODS3(PURE)
};


/********************************************************************/
/*																	*/
/*							ADDRESS BOOK SPI						*/
/*																	*/
/********************************************************************/

/* Address Book Provider ------------------------------------------------- */

/* OpenTemplateID() */
#define FILL_ENTRY				((ULONG) 0x00000001)

/* For Logon() */

/*#define AB_NO_DIALOG			((ULONG) 0x00000001) in mapidefs.h */
/*#define MAPI_UNICODE			((ULONG) 0x80000000) in mapidefs.h */



DECLARE_MAPI_INTERFACE_PTR(IABProvider, LPABPROVIDER);
DECLARE_MAPI_INTERFACE_PTR(IABLogon,    LPABLOGON);

#define MAPI_IABPROVIDER_METHODS(IPURE)                                 \
	MAPIMETHOD(Shutdown)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
    MAPIMETHOD(Logon)                                                   \
        (THIS_  LPMAPISUP                   lpMAPISup,                  \
                ULONG                       ulUIParam,                  \
                LPTSTR                      lpszProfileName,            \
                ULONG                       ulFlags,                    \
				ULONG FAR *					lpulpcbSecurity,			\
				LPBYTE FAR *				lppbSecurity,				\
                LPMAPIERROR FAR *			lppMAPIError,				\
                LPABLOGON FAR *             lppABLogon) IPURE;          \

#undef       INTERFACE
#define      INTERFACE  IABProvider
DECLARE_MAPI_INTERFACE_(IABProvider, IUnknown)
{
	BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IABPROVIDER_METHODS(PURE)
};

/* For GetOneOffTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#define MAPI_IABLOGON_METHODS(IPURE)                                    \
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Logoff)													\
		(THIS_	ULONG						ulFlags) IPURE;				\
    MAPIMETHOD(OpenEntry)                                               \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
    MAPIMETHOD(CompareEntryIDs)                                         \
        (THIS_  ULONG                       cbEntryID1,                 \
                LPENTRYID                   lpEntryID1,                 \
                ULONG                       cbEntryID2,                 \
                LPENTRYID                   lpEntryID2,                 \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulResult) IPURE;          \
    MAPIMETHOD(Advise)				                                    \
        (THIS_  ULONG                       cbEntryID,                  \
                LPENTRYID                   lpEntryID,                  \
                ULONG                       ulEventMask,                \
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                       lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPMAPISTATUS FAR *          lppEntry) IPURE;            \
    MAPIMETHOD(OpenTemplateID)                                          \
        (THIS_  ULONG                       cbTemplateID,               \
                LPENTRYID                   lpTemplateID,               \
                ULONG                       ulTemplateFlags,            \
                LPMAPIPROP                  lpMAPIPropData,             \
                LPCIID                       lpInterface,                \
                LPMAPIPROP FAR *            lppMAPIPropNew,             \
                LPMAPIPROP                  lpMAPIPropSibling) IPURE;   \
    MAPIMETHOD(GetOneOffTable)                                          \
        (THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *           lppTable) IPURE;            \
	MAPIMETHOD(PrepareRecips)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray				lpPropTagArray,				\
				LPADRLIST					lpRecipList) IPURE;			\

#undef       INTERFACE
#define      INTERFACE  IABLogon
DECLARE_MAPI_INTERFACE_(IABLogon, IUnknown)
{
	BEGIN_INTERFACE
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IABLOGON_METHODS(PURE)
};

typedef HRESULT (STDMAPIINITCALLTYPE ABPROVIDERINIT)(
	HINSTANCE			hInstance,
	LPMALLOC			lpMalloc,
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPALLOCATEMORE 		lpAllocateMore,
	LPFREEBUFFER 		lpFreeBuffer,
    ULONG				ulFlags,
    ULONG				ulMAPIVer,
    ULONG FAR *			lpulProviderVer,
    LPABPROVIDER FAR *	lppABProvider
);

ABPROVIDERINIT ABProviderInit;



/********************************************************************/
/*																	*/
/*							TRANSPORT SPI							*/
/*																	*/
/********************************************************************/

/* For DeinitTransport */

#define	DEINIT_NORMAL				((ULONG) 0x00000001)
#define	DEINIT_HURRY				((ULONG) 0x80000000)

/* For TransportLogon */

/* Flags that the Spooler may pass to the transport: */

#define LOGON_NO_DIALOG				((ULONG) 0x00000001)
#define	LOGON_NO_CONNECT			((ULONG) 0x00000004)
#define	LOGON_NO_INBOUND			((ULONG) 0x00000008)
#define	LOGON_NO_OUTBOUND			((ULONG) 0x00000010)
/*#define MAPI_UNICODE				((ULONG) 0x80000000) in mapidefs.h */

/* Flags that the transport may pass to the Spooler: */

#define	LOGON_SP_IDLE				((ULONG) 0x00010000)
#define	LOGON_SP_POLL				((ULONG) 0x00020000)
#define	LOGON_SP_RESOLVE			((ULONG) 0x00040000)


DECLARE_MAPI_INTERFACE_PTR(IXPProvider, LPXPPROVIDER);
DECLARE_MAPI_INTERFACE_PTR(IXPLogon, LPXPLOGON);

#define MAPI_IXPPROVIDER_METHODS(IPURE)									\
	MAPIMETHOD(Shutdown)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(TransportLogon)											\
		(THIS_	LPMAPISUP					lpMAPISup,					\
				ULONG						ulUIParam,					\
				__in LPTSTR						lpszProfileName,			\
				ULONG FAR *					lpulFlags,					\
                LPMAPIERROR FAR *			lppMAPIError,				\
				LPXPLOGON FAR *				lppXPLogon) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IXPProvider
DECLARE_MAPI_INTERFACE_(IXPProvider, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IXPPROVIDER_METHODS(PURE)
};

/* OptionData returned from call to RegisterOptions */

#define OPTION_TYPE_RECIPIENT		((ULONG) 0x00000001)
#define OPTION_TYPE_MESSAGE			((ULONG) 0x00000002)

typedef struct _OPTIONDATA
{
	ULONG			ulFlags;		/* MAPI_RECIPIENT, MAPI_MESSAGE */
	LPGUID			lpRecipGUID;	/* Same as returned by AddressTypes() */
	LPTSTR			lpszAdrType;	/* Same as returned by AddressTypes() */
	LPTSTR			lpszDLLName;	/* Options DLL */
	ULONG			ulOrdinal;		/* Ordinal in that DLL */
	ULONG			cbOptionsData;	/* Count of bytes in lpbOptionsData */
	LPBYTE			lpbOptionsData;	/* Providers per [recip|message] option data */
	ULONG			cOptionsProps;	/* Count of Options default prop values */
	LPSPropValue	lpOptionsProps;	/* Default Options property values */
} OPTIONDATA, FAR *LPOPTIONDATA;

typedef SCODE (STDMAPIINITCALLTYPE OPTIONCALLBACK)(
			HINSTANCE			hInst,
			LPMALLOC			lpMalloc,
			ULONG				ulFlags,
			ULONG				cbOptionData,
			LPBYTE				lpbOptionData,
			LPMAPISUP			lpMAPISup,
			LPMAPIPROP			lpDataSource,
			LPMAPIPROP FAR *	lppWrappedSource,
            LPMAPIERROR FAR *	lppMAPIError);

/* For XP_AddressTypes */

/*#define MAPI_UNICODE				((ULONG) 0x80000000) in mapidefs.h */

/* For XP_RegisterRecipOptions */

/*#define MAPI_UNICODE				((ULONG) 0x80000000) in mapidefs.h */

/* For XP_RegisterMessageOptions */

/*#define MAPI_UNICODE				((ULONG) 0x80000000) in mapidefs.h */

/* For TransportNotify */

#define NOTIFY_ABORT_DEFERRED		((ULONG) 0x40000000)
#define NOTIFY_CANCEL_MESSAGE		((ULONG) 0x80000000)
#define NOTIFY_BEGIN_INBOUND		((ULONG) 0x00000001)
#define NOTIFY_END_INBOUND			((ULONG) 0x00010000)
#define NOTIFY_BEGIN_OUTBOUND		((ULONG) 0x00000002)
#define NOTIFY_END_OUTBOUND			((ULONG) 0x00020000)
#define NOTIFY_BEGIN_INBOUND_FLUSH	((ULONG) 0x00000004)
#define NOTIFY_END_INBOUND_FLUSH	((ULONG) 0x00040000)
#define NOTIFY_BEGIN_OUTBOUND_FLUSH	((ULONG) 0x00000008)
#define NOTIFY_END_OUTBOUND_FLUSH	((ULONG) 0x00080000)

/* For TransportLogoff */

#define	LOGOFF_NORMAL				((ULONG) 0x00000001)
#define LOGOFF_HURRY				((ULONG) 0x80000000)

/* For SubmitMessage */

#define BEGIN_DEFERRED				((ULONG) 0x00000001)

/* For EndMessage */

/* Flags that the Spooler may pass to the Transport: */

/* Flags that the transport may pass to the Spooler: */

#define END_RESEND_NOW				((ULONG) 0x00010000)
#define END_RESEND_LATER			((ULONG) 0x00020000)
#define END_DONT_RESEND				((ULONG) 0x00040000)

#define MAPI_IXPLOGON_METHODS(IPURE)									\
	MAPIMETHOD(AddressTypes)											\
		(THIS_	ULONG FAR *					lpulFlags,					\
				ULONG FAR *					lpcAdrType,					\
				__deref_out_ecount_full(*lpcAdrType) LPTSTR FAR * FAR *			lpppAdrTypeArray,			\
				ULONG FAR *					lpcMAPIUID,					\
				LPMAPIUID FAR * FAR *		lpppUIDArray) IPURE;		\
	MAPIMETHOD(RegisterOptions)											\
		(THIS_	ULONG FAR *					lpulFlags,					\
				ULONG FAR *					lpcOptions,					\
				LPOPTIONDATA FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(TransportNotify)											\
		(THIS_	ULONG FAR *					lpulFlags,					\
				LPVOID FAR *				lppvData) IPURE;			\
	MAPIMETHOD(Idle)													\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(TransportLogoff)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SubmitMessage)											\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulMsgRef,					\
				ULONG FAR *					lpulReturnParm) IPURE;		\
	MAPIMETHOD(EndMessage)												\
		(THIS_	ULONG						ulMsgRef,					\
				ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(Poll)													\
		(THIS_	ULONG FAR *					lpulIncoming) IPURE;		\
	MAPIMETHOD(StartMessage)											\
		(THIS_	ULONG						ulFlags,					\
				LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulMsgRef) IPURE;			\
    MAPIMETHOD(OpenStatusEntry)                                         \
        (THIS_  LPCIID                      lpInterface,                \
                ULONG                       ulFlags,                    \
                ULONG FAR *                 lpulObjType,                \
                LPMAPISTATUS FAR *          lppEntry) IPURE;            \
	MAPIMETHOD(ValidateState)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(FlushQueues)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						cbTargetTransport,			\
				LPENTRYID					lpTargetTransport,			\
				ULONG						ulFlags) IPURE;				\

#undef       INTERFACE
#define      INTERFACE  IXPLogon
DECLARE_MAPI_INTERFACE_(IXPLogon, IUnknown)
{
	BEGIN_INTERFACE	
    MAPI_IUNKNOWN_METHODS(PURE)
    MAPI_IXPLOGON_METHODS(PURE)
};


/* Transport Provider Entry Point */

typedef HRESULT (STDMAPIINITCALLTYPE XPPROVIDERINIT)(
	HINSTANCE			hInstance,
	LPMALLOC			lpMalloc,
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPALLOCATEMORE 		lpAllocateMore,
	LPFREEBUFFER 		lpFreeBuffer,
	ULONG				ulFlags,
	ULONG				ulMAPIVer,
	ULONG FAR *			lpulProviderVer,
	LPXPPROVIDER FAR *	lppXPProvider);

XPPROVIDERINIT XPProviderInit;

/********************************************************************/
/*																	*/
/*							MESSAGE STORE SPI						*/
/*																	*/
/********************************************************************/

/* Flags and enums */

/* For Logon() */

/*#define MAPI_UNICODE			((ULONG) 0x80000000) in mapidefs.h */
/*#define MDB_NO_DIALOG			((ULONG) 0x00000001) in mapidefs.h */
/*#define MDB_WRITE				((ULONG) 0x00000004) in mapidefs.h */
/*#define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) in mapidefs.h */
/*#define MDB_TEMPORARY			((ULONG) 0x00000020) in mapidefs.h */
/*#define MDB_NO_MAIL			((ULONG) 0x00000080) in mapidefs.h */

/* For SpoolerLogon() */

/*#define MAPI_UNICODE			((ULONG) 0x80000000) in mapidefs.h */
/*#define MDB_NO_DIALOG			((ULONG) 0x00000001) in mapidefs.h */
/*#define MDB_WRITE				((ULONG) 0x00000004) in mapidefs.h */
/*#define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) in mapidefs.h */

/* GetCredentials, SetCredentials */

#define LOGON_SP_TRANSPORT		((ULONG) 0x00000001)
#define LOGON_SP_PROMPT			((ULONG) 0x00000002)
#define LOGON_SP_NEWPW			((ULONG) 0x00000004)
#define LOGON_CHANGED			((ULONG) 0x00000008)

/* DoMCDialog */

#define DIALOG_FOLDER			((ULONG) 0x00000001)
#define DIALOG_MESSAGE			((ULONG) 0x00000002)
#define DIALOG_PROP				((ULONG) 0x00000004)
#define DIALOG_ATTACH			((ULONG) 0x00000008)

#define DIALOG_MOVE				((ULONG) 0x00000010)
#define DIALOG_COPY				((ULONG) 0x00000020)
#define DIALOG_DELETE			((ULONG) 0x00000040)

#define DIALOG_ALLOW_CANCEL		((ULONG) 0x00000080)
#define DIALOG_CONFIRM_CANCEL	((ULONG) 0x00000100)

/* ExpandRecips */

#define NEEDS_PREPROCESSING		((ULONG) 0x00000001)
#define NEEDS_SPOOLER			((ULONG) 0x00000002)

/* PrepareSubmit */

#define CHECK_SENDER			((ULONG) 0x00000001)
#define NON_STANDARD			((ULONG) 0x00010000)


DECLARE_MAPI_INTERFACE_PTR(IMSLogon, LPMSLOGON);
DECLARE_MAPI_INTERFACE_PTR(IMSProvider, LPMSPROVIDER);

/* Message Store Provider Interface (IMSPROVIDER) */

#define MAPI_IMSPROVIDER_METHODS(IPURE)									\
	MAPIMETHOD(Shutdown)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(Logon)													\
		(THIS_	LPMAPISUP					lpMAPISup,					\
				ULONG						ulUIParam,					\
				LPTSTR						lpszProfileName,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags,					\
				LPCIID						lpInterface,				\
				ULONG FAR *					lpcbSpoolSecurity,			\
				LPBYTE FAR *				lppbSpoolSecurity,			\
                LPMAPIERROR FAR *			lppMAPIError,				\
				LPMSLOGON FAR *				lppMSLogon,					\
				LPMDB FAR *					lppMDB) IPURE;				\
	MAPIMETHOD(SpoolerLogon)											\
		(THIS_	LPMAPISUP					lpMAPISup,					\
				ULONG						ulUIParam,					\
				LPTSTR						lpszProfileName,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags,					\
				LPCIID						lpInterface,				\
				ULONG						cbSpoolSecurity,			\
				LPBYTE						lpbSpoolSecurity,			\
                LPMAPIERROR FAR *			lppMAPIError,				\
				LPMSLOGON FAR *				lppMSLogon,					\
				LPMDB FAR *					lppMDB) IPURE;				\
	MAPIMETHOD(CompareStoreIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IMSProvider
DECLARE_MAPI_INTERFACE_(IMSProvider, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMSPROVIDER_METHODS(PURE)
};

/* The MSLOGON object is returned by the Logon() method of the
 * MSPROVIDER interface.  This object is for use by MAPIX.DLL.
 */
#define MAPI_IMSLOGON_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Logoff)													\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(OpenStatusEntry)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPVOID FAR *				lppEntry) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IMSLogon
DECLARE_MAPI_INTERFACE_(IMSLogon, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMSLOGON_METHODS(PURE)
};

/* Message Store Provider Entry Point */

typedef HRESULT (STDMAPIINITCALLTYPE MSPROVIDERINIT)(
	HINSTANCE				hInstance,
	LPMALLOC				lpMalloc,			/* AddRef() if you keep it */
	LPALLOCATEBUFFER		lpAllocateBuffer,	/* -> AllocateBuffer */
	LPALLOCATEMORE			lpAllocateMore, 	/* -> AllocateMore   */
	LPFREEBUFFER			lpFreeBuffer, 		/* -> FreeBuffer     */
	ULONG					ulFlags,
	ULONG					ulMAPIVer,
	ULONG FAR *				lpulProviderVer,
	LPMSPROVIDER FAR *		lppMSProvider
);

MSPROVIDERINIT MSProviderInit;


/********************************************************************/
/*																	*/
/*					  MESSAGE SERVICE CONFIGURATION					*/
/*																	*/
/********************************************************************/

/* Flags for service configuration entry point */

/* #define MAPI_UNICODE				 0x80000000 */
/* #define SERVICE_UI_ALWAYS  		 0x00000002	*/
/* #define SERVICE_UI_ALLOWED 		 0x00000010	*/
#define MSG_SERVICE_UI_READ_ONLY	 0x00000008	/* display parameters only */
#define SERVICE_LOGON_FAILED		 0x00000020 /* reconfigure provider */

/* Contexts for service configuration entry point */

#define MSG_SERVICE_INSTALL			0x00000001
#define MSG_SERVICE_CREATE			0x00000002
#define MSG_SERVICE_CONFIGURE		0x00000003
#define MSG_SERVICE_DELETE			0x00000004
#define MSG_SERVICE_UNINSTALL		0x00000005
#define MSG_SERVICE_PROVIDER_CREATE	0x00000006
#define MSG_SERVICE_PROVIDER_DELETE	0x00000007

/* Prototype for service configuration entry point */

typedef HRESULT (STDAPICALLTYPE MSGSERVICEENTRY)(
	HINSTANCE		hInstance,
	LPMALLOC		lpMalloc,
	LPMAPISUP		lpMAPISup,
	ULONG			ulUIParam,
	ULONG			ulFlags,
	ULONG			ulContext,
	ULONG			cValues,
	LPSPropValue	lpProps,
	LPPROVIDERADMIN lpProviderAdmin,
	LPMAPIERROR FAR *lppMapiError
);
typedef MSGSERVICEENTRY FAR *LPMSGSERVICEENTRY;


#ifdef __cplusplus
}
#endif

#endif /* MAPISPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPITags.h ===
/*
 *	M A P I T A G S . H
 *
 *	Property tag definitions for standard properties of MAPI
 *	objects.
 *
 *	The following ranges should be used for all property IDs. Note that
 *	property IDs for objects other than messages and recipients should
 *	all fall in the range 0x3000 to 0x3FFF:
 *
 *	From	To		Kind of property
 *	--------------------------------
 *	0001	0BFF	MAPI_defined envelope property
 *	0C00	0DFF	MAPI_defined per-recipient property
 *	0E00	0FFF	MAPI_defined non-transmittable property
 *	1000	2FFF	MAPI_defined message content property
 *
 *	3000	3FFF	MAPI_defined property (usually not message or recipient)
 *
 *	4000	57FF	Transport-defined envelope property
 *	5800	5FFF	Transport-defined per-recipient property
 *	6000	65FF	User-defined non-transmittable property
 *	6600	67FF	Provider-defined internal non-transmittable property
 *	6800	7BFF	Message class-defined content property
 *	7C00	7FFF	Message class-defined non-transmittable
 *					property
 *
 *	8000	FFFE	User-defined Name-to-id mapped property
 *
 *	The 3000-3FFF range is further subdivided as follows:
 *
 *	From	To		Kind of property
 *	--------------------------------
 *	3000	33FF	Common property such as display name, entry ID
 *	3400	35FF	Message store object
 *	3600	36FF	Folder or AB container
 *	3700	38FF	Attachment
 *	3900	39FF	Address book object
 *	3A00	3BFF	Mail user
 *	3C00	3CFF	Distribution list
 *	3D00	3DFF	Profile section
 *	3E00	3FFF	Status object
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef	MAPITAGS_H
#define	MAPITAGS_H

#if _MSC_VER > 1000
#pragma once
#endif

/* Determine if a property is transmittable. */

#define FIsTransmittable(ulPropTag) \
	((PROP_ID (ulPropTag) <  (ULONG)0x0E00) || \
	(PROP_ID (ulPropTag)  >= (ULONG)0x8000) || \
	((PROP_ID (ulPropTag) >= (ULONG)0x1000) && (PROP_ID (ulPropTag) < (ULONG)0x6000)) || \
	((PROP_ID (ulPropTag) >= (ULONG)0x6800) && (PROP_ID (ulPropTag) < (ULONG)0x7C00)))

/*
 *	Message envelope properties
 */

#define PR_ACKNOWLEDGEMENT_MODE						PROP_TAG( PT_LONG,		0x0001)
#define PR_ALTERNATE_RECIPIENT_ALLOWED				PROP_TAG( PT_BOOLEAN,	0x0002)
#define PR_AUTHORIZING_USERS						PROP_TAG( PT_BINARY,	0x0003)
#define PR_AUTO_FORWARD_COMMENT						PROP_TAG( PT_TSTRING,	0x0004)
#define PR_AUTO_FORWARD_COMMENT_W					PROP_TAG( PT_UNICODE,	0x0004)
#define PR_AUTO_FORWARD_COMMENT_A					PROP_TAG( PT_STRING8,	0x0004)
#define PR_AUTO_FORWARDED							PROP_TAG( PT_BOOLEAN,	0x0005)
#define PR_CONTENT_CONFIDENTIALITY_ALGORITHM_ID		PROP_TAG( PT_BINARY,	0x0006)
#define PR_CONTENT_CORRELATOR						PROP_TAG( PT_BINARY,	0x0007)
#define PR_CONTENT_IDENTIFIER						PROP_TAG( PT_TSTRING,	0x0008)
#define PR_CONTENT_IDENTIFIER_W						PROP_TAG( PT_UNICODE,	0x0008)
#define PR_CONTENT_IDENTIFIER_A						PROP_TAG( PT_STRING8,	0x0008)
#define PR_CONTENT_LENGTH							PROP_TAG( PT_LONG,		0x0009)
#define PR_CONTENT_RETURN_REQUESTED					PROP_TAG( PT_BOOLEAN,	0x000A)



#define PR_CONVERSATION_KEY							PROP_TAG( PT_BINARY,	0x000B)

#define PR_CONVERSION_EITS							PROP_TAG( PT_BINARY,	0x000C)
#define PR_CONVERSION_WITH_LOSS_PROHIBITED			PROP_TAG( PT_BOOLEAN,	0x000D)
#define PR_CONVERTED_EITS							PROP_TAG( PT_BINARY,	0x000E)
#define PR_DEFERRED_DELIVERY_TIME					PROP_TAG( PT_SYSTIME,	0x000F)
#define PR_DELIVER_TIME								PROP_TAG( PT_SYSTIME,	0x0010)
#define PR_DISCARD_REASON							PROP_TAG( PT_LONG,		0x0011)
#define PR_DISCLOSURE_OF_RECIPIENTS					PROP_TAG( PT_BOOLEAN,	0x0012)
#define PR_DL_EXPANSION_HISTORY						PROP_TAG( PT_BINARY,	0x0013)
#define PR_DL_EXPANSION_PROHIBITED					PROP_TAG( PT_BOOLEAN,	0x0014)
#define PR_EXPIRY_TIME								PROP_TAG( PT_SYSTIME,	0x0015)
#define PR_IMPLICIT_CONVERSION_PROHIBITED			PROP_TAG( PT_BOOLEAN,	0x0016)
#define PR_IMPORTANCE								PROP_TAG( PT_LONG,		0x0017)
#define PR_IPM_ID									PROP_TAG( PT_BINARY,	0x0018)
#define PR_LATEST_DELIVERY_TIME						PROP_TAG( PT_SYSTIME,	0x0019)
#define PR_MESSAGE_CLASS							PROP_TAG( PT_TSTRING,	0x001A)
#define PR_MESSAGE_CLASS_W							PROP_TAG( PT_UNICODE,	0x001A)
#define PR_MESSAGE_CLASS_A							PROP_TAG( PT_STRING8,	0x001A)
#define PR_MESSAGE_DELIVERY_ID						PROP_TAG( PT_BINARY,	0x001B)





#define PR_MESSAGE_SECURITY_LABEL					PROP_TAG( PT_BINARY,	0x001E)
#define PR_OBSOLETED_IPMS							PROP_TAG( PT_BINARY,	0x001F)
#define PR_ORIGINALLY_INTENDED_RECIPIENT_NAME		PROP_TAG( PT_BINARY,	0x0020)
#define PR_ORIGINAL_EITS							PROP_TAG( PT_BINARY,	0x0021)
#define PR_ORIGINATOR_CERTIFICATE					PROP_TAG( PT_BINARY,	0x0022)
#define PR_ORIGINATOR_DELIVERY_REPORT_REQUESTED		PROP_TAG( PT_BOOLEAN,	0x0023)
#define PR_ORIGINATOR_RETURN_ADDRESS				PROP_TAG( PT_BINARY,	0x0024)



#define PR_PARENT_KEY								PROP_TAG( PT_BINARY,	0x0025)
#define PR_PRIORITY									PROP_TAG( PT_LONG,		0x0026)



#define PR_ORIGIN_CHECK								PROP_TAG( PT_BINARY,	0x0027)
#define PR_PROOF_OF_SUBMISSION_REQUESTED			PROP_TAG( PT_BOOLEAN,	0x0028)
#define PR_READ_RECEIPT_REQUESTED					PROP_TAG( PT_BOOLEAN,	0x0029)
#define PR_RECEIPT_TIME								PROP_TAG( PT_SYSTIME,	0x002A)
#define PR_RECIPIENT_REASSIGNMENT_PROHIBITED		PROP_TAG( PT_BOOLEAN,	0x002B)
#define PR_REDIRECTION_HISTORY						PROP_TAG( PT_BINARY,	0x002C)
#define PR_RELATED_IPMS								PROP_TAG( PT_BINARY,	0x002D)
#define PR_ORIGINAL_SENSITIVITY						PROP_TAG( PT_LONG,		0x002E)
#define	PR_LANGUAGES								PROP_TAG( PT_TSTRING,	0x002F)
#define	PR_LANGUAGES_W								PROP_TAG( PT_UNICODE,	0x002F)
#define	PR_LANGUAGES_A								PROP_TAG( PT_STRING8,	0x002F)
#define PR_REPLY_TIME								PROP_TAG( PT_SYSTIME,	0x0030)
#define PR_REPORT_TAG								PROP_TAG( PT_BINARY,	0x0031)
#define PR_REPORT_TIME								PROP_TAG( PT_SYSTIME,	0x0032)
#define PR_RETURNED_IPM								PROP_TAG( PT_BOOLEAN,	0x0033)
#define PR_SECURITY									PROP_TAG( PT_LONG,		0x0034)
#define	PR_INCOMPLETE_COPY							PROP_TAG( PT_BOOLEAN,	0x0035)
#define PR_SENSITIVITY								PROP_TAG( PT_LONG,		0x0036)
#define PR_SUBJECT									PROP_TAG( PT_TSTRING,	0x0037)
#define PR_SUBJECT_W								PROP_TAG( PT_UNICODE,	0x0037)
#define PR_SUBJECT_A								PROP_TAG( PT_STRING8,	0x0037)
#define PR_SUBJECT_IPM								PROP_TAG( PT_BINARY,	0x0038)
#define PR_CLIENT_SUBMIT_TIME						PROP_TAG( PT_SYSTIME,	0x0039)
#define PR_REPORT_NAME								PROP_TAG( PT_TSTRING,	0x003A)
#define PR_REPORT_NAME_W							PROP_TAG( PT_UNICODE,	0x003A)
#define PR_REPORT_NAME_A							PROP_TAG( PT_STRING8,	0x003A)
#define	PR_SENT_REPRESENTING_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x003B)
#define PR_X400_CONTENT_TYPE						PROP_TAG( PT_BINARY,	0x003C)
#define PR_SUBJECT_PREFIX							PROP_TAG( PT_TSTRING,	0x003D)
#define PR_SUBJECT_PREFIX_W	 						PROP_TAG( PT_UNICODE,	0x003D)
#define PR_SUBJECT_PREFIX_A	 						PROP_TAG( PT_STRING8,	0x003D)
#define PR_NON_RECEIPT_REASON						PROP_TAG( PT_LONG,		0x003E)
#define PR_RECEIVED_BY_ENTRYID						PROP_TAG( PT_BINARY,	0x003F)
#define PR_RECEIVED_BY_NAME							PROP_TAG( PT_TSTRING,	0x0040)
#define PR_RECEIVED_BY_NAME_W						PROP_TAG( PT_UNICODE,	0x0040)
#define PR_RECEIVED_BY_NAME_A						PROP_TAG( PT_STRING8,	0x0040)
#define	PR_SENT_REPRESENTING_ENTRYID				PROP_TAG( PT_BINARY,	0x0041)
#define PR_SENT_REPRESENTING_NAME					PROP_TAG( PT_TSTRING,	0x0042)
#define PR_SENT_REPRESENTING_NAME_W					PROP_TAG( PT_UNICODE,	0x0042)
#define PR_SENT_REPRESENTING_NAME_A					PROP_TAG( PT_STRING8,	0x0042)
#define PR_RCVD_REPRESENTING_ENTRYID				PROP_TAG( PT_BINARY,	0x0043)
#define PR_RCVD_REPRESENTING_NAME					PROP_TAG( PT_TSTRING,	0x0044)
#define PR_RCVD_REPRESENTING_NAME_W					PROP_TAG( PT_UNICODE,	0x0044)
#define PR_RCVD_REPRESENTING_NAME_A					PROP_TAG( PT_STRING8,	0x0044)
#define PR_REPORT_ENTRYID							PROP_TAG( PT_BINARY,	0x0045)
#define PR_READ_RECEIPT_ENTRYID						PROP_TAG( PT_BINARY,	0x0046)
#define PR_MESSAGE_SUBMISSION_ID					PROP_TAG( PT_BINARY,	0x0047)
#define PR_PROVIDER_SUBMIT_TIME						PROP_TAG( PT_SYSTIME,	0x0048)
#define	PR_ORIGINAL_SUBJECT							PROP_TAG( PT_TSTRING,	0x0049)
#define	PR_ORIGINAL_SUBJECT_W						PROP_TAG( PT_UNICODE,	0x0049)
#define	PR_ORIGINAL_SUBJECT_A						PROP_TAG( PT_STRING8,	0x0049)
#define PR_DISC_VAL									PROP_TAG( PT_BOOLEAN,	0x004A)
#define PR_ORIG_MESSAGE_CLASS						PROP_TAG( PT_TSTRING,	0x004B)
#define PR_ORIG_MESSAGE_CLASS_W						PROP_TAG( PT_UNICODE,	0x004B)
#define PR_ORIG_MESSAGE_CLASS_A						PROP_TAG( PT_STRING8,	0x004B)
#define PR_ORIGINAL_AUTHOR_ENTRYID					PROP_TAG( PT_BINARY,	0x004C)
#define PR_ORIGINAL_AUTHOR_NAME						PROP_TAG( PT_TSTRING,	0x004D)
#define PR_ORIGINAL_AUTHOR_NAME_W					PROP_TAG( PT_UNICODE,	0x004D)
#define PR_ORIGINAL_AUTHOR_NAME_A					PROP_TAG( PT_STRING8,	0x004D)
#define PR_ORIGINAL_SUBMIT_TIME						PROP_TAG( PT_SYSTIME,	0x004E)
#define PR_REPLY_RECIPIENT_ENTRIES					PROP_TAG( PT_BINARY,	0x004F)
#define PR_REPLY_RECIPIENT_NAMES					PROP_TAG( PT_TSTRING,	0x0050)
#define PR_REPLY_RECIPIENT_NAMES_W					PROP_TAG( PT_UNICODE,	0x0050)
#define PR_REPLY_RECIPIENT_NAMES_A					PROP_TAG( PT_STRING8,	0x0050)

#define PR_RECEIVED_BY_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x0051)
#define PR_RCVD_REPRESENTING_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x0052)
#define PR_READ_RECEIPT_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x0053)
#define PR_REPORT_SEARCH_KEY						PROP_TAG( PT_BINARY,	0x0054)
#define	PR_ORIGINAL_DELIVERY_TIME					PROP_TAG( PT_SYSTIME,	0x0055)
#define PR_ORIGINAL_AUTHOR_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x0056)

#define	PR_MESSAGE_TO_ME							PROP_TAG( PT_BOOLEAN,	0x0057)
#define	PR_MESSAGE_CC_ME							PROP_TAG( PT_BOOLEAN,	0x0058)
#define	PR_MESSAGE_RECIP_ME							PROP_TAG( PT_BOOLEAN,	0x0059)

#define PR_ORIGINAL_SENDER_NAME						PROP_TAG( PT_TSTRING,	0x005A)
#define PR_ORIGINAL_SENDER_NAME_W					PROP_TAG( PT_UNICODE,	0x005A)
#define PR_ORIGINAL_SENDER_NAME_A					PROP_TAG( PT_STRING8,	0x005A)
#define	PR_ORIGINAL_SENDER_ENTRYID					PROP_TAG( PT_BINARY,	0x005B)
#define	PR_ORIGINAL_SENDER_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x005C)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME			PROP_TAG( PT_TSTRING,	0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME_W		PROP_TAG( PT_UNICODE,	0x005D)
#define PR_ORIGINAL_SENT_REPRESENTING_NAME_A		PROP_TAG( PT_STRING8,	0x005D)
#define	PR_ORIGINAL_SENT_REPRESENTING_ENTRYID		PROP_TAG( PT_BINARY,	0x005E)
#define	PR_ORIGINAL_SENT_REPRESENTING_SEARCH_KEY	PROP_TAG( PT_BINARY,	0x005F)

#define PR_START_DATE								PROP_TAG( PT_SYSTIME,	0x0060)
#define PR_END_DATE									PROP_TAG( PT_SYSTIME,	0x0061)
#define PR_OWNER_APPT_ID							PROP_TAG( PT_LONG,		0x0062)
#define PR_RESPONSE_REQUESTED						PROP_TAG( PT_BOOLEAN,	0x0063)

#define PR_SENT_REPRESENTING_ADDRTYPE				PROP_TAG( PT_TSTRING,	0x0064)
#define PR_SENT_REPRESENTING_ADDRTYPE_W				PROP_TAG( PT_UNICODE,	0x0064)
#define PR_SENT_REPRESENTING_ADDRTYPE_A				PROP_TAG( PT_STRING8,	0x0064)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS			PROP_TAG( PT_TSTRING,	0x0065)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS_W		PROP_TAG( PT_UNICODE,	0x0065)
#define PR_SENT_REPRESENTING_EMAIL_ADDRESS_A		PROP_TAG( PT_STRING8,	0x0065)

#define PR_ORIGINAL_SENDER_ADDRTYPE					PROP_TAG( PT_TSTRING,	0x0066)
#define PR_ORIGINAL_SENDER_ADDRTYPE_W				PROP_TAG( PT_UNICODE,	0x0066)
#define PR_ORIGINAL_SENDER_ADDRTYPE_A				PROP_TAG( PT_STRING8,	0x0066)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS			PROP_TAG( PT_TSTRING,	0x0067)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS_W			PROP_TAG( PT_UNICODE,	0x0067)
#define PR_ORIGINAL_SENDER_EMAIL_ADDRESS_A			PROP_TAG( PT_STRING8,	0x0067)

#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE		PROP_TAG( PT_TSTRING,	0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_W	PROP_TAG( PT_UNICODE,	0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_ADDRTYPE_A	PROP_TAG( PT_STRING8,	0x0068)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS	PROP_TAG( PT_TSTRING,	0x0069)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_W	PROP_TAG( PT_UNICODE,	0x0069)
#define PR_ORIGINAL_SENT_REPRESENTING_EMAIL_ADDRESS_A	PROP_TAG( PT_STRING8,	0x0069)

#define	PR_CONVERSATION_TOPIC						PROP_TAG( PT_TSTRING,	0x0070)
#define	PR_CONVERSATION_TOPIC_W						PROP_TAG( PT_UNICODE,	0x0070)
#define	PR_CONVERSATION_TOPIC_A						PROP_TAG( PT_STRING8,	0x0070)
#define	PR_CONVERSATION_INDEX						PROP_TAG( PT_BINARY,	0x0071)

#define PR_ORIGINAL_DISPLAY_BCC						PROP_TAG( PT_TSTRING,	0x0072)
#define PR_ORIGINAL_DISPLAY_BCC_W					PROP_TAG( PT_UNICODE,	0x0072)
#define PR_ORIGINAL_DISPLAY_BCC_A					PROP_TAG( PT_STRING8,	0x0072)
#define PR_ORIGINAL_DISPLAY_CC						PROP_TAG( PT_TSTRING,	0x0073)
#define PR_ORIGINAL_DISPLAY_CC_W					PROP_TAG( PT_UNICODE,	0x0073)
#define PR_ORIGINAL_DISPLAY_CC_A					PROP_TAG( PT_STRING8,	0x0073)
#define PR_ORIGINAL_DISPLAY_TO						PROP_TAG( PT_TSTRING,	0x0074)
#define PR_ORIGINAL_DISPLAY_TO_W					PROP_TAG( PT_UNICODE,	0x0074)
#define PR_ORIGINAL_DISPLAY_TO_A					PROP_TAG( PT_STRING8,	0x0074)

#define PR_RECEIVED_BY_ADDRTYPE						PROP_TAG( PT_TSTRING,	0x0075)
#define PR_RECEIVED_BY_ADDRTYPE_W					PROP_TAG( PT_UNICODE,	0x0075)
#define PR_RECEIVED_BY_ADDRTYPE_A					PROP_TAG( PT_STRING8,	0x0075)
#define	PR_RECEIVED_BY_EMAIL_ADDRESS				PROP_TAG( PT_TSTRING,	0x0076)
#define	PR_RECEIVED_BY_EMAIL_ADDRESS_W				PROP_TAG( PT_UNICODE,	0x0076)
#define	PR_RECEIVED_BY_EMAIL_ADDRESS_A				PROP_TAG( PT_STRING8,	0x0076)

#define PR_RCVD_REPRESENTING_ADDRTYPE				PROP_TAG( PT_TSTRING,	0x0077)
#define PR_RCVD_REPRESENTING_ADDRTYPE_W				PROP_TAG( PT_UNICODE,	0x0077)
#define PR_RCVD_REPRESENTING_ADDRTYPE_A				PROP_TAG( PT_STRING8,	0x0077)
#define PR_RCVD_REPRESENTING_EMAIL_ADDRESS			PROP_TAG( PT_TSTRING,	0x0078)
#define PR_RCVD_REPRESENTING_EMAIL_ADDRESS_W		PROP_TAG( PT_UNICODE,	0x0078)
#define PR_RCVD_REPRESENTING_EMAIL_ADDRESS_A		PROP_TAG( PT_STRING8,	0x0078)

#define PR_ORIGINAL_AUTHOR_ADDRTYPE					PROP_TAG( PT_TSTRING,	0x0079)
#define PR_ORIGINAL_AUTHOR_ADDRTYPE_W				PROP_TAG( PT_UNICODE,	0x0079)
#define PR_ORIGINAL_AUTHOR_ADDRTYPE_A				PROP_TAG( PT_STRING8,	0x0079)
#define PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS			PROP_TAG( PT_TSTRING,	0x007A)
#define PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_W			PROP_TAG( PT_UNICODE,	0x007A)
#define PR_ORIGINAL_AUTHOR_EMAIL_ADDRESS_A			PROP_TAG( PT_STRING8,	0x007A)

#define PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE		PROP_TAG( PT_TSTRING,	0x007B)
#define PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_W		PROP_TAG( PT_UNICODE,	0x007B)
#define PR_ORIGINALLY_INTENDED_RECIP_ADDRTYPE_A		PROP_TAG( PT_STRING8,	0x007B)
#define PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS	PROP_TAG( PT_TSTRING,	0x007C)
#define PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_W	PROP_TAG( PT_UNICODE,	0x007C)
#define PR_ORIGINALLY_INTENDED_RECIP_EMAIL_ADDRESS_A	PROP_TAG( PT_STRING8,	0x007C)

#define PR_TRANSPORT_MESSAGE_HEADERS				PROP_TAG(PT_TSTRING,	0x007D)
#define PR_TRANSPORT_MESSAGE_HEADERS_W				PROP_TAG(PT_UNICODE,	0x007D)
#define PR_TRANSPORT_MESSAGE_HEADERS_A				PROP_TAG(PT_STRING8,	0x007D)

#define PR_DELEGATION								PROP_TAG(PT_BINARY,		0x007E)

#define PR_TNEF_CORRELATION_KEY						PROP_TAG(PT_BINARY,		0x007F)



/*
 *	Message content properties
 */

#define PR_BODY										PROP_TAG( PT_TSTRING,	0x1000)
#define PR_BODY_W									PROP_TAG( PT_UNICODE,	0x1000)
#define PR_BODY_A									PROP_TAG( PT_STRING8,	0x1000)
#define PR_REPORT_TEXT								PROP_TAG( PT_TSTRING,	0x1001)
#define PR_REPORT_TEXT_W							PROP_TAG( PT_UNICODE,	0x1001)
#define PR_REPORT_TEXT_A							PROP_TAG( PT_STRING8,	0x1001)
#define PR_ORIGINATOR_AND_DL_EXPANSION_HISTORY		PROP_TAG( PT_BINARY,	0x1002)
#define PR_REPORTING_DL_NAME						PROP_TAG( PT_BINARY,	0x1003)
#define PR_REPORTING_MTA_CERTIFICATE				PROP_TAG( PT_BINARY,	0x1004)

/*  Removed PR_REPORT_ORIGIN_AUTHENTICATION_CHECK with DCR 3865, use PR_ORIGIN_CHECK */

#define PR_RTF_SYNC_BODY_CRC						PROP_TAG( PT_LONG,		0x1006)
#define PR_RTF_SYNC_BODY_COUNT						PROP_TAG( PT_LONG,		0x1007)
#define PR_RTF_SYNC_BODY_TAG						PROP_TAG( PT_TSTRING,	0x1008)
#define PR_RTF_SYNC_BODY_TAG_W						PROP_TAG( PT_UNICODE,	0x1008)
#define PR_RTF_SYNC_BODY_TAG_A						PROP_TAG( PT_STRING8,	0x1008)
#define PR_RTF_COMPRESSED							PROP_TAG( PT_BINARY,	0x1009)
#define PR_RTF_SYNC_PREFIX_COUNT					PROP_TAG( PT_LONG,		0x1010)
#define PR_RTF_SYNC_TRAILING_COUNT					PROP_TAG( PT_LONG,		0x1011)
#define PR_ORIGINALLY_INTENDED_RECIP_ENTRYID		PROP_TAG( PT_BINARY,	0x1012)

/*
 *  Reserved 0x1100-0x1200
 */


/*
 *	Message recipient properties
 */

#define PR_CONTENT_INTEGRITY_CHECK					PROP_TAG( PT_BINARY,	0x0C00)
#define PR_EXPLICIT_CONVERSION						PROP_TAG( PT_LONG,		0x0C01)
#define PR_IPM_RETURN_REQUESTED						PROP_TAG( PT_BOOLEAN,	0x0C02)
#define PR_MESSAGE_TOKEN							PROP_TAG( PT_BINARY,	0x0C03)
#define PR_NDR_REASON_CODE							PROP_TAG( PT_LONG,		0x0C04)
#define PR_NDR_DIAG_CODE							PROP_TAG( PT_LONG,		0x0C05)
#define PR_NON_RECEIPT_NOTIFICATION_REQUESTED		PROP_TAG( PT_BOOLEAN,	0x0C06)
#define PR_DELIVERY_POINT							PROP_TAG( PT_LONG,		0x0C07)

#define PR_ORIGINATOR_NON_DELIVERY_REPORT_REQUESTED	PROP_TAG( PT_BOOLEAN,	0x0C08)
#define PR_ORIGINATOR_REQUESTED_ALTERNATE_RECIPIENT	PROP_TAG( PT_BINARY,	0x0C09)
#define PR_PHYSICAL_DELIVERY_BUREAU_FAX_DELIVERY	PROP_TAG( PT_BOOLEAN,	0x0C0A)
#define PR_PHYSICAL_DELIVERY_MODE					PROP_TAG( PT_LONG,		0x0C0B)
#define PR_PHYSICAL_DELIVERY_REPORT_REQUEST			PROP_TAG( PT_LONG,		0x0C0C)
#define PR_PHYSICAL_FORWARDING_ADDRESS				PROP_TAG( PT_BINARY,	0x0C0D)
#define PR_PHYSICAL_FORWARDING_ADDRESS_REQUESTED	PROP_TAG( PT_BOOLEAN,	0x0C0E)
#define PR_PHYSICAL_FORWARDING_PROHIBITED			PROP_TAG( PT_BOOLEAN,	0x0C0F)
#define PR_PHYSICAL_RENDITION_ATTRIBUTES			PROP_TAG( PT_BINARY,	0x0C10)
#define PR_PROOF_OF_DELIVERY						PROP_TAG( PT_BINARY,	0x0C11)
#define PR_PROOF_OF_DELIVERY_REQUESTED				PROP_TAG( PT_BOOLEAN,	0x0C12)
#define PR_RECIPIENT_CERTIFICATE					PROP_TAG( PT_BINARY,	0x0C13)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE				PROP_TAG( PT_TSTRING,	0x0C14)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE_W			PROP_TAG( PT_UNICODE,	0x0C14)
#define PR_RECIPIENT_NUMBER_FOR_ADVICE_A			PROP_TAG( PT_STRING8,	0x0C14)
#define PR_RECIPIENT_TYPE							PROP_TAG( PT_LONG,		0x0C15)
#define PR_REGISTERED_MAIL_TYPE						PROP_TAG( PT_LONG,		0x0C16)
#define PR_REPLY_REQUESTED							PROP_TAG( PT_BOOLEAN,	0x0C17)
#define PR_REQUESTED_DELIVERY_METHOD				PROP_TAG( PT_LONG,		0x0C18)
#define PR_SENDER_ENTRYID							PROP_TAG( PT_BINARY,	0x0C19)
#define PR_SENDER_NAME								PROP_TAG( PT_TSTRING,	0x0C1A)
#define PR_SENDER_NAME_W							PROP_TAG( PT_UNICODE,	0x0C1A)
#define PR_SENDER_NAME_A							PROP_TAG( PT_STRING8,	0x0C1A)
#define PR_SUPPLEMENTARY_INFO						PROP_TAG( PT_TSTRING,	0x0C1B)
#define PR_SUPPLEMENTARY_INFO_W						PROP_TAG( PT_UNICODE,	0x0C1B)
#define PR_SUPPLEMENTARY_INFO_A						PROP_TAG( PT_STRING8,	0x0C1B)
#define PR_TYPE_OF_MTS_USER							PROP_TAG( PT_LONG,		0x0C1C)
#define PR_SENDER_SEARCH_KEY						PROP_TAG( PT_BINARY,	0x0C1D)
#define PR_SENDER_ADDRTYPE							PROP_TAG( PT_TSTRING,	0x0C1E)
#define PR_SENDER_ADDRTYPE_W						PROP_TAG( PT_UNICODE,	0x0C1E)
#define PR_SENDER_ADDRTYPE_A						PROP_TAG( PT_STRING8,	0x0C1E)
#define PR_SENDER_EMAIL_ADDRESS						PROP_TAG( PT_TSTRING,	0x0C1F)
#define PR_SENDER_EMAIL_ADDRESS_W					PROP_TAG( PT_UNICODE,	0x0C1F)
#define PR_SENDER_EMAIL_ADDRESS_A					PROP_TAG( PT_STRING8,	0x0C1F)

/*
 *	Message non-transmittable properties
 */

/*
 * The two tags, PR_MESSAGE_RECIPIENTS and PR_MESSAGE_ATTACHMENTS,
 * are to be used in the exclude list passed to
 * IMessage::CopyTo when the caller wants either the recipients or attachments
 * of the message to not get copied.  It is also used in the ProblemArray
 * return from IMessage::CopyTo when an error is encountered copying them
 */

#define PR_CURRENT_VERSION							PROP_TAG( PT_I8,		0x0E00)
#define PR_DELETE_AFTER_SUBMIT						PROP_TAG( PT_BOOLEAN,	0x0E01)
#define PR_DISPLAY_BCC								PROP_TAG( PT_TSTRING,	0x0E02)
#define PR_DISPLAY_BCC_W							PROP_TAG( PT_UNICODE,	0x0E02)
#define PR_DISPLAY_BCC_A							PROP_TAG( PT_STRING8,	0x0E02)
#define PR_DISPLAY_CC								PROP_TAG( PT_TSTRING,	0x0E03)
#define PR_DISPLAY_CC_W								PROP_TAG( PT_UNICODE,	0x0E03)
#define PR_DISPLAY_CC_A								PROP_TAG( PT_STRING8,	0x0E03)
#define PR_DISPLAY_TO								PROP_TAG( PT_TSTRING,	0x0E04)
#define PR_DISPLAY_TO_W								PROP_TAG( PT_UNICODE,	0x0E04)
#define PR_DISPLAY_TO_A								PROP_TAG( PT_STRING8,	0x0E04)
#define PR_PARENT_DISPLAY							PROP_TAG( PT_TSTRING,	0x0E05)
#define PR_PARENT_DISPLAY_W							PROP_TAG( PT_UNICODE,	0x0E05)
#define PR_PARENT_DISPLAY_A							PROP_TAG( PT_STRING8,	0x0E05)
#define PR_MESSAGE_DELIVERY_TIME					PROP_TAG( PT_SYSTIME,	0x0E06)
#define PR_MESSAGE_FLAGS							PROP_TAG( PT_LONG,		0x0E07)
#define PR_MESSAGE_SIZE								PROP_TAG( PT_LONG,		0x0E08)
#define PR_PARENT_ENTRYID							PROP_TAG( PT_BINARY,	0x0E09)
#define PR_SENTMAIL_ENTRYID							PROP_TAG( PT_BINARY,	0x0E0A)
#define PR_CORRELATE								PROP_TAG( PT_BOOLEAN,	0x0E0C)
#define PR_CORRELATE_MTSID							PROP_TAG( PT_BINARY,	0x0E0D)
#define PR_DISCRETE_VALUES							PROP_TAG( PT_BOOLEAN,	0x0E0E)
#define PR_RESPONSIBILITY							PROP_TAG( PT_BOOLEAN,	0x0E0F)
#define	PR_SPOOLER_STATUS							PROP_TAG( PT_LONG,		0x0E10)
#define	PR_TRANSPORT_STATUS							PROP_TAG( PT_LONG,		0x0E11)
#define PR_MESSAGE_RECIPIENTS						PROP_TAG( PT_OBJECT,	0x0E12)
#define PR_MESSAGE_ATTACHMENTS						PROP_TAG( PT_OBJECT,	0x0E13)
#define PR_SUBMIT_FLAGS								PROP_TAG( PT_LONG,		0x0E14)
#define PR_RECIPIENT_STATUS							PROP_TAG( PT_LONG,		0x0E15)
#define	PR_TRANSPORT_KEY							PROP_TAG( PT_LONG,		0x0E16)
#define PR_MSG_STATUS								PROP_TAG( PT_LONG,		0x0E17)
#define	PR_MESSAGE_DOWNLOAD_TIME					PROP_TAG( PT_LONG,		0x0E18)
#define PR_CREATION_VERSION							PROP_TAG( PT_I8,		0x0E19)
#define PR_MODIFY_VERSION							PROP_TAG( PT_I8,		0x0E1A)
#define PR_HASATTACH								PROP_TAG( PT_BOOLEAN,	0x0E1B)
#define PR_BODY_CRC									PROP_TAG( PT_LONG,      0x0E1C)
#define PR_NORMALIZED_SUBJECT						PROP_TAG( PT_TSTRING,	0x0E1D)
#define PR_NORMALIZED_SUBJECT_W						PROP_TAG( PT_UNICODE,	0x0E1D)
#define PR_NORMALIZED_SUBJECT_A						PROP_TAG( PT_STRING8,	0x0E1D)
#define PR_RTF_IN_SYNC								PROP_TAG( PT_BOOLEAN,	0x0E1F)
#define PR_ATTACH_SIZE								PROP_TAG( PT_LONG,		0x0E20)
#define PR_ATTACH_NUM								PROP_TAG( PT_LONG,		0x0E21)
#define PR_PREPROCESS								PROP_TAG( PT_BOOLEAN,	0x0E22)

/* PR_ORIGINAL_DISPLAY_TO, _CC, and _BCC moved to transmittible range 03/09/95 */

#define PR_ORIGINATING_MTA_CERTIFICATE				PROP_TAG( PT_BINARY,	0x0E25)
#define PR_PROOF_OF_SUBMISSION						PROP_TAG( PT_BINARY,	0x0E26)


/*
 * The range of non-message and non-recipient property IDs (0x3000 - 0x3FFF) is
 * further broken down into ranges to make assigning new property IDs easier.
 *
 *	From	To		Kind of property
 *	--------------------------------
 *	3000	32FF	MAPI_defined common property
 *	3200	33FF	MAPI_defined form property
 *	3400	35FF	MAPI_defined message store property
 *	3600	36FF	MAPI_defined Folder or AB Container property
 *	3700	38FF	MAPI_defined attachment property
 *	3900	39FF	MAPI_defined address book property
 *	3A00	3BFF	MAPI_defined mailuser property
 *	3C00	3CFF	MAPI_defined DistList property
 *	3D00	3DFF	MAPI_defined Profile Section property
 *	3E00	3EFF	MAPI_defined Status property
 *	3F00	3FFF	MAPI_defined display table property
 */

/*
 *	Properties common to numerous MAPI objects.
 *
 *	Those properties that can appear on messages are in the
 *	non-transmittable range for messages. They start at the high
 *	end of that range and work down.
 *
 *	Properties that never appear on messages are defined in the common
 *	property range (see above).
 */

/*
 * properties that are common to multiple objects (including message objects)
 * -- these ids are in the non-transmittable range
 */

#define PR_ENTRYID									PROP_TAG( PT_BINARY,	0x0FFF)
#define PR_OBJECT_TYPE								PROP_TAG( PT_LONG,		0x0FFE)
#define PR_ICON										PROP_TAG( PT_BINARY,	0x0FFD)
#define PR_MINI_ICON								PROP_TAG( PT_BINARY,	0x0FFC)
#define PR_STORE_ENTRYID							PROP_TAG( PT_BINARY,	0x0FFB)
#define PR_STORE_RECORD_KEY							PROP_TAG( PT_BINARY,	0x0FFA)
#define PR_RECORD_KEY								PROP_TAG( PT_BINARY,	0x0FF9)
#define PR_MAPPING_SIGNATURE						PROP_TAG( PT_BINARY,	0x0FF8)
#define PR_ACCESS_LEVEL								PROP_TAG( PT_LONG,		0x0FF7)
#define PR_INSTANCE_KEY								PROP_TAG( PT_BINARY,	0x0FF6)
#define PR_ROW_TYPE									PROP_TAG( PT_LONG,		0x0FF5)
#define PR_ACCESS									PROP_TAG( PT_LONG,		0x0FF4)

/*
 * properties that are common to multiple objects (usually not including message objects)
 * -- these ids are in the transmittable range
 */

#define PR_ROWID									PROP_TAG( PT_LONG,		0x3000)
#define PR_DISPLAY_NAME								PROP_TAG( PT_TSTRING,	0x3001)
#define PR_DISPLAY_NAME_W							PROP_TAG( PT_UNICODE,	0x3001)
#define PR_DISPLAY_NAME_A							PROP_TAG( PT_STRING8,	0x3001)
#define PR_ADDRTYPE									PROP_TAG( PT_TSTRING,	0x3002)
#define PR_ADDRTYPE_W								PROP_TAG( PT_UNICODE,	0x3002)
#define PR_ADDRTYPE_A								PROP_TAG( PT_STRING8,	0x3002)
#define PR_EMAIL_ADDRESS							PROP_TAG( PT_TSTRING,	0x3003)
#define PR_EMAIL_ADDRESS_W							PROP_TAG( PT_UNICODE,	0x3003)
#define PR_EMAIL_ADDRESS_A							PROP_TAG( PT_STRING8,	0x3003)
#define PR_COMMENT									PROP_TAG( PT_TSTRING,	0x3004)
#define PR_COMMENT_W								PROP_TAG( PT_UNICODE,	0x3004)
#define PR_COMMENT_A								PROP_TAG( PT_STRING8,	0x3004)
#define PR_DEPTH									PROP_TAG( PT_LONG,		0x3005)
#define PR_PROVIDER_DISPLAY							PROP_TAG( PT_TSTRING,	0x3006)
#define PR_PROVIDER_DISPLAY_W						PROP_TAG( PT_UNICODE,	0x3006)
#define PR_PROVIDER_DISPLAY_A						PROP_TAG( PT_STRING8,	0x3006)
#define PR_CREATION_TIME							PROP_TAG( PT_SYSTIME,	0x3007)
#define PR_LAST_MODIFICATION_TIME					PROP_TAG( PT_SYSTIME,	0x3008)
#define PR_RESOURCE_FLAGS							PROP_TAG( PT_LONG,		0x3009)
#define PR_PROVIDER_DLL_NAME						PROP_TAG( PT_TSTRING,	0x300A)
#define PR_PROVIDER_DLL_NAME_W						PROP_TAG( PT_UNICODE,	0x300A)
#define PR_PROVIDER_DLL_NAME_A						PROP_TAG( PT_STRING8,	0x300A)
#define PR_SEARCH_KEY								PROP_TAG( PT_BINARY,	0x300B)
#define PR_PROVIDER_UID								PROP_TAG( PT_BINARY,	0x300C)
#define PR_PROVIDER_ORDINAL							PROP_TAG( PT_LONG,		0x300D)

/*
 *  MAPI Form properties
 */
#define PR_FORM_VERSION								PROP_TAG(PT_TSTRING,	0x3301)
#define PR_FORM_VERSION_W							PROP_TAG(PT_UNICODE,	0x3301)
#define PR_FORM_VERSION_A							PROP_TAG(PT_STRING8,	0x3301)
#define PR_FORM_CLSID								PROP_TAG(PT_CLSID,		0x3302)
#define PR_FORM_CONTACT_NAME						PROP_TAG(PT_TSTRING,	0x3303)
#define PR_FORM_CONTACT_NAME_W						PROP_TAG(PT_UNICODE,	0x3303)
#define PR_FORM_CONTACT_NAME_A						PROP_TAG(PT_STRING8,	0x3303)
#define PR_FORM_CATEGORY							PROP_TAG(PT_TSTRING,	0x3304)
#define PR_FORM_CATEGORY_W							PROP_TAG(PT_UNICODE,	0x3304)
#define PR_FORM_CATEGORY_A							PROP_TAG(PT_STRING8,	0x3304)
#define PR_FORM_CATEGORY_SUB						PROP_TAG(PT_TSTRING,	0x3305)
#define PR_FORM_CATEGORY_SUB_W						PROP_TAG(PT_UNICODE,	0x3305)
#define PR_FORM_CATEGORY_SUB_A						PROP_TAG(PT_STRING8,	0x3305)
#define PR_FORM_HOST_MAP							PROP_TAG(PT_MV_LONG,	0x3306)
#define PR_FORM_HIDDEN								PROP_TAG(PT_BOOLEAN,	0x3307)
#define PR_FORM_DESIGNER_NAME						PROP_TAG(PT_TSTRING,	0x3308)
#define PR_FORM_DESIGNER_NAME_W						PROP_TAG(PT_UNICODE,	0x3308)
#define PR_FORM_DESIGNER_NAME_A						PROP_TAG(PT_STRING8,	0x3308)
#define PR_FORM_DESIGNER_GUID						PROP_TAG(PT_CLSID,		0x3309)
#define PR_FORM_MESSAGE_BEHAVIOR					PROP_TAG(PT_LONG,		0x330A)

/*
 *	Message store properties
 */

#define PR_DEFAULT_STORE							PROP_TAG( PT_BOOLEAN,	0x3400)
#define PR_STORE_SUPPORT_MASK						PROP_TAG( PT_LONG,		0x340D)
#define PR_STORE_STATE								PROP_TAG( PT_LONG,		0x340E)

#define PR_IPM_SUBTREE_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x3410)
#define PR_IPM_OUTBOX_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x3411)
#define PR_IPM_WASTEBASKET_SEARCH_KEY				PROP_TAG( PT_BINARY,	0x3412)
#define PR_IPM_SENTMAIL_SEARCH_KEY					PROP_TAG( PT_BINARY,	0x3413)
#define PR_MDB_PROVIDER								PROP_TAG( PT_BINARY,	0x3414)
#define PR_RECEIVE_FOLDER_SETTINGS					PROP_TAG( PT_OBJECT,	0x3415)

#define PR_VALID_FOLDER_MASK						PROP_TAG( PT_LONG,		0x35DF)
#define PR_IPM_SUBTREE_ENTRYID						PROP_TAG( PT_BINARY,	0x35E0)

#define PR_IPM_OUTBOX_ENTRYID						PROP_TAG( PT_BINARY,	0x35E2)
#define PR_IPM_WASTEBASKET_ENTRYID					PROP_TAG( PT_BINARY,	0x35E3)
#define PR_IPM_SENTMAIL_ENTRYID						PROP_TAG( PT_BINARY,	0x35E4)
#define PR_VIEWS_ENTRYID							PROP_TAG( PT_BINARY,	0x35E5)
#define PR_COMMON_VIEWS_ENTRYID						PROP_TAG( PT_BINARY,	0x35E6)
#define PR_FINDER_ENTRYID							PROP_TAG( PT_BINARY,	0x35E7)

/* Proptags 0x35E8-0x35FF reserved for folders "guaranteed" by PR_VALID_FOLDER_MASK */


/*
 *	Folder and AB Container properties
 */

#define PR_CONTAINER_FLAGS							PROP_TAG( PT_LONG,		0x3600)
#define PR_FOLDER_TYPE								PROP_TAG( PT_LONG,		0x3601)
#define PR_CONTENT_COUNT							PROP_TAG( PT_LONG,		0x3602)
#define PR_CONTENT_UNREAD							PROP_TAG( PT_LONG,		0x3603)
#define PR_CREATE_TEMPLATES							PROP_TAG( PT_OBJECT,	0x3604)
#define PR_DETAILS_TABLE							PROP_TAG( PT_OBJECT,	0x3605)
#define PR_SEARCH									PROP_TAG( PT_OBJECT,	0x3607)
#define PR_SELECTABLE								PROP_TAG( PT_BOOLEAN,	0x3609)
#define PR_SUBFOLDERS								PROP_TAG( PT_BOOLEAN,	0x360A)
#define PR_STATUS									PROP_TAG( PT_LONG,		0x360B)
#define PR_ANR										PROP_TAG( PT_TSTRING,	0x360C)
#define PR_ANR_W									PROP_TAG( PT_UNICODE,	0x360C)
#define PR_ANR_A									PROP_TAG( PT_STRING8,	0x360C)
#define PR_CONTENTS_SORT_ORDER						PROP_TAG( PT_MV_LONG,	0x360D)
#define PR_CONTAINER_HIERARCHY						PROP_TAG( PT_OBJECT,	0x360E)
#define PR_CONTAINER_CONTENTS						PROP_TAG( PT_OBJECT,	0x360F)
#define PR_FOLDER_ASSOCIATED_CONTENTS				PROP_TAG( PT_OBJECT,	0x3610)
#define PR_DEF_CREATE_DL							PROP_TAG( PT_BINARY,	0x3611)
#define PR_DEF_CREATE_MAILUSER						PROP_TAG( PT_BINARY,	0x3612)
#define	PR_CONTAINER_CLASS							PROP_TAG( PT_TSTRING,	0x3613)
#define	PR_CONTAINER_CLASS_W						PROP_TAG( PT_UNICODE,	0x3613)
#define	PR_CONTAINER_CLASS_A						PROP_TAG( PT_STRING8,	0x3613)
#define	PR_CONTAINER_MODIFY_VERSION					PROP_TAG( PT_I8,		0x3614)
#define PR_AB_PROVIDER_ID							PROP_TAG( PT_BINARY,	0x3615)
#define PR_DEFAULT_VIEW_ENTRYID						PROP_TAG( PT_BINARY,	0x3616)
#define	PR_ASSOC_CONTENT_COUNT						PROP_TAG( PT_LONG,		0x3617)

/* Reserved 0x36C0-0x36FF */

/*
 *	Attachment properties
 */

#define PR_ATTACHMENT_X400_PARAMETERS				PROP_TAG( PT_BINARY,	0x3700)
#define PR_ATTACH_DATA_OBJ							PROP_TAG( PT_OBJECT,	0x3701)
#define PR_ATTACH_DATA_BIN							PROP_TAG( PT_BINARY,	0x3701)
#define PR_ATTACH_ENCODING							PROP_TAG( PT_BINARY,	0x3702)
#define PR_ATTACH_EXTENSION							PROP_TAG( PT_TSTRING,	0x3703)
#define PR_ATTACH_EXTENSION_W						PROP_TAG( PT_UNICODE,	0x3703)
#define PR_ATTACH_EXTENSION_A						PROP_TAG( PT_STRING8,	0x3703)
#define PR_ATTACH_FILENAME							PROP_TAG( PT_TSTRING,	0x3704)
#define PR_ATTACH_FILENAME_W						PROP_TAG( PT_UNICODE,	0x3704)
#define PR_ATTACH_FILENAME_A						PROP_TAG( PT_STRING8,	0x3704)
#define PR_ATTACH_METHOD							PROP_TAG( PT_LONG,		0x3705)
#define PR_ATTACH_LONG_FILENAME	 					PROP_TAG( PT_TSTRING,	0x3707)
#define PR_ATTACH_LONG_FILENAME_W					PROP_TAG( PT_UNICODE,	0x3707)
#define PR_ATTACH_LONG_FILENAME_A					PROP_TAG( PT_STRING8,	0x3707)
#define PR_ATTACH_PATHNAME							PROP_TAG( PT_TSTRING,	0x3708)
#define PR_ATTACH_PATHNAME_W						PROP_TAG( PT_UNICODE,	0x3708)
#define PR_ATTACH_PATHNAME_A						PROP_TAG( PT_STRING8,	0x3708)
#define PR_ATTACH_RENDERING							PROP_TAG( PT_BINARY,    0x3709)
#define PR_ATTACH_TAG								PROP_TAG( PT_BINARY,	0x370A)
#define PR_RENDERING_POSITION						PROP_TAG( PT_LONG,		0x370B)
#define PR_ATTACH_TRANSPORT_NAME					PROP_TAG( PT_TSTRING,	0x370C)
#define PR_ATTACH_TRANSPORT_NAME_W					PROP_TAG( PT_UNICODE,	0x370C)
#define PR_ATTACH_TRANSPORT_NAME_A					PROP_TAG( PT_STRING8,	0x370C)
#define PR_ATTACH_LONG_PATHNAME	 					PROP_TAG( PT_TSTRING,	0x370D)
#define PR_ATTACH_LONG_PATHNAME_W					PROP_TAG( PT_UNICODE,	0x370D)
#define PR_ATTACH_LONG_PATHNAME_A					PROP_TAG( PT_STRING8,	0x370D)
#define PR_ATTACH_MIME_TAG							PROP_TAG( PT_TSTRING,	0x370E)
#define PR_ATTACH_MIME_TAG_W						PROP_TAG( PT_UNICODE,	0x370E)
#define PR_ATTACH_MIME_TAG_A						PROP_TAG( PT_STRING8,	0x370E)
#define	PR_ATTACH_ADDITIONAL_INFO					PROP_TAG( PT_BINARY,	0x370F)

/*
 *  AB Object properties
 */

#define PR_DISPLAY_TYPE								PROP_TAG( PT_LONG,		0x3900)
#define PR_TEMPLATEID								PROP_TAG( PT_BINARY,	0x3902)
#define PR_PRIMARY_CAPABILITY						PROP_TAG( PT_BINARY,	0x3904)


/*
 *	Mail user properties
 */
#define PR_7BIT_DISPLAY_NAME						PROP_TAG( PT_STRING8,	0x39FF)
#define PR_ACCOUNT									PROP_TAG( PT_TSTRING,	0x3A00)
#define PR_ACCOUNT_W								PROP_TAG( PT_UNICODE,	0x3A00)
#define PR_ACCOUNT_A								PROP_TAG( PT_STRING8,	0x3A00)
#define PR_ALTERNATE_RECIPIENT						PROP_TAG( PT_BINARY,	0x3A01)
#define PR_CALLBACK_TELEPHONE_NUMBER				PROP_TAG( PT_TSTRING,	0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A02)
#define PR_CALLBACK_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A02)
#define PR_CONVERSION_PROHIBITED					PROP_TAG( PT_BOOLEAN,	0x3A03)
#define PR_DISCLOSE_RECIPIENTS						PROP_TAG( PT_BOOLEAN,	0x3A04)
#define PR_GENERATION								PROP_TAG( PT_TSTRING,	0x3A05)
#define PR_GENERATION_W								PROP_TAG( PT_UNICODE,	0x3A05)
#define PR_GENERATION_A								PROP_TAG( PT_STRING8,	0x3A05)
#define PR_GIVEN_NAME								PROP_TAG( PT_TSTRING,	0x3A06)
#define PR_GIVEN_NAME_W								PROP_TAG( PT_UNICODE,	0x3A06)
#define PR_GIVEN_NAME_A								PROP_TAG( PT_STRING8,	0x3A06)
#define PR_GOVERNMENT_ID_NUMBER						PROP_TAG( PT_TSTRING,	0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A07)
#define PR_GOVERNMENT_ID_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A07)
#define PR_BUSINESS_TELEPHONE_NUMBER				PROP_TAG( PT_TSTRING,	0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A08)
#define PR_BUSINESS_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A08)
#define PR_OFFICE_TELEPHONE_NUMBER					PR_BUSINESS_TELEPHONE_NUMBER
#define PR_OFFICE_TELEPHONE_NUMBER_W				PR_BUSINESS_TELEPHONE_NUMBER_W
#define PR_OFFICE_TELEPHONE_NUMBER_A				PR_BUSINESS_TELEPHONE_NUMBER_A
#define PR_HOME_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A09)
#define PR_HOME_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A09)
#define PR_INITIALS									PROP_TAG( PT_TSTRING,	0x3A0A)
#define PR_INITIALS_W								PROP_TAG( PT_UNICODE,	0x3A0A)
#define PR_INITIALS_A								PROP_TAG( PT_STRING8,	0x3A0A)
#define PR_KEYWORD									PROP_TAG( PT_TSTRING,	0x3A0B)
#define PR_KEYWORD_W								PROP_TAG( PT_UNICODE,	0x3A0B)
#define PR_KEYWORD_A								PROP_TAG( PT_STRING8,	0x3A0B)
#define PR_LANGUAGE									PROP_TAG( PT_TSTRING,	0x3A0C)
#define PR_LANGUAGE_W								PROP_TAG( PT_UNICODE,	0x3A0C)
#define PR_LANGUAGE_A								PROP_TAG( PT_STRING8,	0x3A0C)
#define PR_LOCATION									PROP_TAG( PT_TSTRING,	0x3A0D)
#define PR_LOCATION_W								PROP_TAG( PT_UNICODE,	0x3A0D)
#define PR_LOCATION_A								PROP_TAG( PT_STRING8,	0x3A0D)
#define PR_MAIL_PERMISSION							PROP_TAG( PT_BOOLEAN,	0x3A0E)
#define PR_MHS_COMMON_NAME							PROP_TAG( PT_TSTRING,	0x3A0F)
#define PR_MHS_COMMON_NAME_W						PROP_TAG( PT_UNICODE,	0x3A0F)
#define PR_MHS_COMMON_NAME_A						PROP_TAG( PT_STRING8,	0x3A0F)
#define PR_ORGANIZATIONAL_ID_NUMBER					PROP_TAG( PT_TSTRING,	0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A10)
#define PR_ORGANIZATIONAL_ID_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A10)
#define PR_SURNAME									PROP_TAG( PT_TSTRING,	0x3A11)
#define PR_SURNAME_W								PROP_TAG( PT_UNICODE,	0x3A11)
#define PR_SURNAME_A								PROP_TAG( PT_STRING8,	0x3A11)
#define PR_ORIGINAL_ENTRYID							PROP_TAG( PT_BINARY,	0x3A12)
#define PR_ORIGINAL_DISPLAY_NAME					PROP_TAG( PT_TSTRING,	0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_W					PROP_TAG( PT_UNICODE,	0x3A13)
#define PR_ORIGINAL_DISPLAY_NAME_A					PROP_TAG( PT_STRING8,	0x3A13)
#define PR_ORIGINAL_SEARCH_KEY						PROP_TAG( PT_BINARY,	0x3A14)
#define PR_POSTAL_ADDRESS							PROP_TAG( PT_TSTRING,	0x3A15)
#define PR_POSTAL_ADDRESS_W							PROP_TAG( PT_UNICODE,	0x3A15)
#define PR_POSTAL_ADDRESS_A							PROP_TAG( PT_STRING8,	0x3A15)
#define PR_COMPANY_NAME								PROP_TAG( PT_TSTRING,	0x3A16)
#define PR_COMPANY_NAME_W							PROP_TAG( PT_UNICODE,	0x3A16)
#define PR_COMPANY_NAME_A							PROP_TAG( PT_STRING8,	0x3A16)
#define PR_TITLE									PROP_TAG( PT_TSTRING,	0x3A17)
#define PR_TITLE_W									PROP_TAG( PT_UNICODE,	0x3A17)
#define PR_TITLE_A									PROP_TAG( PT_STRING8,	0x3A17)
#define PR_DEPARTMENT_NAME							PROP_TAG( PT_TSTRING,	0x3A18)
#define PR_DEPARTMENT_NAME_W						PROP_TAG( PT_UNICODE,	0x3A18)
#define PR_DEPARTMENT_NAME_A						PROP_TAG( PT_STRING8,	0x3A18)
#define PR_OFFICE_LOCATION							PROP_TAG( PT_TSTRING,	0x3A19)
#define PR_OFFICE_LOCATION_W						PROP_TAG( PT_UNICODE,	0x3A19)
#define PR_OFFICE_LOCATION_A						PROP_TAG( PT_STRING8,	0x3A19)
#define PR_PRIMARY_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A1A)
#define PR_PRIMARY_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A1A)
#define PR_BUSINESS2_TELEPHONE_NUMBER				PROP_TAG( PT_TSTRING,	0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A1B)
#define PR_BUSINESS2_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A1B)
#define PR_OFFICE2_TELEPHONE_NUMBER					PR_BUSINESS2_TELEPHONE_NUMBER
#define PR_OFFICE2_TELEPHONE_NUMBER_W				PR_BUSINESS2_TELEPHONE_NUMBER_W
#define PR_OFFICE2_TELEPHONE_NUMBER_A				PR_BUSINESS2_TELEPHONE_NUMBER_A
#define PR_MOBILE_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A1C)
#define PR_MOBILE_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A1C)
#define PR_CELLULAR_TELEPHONE_NUMBER				PR_MOBILE_TELEPHONE_NUMBER
#define PR_CELLULAR_TELEPHONE_NUMBER_W				PR_MOBILE_TELEPHONE_NUMBER_W
#define PR_CELLULAR_TELEPHONE_NUMBER_A				PR_MOBILE_TELEPHONE_NUMBER_A
#define PR_RADIO_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A1D)
#define PR_RADIO_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A1D)
#define PR_CAR_TELEPHONE_NUMBER						PROP_TAG( PT_TSTRING,	0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A1E)
#define PR_CAR_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A1E)
#define PR_OTHER_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A1F)
#define PR_OTHER_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A1F)
#define PR_TRANSMITABLE_DISPLAY_NAME				PROP_TAG( PT_TSTRING,	0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_W				PROP_TAG( PT_UNICODE,	0x3A20)
#define PR_TRANSMITABLE_DISPLAY_NAME_A				PROP_TAG( PT_STRING8,	0x3A20)
#define PR_PAGER_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A21)
#define PR_PAGER_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A21)
#define PR_BEEPER_TELEPHONE_NUMBER					PR_PAGER_TELEPHONE_NUMBER
#define PR_BEEPER_TELEPHONE_NUMBER_W				PR_PAGER_TELEPHONE_NUMBER_W
#define PR_BEEPER_TELEPHONE_NUMBER_A				PR_PAGER_TELEPHONE_NUMBER_A
#define PR_USER_CERTIFICATE							PROP_TAG( PT_BINARY,	0x3A22)
#define PR_PRIMARY_FAX_NUMBER						PROP_TAG( PT_TSTRING,	0x3A23)
#define PR_PRIMARY_FAX_NUMBER_W						PROP_TAG( PT_UNICODE,	0x3A23)
#define PR_PRIMARY_FAX_NUMBER_A						PROP_TAG( PT_STRING8,	0x3A23)
#define PR_BUSINESS_FAX_NUMBER						PROP_TAG( PT_TSTRING,	0x3A24)
#define PR_BUSINESS_FAX_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A24)
#define PR_BUSINESS_FAX_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A24)
#define PR_HOME_FAX_NUMBER							PROP_TAG( PT_TSTRING,	0x3A25)
#define PR_HOME_FAX_NUMBER_W						PROP_TAG( PT_UNICODE,	0x3A25)
#define PR_HOME_FAX_NUMBER_A						PROP_TAG( PT_STRING8,	0x3A25)
#define PR_COUNTRY									PROP_TAG( PT_TSTRING,	0x3A26)
#define PR_COUNTRY_W								PROP_TAG( PT_UNICODE,	0x3A26)
#define PR_COUNTRY_A								PROP_TAG( PT_STRING8,	0x3A26)
#define PR_BUSINESS_ADDRESS_COUNTRY					PR_COUNTRY
#define PR_BUSINESS_ADDRESS_COUNTRY_W				PR_COUNTRY_W
#define PR_BUSINESS_ADDRESS_COUNTRY_A				PR_COUNTRY_A

#define PR_LOCALITY									PROP_TAG( PT_TSTRING,	0x3A27)
#define PR_LOCALITY_W								PROP_TAG( PT_UNICODE,	0x3A27)
#define PR_LOCALITY_A								PROP_TAG( PT_STRING8,	0x3A27)
#define PR_BUSINESS_ADDRESS_CITY					PR_LOCALITY
#define PR_BUSINESS_ADDRESS_CITY_W					PR_LOCALITY_W
#define PR_BUSINESS_ADDRESS_CITY_A					PR_LOCALITY_A

#define PR_STATE_OR_PROVINCE						PROP_TAG( PT_TSTRING,	0x3A28)
#define PR_STATE_OR_PROVINCE_W						PROP_TAG( PT_UNICODE,	0x3A28)
#define PR_STATE_OR_PROVINCE_A						PROP_TAG( PT_STRING8,	0x3A28)
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE		PR_STATE_OR_PROVINCE
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_W		PR_STATE_OR_PROVINCE_W
#define PR_BUSINESS_ADDRESS_STATE_OR_PROVINCE_A		PR_STATE_OR_PROVINCE_A

#define PR_STREET_ADDRESS							PROP_TAG( PT_TSTRING,	0x3A29)
#define PR_STREET_ADDRESS_W							PROP_TAG( PT_UNICODE,	0x3A29)
#define PR_STREET_ADDRESS_A							PROP_TAG( PT_STRING8,	0x3A29)
#define PR_BUSINESS_ADDRESS_STREET					PR_STREET_ADDRESS
#define PR_BUSINESS_ADDRESS_STREET_W				PR_STREET_ADDRESS_W
#define PR_BUSINESS_ADDRESS_STREET_A				PR_STREET_ADDRESS_A

#define PR_POSTAL_CODE								PROP_TAG( PT_TSTRING,	0x3A2A)
#define PR_POSTAL_CODE_W							PROP_TAG( PT_UNICODE,	0x3A2A)
#define PR_POSTAL_CODE_A							PROP_TAG( PT_STRING8,	0x3A2A)
#define PR_BUSINESS_ADDRESS_POSTAL_CODE				PR_POSTAL_CODE
#define PR_BUSINESS_ADDRESS_POSTAL_CODE_W			PR_POSTAL_CODE_W
#define PR_BUSINESS_ADDRESS_POSTAL_CODE_A			PR_POSTAL_CODE_A


#define PR_POST_OFFICE_BOX							PROP_TAG( PT_TSTRING,	0x3A2B)
#define PR_POST_OFFICE_BOX_W						PROP_TAG( PT_UNICODE,	0x3A2B)
#define PR_POST_OFFICE_BOX_A						PROP_TAG( PT_STRING8,	0x3A2B)
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX			PR_POST_OFFICE_BOX
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_W		PR_POST_OFFICE_BOX_W
#define PR_BUSINESS_ADDRESS_POST_OFFICE_BOX_A		PR_POST_OFFICE_BOX_A


#define PR_TELEX_NUMBER								PROP_TAG( PT_TSTRING,	0x3A2C)
#define PR_TELEX_NUMBER_W							PROP_TAG( PT_UNICODE,	0x3A2C)
#define PR_TELEX_NUMBER_A							PROP_TAG( PT_STRING8,	0x3A2C)
#define PR_ISDN_NUMBER								PROP_TAG( PT_TSTRING,	0x3A2D)
#define PR_ISDN_NUMBER_W							PROP_TAG( PT_UNICODE,	0x3A2D)
#define PR_ISDN_NUMBER_A							PROP_TAG( PT_STRING8,	0x3A2D)
#define PR_ASSISTANT_TELEPHONE_NUMBER				PROP_TAG( PT_TSTRING,	0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_W				PROP_TAG( PT_UNICODE,	0x3A2E)
#define PR_ASSISTANT_TELEPHONE_NUMBER_A				PROP_TAG( PT_STRING8,	0x3A2E)
#define PR_HOME2_TELEPHONE_NUMBER					PROP_TAG( PT_TSTRING,	0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_W					PROP_TAG( PT_UNICODE,	0x3A2F)
#define PR_HOME2_TELEPHONE_NUMBER_A					PROP_TAG( PT_STRING8,	0x3A2F)
#define PR_ASSISTANT								PROP_TAG( PT_TSTRING,	0x3A30)
#define PR_ASSISTANT_W								PROP_TAG( PT_UNICODE,	0x3A30)
#define PR_ASSISTANT_A								PROP_TAG( PT_STRING8,	0x3A30)
#define PR_SEND_RICH_INFO							PROP_TAG( PT_BOOLEAN,	0x3A40)

#define PR_WEDDING_ANNIVERSARY						PROP_TAG( PT_SYSTIME, 0x3A41)
#define PR_BIRTHDAY									PROP_TAG( PT_SYSTIME, 0x3A42)


#define PR_HOBBIES									PROP_TAG( PT_TSTRING, 0x3A43)
#define PR_HOBBIES_W								PROP_TAG( PT_UNICODE, 0x3A43)
#define PR_HOBBIES_A								PROP_TAG( PT_STRING8, 0x3A43)

#define PR_MIDDLE_NAME								PROP_TAG( PT_TSTRING, 0x3A44)
#define PR_MIDDLE_NAME_W							PROP_TAG( PT_UNICODE, 0x3A44)
#define PR_MIDDLE_NAME_A							PROP_TAG( PT_STRING8, 0x3A44)

#define PR_DISPLAY_NAME_PREFIX						PROP_TAG( PT_TSTRING, 0x3A45)
#define PR_DISPLAY_NAME_PREFIX_W					PROP_TAG( PT_UNICODE, 0x3A45)
#define PR_DISPLAY_NAME_PREFIX_A					PROP_TAG( PT_STRING8, 0x3A45)

#define PR_PROFESSION								PROP_TAG( PT_TSTRING, 0x3A46)
#define PR_PROFESSION_W								PROP_TAG( PT_UNICODE, 0x3A46)
#define PR_PROFESSION_A								PROP_TAG( PT_STRING8, 0x3A46)

#define PR_PREFERRED_BY_NAME						PROP_TAG( PT_TSTRING, 0x3A47)
#define PR_PREFERRED_BY_NAME_W						PROP_TAG( PT_UNICODE, 0x3A47)
#define PR_PREFERRED_BY_NAME_A						PROP_TAG( PT_STRING8, 0x3A47)

#define PR_SPOUSE_NAME								PROP_TAG( PT_TSTRING, 0x3A48)
#define PR_SPOUSE_NAME_W							PROP_TAG( PT_UNICODE, 0x3A48)
#define PR_SPOUSE_NAME_A							PROP_TAG( PT_STRING8, 0x3A48)

#define PR_COMPUTER_NETWORK_NAME					PROP_TAG( PT_TSTRING, 0x3A49)
#define PR_COMPUTER_NETWORK_NAME_W					PROP_TAG( PT_UNICODE, 0x3A49)
#define PR_COMPUTER_NETWORK_NAME_A					PROP_TAG( PT_STRING8, 0x3A49)

#define PR_CUSTOMER_ID								PROP_TAG( PT_TSTRING, 0x3A4A)
#define PR_CUSTOMER_ID_W							PROP_TAG( PT_UNICODE, 0x3A4A)
#define PR_CUSTOMER_ID_A							PROP_TAG( PT_STRING8, 0x3A4A)

#define PR_TTYTDD_PHONE_NUMBER						PROP_TAG( PT_TSTRING, 0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_W					PROP_TAG( PT_UNICODE, 0x3A4B)
#define PR_TTYTDD_PHONE_NUMBER_A					PROP_TAG( PT_STRING8, 0x3A4B)

#define PR_FTP_SITE									PROP_TAG( PT_TSTRING, 0x3A4C)
#define PR_FTP_SITE_W								PROP_TAG( PT_UNICODE, 0x3A4C)
#define PR_FTP_SITE_A								PROP_TAG( PT_STRING8, 0x3A4C)

#define PR_GENDER									PROP_TAG( PT_SHORT, 0x3A4D)

#define PR_MANAGER_NAME								PROP_TAG( PT_TSTRING, 0x3A4E)
#define PR_MANAGER_NAME_W							PROP_TAG( PT_UNICODE, 0x3A4E)
#define PR_MANAGER_NAME_A							PROP_TAG( PT_STRING8, 0x3A4E)

#define PR_NICKNAME									PROP_TAG( PT_TSTRING, 0x3A4F)
#define PR_NICKNAME_W								PROP_TAG( PT_UNICODE, 0x3A4F)
#define PR_NICKNAME_A								PROP_TAG( PT_STRING8, 0x3A4F)

#define PR_PERSONAL_HOME_PAGE						PROP_TAG( PT_TSTRING, 0x3A50)
#define PR_PERSONAL_HOME_PAGE_W						PROP_TAG( PT_UNICODE, 0x3A50)
#define PR_PERSONAL_HOME_PAGE_A						PROP_TAG( PT_STRING8, 0x3A50)


#define PR_BUSINESS_HOME_PAGE						PROP_TAG( PT_TSTRING, 0x3A51)
#define PR_BUSINESS_HOME_PAGE_W						PROP_TAG( PT_UNICODE, 0x3A51)
#define PR_BUSINESS_HOME_PAGE_A						PROP_TAG( PT_STRING8, 0x3A51)

#define PR_CONTACT_VERSION							PROP_TAG( PT_CLSID, 0x3A52)
#define PR_CONTACT_ENTRYIDS							PROP_TAG( PT_MV_BINARY, 0x3A53)

#define PR_CONTACT_ADDRTYPES						PROP_TAG( PT_MV_TSTRING, 0x3A54)
#define PR_CONTACT_ADDRTYPES_W						PROP_TAG( PT_MV_UNICODE, 0x3A54)
#define PR_CONTACT_ADDRTYPES_A						PROP_TAG( PT_MV_STRING8, 0x3A54)

#define PR_CONTACT_DEFAULT_ADDRESS_INDEX			PROP_TAG( PT_LONG, 0x3A55)

#define PR_CONTACT_EMAIL_ADDRESSES					PROP_TAG( PT_MV_TSTRING, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_W				PROP_TAG( PT_MV_UNICODE, 0x3A56)
#define PR_CONTACT_EMAIL_ADDRESSES_A				PROP_TAG( PT_MV_STRING8, 0x3A56)


#define PR_COMPANY_MAIN_PHONE_NUMBER				PROP_TAG( PT_TSTRING, 0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_W				PROP_TAG( PT_UNICODE, 0x3A57)
#define PR_COMPANY_MAIN_PHONE_NUMBER_A				PROP_TAG( PT_STRING8, 0x3A57)

#define PR_CHILDRENS_NAMES							PROP_TAG( PT_MV_TSTRING, 0x3A58)
#define PR_CHILDRENS_NAMES_W						PROP_TAG( PT_MV_UNICODE, 0x3A58)
#define PR_CHILDRENS_NAMES_A						PROP_TAG( PT_MV_STRING8, 0x3A58)



#define PR_HOME_ADDRESS_CITY						PROP_TAG( PT_TSTRING, 0x3A59)
#define PR_HOME_ADDRESS_CITY_W						PROP_TAG( PT_UNICODE, 0x3A59)
#define PR_HOME_ADDRESS_CITY_A						PROP_TAG( PT_STRING8, 0x3A59)

#define PR_HOME_ADDRESS_COUNTRY						PROP_TAG( PT_TSTRING, 0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_W					PROP_TAG( PT_UNICODE, 0x3A5A)
#define PR_HOME_ADDRESS_COUNTRY_A					PROP_TAG( PT_STRING8, 0x3A5A)

#define PR_HOME_ADDRESS_POSTAL_CODE					PROP_TAG( PT_TSTRING, 0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_W				PROP_TAG( PT_UNICODE, 0x3A5B)
#define PR_HOME_ADDRESS_POSTAL_CODE_A				PROP_TAG( PT_STRING8, 0x3A5B)

#define PR_HOME_ADDRESS_STATE_OR_PROVINCE			PROP_TAG( PT_TSTRING, 0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_W			PROP_TAG( PT_UNICODE, 0x3A5C)
#define PR_HOME_ADDRESS_STATE_OR_PROVINCE_A			PROP_TAG( PT_STRING8, 0x3A5C)

#define PR_HOME_ADDRESS_STREET						PROP_TAG( PT_TSTRING, 0x3A5D)
#define PR_HOME_ADDRESS_STREET_W					PROP_TAG( PT_UNICODE, 0x3A5D)
#define PR_HOME_ADDRESS_STREET_A					PROP_TAG( PT_STRING8, 0x3A5D)

#define PR_HOME_ADDRESS_POST_OFFICE_BOX				PROP_TAG( PT_TSTRING, 0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_W			PROP_TAG( PT_UNICODE, 0x3A5E)
#define PR_HOME_ADDRESS_POST_OFFICE_BOX_A			PROP_TAG( PT_STRING8, 0x3A5E)

#define PR_OTHER_ADDRESS_CITY						PROP_TAG( PT_TSTRING, 0x3A5F)
#define PR_OTHER_ADDRESS_CITY_W						PROP_TAG( PT_UNICODE, 0x3A5F)
#define PR_OTHER_ADDRESS_CITY_A						PROP_TAG( PT_STRING8, 0x3A5F)

#define PR_OTHER_ADDRESS_COUNTRY					PROP_TAG( PT_TSTRING, 0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_W					PROP_TAG( PT_UNICODE, 0x3A60)
#define PR_OTHER_ADDRESS_COUNTRY_A					PROP_TAG( PT_STRING8, 0x3A60)

#define PR_OTHER_ADDRESS_POSTAL_CODE				PROP_TAG( PT_TSTRING, 0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_W				PROP_TAG( PT_UNICODE, 0x3A61)
#define PR_OTHER_ADDRESS_POSTAL_CODE_A				PROP_TAG( PT_STRING8, 0x3A61)

#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE			PROP_TAG( PT_TSTRING, 0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_W		PROP_TAG( PT_UNICODE, 0x3A62)
#define PR_OTHER_ADDRESS_STATE_OR_PROVINCE_A		PROP_TAG( PT_STRING8, 0x3A62)

#define PR_OTHER_ADDRESS_STREET						PROP_TAG( PT_TSTRING, 0x3A63)
#define PR_OTHER_ADDRESS_STREET_W					PROP_TAG( PT_UNICODE, 0x3A63)
#define PR_OTHER_ADDRESS_STREET_A					PROP_TAG( PT_STRING8, 0x3A63)

#define PR_OTHER_ADDRESS_POST_OFFICE_BOX			PROP_TAG( PT_TSTRING, 0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_W			PROP_TAG( PT_UNICODE, 0x3A64)
#define PR_OTHER_ADDRESS_POST_OFFICE_BOX_A			PROP_TAG( PT_STRING8, 0x3A64)


/*
 *	Profile section properties
 */

#define PR_STORE_PROVIDERS							PROP_TAG( PT_BINARY,	0x3D00)
#define PR_AB_PROVIDERS								PROP_TAG( PT_BINARY,	0x3D01)
#define PR_TRANSPORT_PROVIDERS						PROP_TAG( PT_BINARY,	0x3D02)

#define PR_DEFAULT_PROFILE							PROP_TAG( PT_BOOLEAN,	0x3D04)
#define PR_AB_SEARCH_PATH							PROP_TAG( PT_MV_BINARY,	0x3D05)
#define PR_AB_DEFAULT_DIR							PROP_TAG( PT_BINARY,	0x3D06)
#define PR_AB_DEFAULT_PAB							PROP_TAG( PT_BINARY,	0x3D07)

#define PR_FILTERING_HOOKS                          PROP_TAG( PT_BINARY,    0x3D08)
#define PR_SERVICE_NAME								PROP_TAG( PT_TSTRING,	0x3D09)
#define PR_SERVICE_NAME_W							PROP_TAG( PT_UNICODE,	0x3D09)
#define PR_SERVICE_NAME_A							PROP_TAG( PT_STRING8,	0x3D09)
#define PR_SERVICE_DLL_NAME							PROP_TAG( PT_TSTRING,	0x3D0A)
#define PR_SERVICE_DLL_NAME_W						PROP_TAG( PT_UNICODE,	0x3D0A)
#define PR_SERVICE_DLL_NAME_A						PROP_TAG( PT_STRING8,	0x3D0A)
#define PR_SERVICE_ENTRY_NAME						PROP_TAG( PT_STRING8,	0x3D0B)
#define PR_SERVICE_UID								PROP_TAG( PT_BINARY,	0x3D0C)
#define PR_SERVICE_EXTRA_UIDS						PROP_TAG( PT_BINARY,	0x3D0D)
#define PR_SERVICES									PROP_TAG( PT_BINARY,	0x3D0E)
#define PR_SERVICE_SUPPORT_FILES   					PROP_TAG( PT_MV_TSTRING, 0x3D0F)
#define PR_SERVICE_SUPPORT_FILES_W					PROP_TAG( PT_MV_UNICODE, 0x3D0F)
#define PR_SERVICE_SUPPORT_FILES_A					PROP_TAG( PT_MV_STRING8, 0x3D0F)
#define PR_SERVICE_DELETE_FILES   					PROP_TAG( PT_MV_TSTRING, 0x3D10)
#define PR_SERVICE_DELETE_FILES_W					PROP_TAG( PT_MV_UNICODE, 0x3D10)
#define PR_SERVICE_DELETE_FILES_A					PROP_TAG( PT_MV_STRING8, 0x3D10)
#define PR_AB_SEARCH_PATH_UPDATE   					PROP_TAG( PT_BINARY, 	 0x3D11)
#define PR_PROFILE_NAME								PROP_TAG( PT_TSTRING,	0x3D12)
#define PR_PROFILE_NAME_A							PROP_TAG( PT_STRING8,	0x3D12)
#define PR_PROFILE_NAME_W							PROP_TAG( PT_UNICODE,	0x3D12)

/*
 *	Status object properties
 */

#define PR_IDENTITY_DISPLAY							PROP_TAG( PT_TSTRING,	0x3E00)
#define PR_IDENTITY_DISPLAY_W						PROP_TAG( PT_UNICODE,	0x3E00)
#define PR_IDENTITY_DISPLAY_A						PROP_TAG( PT_STRING8,	0x3E00)
#define PR_IDENTITY_ENTRYID							PROP_TAG( PT_BINARY,	0x3E01)
#define PR_RESOURCE_METHODS							PROP_TAG( PT_LONG,		0x3E02)
#define PR_RESOURCE_TYPE							PROP_TAG( PT_LONG,		0x3E03)
#define PR_STATUS_CODE								PROP_TAG( PT_LONG,		0x3E04)
#define PR_IDENTITY_SEARCH_KEY						PROP_TAG( PT_BINARY,	0x3E05)
#define PR_OWN_STORE_ENTRYID						PROP_TAG( PT_BINARY,	0x3E06)
#define PR_RESOURCE_PATH							PROP_TAG( PT_TSTRING,   0x3E07)
#define PR_RESOURCE_PATH_W							PROP_TAG( PT_UNICODE,   0x3E07)
#define PR_RESOURCE_PATH_A							PROP_TAG( PT_STRING8,   0x3E07)
#define PR_STATUS_STRING							PROP_TAG( PT_TSTRING,	0x3E08)
#define PR_STATUS_STRING_W							PROP_TAG( PT_UNICODE,	0x3E08)
#define PR_STATUS_STRING_A							PROP_TAG( PT_STRING8,	0x3E08)
#define PR_X400_DEFERRED_DELIVERY_CANCEL			PROP_TAG( PT_BOOLEAN,	0x3E09)
#define PR_HEADER_FOLDER_ENTRYID					PROP_TAG( PT_BINARY,	0x3E0A)
#define PR_REMOTE_PROGRESS							PROP_TAG( PT_LONG,		0x3E0B)
#define PR_REMOTE_PROGRESS_TEXT						PROP_TAG( PT_TSTRING,	0x3E0C)
#define PR_REMOTE_PROGRESS_TEXT_W					PROP_TAG( PT_UNICODE,	0x3E0C)
#define PR_REMOTE_PROGRESS_TEXT_A					PROP_TAG( PT_STRING8,	0x3E0C)
#define PR_REMOTE_VALIDATE_OK						PROP_TAG( PT_BOOLEAN,	0x3E0D)

/*
 * Display table properties
 */

#define PR_CONTROL_FLAGS							PROP_TAG( PT_LONG,		0x3F00)
#define PR_CONTROL_STRUCTURE						PROP_TAG( PT_BINARY,	0x3F01)
#define PR_CONTROL_TYPE								PROP_TAG( PT_LONG,		0x3F02)
#define PR_DELTAX									PROP_TAG( PT_LONG,		0x3F03)
#define PR_DELTAY									PROP_TAG( PT_LONG,		0x3F04)
#define PR_XPOS										PROP_TAG( PT_LONG,		0x3F05)
#define PR_YPOS										PROP_TAG( PT_LONG,		0x3F06)
#define PR_CONTROL_ID								PROP_TAG( PT_BINARY,	0x3F07)
#define PR_INITIAL_DETAILS_PANE						PROP_TAG( PT_LONG,		0x3F08)

/*
 * Secure property id range
 */

#define PROP_ID_SECURE_MIN 							0x67F0
#define PROP_ID_SECURE_MAX 							0x67FF


#endif	/* MAPITAGS_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPIVal.h ===
/*
 *	M A P I V A L . H
 *	
 *	Macros used to validate parameters on standard MAPI object methods.
 *	Used in conjunction with routines found in MAPIU.DLL.
 *	
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef	_INC_VALIDATE
#define	_INC_VALIDATE

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MAPIUTIL_H
#include	<mapiutil.h>
#endif
#include	<stddef.h>
#include	<stdarg.h>


#define MAKE_ENUM(Method, Interface)	Interface##_##Method

typedef enum _tagMethods
{
/* IUnknown */
	MAKE_ENUM(QueryInterface, IUnknown) = 0,
	MAKE_ENUM(AddRef, IUnknown),			/* For completness */
	MAKE_ENUM(Release, IUnknown),			/* For completness */
	
/* IMAPIProps */
	MAKE_ENUM(GetLastError, IMAPIProp),
	MAKE_ENUM(SaveChanges, IMAPIProp),
	MAKE_ENUM(GetProps, IMAPIProp),
	MAKE_ENUM(GetPropList, IMAPIProp),
	MAKE_ENUM(OpenProperty, IMAPIProp),
	MAKE_ENUM(SetProps, IMAPIProp),
	MAKE_ENUM(DeleteProps, IMAPIProp),
	MAKE_ENUM(CopyTo, IMAPIProp),
	MAKE_ENUM(CopyProps, IMAPIProp),
	MAKE_ENUM(GetNamesFromIDs, IMAPIProp),
	MAKE_ENUM(GetIDsFromNames, IMAPIProp),

/* IMAPITable */
	MAKE_ENUM(GetLastError, IMAPITable),
	MAKE_ENUM(Advise, IMAPITable),
	MAKE_ENUM(Unadvise, IMAPITable),
	MAKE_ENUM(GetStatus, IMAPITable),
	MAKE_ENUM(SetColumns, IMAPITable),
	MAKE_ENUM(QueryColumns, IMAPITable),
	MAKE_ENUM(GetRowCount, IMAPITable),
	MAKE_ENUM(SeekRow, IMAPITable),
	MAKE_ENUM(SeekRowApprox, IMAPITable),
	MAKE_ENUM(QueryPosition, IMAPITable),
	MAKE_ENUM(FindRow, IMAPITable),
	MAKE_ENUM(Restrict, IMAPITable),
	MAKE_ENUM(CreateBookmark, IMAPITable),
	MAKE_ENUM(FreeBookmark, IMAPITable),
	MAKE_ENUM(SortTable, IMAPITable),
	MAKE_ENUM(QuerySortOrder, IMAPITable),
	MAKE_ENUM(QueryRows, IMAPITable),
	MAKE_ENUM(Abort, IMAPITable),
	MAKE_ENUM(ExpandRow, IMAPITable),
	MAKE_ENUM(CollapseRow, IMAPITable),
	MAKE_ENUM(WaitForCompletion, IMAPITable),
	MAKE_ENUM(GetCollapseState, IMAPITable),
	MAKE_ENUM(SetCollapseState, IMAPITable),

/* IMAPIContainer */
	MAKE_ENUM(GetContentsTable, IMAPIContainer),
	MAKE_ENUM(GetHierarchyTable, IMAPIContainer),
	MAKE_ENUM(OpenEntry, IMAPIContainer),
	MAKE_ENUM(SetSearchCriteria, IMAPIContainer),
	MAKE_ENUM(GetSearchCriteria, IMAPIContainer),

/* IABContainer */
	MAKE_ENUM(CreateEntry, IABContainer),
	MAKE_ENUM(CopyEntries, IABContainer),
	MAKE_ENUM(DeleteEntries, IABContainer),
	MAKE_ENUM(ResolveNames, IABContainer),

/* IDistList */
	MAKE_ENUM(CreateEntry, IDistList),
	MAKE_ENUM(CopyEntries, IDistList),
	MAKE_ENUM(DeleteEntries, IDistList),
	MAKE_ENUM(ResolveNames, IDistList),

/* IMAPIFolder */
	MAKE_ENUM(CreateMessage, IMAPIFolder),
	MAKE_ENUM(CopyMessages, IMAPIFolder),
	MAKE_ENUM(DeleteMessages, IMAPIFolder),
	MAKE_ENUM(CreateFolder, IMAPIFolder),
	MAKE_ENUM(CopyFolder, IMAPIFolder),
	MAKE_ENUM(DeleteFolder, IMAPIFolder),
	MAKE_ENUM(SetReadFlags, IMAPIFolder),
	MAKE_ENUM(GetMessageStatus, IMAPIFolder),
	MAKE_ENUM(SetMessageStatus, IMAPIFolder),
	MAKE_ENUM(SaveContentsSort, IMAPIFolder),
	MAKE_ENUM(EmptyFolder, IMAPIFolder),

/* IMsgStore */
	MAKE_ENUM(Advise, IMsgStore),
	MAKE_ENUM(Unadvise, IMsgStore),
	MAKE_ENUM(CompareEntryIDs, IMsgStore),
	MAKE_ENUM(OpenEntry, IMsgStore),
	MAKE_ENUM(SetReceiveFolder, IMsgStore),
	MAKE_ENUM(GetReceiveFolder, IMsgStore),
	MAKE_ENUM(GetReceiveFolderTable, IMsgStore),
	MAKE_ENUM(StoreLogoff, IMsgStore),
	MAKE_ENUM(AbortSubmit, IMsgStore),
	MAKE_ENUM(GetOutgoingQueue, IMsgStore),
	MAKE_ENUM(SetLockState, IMsgStore),
	MAKE_ENUM(FinishedMsg, IMsgStore),
	MAKE_ENUM(NotifyNewMail, IMsgStore),

/* IMessage */
	MAKE_ENUM(GetAttachmentTable, IMessage),
	MAKE_ENUM(OpenAttach, IMessage),
	MAKE_ENUM(CreateAttach, IMessage),
	MAKE_ENUM(DeleteAttach, IMessage),
	MAKE_ENUM(GetRecipientTable, IMessage),
	MAKE_ENUM(ModifyRecipients, IMessage),
	MAKE_ENUM(SubmitMessage, IMessage),
	MAKE_ENUM(SetReadFlag, IMessage),


/* IABProvider */
	MAKE_ENUM(Shutdown, IABProvider),
	MAKE_ENUM(Logon, IABProvider),

/* IABLogon */
	MAKE_ENUM(GetLastError, IABLogon),
	MAKE_ENUM(Logoff, IABLogon),
	MAKE_ENUM(OpenEntry, IABLogon),
	MAKE_ENUM(CompareEntryIDs, IABLogon),
	MAKE_ENUM(Advise, IABLogon),
	MAKE_ENUM(Unadvise, IABLogon),
	MAKE_ENUM(OpenStatusEntry, IABLogon),
	MAKE_ENUM(OpenTemplateID, IABLogon),
	MAKE_ENUM(GetOneOffTable, IABLogon),
	MAKE_ENUM(PrepareRecips, IABLogon),

/* IXPProvider */
	MAKE_ENUM(Shutdown, IXPProvider),
	MAKE_ENUM(TransportLogon, IXPProvider),

/* IXPLogon */
	MAKE_ENUM(AddressTypes, IXPLogon),
	MAKE_ENUM(RegisterOptions, IXPLogon),
	MAKE_ENUM(TransportNotify, IXPLogon),
	MAKE_ENUM(Idle, IXPLogon),
	MAKE_ENUM(TransportLogoff, IXPLogon),
	MAKE_ENUM(SubmitMessage, IXPLogon),
	MAKE_ENUM(EndMessage, IXPLogon),
	MAKE_ENUM(Poll, IXPLogon),
	MAKE_ENUM(StartMessage, IXPLogon),
	MAKE_ENUM(OpenStatusEntry, IXPLogon),
	MAKE_ENUM(ValidateState, IXPLogon),
	MAKE_ENUM(FlushQueues, IXPLogon),

/* IMSProvider */
	MAKE_ENUM(Shutdown, IMSProvider),
	MAKE_ENUM(Logon, IMSProvider),
	MAKE_ENUM(SpoolerLogon, IMSProvider),
	MAKE_ENUM(CompareStoreIDs, IMSProvider),

/* IMSLogon */
	MAKE_ENUM(GetLastError, IMSLogon),
	MAKE_ENUM(Logoff, IMSLogon),
	MAKE_ENUM(OpenEntry, IMSLogon),
	MAKE_ENUM(CompareEntryIDs, IMSLogon),
	MAKE_ENUM(Advise, IMSLogon),
	MAKE_ENUM(Unadvise, IMSLogon),
	MAKE_ENUM(OpenStatusEntry, IMSLogon),
	
/* IMAPIControl */
	MAKE_ENUM(GetLastError, IMAPIControl),
	MAKE_ENUM(Activate, IMAPIControl),
	MAKE_ENUM(GetState, IMAPIControl),
	
/* IMAPIStatus */
	MAKE_ENUM(ValidateState, IMAPIStatus),
	MAKE_ENUM(SettingsDialog, IMAPIStatus),
	MAKE_ENUM(ChangePassword, IMAPIStatus),
	MAKE_ENUM(FlushQueues, IMAPIStatus),

/* IStream */
	MAKE_ENUM(Read, IStream),
	MAKE_ENUM(Write, IStream),
	MAKE_ENUM(Seek, IStream),
	MAKE_ENUM(SetSize, IStream),
	MAKE_ENUM(CopyTo, IStream),
	MAKE_ENUM(Commit, IStream),
	MAKE_ENUM(Revert, IStream),
	MAKE_ENUM(LockRegion, IStream),
	MAKE_ENUM(UnlockRegion, IStream),
	MAKE_ENUM(Stat, IStream),
	MAKE_ENUM(Clone, IStream),

/* IMAPIAdviseSink */
	MAKE_ENUM(OnNotify, IMAPIAdviseSink),

} METHODS;


/* Macro wrappers to hide the Validate function return handling */
#if defined(_X86_) || defined( WIN16 )
#ifdef __cplusplus

/* C++ methods can't take the address of the This pointer, so we must
   use the first parameter instead */

#define ValidateParameters(eMethod, First)				\
		{	HRESULT   _hr_;								\
			_hr_ = __CPPValidateParameters(eMethod, (LPVOID) &First);	\
			if (HR_FAILED(_hr_)) return (_hr_);	}

#define UlValidateParameters(eMethod, First)				\
		{	HRESULT   _hr_;								\
			_hr_ = __CPPValidateParameters(eMethod, &First);	\
			if (HR_FAILED(_hr_)) return (ULONG) (_hr_);	}

/* Methods called by MAPI should have correct parameters
   - just assert in Debug to check */
#define CheckParameters(eMethod, First)				\
		AssertSz(HR_SUCCEEDED(__CPPValidateParameters(eMethod, &First)), "Parameter validation failed for method called by MAPI!")


#else /* __cplusplus */

/* For methods that will be called by clients
   - validate always */

#define ValidateParameters(eMethod, ppThis)				\
		{	HRESULT   _hr_;								\
			_hr_ = __ValidateParameters(eMethod, ppThis);	\
			if (HR_FAILED(_hr_)) return (_hr_);	}

#define UlValidateParameters(eMethod, ppThis)				\
		{	HRESULT   _hr_;								\
			_hr_ = __ValidateParameters(eMethod, ppThis);	\
			if (HR_FAILED(_hr_)) return (ULONG) (_hr_);	}

/* Methods called by MAPI should have correct parameters
   - just assert in Debug to check */
#define CheckParameters(eMethod, ppThis)				\
		AssertSz(HR_SUCCEEDED(__ValidateParameters(eMethod, ppThis)), "Parameter validation failed for method called by MAPI!")

#endif /* __cplusplus */
#endif /* _X86_ || WIN16 */

/* Prototypes for functions used to validate complex parameters.
 */
#define FBadPropVal( lpPropVal)	(FAILED(ScCountProps( 1, lpPropVal, NULL)))

#define FBadRgPropVal( lpPropVal, cValues) \
		(FAILED(ScCountProps( cValues, lpPropVal, NULL)))

#define FBadAdrList( lpAdrList) \
		(   AssertSz(   (   offsetof( ADRLIST, cEntries) \
						 == offsetof( SRowSet, cRows)) \
					 && (   offsetof( ADRLIST, aEntries) \
						 == offsetof( SRowSet, aRow)) \
					 && (   offsetof( ADRENTRY, cValues) \
						 == offsetof( SRow, cValues)) \
					 && (   offsetof( ADRENTRY, rgPropVals) \
						 == offsetof( SRow, lpProps)) \
					, "ADRLIST doesn't match SRowSet") \
		 || FBadRowSet( (LPSRowSet) lpAdrList))

STDAPI_(BOOL)
FBadRglpszW(__in LPWSTR FAR	*lppszW,
			 ULONG		cStrings);

STDAPI_(BOOL)
FBadRowSet( LPSRowSet	lpRowSet);

STDAPI_(BOOL)
FBadRglpNameID( LPMAPINAMEID FAR *	lppNameId,
				ULONG				cNames);

STDAPI_(BOOL)
FBadEntryList( LPENTRYLIST	lpEntryList);


/* BAD_STANDARD_OBJ
 *
 * This macro insures that the object is a writable object of the correct size
 * and that this method belongs to the object.
 *
 * NOTES ON USE!
 *	This depends upon using the standard method of declaring the object
 *	interface.
 *
 *	prefix is the method prefix you chose when declaring the object interface.
 *	method is the standard method name of the calling method.
 *	lpVtbl is the name of the lpVtbl element of your object.
 */
#define BAD_STANDARD_OBJ( lpObj, prefix, method, lpVtbl) \
	(   IsBadWritePtr( (lpObj), sizeof(*lpObj)) \
	 || IsBadReadPtr( (void *) &(lpObj->lpVtbl->method), sizeof(LPVOID)) \
	 ||( ( LPVOID) (lpObj->lpVtbl->method) != (LPVOID) (prefix##method)))


#define FBadUnknown( lpObj ) \
	(	IsBadReadPtr( (lpObj), sizeof(LPVOID) ) \
	 ||	IsBadReadPtr( (lpObj)->lpVtbl, 3 * sizeof(LPUNKNOWN) ) \
	 ||	IsBadCodePtr( (FARPROC)(lpObj)->lpVtbl->QueryInterface ))

/*
 * IUnknown
 */


/*
 * QueryInterface
 */
#define FBadQueryInterface( lpObj, riid, ppvObj)	\
	(   IsBadReadPtr( riid, sizeof(IID)) \
	 || IsBadWritePtr( ppvObj, sizeof(LPVOID)))


/*
 * AddRef
 *	No parameter validation required.
 */
#define FBadAddRef( lpObj)	FALSE


/*
 * Release
 *	No parameter validation required.
 */
#define FBadRelease( lpObj)	FALSE


/*
 * GetLastError
 */
#define FBadGetLastError( lpObj, hResult, ulFlags, lppMAPIError )\
	(IsBadWritePtr( lppMAPIError, sizeof(LPMAPIERROR)))

/*
 * IMAPIProp
 */


/*
 * SaveChanges
 *	No parameter validation required.
 */
#define FBadSaveChanges( lpObj, ulFlags)	FALSE


/*
 * GetProps
 */
#define FBadGetProps( lpObj, lpPTagA, lpcValues, lppPropArray) \
	(   (   lpPTagA \
		 && (   IsBadReadPtr( lpPTagA, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPTagA, (UINT)(  (lpPTagA->cValues + 1) \
									          * sizeof(ULONG))))) \
	 || IsBadWritePtr( lpcValues, sizeof(ULONG)) \
	 || IsBadWritePtr( lppPropArray, sizeof(LPSPropValue)))


/*
 * GetPropList
 */
#define FBadGetPropList( lpObj, lppPTagA) \
	(IsBadWritePtr( lppPTagA, sizeof(LPSPropTagArray FAR *)))


/*
 * OpenProperty
 */
#define FBadOpenProperty( lpObj, ulPropTag, lpiid, ulInterfaceOptions, ulFlags \
						, lppUnk) \
	(   IsBadReadPtr( lpiid, sizeof(IID)) \
	 || IsBadWritePtr( lppUnk, sizeof (LPUNKNOWN FAR *)))


/*
 * SetProps
 */
#define FBadSetProps( lpObj, cValues, lpPropArray, lppProblems) \
	(   FBadRgPropVal( lpPropArray, (UINT) cValues) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * DeleteProps
 */
#define FBadDeleteProps( lpObj, lpPTagA, lppProblems) \
	(   (   !lpPTagA \
		 || (   IsBadReadPtr( lpPTagA, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPTagA, (UINT)(  (lpPTagA->cValues + 1) \
									          * sizeof(ULONG))))) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * CopyTo
 */
#define FBadCopyTo( lpIPDAT, ciidExclude, rgiidExclude, lpExcludeProps \
				  , ulUIParam, lpProgress, lpInterface, lpDestObj \
				  , ulFlags, lppProblems) \
	(	(	ciidExclude \
		 && (  IsBadReadPtr( rgiidExclude, (UINT)(ciidExclude * sizeof(IID))))) \
	 || (   lpExcludeProps \
		 && (   IsBadReadPtr( lpExcludeProps, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpExcludeProps \
			 				, (UINT)(  (lpExcludeProps->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || (lpProgress && FBadUnknown( lpProgress )) \
     || (lpInterface && IsBadReadPtr( lpInterface, sizeof(IID))) \
	 || IsBadReadPtr( lpDestObj, sizeof(LPVOID)) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))


/*
 * CopyProps
 */
#define FBadCopyProps( lpIPDAT, lpPropTagArray \
					 , ulUIParam, lpProgress, lpInterface, lpDestObj \
					 , ulFlags, lppProblems) \
	(   (   lpPropTagArray \
		 && (   IsBadReadPtr( lpPropTagArray, sizeof(ULONG)) \
		 	 || IsBadReadPtr( lpPropTagArray \
			 				, (UINT)(  (lpPropTagArray->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || (lpProgress && FBadUnknown( lpProgress )) \
     || (lpInterface && IsBadReadPtr( lpInterface, sizeof(IID))) \
	 || IsBadReadPtr( lpDestObj, sizeof(LPVOID)) \
	 || (   lppProblems \
	 	 && IsBadWritePtr( lppProblems, sizeof(LPSPropProblemArray))))



/*
 * GetNamesFromIDs
 */
#define FBadGetNamesFromIDs( lpIPDAT, lppPropTags, lpPropSetGuid, ulFlags, \
							 lpcPropNames, lpppPropNames) \
	(   IsBadReadPtr( lppPropTags, sizeof(LPSPropTagArray)) \
	 || ( lpPropSetGuid && IsBadReadPtr( lpPropSetGuid, sizeof(GUID))) \
	 || (   *lppPropTags \
		 && (   IsBadReadPtr( *lppPropTags, sizeof(ULONG)) \
		 	 || IsBadReadPtr( *lppPropTags \
			 				, (UINT)( ( ( *lppPropTags)->cValues + 1) \
							         * sizeof(ULONG))))) \
	 || IsBadWritePtr( lpcPropNames, sizeof (ULONG)) \
	 || IsBadWritePtr( lpppPropNames, sizeof (LPVOID FAR *)))



/*
 * GetNamesFromIDs
 */
#define FBadGetIDsFromNames( lpIPDAT, cPropNames, lppPropNames, ulFlags \
						   , lppPropTags) \
	(   (cPropNames && FBadRglpNameID( lppPropNames, cPropNames)) \
	 || IsBadWritePtr( lppPropTags, sizeof(LPULONG FAR *)))


STDAPI_(ULONG)
FBadRestriction( LPSRestriction lpres );

STDAPI_(ULONG)
FBadPropTag( ULONG ulPropTag );

STDAPI_(ULONG)
FBadRow( LPSRow lprow );

STDAPI_(ULONG)
FBadProp( LPSPropValue lpprop );

STDAPI_(ULONG)
FBadSortOrderSet( LPSSortOrderSet lpsos );

STDAPI_(ULONG)
FBadColumnSet( LPSPropTagArray lpptaCols );

/* Validation function

	The eMethod parameter tells us which internal validation to perform.
	
	The ppThis parameter tells us where the stack is, so we can access the other
	parameters.
	
	Becuase of this *magic* we MUST obtain the pointer to the This pointer in
	the method function.
	
*/

#ifdef WIN16
#define BASED_STACK			__based(__segname("_STACK"))
#else
#define BASED_STACK
#endif


#ifdef WIN16
HRESULT	 PASCAL
#else
HRESULT	 STDAPICALLTYPE		
#endif
__CPPValidateParameters(METHODS eMethod, const LPVOID ppFirst);

#ifdef WIN16
HRESULT	 PASCAL
#else
HRESULT	 STDAPICALLTYPE		
#endif
__ValidateParameters(METHODS eMethod, LPVOID ppThis);

#ifdef _MAC
#define STDAPIVCALLTYPE         __cdecl
#define STDAPIV                 EXTERN_C HRESULT STDAPIVCALLTYPE
#define STDAPIV_(type)          EXTERN_C type STDAPIVCALLTYPE
#endif /* _MAC */

/* Macro wrappers for platform independent validation */

#if defined(_X86_) || defined( WIN16 )

#define ArgSize(T) ((sizeof(T)+3)/4)
#define MakeArg1(idx, a1) memcpy(__rgArgs+idx, &a1, ArgSize(a1)*4)
#define MakeArg2(idx, a1, a2) MakeArg1(idx, a1); MakeArg1(idx+ArgSize(a1), a2)
#define MakeArg3(idx, a1, a2, a3) MakeArg1(idx, a1); MakeArg2(idx+ArgSize(a1), a2, a3)
#define MakeArg4(idx, a1, a2, a3, a4) MakeArg1(idx, a1); MakeArg3(idx+ArgSize(a1), a2, a3, a4)
#define MakeArg5(idx, a1, a2, a3, a4, a5) MakeArg1(idx, a1); MakeArg4(idx+ArgSize(a1), a2, a3, a4, a5)
#define MakeArg6(idx, a1, a2, a3, a4, a5, a6) MakeArg1(idx, a1); MakeArg5(idx+ArgSize(a1), a2, a3, a4, a5, a6)
#define MakeArg7(idx, a1, a2, a3, a4, a5, a6, a7) MakeArg1(idx, a1); MakeArg6(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7)
#define MakeArg8(idx, a1, a2, a3, a4, a5, a6, a7, a8) MakeArg1(idx, a1); MakeArg7(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8)
#define MakeArg9(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9) MakeArg1(idx, a1); MakeArg8(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9)
#define MakeArg10(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) MakeArg1(idx, a1); MakeArg9(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10)
#define MakeArg11(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) MakeArg1(idx, a1); MakeArg10(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)
#define MakeArg12(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) MakeArg1(idx, a1); MakeArg11(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)
#define MakeArg13(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) MakeArg1(idx, a1); MakeArg12(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)
#define MakeArg14(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) MakeArg1(idx, a1); MakeArg13(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)
#define MakeArg15(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) MakeArg1(idx, a1); MakeArg14(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)
#define MakeArg16(idx, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) MakeArg1(idx, a1); MakeArg15(idx+ArgSize(a1), a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16)

#define MakeArray1(a1) \
	DWORD __rgArgs[ArgSize(a1)]; \
	MakeArg1(0, a1)

#define MakeArray2(a1, a2) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2)]; \
	MakeArg2(0, a1, a2)

#define MakeArray3(a1, a2, a3) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3)]; \
	MakeArg3(0, a1, a2, a3)

#define MakeArray4(a1, a2, a3, a4) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4)]; \
	MakeArg4(0, a1, a2, a3, a4)

#define MakeArray5(a1, a2, a3, a4, a5) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5)]; \
	MakeArg5(0, a1, a2, a3, a4, a5)

#define MakeArray6(a1, a2, a3, a4, a5, a6) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6)]; \
	MakeArg6(0, a1, a2, a3, a4, a5, a6)

#define MakeArray7(a1, a2, a3, a4, a5, a6, a7) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7)]; \
	MakeArg7(0, a1, a2, a3, a4, a5, a6, a7)

#define MakeArray8(a1, a2, a3, a4, a5, a6, a7, a8) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8)]; \
	MakeArg8(0, a1, a2, a3, a4, a5, a6, a7, a8)

#define MakeArray9(a1, a2, a3, a4, a5, a6, a7, a8, a9) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9)]; \
	MakeArg9(0, a1, a2, a3, a4, a5, a6, a7, a8, a9)

#define MakeArray10(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10)]; \
	MakeArg10(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)

#define MakeArray11(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10) + ArgSize(a11)]; \
	MakeArg11(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11)

#define MakeArray12(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10) + ArgSize(a11) + ArgSize(a12)]; \
	MakeArg12(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)

#define MakeArray13(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10) + ArgSize(a11) + ArgSize(a12) + ArgSize(a13)]; \
	MakeArg13(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13)

#define MakeArray14(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10) + ArgSize(a11) + ArgSize(a12) + ArgSize(a13) + ArgSize(a14)]; \
	MakeArg14(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14)

#define MakeArray15(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10) + ArgSize(a11) + ArgSize(a12) + ArgSize(a13) + ArgSize(a14) + ArgSize(a15)]; \
	MakeArg15(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15)

#define MakeArray16(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16) \
	DWORD __rgArgs[ArgSize(a1) + ArgSize(a2) + ArgSize(a3) + ArgSize(a4) + ArgSize(a5) + ArgSize(a6) + ArgSize(a7) + ArgSize(a8) + ArgSize(a9) + ArgSize(a10) + ArgSize(a11) + ArgSize(a12) + ArgSize(a13) + ArgSize(a14) + ArgSize(a15) + ArgSize(a16)]; \
	MakeArg16(0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16)



#define ValidateParameters1( m, a1 ) 
#define ValidateParameters2( m, a1, a2 ) \
			{ HRESULT _hr_; \
			MakeArray1(a2); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters3( m, a1, a2, a3 ) \
			{ HRESULT _hr_; \
			MakeArray2(a2, a3); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters4( m, a1, a2, a3, a4 ) \
			{ HRESULT _hr_; \
			MakeArray3(a2, a3, a4); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			{ HRESULT _hr_; \
			MakeArray4(a2, a3, a4, a5); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			{ HRESULT _hr_; \
			MakeArray5(a2, a3, a4, a5, a6); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			{ HRESULT _hr_; \
			MakeArray6(a2, a3, a4, a5, a6, a7); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			{ HRESULT _hr_; \
			MakeArray7(a2, a3, a4, a5, a6, a7, a8); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			{ HRESULT _hr_; \
			MakeArray8(a2, a3, a4, a5, a6, a7, a8, a9); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			{ HRESULT _hr_; \
			MakeArray9(a2, a3, a4, a5, a6, a7, a8, a9, a10); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			{ HRESULT _hr_; \
			MakeArray10(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			{ HRESULT _hr_; \
			MakeArray11(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			{ HRESULT _hr_; \
			MakeArray12(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			{ HRESULT _hr_; \
			MakeArray13(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			{ HRESULT _hr_; \
			MakeArray14(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }
#define ValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			{ HRESULT _hr_; \
			MakeArray15(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return (_hr_); }

#define UlValidateParameters1( m, a1 ) 
#define UlValidateParameters2( m, a1, a2 ) \
			{ HRESULT _hr_; \
			MakeArray1(a2); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters3( m, a1, a2, a3 ) \
			{ HRESULT _hr_; \
			MakeArray2(a2, a3); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters4( m, a1, a2, a3, a4 ) \
			{ HRESULT _hr_; \
			MakeArray3(a2, a3, a4); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			{ HRESULT _hr_; \
			MakeArray4(a2, a3, a4, a5); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			{ HRESULT _hr_; \
			MakeArray5(a2, a3, a4, a5, a6); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			{ HRESULT _hr_; \
			MakeArray6(a2, a3, a4, a5, a6, a7); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			{ HRESULT _hr_; \
			MakeArray7(a2, a3, a4, a5, a6, a7, a8); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			{ HRESULT _hr_; \
			MakeArray8(a2, a3, a4, a5, a6, a7, a8, a9); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			{ HRESULT _hr_; \
			MakeArray9(a2, a3, a4, a5, a6, a7, a8, a9, a10); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			{ HRESULT _hr_; \
			MakeArray10(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			{ HRESULT _hr_; \
			MakeArray11(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			{ HRESULT _hr_; \
			MakeArray12(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			{ HRESULT _hr_; \
			MakeArray13(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			{ HRESULT _hr_; \
			MakeArray14(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }
#define UlValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			{ HRESULT _hr_; \
			MakeArray15(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); \
			_hr_ = HrValidateParameters(m, (void **)__rgArgs); if (HR_FAILED(_hr_)) return ((ULONG)_hr_); }

#ifdef DEBUG
#define CheckParameters1( m, a1 ) 
#define CheckParameters2( m, a1, a2 ) \
			{ \
			MakeArray1(a2); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters3( m, a1, a2, a3 ) \
			{ \
			MakeArray2(a2, a3); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters4( m, a1, a2, a3, a4 ) \
			{ \
			MakeArray3(a2, a3, a4); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters5( m, a1, a2, a3, a4, a5 ) \
			{ \
			MakeArray4(a2, a3, a4, a5); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			{ \
			MakeArray5(a2, a3, a4, a5, a6); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			{ \
			MakeArray6(a2, a3, a4, a5, a6, a7); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			{ \
			MakeArray7(a2, a3, a4, a5, a6, a7, a8); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			{ \
			MakeArray8(a2, a3, a4, a5, a6, a7, a8, a9); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			{ \
			MakeArray9(a2, a3, a4, a5, a6, a7, a8, a9, a10); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			{ \
			MakeArray10(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			{ \
			MakeArray11(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			{ \
			MakeArray12(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			{ \
			MakeArray13(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			{ \
			MakeArray14(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			{ \
			MakeArray15(a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16); \
			AssertSz(HR_SUCCEEDED( HrValidateParameters(m, (void **)__rgArgs)), "Parameter validation failed for method called by MAPI!"); }
#else /* DEBUG */
#define CheckParameters1( m, a1 ) 
#define CheckParameters2( m, a1, a2 )
#define CheckParameters3( m, a1, a2, a3 )
#define CheckParameters4( m, a1, a2, a3, a4 )
#define CheckParameters5( m, a1, a2, a3, a4, a5 )
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 )
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 )
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 )
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 )
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 )
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 )
#endif /* DEBUG */
#else /* !_X86_  && !WIN16 */
#define ValidateParms(x)	{ HRESULT _hr_ = HrValidateParametersV x; if (HR_FAILED(_hr_)) return (_hr_); }
#define UlValidateParms(x)	{ HRESULT _hr_ = HrValidateParametersV x; if (HR_FAILED(_hr_)) return (ULONG)(_hr_); }
#define CheckParms(x) 		AssertSz(HR_SUCCEEDED( HrValidateParametersV x ), "Parameter validation failed for method called by MAPI!")

#define ValidateParameters1( m, a1 ) \
			ValidateParms( ( m, a1 ) )
#define ValidateParameters2( m, a1, a2 )	\
			ValidateParms( ( m, a1, a2 ))
#define ValidateParameters3( m, a1, a2, a3 )	\
			ValidateParms( ( m, a1, a2, a3 ))
#define ValidateParameters4( m, a1, a2, a3, a4 ) \
			ValidateParms( ( m, a1, a2, a3, a4 ))
#define ValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5 ))
#define ValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define ValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define ValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define ValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			ValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define ValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define ValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define ValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define ValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define ValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define ValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define ValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			ValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#define UlValidateParameters1( m, a1 ) \
			UlValidateParms( ( m, a1 ) )
#define UlValidateParameters2( m, a1, a2 )	\
			UlValidateParms( ( m, a1, a2 ))
#define UlValidateParameters3( m, a1, a2, a3 )	\
			UlValidateParms( ( m, a1, a2, a3 ))
#define UlValidateParameters4( m, a1, a2, a3, a4 ) \
			UlValidateParms( ( m, a1, a2, a3, a4 ))
#define UlValidateParameters5( m, a1, a2, a3, a4, a5 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5 ))
#define UlValidateParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define UlValidateParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define UlValidateParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define UlValidateParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			UlValidateParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define UlValidateParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define UlValidateParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define UlValidateParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define UlValidateParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define UlValidateParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define UlValidateParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define UlValidateParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			UlValidateParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#define CheckParameters1( m, a1 ) \
			CheckParms( ( m, a1 ) )
#define CheckParameters2( m, a1, a2 )	\
			CheckParms( ( m, a1, a2 ))
#define CheckParameters3( m, a1, a2, a3 )	\
			CheckParms( ( m, a1, a2, a3 ))
#define CheckParameters4( m, a1, a2, a3, a4 ) \
			CheckParms( ( m, a1, a2, a3, a4 ))
#define CheckParameters5( m, a1, a2, a3, a4, a5 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5 ))
#define CheckParameters6( m, a1, a2, a3, a4, a5, a6 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6 ))
#define CheckParameters7( m, a1, a2, a3, a4, a5, a6, a7 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7 ))
#define CheckParameters8( m, a1, a2, a3, a4, a5, a6, a7, a8 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8 ))
#define CheckParameters9( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			CheckParms( ( m, a1, a2, a3, a4, a5, a6, a7, a8, a9 ))
#define CheckParameters10( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ))
#define CheckParameters11( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11 ))
#define CheckParameters12( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12 ))
#define CheckParameters13( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ))
#define CheckParameters14( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14 ))
#define CheckParameters15( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15 ))
#define CheckParameters16( m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ) \
			CheckParms( (  m, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16 ))

#endif /* _X86_ || WIN16 */


/*
 *  	M A P I    P A R A M E T E R   V A L I D A T I O N    M A C R O S
 */


/* IUnknown */

#define Validate_IUnknown_QueryInterface( a1, a2, a3 ) \
			 ValidateParameters3( IUnknown_QueryInterface, a1, a2, a3 )
#define UlValidate_IUnknown_QueryInterface( a1, a2, a3 ) \
			 UlValidateParameters3( IUnknown_QueryInterface, a1, a2, a3 )
#define CheckParameters_IUnknown_QueryInterface( a1, a2, a3 ) \
			 CheckParameters3( IUnknown_QueryInterface, a1, a2, a3 )

#define Validate_IUnknown_AddRef( a1 ) \
			 ValidateParameters1( IUnknown_AddRef, a1 )
#define UlValidate_IUnknown_AddRef( a1 ) \
			 UlValidateParameters1( IUnknown_AddRef, a1 )
#define CheckParameters_IUnknown_AddRef( a1 ) \
			 CheckParameters1( IUnknown_AddRef, a1 )

#define Validate_IUnknown_Release( a1 ) \
			 ValidateParameters1( IUnknown_Release, a1 )
#define UlValidate_IUnknown_Release( a1 ) \
			 UlValidateParameters1( IUnknown_Release, a1 )
#define CheckParameters_IUnknown_Release( a1 ) \
			 CheckParameters1( IUnknown_Release, a1 )


/* IMAPIProp */

#define Validate_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPIProp_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIProp_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPIProp_SaveChanges( a1, a2 ) \
			 ValidateParameters2( IMAPIProp_SaveChanges, a1, a2 )
#define UlValidate_IMAPIProp_SaveChanges( a1, a2 ) \
			 UlValidateParameters2( IMAPIProp_SaveChanges, a1, a2 )
#define CheckParameters_IMAPIProp_SaveChanges( a1, a2 ) \
			 CheckParameters2( IMAPIProp_SaveChanges, a1, a2 )

#define Validate_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIProp_GetProps( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIProp_GetProps, a1, a2, a3, a4, a5 )

#define Validate_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIProp_GetPropList, a1, a2, a3 )
#define UlValidate_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIProp_GetPropList, a1, a2, a3 )
#define CheckParameters_IMAPIProp_GetPropList( a1, a2, a3 ) \
			 CheckParameters3( IMAPIProp_GetPropList, a1, a2, a3 )

#define Validate_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIProp_OpenProperty( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIProp_OpenProperty, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )
#define UlValidate_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )
#define CheckParameters_IMAPIProp_SetProps( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIProp_SetProps, a1, a2, a3, a4 )

#define Validate_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )
#define UlValidate_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )
#define CheckParameters_IMAPIProp_DeleteProps( a1, a2, a3 ) \
			 CheckParameters3( IMAPIProp_DeleteProps, a1, a2, a3 )

#define Validate_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 ValidateParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define UlValidate_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 UlValidateParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )
#define CheckParameters_IMAPIProp_CopyTo( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 ) \
			 CheckParameters10( IMAPIProp_CopyTo, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 )

#define Validate_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 ValidateParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )
#define UlValidate_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 UlValidateParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters_IMAPIProp_CopyProps( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 CheckParameters8( IMAPIProp_CopyProps, a1, a2, a3, a4, a5, a6, a7, a8 )

#define Validate_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIProp_GetNamesFromIDs( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIProp_GetNamesFromIDs, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIProp_GetIDsFromNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIProp_GetIDsFromNames, a1, a2, a3, a4, a5 )


/* IMAPITable */

#define Validate_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_Advise, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_Advise, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_Advise( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_Advise, a1, a2, a3, a4 )

#define Validate_IMAPITable_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMAPITable_Unadvise, a1, a2 )
#define UlValidate_IMAPITable_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_Unadvise, a1, a2 )
#define CheckParameters_IMAPITable_Unadvise( a1, a2 ) \
			 CheckParameters2( IMAPITable_Unadvise, a1, a2 )

#define Validate_IMAPITable_GetStatus( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_GetStatus, a1, a2, a3 )
#define UlValidate_IMAPITable_GetStatus( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_GetStatus, a1, a2, a3 )
#define CheckParameters_IMAPITable_GetStatus( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_GetStatus, a1, a2, a3 )

#define Validate_IMAPITable_SetColumns( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SetColumns, a1, a2, a3 )
#define UlValidate_IMAPITable_SetColumns( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SetColumns, a1, a2, a3 )
#define CheckParameters_IMAPITable_SetColumns( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SetColumns, a1, a2, a3 )

#define Validate_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_QueryColumns, a1, a2, a3 )
#define UlValidate_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_QueryColumns, a1, a2, a3 )
#define CheckParameters_IMAPITable_QueryColumns( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_QueryColumns, a1, a2, a3 )

#define Validate_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_GetRowCount, a1, a2, a3 )
#define UlValidate_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_GetRowCount, a1, a2, a3 )
#define CheckParameters_IMAPITable_GetRowCount( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_GetRowCount, a1, a2, a3 )

#define Validate_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_SeekRow( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_SeekRow, a1, a2, a3, a4 )

#define Validate_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )
#define UlValidate_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )
#define CheckParameters_IMAPITable_SeekRowApprox( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SeekRowApprox, a1, a2, a3 )

#define Validate_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_QueryPosition( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_QueryPosition, a1, a2, a3, a4 )

#define Validate_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_FindRow( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_FindRow, a1, a2, a3, a4 )

#define Validate_IMAPITable_Restrict( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_Restrict, a1, a2, a3 )
#define UlValidate_IMAPITable_Restrict( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_Restrict, a1, a2, a3 )
#define CheckParameters_IMAPITable_Restrict( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_Restrict, a1, a2, a3 )

#define Validate_IMAPITable_CreateBookmark( a1, a2 ) \
			 ValidateParameters2( IMAPITable_CreateBookmark, a1, a2 )
#define UlValidate_IMAPITable_CreateBookmark( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_CreateBookmark, a1, a2 )
#define CheckParameters_IMAPITable_CreateBookmark( a1, a2 ) \
			 CheckParameters2( IMAPITable_CreateBookmark, a1, a2 )

#define Validate_IMAPITable_FreeBookmark( a1, a2 ) \
			 ValidateParameters2( IMAPITable_FreeBookmark, a1, a2 )
#define UlValidate_IMAPITable_FreeBookmark( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_FreeBookmark, a1, a2 )
#define CheckParameters_IMAPITable_FreeBookmark( a1, a2 ) \
			 CheckParameters2( IMAPITable_FreeBookmark, a1, a2 )

#define Validate_IMAPITable_SortTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPITable_SortTable, a1, a2, a3 )
#define UlValidate_IMAPITable_SortTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPITable_SortTable, a1, a2, a3 )
#define CheckParameters_IMAPITable_SortTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPITable_SortTable, a1, a2, a3 )

#define Validate_IMAPITable_QuerySortOrder( a1, a2 ) \
			 ValidateParameters2( IMAPITable_QuerySortOrder, a1, a2 )
#define UlValidate_IMAPITable_QuerySortOrder( a1, a2 ) \
			 UlValidateParameters2( IMAPITable_QuerySortOrder, a1, a2 )
#define CheckParameters_IMAPITable_QuerySortOrder( a1, a2 ) \
			 CheckParameters2( IMAPITable_QuerySortOrder, a1, a2 )

#define Validate_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_QueryRows( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_QueryRows, a1, a2, a3, a4 )

#define Validate_IMAPITable_Abort( a1 ) \
			 ValidateParameters1( IMAPITable_Abort, a1 )
#define UlValidate_IMAPITable_Abort( a1 ) \
			 UlValidateParameters1( IMAPITable_Abort, a1 )
#define CheckParameters_IMAPITable_Abort( a1 ) \
			 CheckParameters1( IMAPITable_Abort, a1 )

#define Validate_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPITable_ExpandRow( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPITable_ExpandRow, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPITable_CollapseRow( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPITable_CollapseRow, a1, a2, a3, a4, a5 )

#define Validate_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )
#define UlValidate_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )
#define CheckParameters_IMAPITable_WaitForCompletion( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPITable_WaitForCompletion, a1, a2, a3, a4 )

#define Validate_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPITable_GetCollapseState( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPITable_GetCollapseState, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPITable_SetCollapseState( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPITable_SetCollapseState, a1, a2, a3, a4, a5 )


/* IMAPIContainer */

#define Validate_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )
#define UlValidate_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )
#define CheckParameters_IMAPIContainer_GetContentsTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPIContainer_GetContentsTable, a1, a2, a3 )

#define Validate_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )
#define UlValidate_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )
#define CheckParameters_IMAPIContainer_GetHierarchyTable( a1, a2, a3 ) \
			 CheckParameters3( IMAPIContainer_GetHierarchyTable, a1, a2, a3 )

#define Validate_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIContainer_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIContainer_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )
#define UlValidate_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )
#define CheckParameters_IMAPIContainer_SetSearchCriteria( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIContainer_SetSearchCriteria, a1, a2, a3, a4 )

#define Validate_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIContainer_GetSearchCriteria( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIContainer_GetSearchCriteria, a1, a2, a3, a4, a5 )


/* IABContainer */

#define Validate_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_CreateEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_CreateEntry, a1, a2, a3, a4, a5 )

#define Validate_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_CopyEntries( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_CopyEntries, a1, a2, a3, a4, a5 )

#define Validate_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 ValidateParameters3( IABContainer_DeleteEntries, a1, a2, a3 )
#define UlValidate_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 UlValidateParameters3( IABContainer_DeleteEntries, a1, a2, a3 )
#define CheckParameters_IABContainer_DeleteEntries( a1, a2, a3 ) \
			 CheckParameters3( IABContainer_DeleteEntries, a1, a2, a3 )

#define Validate_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )
#define UlValidate_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IABContainer_ResolveNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABContainer_ResolveNames, a1, a2, a3, a4, a5 )


/* IDistList */

#define Validate_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_CreateEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_CreateEntry, a1, a2, a3, a4, a5 )

#define Validate_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_CopyEntries( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_CopyEntries, a1, a2, a3, a4, a5 )

#define Validate_IDistList_DeleteEntries( a1, a2, a3 ) \
			 ValidateParameters3( IDistList_DeleteEntries, a1, a2, a3 )
#define UlValidate_IDistList_DeleteEntries( a1, a2, a3 ) \
			 UlValidateParameters3( IDistList_DeleteEntries, a1, a2, a3 )
#define CheckParameters_IDistList_DeleteEntries( a1, a2, a3 ) \
			 CheckParameters3( IDistList_DeleteEntries, a1, a2, a3 )

#define Validate_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )
#define UlValidate_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )
#define CheckParameters_IDistList_ResolveNames( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IDistList_ResolveNames, a1, a2, a3, a4, a5 )


/* IMAPIFolder */

#define Validate_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )
#define UlValidate_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )
#define CheckParameters_IMAPIFolder_CreateMessage( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIFolder_CreateMessage, a1, a2, a3, a4 )

#define Validate_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIFolder_CopyMessages( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIFolder_CopyMessages, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_DeleteMessages( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_DeleteMessages, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMAPIFolder_CreateFolder( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMAPIFolder_CreateFolder, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 ValidateParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define UlValidate_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 UlValidateParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters_IMAPIFolder_CopyFolder( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 CheckParameters9( IMAPIFolder_CopyFolder, a1, a2, a3, a4, a5, a6, a7, a8, a9 )

#define Validate_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIFolder_DeleteFolder( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIFolder_DeleteFolder, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_SetReadFlags( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_SetReadFlags, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIFolder_GetMessageStatus( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIFolder_GetMessageStatus, a1, a2, a3, a4, a5 )

#define Validate_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMAPIFolder_SetMessageStatus( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMAPIFolder_SetMessageStatus, a1, a2, a3, a4, a5, a6 )

#define Validate_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )
#define UlValidate_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )
#define CheckParameters_IMAPIFolder_SaveContentsSort( a1, a2, a3 ) \
			 CheckParameters3( IMAPIFolder_SaveContentsSort, a1, a2, a3 )

#define Validate_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )
#define UlValidate_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )
#define CheckParameters_IMAPIFolder_EmptyFolder( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIFolder_EmptyFolder, a1, a2, a3, a4 )


/* IMsgStore */

#define Validate_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMsgStore_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMsgStore_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IMsgStore_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMsgStore_Unadvise, a1, a2 )
#define UlValidate_IMsgStore_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_Unadvise, a1, a2 )
#define CheckParameters_IMsgStore_Unadvise( a1, a2 ) \
			 CheckParameters2( IMsgStore_Unadvise, a1, a2 )

#define Validate_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMsgStore_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMsgStore_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMsgStore_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMsgStore_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )
#define UlValidate_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )
#define CheckParameters_IMsgStore_SetReceiveFolder( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMsgStore_SetReceiveFolder, a1, a2, a3, a4, a5 )

#define Validate_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMsgStore_GetReceiveFolder( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMsgStore_GetReceiveFolder, a1, a2, a3, a4, a5, a6 )

#define Validate_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )
#define UlValidate_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )
#define CheckParameters_IMsgStore_GetReceiveFolderTable( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_GetReceiveFolderTable, a1, a2, a3 )

#define Validate_IMsgStore_StoreLogoff( a1, a2 ) \
			 ValidateParameters2( IMsgStore_StoreLogoff, a1, a2 )
#define UlValidate_IMsgStore_StoreLogoff( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_StoreLogoff, a1, a2 )
#define CheckParameters_IMsgStore_StoreLogoff( a1, a2 ) \
			 CheckParameters2( IMsgStore_StoreLogoff, a1, a2 )

#define Validate_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )
#define UlValidate_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )
#define CheckParameters_IMsgStore_AbortSubmit( a1, a2, a3, a4 ) \
			 CheckParameters4( IMsgStore_AbortSubmit, a1, a2, a3, a4 )

#define Validate_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )
#define UlValidate_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )
#define CheckParameters_IMsgStore_GetOutgoingQueue( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_GetOutgoingQueue, a1, a2, a3 )

#define Validate_IMsgStore_SetLockState( a1, a2, a3 ) \
			 ValidateParameters3( IMsgStore_SetLockState, a1, a2, a3 )
#define UlValidate_IMsgStore_SetLockState( a1, a2, a3 ) \
			 UlValidateParameters3( IMsgStore_SetLockState, a1, a2, a3 )
#define CheckParameters_IMsgStore_SetLockState( a1, a2, a3 ) \
			 CheckParameters3( IMsgStore_SetLockState, a1, a2, a3 )

#define Validate_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )
#define UlValidate_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )
#define CheckParameters_IMsgStore_FinishedMsg( a1, a2, a3, a4 ) \
			 CheckParameters4( IMsgStore_FinishedMsg, a1, a2, a3, a4 )

#define Validate_IMsgStore_NotifyNewMail( a1, a2 ) \
			 ValidateParameters2( IMsgStore_NotifyNewMail, a1, a2 )
#define UlValidate_IMsgStore_NotifyNewMail( a1, a2 ) \
			 UlValidateParameters2( IMsgStore_NotifyNewMail, a1, a2 )
#define CheckParameters_IMsgStore_NotifyNewMail( a1, a2 ) \
			 CheckParameters2( IMsgStore_NotifyNewMail, a1, a2 )


/* IMessage */

#define Validate_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )
#define UlValidate_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )
#define CheckParameters_IMessage_GetAttachmentTable( a1, a2, a3 ) \
			 CheckParameters3( IMessage_GetAttachmentTable, a1, a2, a3 )

#define Validate_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_OpenAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_OpenAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_CreateAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_CreateAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )
#define UlValidate_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )
#define CheckParameters_IMessage_DeleteAttach( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMessage_DeleteAttach, a1, a2, a3, a4, a5 )

#define Validate_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_GetRecipientTable, a1, a2, a3 )
#define UlValidate_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_GetRecipientTable, a1, a2, a3 )
#define CheckParameters_IMessage_GetRecipientTable( a1, a2, a3 ) \
			 CheckParameters3( IMessage_GetRecipientTable, a1, a2, a3 )

#define Validate_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 ValidateParameters3( IMessage_ModifyRecipients, a1, a2, a3 )
#define UlValidate_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 UlValidateParameters3( IMessage_ModifyRecipients, a1, a2, a3 )
#define CheckParameters_IMessage_ModifyRecipients( a1, a2, a3 ) \
			 CheckParameters3( IMessage_ModifyRecipients, a1, a2, a3 )

#define Validate_IMessage_SubmitMessage( a1, a2 ) \
			 ValidateParameters2( IMessage_SubmitMessage, a1, a2 )
#define UlValidate_IMessage_SubmitMessage( a1, a2 ) \
			 UlValidateParameters2( IMessage_SubmitMessage, a1, a2 )
#define CheckParameters_IMessage_SubmitMessage( a1, a2 ) \
			 CheckParameters2( IMessage_SubmitMessage, a1, a2 )

#define Validate_IMessage_SetReadFlag( a1, a2 ) \
			 ValidateParameters2( IMessage_SetReadFlag, a1, a2 )
#define UlValidate_IMessage_SetReadFlag( a1, a2 ) \
			 UlValidateParameters2( IMessage_SetReadFlag, a1, a2 )
#define CheckParameters_IMessage_SetReadFlag( a1, a2 ) \
			 CheckParameters2( IMessage_SetReadFlag, a1, a2 )


/* IABProvider */

#define Validate_IABProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IABProvider_Shutdown, a1, a2 )
#define UlValidate_IABProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IABProvider_Shutdown, a1, a2 )
#define CheckParameters_IABProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IABProvider_Shutdown, a1, a2 )

#define Validate_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 ValidateParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define UlValidate_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 UlValidateParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )
#define CheckParameters_IABProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9 ) \
			 CheckParameters9( IABProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9 )


/* IABLogon */

#define Validate_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IABLogon_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IABLogon_GetLastError, a1, a2, a3, a4 )

#define Validate_IABLogon_Logoff( a1, a2 ) \
			 ValidateParameters2( IABLogon_Logoff, a1, a2 )
#define UlValidate_IABLogon_Logoff( a1, a2 ) \
			 UlValidateParameters2( IABLogon_Logoff, a1, a2 )
#define CheckParameters_IABLogon_Logoff( a1, a2 ) \
			 CheckParameters2( IABLogon_Logoff, a1, a2 )

#define Validate_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IABLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IABLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IABLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IABLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IABLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IABLogon_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IABLogon_Unadvise( a1, a2 ) \
			 ValidateParameters2( IABLogon_Unadvise, a1, a2 )
#define UlValidate_IABLogon_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IABLogon_Unadvise, a1, a2 )
#define CheckParameters_IABLogon_Unadvise( a1, a2 ) \
			 CheckParameters2( IABLogon_Unadvise, a1, a2 )

#define Validate_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IABLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IABLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )

#define Validate_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 ValidateParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )
#define UlValidate_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 UlValidateParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )
#define CheckParameters_IABLogon_OpenTemplateID( a1, a2, a3, a4, a5, a6, a7, a8 ) \
			 CheckParameters8( IABLogon_OpenTemplateID, a1, a2, a3, a4, a5, a6, a7, a8 )

#define Validate_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 ValidateParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )
#define UlValidate_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 UlValidateParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )
#define CheckParameters_IABLogon_GetOneOffTable( a1, a2, a3 ) \
			 CheckParameters3( IABLogon_GetOneOffTable, a1, a2, a3 )

#define Validate_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 ValidateParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )
#define UlValidate_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )
#define CheckParameters_IABLogon_PrepareRecips( a1, a2, a3, a4 ) \
			 CheckParameters4( IABLogon_PrepareRecips, a1, a2, a3, a4 )


/* IXPProvider */

#define Validate_IXPProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IXPProvider_Shutdown, a1, a2 )
#define UlValidate_IXPProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IXPProvider_Shutdown, a1, a2 )
#define CheckParameters_IXPProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IXPProvider_Shutdown, a1, a2 )

#define Validate_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IXPProvider_TransportLogon( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IXPProvider_TransportLogon, a1, a2, a3, a4, a5, a6, a7 )


/* IXPLogon */

#define Validate_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IXPLogon_AddressTypes( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IXPLogon_AddressTypes, a1, a2, a3, a4, a5, a6 )

#define Validate_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 ValidateParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )
#define UlValidate_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )
#define CheckParameters_IXPLogon_RegisterOptions( a1, a2, a3, a4 ) \
			 CheckParameters4( IXPLogon_RegisterOptions, a1, a2, a3, a4 )

#define Validate_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_TransportNotify, a1, a2, a3 )
#define UlValidate_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_TransportNotify, a1, a2, a3 )
#define CheckParameters_IXPLogon_TransportNotify( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_TransportNotify, a1, a2, a3 )

#define Validate_IXPLogon_Idle( a1, a2 ) \
			 ValidateParameters2( IXPLogon_Idle, a1, a2 )
#define UlValidate_IXPLogon_Idle( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_Idle, a1, a2 )
#define CheckParameters_IXPLogon_Idle( a1, a2 ) \
			 CheckParameters2( IXPLogon_Idle, a1, a2 )

#define Validate_IXPLogon_TransportLogoff( a1, a2 ) \
			 ValidateParameters2( IXPLogon_TransportLogoff, a1, a2 )
#define UlValidate_IXPLogon_TransportLogoff( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_TransportLogoff, a1, a2 )
#define CheckParameters_IXPLogon_TransportLogoff( a1, a2 ) \
			 CheckParameters2( IXPLogon_TransportLogoff, a1, a2 )

#define Validate_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_SubmitMessage( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_SubmitMessage, a1, a2, a3, a4, a5 )

#define Validate_IXPLogon_EndMessage( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_EndMessage, a1, a2, a3 )
#define UlValidate_IXPLogon_EndMessage( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_EndMessage, a1, a2, a3 )
#define CheckParameters_IXPLogon_EndMessage( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_EndMessage, a1, a2, a3 )

#define Validate_IXPLogon_Poll( a1, a2 ) \
			 ValidateParameters2( IXPLogon_Poll, a1, a2 )
#define UlValidate_IXPLogon_Poll( a1, a2 ) \
			 UlValidateParameters2( IXPLogon_Poll, a1, a2 )
#define CheckParameters_IXPLogon_Poll( a1, a2 ) \
			 CheckParameters2( IXPLogon_Poll, a1, a2 )

#define Validate_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 ValidateParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )
#define UlValidate_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )
#define CheckParameters_IXPLogon_StartMessage( a1, a2, a3, a4 ) \
			 CheckParameters4( IXPLogon_StartMessage, a1, a2, a3, a4 )

#define Validate_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )

#define Validate_IXPLogon_ValidateState( a1, a2, a3 ) \
			 ValidateParameters3( IXPLogon_ValidateState, a1, a2, a3 )
#define UlValidate_IXPLogon_ValidateState( a1, a2, a3 ) \
			 UlValidateParameters3( IXPLogon_ValidateState, a1, a2, a3 )
#define CheckParameters_IXPLogon_ValidateState( a1, a2, a3 ) \
			 CheckParameters3( IXPLogon_ValidateState, a1, a2, a3 )

#define Validate_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )
#define UlValidate_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )
#define CheckParameters_IXPLogon_FlushQueues( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IXPLogon_FlushQueues, a1, a2, a3, a4, a5 )


/* IMSProvider */

#define Validate_IMSProvider_Shutdown( a1, a2 ) \
			 ValidateParameters2( IMSProvider_Shutdown, a1, a2 )
#define UlValidate_IMSProvider_Shutdown( a1, a2 ) \
			 UlValidateParameters2( IMSProvider_Shutdown, a1, a2 )
#define CheckParameters_IMSProvider_Shutdown( a1, a2 ) \
			 CheckParameters2( IMSProvider_Shutdown, a1, a2 )

#define Validate_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 ValidateParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define UlValidate_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 UlValidateParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters_IMSProvider_Logon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 CheckParameters13( IMSProvider_Logon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )

#define Validate_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 ValidateParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define UlValidate_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 UlValidateParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )
#define CheckParameters_IMSProvider_SpoolerLogon( a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 ) \
			 CheckParameters13( IMSProvider_SpoolerLogon, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13 )

#define Validate_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSProvider_CompareStoreIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSProvider_CompareStoreIDs, a1, a2, a3, a4, a5, a6, a7 )


/* IMSLogon */

#define Validate_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMSLogon_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMSLogon_GetLastError, a1, a2, a3, a4 )

#define Validate_IMSLogon_Logoff( a1, a2 ) \
			 ValidateParameters2( IMSLogon_Logoff, a1, a2 )
#define UlValidate_IMSLogon_Logoff( a1, a2 ) \
			 UlValidateParameters2( IMSLogon_Logoff, a1, a2 )
#define CheckParameters_IMSLogon_Logoff( a1, a2 ) \
			 CheckParameters2( IMSLogon_Logoff, a1, a2 )

#define Validate_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSLogon_OpenEntry( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSLogon_OpenEntry, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 ValidateParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define UlValidate_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 UlValidateParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )
#define CheckParameters_IMSLogon_CompareEntryIDs( a1, a2, a3, a4, a5, a6, a7 ) \
			 CheckParameters7( IMSLogon_CompareEntryIDs, a1, a2, a3, a4, a5, a6, a7 )

#define Validate_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 ValidateParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define UlValidate_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 UlValidateParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )
#define CheckParameters_IMSLogon_Advise( a1, a2, a3, a4, a5, a6 ) \
			 CheckParameters6( IMSLogon_Advise, a1, a2, a3, a4, a5, a6 )

#define Validate_IMSLogon_Unadvise( a1, a2 ) \
			 ValidateParameters2( IMSLogon_Unadvise, a1, a2 )
#define UlValidate_IMSLogon_Unadvise( a1, a2 ) \
			 UlValidateParameters2( IMSLogon_Unadvise, a1, a2 )
#define CheckParameters_IMSLogon_Unadvise( a1, a2 ) \
			 CheckParameters2( IMSLogon_Unadvise, a1, a2 )

#define Validate_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define UlValidate_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )
#define CheckParameters_IMSLogon_OpenStatusEntry( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMSLogon_OpenStatusEntry, a1, a2, a3, a4, a5 )


/* IMAPIControl */

#define Validate_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )
#define UlValidate_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )
#define CheckParameters_IMAPIControl_GetLastError( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIControl_GetLastError, a1, a2, a3, a4 )

#define Validate_IMAPIControl_Activate( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIControl_Activate, a1, a2, a3 )
#define UlValidate_IMAPIControl_Activate( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIControl_Activate, a1, a2, a3 )
#define CheckParameters_IMAPIControl_Activate( a1, a2, a3 ) \
			 CheckParameters3( IMAPIControl_Activate, a1, a2, a3 )

#define Validate_IMAPIControl_GetState( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIControl_GetState, a1, a2, a3 )
#define UlValidate_IMAPIControl_GetState( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIControl_GetState, a1, a2, a3 )
#define CheckParameters_IMAPIControl_GetState( a1, a2, a3 ) \
			 CheckParameters3( IMAPIControl_GetState, a1, a2, a3 )


/* IMAPIStatus */

#define Validate_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )
#define UlValidate_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )
#define CheckParameters_IMAPIStatus_ValidateState( a1, a2, a3 ) \
			 CheckParameters3( IMAPIStatus_ValidateState, a1, a2, a3 )

#define Validate_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )
#define UlValidate_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )
#define CheckParameters_IMAPIStatus_SettingsDialog( a1, a2, a3 ) \
			 CheckParameters3( IMAPIStatus_SettingsDialog, a1, a2, a3 )

#define Validate_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 ValidateParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )
#define UlValidate_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )
#define CheckParameters_IMAPIStatus_ChangePassword( a1, a2, a3, a4 ) \
			 CheckParameters4( IMAPIStatus_ChangePassword, a1, a2, a3, a4 )

#define Validate_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )
#define UlValidate_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )
#define CheckParameters_IMAPIStatus_FlushQueues( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IMAPIStatus_FlushQueues, a1, a2, a3, a4, a5 )


/* IStream */

#define Validate_IStream_Read( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Read, a1, a2, a3, a4 )
#define UlValidate_IStream_Read( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Read, a1, a2, a3, a4 )
#define CheckParameters_IStream_Read( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Read, a1, a2, a3, a4 )

#define Validate_IStream_Write( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Write, a1, a2, a3, a4 )
#define UlValidate_IStream_Write( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Write, a1, a2, a3, a4 )
#define CheckParameters_IStream_Write( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Write, a1, a2, a3, a4 )

#define Validate_IStream_Seek( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_Seek, a1, a2, a3, a4 )
#define UlValidate_IStream_Seek( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_Seek, a1, a2, a3, a4 )
#define CheckParameters_IStream_Seek( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_Seek, a1, a2, a3, a4 )

#define Validate_IStream_SetSize( a1, a2 ) \
			 ValidateParameters2( IStream_SetSize, a1, a2 )
#define UlValidate_IStream_SetSize( a1, a2 ) \
			 UlValidateParameters2( IStream_SetSize, a1, a2 )
#define CheckParameters_IStream_SetSize( a1, a2 ) \
			 CheckParameters2( IStream_SetSize, a1, a2 )

#define Validate_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 ValidateParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )
#define UlValidate_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 UlValidateParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )
#define CheckParameters_IStream_CopyTo( a1, a2, a3, a4, a5 ) \
			 CheckParameters5( IStream_CopyTo, a1, a2, a3, a4, a5 )

#define Validate_IStream_Commit( a1, a2 ) \
			 ValidateParameters2( IStream_Commit, a1, a2 )
#define UlValidate_IStream_Commit( a1, a2 ) \
			 UlValidateParameters2( IStream_Commit, a1, a2 )
#define CheckParameters_IStream_Commit( a1, a2 ) \
			 CheckParameters2( IStream_Commit, a1, a2 )

#define Validate_IStream_Revert( a1 ) \
			 ValidateParameters1( IStream_Revert, a1 )
#define UlValidate_IStream_Revert( a1 ) \
			 UlValidateParameters1( IStream_Revert, a1 )
#define CheckParameters_IStream_Revert( a1 ) \
			 CheckParameters1( IStream_Revert, a1 )

#define Validate_IStream_LockRegion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_LockRegion, a1, a2, a3, a4 )
#define UlValidate_IStream_LockRegion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_LockRegion, a1, a2, a3, a4 )
#define CheckParameters_IStream_LockRegion( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_LockRegion, a1, a2, a3, a4 )

#define Validate_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 ValidateParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )
#define UlValidate_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 UlValidateParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )
#define CheckParameters_IStream_UnlockRegion( a1, a2, a3, a4 ) \
			 CheckParameters4( IStream_UnlockRegion, a1, a2, a3, a4 )

#define Validate_IStream_Stat( a1, a2, a3 ) \
			 ValidateParameters3( IStream_Stat, a1, a2, a3 )
#define UlValidate_IStream_Stat( a1, a2, a3 ) \
			 UlValidateParameters3( IStream_Stat, a1, a2, a3 )
#define CheckParameters_IStream_Stat( a1, a2, a3 ) \
			 CheckParameters3( IStream_Stat, a1, a2, a3 )

#define Validate_IStream_Clone( a1, a2 ) \
			 ValidateParameters2( IStream_Clone, a1, a2 )
#define UlValidate_IStream_Clone( a1, a2 ) \
			 UlValidateParameters2( IStream_Clone, a1, a2 )
#define CheckParameters_IStream_Clone( a1, a2 ) \
			 CheckParameters2( IStream_Clone, a1, a2 )


/* IMAPIAdviseSink */

#define Validate_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 ValidateParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )
#define UlValidate_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 UlValidateParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )
#define CheckParameters_IMAPIAdviseSink_OnNotify( a1, a2, a3 ) \
			 CheckParameters3( IMAPIAdviseSink_OnNotify, a1, a2, a3 )


#ifdef WIN16
HRESULT
PASCAL	HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg );
#elif defined(_X86_)
STDAPI	HrValidateParameters( METHODS eMethod, LPVOID FAR *ppFirstArg );
#else
STDAPIV	HrValidateParametersV( METHODS eMethod, ... );
STDAPIV HrValidateParametersValist( METHODS eMethod, va_list arglist );
#endif /* WIN16 */


#ifdef __cplusplus
}
#endif

#endif	/* _INC_VALIDATE */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPIWin.h ===
/*
 *	M A P I W I N . H
 *
 *	Definitions used by the MAPI Development Team to aid in
 *	developing single-source service providers that run on
 *	both WIN32 and WIN16 platforms.
 *	There are three sections.
 *
 *	The first section defines how to call something that
 *	is available by different methods in WIN16 vs. WIN32.
 *	As such, they are totally new mechanisms.
 *
 *	The second section establishes things that are available
 *	AS-IS in one environment but we have to define for the
 *	other environment.
 *
 *	The third section simply defines a few conventions
 *	(simplifications) for common operations.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

/*
 *	Routines are included in the first section to manage per-instance
 *	global variables for DLLs. They assume that all of the DLL's
 *	per-instance global variables live in a single block of memory.
 *	Functions are provided to install and retrieve the correct block of
 *	memory for the current instance.
 *
 *	There are only two functions:
 *
 *		PvGetInstanceGlobals	Call this to get the address of the
 *								per-instance globals structure.
 *		ScSetinstanceGlobals	Call this to install the
 *								per-instance globals structure. It
 *								may fail if the number of instances
 *								exceeds a certain limit.
 *
 *	The caller is free to choose the name, size, and allocation
 *	method of the per-instance global variables structure.
 *
 *	The WIN32 implementation uses a pointer in the DLL's data
 *	segment. This assumes that the DLL gets a separate instance
 *	of the default data segment per calling process.
 *
 *	The WIN16 implementation uses a fixed array of pointers and a
 *	matching fixed array of keys unique to the calling process.
 */

/*
 *	The second section consists largely of Win32 file I/O functions
 *	that are not supported under Win16. These functions are
 *	implemented in mapiwin.c, using DOS calls. Most have limitations
 *	relative to their Win32 counterparts, which are spelled out in
 *	the comments to the source code.
 */

#ifndef __MAPIWIN_H__
#define __MAPIWIN_H__

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#include "mapinls.h"

#ifdef __cplusplus
extern "C" {
#endif


/********************************/
/*	Our conventions for things	*/
/*	we choose to do differently	*/
/*	on WIN16 vs. WIN32.			*/
/********************************/

#ifdef	WIN16

#define	MULDIV(x,y,z)				MulDiv32(x,y,z)
#define IsBadReadPtr(lp,cb)			FBadReadPtr(lp,cb)

#define cInstMax					50
LPVOID FAR PASCAL	PvGetInstanceGlobals(void);
LONG FAR PASCAL		ScSetInstanceGlobals(LPVOID pv);
LONG FAR PASCAL		ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid);
LPVOID FAR PASCAL	PvGetVerifyInstanceGlobals(DWORD dwPid);
LPVOID FAR PASCAL	PvSlowGetInstanceGlobals(DWORD dwPid);
BOOL __export FAR PASCAL FCleanupInstanceGlobals(WORD, DWORD);

#elif defined(_MAC)	/* !WIN16 */

#define	MULDIV(x,y,z)				MulDiv(x,y,z)

LPVOID FAR PASCAL	PvGetInstanceGlobals(WORD wDataSet);
LONG FAR PASCAL		ScSetInstanceGlobals(LPVOID pv, WORD wDataSet);
LONG FAR PASCAL		ScSetVerifyInstanceGlobals(LPVOID pv, DWORD dwPid,
						WORD wDataSet);
LPVOID FAR PASCAL	PvGetVerifyInstanceGlobals(DWORD dwPid, DWORD wDataSet);
LPVOID FAR PASCAL	PvSlowGetInstanceGlobals(DWORD dwPid, DWORD wDataSet);
BOOL FAR PASCAL		FCleanupInstanceGlobals(WORD, DWORD);

#else	/* !WIN16 */

#define	MULDIV(x,y,z)				MulDiv(x,y,z)

extern LPVOID pinstX;
#define PvGetInstanceGlobals()					pinstX
#define ScSetInstanceGlobals(_pv)				(pinstX = _pv, 0)
#define PvGetVerifyInstanceGlobals(_pid)		pinstX
#define ScSetVerifyInstanceGlobals(_pv,_pid)	(pinstX = _pv, 0)
#define PvSlowGetInstanceGlobals(_pid)			pinstX

#endif	/* WIN16 */

#if defined(_WIN32) && !defined(_MAC)
#define szMAPIDLLSuffix		"32"
#elif defined(WIN16) || defined(DOS)
#define szMAPIDLLSuffix		""
#elif  defined(_MAC)
#define szMAPIDLLSuffix		"M"
#else
#error "Don't know the suffix for DLLs on this platform"
#endif

/********************************/
/*  Things missing from one		*/
/*	system-provided environment	*/
/*	or the other.				*/
/********************************/

#if !defined(_WIN32)
#define	ZeroMemory(pb,cb)			memset((pb),0,(cb))
#define FillMemory(pb,cb,b)			memset((pb),(b),(cb))
#define CopyMemory(pbDst,pbSrc,cb)	do								\
									{								\
										size_t _cb = (size_t)(cb);	\
										if (_cb)					\
											memcpy(pbDst,pbSrc,_cb);\
									} while (FALSE)
#define MoveMemory(pbDst,pbSrc,cb)	memmove((pbDst),(pbSrc),(cb))

#define UNALIGNED

#endif

#if defined(WIN16) || defined(_MAC)

#ifndef _MAC
#include <error.h>				/*	for GetLastError() */
#endif

typedef	int					INT;
typedef	unsigned long		ULONG;
typedef	short				SHORT;
typedef	unsigned short		USHORT;
typedef double 				LONGLONG;
typedef double 				DWORDLONG;
typedef unsigned char		UCHAR;
typedef unsigned char FAR*	PUCHAR;
typedef int					BOOL;


#ifndef _MAC
typedef char				BOOLEAN;

#ifndef _FILETIME_
#define _FILETIME_
typedef struct tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif		/* _FILETIME */

typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, FAR *LPSYSTEMTIME;

typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    CHAR StandardName[ 32 ];		/* was WCHAR */
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    CHAR DaylightName[ 32 ];		/* was WCHAR */
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, FAR *LPTIME_ZONE_INFORMATION;


#if defined(DOS) || defined(WIN16)
/* Simulate effect of afx header */
#define __T(x)		x
#define _T(x)		__T(x)
#define TEXT		_T
#endif

#define APIENTRY		WINAPI

#define	SetForegroundWindow			SetActiveWindow

#define wsprintfA					wsprintf
#define GetWindowsDirectoryA		GetWindowsDirectory
#define GetSystemDirectoryA			GetSystemDirectory
#define GetPrivateProfileStringA 	GetPrivateProfileString
#define GetPrivateProfileIntA		GetPrivateProfileInt
#define GetProfileStringA			GetProfileString
#define GetModuleFileNameA			GetModuleFileName
#define CharUpperBuffA				CharUpperBuff
#define LoadLibraryA				LoadLibrary
#define lstrcatA					lstrcat
#define RegisterWindowMessageA		RegisterWindowMessage
#define MAKEINTRESOURCEA			MAKEINTRESOURCE

#define WNDCLASSA					WNDCLASS									

#endif	/* !_MAC */

/* Synchronization */
#define InterlockedIncrement(plong)	(++(*(plong)))
#define InterlockedDecrement(plong) (--(*(plong)))

#ifndef CreateMutex
#define CreateMutexA	CreateMutex
#define CreateMutexW	CreateMutex
#define CreateMutex(pv, bool, sz)	(INVALID_HANDLE_VALUE)
#endif

#define WaitForSingleObject(hObj, dw)	((void)0)
#define ReleaseMutex(hObj)				((BOOL)1)
#define CloseMutexHandle(hObj)			TRUE

#define	CRITICAL_SECTION			ULONG
#define	InitializeCriticalSection(_pcs)	((void)0)
#define	DeleteCriticalSection(_pcs)		((void)0)
#define	EnterCriticalSection(_pcs)		((void)0)
#define	LeaveCriticalSection(_pcs)		((void)0)

#define MAX_PATH					260

#ifndef	_MAC
/*
 *	File Access Modes
 *
 *	The possible combination of file access modes as passed into
 *	the CreateFile() api map to OpenFile() as follows:
 *
 *	 GENERIC_READ						OPEN_ACCESS_READONLY
 *	 GENERIC_WRITE						OPEN_ACCESS_WRITEONLY
 *	 GENERIC_READ | GENERIC_WRITE		OPEN_ACCESS_READWRITE
 *
 *	 0									OPEN_SHARE_DENYREADWRITE
 *	 FILE_SHARE_READ					OPEN_SHARE_DENYWRITE
 *	 FILE_SHARE_WRITE					OPEN_SHARE_DENYREAD
 *	 FILE_SHARE_READ | FILE_SHARE_WRITE	OPEN_SHARE_DENYNONE
 *
 *	Due to the mappings we cannot pass them through directly,
 *	so we will have to use a conversion within APIs that test
 *	these bits.  It would be best to use the Win32 #defines
 *	for these flags and convert as needed in the APIs.
 */
#define GENERIC_READ				(0x80000000) /* from WINNT.H */
#define GENERIC_WRITE				(0x40000000) /* from WINNT.H */
#define FILE_SHARE_READ				(0x00000001) /* from WINNT.H */
#define FILE_SHARE_WRITE			(0x00000002) /* from WINNT.H */
#endif	/* _MAC */

#define FILE_FLAG_SEQUENTIAL_SCAN	0x08000000

#define CREATE_NEW          1
#define CREATE_ALWAYS       2
#define OPEN_EXISTING       3
#define OPEN_ALWAYS         4
#define TRUNCATE_EXISTING   5

#ifndef _MAC
#define INVALID_HANDLE_VALUE		((HANDLE)(-1))
#define DELETE						0x00010000L

#define FILE_BEGIN					0
#define FILE_CURRENT				1
#define FILE_END					2
#endif

#define FILE_ATTRIBUTE_READONLY         0x00000001
#define FILE_ATTRIBUTE_HIDDEN           0x00000002
#define FILE_ATTRIBUTE_SYSTEM           0x00000004
#define FILE_ATTRIBUTE_DIRECTORY        0x00000010
#define FILE_ATTRIBUTE_ARCHIVE          0x00000020
#define FILE_ATTRIBUTE_NORMAL           0x00000080
#define	FILE_ATTRIBUTE_TEMPORARY		0x00000100

#define FILE_FLAG_WRITE_THROUGH     0x80000000
#define FILE_FLAG_RANDOM_ACCESS     0x10000000

#ifndef _MAC
typedef struct _WIN32_FIND_DATA {
    DWORD		dwFileAttributes;
    FILETIME	ftCreationTime;
    FILETIME	ftLastAccessTime;
    FILETIME	ftLastWriteTime;
    DWORD		nFileSizeHigh;
    DWORD		nFileSizeLow;
    DWORD		dwReserved0;
    DWORD		dwReserved1;
    CHAR		cFileName[ MAX_PATH ];
    CHAR		cAlternateFileName[ 16 ];
} WIN32_FIND_DATA, *PWIN32_FIND_DATA, *LPWIN32_FIND_DATA;

#define TIME_ZONE_ID_INVALID		0xFFFFFFFF
#endif
#define TIME_ZONE_ID_UNKNOWN		0
#define TIME_ZONE_ID_STANDARD		1
#define TIME_ZONE_ID_DAYLIGHT		2



DWORD WINAPI	GetLastError(void);
DWORD WINAPI	GetFileAttributes(LPCSTR lpFileName);
DWORD WINAPI	GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);
BOOL WINAPI		GetFileTime(HANDLE hFile, FILETIME FAR *lpftCreation,
				FILETIME FAR *lpftLastAccess, FILETIME FAR *lpftLastWrite);
BOOL WINAPI		SetFileTime(HANDLE hFile, const FILETIME FAR *lpftCreation,
				const FILETIME FAR *lpftLastAccess,
				const FILETIME FAR *lpftLastWrite);
#ifndef _MAC
/*  IsTask can crash - here's a safer one.  */
BOOL WINAPI		FIsTask(HTASK hTask);

HANDLE WINAPI	CreateFile(LPCSTR lpFileName, DWORD dwDesiredAccess,
				DWORD dwShareMode, LPVOID lpSecurityAttributes,
				DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes,
				HANDLE hTemplateFile);
BOOL WINAPI		ReadFile(HANDLE hFile, LPVOID lpBuffer,
				DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead,
				LPVOID lpOverlapped);
BOOL WINAPI		WriteFile(HANDLE hFile, LPCVOID lpBuffer,
				DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten,
				LPVOID lpOverlapped);
#endif
DWORD WINAPI	SetFilePointer(HANDLE hFile, LONG lDistanceToMove,
				LONG FAR *lpDistanceToMoveHigh, DWORD dwMoveMethod);
BOOL WINAPI		SetEndOfFile(HANDLE hFile);
BOOL WINAPI		CloseHandle(HANDLE hObject);
DWORD WINAPI	GetTempPath(DWORD nBufferLength, LPSTR lpBuffer);
UINT WINAPI		GetTempFileName32 (LPCSTR lpPathName, LPCSTR lpPrefixString,
				UINT uUnique, LPSTR lpTempFileName);
BOOL WINAPI		DeleteFile(LPCSTR lpFileName);
#ifndef _MAC
BOOL WINAPI		CreateDirectory(LPCSTR lpPathName, LPVOID lpSecurityAttributes);
#endif
BOOL WINAPI		RemoveDirectory(LPCSTR lpPathName);
BOOL WINAPI		CopyFile(LPCSTR szSrc, LPCSTR szDst, BOOL fFailIfExists);
BOOL WINAPI		MoveFile(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
HANDLE WINAPI	FindFirstFile(LPCSTR lpFileName, LPWIN32_FIND_DATA lpFindFileData);
BOOL WINAPI		FindNextFile(HANDLE hFindFile, LPWIN32_FIND_DATA lpFindFileData);
BOOL WINAPI		FindClose(HANDLE hFindFile);
DWORD WINAPI	GetFullPathName(LPCSTR lpFileName, DWORD nBufferLength,
			    LPSTR lpBuffer, LPSTR *lpFilePart);
void WINAPI		Sleep(DWORD dwMilliseconds);
LONG WINAPI		CompareFileTime(const FILETIME FAR *, const FILETIME FAR *);
BOOL WINAPI		LocalFileTimeToFileTime(const FILETIME FAR *, FILETIME FAR *);
BOOL WINAPI		FileTimeToLocalFileTime(const FILETIME FAR *, FILETIME FAR *);
BOOL WINAPI		FileTimeToSystemTime(const FILETIME FAR *, SYSTEMTIME FAR *);
BOOL WINAPI		SystemTimeToFileTime(const SYSTEMTIME FAR *, FILETIME FAR *);
void WINAPI		GetSystemTime(SYSTEMTIME FAR *);
void WINAPI		GetLocalTime(SYSTEMTIME FAR *);
BOOL WINAPI		FileTimeToDosDateTime(const FILETIME FAR * lpFileTime,
			    WORD FAR *lpFatDate, WORD FAR *lpFatTime);
BOOL WINAPI		DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime,
			    FILETIME FAR * lpFileTime);
DWORD WINAPI	GetTimeZoneInformation(
				LPTIME_ZONE_INFORMATION lpTimeZoneInformation);
BOOL WINAPI		SetTimeZoneInformation(
				const TIME_ZONE_INFORMATION FAR *lpTimeZoneInformation);

DWORD WINAPI	GetCurrentProcessId(void);
long WINAPI		MulDiv32(long, long, long);
#ifndef _MAC
BOOL WINAPI		FBadReadPtr(const void FAR* lp, UINT cb);
#endif

#else	/* !WIN16 */

/* Remaps GetTempFileName32() to the real 32bit version */

#define GetTempFileName32(_szPath,_szPfx,_n,_lpbuf)	GetTempFileName(_szPath,_szPfx,_n,_lpbuf)

#define CloseMutexHandle	CloseHandle

#endif	/* !WIN16 */


#ifdef _MAC
#define	CRITICAL_SECTION			ULONG
#define	InitializeCriticalSection(_pcs)	((void)0)
#define	DeleteCriticalSection(_pcs)		((void)0)
#define	EnterCriticalSection(_pcs)		((void)0)
#define	LeaveCriticalSection(_pcs)		((void)0)
#endif

/********************************/
/*	Our private conventions		*/
/*	(common to WIN16/WIN32)		*/
/********************************/

#define	Cbtszsize(_a)	((lstrlen(_a)+1)*sizeof(TCHAR))
#define	CbtszsizeA(_a)	((lstrlenA(_a) + 1))
#define	CbtszsizeW(_a)	((lstrlenW(_a) + 1) * sizeof(WCHAR))
#define HexCchOf(_s)	(sizeof(_s)*2+1)
#define HexSizeOf(_s)	(HexCchOf(_s)*sizeof(TCHAR))

BOOL WINAPI IsBadBoundedStringPtr(const void FAR* lpsz, UINT cchMax);

#ifdef __cplusplus
}
#endif

#endif /* __MAPIWIN_H__ */

=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPIUtil.h ===
/*
 *	M A P I U T I L . H
 *
 *  Definitions and prototypes for utility functions provided by MAPI
 *  in MAPI[xx].DLL.
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPIUTIL_H_
#define _MAPIUTIL_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MAPIX_H
#include <mapix.h>
#endif

#ifdef WIN16
#include <storage.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif


/* IMAPITable in memory */

/* ITableData Interface ---------------------------------------------------- */

DECLARE_MAPI_INTERFACE_PTR(ITableData, LPTABLEDATA);

typedef void (STDAPICALLTYPE CALLERRELEASE)(
	ULONG		ulCallerData,
	LPTABLEDATA	lpTblData,
	LPMAPITABLE	lpVue
);

#define MAPI_ITABLEDATA_METHODS(IPURE)									\
	MAPIMETHOD(HrGetView)												\
		(THIS_	LPSSortOrderSet				lpSSortOrderSet,			\
				CALLERRELEASE FAR *			lpfCallerRelease,			\
				ULONG						ulCallerData,				\
				LPMAPITABLE FAR *			lppMAPITable) IPURE;		\
	MAPIMETHOD(HrModifyRow)												\
		(THIS_	LPSRow) IPURE;											\
	MAPIMETHOD(HrDeleteRow)												\
		(THIS_	LPSPropValue				lpSPropValue) IPURE;		\
	MAPIMETHOD(HrQueryRow)												\
		(THIS_	LPSPropValue				lpsPropValue,				\
				LPSRow FAR *				lppSRow,					\
				ULONG FAR *					lpuliRow) IPURE;			\
	MAPIMETHOD(HrEnumRow)												\
		(THIS_	ULONG						ulRowNumber,				\
				LPSRow FAR *				lppSRow) IPURE;				\
	MAPIMETHOD(HrNotify)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cValues,					\
				LPSPropValue				lpSPropValue) IPURE;		\
	MAPIMETHOD(HrInsertRow)												\
		(THIS_	ULONG						uliRow,						\
				LPSRow						lpSRow) IPURE;				\
	MAPIMETHOD(HrModifyRows)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSRowSet) IPURE;			\
	MAPIMETHOD(HrDeleteRows)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lprowsetToDelete,			\
				ULONG FAR *					cRowsDeleted) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE	ITableData
DECLARE_MAPI_INTERFACE_(ITableData, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_ITABLEDATA_METHODS(PURE)
};


/* Entry Point for in memory ITable */


/*	CreateTable()
 *		Creates the internal memory structures and object handle
 *		to bring a new table into existence.
 *
 *	lpInterface
 *		Interface ID of the TableData object (IID_IMAPITableData)
 *
 *	lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *		Function addresses are provided by the caller so that
 *		this DLL allocates/frees memory appropriately.
 *	lpvReserved
 *		Reserved.  Should be NULL.
 *	ulTableType
 *		TBLTYPE_DYNAMIC, etc.  Visible to the calling application
 *		as part of the GetStatus return data on its views
 *	ulPropTagIndexColumn
 *		Index column for use when changing the data
 *	lpSPropTagArrayColumns
 *		Column proptags for the minimum set of columns in the table
 *	lppTableData
 *		Address of the pointer which will receive the TableData object
 */

STDAPI_(SCODE)
CreateTable( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 ULONG					ulTableType,
			 ULONG					ulPropTagIndexColumn,
			 LPSPropTagArray		lpSPropTagArrayColumns,
			 LPTABLEDATA FAR *		lppTableData );

/*	HrGetView()
 *		This function obtains a new view on the underlying data
 *		which supports the IMAPITable interface.  All rows and columns
 *		of the underlying table data are initially visible
 *	lpSSortOrderSet
 *		if specified, results in the view being sorted
 *	lpfCallerRelease
 *		pointer to a routine to be called when the view is released, or
 *		NULL.
 *	ulCallerData
 *		arbitrary data the caller wants saved with this view and returned in
 *		the Release callback.
 */

/*	HrModifyRows()
 *		Add or modify a set of rows in the table data
 *	ulFlags
 *		Must be zero
 *	lpSRowSet
 *		Each row in the row set contains all the properties for one row
 *		in the table.  One of the properties must be the index column.  Any
 *		row in the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added.
 *		Each row in LPSRowSet MUST have a unique Index column!
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */

/*	HrModifyRow()
 *		Add or modify one row in the table
 *	lpSRow
 *		This row contains all the properties for one row in the table.
 *		One of the properties must be the index column.	 Any row in
 *		the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */

/*	HrDeleteRows()
 *		Delete a row in the table.
 *	ulFlags
 *		TAD_ALL_ROWS - Causes all rows in the table to be deleted
 *					   lpSRowSet is ignored in this case.
 *	lpSRowSet
 *		Each row in the row set contains all the properties for one row
 *		in the table.  One of the properties must be the index column.  Any
 *		row in the table with the same value for its index column is
 *		deleted.
 *		Each row in LPSRowSet MUST have a unique Index column!
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */
#define	TAD_ALL_ROWS	1

/*	HrDeleteRow()
 *		Delete a row in the table.
 *	lpSPropValue
 *		This property value specifies the row which has this value
 *		for its index column
 */

/*	HrQueryRow()
 *		Returns the values of a specified row in the table
 *	lpSPropValue
 *		This property value specifies the row which has this value
 *		for its index column
 *	lppSRow
 *		Address of where to return a pointer to an SRow
 *	lpuliRow
 *	  Address of where to return the row number. This can be NULL
 *	  if the row number is not required.
 *
 */

/*	HrEnumRow()
 *		Returns the values of a specific (numbered) row in the table
 *	ulRowNumber
 *		Indicates row number 0 to n-1
 *	lppSRow
 *		Address of where to return a pointer to a SRow
 */

/*	HrInsertRow()
 *		Inserts a row into the table.
 *	uliRow
 *		The row number before which this row will be inserted into the table.
 *		Row numbers can be from 0 to n where o to n-1 result in row insertion
 *	  a row number of n results in the row being appended to the table.
 *	lpSRow
 *		This row contains all the properties for one row in the table.
 *		One of the properties must be the index column.	 Any row in
 *		the table with the same value for its index column is
 *		replaced, or if there is no current row with that value the
 *		row is added
 *		If any views are open, the view is updated as well.
 *		The properties do not have to be in the same order as the
 *		columns in the current table
 */


/* IMAPIProp in memory */

/* IPropData Interface ---------------------------------------------------- */


#define MAPI_IPROPDATA_METHODS(IPURE)									\
	MAPIMETHOD(HrSetObjAccess)											\
		(THIS_	ULONG						ulAccess) IPURE;			\
	MAPIMETHOD(HrSetPropAccess)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG FAR *					rgulAccess) IPURE;			\
	MAPIMETHOD(HrGetPropAccess)											\
		(THIS_	LPSPropTagArray FAR *		lppPropTagArray,			\
				ULONG FAR * FAR *			lprgulAccess) IPURE;		\
	MAPIMETHOD(HrAddObjProps)											\
		(THIS_	LPSPropTagArray				lppPropTagArray,			\
				LPSPropProblemArray FAR *	lprgulAccess) IPURE;


#undef		 INTERFACE
#define		 INTERFACE	IPropData
DECLARE_MAPI_INTERFACE_(IPropData, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IPROPDATA_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IPropData, LPPROPDATA);


/* Entry Point for in memory IMAPIProp */


/*	CreateIProp()
 *		Creates the internal memory structures and object handle
 *		to bring a new property interface into existance.
 *
 *	lpInterface
 *		Interface ID of the TableData object (IID_IMAPIPropData)
 *
 *	lpAllocateBuffer, lpAllocateMore, and lpFreeBuffer
 *		Function addresses are provided by the caller so that
 *		this DLL allocates/frees memory appropriately.
 *	lppPropData
 *		Address of the pointer which will receive the IPropData object
 *	lpvReserved
 *		Reserved.  Should be NULL.
 */

STDAPI_(SCODE)
CreateIProp( LPCIID					lpInterface,
			 ALLOCATEBUFFER FAR *	lpAllocateBuffer,
			 ALLOCATEMORE FAR *		lpAllocateMore,
			 FREEBUFFER FAR *		lpFreeBuffer,
			 LPVOID					lpvReserved,
			 LPPROPDATA FAR *		lppPropData );

/*
 *	Defines for prop/obj access
 */
#define IPROP_READONLY		((ULONG) 0x00000001)
#define IPROP_READWRITE		((ULONG) 0x00000002)
#define IPROP_CLEAN			((ULONG) 0x00010000)
#define IPROP_DIRTY			((ULONG) 0x00020000)

/*
 -	HrSetPropAccess
 -
 *	Sets access right attributes on a per-property basis.  By default,
 *	all properties are read/write.
 *
 */

/*
 -	HrSetObjAccess
 -
 *	Sets access rights for the object itself.  By default, the object has
 *	read/write access.
 *
 */

#ifndef NOIDLEENGINE

/* Idle time scheduler */

/*
 *	PRI
 *
 *	Priority of an idle task.
 *	The idle engine sorts tasks by priority, and the one with the higher
 *	value runs first. Within a priority level, the functions are called
 *	round-robin.
 */

#define PRILOWEST	-32768
#define PRIHIGHEST	32767
#define PRIUSER		0

/*
 *	IRO
 *
 *	Idle routine options.  This is a combined bit mask consisting of
 *	individual firo's.	Listed below are the possible bit flags.
 *
 *		FIROWAIT and FIROINTERVAL are mutually exclusive.
 *		If neither of the flags are specified, the default action
 *		is to ignore the time parameter of the idle function and
 *		call it as often as possible if firoPerBlock is not set;
 *		otherwise call it one time only during the idle block
 *		once the time constraint has been set. FIROINTERVAL
 *		is also incompatible with FIROPERBLOCK.
 *
 *		FIROWAIT		- time given is minimum idle time before calling
 *						  for the first time in the block of idle time,
 *						  afterwhich call as often as possible.
 *		FIROINTERVAL	- time given is minimum interval between each
 *						  successive call
 *		FIROPERBLOCK	- called only once per contiguous block of idle
 *						  time
 *		FIRODISABLED	- initially disabled when registered, the
 *						  default is to enable the function when registered.
 *		FIROONCEONLY	- called only one time by the scheduler and then
 *						  deregistered automatically.
 */

#define IRONULL			((USHORT) 0x0000)
#define FIROWAIT		((USHORT) 0x0001)
#define FIROINTERVAL	((USHORT) 0x0002)
#define FIROPERBLOCK	((USHORT) 0x0004)
#define FIRODISABLED	((USHORT) 0x0020)
#define FIROONCEONLY	((USHORT) 0x0040)

/*
 *	IRC
 *
 *	Idle routine change options. This is a combined bit mask consisting
 *	of individual firc's; each one identifies an aspect of the idle task
 *	that can be changed.
 *
 */

#define IRCNULL			((USHORT) 0x0000)
#define FIRCPFN			((USHORT) 0x0001)	/* change function pointer */
#define FIRCPV			((USHORT) 0x0002)	/* change parameter block  */
#define FIRCPRI			((USHORT) 0x0004)	/* change priority		   */
#define FIRCCSEC		((USHORT) 0x0008)	/* change time			   */
#define FIRCIRO			((USHORT) 0x0010)	/* change routine options  */

/*
 *	Type definition for idle functions.	 An idle function takes one
 *	parameter, an PV, and returns a BOOL value.
 */

typedef BOOL (STDAPICALLTYPE FNIDLE) (LPVOID);
typedef FNIDLE FAR *PFNIDLE;

/*
 *	FTG
 *
 *	Function Tag.  Used to identify a registered idle function.
 *
 */

typedef void FAR *FTG;
typedef FTG  FAR *PFTG;
#define FTGNULL			((FTG) NULL)

/*
 -	MAPIInitIdle/MAPIDeinitIdle
 -
 *	Purpose:
 *		Initialises the idle engine
 *		If the initialisation succeded, returns 0, else returns -1
 *
 *	Arguments:
 *		lpvReserved		Reserved, must be NULL.
 */

STDAPI_(LONG)
MAPIInitIdle (LPVOID lpvReserved);

STDAPI_(VOID)
MAPIDeinitIdle (VOID);


/*
 *	FtgRegisterIdleRoutine
 *
 *		Registers the function pfn of type PFNIDLE, i.e., (BOOL (*)(LPVOID))
 *		as an idle function.
 *
 *		The idle function will be called with the parameter pv by the
 *		idle engine. The function has initial priority priIdle,
 *		associated time csecIdle, and options iroIdle.
 */

STDAPI_(FTG)
FtgRegisterIdleRoutine (PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
	short priIdle, ULONG csecIdle, USHORT iroIdle);

/*
 *	DeregisterIdleRoutine
 *
 *		Removes the given routine from the list of idle routines.
 *		The routine will not be called again.  It is the responsibility
 *		of the caller to clean up any data structures pointed to by the
 *		pvIdleParam parameter; this routine does not free the block.
 */

STDAPI_(void)
DeregisterIdleRoutine (FTG ftg);

/*
 *	EnableIdleRoutine
 *
 *		Enables or disables an idle routine.
 */

STDAPI_(void)
EnableIdleRoutine (FTG ftg, BOOL fEnable);

/*
 *	ChangeIdleRoutine
 *
 *		Changes some or all of the characteristics of the given idle
 *		function. The changes to make are indicated with flags in the
 *		ircIdle parameter.
 */

STDAPI_(void)
ChangeIdleRoutine (FTG ftg, PFNIDLE lpfnIdle, LPVOID lpvIdleParam,
	short priIdle, ULONG csecIdle, USHORT iroIdle, USHORT ircIdle);


#endif	/* ! NOIDLEENGINE */


/* IMalloc Utilities */

STDAPI_(LPMALLOC) MAPIGetDefaultMalloc(VOID);


/* StreamOnFile (SOF) */

/*
 *	Methods and #define's for implementing an OLE 2.0 storage stream
 *	(as defined in the OLE 2.0 specs) on top of a system file.
 */

#define SOF_UNIQUEFILENAME	((ULONG) 0x80000000)

STDMETHODIMP OpenStreamOnFile(
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPFREEBUFFER		lpFreeBuffer,
	ULONG				ulFlags,
	__in LPTSTR			lpszFileName,
	__in_opt LPTSTR			lpszPrefix,
	LPSTREAM FAR *		lppStream);

typedef HRESULT (STDMETHODCALLTYPE FAR * LPOPENSTREAMONFILE) (
	LPALLOCATEBUFFER	lpAllocateBuffer,
	LPFREEBUFFER		lpFreeBuffer,
	ULONG				ulFlags,
	__in LPTSTR			lpszFileName,
	__in LPTSTR			lpszPrefix,
	LPSTREAM FAR *		lppStream);

#ifdef	_WIN32
#define OPENSTREAMONFILE "OpenStreamOnFile"
#endif
#ifdef	WIN16
#define OPENSTREAMONFILE "_OPENSTREAMONFILE"
#endif


/* Property interface utilities */

/*
 *	Copies a single SPropValue from Src to Dest.  Handles all the various
 *	types of properties and will link its allocations given the master
 *	allocation object and an allocate more function.
 */
STDAPI_(SCODE)
PropCopyMore( LPSPropValue		lpSPropValueDest,
			  LPSPropValue		lpSPropValueSrc,
			  ALLOCATEMORE *	lpfAllocMore,
			  LPVOID			lpvObject );

/*
 *	Returns the size in bytes of structure at lpSPropValue, including the
 *	Value.
 */
STDAPI_(ULONG)
UlPropSize(	LPSPropValue	lpSPropValue );


STDAPI_(BOOL)
FEqualNames( LPMAPINAMEID lpName1, LPMAPINAMEID lpName2 );

#if defined(_WIN32) && !defined(_WINNT) && !defined(_WIN95) && !defined(_MAC)
#define _WINNT
#endif

STDAPI_(void)
GetInstance(LPSPropValue lpPropMv, LPSPropValue lpPropSv, ULONG uliInst);

extern char rgchCsds[];
extern char rgchCids[];
extern char rgchCsdi[];
extern char rgchCidi[];

STDAPI_(BOOL)
FPropContainsProp( LPSPropValue	lpSPropValueDst,
				   LPSPropValue	lpSPropValueSrc,
				   ULONG		ulFuzzyLevel );

STDAPI_(BOOL)
FPropCompareProp( LPSPropValue	lpSPropValue1,
				  ULONG			ulRelOp,
				  LPSPropValue	lpSPropValue2 );

STDAPI_(LONG)
LPropCompareProp( LPSPropValue	lpSPropValueA,
				  LPSPropValue	lpSPropValueB );

STDAPI_(HRESULT)
HrAddColumns(	LPMAPITABLE			lptbl,
				LPSPropTagArray		lpproptagColumnsNew,
				LPALLOCATEBUFFER	lpAllocateBuffer,
				LPFREEBUFFER		lpFreeBuffer);

STDAPI_(HRESULT)
HrAddColumnsEx(	LPMAPITABLE			lptbl,
				LPSPropTagArray		lpproptagColumnsNew,
				LPALLOCATEBUFFER	lpAllocateBuffer,
				LPFREEBUFFER		lpFreeBuffer,
				void				(FAR *lpfnFilterColumns)(LPSPropTagArray ptaga));


/* Notification utilities */

/*
 *	Function that creates an advise sink object given a notification
 *	callback function and context.
 */

STDAPI
HrAllocAdviseSink( LPNOTIFCALLBACK lpfnCallback,
				   LPVOID lpvContext,
				   LPMAPIADVISESINK FAR *lppAdviseSink );


/*
 *	Wraps an existing advise sink with another one which guarantees
 *	that the original advise sink will be called in the thread on
 *	which it was created.
 */

STDAPI
HrThisThreadAdviseSink( LPMAPIADVISESINK lpAdviseSink,
						LPMAPIADVISESINK FAR *lppAdviseSink);



/*
 *	Allows a client and/or provider to force notifications
 *	which are currently queued in the MAPI notification engine
 *	to be dispatched without doing a message dispatch.
 */

STDAPI HrDispatchNotifications (ULONG ulFlags);


/* Service Provider Utilities */

/*
 *	Structures and utility function for building a display table
 *	from resources.
 */

typedef struct {
	ULONG			ulCtlType;			/* DTCT_LABEL, etc. */
	ULONG			ulCtlFlags;			/* DT_REQUIRED, etc. */
	LPBYTE			lpbNotif;			/*	pointer to notification data */
	ULONG			cbNotif;			/* count of bytes of notification data */
	LPTSTR			lpszFilter;			/* character filter for edit/combobox */
	ULONG			ulItemID;			/* to validate parallel dlg template entry */
	union {								/* ulCtlType discriminates */
		LPVOID			lpv;			/* Initialize this to avoid warnings */
		LPDTBLLABEL		lplabel;
		LPDTBLEDIT		lpedit;
		LPDTBLLBX		lplbx;
		LPDTBLCOMBOBOX	lpcombobox;
		LPDTBLDDLBX		lpddlbx;
		LPDTBLCHECKBOX	lpcheckbox;
		LPDTBLGROUPBOX	lpgroupbox;
		LPDTBLBUTTON	lpbutton;
		LPDTBLRADIOBUTTON lpradiobutton;
		LPDTBLMVLISTBOX	lpmvlbx;
		LPDTBLMVDDLBX	lpmvddlbx;
		LPDTBLPAGE		lppage;
	} ctl;
} DTCTL, FAR *LPDTCTL;

typedef struct {
	ULONG			cctl;
	LPTSTR			lpszResourceName;	/* as usual, may be an integer ID */
	union {								/* as usual, may be an integer ID */
		LPTSTR			lpszComponent;
		ULONG			ulItemID;
	};
	LPDTCTL			lpctl;
} DTPAGE, FAR *LPDTPAGE;



STDAPI
BuildDisplayTable(	LPALLOCATEBUFFER	lpAllocateBuffer,
					LPALLOCATEMORE		lpAllocateMore,
					LPFREEBUFFER		lpFreeBuffer,
					LPMALLOC			lpMalloc,
					HINSTANCE			hInstance,
					UINT				cPages,
					LPDTPAGE			lpPage,
					ULONG				ulFlags,
					LPMAPITABLE *		lppTable,
					LPTABLEDATA	*		lppTblData );


/* MAPI structure validation/copy utilities */

/*
 *	Validate, copy, and adjust pointers in MAPI structures:
 *		notification
 *		property value array
 *		option data
 */

STDAPI_(SCODE)
ScCountNotifications(int cNotifications, LPNOTIFICATION lpNotifications,
		ULONG FAR *lpcb);

STDAPI_(SCODE)
ScCopyNotifications(int cNotification, LPNOTIFICATION lpNotifications,
		LPVOID lpvDst, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocNotifications(int cNotification, LPNOTIFICATION lpNotifications,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);


STDAPI_(SCODE)
ScCountProps(int cValues, LPSPropValue lpPropArray, ULONG FAR *lpcb);

STDAPI_(LPSPropValue)
LpValFindProp(ULONG ulPropTag, ULONG cValues, LPSPropValue lpPropArray);

STDAPI_(SCODE)
ScCopyProps(int cValues, LPSPropValue lpPropArray, LPVOID lpvDst,
		ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocProps(int cValues, LPSPropValue lpPropArray,
		LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScDupPropset(int cValues, LPSPropValue lpPropArray,
		LPALLOCATEBUFFER lpAllocateBuffer, LPSPropValue FAR *lppPropArray);


/* General utility functions */

/* Related to the OLE Component object model */

STDAPI_(ULONG)			UlAddRef(LPVOID lpunk);
STDAPI_(ULONG)			UlRelease(LPVOID lpunk);

/* Related to the MAPI interface */

STDAPI					HrGetOneProp(LPMAPIPROP lpMapiProp, ULONG ulPropTag,
						LPSPropValue FAR *lppProp);
STDAPI					HrSetOneProp(LPMAPIPROP lpMapiProp,
						LPSPropValue lpProp);
STDAPI_(BOOL)			FPropExists(LPMAPIPROP lpMapiProp, ULONG ulPropTag);
STDAPI_(LPSPropValue)	PpropFindProp(LPSPropValue lpPropArray, ULONG cValues,
						ULONG ulPropTag);
STDAPI_(void)			FreePadrlist(LPADRLIST lpAdrlist);
STDAPI_(void)			FreeProws(LPSRowSet lpRows);
STDAPI					HrQueryAllRows(LPMAPITABLE lpTable,
						LPSPropTagArray lpPropTags,
						LPSRestriction lpRestriction,
						LPSSortOrderSet lpSortOrderSet,
						LONG crowsMax,
						LPSRowSet FAR *lppRows);

/* Create or validate the IPM folder tree in a message store */

#define MAPI_FORCE_CREATE	1
#define MAPI_FULL_IPM_TREE	2

STDAPI					HrValidateIPMSubtree(LPMDB lpMDB, ULONG ulFlags,
						ULONG FAR *lpcValues, LPSPropValue FAR *lppValues,
						LPMAPIERROR FAR *lpperr);

/* Encoding and decoding strings */

STDAPI_(BOOL)			FBinFromHex(__in LPTSTR lpsz, LPBYTE lpb);
STDAPI_(SCODE)			ScBinFromHexBounded(__in LPTSTR lpsz, LPBYTE lpb, ULONG cb);
STDAPI_(void)			HexFromBin(LPBYTE lpb, int cb, __in LPTSTR lpsz);
STDAPI_(ULONG)			UlFromSzHex(LPCTSTR lpsz);

/* Encoding and decoding entry IDs */
STDAPI					HrEntryIDFromSz(__in LPTSTR lpsz, ULONG FAR *lpcb,
						LPENTRYID FAR *lppEntryID);
STDAPI					HrSzFromEntryID(ULONG cb, LPENTRYID lpEntryID,
						__in LPTSTR FAR *lpsz);
STDAPI					HrComposeEID(LPMAPISESSION lpSession,
						ULONG cbStoreRecordKey, LPBYTE lpStoreRecordKey,
						ULONG cbMsgEntryID, LPENTRYID lpMsgEntryID,
						ULONG FAR *lpcbEID, LPENTRYID FAR *lppEntryID);
STDAPI					HrDecomposeEID(LPMAPISESSION lpSession,
						ULONG cbEntryID, LPENTRYID lpEntryID,
						ULONG FAR *lpcbStoreEntryID,
						LPENTRYID FAR *lppStoreEntryID,
						ULONG FAR *lpcbMsgEntryID,
						LPENTRYID FAR *lppMsgEntryID);
STDAPI					HrComposeMsgID(LPMAPISESSION lpSession,
						ULONG cbStoreSearchKey, LPBYTE pStoreSearchKey,
						ULONG cbMsgEntryID, LPENTRYID lpMsgEntryID,
						__in LPTSTR FAR *lpszMsgID);
STDAPI					HrDecomposeMsgID(LPMAPISESSION lpSession,
						__in LPTSTR lpszMsgID,
						ULONG FAR *lpcbStoreEntryID,
						LPENTRYID FAR *lppStoreEntryID,
						ULONG FAR *lppcbMsgEntryID,
						LPENTRYID FAR *lppMsgEntryID);

/* C runtime substitutes */


STDAPI_(LPTSTR)			SzFindCh(LPCTSTR lpsz, USHORT ch);		/* strchr */
STDAPI_(LPTSTR)			SzFindLastCh(LPCTSTR lpsz, USHORT ch);	/* strrchr */
STDAPI_(LPTSTR)			SzFindSz(LPCTSTR lpsz, LPCTSTR lpszKey); /*strstr */
STDAPI_(unsigned int)	UFromSz(LPCTSTR lpsz);					/* atoi */

STDAPI_(SCODE)			ScUNCFromLocalPath(__in LPSTR lpszLocal, __in LPSTR lpszUNC,
						UINT cchUNC);
STDAPI_(SCODE)			ScLocalPathFromUNC(__in LPSTR lpszUNC, __in LPSTR lpszLocal,
						UINT cchLocal);

/* 64-bit arithmetic with times */

STDAPI_(FILETIME)		FtAddFt(FILETIME ftAddend1, FILETIME ftAddend2);
STDAPI_(FILETIME)		FtMulDwDw(DWORD ftMultiplicand, DWORD ftMultiplier);
STDAPI_(FILETIME)		FtMulDw(DWORD ftMultiplier, FILETIME ftMultiplicand);
STDAPI_(FILETIME)		FtSubFt(FILETIME ftMinuend, FILETIME ftSubtrahend);
STDAPI_(FILETIME)		FtNegFt(FILETIME ft);

/* Message composition */

STDAPI_(SCODE)			ScCreateConversationIndex (ULONG cbParent,
							LPBYTE lpbParent,
							ULONG FAR *	lpcbConvIndex,
							LPBYTE FAR * lppbConvIndex);

/* Store support */

STDAPI WrapStoreEntryID (ULONG ulFlags, __in LPTSTR lpszDLLName, ULONG cbOrigEntry,
	LPENTRYID lpOrigEntry, ULONG *lpcbWrappedEntry, LPENTRYID *lppWrappedEntry);

/* RTF Sync Utilities */

#define RTF_SYNC_RTF_CHANGED	((ULONG) 0x00000001)
#define RTF_SYNC_BODY_CHANGED	((ULONG) 0x00000002)

STDAPI_(HRESULT)
RTFSync (LPMESSAGE lpMessage, ULONG ulFlags, __out BOOL FAR * lpfMessageUpdated);


/* Flags for WrapCompressedRTFStream() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) mapidefs.h */
/****** STORE_UNCOMPRESSED_RTF	((ULONG) 0x00008000) mapidefs.h */

STDAPI_(HRESULT)
WrapCompressedRTFStream (__in LPSTREAM lpCompressedRTFStream,
		ULONG ulFlags, __out LPSTREAM FAR * lpUncompressedRTFStream);

/* Storage on Stream */

#if defined(_WIN32) || defined(WIN16)
STDAPI_(HRESULT)
HrIStorageFromStream (LPUNKNOWN lpUnkIn,
	LPCIID lpInterface, ULONG ulFlags, LPSTORAGE FAR * lppStorageOut);
#endif


/*
 * Setup and cleanup.
 *
 * Providers never need to make these calls.
 *
 * Test applications and the like which do not call MAPIInitialize
 * may want to call them, so that the few utility functions which
 * need MAPI allocators (and do not ask for them explicitly)
 * will work.
 */

/* All flags are reserved for ScInitMapiUtil. */

STDAPI_(SCODE)			ScInitMapiUtil(ULONG ulFlags);
STDAPI_(VOID)			DeinitMapiUtil(VOID);


/*
 *	Entry point names.
 *	
 *	These are for new entry points defined since MAPI first shipped
 *	in Windows 95. Using these names in a GetProcAddress call makes
 *	it easier to write code which uses them optionally.
 */

#if defined (WIN16)
#define szHrDispatchNotifications "HrDispatchNotifications"
#elif defined (_WIN32) && defined (_X86_)
#define szHrDispatchNotifications "_HrDispatchNotifications@4"
#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_) || defined(_IA64_)
#define szHrDispatchNotifications "HrDispatchNotifications"
#endif

typedef HRESULT (STDAPICALLTYPE DISPATCHNOTIFICATIONS)(ULONG ulFlags);
typedef DISPATCHNOTIFICATIONS FAR * LPDISPATCHNOTIFICATIONS;

#if defined (WIN16)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#elif defined (_WIN32) && defined (_X86_)
#define szScCreateConversationIndex "_ScCreateConversationIndex@16"
#elif defined (_ALPHA_) || defined (_MIPS_) || defined (_PPC_) || defined(_IA64_)
#define szScCreateConversationIndex "ScCreateConversationIndex"
#endif

typedef SCODE (STDAPICALLTYPE CREATECONVERSATIONINDEX)(ULONG cbParent,
	LPBYTE lpbParent, ULONG FAR *lpcbConvIndex, LPBYTE FAR *lppbConvIndex);
typedef CREATECONVERSATIONINDEX FAR *LPCREATECONVERSATIONINDEX;

#ifdef __cplusplus
}
#endif

#endif /* _MAPIUTIL_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPIWz.h ===
/*
 *	M A P I W Z . H
 *
 *	Definitions for the Profile Wizard.	 Includes all prototypes
 *	and constants required by the provider-wizard code consumers.
 *
 *	Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPIWZ_H
#define _MAPIWZ_H

#if _MSC_VER > 1000
#pragma once
#endif

#define	WIZ_QUERYNUMPAGES	(WM_USER +10)
#define WIZ_NEXT			(WM_USER +11)
#define WIZ_PREV			(WM_USER +12)
/*
 *	NOTE: Provider-Wizards should not use ids ranging between
 *	(WM_USER + 1) and (WM_USER +20) as these have been reserved for
 *	future releases.
 */

/*	Flags for LaunchWizard API */

#define MAPI_PW_FIRST_PROFILE			0x00000001
#define MAPI_PW_LAUNCHED_BY_CONFIG		0x00000002
#define MAPI_PW_ADD_SERVICE_ONLY		0x00000004
#define MAPI_PW_PROVIDER_UI_ONLY		0x00000008
#define MAPI_PW_HIDE_SERVICES_LIST		0x00000010

/*
 *  Provider should set this property to TRUE if it does not
 *  want the Profile Wizard to display the PST setup page.
 */
#define PR_WIZARD_NO_PST_PAGE			PROP_TAG(PT_BOOLEAN, 0x6700)
#define PR_WIZARD_NO_PAB_PAGE			PROP_TAG(PT_BOOLEAN, 0x6701)

typedef HRESULT (STDAPICALLTYPE LAUNCHWIZARDENTRY)
(
	HWND			hParentWnd,
	ULONG			ulFlags,
	LPCTSTR FAR *	lppszServiceNameToAdd,
	ULONG			cbBufferMax,
	LPTSTR			lpszNewProfileName
);
typedef LAUNCHWIZARDENTRY FAR * LPLAUNCHWIZARDENTRY;

typedef BOOL (STDAPICALLTYPE SERVICEWIZARDDLGPROC)
(
	HWND			hDlg,
	UINT			wMsgID,
	WPARAM			wParam,
	LPARAM			lParam
);
typedef SERVICEWIZARDDLGPROC FAR * LPSERVICEWIZARDDLGPROC;

typedef ULONG (STDAPICALLTYPE WIZARDENTRY)
(
	HINSTANCE       hProviderDLLInstance,
	LPTSTR FAR *    lppcsResourceName,
	DLGPROC FAR *   lppDlgProc,
	LPMAPIPROP      lpMapiProp,
    LPVOID          lpMapiSupportObject
);
typedef WIZARDENTRY FAR * LPWIZARDENTRY;

#define LAUNCHWIZARDENTRYNAME			"LAUNCHWIZARD"

#endif	/* _MAPIWZ_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MciAvi.h ===
/**************************************************************************
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 *
**	Copyright (C) Microsoft Corporation 1991-1996. All rights reserved.
**
**	Title: mciavi.h - Multimedia Systems Media Control Interface
**	AVI driver external header file
**
**	Version:	1.00	
**
**	Date:		16-JUL-1992
**
**	Depends on MMSYSTEM.H and WINDOWS.h
*/

/************************************************************************/


/*
** These three flags apply to the 'play' command:
**	play <alias> window		Play in normal window
**	play <alias> fullscreen		Play in 320x240 full-screen mode
**	play <alias> fullscreen by 2	Play fullscreen, zoomed by 2
*/
#define MCI_MCIAVI_PLAY_WINDOW		0x01000000L
#define	MCI_MCIAVI_PLAY_FULLSCREEN	0x02000000L
#define MCI_MCIAVI_PLAY_FULLBY2		0x04000000L
/*
** Debugging constants for AVI diagnostics
*/
/*
** Returns number of frames not drawn during last play.  If this number
** is more than a small fraction of the number of frames that should have
** been displayed, things aren't looking good.
*/
#define MCI_AVI_STATUS_FRAMES_SKIPPED		0x8001L
/*
** Returns a number representing how well the last AVI play worked.
** A result of 1000 indicates that the AVI sequence took the amount
** of time to play that it should have; a result of 2000, for instance,
** would indicate that a 5-second AVI sequence took 10 seconds to play,
** implying that the audio and video were badly broken up.
*/
#define MCI_AVI_STATUS_LAST_PLAY_SPEED		0x8002L
/*
** Returns the number of times that the audio definitely broke up.
** (We count one for every time we're about to write some audio data
** to the driver, and we notice that it's already played all of the
** data we have.
*/
#define MCI_AVI_STATUS_AUDIO_BREAKS		0x8003L


#define MCI_AVI_SETVIDEO_DRAW_PROCEDURE		0x8000L

#define MCI_AVI_SETVIDEO_PALETTE_COLOR		0x8100L


/*
** This constant specifies that the "halftone" palette should be
** used, rather than the default palette.
*/
#define MCI_AVI_SETVIDEO_PALETTE_HALFTONE       0x0000FFFFL

/*
**	Custom error return values
*/
#define MCIERR_AVI_OLDAVIFORMAT		(MCIERR_CUSTOM_DRIVER_BASE + 100)
#define MCIERR_AVI_NOTINTERLEAVED	(MCIERR_CUSTOM_DRIVER_BASE + 101)
#define MCIERR_AVI_NODISPDIB		(MCIERR_CUSTOM_DRIVER_BASE + 102)
#define MCIERR_AVI_CANTPLAYFULLSCREEN	(MCIERR_CUSTOM_DRIVER_BASE + 103)
#define MCIERR_AVI_TOOBIGFORVGA		(MCIERR_CUSTOM_DRIVER_BASE + 104)
#define MCIERR_AVI_NOCOMPRESSOR         (MCIERR_CUSTOM_DRIVER_BASE + 105)
#define MCIERR_AVI_DISPLAYERROR         (MCIERR_CUSTOM_DRIVER_BASE + 106)
#define MCIERR_AVI_AUDIOERROR		(MCIERR_CUSTOM_DRIVER_BASE + 107)
#define MCIERR_AVI_BADPALETTE		(MCIERR_CUSTOM_DRIVER_BASE + 108)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MAPIX.h ===
/*
 *	M A P I X . H
 *	
 *	Definitions of objects/flags, etc used by Extended MAPI.
 *	
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIX_H
#define MAPIX_H

#if _MSC_VER > 1000
#pragma once
#endif

/* Include common MAPI header files if they haven't been already. */
#ifndef MAPIDEFS_H
#include <mapidefs.h>
#endif
#ifndef MAPICODE_H
#include <mapicode.h>
#endif
#ifndef MAPIGUID_H
#include <mapiguid.h>
#endif
#ifndef MAPITAGS_H
#include <mapitags.h>
#endif

#ifdef	__cplusplus
extern "C" {
#endif	

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

/* Forward interface declarations */

DECLARE_MAPI_INTERFACE_PTR(IProfAdmin,			LPPROFADMIN);
DECLARE_MAPI_INTERFACE_PTR(IMsgServiceAdmin,	LPSERVICEADMIN);
DECLARE_MAPI_INTERFACE_PTR(IMAPISession,		LPMAPISESSION);

/* ------------------------------------------------------ */
/* shared with simple mapi */

typedef ULONG       FLAGS;

/* MAPILogon() flags.       */

#define MAPI_LOGON_UI           0x00000001  /* Display logon UI					*/
#define MAPI_NEW_SESSION        0x00000002  /* Don't use shared session			*/
#define MAPI_ALLOW_OTHERS       0x00000008  /* Make this a shared session		*/
#define MAPI_EXPLICIT_PROFILE   0x00000010  /* Don't use default profile		*/
#define MAPI_EXTENDED           0x00000020  /* Extended MAPI Logon				*/
#define MAPI_FORCE_DOWNLOAD     0x00001000  /* Get new mail before return		*/
#define MAPI_SERVICE_UI_ALWAYS	0x00002000	/* Do logon UI in all providers		*/
#define MAPI_NO_MAIL			0x00008000	/* Do not activate transports		*/
/* #define MAPI_NT_SERVICE			0x00010000	Allow logon from an NT service	*/
#ifndef MAPI_PASSWORD_UI
#define MAPI_PASSWORD_UI		0x00020000	/* Display password UI only			*/
#endif
#define MAPI_TIMEOUT_SHORT		0x00100000	/* Minimal wait for logon resources	*/

#define MAPI_SIMPLE_DEFAULT (MAPI_LOGON_UI | MAPI_FORCE_DOWNLOAD | MAPI_ALLOW_OTHERS)
#define MAPI_SIMPLE_EXPLICIT (MAPI_NEW_SESSION | MAPI_FORCE_DOWNLOAD | MAPI_EXPLICIT_PROFILE)

/* Structure passed to MAPIInitialize(), and its ulFlags values */

typedef struct
{
	ULONG			ulVersion;
	ULONG			ulFlags;
} MAPIINIT_0, FAR *LPMAPIINIT_0;

typedef MAPIINIT_0 MAPIINIT;
typedef MAPIINIT FAR *LPMAPIINIT;

#define MAPI_INIT_VERSION				0

#define MAPI_MULTITHREAD_NOTIFICATIONS	0x00000001
/* Reserved for MAPI					0x40000000 */
/* #define MAPI_NT_SERVICE				0x00010000	Use from NT service */

/* MAPI base functions */

typedef HRESULT (STDAPICALLTYPE MAPIINITIALIZE)(
	LPVOID			lpMapiInit
);
typedef MAPIINITIALIZE FAR *LPMAPIINITIALIZE;

typedef void (STDAPICALLTYPE MAPIUNINITIALIZE)(void);
typedef MAPIUNINITIALIZE FAR *LPMAPIUNINITIALIZE;

MAPIINITIALIZE		MAPIInitialize;
MAPIUNINITIALIZE	MAPIUninitialize;


/*  Extended MAPI Logon function */


typedef HRESULT (STDMETHODCALLTYPE MAPILOGONEX)(
	ULONG_PTR ulUIParam,
	__in_opt LPTSTR lpszProfileName,
	__in_opt LPTSTR lpszPassword,
	ULONG ulFlags,   /*  ulFlags takes all that SimpleMAPI does + MAPI_UNICODE */
	LPMAPISESSION FAR * lppSession
);
typedef MAPILOGONEX FAR *LPMAPILOGONEX;

MAPILOGONEX MAPILogonEx;


typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEBUFFER)(
	ULONG			cbSize,
	LPVOID FAR *	lppBuffer
);

typedef SCODE (STDMETHODCALLTYPE MAPIALLOCATEMORE)(
	ULONG			cbSize,
	LPVOID			lpObject,
	LPVOID FAR *	lppBuffer
);

typedef ULONG (STDAPICALLTYPE MAPIFREEBUFFER)(
	LPVOID			lpBuffer
);

typedef MAPIALLOCATEBUFFER FAR	*LPMAPIALLOCATEBUFFER;
typedef MAPIALLOCATEMORE FAR	*LPMAPIALLOCATEMORE;
typedef MAPIFREEBUFFER FAR 		*LPMAPIFREEBUFFER;

MAPIALLOCATEBUFFER MAPIAllocateBuffer;
MAPIALLOCATEMORE MAPIAllocateMore;
MAPIFREEBUFFER MAPIFreeBuffer;

typedef HRESULT (STDMETHODCALLTYPE MAPIADMINPROFILES)(
	ULONG ulFlags,
	LPPROFADMIN FAR *lppProfAdmin
);

typedef MAPIADMINPROFILES FAR *LPMAPIADMINPROFILES;

MAPIADMINPROFILES MAPIAdminProfiles;

/* IMAPISession Interface -------------------------------------------------- */

/* Flags for OpenEntry and others */

/*#define MAPI_MODIFY				((ULONG) 0x00000001) */

/* Flags for Logoff */

#define MAPI_LOGOFF_SHARED      0x00000001  /* Close all shared sessions    */
#define MAPI_LOGOFF_UI          0x00000002  /* It's OK to present UI        */

/* Flags for SetDefaultStore. They are mutually exclusive. */

#define MAPI_DEFAULT_STORE			0x00000001	/* for incoming messages */
#define MAPI_SIMPLE_STORE_TEMPORARY	0x00000002	/* for simple MAPI and CMC */
#define MAPI_SIMPLE_STORE_PERMANENT	0x00000003	/* for simple MAPI and CMC */
#define	MAPI_PRIMARY_STORE			0x00000004	/* Used by some clients */
#define	MAPI_SECONDARY_STORE		0x00000005	/* Used by some clients */

/* Flags for ShowForm. */

#define MAPI_POST_MESSAGE		0x00000001	/* Selects post/send semantics */
#define MAPI_NEW_MESSAGE		0x00000002	/* Governs copying during submission */

/*  MessageOptions */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  QueryDefaultMessageOpt */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#define MAPI_IMAPISESSION_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetMsgStoresTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenMsgStore)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPMDB FAR *					lppMDB) IPURE;				\
	MAPIMETHOD(OpenAddressBook)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPADRBOOK FAR *				lppAdrBook) IPURE;			\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUID,						\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfSect) IPURE;			\
	MAPIMETHOD(GetStatusTable)											\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;	\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(MessageOptions)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				__in LPTSTR					lpszAdrType,				\
				LPMESSAGE					lpMessage) IPURE;			\
	MAPIMETHOD(QueryDefaultMessageOpt)									\
		(THIS_	__in LPTSTR						lpszAdrType,			\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(EnumAdrTypes)											\
		(THIS_	ULONG						ulFlags,					\
				__out ULONG FAR *					lpcAdrTypes,		\
				__out_ecount(lpcAdrTypes) 								\
						LPTSTR FAR * FAR *lpppszAdrTypes) IPURE;		\
	MAPIMETHOD(QueryIdentity)											\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(Logoff)													\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						ulReserved) IPURE;			\
	MAPIMETHOD(SetDefaultStore)											\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(AdminServices)											\
		(THIS_	ULONG						ulFlags,					\
				LPSERVICEADMIN FAR *		lppServiceAdmin) IPURE;		\
	MAPIMETHOD(ShowForm)												\
		(THIS_	ULONG_PTR					ulUIParam,					\
				LPMDB						lpMsgStore,					\
				LPMAPIFOLDER				lpParentFolder,				\
				LPCIID						lpInterface,				\
				ULONG						ulMessageToken,				\
				LPMESSAGE					lpMessageSent,				\
				ULONG						ulFlags,					\
				ULONG						ulMessageStatus,			\
				ULONG						ulMessageFlags,				\
				ULONG						ulAccess,					\
				__in LPSTR					lpszMessageClass) IPURE;	\
	MAPIMETHOD(PrepareForm)												\
		(THIS_	LPCIID						lpInterface,				\
				LPMESSAGE					lpMessage,					\
				ULONG FAR *					lpulMessageToken) IPURE;	\


#undef		 INTERFACE
#define		 INTERFACE  IMAPISession
DECLARE_MAPI_INTERFACE_(IMAPISession, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPISESSION_METHODS(PURE)
};

/*DECLARE_MAPI_INTERFACE_PTR(IMAPISession, LPMAPISESSION);*/

/* IAddrBook Interface ----------------------------------------------------- */

/*  CreateOneOff */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */
/****** MAPI_SEND_NO_RICH_INFO		((ULONG) 0x00010000) */

/*  RecipOptions */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  QueryDefaultRecipOpt */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  GetSearchPath */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */


#define MAPI_IADDRBOOK_METHODS(IPURE)									\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;	\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(CreateOneOff)											\
		(THIS_	__in LPTSTR					lpszName,					\
				__in LPTSTR					lpszAdrType,				\
				__in LPTSTR					lpszAddress,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(NewEntry)												\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cbEIDContainer,				\
				LPENTRYID					lpEIDContainer,				\
				ULONG						cbEIDNewEntryTpl,			\
				LPENTRYID					lpEIDNewEntryTpl,			\
				ULONG FAR *					lpcbEIDNewEntry,			\
				LPENTRYID FAR *				lppEIDNewEntry) IPURE;		\
	MAPIMETHOD(ResolveName)												\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				__in LPTSTR					lpszNewEntryTitle,			\
				LPADRLIST					lpAdrList) IPURE;			\
	MAPIMETHOD(Address)													\
		(THIS_	ULONG_PTR FAR *				lpulUIParam,				\
				LPADRPARM					lpAdrParms,					\
				LPADRLIST FAR *				lppAdrList) IPURE;			\
	MAPIMETHOD(Details)													\
		(THIS_	ULONG FAR *					lpulUIParam,				\
				LPFNDISMISS					lpfnDismiss,				\
				LPVOID						lpvDismissContext,			\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPFNBUTTON					lpfButtonCallback,			\
				LPVOID						lpvButtonContext,			\
				__in LPTSTR					lpszButtonText,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RecipOptions)											\
		(THIS_	ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				LPADRENTRY					lpRecip) IPURE;				\
	MAPIMETHOD(QueryDefaultRecipOpt)									\
		(THIS_	__in LPTSTR					lpszAdrType,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcValues,					\
				LPSPropValue FAR *			lppOptions) IPURE;			\
	MAPIMETHOD(GetPAB)													\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetPAB)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetDefaultDir)											\
		(THIS_	ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(SetDefaultDir)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet FAR *				lppSearchPath) IPURE;		\
	MAPIMETHOD(SetSearchPath)											\
		(THIS_	ULONG						ulFlags,					\
				LPSRowSet					lpSearchPath) IPURE;		\
	MAPIMETHOD(PrepareRecips)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray				lpPropTagArray,				\
				LPADRLIST					lpRecipList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IAddrBook
DECLARE_MAPI_INTERFACE_(IAddrBook, IMAPIProp)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IADDRBOOK_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IAddrBook, LPADRBOOK);

/* IProfAdmin Interface ---------------------------------------------------- */

/* Flags for CreateProfile */
#define MAPI_DEFAULT_SERVICES			0x00000001

/* GetProfileTable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#define MAPI_IPROFADMIN_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetProfileTable)											\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(CreateProfile)											\
		(THIS_	__in LPTSTR					lpszProfileName,			\
				__in LPTSTR					lpszPassword,				\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteProfile)											\
		(THIS_	__in LPTSTR					lpszProfileName,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ChangeProfilePassword)									\
		(THIS_	__in LPTSTR					lpszProfileName,			\
				__in LPTSTR					lpszOldPassword,			\
				__in LPTSTR					lpszNewPassword,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CopyProfile)												\
		(THIS_	__in LPTSTR					lpszOldProfileName,			\
				__in LPTSTR					lpszOldPassword,			\
				__in LPTSTR					lpszNewProfileName,			\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RenameProfile)											\
		(THIS_	__in LPTSTR					lpszOldProfileName,			\
				__in LPTSTR					lpszOldPassword,			\
				__in LPTSTR					lpszNewProfileName,			\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetDefaultProfile)										\
		(THIS_	__in LPTSTR					lpszProfileName,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(AdminServices)											\
		(THIS_	__in LPTSTR					lpszProfileName,			\
				__in LPTSTR					lpszPassword,				\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				LPSERVICEADMIN FAR *		lppServiceAdmin) IPURE;		\


#undef		 INTERFACE
#define		 INTERFACE  IProfAdmin
DECLARE_MAPI_INTERFACE_(IProfAdmin, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IPROFADMIN_METHODS(PURE)
};

/* IMsgServiceAdmin Interface ---------------------------------------------- */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define SERVICE_DEFAULT_STORE		0x00000001
#define SERVICE_SINGLE_COPY			0x00000002
#define SERVICE_CREATE_WITH_STORE	0x00000004
#define SERVICE_PRIMARY_IDENTITY	0x00000008
#define SERVICE_NO_PRIMARY_IDENTITY	0x00000020

/*  GetMsgServiceTable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

/*  GetProviderTable */
/****** MAPI_UNICODE			((ULONG) 0x80000000) */

#define MAPI_IMSGSERVICEADMIN_METHODS(IPURE)							\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetMsgServiceTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(CreateMsgService)										\
		(THIS_	__in LPTSTR					lpszService,				\
				__in LPTSTR					lpszDisplayName,			\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteMsgService)										\
		(THIS_	LPMAPIUID					lpUID) IPURE;				\
	MAPIMETHOD(CopyMsgService)											\
		(THIS_	LPMAPIUID					lpUID,						\
				__in LPTSTR					lpszDisplayName,			\
				LPCIID						lpInterfaceToCopy,			\
				LPCIID						lpInterfaceDst,				\
				LPVOID						lpObjectDst,				\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RenameMsgService)										\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG						ulFlags,					\
				__in LPTSTR					lpszDisplayName) IPURE;		\
	MAPIMETHOD(ConfigureMsgService)										\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG_PTR					ulUIParam,					\
				ULONG						ulFlags,					\
				ULONG						cValues,					\
				LPSPropValue				lpProps) IPURE;				\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUID,						\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfSect) IPURE;			\
	MAPIMETHOD(MsgServiceTransportOrder)								\
		(THIS_	ULONG						cUID,						\
				LPMAPIUID					lpUIDList,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(AdminProviders)											\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG						ulFlags,					\
				LPPROVIDERADMIN FAR *		lppProviderAdmin) IPURE;	\
	MAPIMETHOD(SetPrimaryIdentity)										\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetProviderTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\


#undef 		 INTERFACE
#define 	 INTERFACE	IMsgServiceAdmin
DECLARE_MAPI_INTERFACE_(IMsgServiceAdmin, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMSGSERVICEADMIN_METHODS(PURE)
};

#ifdef	__cplusplus
}		/*	extern "C" */
#endif	

#endif /* MAPIX_H */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Mcx.h ===
/************************************************************************
*                                                                       *
*   mcx.h -- This module defines the 32-Bit Windows MCX APIs            *
*                                                                       *
*   Copyright (c) 1990-1999, Microsoft Corp. All rights reserved.       *
*                                                                       *
************************************************************************/

#ifndef _MCX_H_
#define _MCX_H_

#if _MSC_VER > 1000
#pragma once
#endif

typedef struct _MODEMDEVCAPS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // product and version identification
    DWORD   dwModemProviderVersion;
    DWORD   dwModemManufacturerOffset;
    DWORD   dwModemManufacturerSize;
    DWORD   dwModemModelOffset;
    DWORD   dwModemModelSize;
    DWORD   dwModemVersionOffset;
    DWORD   dwModemVersionSize;

    // local option capabilities
    DWORD   dwDialOptions;          // bitmap of supported values
    DWORD   dwCallSetupFailTimer;   // maximum in seconds
    DWORD   dwInactivityTimeout;    // maximum in seconds
    DWORD   dwSpeakerVolume;        // bitmap of supported values
    DWORD   dwSpeakerMode;          // bitmap of supported values
    DWORD   dwModemOptions;         // bitmap of supported values
    DWORD   dwMaxDTERate;           // maximum value in bit/s
    DWORD   dwMaxDCERate;           // maximum value in bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    // static local options (read/write)
    DWORD   dwCallSetupFailTimer;       // seconds
    DWORD   dwInactivityTimeout;        // seconds
    DWORD   dwSpeakerVolume;            // level
    DWORD   dwSpeakerMode;              // mode
    DWORD   dwPreferredModemOptions;    // bitmap

    // negotiated options (read only) for current or last call
    DWORD   dwNegotiatedModemOptions;   // bitmap
    DWORD   dwNegotiatedDCERate;        // bit/s

    // Variable portion for proprietary expansion
    BYTE    abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

// Dial Options
#define DIALOPTION_BILLING  0x00000040  // Supports wait for bong "$"
#define DIALOPTION_QUIET    0x00000080  // Supports wait for quiet "@"
#define DIALOPTION_DIALTONE 0x00000100  // Supports wait for dial tone "W"

// SpeakerVolume for MODEMDEVCAPS
#define MDMVOLFLAG_LOW      0x00000001
#define MDMVOLFLAG_MEDIUM   0x00000002
#define MDMVOLFLAG_HIGH     0x00000004

// SpeakerVolume for MODEMSETTINGS
#define MDMVOL_LOW          0x00000000
#define MDMVOL_MEDIUM       0x00000001
#define MDMVOL_HIGH         0x00000002

// SpeakerMode for MODEMDEVCAPS
#define MDMSPKRFLAG_OFF         0x00000001
#define MDMSPKRFLAG_DIAL        0x00000002
#define MDMSPKRFLAG_ON          0x00000004
#define MDMSPKRFLAG_CALLSETUP   0x00000008

// SpeakerMode for MODEMSETTINGS
#define MDMSPKR_OFF         0x00000000
#define MDMSPKR_DIAL        0x00000001
#define MDMSPKR_ON          0x00000002
#define MDMSPKR_CALLSETUP   0x00000003

// Modem Options
#define MDM_COMPRESSION      0x00000001
#define MDM_ERROR_CONTROL    0x00000002
#define MDM_FORCED_EC        0x00000004
#define MDM_CELLULAR         0x00000008
#define MDM_FLOWCONTROL_HARD 0x00000010
#define MDM_FLOWCONTROL_SOFT 0x00000020
#define MDM_CCITT_OVERRIDE   0x00000040
#define MDM_SPEED_ADJUST     0x00000080
#define MDM_TONE_DIAL        0x00000100
#define MDM_BLIND_DIAL       0x00000200
#define MDM_V23_OVERRIDE     0x00000400
#define MDM_DIAGNOSTICS      0x00000800


//=========================================================================
//
//
//      EXTENDED MODEM OPTIONS INFORMATION
//
//      THE following macros define additional bits in dwPreferredModemOptions.
//
//      These bits specify information relevant to making ISDN and GSM
//      calls, such as which protocol to use.
//
//=========================================================================

#define MDM_MASK_BEARERMODE   0x0000f000
#define MDM_SHIFT_BEARERMODE 12

#define MDM_MASK_PROTOCOLID   0x000f0000
#define MDM_SHIFT_PROTOCOLID  16

#define MDM_MASK_PROTOCOLDATA 0x0ff00000
#define MDM_SHIFT_PROTOCOLDATA  20

//
// PROTOCOLINFO is the union of PROTOCOLID and PROTOCOLDATA ...
//
#define MDM_MASK_PROTOCOLINFO  (MDM_MASK_PROTOCOLID|MDM_MASK_PROTOCOLDATA)
#define MDM_SHIFT_PROTOCOLINFO MDM_SHIFT_PROTOCOLID

//
// EXTENDEDINFO is the union of BEARERMODE and PROTOCOLINFO
//
#define MDM_MASK_EXTENDEDINFO (MDM_MASK_BEARERMODE|MDM_MASK_PROTOCOLINFO)
#define MDM_SHIFT_EXTENDEDINFO  MDM_SHIFT_BEARERMODE


#define MDM_GET_BEARERMODE(_dwOptions) \
                   (((_dwOptions)&MDM_MASK_BEARERMODE) >> MDM_SHIFT_BEARERMODE)

#define MDM_SET_BEARERMODE(_dwOptions,_bm)     \
    (((_dwOptions) &= ~MDM_MASK_BEARERMODE), \
    ((_dwOptions)  |= (((_bm)<<MDM_SHIFT_BEARERMODE)&MDM_MASK_BEARERMODE)))

#define MDM_GET_PROTOCOLID(_dwOptions) \
               (((_dwOptions)&MDM_MASK_PROTOCOLID) >> MDM_SHIFT_PROTOCOLID)

#define MDM_SET_PROTOCOLID(_dwOptions,_prot)     \
    (((_dwOptions) &= ~MDM_MASK_PROTOCOLID), \
    ((_dwOptions)  |= (((_prot)<<MDM_SHIFT_PROTOCOLID)&MDM_MASK_PROTOCOLID)))

#define MDM_GET_PROTOCOLDATA(_dwOptions) \
               (((_dwOptions)&MDM_MASK_PROTOCOLDATA) >> MDM_SHIFT_PROTOCOLDATA)

#define MDM_SET_PROTOCOLDATA(_dwOptions,_pd)     \
   (((_dwOptions) &= ~MDM_MASK_PROTOCOLDATA), \
   ((_dwOptions)  |= (((_pd)<<MDM_SHIFT_PROTOCOLDATA)&MDM_MASK_PROTOCOLDATA)))

//
// MDM_GET_PROTOCOLINFO gets the protocol-id and info bits in
// their IN-PLACE form (preserving their place in dwModemPreferredOptions)
//
#define MDM_GET_PROTOCOLINFO(_dwOptions) \
               ((_dwOptions)&MDM_MASK_PROTOCOLINFO)

//
// MDM_SET_PROTOCOLINFO takes as its argument the protocol-id and info bits in
// their IN-PLACE form (final position within dwModemPreferredOptions)
//
#define MDM_SET_PROTOCOLINFO(_dwOptions,_pinfo)     \
  (((_dwOptions) &= ~MDM_MASK_PROTOCOLINFO), \
  ((_dwOptions)  |= ((_pinfo)&MDM_MASK_PROTOCOLINFO)))

//
// MDM_GEN_PROTOCOLINFO generates the  the protocol-id and info bits in
// their IN-PLACE form (final position  within dwModemPreferredOptions).
//
#define MDM_GEN_PROTOCOLINFO(_pid, _pdata) \
        ((((_pid  )<<MDM_SHIFT_PROTOCOLID  )&MDM_MASK_PROTOCOLID  )   \
        |(((_pdata)<<MDM_SHIFT_PROTOCOLDATA)&MDM_MASK_PROTOCOLDATA))

//
// MDM_GET_EXTENDEDIONFO gets the bearermode and protocol information in
// their IN-PLACE form (preserving their place in dwModemPreferredOptions)
//
#define MDM_GET_EXTENDEDINFO(_dwOptions) \
               ((_dwOptions)&MDM_MASK_EXTENDEDINFO)

//
// MDM_SET_PROTOCOLINFO takes as its argument the bearermode and
// protocol bits in their IN-PLACE form (final position within
// dwModemPreferredOptions)
//
#define MDM_SET_EXTENDEDINFO(_dwOptions,_extinfo)     \
  (((_dwOptions) &= ~MDM_MASK_EXTENDEDINFO), \
  ((_dwOptions)  |= ((_extinfo) & MDM_MASK_EXTENDEDINFO)))


//
// MDM_GEN_EXTENDEDINFO generates the bearermode and protocol information
// in their IN-PLACE form (final position within dwModemPreferredOptions0.
//
#define MDM_GEN_EXTENDEDINFO(_bearermode, _pinfo)   \
        (((_pinfo)&MDM_MASK_PROTOCOLINFO  )         \
         |(((_bearermode)<<MDM_SHIFT_BEARERMODE)&MDM_MASK_BEARERMODE))


//=========================================================================
//  BEARER MODES
//=========================================================================
//
#define MDM_BEARERMODE_ANALOG   0x0
#define MDM_BEARERMODE_ISDN     0x1
#define MDM_BEARERMODE_GSM      0x2


//=========================================================================
//  PROTOCOL IDs
//=========================================================================
//
#define MDM_PROTOCOLID_DEFAULT  0x0
#define MDM_PROTOCOLID_HDLCPPP  0x1
#define MDM_PROTOCOLID_V128     0x2
#define MDM_PROTOCOLID_X75      0x3
#define MDM_PROTOCOLID_V110     0x4
#define MDM_PROTOCOLID_V120     0x5
#define MDM_PROTOCOLID_AUTO     0x6 // Auto protocol detection.
#define MDM_PROTOCOLID_ANALOG   0x7 // Applicable only to GSM
#define MDM_PROTOCOLID_GPRS     0x8
#define MDM_PROTOCOLID_PIAFS    0x9


//=========================================================================
//  HDLC PPP PROTOCOL INFORMATION
//=========================================================================
//
// Following are specific to the HDLC-PPP protocol.
// The shifts are w.r.t. the start of the PROTOCOLDATA field.

#define MDM_SHIFT_HDLCPPP_SPEED    0x0
#define MDM_MASK_HDLCPPP_SPEED     0x7  // 3 bits

#define MDM_HDLCPPP_SPEED_DEFAULT  0x0
#define MDM_HDLCPPP_SPEED_64K      0x1
#define MDM_HDLCPPP_SPEED_56K      0x2


#define MDM_SHIFT_HDLCPPP_AUTH     0x3
#define MDM_MASK_HDLCPPP_AUTH      (0x7<<3)  // 3 bits

#define MDM_HDLCPPP_AUTH_DEFAULT   0x0
#define MDM_HDLCPPP_AUTH_NONE      0x1
#define MDM_HDLCPPP_AUTH_PAP       0x2
#define MDM_HDLCPPP_AUTH_CHAP      0x3
#define MDM_HDLCPPP_AUTH_MSCHAP    0x4


#define MDM_SHIFT_HDLCPPP_ML       0x6
#define MDM_MASK_HDLCPPP_ML        (0x3<<6)  // 2 bits

#define MDM_HDLCPPP_ML_DEFAULT     0x0
#define MDM_HDLCPPP_ML_NONE        0x1
#define MDM_HDLCPPP_ML_2           0x2

#define MDM_GEN_HDLCPPP_PROTOCOL_DATA(_speed, _auth, _ml)           \
    ((((_speed)<<MDM_SHIFT_HDLCPPP_SPEED)&MDM_MASK_HDLCPPP_SPEED)   \
    |(((_auth )<<MDM_SHIFT_HDLCPPP_AUTH )&MDM_MASK_HDLCPPP_AUTH )   \
    |(((_ml   )<<MDM_SHIFT_HDLCPPP_ML   )&MDM_MASK_HDLCPPP_ML   ))


#define MDM_PROTOCOL_HDLCPPP_64K        \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_64K,      \
            MDM_HDLCPPP_AUTH_DEFAULT,   \
            MDM_HDLCPPP_ML_DEFAULT      \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_56K        \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_56K,      \
            MDM_HDLCPPP_AUTH_DEFAULT,   \
            MDM_HDLCPPP_ML_DEFAULT      \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_112K       \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_56K,      \
            MDM_HDLCPPP_AUTH_DEFAULT,   \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_112K_PAP   \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_56K,      \
            MDM_HDLCPPP_AUTH_PAP,       \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_112K_CHAP  \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_56K,      \
            MDM_HDLCPPP_AUTH_CHAP,      \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_112K_MSCHAP\
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_56K,      \
            MDM_HDLCPPP_AUTH_MSCHAP,    \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )
#define MDM_PROTOCOL_HDLCPPP_128K       \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_64K,      \
            MDM_HDLCPPP_AUTH_DEFAULT,   \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_128K_PAP   \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_64K,      \
            MDM_HDLCPPP_AUTH_PAP,       \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_128K_CHAP  \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_64K,      \
            MDM_HDLCPPP_AUTH_CHAP,      \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

#define MDM_PROTOCOL_HDLCPPP_128K_MSCHAP\
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_HDLCPPP,         \
        MDM_GEN_HDLCPPP_PROTOCOL_DATA ( \
            MDM_HDLCPPP_SPEED_64K,      \
            MDM_HDLCPPP_AUTH_MSCHAP,    \
            MDM_HDLCPPP_ML_2            \
            )                           \
        )

//=========================================================================
//  V120 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================

#define MDM_SHIFT_V120_SPEED    0x0
#define MDM_MASK_V120_SPEED     0x7  // 3 bits

#define MDM_V120_SPEED_DEFAULT  0x0
#define MDM_V120_SPEED_64K      0x1
#define MDM_V120_SPEED_56K      0x2


#define MDM_SHIFT_V120_ML       0x6
#define MDM_MASK_V120_ML        (0x3<<6)  // 2 bits

#define MDM_V120_ML_DEFAULT     0x0
#define MDM_V120_ML_NONE        0x1
#define MDM_V120_ML_2           0x2


#define MDM_GEN_V120_PROTOCOL_DATA(_speed, _ml)               \
    ((((_speed)<<MDM_SHIFT_V120_SPEED)&MDM_MASK_V120_SPEED)   \
    |(((_ml   )<<MDM_SHIFT_V120_ML   )&MDM_MASK_V120_ML   ))


#define MDM_PROTOCOL_V120_64K       \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V120,        \
        MDM_GEN_V120_PROTOCOL_DATA (\
            MDM_V120_SPEED_64K,     \
            MDM_V120_ML_NONE        \
            )                       \
        )

#define MDM_PROTOCOL_V120_56K       \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V120,        \
        MDM_GEN_V120_PROTOCOL_DATA (\
            MDM_V120_SPEED_56K,     \
            MDM_V120_ML_NONE        \
            )                       \
        )

#define MDM_PROTOCOL_V120_112K      \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V120,        \
        MDM_GEN_V120_PROTOCOL_DATA (\
            MDM_V120_SPEED_56K,     \
            MDM_V120_ML_2           \
            )                       \
        )

#define MDM_PROTOCOL_V120_128K      \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V120,        \
        MDM_GEN_V120_PROTOCOL_DATA (\
            MDM_V120_SPEED_64K,     \
            MDM_V120_ML_2           \
            )                       \
        )


//=========================================================================
//  X75 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================


#define MDM_SHIFT_X75_DATA    0x0
#define MDM_MASK_X75_DATA     0x7  // 3 bits

#define MDM_X75_DATA_DEFAULT  0x0
#define MDM_X75_DATA_64K      0x1
#define MDM_X75_DATA_128K     0x2
#define MDM_X75_DATA_T_70     0x3
#define MDM_X75_DATA_BTX      0x4

#define MDM_GEN_X75_PROTOCOL_DATA(_data) \
    (((_data)<<MDM_SHIFT_X75_DATA)&MDM_MASK_X75_DATA)


#define MDM_PROTOCOL_X75_64K        \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_X75,         \
        MDM_GEN_X75_PROTOCOL_DATA ( \
            MDM_X75_DATA_64K        \
            )                       \
        )

#define MDM_PROTOCOL_X75_128K       \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_X75,         \
        MDM_GEN_X75_PROTOCOL_DATA ( \
            MDM_X75_DATA_128K       \
            )                       \
        )

#define MDM_PROTOCOL_X75_T_70       \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_X75,         \
        MDM_GEN_X75_PROTOCOL_DATA ( \
            MDM_X75_DATA_T_70       \
            )                       \
        )                           \

#define MDM_PROTOCOL_X75_BTX        \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_X75,         \
        MDM_GEN_X75_PROTOCOL_DATA ( \
            MDM_X75_DATA_BTX        \
            )                       \
        )


//=========================================================================
//  V110 PROTOCOL INFORMATION
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================


#define MDM_SHIFT_V110_SPEED   0x0
#define MDM_MASK_V110_SPEED    0xf  // 4 bits

#define MDM_V110_SPEED_DEFAULT 0x0
#define MDM_V110_SPEED_1DOT2K  0x1
#define MDM_V110_SPEED_2DOT4K  0x2
#define MDM_V110_SPEED_4DOT8K  0x3
#define MDM_V110_SPEED_9DOT6K  0x4
#define MDM_V110_SPEED_12DOT0K 0x5
#define MDM_V110_SPEED_14DOT4K 0x6
#define MDM_V110_SPEED_19DOT2K 0x7
#define MDM_V110_SPEED_28DOT8K 0x8
#define MDM_V110_SPEED_38DOT4K 0x9
#define MDM_V110_SPEED_57DOT6K 0xA

#define MDM_GEN_V110_PROTOCOL_DATA(_data) \
    (((_data)<<MDM_SHIFT_V110_SPEED)&MDM_MASK_V110_SPEED)


#define MDM_PROTOCOL_V110_1DOT2K    \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_1DOT2K   \
            )                       \
        )

#define MDM_PROTOCOL_V110_2DOT4K    \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_2DOT4K   \
            )                       \
        )

#define MDM_PROTOCOL_V110_4DOT8K    \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_4DOT8K   \
            )                       \
        )

#define MDM_PROTOCOL_V110_9DOT6K    \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_9DOT6K   \
            )                       \
        )

#define MDM_PROTOCOL_V110_12DOT0K   \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_12DOT0K  \
            )                       \
        )

#define MDM_PROTOCOL_V110_14DOT4K   \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_14DOT4K  \
            )                       \
        )

#define MDM_PROTOCOL_V110_19DOT2K   \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_19DOT2K  \
            )                       \
        )

#define MDM_PROTOCOL_V110_28DOT8K   \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_28DOT8K  \
            )                       \
        )

#define MDM_PROTOCOL_V110_38DOT4K   \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_38DOT4K  \
            )                       \
        )

#define MDM_PROTOCOL_V110_57DOT6K   \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_V110,        \
        MDM_GEN_V110_PROTOCOL_DATA (\
            MDM_V110_SPEED_57DOT6K  \
            )                       \
        )

//=========================================================================
//  AUTO PROTOCOL INFORMATION (ie, when the protocol is detected automatically)
//
// The shifts are w.r.t. the start of the PROTOCOLDATA field.
//
//=========================================================================
//
// Following are specific to the AUTO-protocol
//

#define MDM_SHIFT_AUTO_SPEED    0x0
#define MDM_MASK_AUTO_SPEED     0x7  // 3 bits
#define MDM_AUTO_SPEED_DEFAULT  0x0

#define MDM_SHIFT_AUTO_ML       0x6
#define MDM_MASK_AUTO_ML        (0x3<<6)  // 2 bits
#define MDM_AUTO_ML_DEFAULT     0x0
#define MDM_AUTO_ML_NONE        0x1
#define MDM_AUTO_ML_2           0x2

#define MDM_GEN_AUTO_PROTOCOL_DATA(_speed, _ml)             \
    ((((_speed)<<MDM_SHIFT_AUTO_SPEED)&MDM_MASK_AUTO_SPEED) \
    |(((_ml   )<<MDM_SHIFT_AUTO_ML   )&MDM_MASK_AUTO_ML))


#define MDM_PROTOCOL_AUTO_1CH       \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_AUTO,        \
        MDM_GEN_AUTO_PROTOCOL_DATA (\
            MDM_AUTO_SPEED_DEFAULT, \
            MDM_AUTO_ML_NONE        \
            )                       \
        )

#define MDM_PROTOCOL_AUTO_2CH       \
    MDM_GEN_PROTOCOLINFO(           \
        MDM_PROTOCOLID_AUTO,        \
        MDM_GEN_AUTO_PROTOCOL_DATA (\
            MDM_AUTO_SPEED_DEFAULT, \
            MDM_AUTO_ML_2           \
            )                       \
        )

//=========================================================================
//  ANALOG PROTOCOL INFORMATION (Applicable only to GSM)
//=========================================================================
//
// Following are specific to GSM Analog protocol
//

#define MDM_ANALOG_RLP_ON       0x0
#define MDM_ANALOG_RLP_OFF      0x1
#define MDM_ANALOG_V34          0x2

#define MDM_GEN_ANALOG_PROTOCOL_DATA(_rlp) \
    (_rlp)


#define MDM_PROTOCOL_ANALOG_RLP         \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_ANALOG,          \
        MDM_GEN_ANALOG_PROTOCOL_DATA (  \
            MDM_ANALOG_RLP_ON           \
            )                           \
        )

#define MDM_PROTOCOL_ANALOG_NRLP        \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_ANALOG,          \
        MDM_GEN_ANALOG_PROTOCOL_DATA (  \
            MDM_ANALOG_RLP_OFF          \
            )                           \
        )

//
//  v34 anolog for isdn
//
#define MDM_PROTOCOL_ANALOG_V34         \
    MDM_GEN_PROTOCOLINFO(               \
        MDM_PROTOCOLID_ANALOG,          \
        MDM_GEN_ANALOG_PROTOCOL_DATA (  \
            MDM_ANALOG_V34              \
            )                           \
        )


//=========================================================================
//  GPRS PROTOCOL INFORMATION (Applicable only to GSM)
//=========================================================================
//
// Following are specific to GPRS protocol
//

#define MDM_PROTOCOL_GPRS             \
    MDM_GEN_PROTOCOLINFO(             \
        MDM_PROTOCOLID_GPRS,          \
        0                             \
        )


//=========================================================================
//  PIAFS PROTOCOL INFORMATION
//=========================================================================
//
// Following are specific to PIAFS protocol
//

#define MDM_PIAFS_INCOMING            0
#define MDM_PIAFS_OUTGOING            1

#define MDM_PROTOCOL_PIAFS_INCOMING   \
    MDM_GEN_PROTOCOLINFO(             \
        MDM_PROTOCOLID_PIAFS,         \
        MDM_PIAFS_INCOMING            \
        )

#define MDM_PROTOCOL_PIAFS_OUTGOING   \
    MDM_GEN_PROTOCOLINFO(             \
        MDM_PROTOCOLID_PIAFS,         \
        MDM_PIAFS_OUTGOING           \
        )

#endif /* _MCX_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Mdcommsg.h ===
/*++

Copyright (c) 1997-1999 Microsoft Corporation

Module Name:

    commsg.h

Abstract:

    HRESULT <-> Win32 error mapping macros.

Author:

    Michael W. Thomas (michth)   24-Sep-1996

Revision History:

    Keith Moore (keithmo)        07-Feb-1997
        Cleanup, comment, made Metadata errors "real" HRESULTs.

--*/


#ifndef _COMMSG_H_
#define _COMMSG_H_


//
// RETURNCODETOHRESULT() maps a return code to an HRESULT. If the return
// code is a Win32 error (identified by a zero high word) then it is mapped
// using the standard HRESULT_FROM_WIN32() macro. Otherwise, the return
// code is assumed to already be an HRESULT and is returned unchanged.
//

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                  \
                : (rc))


//
// HRESULTTOWIN32() maps an HRESULT to a Win32 error. If the facility code
// of the HRESULT is FACILITY_WIN32, then the code portion (i.e. the
// original Win32 error) is returned. Otherwise, the original HRESULT is
// returned unchagned.
//

#define HRESULTTOWIN32(hres)                                \
            ((HRESULT_FACILITY(hres) == FACILITY_WIN32)     \
                ? HRESULT_CODE(hres)                        \
                : (hres))


#endif  // _COMMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Mddefw.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for mddefw.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __mddefw_h__
#define __mddefw_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_mddefw_0000_0000 */
/* [local] */ 

/*++
                                                                                
Copyright (c) 1997-1999 Microsoft Corporation
                                                                                
Module Name: mddef.h
                                                                                
    Definitions for Admin Objects and Metadata
                                                                                
--*/
#ifndef _MD_DEFW_
#define _MD_DEFW_
#include <mdmsg.h>
#include <mdcommsg.h>
/*                                                                              
    Error Codes                                                                 
                                                                                
        Metadata api's all return HRESULTS. Since internal results are either   
        winerrors or Metadata specific return codes (see mdmsg.h), they are     
        converted to HRESULTS using the RETURNCODETOHRESULT macro (see          
        commsg.h).                                                              
*/                                                                              
                                                                                
/*                                                                              
    Max Name Length                                                             
        The maximum number of characters in the length of a metaobject name,    
        including the terminating NULL. This refers to each node in the tree,   
        not the entire path.                                                    
        eg. strlen("Root") < METADATA_MAX_NAME_LEN                            
*/                                                                              
#define METADATA_MAX_NAME_LEN           256
/*                                                                              
   Access Permissons                                                            
       Permissions associated with handles of type METADATA_HANDLE              
                                                                                
       METADATA_PERMISSION_READ - Allows reading metadata.                      
       METADATA_PERMISSION_WRITE - Allows writing metadata.                     
*/                                                                              
#define METADATA_PERMISSION_READ        0x00000001
#define METADATA_PERMISSION_WRITE       0x00000002
/*                                                                              
    Data Types                                                                  
                                                                                
        ALL_METADATA - Used on Get/Enum/Getall api's (ComMDGetMetaData,         
            ComMDEnumMetaData, and ComMDGetAllMetaData), api's to allow getting 
            all data. Not valid on the Set api.                                 
                                                                                
        DWORD_METADATA - The data is an unsigned 32 bit value.                  
                                                                                
        STRING_METADATA - The data is a null terminated ASCII string.           
                                                                                
        BINARY_METADATA - The data is any binary value.                         
                                                                                
        EXPANDSZ_METADATA - The data is a null terminated ASCII string.         
            Clients are expected to treat this as an expandsz string.           
                                                                                
        MULTISZ_METADATA - A series of NULL terminated ASCII strings. ending    
            with 2 NULL's.                                                      
*/                                                                              

enum METADATATYPES
    {	ALL_METADATA	= 0,
	DWORD_METADATA	= ( ALL_METADATA + 1 ) ,
	STRING_METADATA	= ( DWORD_METADATA + 1 ) ,
	BINARY_METADATA	= ( STRING_METADATA + 1 ) ,
	EXPANDSZ_METADATA	= ( BINARY_METADATA + 1 ) ,
	MULTISZ_METADATA	= ( EXPANDSZ_METADATA + 1 ) ,
	INVALID_END_METADATA	= ( MULTISZ_METADATA + 1 ) 
    } ;
/*                                                                              
    Attributes - The flags for the data.                                        
                                                                                
        METADATA_INHERIT - If set for a data item, the data item can be         
            inherited. If set on input to the Get/Enum/Getall api's,            
            (ComMDGetMetaData, ComMDEnumMetaData, and ComMDGetAllMetaData),     
            inheritable data will be returned. If not set on input to the       
            Get/Enum/Getall, inheritable data will not be returned.             
                                                                                
        METADATA_PARTIAL_PATH - If set on input to Get/Enum/Getall api's, this  
            routine will return ERROR_SUCCESS and the inherited data even if    
            the entire path is not present. Only valid if METADATA_INHERIT is   
            also set. Should not be set for data items on input the the Set api 
            (ComMDSetMetaData).                                                 
                                                                                
        METADATA_SECURE - If set for a data item, the data is stored in a       
            secure fasion. Should not be set on input to Get/Enum api's.        
                                                                                
        METADATA_REFERENCE - If set for a data item, the data item may be       
            gotten by reference. If set on input to Get/Enum/GetAll api's and   
            set on a the data item being returned, the data is returned by      
            reference. A pointer to the metadata server's copy of the data is   
            placed in the Data field of the METADATA_RECORD or                  
            METADATA_GETALL_RECORD, and the DataTag field is set. This data must
            be freed by calling ComMDReleaseReferenceData. The client must not  
            change this data. This flag must not be set on input to             
            Get/Enum/Getall api's from remote clients.                          
                                                                                
        METADATA_VOLATILE - If set for a data item, the data item will not be   
            saved to long term storage.                                         
                                                                                
        METADATA_ISINHERITED - If specified on input to one of the get api's,   
        the flag will be set on return if the data was inherited.               
                                                                                
        METADATA_INSERT_PATH - If specified on input to one of the get api's,   
        and on a string data item, the path relative to handle will replaced the
        string MD_INSERT_PATH_STRING in the string data.                        
                                                                                
        METADATA_LOCAL_MACHINE_ONLY - If set for a data item, the data item
        will not be replicated during web cluster replication.
                                                                                
        METADATA_NON_SECURE_ONLY - When using GetAll api, do not
        retrieve properties which are secure.
                                                                                
*/                                                                              
                                                                                
#define METADATA_NO_ATTRIBUTES          0                                       
#define METADATA_INHERIT                0x00000001                              
#define METADATA_PARTIAL_PATH           0x00000002                              
#define METADATA_SECURE                 0x00000004                              
#define METADATA_REFERENCE              0x00000008                              
#define METADATA_VOLATILE               0x00000010                              
#define METADATA_ISINHERITED            0x00000020                              
#define METADATA_INSERT_PATH            0x00000040                              
#define METADATA_LOCAL_MACHINE_ONLY     0x00000080                              
#define METADATA_NON_SECURE_ONLY        0x00000100                              
#define METADATA_DONT_EXPAND            0x00000200                              
                                                                                
/*                                                                              
    Backup Flags.                                                               
                                                                                
        MD_BACKUP_OVERWRITE - If set, the metabase will be backed up even if    
            a backupe with the same name and version already exists. The        
            existing backup will be overwritten.                                
                                                                                
        MD_BACKUP_SAVE_FIRST - If set backup will save the metabase prior to    
            making the backup. If the save fails, backup behavior is dependent  
            on the value of MD_BACKUP_FORCE_BACKUP.                             
                                                                                
        MD_BACKUP_FORCE_BACKUP - If set backup will proceed even if the save    
            failed. Only valid if MD_BACKUP_SAVE_FIRST is set. If the save      
            but the backup succeeds, a warning will be returned.                
*/                                                                              
                                                                                
#define MD_BACKUP_OVERWRITE             0x00000001                              
#define MD_BACKUP_SAVE_FIRST            0x00000002                              
#define MD_BACKUP_FORCE_BACKUP          0x00000004                              
/*                                                                              
    Backup Version Defines.                                                     
                                                                                
        MD_BACKUP_NEXT_VERSION - For Backup, indicates use the next available   
            backup version of the BackupLocation specified, ie. one higher than 
            the highest existing version.                                       
            Not valid for Restore or DeleteBackup.                              
                                                                                
        MD_BACKUP_HIGHEST_VERSION - For Backup, Restore, and DeleteBackup, will 
            use the highest existing backup version of the BackupLocation       
            specified.                                                          
                                                                                
        MD_BACKUP_MAX_VERSION - The highest allowed backup version number.      
                                                                                
        MD_BACKUP_MAX_LEN - The maximup length, in UNICODE characters, of the   
            BackupLocation.                                                     
*/                                                                              
                                                                                
#define MD_BACKUP_NEXT_VERSION          0xffffffff                              
#define MD_BACKUP_HIGHEST_VERSION       0xfffffffe                              
#define MD_BACKUP_MAX_VERSION           9999                                    
#define MD_BACKUP_MAX_LEN               (100)                                   
                                                                                
/*                                                                              
    Backup Location Defines.                                                    
                                                                                
        MD_DEFAULT_BACKUP_LOCATION - The default location to backup from or     
            restore to if no location is specified.                             
*/                                                                              
                                                                                
#define MD_DEFAULT_BACKUP_LOCATION TEXT("MDBackUp")                           
                                                                                
/*                                                                              
    History Flags.                                                              
                                                                                
        MD_HISTORY_LATEST - The most recent history file by timestamp           
*/                                                                              
                                                                                
#define MD_HISTORY_LATEST               0x00000001                              
                                                                                
/*                                                                              
    Export Flags.                                                               
                                                                                
        MD_EXPORT_INHERITED - If set, inherited properties will be backed up    
            to special section in output file called IIsInheritedProperties.    
            If not set, inherited properties are ignored.                       
                                                                                
        MD_EXPORT_NODE_ONLY - If set, children will not be exported.            
            If not set, children will be exported.                              
*/                                                                              
                                                                                
#define MD_EXPORT_INHERITED             0x00000001                              
#define MD_EXPORT_NODE_ONLY             0x00000002                              
                                                                                
/*                                                                              
    Import Flags.                                                               
                                                                                
        MD_IMPORT_INHERITED - If set, inherited properties will be imported.    
                                                                                
        MD_IMPORT_NODE_ONLY - If set, children will not be imported.            
            If not set, children will be imported.                              
                                                                                
        MD_IMPORT_MERGE - If set, imported settings overwrite existing          
            settings, but entire node is not overwritten.  If not set, entire   
            node is clobbered.                                                  
*/                                                                              
                                                                                
#define MD_IMPORT_INHERITED             0x00000001                              
#define MD_IMPORT_NODE_ONLY             0x00000002                              
#define MD_IMPORT_MERGE                 0x00000004                              
                                                                                
/*                                                                              
    Insert Path Defines.                                                        
*/                                                                              
                                                                                
                                                                                
#define MD_INSERT_PATH_STRINGA      "<%INSERT_PATH%>"                         
#define MD_INSERT_PATH_STRINGW      L##"<%INSERT_PATH%>"                      
#define MD_INSERT_PATH_STRING       TEXT("<%INSERT_PATH%>")                   
                                                                                
/*                                                                              
    Handle Defines.                                                             
*/                                                                              
                                                                                
#define METADATA_MASTER_ROOT_HANDLE     0
                                                                                
/*                                                                              
    METADATA_RECORD is the basic input/output parameter for the set and get     
        metadata api's. The Set api (ComMDSetMetaData) takes all fields as      
        input, except DataTag. The Get/Enum api's (ComMDGetMetadata and         
        ComMDEnumMetaData) take some of the fields as input, and fill in all    
        fields as output.                                                       
                                                                                
    Identifier - The identifier of the data.                                    
                                                                                
    Attributes - The flags for the data.                                        
                                                                                
    UserType - The User Type for the data. This is a user defined field to allow
        users to group data. If set to anything other than ALL_METADATA on input
        to Get/Set apis, only metadata of the specified User Type will be       
        returned.                                                               
                                                                                
        ALL_METADATA                                                            
                                                                                
        User Defined Values                                                     
                                                                                
    DataType - The Type of the data. Must be set to a valid value other than    
        ALL_METADATA for each data item. If set to anything other than          
        ALL_METADATA on input to Get/Set api's, only metadata of the            
        specified Data Type will be returned.                                   
             ALL_METADATA                                                       
             DWORD_METADATA                                                     
             STRING_METADATA                                                    
             BINARY_METADATA                                                    
             EXPANDSZ_METADATA                                                  
                                                                                
    DataLen - On input to the Set api, specifies the length of Data, in         
        bytes. Inprocess clients only need to specify this for binary data.     
        Remote clients need to specify this for all data types. For strings,    
        this must include the trailing '\0', eg. strlen(string) + 1.            
        On input to Get/Enum apis, specifies the size of the buffer pointed to  
        by Data. On successful output from Get/Enum API's, specifies the size of
        Data in bytes.                                                          
                                                                                
    Data - On input to the Set api, points to the data. On input to the         
        Get/Enum api's, points to a buffer to return the data in. On output     
        from the Get/Enum api's, points to the data. If the data is not         
        gotten by reference, the  pointer will be unchanged.                    
                                                                                
    DataTag - A tag for reference data. Not used in the Set api. Not used on    
        input to the Get/Enum api's. On successful return from the Get/Enum     
        api's, this is set to a nonzero tag if the data was gotten by reference,
        and set to 0 if the data was not gotten by reference.                   
*/                                                                              
typedef struct _METADATA_RECORD
    {
    DWORD dwMDIdentifier;
    DWORD dwMDAttributes;
    DWORD dwMDUserType;
    DWORD dwMDDataType;
    DWORD dwMDDataLen;
    unsigned char *pbMDData;
    DWORD dwMDDataTag;
    } 	METADATA_RECORD;

typedef struct _METADATA_RECORD *PMETADATA_RECORD;

/*                                                                              
    METADATA_GETALL_RECORD, is essentially the same as METADATA_RECORD, but is  
        used by MDGetAllMetaData. It is used the same as the corresponding      
        METADATA_RECORD values for the MDGetMetaData, with the following        
        exceptions:                                                             
                                                                                
    MDGetAllMetadata does not take the structure as input, but takes parameters 
        equivalent to Attributes, UserType, and DataType.                       
                                                                                
    On output, MDGetAllMetadata returns an array of METADATA_GETALL_RECORD.     
                                                                                
    DataOffset/Data - If the data is not returned by reference, DataOffset      
        contains the byte offset into the buffer provided. If the data is       
        returned by reference, Data contains a pointer to the data.             
                                                                                
                                                                                
    Because an opaque pointer to an array of _METADATA_GETALL_RECORD's is       
    passed on calls to GetAllData, its size must be the same on x86 and ia64.   
    So, the pbMDData member (not used by the public interface) has been         
    removed and a new structure _METADATA_GETALL_INTERNAL_RECORD has been       
    created for use by the callees of the internal interface                    
*/                                                                              
typedef struct _METADATA_GETALL_RECORD
    {
    DWORD dwMDIdentifier;
    DWORD dwMDAttributes;
    DWORD dwMDUserType;
    DWORD dwMDDataType;
    DWORD dwMDDataLen;
    DWORD dwMDDataOffset;
    DWORD dwMDDataTag;
    } 	METADATA_GETALL_RECORD;

typedef struct _METADATA_GETALL_RECORD *PMETADATA_GETALL_RECORD;

typedef struct _METADATA_GETALL_INTERNAL_RECORD
    {
    DWORD dwMDIdentifier;
    DWORD dwMDAttributes;
    DWORD dwMDUserType;
    DWORD dwMDDataType;
    DWORD dwMDDataLen;
    union 
        {
        DWORD_PTR dwMDDataOffset;
        unsigned char *pbMDData;
        } 	;
    DWORD dwMDDataTag;
    } 	METADATA_GETALL_INTERNAL_RECORD;

typedef struct _METADATA_GETALL_INTERNAL_RECORD *PMETADATA_GETALL_INTERNAL_RECORD;

typedef DWORD METADATA_HANDLE;

typedef DWORD *PMETADATA_HANDLE;

/*                                                                              
Handle Information                                                              
                                                                                
    Permissions - The permissions associated with the handle.                   
        METADATA_PERMISSION_READ                                                
        METADATA_PERMISSION_WRITE                                               
                                                                                
    SystemChangeNumber - The system change number at the time the handle was    
        allocated.                                                              
*/                                                                              
typedef struct _METADATA_HANDLE_INFO
    {
    DWORD dwMDPermissions;
    DWORD dwMDSystemChangeNumber;
    } 	METADATA_HANDLE_INFO;

typedef struct _METADATA_HANDLE_INFO *PMETADATA_HANDLE_INFO;

/*                                                                              
    Change Object - The structure passed to ComMDSinkNotify.                    
                                                                                
        Path - The path of the MetaObject modified.                             
                                                                                
        ChangeType - The types of changes made, from the flags below.           
                                                                                
        NumDataIDs - The number of data id's changed.                           
                                                                                
        DataIDs - An array of the data id's changed.                            
*/                                                                              
                                                                                
#define MD_CHANGE_OBJECT     MD_CHANGE_OBJECT_W                                 
#define PMD_CHANGE_OBJECT    PMD_CHANGE_OBJECT_W                                
typedef struct _MD_CHANGE_OBJECT_W
    {
    LPWSTR pszMDPath;
    DWORD dwMDChangeType;
    DWORD dwMDNumDataIDs;
    DWORD *pdwMDDataIDs;
    } 	MD_CHANGE_OBJECT_W;

typedef struct _MD_CHANGE_OBJECT_W *PMD_CHANGE_OBJECT_W;

/*                                                                              
                                                                                
Change Types                                                                    
                                                                                
    MD_CHANGE_TYPE_DELETE_OBJECT - The Meta Object was deleted.                 
                                                                                
    MD_CHANGE_TYPE_ADD_OBJECT - The Meta Object was added.                      
                                                                                
    MD_CHANGE_TYPE_SET_DATA - A data item was set.                              
                                                                                
    MD_CHANGE_TYPE_DELETE_DATA - A data item was deleted.                       
                                                                                
    MD_CHANGE_TYPE_RENAME_OBJECT - The Meta Object was renamed.                 
                                                                                
    MD_CHANGE_TYPE_RESTORE - The Meta Base was restored.                 
                                                                                
*/                                                                              
#define MD_CHANGE_TYPE_DELETE_OBJECT   0x00000001
#define MD_CHANGE_TYPE_ADD_OBJECT      0x00000002
#define MD_CHANGE_TYPE_SET_DATA        0x00000004
#define MD_CHANGE_TYPE_DELETE_DATA     0x00000008
#define MD_CHANGE_TYPE_RENAME_OBJECT   0x00000010
#define MD_CHANGE_TYPE_RESTORE         0x00000020
/*                                                                              
                                                                                
Max Change Entries - The maximum number of change entries that will be sent on  
    a single call to IMDCOMSINK::ComMDSinkNotify. If more notifications are     
    required, IMDCOMSINK::ComMDSinkNotify will be called multiple times.        
*/                                                                              
#define MD_MAX_CHANGE_ENTRIES          100
#endif


extern RPC_IF_HANDLE __MIDL_itf_mddefw_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mddefw_0000_0000_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\mbnapi.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for mbnapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data , no_format_optimization
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mbnapi_h__
#define __mbnapi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IDummyMBNUCMExt_FWD_DEFINED__
#define __IDummyMBNUCMExt_FWD_DEFINED__
typedef interface IDummyMBNUCMExt IDummyMBNUCMExt;
#endif 	/* __IDummyMBNUCMExt_FWD_DEFINED__ */


#ifndef __IMbnInterface_FWD_DEFINED__
#define __IMbnInterface_FWD_DEFINED__
typedef interface IMbnInterface IMbnInterface;
#endif 	/* __IMbnInterface_FWD_DEFINED__ */


#ifndef __IMbnSubscriberInformation_FWD_DEFINED__
#define __IMbnSubscriberInformation_FWD_DEFINED__
typedef interface IMbnSubscriberInformation IMbnSubscriberInformation;
#endif 	/* __IMbnSubscriberInformation_FWD_DEFINED__ */


#ifndef __IMbnInterfaceEvents_FWD_DEFINED__
#define __IMbnInterfaceEvents_FWD_DEFINED__
typedef interface IMbnInterfaceEvents IMbnInterfaceEvents;
#endif 	/* __IMbnInterfaceEvents_FWD_DEFINED__ */


#ifndef __IMbnSignal_FWD_DEFINED__
#define __IMbnSignal_FWD_DEFINED__
typedef interface IMbnSignal IMbnSignal;
#endif 	/* __IMbnSignal_FWD_DEFINED__ */


#ifndef __IMbnSignalEvents_FWD_DEFINED__
#define __IMbnSignalEvents_FWD_DEFINED__
typedef interface IMbnSignalEvents IMbnSignalEvents;
#endif 	/* __IMbnSignalEvents_FWD_DEFINED__ */


#ifndef __IMbnPinManager_FWD_DEFINED__
#define __IMbnPinManager_FWD_DEFINED__
typedef interface IMbnPinManager IMbnPinManager;
#endif 	/* __IMbnPinManager_FWD_DEFINED__ */


#ifndef __IMbnPinManagerEvents_FWD_DEFINED__
#define __IMbnPinManagerEvents_FWD_DEFINED__
typedef interface IMbnPinManagerEvents IMbnPinManagerEvents;
#endif 	/* __IMbnPinManagerEvents_FWD_DEFINED__ */


#ifndef __IMbnPin_FWD_DEFINED__
#define __IMbnPin_FWD_DEFINED__
typedef interface IMbnPin IMbnPin;
#endif 	/* __IMbnPin_FWD_DEFINED__ */


#ifndef __IMbnPinEvents_FWD_DEFINED__
#define __IMbnPinEvents_FWD_DEFINED__
typedef interface IMbnPinEvents IMbnPinEvents;
#endif 	/* __IMbnPinEvents_FWD_DEFINED__ */


#ifndef __IMbnRegistration_FWD_DEFINED__
#define __IMbnRegistration_FWD_DEFINED__
typedef interface IMbnRegistration IMbnRegistration;
#endif 	/* __IMbnRegistration_FWD_DEFINED__ */


#ifndef __IMbnRegistrationEvents_FWD_DEFINED__
#define __IMbnRegistrationEvents_FWD_DEFINED__
typedef interface IMbnRegistrationEvents IMbnRegistrationEvents;
#endif 	/* __IMbnRegistrationEvents_FWD_DEFINED__ */


#ifndef __IMbnConnectionContext_FWD_DEFINED__
#define __IMbnConnectionContext_FWD_DEFINED__
typedef interface IMbnConnectionContext IMbnConnectionContext;
#endif 	/* __IMbnConnectionContext_FWD_DEFINED__ */


#ifndef __IMbnConnectionContextEvents_FWD_DEFINED__
#define __IMbnConnectionContextEvents_FWD_DEFINED__
typedef interface IMbnConnectionContextEvents IMbnConnectionContextEvents;
#endif 	/* __IMbnConnectionContextEvents_FWD_DEFINED__ */


#ifndef __IMbnConnection_FWD_DEFINED__
#define __IMbnConnection_FWD_DEFINED__
typedef interface IMbnConnection IMbnConnection;
#endif 	/* __IMbnConnection_FWD_DEFINED__ */


#ifndef __IMbnConnectionEvents_FWD_DEFINED__
#define __IMbnConnectionEvents_FWD_DEFINED__
typedef interface IMbnConnectionEvents IMbnConnectionEvents;
#endif 	/* __IMbnConnectionEvents_FWD_DEFINED__ */


#ifndef __IMbnConnectionProfileManager_FWD_DEFINED__
#define __IMbnConnectionProfileManager_FWD_DEFINED__
typedef interface IMbnConnectionProfileManager IMbnConnectionProfileManager;
#endif 	/* __IMbnConnectionProfileManager_FWD_DEFINED__ */


#ifndef __IMbnConnectionProfile_FWD_DEFINED__
#define __IMbnConnectionProfile_FWD_DEFINED__
typedef interface IMbnConnectionProfile IMbnConnectionProfile;
#endif 	/* __IMbnConnectionProfile_FWD_DEFINED__ */


#ifndef __IMbnConnectionProfileEvents_FWD_DEFINED__
#define __IMbnConnectionProfileEvents_FWD_DEFINED__
typedef interface IMbnConnectionProfileEvents IMbnConnectionProfileEvents;
#endif 	/* __IMbnConnectionProfileEvents_FWD_DEFINED__ */


#ifndef __IMbnSmsConfiguration_FWD_DEFINED__
#define __IMbnSmsConfiguration_FWD_DEFINED__
typedef interface IMbnSmsConfiguration IMbnSmsConfiguration;
#endif 	/* __IMbnSmsConfiguration_FWD_DEFINED__ */


#ifndef __IMbnSmsReadMsgPdu_FWD_DEFINED__
#define __IMbnSmsReadMsgPdu_FWD_DEFINED__
typedef interface IMbnSmsReadMsgPdu IMbnSmsReadMsgPdu;
#endif 	/* __IMbnSmsReadMsgPdu_FWD_DEFINED__ */


#ifndef __IMbnSmsReadMsgTextCdma_FWD_DEFINED__
#define __IMbnSmsReadMsgTextCdma_FWD_DEFINED__
typedef interface IMbnSmsReadMsgTextCdma IMbnSmsReadMsgTextCdma;
#endif 	/* __IMbnSmsReadMsgTextCdma_FWD_DEFINED__ */


#ifndef __IMbnSms_FWD_DEFINED__
#define __IMbnSms_FWD_DEFINED__
typedef interface IMbnSms IMbnSms;
#endif 	/* __IMbnSms_FWD_DEFINED__ */


#ifndef __IMbnSmsEvents_FWD_DEFINED__
#define __IMbnSmsEvents_FWD_DEFINED__
typedef interface IMbnSmsEvents IMbnSmsEvents;
#endif 	/* __IMbnSmsEvents_FWD_DEFINED__ */


#ifndef __IMbnServiceActivation_FWD_DEFINED__
#define __IMbnServiceActivation_FWD_DEFINED__
typedef interface IMbnServiceActivation IMbnServiceActivation;
#endif 	/* __IMbnServiceActivation_FWD_DEFINED__ */


#ifndef __IMbnServiceActivationEvents_FWD_DEFINED__
#define __IMbnServiceActivationEvents_FWD_DEFINED__
typedef interface IMbnServiceActivationEvents IMbnServiceActivationEvents;
#endif 	/* __IMbnServiceActivationEvents_FWD_DEFINED__ */


#ifndef __IMbnVendorSpecificOperation_FWD_DEFINED__
#define __IMbnVendorSpecificOperation_FWD_DEFINED__
typedef interface IMbnVendorSpecificOperation IMbnVendorSpecificOperation;
#endif 	/* __IMbnVendorSpecificOperation_FWD_DEFINED__ */


#ifndef __IMbnVendorSpecificEvents_FWD_DEFINED__
#define __IMbnVendorSpecificEvents_FWD_DEFINED__
typedef interface IMbnVendorSpecificEvents IMbnVendorSpecificEvents;
#endif 	/* __IMbnVendorSpecificEvents_FWD_DEFINED__ */


#ifndef __IMbnInterfaceManager_FWD_DEFINED__
#define __IMbnInterfaceManager_FWD_DEFINED__
typedef interface IMbnInterfaceManager IMbnInterfaceManager;
#endif 	/* __IMbnInterfaceManager_FWD_DEFINED__ */


#ifndef __IMbnInterfaceManagerEvents_FWD_DEFINED__
#define __IMbnInterfaceManagerEvents_FWD_DEFINED__
typedef interface IMbnInterfaceManagerEvents IMbnInterfaceManagerEvents;
#endif 	/* __IMbnInterfaceManagerEvents_FWD_DEFINED__ */


#ifndef __IMbnConnectionManager_FWD_DEFINED__
#define __IMbnConnectionManager_FWD_DEFINED__
typedef interface IMbnConnectionManager IMbnConnectionManager;
#endif 	/* __IMbnConnectionManager_FWD_DEFINED__ */


#ifndef __IMbnConnectionManagerEvents_FWD_DEFINED__
#define __IMbnConnectionManagerEvents_FWD_DEFINED__
typedef interface IMbnConnectionManagerEvents IMbnConnectionManagerEvents;
#endif 	/* __IMbnConnectionManagerEvents_FWD_DEFINED__ */


#ifndef __IMbnConnectionProfileManagerEvents_FWD_DEFINED__
#define __IMbnConnectionProfileManagerEvents_FWD_DEFINED__
typedef interface IMbnConnectionProfileManagerEvents IMbnConnectionProfileManagerEvents;
#endif 	/* __IMbnConnectionProfileManagerEvents_FWD_DEFINED__ */


#ifndef __IMbnRadio_FWD_DEFINED__
#define __IMbnRadio_FWD_DEFINED__
typedef interface IMbnRadio IMbnRadio;
#endif 	/* __IMbnRadio_FWD_DEFINED__ */


#ifndef __IMbnRadioEvents_FWD_DEFINED__
#define __IMbnRadioEvents_FWD_DEFINED__
typedef interface IMbnRadioEvents IMbnRadioEvents;
#endif 	/* __IMbnRadioEvents_FWD_DEFINED__ */


#ifndef __MbnConnectionProfileManager_FWD_DEFINED__
#define __MbnConnectionProfileManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class MbnConnectionProfileManager MbnConnectionProfileManager;
#else
typedef struct MbnConnectionProfileManager MbnConnectionProfileManager;
#endif /* __cplusplus */

#endif 	/* __MbnConnectionProfileManager_FWD_DEFINED__ */


#ifndef __MbnInterfaceManager_FWD_DEFINED__
#define __MbnInterfaceManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class MbnInterfaceManager MbnInterfaceManager;
#else
typedef struct MbnInterfaceManager MbnInterfaceManager;
#endif /* __cplusplus */

#endif 	/* __MbnInterfaceManager_FWD_DEFINED__ */


#ifndef __MbnConnectionManager_FWD_DEFINED__
#define __MbnConnectionManager_FWD_DEFINED__

#ifdef __cplusplus
typedef class MbnConnectionManager MbnConnectionManager;
#else
typedef struct MbnConnectionManager MbnConnectionManager;
#endif /* __cplusplus */

#endif 	/* __MbnConnectionManager_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_mbnapi_0000_0000 */
/* [local] */ 



































extern RPC_IF_HANDLE __MIDL_itf_mbnapi_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mbnapi_0000_0000_v0_0_s_ifspec;

#ifndef __IDummyMBNUCMExt_INTERFACE_DEFINED__
#define __IDummyMBNUCMExt_INTERFACE_DEFINED__

/* interface IDummyMBNUCMExt */
/* [object][uuid] */ 


EXTERN_C const IID IID_IDummyMBNUCMExt;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-FFFF-4BBB-AAEE-338E368AF6FA")
    IDummyMBNUCMExt : public IDispatch
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDummyMBNUCMExtVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IDummyMBNUCMExt * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IDummyMBNUCMExt * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IDummyMBNUCMExt * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            __RPC__in IDummyMBNUCMExt * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            __RPC__in IDummyMBNUCMExt * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            __RPC__in IDummyMBNUCMExt * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [range][in] */ __RPC__in_range(0,16384) UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IDummyMBNUCMExt * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        END_INTERFACE
    } IDummyMBNUCMExtVtbl;

    interface IDummyMBNUCMExt
    {
        CONST_VTBL struct IDummyMBNUCMExtVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDummyMBNUCMExt_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDummyMBNUCMExt_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDummyMBNUCMExt_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDummyMBNUCMExt_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IDummyMBNUCMExt_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IDummyMBNUCMExt_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IDummyMBNUCMExt_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDummyMBNUCMExt_INTERFACE_DEFINED__ */



#ifndef __MbnApi_LIBRARY_DEFINED__
#define __MbnApi_LIBRARY_DEFINED__

/* library MbnApi */
/* [helpstring][version][uuid] */ 

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("DCBBBAB6-6002-4BBB-AAEE-338E368AF6FA") 
enum MBN_CELLULAR_CLASS
    {	MBN_CELLULAR_CLASS_NONE	= 0,
	MBN_CELLULAR_CLASS_GSM	= 0x1,
	MBN_CELLULAR_CLASS_CDMA	= 0x2
    } 	MBN_CELLULAR_CLASS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("83A34F4C-BDC4-11DC-A8A8-001321F1405F") 
enum MBN_DATA_CLASS
    {	MBN_DATA_CLASS_NONE	= 0,
	MBN_DATA_CLASS_GPRS	= 0x1,
	MBN_DATA_CLASS_EDGE	= 0x2,
	MBN_DATA_CLASS_UMTS	= 0x4,
	MBN_DATA_CLASS_HSDPA	= 0x8,
	MBN_DATA_CLASS_HSUPA	= 0x10,
	MBN_DATA_CLASS_LTE	= 0x20,
	MBN_DATA_CLASS_1XRTT	= 0x10000,
	MBN_DATA_CLASS_1XEVDO	= 0x20000,
	MBN_DATA_CLASS_1XEVDO_REVA	= 0x40000,
	MBN_DATA_CLASS_1XEVDV	= 0x80000,
	MBN_DATA_CLASS_3XRTT	= 0x100000,
	MBN_DATA_CLASS_1XEVDO_REVB	= 0x200000,
	MBN_DATA_CLASS_UMB	= 0x400000,
	MBN_DATA_CLASS_CUSTOM	= 0x80000000
    } 	MBN_DATA_CLASS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("5DB6A98B-BDC5-11DC-A8A8-001321F1405F") 
enum MBN_BAND_CLASS
    {	MBN_BAND_CLASS_NONE	= 0,
	MBN_BAND_CLASS_0	= 0x1,
	MBN_BAND_CLASS_I	= 0x2,
	MBN_BAND_CLASS_II	= 0x4,
	MBN_BAND_CLASS_III	= 0x8,
	MBN_BAND_CLASS_IV	= 0x10,
	MBN_BAND_CLASS_V	= 0x20,
	MBN_BAND_CLASS_VI	= 0x40,
	MBN_BAND_CLASS_VII	= 0x80,
	MBN_BAND_CLASS_VIII	= 0x100,
	MBN_BAND_CLASS_IX	= 0x200,
	MBN_BAND_CLASS_X	= 0x400,
	MBN_BAND_CLASS_XI	= 0x800,
	MBN_BAND_CLASS_XII	= 0x1000,
	MBN_BAND_CLASS_XIII	= 0x2000,
	MBN_BAND_CLASS_XIV	= 0x4000,
	MBN_BAND_CLASS_XV	= 0x8000,
	MBN_BAND_CLASS_XVI	= 0x10000,
	MBN_BAND_CLASS_XVII	= 0x20000,
	MBN_BAND_CLASS_CUSTOM	= 0x80000000
    } 	MBN_BAND_CLASS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("DCBBBAB6-6012-4BBB-AAEE-338E368AF6FA") 
enum MBN_VOICE_CLASS
    {	MBN_VOICE_CLASS_NONE	= 0,
	MBN_VOICE_CLASS_NO_VOICE	= 0x1,
	MBN_VOICE_CLASS_SEPARATE_VOICE_DATA	= 0x2,
	MBN_VOICE_CLASS_SIMULTANEOUS_VOICE_DATA	= 0x3
    } 	MBN_VOICE_CLASS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("2308C1F7-BDC8-11DC-A8A8-001321F1405F") 
enum MBN_CTRL_CAPS
    {	MBN_CTRL_CAPS_NONE	= 0,
	MBN_CTRL_CAPS_REG_MANUAL	= 0x1,
	MBN_CTRL_CAPS_HW_RADIO_SWITCH	= 0x2,
	MBN_CTRL_CAPS_CDMA_MOBILE_IP	= 0x4,
	MBN_CTRL_CAPS_CDMA_SIMPLE_IP	= 0x8,
	MBN_CTRL_CAPS_PROTECT_UNIQUEID	= 0x10
    } 	MBN_CTRL_CAPS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("E4096459-BDC8-11DC-A8A8-001321F1405F") 
enum MBN_SMS_CAPS
    {	MBN_SMS_CAPS_NONE	= 0,
	MBN_SMS_CAPS_PDU_RECEIVE	= 0x1,
	MBN_SMS_CAPS_PDU_SEND	= 0x2,
	MBN_SMS_CAPS_TEXT_RECEIVE	= 0x4,
	MBN_SMS_CAPS_TEXT_SEND	= 0x8
    } 	MBN_SMS_CAPS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("59C235E7-BDC9-11DC-A8A8-001321F1405F") 
enum MBN_INTERFACE_CAPS_CONSTANTS
    {	MBN_DEVICEID_LEN	= 18,
	MBN_MANUFACTURER_LEN	= 32,
	MBN_MODEL_LEN	= 32,
	MBN_FIRMWARE_LEN	= 32
    } 	MBN_INTERFACE_CAPS_CONSTANTS;

typedef /* [uuid] */  DECLSPEC_UUID("CD1A4B17-BDC9-11DC-A8A8-001321F1405F") struct MBN_INTERFACE_CAPS
    {
    MBN_CELLULAR_CLASS cellularClass;
    MBN_VOICE_CLASS voiceClass;
    ULONG dataClass;
    BSTR customDataClass;
    ULONG gsmBandClass;
    ULONG cdmaBandClass;
    BSTR customBandClass;
    ULONG smsCaps;
    ULONG controlCaps;
    BSTR deviceID;
    BSTR manufacturer;
    BSTR model;
    BSTR firmwareInfo;
    } 	MBN_INTERFACE_CAPS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("DCBBBAB6-6003-4BBB-AAEE-338E368AF6FA") 
enum MBN_READY_STATE
    {	MBN_READY_STATE_OFF	= 0,
	MBN_READY_STATE_INITIALIZED	= ( MBN_READY_STATE_OFF + 1 ) ,
	MBN_READY_STATE_SIM_NOT_INSERTED	= ( MBN_READY_STATE_INITIALIZED + 1 ) ,
	MBN_READY_STATE_BAD_SIM	= ( MBN_READY_STATE_SIM_NOT_INSERTED + 1 ) ,
	MBN_READY_STATE_FAILURE	= ( MBN_READY_STATE_BAD_SIM + 1 ) ,
	MBN_READY_STATE_NOT_ACTIVATED	= ( MBN_READY_STATE_FAILURE + 1 ) ,
	MBN_READY_STATE_DEVICE_LOCKED	= ( MBN_READY_STATE_NOT_ACTIVATED + 1 ) ,
	MBN_READY_STATE_DEVICE_BLOCKED	= ( MBN_READY_STATE_DEVICE_LOCKED + 1 ) 
    } 	MBN_READY_STATE;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("6E1348BB-BDCB-11DC-A8A8-001321F1405F") 
enum MBN_PROVIDER_STATE
    {	MBN_PROVIDER_STATE_NONE	= 0,
	MBN_PROVIDER_STATE_HOME	= 0x1,
	MBN_PROVIDER_STATE_FORBIDDEN	= 0x2,
	MBN_PROVIDER_STATE_PREFERRED	= 0x4,
	MBN_PROVIDER_STATE_VISIBLE	= 0x8,
	MBN_PROVIDER_STATE_REGISTERED	= 0x10
    } 	MBN_PROVIDER_STATE;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("934092FD-BDCB-11DC-A8A8-001321F1405F") 
enum MBN_PROVIDER_CONSTANTS
    {	MBN_PROVIDERNAME_LEN	= 20,
	MBN_PROVIDERID_LEN	= 6
    } 	MBN_PROVIDER_CONSTANTS;

typedef /* [uuid] */  DECLSPEC_UUID("DCBBBAB6-9005-4BBB-AAEE-338E368AF6FA") struct MBN_PROVIDER
    {
    BSTR providerID;
    ULONG providerState;
    BSTR providerName;
    ULONG dataClass;
    } 	MBN_PROVIDER;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("42FAAC0B-BDCC-11DC-A8A8-001321F1405F") 
enum MBN_SIGNAL_CONSTANTS
    {	MBN_RSSI_DEFAULT	= 0xffffffff,
	MBN_RSSI_DISABLE	= 0,
	MBN_RSSI_UNKNOWN	= 99,
	MBN_ERROR_RATE_UNKNOWN	= 99
    } 	MBN_SIGNAL_CONSTANTS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("DCBBBAB6-6005-4BBB-AAEE-338E368AF6FA") 
enum MBN_PIN_TYPE
    {	MBN_PIN_TYPE_NONE	= 0,
	MBN_PIN_TYPE_CUSTOM	= ( MBN_PIN_TYPE_NONE + 1 ) ,
	MBN_PIN_TYPE_PIN1	= ( MBN_PIN_TYPE_CUSTOM + 1 ) ,
	MBN_PIN_TYPE_PIN2	= ( MBN_PIN_TYPE_PIN1 + 1 ) ,
	MBN_PIN_TYPE_DEVICE_SIM_PIN	= ( MBN_PIN_TYPE_PIN2 + 1 ) ,
	MBN_PIN_TYPE_DEVICE_FIRST_SIM_PIN	= ( MBN_PIN_TYPE_DEVICE_SIM_PIN + 1 ) ,
	MBN_PIN_TYPE_NETWORK_PIN	= ( MBN_PIN_TYPE_DEVICE_FIRST_SIM_PIN + 1 ) ,
	MBN_PIN_TYPE_NETWORK_SUBSET_PIN	= ( MBN_PIN_TYPE_NETWORK_PIN + 1 ) ,
	MBN_PIN_TYPE_SVC_PROVIDER_PIN	= ( MBN_PIN_TYPE_NETWORK_SUBSET_PIN + 1 ) ,
	MBN_PIN_TYPE_CORPORATE_PIN	= ( MBN_PIN_TYPE_SVC_PROVIDER_PIN + 1 ) ,
	MBN_PIN_TYPE_SUBSIDY_LOCK	= ( MBN_PIN_TYPE_CORPORATE_PIN + 1 ) 
    } 	MBN_PIN_TYPE;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("BD8A2871-BDCD-11DC-A8A8-001321F1405F") 
enum MBN_PIN_MODE
    {	MBN_PIN_MODE_ENABLED	= 1,
	MBN_PIN_MODE_DISABLED	= ( MBN_PIN_MODE_ENABLED + 1 ) 
    } 	MBN_PIN_MODE;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("C2A93665-BDCD-11DC-A8A8-001321F1405F") 
enum MBN_PIN_FORMAT
    {	MBN_PIN_FORMAT_NONE	= 0,
	MBN_PIN_FORMAT_NUMERIC	= ( MBN_PIN_FORMAT_NONE + 1 ) ,
	MBN_PIN_FORMAT_ALPHANUMERIC	= ( MBN_PIN_FORMAT_NUMERIC + 1 ) 
    } 	MBN_PIN_FORMAT;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("C75E76F5-BDCD-11DC-A8A8-001321F1405F") 
enum MBN_PIN_CONSTANTS
    {	MBN_ATTEMPTS_REMAINING_UNKNOWN	= 0xffffffff,
	MBN_PIN_LENGTH_UNKNOWN	= 0xffffffff
    } 	MBN_PIN_CONSTANTS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("D11BD29D-BDCD-11DC-A8A8-001321F1405F") 
enum MBN_PIN_STATE
    {	MBN_PIN_STATE_NONE	= 0,
	MBN_PIN_STATE_ENTER	= ( MBN_PIN_STATE_NONE + 1 ) ,
	MBN_PIN_STATE_UNBLOCK	= ( MBN_PIN_STATE_ENTER + 1 ) 
    } 	MBN_PIN_STATE;

typedef /* [uuid] */  DECLSPEC_UUID("DCBBBAB6-9006-4BBB-AAEE-338E368AF6FA") struct MBN_PIN_INFO
    {
    MBN_PIN_STATE pinState;
    MBN_PIN_TYPE pinType;
    ULONG attemptsRemaining;
    } 	MBN_PIN_INFO;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("D5F1726B-BDCE-11DC-A8A8-001321F1405F") 
enum MBN_REGISTRATION_CONSTANTS
    {	MBN_ROAMTEXT_LEN	= 64,
	MBN_CDMA_DEFAULT_PROVIDER_ID	= 0
    } 	MBN_REGISTRATION_CONSTANTS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("DCBBBAB6-6009-4BBB-AAEE-338E368AF6FA") 
enum MBN_REGISTER_STATE
    {	MBN_REGISTER_STATE_NONE	= 0,
	MBN_REGISTER_STATE_DEREGISTERED	= ( MBN_REGISTER_STATE_NONE + 1 ) ,
	MBN_REGISTER_STATE_SEARCHING	= ( MBN_REGISTER_STATE_DEREGISTERED + 1 ) ,
	MBN_REGISTER_STATE_HOME	= ( MBN_REGISTER_STATE_SEARCHING + 1 ) ,
	MBN_REGISTER_STATE_ROAMING	= ( MBN_REGISTER_STATE_HOME + 1 ) ,
	MBN_REGISTER_STATE_PARTNER	= ( MBN_REGISTER_STATE_ROAMING + 1 ) ,
	MBN_REGISTER_STATE_DENIED	= ( MBN_REGISTER_STATE_PARTNER + 1 ) 
    } 	MBN_REGISTER_STATE;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("D7F73F35-BDCD-11DC-A8A8-001321F1405F") 
enum MBN_REGISTER_MODE
    {	MBN_REGISTER_MODE_NONE	= 0,
	MBN_REGISTER_MODE_AUTOMATIC	= ( MBN_REGISTER_MODE_NONE + 1 ) ,
	MBN_REGISTER_MODE_MANUAL	= ( MBN_REGISTER_MODE_AUTOMATIC + 1 ) 
    } 	MBN_REGISTER_MODE;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("0E62803F-BDD0-11DC-A8A8-001321F1405F") 
enum MBN_CONTEXT_CONSTANTS
    {	MBN_ACCESSSTRING_LEN	= 100,
	MBN_USERNAME_LEN	= 255,
	MBN_PASSWORD_LEN	= 255,
	MBN_CONTEXT_ID_APPEND	= 0xffffffff
    } 	MBN_CONTEXT_CONSTANTS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("E24B42EF-BDCD-11DC-A8A8-001321F1405F") 
enum MBN_AUTH_PROTOCOL
    {	MBN_AUTH_PROTOCOL_NONE	= 0,
	MBN_AUTH_PROTOCOL_PAP	= ( MBN_AUTH_PROTOCOL_NONE + 1 ) ,
	MBN_AUTH_PROTOCOL_CHAP	= ( MBN_AUTH_PROTOCOL_PAP + 1 ) ,
	MBN_AUTH_PROTOCOL_MSCHAPV2	= ( MBN_AUTH_PROTOCOL_CHAP + 1 ) 
    } 	MBN_AUTH_PROTOCOL;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("E6A360B9-BDCD-11DC-A8A8-001321F1405F") 
enum MBN_COMPRESSION
    {	MBN_COMPRESSION_NONE	= 0,
	MBN_COMPRESSION_ENABLE	= ( MBN_COMPRESSION_NONE + 1 ) 
    } 	MBN_COMPRESSION;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("EB4731EB-BDCD-11DC-A8A8-001321F1405F") 
enum MBN_CONTEXT_TYPE
    {	MBN_CONTEXT_TYPE_NONE	= 0,
	MBN_CONTEXT_TYPE_INTERNET	= ( MBN_CONTEXT_TYPE_NONE + 1 ) ,
	MBN_CONTEXT_TYPE_VPN	= ( MBN_CONTEXT_TYPE_INTERNET + 1 ) ,
	MBN_CONTEXT_TYPE_VOICE	= ( MBN_CONTEXT_TYPE_VPN + 1 ) ,
	MBN_CONTEXT_TYPE_VIDEO_SHARE	= ( MBN_CONTEXT_TYPE_VOICE + 1 ) ,
	MBN_CONTEXT_TYPE_CUSTOM	= ( MBN_CONTEXT_TYPE_VIDEO_SHARE + 1 ) 
    } 	MBN_CONTEXT_TYPE;

typedef /* [uuid] */  DECLSPEC_UUID("FE1F7B6F-BDCD-11DC-A8A8-001321F1405F") struct MBN_CONTEXT
    {
    ULONG contextID;
    MBN_CONTEXT_TYPE contextType;
    BSTR accessString;
    BSTR userName;
    BSTR password;
    MBN_COMPRESSION compression;
    MBN_AUTH_PROTOCOL authType;
    } 	MBN_CONTEXT;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("EFB7C00D-BDCD-11DC-A8A8-001321F1405F") 
enum MBN_ACTIVATION_STATE
    {	MBN_ACTIVATION_STATE_NONE	= 0,
	MBN_ACTIVATION_STATE_ACTIVATED	= ( MBN_ACTIVATION_STATE_NONE + 1 ) ,
	MBN_ACTIVATION_STATE_ACTIVATING	= ( MBN_ACTIVATION_STATE_ACTIVATED + 1 ) ,
	MBN_ACTIVATION_STATE_DEACTIVATED	= ( MBN_ACTIVATION_STATE_ACTIVATING + 1 ) ,
	MBN_ACTIVATION_STATE_DEACTIVATING	= ( MBN_ACTIVATION_STATE_DEACTIVATED + 1 ) 
    } 	MBN_ACTIVATION_STATE;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("F601E1EB-BDCD-11DC-A8A8-001321F1405F") 
enum MBN_CONNECTION_MODE
    {	MBN_CONNECTION_MODE_PROFILE	= 0,
	MBN_CONNECTION_MODE_TMP_PROFILE	= ( MBN_CONNECTION_MODE_PROFILE + 1 ) 
    } 	MBN_CONNECTION_MODE;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("6D8846E5-BDD1-11DC-A8A8-001321F1405F") 
enum MBN_VOICE_CALL_STATE
    {	MBN_VOICE_CALL_STATE_NONE	= 0,
	MBN_VOICE_CALL_STATE_IN_PROGRESS	= ( MBN_VOICE_CALL_STATE_NONE + 1 ) ,
	MBN_VOICE_CALL_STATE_HANGUP	= ( MBN_VOICE_CALL_STATE_IN_PROGRESS + 1 ) 
    } 	MBN_VOICE_CALL_STATE;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("130C65D3-BDD3-11DC-A8A8-001321F1405F") 
enum MBN_SMS_CONSTANTS
    {	MBN_MESSAGE_INDEX_NONE	= 0,
	MBN_CDMA_SHORT_MSG_SIZE_UNKNOWN	= 0,
	MBN_CDMA_SHORT_MSG_SIZE_MAX	= 160
    } 	WWAEXT_SMS_CONSTANTS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("FC208FC1-BDE5-11DC-A8A8-001321F1405F") 
enum MBN_MSG_STATUS
    {	MBN_MSG_STATUS_NEW	= 0,
	MBN_MSG_STATUS_OLD	= ( MBN_MSG_STATUS_NEW + 1 ) ,
	MBN_MSG_STATUS_DRAFT	= ( MBN_MSG_STATUS_OLD + 1 ) ,
	MBN_MSG_STATUS_SENT	= ( MBN_MSG_STATUS_DRAFT + 1 ) 
    } 	MBN_MSG_STATUS;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("29912B29-BDD4-11DC-A8A8-001321F1405F") 
enum MBN_SMS_CDMA_LANG
    {	MBN_SMS_CDMA_LANG_NONE	= 0,
	MBN_SMS_CDMA_LANG_ENGLISH	= ( MBN_SMS_CDMA_LANG_NONE + 1 ) ,
	MBN_SMS_CDMA_LANG_FRENCH	= ( MBN_SMS_CDMA_LANG_ENGLISH + 1 ) ,
	MBN_SMS_CDMA_LANG_SPANISH	= ( MBN_SMS_CDMA_LANG_FRENCH + 1 ) ,
	MBN_SMS_CDMA_LANG_JAPANESE	= ( MBN_SMS_CDMA_LANG_SPANISH + 1 ) ,
	MBN_SMS_CDMA_LANG_KOREAN	= ( MBN_SMS_CDMA_LANG_JAPANESE + 1 ) ,
	MBN_SMS_CDMA_LANG_CHINESE	= ( MBN_SMS_CDMA_LANG_KOREAN + 1 ) ,
	MBN_SMS_CDMA_LANG_HEBREW	= ( MBN_SMS_CDMA_LANG_CHINESE + 1 ) 
    } 	MBN_SMS_CDMA_LANG;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("7F8E74CB-BDD4-11DC-A8A8-001321F1405F") 
enum MBN_SMS_CDMA_ENCODING
    {	MBN_SMS_CDMA_ENCODING_OCTET	= 0,
	MBN_SMS_CDMA_ENCODING_EPM	= ( MBN_SMS_CDMA_ENCODING_OCTET + 1 ) ,
	MBN_SMS_CDMA_ENCODING_7BIT_ASCII	= ( MBN_SMS_CDMA_ENCODING_EPM + 1 ) ,
	MBN_SMS_CDMA_ENCODING_IA5	= ( MBN_SMS_CDMA_ENCODING_7BIT_ASCII + 1 ) ,
	MBN_SMS_CDMA_ENCODING_UNICODE	= ( MBN_SMS_CDMA_ENCODING_IA5 + 1 ) ,
	MBN_SMS_CDMA_ENCODING_SHIFT_JIS	= ( MBN_SMS_CDMA_ENCODING_UNICODE + 1 ) ,
	MBN_SMS_CDMA_ENCODING_KOREAN	= ( MBN_SMS_CDMA_ENCODING_SHIFT_JIS + 1 ) ,
	MBN_SMS_CDMA_ENCODING_LATIN_HEBREW	= ( MBN_SMS_CDMA_ENCODING_KOREAN + 1 ) ,
	MBN_SMS_CDMA_ENCODING_LATIN	= ( MBN_SMS_CDMA_ENCODING_LATIN_HEBREW + 1 ) ,
	MBN_SMS_CDMA_ENCODING_GSM_7BIT	= ( MBN_SMS_CDMA_ENCODING_LATIN + 1 ) 
    } 	MBN_SMS_CDMA_ENCODING;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("0D42B514-BDDC-11DC-A8A8-001321F1405F") 
enum MBN_SMS_FLAG
    {	MBN_SMS_FLAG_ALL	= 0,
	MBN_SMS_FLAG_INDEX	= ( MBN_SMS_FLAG_ALL + 1 ) ,
	MBN_SMS_FLAG_NEW	= ( MBN_SMS_FLAG_INDEX + 1 ) ,
	MBN_SMS_FLAG_OLD	= ( MBN_SMS_FLAG_NEW + 1 ) ,
	MBN_SMS_FLAG_SENT	= ( MBN_SMS_FLAG_OLD + 1 ) ,
	MBN_SMS_FLAG_DRAFT	= ( MBN_SMS_FLAG_SENT + 1 ) 
    } 	MBN_SMS_FLAG;

typedef /* [uuid] */  DECLSPEC_UUID("406BFD60-BDDC-11DC-A8A8-001321F1405F") struct MBN_SMS_FILTER
    {
    MBN_SMS_FLAG flag;
    ULONG messageIndex;
    } 	MBN_SMS_FILTER;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("8098009D-BDDC-11DC-A8A8-001321F1405F") 
enum MBN_SMS_STATUS_FLAG
    {	MBN_SMS_FLAG_NONE	= 0,
	MBN_SMS_FLAG_MESSAGE_STORE_FULL	= 0x1,
	MBN_SMS_FLAG_NEW_MESSAGE	= 0x2
    } 	MBN_SMS_STATUS_FLAG;

typedef /* [uuid] */  DECLSPEC_UUID("1F6E9CA3-BDE6-11DC-A8A8-001321F1405F") struct MBN_SMS_STATUS_INFO
    {
    ULONG flag;
    ULONG messageIndex;
    } 	MBN_SMS_STATUS_INFO;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("4B0FE227-3709-41e2-8A78-E98C0CD0CB09") 
enum MBN_SMS_FORMAT
    {	MBN_SMS_FORMAT_NONE	= 0,
	MBN_SMS_FORMAT_PDU	= 0x1,
	MBN_SMS_FORMAT_TEXT	= 0x2
    } 	MBN_SMS_FORMAT;

typedef /* [helpstring][v1_enum][version][uuid] */  DECLSPEC_UUID("532A3FE4-BDE6-11DC-A8A8-001321F1405F") 
enum MBN_RADIO
    {	MBN_RADIO_OFF	= 0,
	MBN_RADIO_ON	= ( MBN_RADIO_OFF + 1 ) 
    } 	MBN_RADIO;


EXTERN_C const IID LIBID_MbnApi;

#ifndef __IMbnInterface_INTERFACE_DEFINED__
#define __IMbnInterface_INTERFACE_DEFINED__

/* interface IMbnInterface */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnInterface;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2001-4BBB-AAEE-338E368AF6FA")
    IMbnInterface : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InterfaceID( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *InterfaceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterfaceCapability( 
            /* [retval][ref][out] */ __RPC__out MBN_INTERFACE_CAPS *interfaceCaps) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSubscriberInformation( 
            /* [retval][out] */ __RPC__deref_out_opt IMbnSubscriberInformation **subscriberInformation) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetReadyState( 
            /* [retval][ref][out] */ __RPC__out MBN_READY_STATE *readyState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE InEmergencyMode( 
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *emergencyMode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetHomeProvider( 
            /* [retval][ref][out] */ __RPC__out MBN_PROVIDER *homeProvider) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPreferredProviders( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *preferredProviders) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetPreferredProviders( 
            /* [in] */ __RPC__in SAFEARRAY * preferredProviders,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetVisibleProviders( 
            /* [out] */ __RPC__out ULONG *age,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *visibleProviders) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ScanNetwork( 
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnection( 
            /* [retval][out] */ __RPC__deref_out_opt IMbnConnection **mbnConnection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnInterfaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnInterface * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnInterface * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnInterface * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InterfaceID )( 
            __RPC__in IMbnInterface * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *InterfaceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInterfaceCapability )( 
            __RPC__in IMbnInterface * This,
            /* [retval][ref][out] */ __RPC__out MBN_INTERFACE_CAPS *interfaceCaps);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSubscriberInformation )( 
            __RPC__in IMbnInterface * This,
            /* [retval][out] */ __RPC__deref_out_opt IMbnSubscriberInformation **subscriberInformation);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetReadyState )( 
            __RPC__in IMbnInterface * This,
            /* [retval][ref][out] */ __RPC__out MBN_READY_STATE *readyState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *InEmergencyMode )( 
            __RPC__in IMbnInterface * This,
            /* [retval][ref][out] */ __RPC__out VARIANT_BOOL *emergencyMode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetHomeProvider )( 
            __RPC__in IMbnInterface * This,
            /* [retval][ref][out] */ __RPC__out MBN_PROVIDER *homeProvider);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPreferredProviders )( 
            __RPC__in IMbnInterface * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *preferredProviders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetPreferredProviders )( 
            __RPC__in IMbnInterface * This,
            /* [in] */ __RPC__in SAFEARRAY * preferredProviders,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetVisibleProviders )( 
            __RPC__in IMbnInterface * This,
            /* [out] */ __RPC__out ULONG *age,
            /* [retval][out] */ __RPC__deref_out_opt SAFEARRAY * *visibleProviders);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ScanNetwork )( 
            __RPC__in IMbnInterface * This,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            __RPC__in IMbnInterface * This,
            /* [retval][out] */ __RPC__deref_out_opt IMbnConnection **mbnConnection);
        
        END_INTERFACE
    } IMbnInterfaceVtbl;

    interface IMbnInterface
    {
        CONST_VTBL struct IMbnInterfaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnInterface_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnInterface_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnInterface_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnInterface_get_InterfaceID(This,InterfaceID)	\
    ( (This)->lpVtbl -> get_InterfaceID(This,InterfaceID) ) 

#define IMbnInterface_GetInterfaceCapability(This,interfaceCaps)	\
    ( (This)->lpVtbl -> GetInterfaceCapability(This,interfaceCaps) ) 

#define IMbnInterface_GetSubscriberInformation(This,subscriberInformation)	\
    ( (This)->lpVtbl -> GetSubscriberInformation(This,subscriberInformation) ) 

#define IMbnInterface_GetReadyState(This,readyState)	\
    ( (This)->lpVtbl -> GetReadyState(This,readyState) ) 

#define IMbnInterface_InEmergencyMode(This,emergencyMode)	\
    ( (This)->lpVtbl -> InEmergencyMode(This,emergencyMode) ) 

#define IMbnInterface_GetHomeProvider(This,homeProvider)	\
    ( (This)->lpVtbl -> GetHomeProvider(This,homeProvider) ) 

#define IMbnInterface_GetPreferredProviders(This,preferredProviders)	\
    ( (This)->lpVtbl -> GetPreferredProviders(This,preferredProviders) ) 

#define IMbnInterface_SetPreferredProviders(This,preferredProviders,requestID)	\
    ( (This)->lpVtbl -> SetPreferredProviders(This,preferredProviders,requestID) ) 

#define IMbnInterface_GetVisibleProviders(This,age,visibleProviders)	\
    ( (This)->lpVtbl -> GetVisibleProviders(This,age,visibleProviders) ) 

#define IMbnInterface_ScanNetwork(This,requestID)	\
    ( (This)->lpVtbl -> ScanNetwork(This,requestID) ) 

#define IMbnInterface_GetConnection(This,mbnConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,mbnConnection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnInterface_INTERFACE_DEFINED__ */


#ifndef __IMbnSubscriberInformation_INTERFACE_DEFINED__
#define __IMbnSubscriberInformation_INTERFACE_DEFINED__

/* interface IMbnSubscriberInformation */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnSubscriberInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("459ECC43-BCF5-11DC-A8A8-001321F1405F")
    IMbnSubscriberInformation : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SubscriberID( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *SubscriberID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SimIccID( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *SimIccID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TelephoneNumbers( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *TelephoneNumbers) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnSubscriberInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnSubscriberInformation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnSubscriberInformation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnSubscriberInformation * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubscriberID )( 
            __RPC__in IMbnSubscriberInformation * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *SubscriberID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SimIccID )( 
            __RPC__in IMbnSubscriberInformation * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *SimIccID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TelephoneNumbers )( 
            __RPC__in IMbnSubscriberInformation * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *TelephoneNumbers);
        
        END_INTERFACE
    } IMbnSubscriberInformationVtbl;

    interface IMbnSubscriberInformation
    {
        CONST_VTBL struct IMbnSubscriberInformationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnSubscriberInformation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnSubscriberInformation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnSubscriberInformation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnSubscriberInformation_get_SubscriberID(This,SubscriberID)	\
    ( (This)->lpVtbl -> get_SubscriberID(This,SubscriberID) ) 

#define IMbnSubscriberInformation_get_SimIccID(This,SimIccID)	\
    ( (This)->lpVtbl -> get_SimIccID(This,SimIccID) ) 

#define IMbnSubscriberInformation_get_TelephoneNumbers(This,TelephoneNumbers)	\
    ( (This)->lpVtbl -> get_TelephoneNumbers(This,TelephoneNumbers) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnSubscriberInformation_INTERFACE_DEFINED__ */


#ifndef __IMbnInterfaceEvents_INTERFACE_DEFINED__
#define __IMbnInterfaceEvents_INTERFACE_DEFINED__

/* interface IMbnInterfaceEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnInterfaceEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2002-4BBB-AAEE-338E368AF6FA")
    IMbnInterfaceEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnInterfaceCapabilityAvailable( 
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSubscriberInformationChange( 
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnReadyStateChange( 
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnEmergencyModeChange( 
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnHomeProviderAvailable( 
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnPreferredProvidersChange( 
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSetPreferredProvidersComplete( 
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnScanNetworkComplete( 
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnInterfaceEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnInterfaceEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnInterfaceEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnInterfaceEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnInterfaceCapabilityAvailable )( 
            __RPC__in IMbnInterfaceEvents * This,
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSubscriberInformationChange )( 
            __RPC__in IMbnInterfaceEvents * This,
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnReadyStateChange )( 
            __RPC__in IMbnInterfaceEvents * This,
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnEmergencyModeChange )( 
            __RPC__in IMbnInterfaceEvents * This,
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnHomeProviderAvailable )( 
            __RPC__in IMbnInterfaceEvents * This,
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnPreferredProvidersChange )( 
            __RPC__in IMbnInterfaceEvents * This,
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSetPreferredProvidersComplete )( 
            __RPC__in IMbnInterfaceEvents * This,
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnScanNetworkComplete )( 
            __RPC__in IMbnInterfaceEvents * This,
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        END_INTERFACE
    } IMbnInterfaceEventsVtbl;

    interface IMbnInterfaceEvents
    {
        CONST_VTBL struct IMbnInterfaceEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnInterfaceEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnInterfaceEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnInterfaceEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnInterfaceEvents_OnInterfaceCapabilityAvailable(This,newInterface)	\
    ( (This)->lpVtbl -> OnInterfaceCapabilityAvailable(This,newInterface) ) 

#define IMbnInterfaceEvents_OnSubscriberInformationChange(This,newInterface)	\
    ( (This)->lpVtbl -> OnSubscriberInformationChange(This,newInterface) ) 

#define IMbnInterfaceEvents_OnReadyStateChange(This,newInterface)	\
    ( (This)->lpVtbl -> OnReadyStateChange(This,newInterface) ) 

#define IMbnInterfaceEvents_OnEmergencyModeChange(This,newInterface)	\
    ( (This)->lpVtbl -> OnEmergencyModeChange(This,newInterface) ) 

#define IMbnInterfaceEvents_OnHomeProviderAvailable(This,newInterface)	\
    ( (This)->lpVtbl -> OnHomeProviderAvailable(This,newInterface) ) 

#define IMbnInterfaceEvents_OnPreferredProvidersChange(This,newInterface)	\
    ( (This)->lpVtbl -> OnPreferredProvidersChange(This,newInterface) ) 

#define IMbnInterfaceEvents_OnSetPreferredProvidersComplete(This,newInterface,requestID,status)	\
    ( (This)->lpVtbl -> OnSetPreferredProvidersComplete(This,newInterface,requestID,status) ) 

#define IMbnInterfaceEvents_OnScanNetworkComplete(This,newInterface,requestID,status)	\
    ( (This)->lpVtbl -> OnScanNetworkComplete(This,newInterface,requestID,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnInterfaceEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnSignal_INTERFACE_DEFINED__
#define __IMbnSignal_INTERFACE_DEFINED__

/* interface IMbnSignal */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnSignal;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2003-4BBB-AAEE-338E368AF6FA")
    IMbnSignal : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSignalStrength( 
            /* [retval][ref][out] */ __RPC__out ULONG *signalStrength) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSignalError( 
            /* [retval][ref][out] */ __RPC__out ULONG *signalError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnSignalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnSignal * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnSignal * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnSignal * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSignalStrength )( 
            __RPC__in IMbnSignal * This,
            /* [retval][ref][out] */ __RPC__out ULONG *signalStrength);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSignalError )( 
            __RPC__in IMbnSignal * This,
            /* [retval][ref][out] */ __RPC__out ULONG *signalError);
        
        END_INTERFACE
    } IMbnSignalVtbl;

    interface IMbnSignal
    {
        CONST_VTBL struct IMbnSignalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnSignal_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnSignal_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnSignal_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnSignal_GetSignalStrength(This,signalStrength)	\
    ( (This)->lpVtbl -> GetSignalStrength(This,signalStrength) ) 

#define IMbnSignal_GetSignalError(This,signalError)	\
    ( (This)->lpVtbl -> GetSignalError(This,signalError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnSignal_INTERFACE_DEFINED__ */


#ifndef __IMbnSignalEvents_INTERFACE_DEFINED__
#define __IMbnSignalEvents_INTERFACE_DEFINED__

/* interface IMbnSignalEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnSignalEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2004-4BBB-AAEE-338E368AF6FA")
    IMbnSignalEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSignalStateChange( 
            /* [in] */ __RPC__in_opt IMbnSignal *newInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnSignalEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnSignalEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnSignalEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnSignalEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSignalStateChange )( 
            __RPC__in IMbnSignalEvents * This,
            /* [in] */ __RPC__in_opt IMbnSignal *newInterface);
        
        END_INTERFACE
    } IMbnSignalEventsVtbl;

    interface IMbnSignalEvents
    {
        CONST_VTBL struct IMbnSignalEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnSignalEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnSignalEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnSignalEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnSignalEvents_OnSignalStateChange(This,newInterface)	\
    ( (This)->lpVtbl -> OnSignalStateChange(This,newInterface) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnSignalEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnPinManager_INTERFACE_DEFINED__
#define __IMbnPinManager_INTERFACE_DEFINED__

/* interface IMbnPinManager */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnPinManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2005-4BBB-AAEE-338E368AF6FA")
    IMbnPinManager : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPinList( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pinList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPin( 
            /* [in] */ MBN_PIN_TYPE pinType,
            /* [retval][ref][out] */ __RPC__deref_out_opt IMbnPin **pin) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPinState( 
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnPinManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnPinManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnPinManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnPinManager * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPinList )( 
            __RPC__in IMbnPinManager * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *pinList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPin )( 
            __RPC__in IMbnPinManager * This,
            /* [in] */ MBN_PIN_TYPE pinType,
            /* [retval][ref][out] */ __RPC__deref_out_opt IMbnPin **pin);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPinState )( 
            __RPC__in IMbnPinManager * This,
            /* [out] */ __RPC__out ULONG *requestID);
        
        END_INTERFACE
    } IMbnPinManagerVtbl;

    interface IMbnPinManager
    {
        CONST_VTBL struct IMbnPinManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnPinManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnPinManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnPinManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnPinManager_GetPinList(This,pinList)	\
    ( (This)->lpVtbl -> GetPinList(This,pinList) ) 

#define IMbnPinManager_GetPin(This,pinType,pin)	\
    ( (This)->lpVtbl -> GetPin(This,pinType,pin) ) 

#define IMbnPinManager_GetPinState(This,requestID)	\
    ( (This)->lpVtbl -> GetPinState(This,requestID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnPinManager_INTERFACE_DEFINED__ */


#ifndef __IMbnPinManagerEvents_INTERFACE_DEFINED__
#define __IMbnPinManagerEvents_INTERFACE_DEFINED__

/* interface IMbnPinManagerEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnPinManagerEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2006-4BBB-AAEE-338E368AF6FA")
    IMbnPinManagerEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnPinListAvailable( 
            /* [in] */ __RPC__in_opt IMbnPinManager *pinManager) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnGetPinStateComplete( 
            /* [in] */ __RPC__in_opt IMbnPinManager *pinManager,
            /* [in] */ MBN_PIN_INFO pinInfo,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnPinManagerEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnPinManagerEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnPinManagerEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnPinManagerEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnPinListAvailable )( 
            __RPC__in IMbnPinManagerEvents * This,
            /* [in] */ __RPC__in_opt IMbnPinManager *pinManager);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnGetPinStateComplete )( 
            __RPC__in IMbnPinManagerEvents * This,
            /* [in] */ __RPC__in_opt IMbnPinManager *pinManager,
            /* [in] */ MBN_PIN_INFO pinInfo,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        END_INTERFACE
    } IMbnPinManagerEventsVtbl;

    interface IMbnPinManagerEvents
    {
        CONST_VTBL struct IMbnPinManagerEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnPinManagerEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnPinManagerEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnPinManagerEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnPinManagerEvents_OnPinListAvailable(This,pinManager)	\
    ( (This)->lpVtbl -> OnPinListAvailable(This,pinManager) ) 

#define IMbnPinManagerEvents_OnGetPinStateComplete(This,pinManager,pinInfo,requestID,status)	\
    ( (This)->lpVtbl -> OnGetPinStateComplete(This,pinManager,pinInfo,requestID,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnPinManagerEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnPin_INTERFACE_DEFINED__
#define __IMbnPin_INTERFACE_DEFINED__

/* interface IMbnPin */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnPin;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2007-4BBB-AAEE-338E368AF6FA")
    IMbnPin : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PinType( 
            /* [retval][ref][out] */ __RPC__out MBN_PIN_TYPE *PinType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PinFormat( 
            /* [retval][ref][out] */ __RPC__out MBN_PIN_FORMAT *PinFormat) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PinLengthMin( 
            /* [retval][ref][out] */ __RPC__out ULONG *PinLengthMin) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PinLengthMax( 
            /* [retval][ref][out] */ __RPC__out ULONG *PinLengthMax) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PinMode( 
            /* [retval][ref][out] */ __RPC__out MBN_PIN_MODE *PinMode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Enable( 
            /* [string][ref][in] */ __RPC__in_string LPCWSTR pin,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disable( 
            /* [string][ref][in] */ __RPC__in_string LPCWSTR pin,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Enter( 
            /* [string][ref][in] */ __RPC__in_string LPCWSTR pin,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Change( 
            /* [string][ref][in] */ __RPC__in_string LPCWSTR pin,
            /* [string][ref][in] */ __RPC__in_string LPCWSTR newPin,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Unblock( 
            /* [string][ref][in] */ __RPC__in_string LPCWSTR puk,
            /* [string][ref][in] */ __RPC__in_string LPCWSTR newPin,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPinManager( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IMbnPinManager **pinManager) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnPinVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnPin * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnPin * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnPin * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PinType )( 
            __RPC__in IMbnPin * This,
            /* [retval][ref][out] */ __RPC__out MBN_PIN_TYPE *PinType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PinFormat )( 
            __RPC__in IMbnPin * This,
            /* [retval][ref][out] */ __RPC__out MBN_PIN_FORMAT *PinFormat);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PinLengthMin )( 
            __RPC__in IMbnPin * This,
            /* [retval][ref][out] */ __RPC__out ULONG *PinLengthMin);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PinLengthMax )( 
            __RPC__in IMbnPin * This,
            /* [retval][ref][out] */ __RPC__out ULONG *PinLengthMax);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PinMode )( 
            __RPC__in IMbnPin * This,
            /* [retval][ref][out] */ __RPC__out MBN_PIN_MODE *PinMode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Enable )( 
            __RPC__in IMbnPin * This,
            /* [string][ref][in] */ __RPC__in_string LPCWSTR pin,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disable )( 
            __RPC__in IMbnPin * This,
            /* [string][ref][in] */ __RPC__in_string LPCWSTR pin,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Enter )( 
            __RPC__in IMbnPin * This,
            /* [string][ref][in] */ __RPC__in_string LPCWSTR pin,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Change )( 
            __RPC__in IMbnPin * This,
            /* [string][ref][in] */ __RPC__in_string LPCWSTR pin,
            /* [string][ref][in] */ __RPC__in_string LPCWSTR newPin,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Unblock )( 
            __RPC__in IMbnPin * This,
            /* [string][ref][in] */ __RPC__in_string LPCWSTR puk,
            /* [string][ref][in] */ __RPC__in_string LPCWSTR newPin,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPinManager )( 
            __RPC__in IMbnPin * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IMbnPinManager **pinManager);
        
        END_INTERFACE
    } IMbnPinVtbl;

    interface IMbnPin
    {
        CONST_VTBL struct IMbnPinVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnPin_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnPin_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnPin_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnPin_get_PinType(This,PinType)	\
    ( (This)->lpVtbl -> get_PinType(This,PinType) ) 

#define IMbnPin_get_PinFormat(This,PinFormat)	\
    ( (This)->lpVtbl -> get_PinFormat(This,PinFormat) ) 

#define IMbnPin_get_PinLengthMin(This,PinLengthMin)	\
    ( (This)->lpVtbl -> get_PinLengthMin(This,PinLengthMin) ) 

#define IMbnPin_get_PinLengthMax(This,PinLengthMax)	\
    ( (This)->lpVtbl -> get_PinLengthMax(This,PinLengthMax) ) 

#define IMbnPin_get_PinMode(This,PinMode)	\
    ( (This)->lpVtbl -> get_PinMode(This,PinMode) ) 

#define IMbnPin_Enable(This,pin,requestID)	\
    ( (This)->lpVtbl -> Enable(This,pin,requestID) ) 

#define IMbnPin_Disable(This,pin,requestID)	\
    ( (This)->lpVtbl -> Disable(This,pin,requestID) ) 

#define IMbnPin_Enter(This,pin,requestID)	\
    ( (This)->lpVtbl -> Enter(This,pin,requestID) ) 

#define IMbnPin_Change(This,pin,newPin,requestID)	\
    ( (This)->lpVtbl -> Change(This,pin,newPin,requestID) ) 

#define IMbnPin_Unblock(This,puk,newPin,requestID)	\
    ( (This)->lpVtbl -> Unblock(This,puk,newPin,requestID) ) 

#define IMbnPin_GetPinManager(This,pinManager)	\
    ( (This)->lpVtbl -> GetPinManager(This,pinManager) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnPin_INTERFACE_DEFINED__ */


#ifndef __IMbnPinEvents_INTERFACE_DEFINED__
#define __IMbnPinEvents_INTERFACE_DEFINED__

/* interface IMbnPinEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnPinEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2008-4BBB-AAEE-338E368AF6FA")
    IMbnPinEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnEnableComplete( 
            /* [in] */ __RPC__in_opt IMbnPin *pin,
            /* [ref][in] */ __RPC__in MBN_PIN_INFO *pinInfo,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDisableComplete( 
            /* [in] */ __RPC__in_opt IMbnPin *pin,
            /* [ref][in] */ __RPC__in MBN_PIN_INFO *pinInfo,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnEnterComplete( 
            /* [in] */ __RPC__in_opt IMbnPin *Pin,
            /* [ref][in] */ __RPC__in MBN_PIN_INFO *pinInfo,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnChangeComplete( 
            /* [in] */ __RPC__in_opt IMbnPin *Pin,
            /* [ref][in] */ __RPC__in MBN_PIN_INFO *pinInfo,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnUnblockComplete( 
            /* [in] */ __RPC__in_opt IMbnPin *Pin,
            /* [ref][in] */ __RPC__in MBN_PIN_INFO *pinInfo,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnPinEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnPinEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnPinEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnPinEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnEnableComplete )( 
            __RPC__in IMbnPinEvents * This,
            /* [in] */ __RPC__in_opt IMbnPin *pin,
            /* [ref][in] */ __RPC__in MBN_PIN_INFO *pinInfo,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDisableComplete )( 
            __RPC__in IMbnPinEvents * This,
            /* [in] */ __RPC__in_opt IMbnPin *pin,
            /* [ref][in] */ __RPC__in MBN_PIN_INFO *pinInfo,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnEnterComplete )( 
            __RPC__in IMbnPinEvents * This,
            /* [in] */ __RPC__in_opt IMbnPin *Pin,
            /* [ref][in] */ __RPC__in MBN_PIN_INFO *pinInfo,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnChangeComplete )( 
            __RPC__in IMbnPinEvents * This,
            /* [in] */ __RPC__in_opt IMbnPin *Pin,
            /* [ref][in] */ __RPC__in MBN_PIN_INFO *pinInfo,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnUnblockComplete )( 
            __RPC__in IMbnPinEvents * This,
            /* [in] */ __RPC__in_opt IMbnPin *Pin,
            /* [ref][in] */ __RPC__in MBN_PIN_INFO *pinInfo,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        END_INTERFACE
    } IMbnPinEventsVtbl;

    interface IMbnPinEvents
    {
        CONST_VTBL struct IMbnPinEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnPinEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnPinEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnPinEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnPinEvents_OnEnableComplete(This,pin,pinInfo,requestID,status)	\
    ( (This)->lpVtbl -> OnEnableComplete(This,pin,pinInfo,requestID,status) ) 

#define IMbnPinEvents_OnDisableComplete(This,pin,pinInfo,requestID,status)	\
    ( (This)->lpVtbl -> OnDisableComplete(This,pin,pinInfo,requestID,status) ) 

#define IMbnPinEvents_OnEnterComplete(This,Pin,pinInfo,requestID,status)	\
    ( (This)->lpVtbl -> OnEnterComplete(This,Pin,pinInfo,requestID,status) ) 

#define IMbnPinEvents_OnChangeComplete(This,Pin,pinInfo,requestID,status)	\
    ( (This)->lpVtbl -> OnChangeComplete(This,Pin,pinInfo,requestID,status) ) 

#define IMbnPinEvents_OnUnblockComplete(This,Pin,pinInfo,requestID,status)	\
    ( (This)->lpVtbl -> OnUnblockComplete(This,Pin,pinInfo,requestID,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnPinEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnRegistration_INTERFACE_DEFINED__
#define __IMbnRegistration_INTERFACE_DEFINED__

/* interface IMbnRegistration */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnRegistration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2009-4BBB-AAEE-338E368AF6FA")
    IMbnRegistration : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRegisterState( 
            /* [retval][ref][out] */ __RPC__out MBN_REGISTER_STATE *registerState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRegisterMode( 
            /* [retval][ref][out] */ __RPC__out MBN_REGISTER_MODE *registerMode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProviderID( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *providerID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProviderName( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *providerName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRoamingText( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *roamingText) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAvailableDataClasses( 
            /* [retval][ref][out] */ __RPC__out ULONG *availableDataClasses) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCurrentDataClass( 
            /* [retval][ref][out] */ __RPC__out ULONG *currentDataClass) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetRegistrationNetworkError( 
            /* [retval][ref][out] */ __RPC__out ULONG *registrationNetworkError) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPacketAttachNetworkError( 
            /* [retval][ref][out] */ __RPC__out ULONG *packetAttachNetworkError) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetRegisterMode( 
            /* [in] */ MBN_REGISTER_MODE registerMode,
            /* [string][in] */ __RPC__in_string LPCWSTR providerID,
            /* [in] */ ULONG dataClass,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnRegistrationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnRegistration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnRegistration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnRegistration * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRegisterState )( 
            __RPC__in IMbnRegistration * This,
            /* [retval][ref][out] */ __RPC__out MBN_REGISTER_STATE *registerState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRegisterMode )( 
            __RPC__in IMbnRegistration * This,
            /* [retval][ref][out] */ __RPC__out MBN_REGISTER_MODE *registerMode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetProviderID )( 
            __RPC__in IMbnRegistration * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *providerID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetProviderName )( 
            __RPC__in IMbnRegistration * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *providerName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRoamingText )( 
            __RPC__in IMbnRegistration * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *roamingText);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAvailableDataClasses )( 
            __RPC__in IMbnRegistration * This,
            /* [retval][ref][out] */ __RPC__out ULONG *availableDataClasses);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetCurrentDataClass )( 
            __RPC__in IMbnRegistration * This,
            /* [retval][ref][out] */ __RPC__out ULONG *currentDataClass);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetRegistrationNetworkError )( 
            __RPC__in IMbnRegistration * This,
            /* [retval][ref][out] */ __RPC__out ULONG *registrationNetworkError);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetPacketAttachNetworkError )( 
            __RPC__in IMbnRegistration * This,
            /* [retval][ref][out] */ __RPC__out ULONG *packetAttachNetworkError);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetRegisterMode )( 
            __RPC__in IMbnRegistration * This,
            /* [in] */ MBN_REGISTER_MODE registerMode,
            /* [string][in] */ __RPC__in_string LPCWSTR providerID,
            /* [in] */ ULONG dataClass,
            /* [out] */ __RPC__out ULONG *requestID);
        
        END_INTERFACE
    } IMbnRegistrationVtbl;

    interface IMbnRegistration
    {
        CONST_VTBL struct IMbnRegistrationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnRegistration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnRegistration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnRegistration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnRegistration_GetRegisterState(This,registerState)	\
    ( (This)->lpVtbl -> GetRegisterState(This,registerState) ) 

#define IMbnRegistration_GetRegisterMode(This,registerMode)	\
    ( (This)->lpVtbl -> GetRegisterMode(This,registerMode) ) 

#define IMbnRegistration_GetProviderID(This,providerID)	\
    ( (This)->lpVtbl -> GetProviderID(This,providerID) ) 

#define IMbnRegistration_GetProviderName(This,providerName)	\
    ( (This)->lpVtbl -> GetProviderName(This,providerName) ) 

#define IMbnRegistration_GetRoamingText(This,roamingText)	\
    ( (This)->lpVtbl -> GetRoamingText(This,roamingText) ) 

#define IMbnRegistration_GetAvailableDataClasses(This,availableDataClasses)	\
    ( (This)->lpVtbl -> GetAvailableDataClasses(This,availableDataClasses) ) 

#define IMbnRegistration_GetCurrentDataClass(This,currentDataClass)	\
    ( (This)->lpVtbl -> GetCurrentDataClass(This,currentDataClass) ) 

#define IMbnRegistration_GetRegistrationNetworkError(This,registrationNetworkError)	\
    ( (This)->lpVtbl -> GetRegistrationNetworkError(This,registrationNetworkError) ) 

#define IMbnRegistration_GetPacketAttachNetworkError(This,packetAttachNetworkError)	\
    ( (This)->lpVtbl -> GetPacketAttachNetworkError(This,packetAttachNetworkError) ) 

#define IMbnRegistration_SetRegisterMode(This,registerMode,providerID,dataClass,requestID)	\
    ( (This)->lpVtbl -> SetRegisterMode(This,registerMode,providerID,dataClass,requestID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnRegistration_INTERFACE_DEFINED__ */


#ifndef __IMbnRegistrationEvents_INTERFACE_DEFINED__
#define __IMbnRegistrationEvents_INTERFACE_DEFINED__

/* interface IMbnRegistrationEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnRegistrationEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-200A-4BBB-AAEE-338E368AF6FA")
    IMbnRegistrationEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnRegisterModeAvailable( 
            /* [in] */ __RPC__in_opt IMbnRegistration *newInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnRegisterStateChange( 
            /* [in] */ __RPC__in_opt IMbnRegistration *newInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnPacketServiceStateChange( 
            /* [in] */ __RPC__in_opt IMbnRegistration *newInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSetRegisterModeComplete( 
            /* [in] */ __RPC__in_opt IMbnRegistration *newInterface,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnRegistrationEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnRegistrationEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnRegistrationEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnRegistrationEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnRegisterModeAvailable )( 
            __RPC__in IMbnRegistrationEvents * This,
            /* [in] */ __RPC__in_opt IMbnRegistration *newInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnRegisterStateChange )( 
            __RPC__in IMbnRegistrationEvents * This,
            /* [in] */ __RPC__in_opt IMbnRegistration *newInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnPacketServiceStateChange )( 
            __RPC__in IMbnRegistrationEvents * This,
            /* [in] */ __RPC__in_opt IMbnRegistration *newInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSetRegisterModeComplete )( 
            __RPC__in IMbnRegistrationEvents * This,
            /* [in] */ __RPC__in_opt IMbnRegistration *newInterface,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        END_INTERFACE
    } IMbnRegistrationEventsVtbl;

    interface IMbnRegistrationEvents
    {
        CONST_VTBL struct IMbnRegistrationEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnRegistrationEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnRegistrationEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnRegistrationEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnRegistrationEvents_OnRegisterModeAvailable(This,newInterface)	\
    ( (This)->lpVtbl -> OnRegisterModeAvailable(This,newInterface) ) 

#define IMbnRegistrationEvents_OnRegisterStateChange(This,newInterface)	\
    ( (This)->lpVtbl -> OnRegisterStateChange(This,newInterface) ) 

#define IMbnRegistrationEvents_OnPacketServiceStateChange(This,newInterface)	\
    ( (This)->lpVtbl -> OnPacketServiceStateChange(This,newInterface) ) 

#define IMbnRegistrationEvents_OnSetRegisterModeComplete(This,newInterface,requestID,status)	\
    ( (This)->lpVtbl -> OnSetRegisterModeComplete(This,newInterface,requestID,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnRegistrationEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnConnectionContext_INTERFACE_DEFINED__
#define __IMbnConnectionContext_INTERFACE_DEFINED__

/* interface IMbnConnectionContext */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnConnectionContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-200B-4BBB-AAEE-338E368AF6FA")
    IMbnConnectionContext : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProvisionedContexts( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *provisionedContexts) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetProvisionedContext( 
            /* [in] */ MBN_CONTEXT provisionedContexts,
            /* [in] */ __RPC__in LPCWSTR providerID,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnConnectionContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnConnectionContext * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnConnectionContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnConnectionContext * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetProvisionedContexts )( 
            __RPC__in IMbnConnectionContext * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *provisionedContexts);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetProvisionedContext )( 
            __RPC__in IMbnConnectionContext * This,
            /* [in] */ MBN_CONTEXT provisionedContexts,
            /* [in] */ __RPC__in LPCWSTR providerID,
            /* [out] */ __RPC__out ULONG *requestID);
        
        END_INTERFACE
    } IMbnConnectionContextVtbl;

    interface IMbnConnectionContext
    {
        CONST_VTBL struct IMbnConnectionContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnConnectionContext_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnConnectionContext_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnConnectionContext_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnConnectionContext_GetProvisionedContexts(This,provisionedContexts)	\
    ( (This)->lpVtbl -> GetProvisionedContexts(This,provisionedContexts) ) 

#define IMbnConnectionContext_SetProvisionedContext(This,provisionedContexts,providerID,requestID)	\
    ( (This)->lpVtbl -> SetProvisionedContext(This,provisionedContexts,providerID,requestID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnConnectionContext_INTERFACE_DEFINED__ */


#ifndef __IMbnConnectionContextEvents_INTERFACE_DEFINED__
#define __IMbnConnectionContextEvents_INTERFACE_DEFINED__

/* interface IMbnConnectionContextEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnConnectionContextEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-200C-4BBB-AAEE-338E368AF6FA")
    IMbnConnectionContextEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnProvisionedContextListChange( 
            /* [in] */ __RPC__in_opt IMbnConnectionContext *newInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSetProvisionedContextComplete( 
            /* [in] */ __RPC__in_opt IMbnConnectionContext *newInterface,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnConnectionContextEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnConnectionContextEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnConnectionContextEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnConnectionContextEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnProvisionedContextListChange )( 
            __RPC__in IMbnConnectionContextEvents * This,
            /* [in] */ __RPC__in_opt IMbnConnectionContext *newInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSetProvisionedContextComplete )( 
            __RPC__in IMbnConnectionContextEvents * This,
            /* [in] */ __RPC__in_opt IMbnConnectionContext *newInterface,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        END_INTERFACE
    } IMbnConnectionContextEventsVtbl;

    interface IMbnConnectionContextEvents
    {
        CONST_VTBL struct IMbnConnectionContextEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnConnectionContextEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnConnectionContextEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnConnectionContextEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnConnectionContextEvents_OnProvisionedContextListChange(This,newInterface)	\
    ( (This)->lpVtbl -> OnProvisionedContextListChange(This,newInterface) ) 

#define IMbnConnectionContextEvents_OnSetProvisionedContextComplete(This,newInterface,requestID,status)	\
    ( (This)->lpVtbl -> OnSetProvisionedContextComplete(This,newInterface,requestID,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnConnectionContextEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnConnection_INTERFACE_DEFINED__
#define __IMbnConnection_INTERFACE_DEFINED__

/* interface IMbnConnection */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-200D-4BBB-AAEE-338E368AF6FA")
    IMbnConnection : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConnectionID( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *ConnectionID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InterfaceID( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *InterfaceID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ MBN_CONNECTION_MODE connectionMode,
            /* [string][in] */ __RPC__in_string LPCWSTR strProfile,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectionState( 
            /* [ref][out] */ __RPC__out MBN_ACTIVATION_STATE *ConnectionState,
            /* [ref][out] */ __RPC__deref_out_opt BSTR *ProfileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetVoiceCallState( 
            /* [retval][ref][out] */ __RPC__out MBN_VOICE_CALL_STATE *voiceCallState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetActivationNetworkError( 
            /* [retval][ref][out] */ __RPC__out ULONG *networkError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnConnection * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnConnection * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ConnectionID )( 
            __RPC__in IMbnConnection * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *ConnectionID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InterfaceID )( 
            __RPC__in IMbnConnection * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *InterfaceID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            __RPC__in IMbnConnection * This,
            /* [in] */ MBN_CONNECTION_MODE connectionMode,
            /* [string][in] */ __RPC__in_string LPCWSTR strProfile,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            __RPC__in IMbnConnection * This,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectionState )( 
            __RPC__in IMbnConnection * This,
            /* [ref][out] */ __RPC__out MBN_ACTIVATION_STATE *ConnectionState,
            /* [ref][out] */ __RPC__deref_out_opt BSTR *ProfileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetVoiceCallState )( 
            __RPC__in IMbnConnection * This,
            /* [retval][ref][out] */ __RPC__out MBN_VOICE_CALL_STATE *voiceCallState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetActivationNetworkError )( 
            __RPC__in IMbnConnection * This,
            /* [retval][ref][out] */ __RPC__out ULONG *networkError);
        
        END_INTERFACE
    } IMbnConnectionVtbl;

    interface IMbnConnection
    {
        CONST_VTBL struct IMbnConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnConnection_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnConnection_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnConnection_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnConnection_get_ConnectionID(This,ConnectionID)	\
    ( (This)->lpVtbl -> get_ConnectionID(This,ConnectionID) ) 

#define IMbnConnection_get_InterfaceID(This,InterfaceID)	\
    ( (This)->lpVtbl -> get_InterfaceID(This,InterfaceID) ) 

#define IMbnConnection_Connect(This,connectionMode,strProfile,requestID)	\
    ( (This)->lpVtbl -> Connect(This,connectionMode,strProfile,requestID) ) 

#define IMbnConnection_Disconnect(This,requestID)	\
    ( (This)->lpVtbl -> Disconnect(This,requestID) ) 

#define IMbnConnection_GetConnectionState(This,ConnectionState,ProfileName)	\
    ( (This)->lpVtbl -> GetConnectionState(This,ConnectionState,ProfileName) ) 

#define IMbnConnection_GetVoiceCallState(This,voiceCallState)	\
    ( (This)->lpVtbl -> GetVoiceCallState(This,voiceCallState) ) 

#define IMbnConnection_GetActivationNetworkError(This,networkError)	\
    ( (This)->lpVtbl -> GetActivationNetworkError(This,networkError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnConnection_INTERFACE_DEFINED__ */


#ifndef __IMbnConnectionEvents_INTERFACE_DEFINED__
#define __IMbnConnectionEvents_INTERFACE_DEFINED__

/* interface IMbnConnectionEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnConnectionEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-200E-4BBB-AAEE-338E368AF6FA")
    IMbnConnectionEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnConnectComplete( 
            /* [in] */ __RPC__in_opt IMbnConnection *newConnection,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnDisconnectComplete( 
            /* [in] */ __RPC__in_opt IMbnConnection *newConnection,
            /* [in] */ ULONG reqeustID,
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnConnectStateChange( 
            /* [in] */ __RPC__in_opt IMbnConnection *newConnection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnVoiceCallStateChange( 
            /* [in] */ __RPC__in_opt IMbnConnection *newConnection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnConnectionEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnConnectionEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnConnectionEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnConnectionEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnConnectComplete )( 
            __RPC__in IMbnConnectionEvents * This,
            /* [in] */ __RPC__in_opt IMbnConnection *newConnection,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnDisconnectComplete )( 
            __RPC__in IMbnConnectionEvents * This,
            /* [in] */ __RPC__in_opt IMbnConnection *newConnection,
            /* [in] */ ULONG reqeustID,
            /* [in] */ HRESULT status);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnConnectStateChange )( 
            __RPC__in IMbnConnectionEvents * This,
            /* [in] */ __RPC__in_opt IMbnConnection *newConnection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnVoiceCallStateChange )( 
            __RPC__in IMbnConnectionEvents * This,
            /* [in] */ __RPC__in_opt IMbnConnection *newConnection);
        
        END_INTERFACE
    } IMbnConnectionEventsVtbl;

    interface IMbnConnectionEvents
    {
        CONST_VTBL struct IMbnConnectionEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnConnectionEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnConnectionEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnConnectionEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnConnectionEvents_OnConnectComplete(This,newConnection,requestID,status)	\
    ( (This)->lpVtbl -> OnConnectComplete(This,newConnection,requestID,status) ) 

#define IMbnConnectionEvents_OnDisconnectComplete(This,newConnection,reqeustID,status)	\
    ( (This)->lpVtbl -> OnDisconnectComplete(This,newConnection,reqeustID,status) ) 

#define IMbnConnectionEvents_OnConnectStateChange(This,newConnection)	\
    ( (This)->lpVtbl -> OnConnectStateChange(This,newConnection) ) 

#define IMbnConnectionEvents_OnVoiceCallStateChange(This,newConnection)	\
    ( (This)->lpVtbl -> OnVoiceCallStateChange(This,newConnection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnConnectionEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnConnectionProfileManager_INTERFACE_DEFINED__
#define __IMbnConnectionProfileManager_INTERFACE_DEFINED__

/* interface IMbnConnectionProfileManager */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnConnectionProfileManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-200F-4BBB-AAEE-338E368AF6FA")
    IMbnConnectionProfileManager : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectionProfiles( 
            /* [in] */ __RPC__in_opt IMbnInterface *mbnInterface,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *connectionProfiles) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnectionProfile( 
            /* [in] */ __RPC__in_opt IMbnInterface *mbnInterface,
            /* [string][in] */ __RPC__in_string LPCWSTR profileName,
            /* [retval][ref][out] */ __RPC__deref_out_opt IMbnConnectionProfile **connectionProfile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateConnectionProfile( 
            /* [string][in] */ __RPC__in_string LPCWSTR xmlProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnConnectionProfileManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnConnectionProfileManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnConnectionProfileManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnConnectionProfileManager * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectionProfiles )( 
            __RPC__in IMbnConnectionProfileManager * This,
            /* [in] */ __RPC__in_opt IMbnInterface *mbnInterface,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *connectionProfiles);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnectionProfile )( 
            __RPC__in IMbnConnectionProfileManager * This,
            /* [in] */ __RPC__in_opt IMbnInterface *mbnInterface,
            /* [string][in] */ __RPC__in_string LPCWSTR profileName,
            /* [retval][ref][out] */ __RPC__deref_out_opt IMbnConnectionProfile **connectionProfile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateConnectionProfile )( 
            __RPC__in IMbnConnectionProfileManager * This,
            /* [string][in] */ __RPC__in_string LPCWSTR xmlProfile);
        
        END_INTERFACE
    } IMbnConnectionProfileManagerVtbl;

    interface IMbnConnectionProfileManager
    {
        CONST_VTBL struct IMbnConnectionProfileManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnConnectionProfileManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnConnectionProfileManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnConnectionProfileManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnConnectionProfileManager_GetConnectionProfiles(This,mbnInterface,connectionProfiles)	\
    ( (This)->lpVtbl -> GetConnectionProfiles(This,mbnInterface,connectionProfiles) ) 

#define IMbnConnectionProfileManager_GetConnectionProfile(This,mbnInterface,profileName,connectionProfile)	\
    ( (This)->lpVtbl -> GetConnectionProfile(This,mbnInterface,profileName,connectionProfile) ) 

#define IMbnConnectionProfileManager_CreateConnectionProfile(This,xmlProfile)	\
    ( (This)->lpVtbl -> CreateConnectionProfile(This,xmlProfile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnConnectionProfileManager_INTERFACE_DEFINED__ */


#ifndef __IMbnConnectionProfile_INTERFACE_DEFINED__
#define __IMbnConnectionProfile_INTERFACE_DEFINED__

/* interface IMbnConnectionProfile */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnConnectionProfile;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2010-4BBB-AAEE-338E368AF6FA")
    IMbnConnectionProfile : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetProfileXmlData( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *profileData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateProfile( 
            /* [string][in] */ __RPC__in_string LPCWSTR strProfile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Delete( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnConnectionProfileVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnConnectionProfile * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnConnectionProfile * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnConnectionProfile * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetProfileXmlData )( 
            __RPC__in IMbnConnectionProfile * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *profileData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *UpdateProfile )( 
            __RPC__in IMbnConnectionProfile * This,
            /* [string][in] */ __RPC__in_string LPCWSTR strProfile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Delete )( 
            __RPC__in IMbnConnectionProfile * This);
        
        END_INTERFACE
    } IMbnConnectionProfileVtbl;

    interface IMbnConnectionProfile
    {
        CONST_VTBL struct IMbnConnectionProfileVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnConnectionProfile_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnConnectionProfile_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnConnectionProfile_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnConnectionProfile_GetProfileXmlData(This,profileData)	\
    ( (This)->lpVtbl -> GetProfileXmlData(This,profileData) ) 

#define IMbnConnectionProfile_UpdateProfile(This,strProfile)	\
    ( (This)->lpVtbl -> UpdateProfile(This,strProfile) ) 

#define IMbnConnectionProfile_Delete(This)	\
    ( (This)->lpVtbl -> Delete(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnConnectionProfile_INTERFACE_DEFINED__ */


#ifndef __IMbnConnectionProfileEvents_INTERFACE_DEFINED__
#define __IMbnConnectionProfileEvents_INTERFACE_DEFINED__

/* interface IMbnConnectionProfileEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnConnectionProfileEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2011-4BBB-AAEE-338E368AF6FA")
    IMbnConnectionProfileEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnProfileUpdate( 
            /* [in] */ __RPC__in_opt IMbnConnectionProfile *newProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnConnectionProfileEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnConnectionProfileEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnConnectionProfileEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnConnectionProfileEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnProfileUpdate )( 
            __RPC__in IMbnConnectionProfileEvents * This,
            /* [in] */ __RPC__in_opt IMbnConnectionProfile *newProfile);
        
        END_INTERFACE
    } IMbnConnectionProfileEventsVtbl;

    interface IMbnConnectionProfileEvents
    {
        CONST_VTBL struct IMbnConnectionProfileEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnConnectionProfileEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnConnectionProfileEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnConnectionProfileEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnConnectionProfileEvents_OnProfileUpdate(This,newProfile)	\
    ( (This)->lpVtbl -> OnProfileUpdate(This,newProfile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnConnectionProfileEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnSmsConfiguration_INTERFACE_DEFINED__
#define __IMbnSmsConfiguration_INTERFACE_DEFINED__

/* interface IMbnSmsConfiguration */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnSmsConfiguration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2012-4BBB-AAEE-338E368AF6FA")
    IMbnSmsConfiguration : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServiceCenterAddress( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *scAddress) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_ServiceCenterAddress( 
            /* [in] */ __RPC__in LPCWSTR scAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_MaxMessageIndex( 
            /* [retval][ref][out] */ __RPC__out ULONG *index) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_CdmaShortMsgSize( 
            /* [retval][ref][out] */ __RPC__out ULONG *shortMsgSize) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SmsFormat( 
            /* [retval][ref][out] */ __RPC__out MBN_SMS_FORMAT *smsFormat) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_SmsFormat( 
            /* [in] */ MBN_SMS_FORMAT smsFormat) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnSmsConfigurationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnSmsConfiguration * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnSmsConfiguration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnSmsConfiguration * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServiceCenterAddress )( 
            __RPC__in IMbnSmsConfiguration * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *scAddress);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_ServiceCenterAddress )( 
            __RPC__in IMbnSmsConfiguration * This,
            /* [in] */ __RPC__in LPCWSTR scAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_MaxMessageIndex )( 
            __RPC__in IMbnSmsConfiguration * This,
            /* [retval][ref][out] */ __RPC__out ULONG *index);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_CdmaShortMsgSize )( 
            __RPC__in IMbnSmsConfiguration * This,
            /* [retval][ref][out] */ __RPC__out ULONG *shortMsgSize);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SmsFormat )( 
            __RPC__in IMbnSmsConfiguration * This,
            /* [retval][ref][out] */ __RPC__out MBN_SMS_FORMAT *smsFormat);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_SmsFormat )( 
            __RPC__in IMbnSmsConfiguration * This,
            /* [in] */ MBN_SMS_FORMAT smsFormat);
        
        END_INTERFACE
    } IMbnSmsConfigurationVtbl;

    interface IMbnSmsConfiguration
    {
        CONST_VTBL struct IMbnSmsConfigurationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnSmsConfiguration_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnSmsConfiguration_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnSmsConfiguration_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnSmsConfiguration_get_ServiceCenterAddress(This,scAddress)	\
    ( (This)->lpVtbl -> get_ServiceCenterAddress(This,scAddress) ) 

#define IMbnSmsConfiguration_put_ServiceCenterAddress(This,scAddress)	\
    ( (This)->lpVtbl -> put_ServiceCenterAddress(This,scAddress) ) 

#define IMbnSmsConfiguration_get_MaxMessageIndex(This,index)	\
    ( (This)->lpVtbl -> get_MaxMessageIndex(This,index) ) 

#define IMbnSmsConfiguration_get_CdmaShortMsgSize(This,shortMsgSize)	\
    ( (This)->lpVtbl -> get_CdmaShortMsgSize(This,shortMsgSize) ) 

#define IMbnSmsConfiguration_get_SmsFormat(This,smsFormat)	\
    ( (This)->lpVtbl -> get_SmsFormat(This,smsFormat) ) 

#define IMbnSmsConfiguration_put_SmsFormat(This,smsFormat)	\
    ( (This)->lpVtbl -> put_SmsFormat(This,smsFormat) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnSmsConfiguration_INTERFACE_DEFINED__ */


#ifndef __IMbnSmsReadMsgPdu_INTERFACE_DEFINED__
#define __IMbnSmsReadMsgPdu_INTERFACE_DEFINED__

/* interface IMbnSmsReadMsgPdu */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnSmsReadMsgPdu;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2013-4BBB-AAEE-338E368AF6FA")
    IMbnSmsReadMsgPdu : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][ref][out] */ __RPC__out ULONG *Index) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][ref][out] */ __RPC__out MBN_MSG_STATUS *Status) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_PduData( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *PduData) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Message( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *Message) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnSmsReadMsgPduVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnSmsReadMsgPdu * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnSmsReadMsgPdu * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnSmsReadMsgPdu * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            __RPC__in IMbnSmsReadMsgPdu * This,
            /* [retval][ref][out] */ __RPC__out ULONG *Index);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in IMbnSmsReadMsgPdu * This,
            /* [retval][ref][out] */ __RPC__out MBN_MSG_STATUS *Status);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_PduData )( 
            __RPC__in IMbnSmsReadMsgPdu * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *PduData);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Message )( 
            __RPC__in IMbnSmsReadMsgPdu * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *Message);
        
        END_INTERFACE
    } IMbnSmsReadMsgPduVtbl;

    interface IMbnSmsReadMsgPdu
    {
        CONST_VTBL struct IMbnSmsReadMsgPduVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnSmsReadMsgPdu_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnSmsReadMsgPdu_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnSmsReadMsgPdu_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnSmsReadMsgPdu_get_Index(This,Index)	\
    ( (This)->lpVtbl -> get_Index(This,Index) ) 

#define IMbnSmsReadMsgPdu_get_Status(This,Status)	\
    ( (This)->lpVtbl -> get_Status(This,Status) ) 

#define IMbnSmsReadMsgPdu_get_PduData(This,PduData)	\
    ( (This)->lpVtbl -> get_PduData(This,PduData) ) 

#define IMbnSmsReadMsgPdu_get_Message(This,Message)	\
    ( (This)->lpVtbl -> get_Message(This,Message) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnSmsReadMsgPdu_INTERFACE_DEFINED__ */


#ifndef __IMbnSmsReadMsgTextCdma_INTERFACE_DEFINED__
#define __IMbnSmsReadMsgTextCdma_INTERFACE_DEFINED__

/* interface IMbnSmsReadMsgTextCdma */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnSmsReadMsgTextCdma;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2014-4BBB-AAEE-338E368AF6FA")
    IMbnSmsReadMsgTextCdma : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Index( 
            /* [retval][ref][out] */ __RPC__out ULONG *Index) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][ref][out] */ __RPC__out MBN_MSG_STATUS *Status) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Address( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *Address) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Timestamp( 
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *Timestamp) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_EncodingID( 
            /* [retval][ref][out] */ __RPC__out MBN_SMS_CDMA_ENCODING *EncodingID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LanguageID( 
            /* [retval][ref][out] */ __RPC__out MBN_SMS_CDMA_LANG *LanguageID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SizeInCharacters( 
            /* [retval][ref][out] */ __RPC__out ULONG *SizeInCharacters) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Message( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *Message) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnSmsReadMsgTextCdmaVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnSmsReadMsgTextCdma * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnSmsReadMsgTextCdma * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnSmsReadMsgTextCdma * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Index )( 
            __RPC__in IMbnSmsReadMsgTextCdma * This,
            /* [retval][ref][out] */ __RPC__out ULONG *Index);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Status )( 
            __RPC__in IMbnSmsReadMsgTextCdma * This,
            /* [retval][ref][out] */ __RPC__out MBN_MSG_STATUS *Status);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Address )( 
            __RPC__in IMbnSmsReadMsgTextCdma * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *Address);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Timestamp )( 
            __RPC__in IMbnSmsReadMsgTextCdma * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt BSTR *Timestamp);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_EncodingID )( 
            __RPC__in IMbnSmsReadMsgTextCdma * This,
            /* [retval][ref][out] */ __RPC__out MBN_SMS_CDMA_ENCODING *EncodingID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LanguageID )( 
            __RPC__in IMbnSmsReadMsgTextCdma * This,
            /* [retval][ref][out] */ __RPC__out MBN_SMS_CDMA_LANG *LanguageID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SizeInCharacters )( 
            __RPC__in IMbnSmsReadMsgTextCdma * This,
            /* [retval][ref][out] */ __RPC__out ULONG *SizeInCharacters);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Message )( 
            __RPC__in IMbnSmsReadMsgTextCdma * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *Message);
        
        END_INTERFACE
    } IMbnSmsReadMsgTextCdmaVtbl;

    interface IMbnSmsReadMsgTextCdma
    {
        CONST_VTBL struct IMbnSmsReadMsgTextCdmaVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnSmsReadMsgTextCdma_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnSmsReadMsgTextCdma_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnSmsReadMsgTextCdma_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnSmsReadMsgTextCdma_get_Index(This,Index)	\
    ( (This)->lpVtbl -> get_Index(This,Index) ) 

#define IMbnSmsReadMsgTextCdma_get_Status(This,Status)	\
    ( (This)->lpVtbl -> get_Status(This,Status) ) 

#define IMbnSmsReadMsgTextCdma_get_Address(This,Address)	\
    ( (This)->lpVtbl -> get_Address(This,Address) ) 

#define IMbnSmsReadMsgTextCdma_get_Timestamp(This,Timestamp)	\
    ( (This)->lpVtbl -> get_Timestamp(This,Timestamp) ) 

#define IMbnSmsReadMsgTextCdma_get_EncodingID(This,EncodingID)	\
    ( (This)->lpVtbl -> get_EncodingID(This,EncodingID) ) 

#define IMbnSmsReadMsgTextCdma_get_LanguageID(This,LanguageID)	\
    ( (This)->lpVtbl -> get_LanguageID(This,LanguageID) ) 

#define IMbnSmsReadMsgTextCdma_get_SizeInCharacters(This,SizeInCharacters)	\
    ( (This)->lpVtbl -> get_SizeInCharacters(This,SizeInCharacters) ) 

#define IMbnSmsReadMsgTextCdma_get_Message(This,Message)	\
    ( (This)->lpVtbl -> get_Message(This,Message) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnSmsReadMsgTextCdma_INTERFACE_DEFINED__ */


#ifndef __IMbnSms_INTERFACE_DEFINED__
#define __IMbnSms_INTERFACE_DEFINED__

/* interface IMbnSms */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnSms;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2015-4BBB-AAEE-338E368AF6FA")
    IMbnSms : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSmsConfiguration( 
            /* [retval][ref][out] */ __RPC__deref_out_opt IMbnSmsConfiguration **smsConfiguration) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSmsConfiguration( 
            /* [in] */ __RPC__in_opt IMbnSmsConfiguration *smsConfiguration,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SmsSendPdu( 
            /* [in] */ __RPC__in LPCWSTR pduData,
            /* [in] */ BYTE size,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SmsSendCdma( 
            /* [in] */ __RPC__in LPCWSTR address,
            /* [in] */ MBN_SMS_CDMA_ENCODING encoding,
            /* [in] */ MBN_SMS_CDMA_LANG language,
            /* [in] */ ULONG sizeInCharacters,
            /* [in] */ __RPC__in SAFEARRAY * message,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SmsSendCdmaPdu( 
            /* [in] */ __RPC__in SAFEARRAY * message,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SmsRead( 
            /* [ref][in] */ __RPC__in MBN_SMS_FILTER *smsFilter,
            /* [in] */ MBN_SMS_FORMAT smsFormat,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SmsDelete( 
            /* [ref][in] */ __RPC__in MBN_SMS_FILTER *smsFilter,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSmsStatus( 
            /* [ref][out] */ __RPC__out MBN_SMS_STATUS_INFO *smsStatusInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnSmsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnSms * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnSms * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnSms * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSmsConfiguration )( 
            __RPC__in IMbnSms * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt IMbnSmsConfiguration **smsConfiguration);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSmsConfiguration )( 
            __RPC__in IMbnSms * This,
            /* [in] */ __RPC__in_opt IMbnSmsConfiguration *smsConfiguration,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SmsSendPdu )( 
            __RPC__in IMbnSms * This,
            /* [in] */ __RPC__in LPCWSTR pduData,
            /* [in] */ BYTE size,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SmsSendCdma )( 
            __RPC__in IMbnSms * This,
            /* [in] */ __RPC__in LPCWSTR address,
            /* [in] */ MBN_SMS_CDMA_ENCODING encoding,
            /* [in] */ MBN_SMS_CDMA_LANG language,
            /* [in] */ ULONG sizeInCharacters,
            /* [in] */ __RPC__in SAFEARRAY * message,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SmsSendCdmaPdu )( 
            __RPC__in IMbnSms * This,
            /* [in] */ __RPC__in SAFEARRAY * message,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SmsRead )( 
            __RPC__in IMbnSms * This,
            /* [ref][in] */ __RPC__in MBN_SMS_FILTER *smsFilter,
            /* [in] */ MBN_SMS_FORMAT smsFormat,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SmsDelete )( 
            __RPC__in IMbnSms * This,
            /* [ref][in] */ __RPC__in MBN_SMS_FILTER *smsFilter,
            /* [out] */ __RPC__out ULONG *requestID);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSmsStatus )( 
            __RPC__in IMbnSms * This,
            /* [ref][out] */ __RPC__out MBN_SMS_STATUS_INFO *smsStatusInfo);
        
        END_INTERFACE
    } IMbnSmsVtbl;

    interface IMbnSms
    {
        CONST_VTBL struct IMbnSmsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnSms_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnSms_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnSms_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnSms_GetSmsConfiguration(This,smsConfiguration)	\
    ( (This)->lpVtbl -> GetSmsConfiguration(This,smsConfiguration) ) 

#define IMbnSms_SetSmsConfiguration(This,smsConfiguration,requestID)	\
    ( (This)->lpVtbl -> SetSmsConfiguration(This,smsConfiguration,requestID) ) 

#define IMbnSms_SmsSendPdu(This,pduData,size,requestID)	\
    ( (This)->lpVtbl -> SmsSendPdu(This,pduData,size,requestID) ) 

#define IMbnSms_SmsSendCdma(This,address,encoding,language,sizeInCharacters,message,requestID)	\
    ( (This)->lpVtbl -> SmsSendCdma(This,address,encoding,language,sizeInCharacters,message,requestID) ) 

#define IMbnSms_SmsSendCdmaPdu(This,message,requestID)	\
    ( (This)->lpVtbl -> SmsSendCdmaPdu(This,message,requestID) ) 

#define IMbnSms_SmsRead(This,smsFilter,smsFormat,requestID)	\
    ( (This)->lpVtbl -> SmsRead(This,smsFilter,smsFormat,requestID) ) 

#define IMbnSms_SmsDelete(This,smsFilter,requestID)	\
    ( (This)->lpVtbl -> SmsDelete(This,smsFilter,requestID) ) 

#define IMbnSms_GetSmsStatus(This,smsStatusInfo)	\
    ( (This)->lpVtbl -> GetSmsStatus(This,smsStatusInfo) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnSms_INTERFACE_DEFINED__ */


#ifndef __IMbnSmsEvents_INTERFACE_DEFINED__
#define __IMbnSmsEvents_INTERFACE_DEFINED__

/* interface IMbnSmsEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnSmsEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2016-4BBB-AAEE-338E368AF6FA")
    IMbnSmsEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSmsConfigurationChange( 
            /* [in] */ __RPC__in_opt IMbnSms *sms) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSetSmsConfigurationComplete( 
            /* [in] */ __RPC__in_opt IMbnSms *sms,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSmsSendComplete( 
            /* [in] */ __RPC__in_opt IMbnSms *sms,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSmsReadComplete( 
            /* [in] */ __RPC__in_opt IMbnSms *sms,
            /* [in] */ MBN_SMS_FORMAT smsFormat,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * readMsgs,
            /* [in] */ VARIANT_BOOL moreMsgs,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSmsNewClass0Message( 
            /* [in] */ __RPC__in_opt IMbnSms *sms,
            /* [in] */ MBN_SMS_FORMAT smsFormat,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * readMsgs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSmsDeleteComplete( 
            /* [in] */ __RPC__in_opt IMbnSms *sms,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSmsStatusChange( 
            /* [in] */ __RPC__in_opt IMbnSms *sms) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnSmsEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnSmsEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnSmsEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnSmsEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSmsConfigurationChange )( 
            __RPC__in IMbnSmsEvents * This,
            /* [in] */ __RPC__in_opt IMbnSms *sms);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSetSmsConfigurationComplete )( 
            __RPC__in IMbnSmsEvents * This,
            /* [in] */ __RPC__in_opt IMbnSms *sms,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSmsSendComplete )( 
            __RPC__in IMbnSmsEvents * This,
            /* [in] */ __RPC__in_opt IMbnSms *sms,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSmsReadComplete )( 
            __RPC__in IMbnSmsEvents * This,
            /* [in] */ __RPC__in_opt IMbnSms *sms,
            /* [in] */ MBN_SMS_FORMAT smsFormat,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * readMsgs,
            /* [in] */ VARIANT_BOOL moreMsgs,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSmsNewClass0Message )( 
            __RPC__in IMbnSmsEvents * This,
            /* [in] */ __RPC__in_opt IMbnSms *sms,
            /* [in] */ MBN_SMS_FORMAT smsFormat,
            /* [in] */ __RPC__deref_in_opt SAFEARRAY * readMsgs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSmsDeleteComplete )( 
            __RPC__in IMbnSmsEvents * This,
            /* [in] */ __RPC__in_opt IMbnSms *sms,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSmsStatusChange )( 
            __RPC__in IMbnSmsEvents * This,
            /* [in] */ __RPC__in_opt IMbnSms *sms);
        
        END_INTERFACE
    } IMbnSmsEventsVtbl;

    interface IMbnSmsEvents
    {
        CONST_VTBL struct IMbnSmsEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnSmsEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnSmsEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnSmsEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnSmsEvents_OnSmsConfigurationChange(This,sms)	\
    ( (This)->lpVtbl -> OnSmsConfigurationChange(This,sms) ) 

#define IMbnSmsEvents_OnSetSmsConfigurationComplete(This,sms,requestID,status)	\
    ( (This)->lpVtbl -> OnSetSmsConfigurationComplete(This,sms,requestID,status) ) 

#define IMbnSmsEvents_OnSmsSendComplete(This,sms,requestID,status)	\
    ( (This)->lpVtbl -> OnSmsSendComplete(This,sms,requestID,status) ) 

#define IMbnSmsEvents_OnSmsReadComplete(This,sms,smsFormat,readMsgs,moreMsgs,requestID,status)	\
    ( (This)->lpVtbl -> OnSmsReadComplete(This,sms,smsFormat,readMsgs,moreMsgs,requestID,status) ) 

#define IMbnSmsEvents_OnSmsNewClass0Message(This,sms,smsFormat,readMsgs)	\
    ( (This)->lpVtbl -> OnSmsNewClass0Message(This,sms,smsFormat,readMsgs) ) 

#define IMbnSmsEvents_OnSmsDeleteComplete(This,sms,requestID,status)	\
    ( (This)->lpVtbl -> OnSmsDeleteComplete(This,sms,requestID,status) ) 

#define IMbnSmsEvents_OnSmsStatusChange(This,sms)	\
    ( (This)->lpVtbl -> OnSmsStatusChange(This,sms) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnSmsEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnServiceActivation_INTERFACE_DEFINED__
#define __IMbnServiceActivation_INTERFACE_DEFINED__

/* interface IMbnServiceActivation */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnServiceActivation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2017-4BBB-AAEE-338E368AF6FA")
    IMbnServiceActivation : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ __RPC__in SAFEARRAY * vendorSpecificData,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnServiceActivationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnServiceActivation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnServiceActivation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnServiceActivation * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Activate )( 
            __RPC__in IMbnServiceActivation * This,
            /* [in] */ __RPC__in SAFEARRAY * vendorSpecificData,
            /* [out] */ __RPC__out ULONG *requestID);
        
        END_INTERFACE
    } IMbnServiceActivationVtbl;

    interface IMbnServiceActivation
    {
        CONST_VTBL struct IMbnServiceActivationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnServiceActivation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnServiceActivation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnServiceActivation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnServiceActivation_Activate(This,vendorSpecificData,requestID)	\
    ( (This)->lpVtbl -> Activate(This,vendorSpecificData,requestID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnServiceActivation_INTERFACE_DEFINED__ */


#ifndef __IMbnServiceActivationEvents_INTERFACE_DEFINED__
#define __IMbnServiceActivationEvents_INTERFACE_DEFINED__

/* interface IMbnServiceActivationEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnServiceActivationEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2018-4BBB-AAEE-338E368AF6FA")
    IMbnServiceActivationEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnActivationComplete( 
            /* [in] */ __RPC__in_opt IMbnServiceActivation *serviceActivation,
            /* [in] */ __RPC__in SAFEARRAY * vendorSpecificData,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status,
            /* [in] */ ULONG networkError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnServiceActivationEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnServiceActivationEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnServiceActivationEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnServiceActivationEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnActivationComplete )( 
            __RPC__in IMbnServiceActivationEvents * This,
            /* [in] */ __RPC__in_opt IMbnServiceActivation *serviceActivation,
            /* [in] */ __RPC__in SAFEARRAY * vendorSpecificData,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status,
            /* [in] */ ULONG networkError);
        
        END_INTERFACE
    } IMbnServiceActivationEventsVtbl;

    interface IMbnServiceActivationEvents
    {
        CONST_VTBL struct IMbnServiceActivationEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnServiceActivationEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnServiceActivationEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnServiceActivationEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnServiceActivationEvents_OnActivationComplete(This,serviceActivation,vendorSpecificData,requestID,status,networkError)	\
    ( (This)->lpVtbl -> OnActivationComplete(This,serviceActivation,vendorSpecificData,requestID,status,networkError) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnServiceActivationEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnVendorSpecificOperation_INTERFACE_DEFINED__
#define __IMbnVendorSpecificOperation_INTERFACE_DEFINED__

/* interface IMbnVendorSpecificOperation */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnVendorSpecificOperation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-2019-4BBB-AAEE-338E368AF6FA")
    IMbnVendorSpecificOperation : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetVendorSpecific( 
            /* [ref][in] */ __RPC__in SAFEARRAY * vendorSpecificData,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnVendorSpecificOperationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnVendorSpecificOperation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnVendorSpecificOperation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnVendorSpecificOperation * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetVendorSpecific )( 
            __RPC__in IMbnVendorSpecificOperation * This,
            /* [ref][in] */ __RPC__in SAFEARRAY * vendorSpecificData,
            /* [out] */ __RPC__out ULONG *requestID);
        
        END_INTERFACE
    } IMbnVendorSpecificOperationVtbl;

    interface IMbnVendorSpecificOperation
    {
        CONST_VTBL struct IMbnVendorSpecificOperationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnVendorSpecificOperation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnVendorSpecificOperation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnVendorSpecificOperation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnVendorSpecificOperation_SetVendorSpecific(This,vendorSpecificData,requestID)	\
    ( (This)->lpVtbl -> SetVendorSpecific(This,vendorSpecificData,requestID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnVendorSpecificOperation_INTERFACE_DEFINED__ */


#ifndef __IMbnVendorSpecificEvents_INTERFACE_DEFINED__
#define __IMbnVendorSpecificEvents_INTERFACE_DEFINED__

/* interface IMbnVendorSpecificEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnVendorSpecificEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-201A-4BBB-AAEE-338E368AF6FA")
    IMbnVendorSpecificEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnEventNotification( 
            /* [in] */ __RPC__in_opt IMbnVendorSpecificOperation *vendorOperation,
            /* [in] */ __RPC__in SAFEARRAY * vendorSpecificData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSetVendorSpecificComplete( 
            /* [in] */ __RPC__in_opt IMbnVendorSpecificOperation *vendorOperation,
            /* [in] */ __RPC__in SAFEARRAY * vendorSpecificData,
            /* [in] */ ULONG requestID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnVendorSpecificEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnVendorSpecificEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnVendorSpecificEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnVendorSpecificEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnEventNotification )( 
            __RPC__in IMbnVendorSpecificEvents * This,
            /* [in] */ __RPC__in_opt IMbnVendorSpecificOperation *vendorOperation,
            /* [in] */ __RPC__in SAFEARRAY * vendorSpecificData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSetVendorSpecificComplete )( 
            __RPC__in IMbnVendorSpecificEvents * This,
            /* [in] */ __RPC__in_opt IMbnVendorSpecificOperation *vendorOperation,
            /* [in] */ __RPC__in SAFEARRAY * vendorSpecificData,
            /* [in] */ ULONG requestID);
        
        END_INTERFACE
    } IMbnVendorSpecificEventsVtbl;

    interface IMbnVendorSpecificEvents
    {
        CONST_VTBL struct IMbnVendorSpecificEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnVendorSpecificEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnVendorSpecificEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnVendorSpecificEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnVendorSpecificEvents_OnEventNotification(This,vendorOperation,vendorSpecificData)	\
    ( (This)->lpVtbl -> OnEventNotification(This,vendorOperation,vendorSpecificData) ) 

#define IMbnVendorSpecificEvents_OnSetVendorSpecificComplete(This,vendorOperation,vendorSpecificData,requestID)	\
    ( (This)->lpVtbl -> OnSetVendorSpecificComplete(This,vendorOperation,vendorSpecificData,requestID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnVendorSpecificEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnInterfaceManager_INTERFACE_DEFINED__
#define __IMbnInterfaceManager_INTERFACE_DEFINED__

/* interface IMbnInterfaceManager */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnInterfaceManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-201B-4BBB-AAEE-338E368AF6FA")
    IMbnInterfaceManager : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ __RPC__in LPCWSTR interfaceID,
            /* [retval][ref][out] */ __RPC__deref_out_opt IMbnInterface **mbnInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetInterfaces( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *mbnInterfaces) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnInterfaceManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnInterfaceManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnInterfaceManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnInterfaceManager * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInterface )( 
            __RPC__in IMbnInterfaceManager * This,
            /* [in] */ __RPC__in LPCWSTR interfaceID,
            /* [retval][ref][out] */ __RPC__deref_out_opt IMbnInterface **mbnInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetInterfaces )( 
            __RPC__in IMbnInterfaceManager * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *mbnInterfaces);
        
        END_INTERFACE
    } IMbnInterfaceManagerVtbl;

    interface IMbnInterfaceManager
    {
        CONST_VTBL struct IMbnInterfaceManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnInterfaceManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnInterfaceManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnInterfaceManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnInterfaceManager_GetInterface(This,interfaceID,mbnInterface)	\
    ( (This)->lpVtbl -> GetInterface(This,interfaceID,mbnInterface) ) 

#define IMbnInterfaceManager_GetInterfaces(This,mbnInterfaces)	\
    ( (This)->lpVtbl -> GetInterfaces(This,mbnInterfaces) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnInterfaceManager_INTERFACE_DEFINED__ */


#ifndef __IMbnInterfaceManagerEvents_INTERFACE_DEFINED__
#define __IMbnInterfaceManagerEvents_INTERFACE_DEFINED__

/* interface IMbnInterfaceManagerEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnInterfaceManagerEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-201C-4BBB-AAEE-338E368AF6FA")
    IMbnInterfaceManagerEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnInterfaceArrival( 
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnInterfaceRemoval( 
            /* [in] */ __RPC__in_opt IMbnInterface *oldInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnInterfaceManagerEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnInterfaceManagerEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnInterfaceManagerEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnInterfaceManagerEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnInterfaceArrival )( 
            __RPC__in IMbnInterfaceManagerEvents * This,
            /* [in] */ __RPC__in_opt IMbnInterface *newInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnInterfaceRemoval )( 
            __RPC__in IMbnInterfaceManagerEvents * This,
            /* [in] */ __RPC__in_opt IMbnInterface *oldInterface);
        
        END_INTERFACE
    } IMbnInterfaceManagerEventsVtbl;

    interface IMbnInterfaceManagerEvents
    {
        CONST_VTBL struct IMbnInterfaceManagerEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnInterfaceManagerEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnInterfaceManagerEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnInterfaceManagerEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnInterfaceManagerEvents_OnInterfaceArrival(This,newInterface)	\
    ( (This)->lpVtbl -> OnInterfaceArrival(This,newInterface) ) 

#define IMbnInterfaceManagerEvents_OnInterfaceRemoval(This,oldInterface)	\
    ( (This)->lpVtbl -> OnInterfaceRemoval(This,oldInterface) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnInterfaceManagerEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnConnectionManager_INTERFACE_DEFINED__
#define __IMbnConnectionManager_INTERFACE_DEFINED__

/* interface IMbnConnectionManager */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnConnectionManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-201D-4BBB-AAEE-338E368AF6FA")
    IMbnConnectionManager : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnection( 
            /* [in] */ __RPC__in LPCWSTR connectionID,
            /* [retval][ref][out] */ __RPC__deref_out_opt IMbnConnection **mbnConnection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetConnections( 
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *mbnConnections) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnConnectionManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnConnectionManager * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnConnectionManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnConnectionManager * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            __RPC__in IMbnConnectionManager * This,
            /* [in] */ __RPC__in LPCWSTR connectionID,
            /* [retval][ref][out] */ __RPC__deref_out_opt IMbnConnection **mbnConnection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetConnections )( 
            __RPC__in IMbnConnectionManager * This,
            /* [retval][ref][out] */ __RPC__deref_out_opt SAFEARRAY * *mbnConnections);
        
        END_INTERFACE
    } IMbnConnectionManagerVtbl;

    interface IMbnConnectionManager
    {
        CONST_VTBL struct IMbnConnectionManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnConnectionManager_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnConnectionManager_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnConnectionManager_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnConnectionManager_GetConnection(This,connectionID,mbnConnection)	\
    ( (This)->lpVtbl -> GetConnection(This,connectionID,mbnConnection) ) 

#define IMbnConnectionManager_GetConnections(This,mbnConnections)	\
    ( (This)->lpVtbl -> GetConnections(This,mbnConnections) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnConnectionManager_INTERFACE_DEFINED__ */


#ifndef __IMbnConnectionManagerEvents_INTERFACE_DEFINED__
#define __IMbnConnectionManagerEvents_INTERFACE_DEFINED__

/* interface IMbnConnectionManagerEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnConnectionManagerEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-201E-4BBB-AAEE-338E368AF6FA")
    IMbnConnectionManagerEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnConnectionArrival( 
            /* [in] */ __RPC__in_opt IMbnConnection *newConnection) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnConnectionRemoval( 
            /* [in] */ __RPC__in_opt IMbnConnection *oldConnection) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnConnectionManagerEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnConnectionManagerEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnConnectionManagerEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnConnectionManagerEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnConnectionArrival )( 
            __RPC__in IMbnConnectionManagerEvents * This,
            /* [in] */ __RPC__in_opt IMbnConnection *newConnection);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnConnectionRemoval )( 
            __RPC__in IMbnConnectionManagerEvents * This,
            /* [in] */ __RPC__in_opt IMbnConnection *oldConnection);
        
        END_INTERFACE
    } IMbnConnectionManagerEventsVtbl;

    interface IMbnConnectionManagerEvents
    {
        CONST_VTBL struct IMbnConnectionManagerEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnConnectionManagerEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnConnectionManagerEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnConnectionManagerEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnConnectionManagerEvents_OnConnectionArrival(This,newConnection)	\
    ( (This)->lpVtbl -> OnConnectionArrival(This,newConnection) ) 

#define IMbnConnectionManagerEvents_OnConnectionRemoval(This,oldConnection)	\
    ( (This)->lpVtbl -> OnConnectionRemoval(This,oldConnection) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnConnectionManagerEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnConnectionProfileManagerEvents_INTERFACE_DEFINED__
#define __IMbnConnectionProfileManagerEvents_INTERFACE_DEFINED__

/* interface IMbnConnectionProfileManagerEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnConnectionProfileManagerEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCBBBAB6-201F-4BBB-AAEE-338E368AF6FA")
    IMbnConnectionProfileManagerEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnConnectionProfileArrival( 
            /* [in] */ __RPC__in_opt IMbnConnectionProfile *newConnectionProfile) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnConnectionProfileRemoval( 
            /* [in] */ __RPC__in_opt IMbnConnectionProfile *oldConnectionProfile) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnConnectionProfileManagerEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnConnectionProfileManagerEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnConnectionProfileManagerEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnConnectionProfileManagerEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnConnectionProfileArrival )( 
            __RPC__in IMbnConnectionProfileManagerEvents * This,
            /* [in] */ __RPC__in_opt IMbnConnectionProfile *newConnectionProfile);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnConnectionProfileRemoval )( 
            __RPC__in IMbnConnectionProfileManagerEvents * This,
            /* [in] */ __RPC__in_opt IMbnConnectionProfile *oldConnectionProfile);
        
        END_INTERFACE
    } IMbnConnectionProfileManagerEventsVtbl;

    interface IMbnConnectionProfileManagerEvents
    {
        CONST_VTBL struct IMbnConnectionProfileManagerEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnConnectionProfileManagerEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnConnectionProfileManagerEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnConnectionProfileManagerEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnConnectionProfileManagerEvents_OnConnectionProfileArrival(This,newConnectionProfile)	\
    ( (This)->lpVtbl -> OnConnectionProfileArrival(This,newConnectionProfile) ) 

#define IMbnConnectionProfileManagerEvents_OnConnectionProfileRemoval(This,oldConnectionProfile)	\
    ( (This)->lpVtbl -> OnConnectionProfileRemoval(This,oldConnectionProfile) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnConnectionProfileManagerEvents_INTERFACE_DEFINED__ */


#ifndef __IMbnRadio_INTERFACE_DEFINED__
#define __IMbnRadio_INTERFACE_DEFINED__

/* interface IMbnRadio */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnRadio;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCCCCAB6-201F-4BBB-AAEE-338E368AF6FA")
    IMbnRadio : public IUnknown
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_SoftwareRadioState( 
            /* [retval][ref][out] */ __RPC__out MBN_RADIO *SoftwareRadioState) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HardwareRadioState( 
            /* [retval][ref][out] */ __RPC__out MBN_RADIO *HardwareRadioState) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetSoftwareRadioState( 
            /* [in] */ MBN_RADIO radioState,
            /* [out] */ __RPC__out ULONG *requestID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnRadioVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnRadio * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnRadio * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnRadio * This);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_SoftwareRadioState )( 
            __RPC__in IMbnRadio * This,
            /* [retval][ref][out] */ __RPC__out MBN_RADIO *SoftwareRadioState);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_HardwareRadioState )( 
            __RPC__in IMbnRadio * This,
            /* [retval][ref][out] */ __RPC__out MBN_RADIO *HardwareRadioState);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *SetSoftwareRadioState )( 
            __RPC__in IMbnRadio * This,
            /* [in] */ MBN_RADIO radioState,
            /* [out] */ __RPC__out ULONG *requestID);
        
        END_INTERFACE
    } IMbnRadioVtbl;

    interface IMbnRadio
    {
        CONST_VTBL struct IMbnRadioVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnRadio_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnRadio_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnRadio_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnRadio_get_SoftwareRadioState(This,SoftwareRadioState)	\
    ( (This)->lpVtbl -> get_SoftwareRadioState(This,SoftwareRadioState) ) 

#define IMbnRadio_get_HardwareRadioState(This,HardwareRadioState)	\
    ( (This)->lpVtbl -> get_HardwareRadioState(This,HardwareRadioState) ) 

#define IMbnRadio_SetSoftwareRadioState(This,radioState,requestID)	\
    ( (This)->lpVtbl -> SetSoftwareRadioState(This,radioState,requestID) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnRadio_INTERFACE_DEFINED__ */


#ifndef __IMbnRadioEvents_INTERFACE_DEFINED__
#define __IMbnRadioEvents_INTERFACE_DEFINED__

/* interface IMbnRadioEvents */
/* [helpstring][uuid][oleautomation][nonextensible][object] */ 


EXTERN_C const IID IID_IMbnRadioEvents;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DCDDDAB6-201F-4BBB-AAEE-338E368AF6FA")
    IMbnRadioEvents : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnRadioStateChange( 
            /* [in] */ __RPC__in_opt IMbnRadio *newInterface) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OnSetSoftwareRadioStateComplete( 
            /* [in] */ __RPC__in_opt IMbnRadio *newInterface,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMbnRadioEventsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMbnRadioEvents * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMbnRadioEvents * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMbnRadioEvents * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnRadioStateChange )( 
            __RPC__in IMbnRadioEvents * This,
            /* [in] */ __RPC__in_opt IMbnRadio *newInterface);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *OnSetSoftwareRadioStateComplete )( 
            __RPC__in IMbnRadioEvents * This,
            /* [in] */ __RPC__in_opt IMbnRadio *newInterface,
            /* [in] */ ULONG requestID,
            /* [in] */ HRESULT status);
        
        END_INTERFACE
    } IMbnRadioEventsVtbl;

    interface IMbnRadioEvents
    {
        CONST_VTBL struct IMbnRadioEventsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMbnRadioEvents_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMbnRadioEvents_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMbnRadioEvents_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMbnRadioEvents_OnRadioStateChange(This,newInterface)	\
    ( (This)->lpVtbl -> OnRadioStateChange(This,newInterface) ) 

#define IMbnRadioEvents_OnSetSoftwareRadioStateComplete(This,newInterface,requestID,status)	\
    ( (This)->lpVtbl -> OnSetSoftwareRadioStateComplete(This,newInterface,requestID,status) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMbnRadioEvents_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_MbnConnectionProfileManager;

#ifdef __cplusplus

class DECLSPEC_UUID("BDFEE05A-4418-11DD-90ED-001C257CCFF1")
MbnConnectionProfileManager;
#endif

EXTERN_C const CLSID CLSID_MbnInterfaceManager;

#ifdef __cplusplus

class DECLSPEC_UUID("BDFEE05B-4418-11DD-90ED-001C257CCFF1")
MbnInterfaceManager;
#endif

EXTERN_C const CLSID CLSID_MbnConnectionManager;

#ifdef __cplusplus

class DECLSPEC_UUID("BDFEE05C-4418-11DD-90ED-001C257CCFF1")
MbnConnectionManager;
#endif
#endif /* __MbnApi_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Mdmsg.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993-1999           **/
/**********************************************************************/

/*
    mdmsg.h

    This file is generated by the MC tool from the MDMSG.MC message
    file.


    FILE HISTORY:
        michth      26-Jun-1996 Created.

*/


#ifndef _MDMSG_H_
#define _MDMSG_H_

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+-+-+-+-+---------------------+-------------------------------+
//  |S|R|C|N|r|    Facility         |               Code            |
//  +-+-+-+-+-+---------------------+-------------------------------+
//
//  where
//
//      S - Severity - indicates success/fail
//
//          0 - Success
//          1 - Fail (COERROR)
//
//      R - reserved portion of the facility code, corresponds to NT's
//              second severity bit.
//
//      C - reserved portion of the facility code, corresponds to NT's
//              C field.
//
//      N - reserved portion of the facility code. Used to indicate a
//              mapped NT status value.
//
//      r - reserved portion of the facility code. Reserved for internal
//              use. Used to indicate HRESULT values that are not status
//              values, but are instead message ids for display strings.
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MD_ERROR_NOT_INITIALIZED
//
// MessageText:
//
// MetaData has not been initialized.
//
#define MD_ERROR_NOT_INITIALIZED         0x800CC800L

//
// MessageId: MD_ERROR_DATA_NOT_FOUND
//
// MessageText:
//
// The specified metadata was not found.
//
#define MD_ERROR_DATA_NOT_FOUND          0x800CC801L

//
// MessageId: MD_ERROR_INVALID_VERSION
//
// MessageText:
//
// The version specified in metadata storage was not recognized.
//
#define MD_ERROR_INVALID_VERSION         0x800CC802L

//
// MessageId: MD_WARNING_PATH_NOT_FOUND
//
// MessageText:
//
// A specified metaobject path was not found. The metaobject and associated metadata was ignored.
//
#define MD_WARNING_PATH_NOT_FOUND        0x000CC803L

//
// MessageId: MD_WARNING_DUP_NAME
//
// MessageText:
//
// A metaobject or metadata was specified more than once. The duplicate ignored.
//
#define MD_WARNING_DUP_NAME              0x000CC804L

//
// MessageId: MD_WARNING_INVALID_DATA
//
// MessageText:
//
// Invalid metadata was specified. The invalid metadata was ignored.
//
#define MD_WARNING_INVALID_DATA          0x000CC805L

//
// MessageId: MD_ERROR_SECURE_CHANNEL_FAILURE
//
// MessageText:
//
// A secure communications channel could not be established with the target server.
//
#define MD_ERROR_SECURE_CHANNEL_FAILURE  0x800CC806L

//
// MessageId: MD_WARNING_PATH_NOT_INSERTED
//
// MessageText:
//
// The path was not inserted into the string as requested. The probable cause is that the data is at an object at a higher level than the handle.
//
#define MD_WARNING_PATH_NOT_INSERTED     0x000CC807L

//
// MessageId: MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE
//
// MessageText:
//
// The METADATA_SECURE attribute cannot be removed from a data item via the GetData method. Use the DeleteData method to remove the secure data.
//
#define MD_ERROR_CANNOT_REMOVE_SECURE_ATTRIBUTE 0x800CC808L

//
// MessageId: MD_WARNING_SAVE_FAILED
//
// MessageText:
//
// The metadata save prior to backup failed. The previous version of the data was backed up.
//
#define MD_WARNING_SAVE_FAILED           0x000CC809L

//
// MessageId: MD_ERROR_IISAO_INVALID_SCHEMA
//
// MessageText:
//
// The schema information could not be loaded. A required key or property is missing from the metabase.
//
#define MD_ERROR_IISAO_INVALID_SCHEMA    0x800CC810L

//
// MessageId: MD_ERROR_READ_METABASE_FILE
//
// MessageText:
//
// Unable to read the metabase file.  Look at eventlog for further details.
//
#define MD_ERROR_READ_METABASE_FILE      0x800CC819L

//
// MessageId: MD_ERROR_NO_SESSION_KEY
//
// MessageText:
//
// Could not find session key in IIS_Global section of XML file.
//
#define MD_ERROR_NO_SESSION_KEY          0x800CC81DL


#endif  // _MDMSG_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\mediaerr.h ===
//------------------------------------------------------------------------------
// File: MediaErr.h
//
// Desc: Shell error codes
//
// Copyright (c) 1999 - 2001, Microsoft Corporation.  All rights reserved.
//------------------------------------------------------------------------------


#ifndef _MEDIAERR_H_
#define _MEDIAERR_H_

#define DMO_E_INVALIDSTREAMINDEX 0x80040201
#define DMO_E_INVALIDTYPE        0x80040202
#define DMO_E_TYPE_NOT_SET       0x80040203
#define DMO_E_NOTACCEPTING       0x80040204
#define DMO_E_TYPE_NOT_ACCEPTED  0x80040205
#define DMO_E_NO_MORE_ITEMS      0x80040206

#endif _MEDIAERR_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MDhcp.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0453 */
/* Compiler settings for mdhcp.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mdhcp_h__
#define __mdhcp_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMcastScope_FWD_DEFINED__
#define __IMcastScope_FWD_DEFINED__
typedef interface IMcastScope IMcastScope;
#endif 	/* __IMcastScope_FWD_DEFINED__ */


#ifndef __IMcastLeaseInfo_FWD_DEFINED__
#define __IMcastLeaseInfo_FWD_DEFINED__
typedef interface IMcastLeaseInfo IMcastLeaseInfo;
#endif 	/* __IMcastLeaseInfo_FWD_DEFINED__ */


#ifndef __IEnumMcastScope_FWD_DEFINED__
#define __IEnumMcastScope_FWD_DEFINED__
typedef interface IEnumMcastScope IEnumMcastScope;
#endif 	/* __IEnumMcastScope_FWD_DEFINED__ */


#ifndef __IMcastAddressAllocation_FWD_DEFINED__
#define __IMcastAddressAllocation_FWD_DEFINED__
typedef interface IMcastAddressAllocation IMcastAddressAllocation;
#endif 	/* __IMcastAddressAllocation_FWD_DEFINED__ */


#ifndef __IMcastScope_FWD_DEFINED__
#define __IMcastScope_FWD_DEFINED__
typedef interface IMcastScope IMcastScope;
#endif 	/* __IMcastScope_FWD_DEFINED__ */


#ifndef __IMcastLeaseInfo_FWD_DEFINED__
#define __IMcastLeaseInfo_FWD_DEFINED__
typedef interface IMcastLeaseInfo IMcastLeaseInfo;
#endif 	/* __IMcastLeaseInfo_FWD_DEFINED__ */


#ifndef __IEnumMcastScope_FWD_DEFINED__
#define __IEnumMcastScope_FWD_DEFINED__
typedef interface IEnumMcastScope IEnumMcastScope;
#endif 	/* __IEnumMcastScope_FWD_DEFINED__ */


#ifndef __IMcastAddressAllocation_FWD_DEFINED__
#define __IMcastAddressAllocation_FWD_DEFINED__
typedef interface IMcastAddressAllocation IMcastAddressAllocation;
#endif 	/* __IMcastAddressAllocation_FWD_DEFINED__ */


#ifndef __McastAddressAllocation_FWD_DEFINED__
#define __McastAddressAllocation_FWD_DEFINED__

#ifdef __cplusplus
typedef class McastAddressAllocation McastAddressAllocation;
#else
typedef struct McastAddressAllocation McastAddressAllocation;
#endif /* __cplusplus */

#endif 	/* __McastAddressAllocation_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "tapi3if.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_mdhcp_0000_0000 */
/* [local] */ 

/* Copyright (c) Microsoft Corporation. All rights reserved.*/


extern RPC_IF_HANDLE __MIDL_itf_mdhcp_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mdhcp_0000_0000_v0_0_s_ifspec;

#ifndef __IMcastScope_INTERFACE_DEFINED__
#define __IMcastScope_INTERFACE_DEFINED__

/* interface IMcastScope */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMcastScope;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DF0DAEF4-A289-11D1-8697-006008B0E5D2")
    IMcastScope : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScopeID( 
            /* [retval][out] */ __RPC__out long *pID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerID( 
            /* [retval][out] */ __RPC__out long *pID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_InterfaceID( 
            /* [retval][out] */ __RPC__out long *pID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ScopeDescription( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDescription) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TTL( 
            /* [retval][out] */ __RPC__out long *pTTL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMcastScopeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMcastScope * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMcastScope * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMcastScope * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMcastScope * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMcastScope * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMcastScope * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMcastScope * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScopeID )( 
            IMcastScope * This,
            /* [retval][out] */ __RPC__out long *pID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerID )( 
            IMcastScope * This,
            /* [retval][out] */ __RPC__out long *pID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_InterfaceID )( 
            IMcastScope * This,
            /* [retval][out] */ __RPC__out long *pID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ScopeDescription )( 
            IMcastScope * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDescription);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TTL )( 
            IMcastScope * This,
            /* [retval][out] */ __RPC__out long *pTTL);
        
        END_INTERFACE
    } IMcastScopeVtbl;

    interface IMcastScope
    {
        CONST_VTBL struct IMcastScopeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMcastScope_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMcastScope_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMcastScope_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMcastScope_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMcastScope_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMcastScope_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMcastScope_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMcastScope_get_ScopeID(This,pID)	\
    ( (This)->lpVtbl -> get_ScopeID(This,pID) ) 

#define IMcastScope_get_ServerID(This,pID)	\
    ( (This)->lpVtbl -> get_ServerID(This,pID) ) 

#define IMcastScope_get_InterfaceID(This,pID)	\
    ( (This)->lpVtbl -> get_InterfaceID(This,pID) ) 

#define IMcastScope_get_ScopeDescription(This,ppDescription)	\
    ( (This)->lpVtbl -> get_ScopeDescription(This,ppDescription) ) 

#define IMcastScope_get_TTL(This,pTTL)	\
    ( (This)->lpVtbl -> get_TTL(This,pTTL) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastScope_get_ScopeID_Proxy( 
    IMcastScope * This,
    /* [retval][out] */ __RPC__out long *pID);


void __RPC_STUB IMcastScope_get_ScopeID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastScope_get_ServerID_Proxy( 
    IMcastScope * This,
    /* [retval][out] */ __RPC__out long *pID);


void __RPC_STUB IMcastScope_get_ServerID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastScope_get_InterfaceID_Proxy( 
    IMcastScope * This,
    /* [retval][out] */ __RPC__out long *pID);


void __RPC_STUB IMcastScope_get_InterfaceID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastScope_get_ScopeDescription_Proxy( 
    IMcastScope * This,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *ppDescription);


void __RPC_STUB IMcastScope_get_ScopeDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastScope_get_TTL_Proxy( 
    IMcastScope * This,
    /* [retval][out] */ __RPC__out long *pTTL);


void __RPC_STUB IMcastScope_get_TTL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMcastScope_INTERFACE_DEFINED__ */


#ifndef __IMcastLeaseInfo_INTERFACE_DEFINED__
#define __IMcastLeaseInfo_INTERFACE_DEFINED__

/* interface IMcastLeaseInfo */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMcastLeaseInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DF0DAEFD-A289-11D1-8697-006008B0E5D2")
    IMcastLeaseInfo : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_RequestID( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppRequestID) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LeaseStartTime( 
            /* [retval][out] */ __RPC__out DATE *pTime) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LeaseStartTime( 
            /* [in] */ DATE time) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_LeaseStopTime( 
            /* [retval][out] */ __RPC__out DATE *pTime) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_LeaseStopTime( 
            /* [in] */ DATE time) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_AddressCount( 
            /* [retval][out] */ __RPC__out long *pCount) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ServerAddress( 
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppAddress) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_TTL( 
            /* [retval][out] */ __RPC__out long *pTTL) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Addresses( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateAddresses( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumBstr **ppEnumAddresses) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMcastLeaseInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMcastLeaseInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMcastLeaseInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMcastLeaseInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMcastLeaseInfo * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMcastLeaseInfo * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMcastLeaseInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMcastLeaseInfo * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_RequestID )( 
            IMcastLeaseInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppRequestID);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LeaseStartTime )( 
            IMcastLeaseInfo * This,
            /* [retval][out] */ __RPC__out DATE *pTime);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LeaseStartTime )( 
            IMcastLeaseInfo * This,
            /* [in] */ DATE time);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_LeaseStopTime )( 
            IMcastLeaseInfo * This,
            /* [retval][out] */ __RPC__out DATE *pTime);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_LeaseStopTime )( 
            IMcastLeaseInfo * This,
            /* [in] */ DATE time);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_AddressCount )( 
            IMcastLeaseInfo * This,
            /* [retval][out] */ __RPC__out long *pCount);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ServerAddress )( 
            IMcastLeaseInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt BSTR *ppAddress);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_TTL )( 
            IMcastLeaseInfo * This,
            /* [retval][out] */ __RPC__out long *pTTL);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Addresses )( 
            IMcastLeaseInfo * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateAddresses )( 
            IMcastLeaseInfo * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumBstr **ppEnumAddresses);
        
        END_INTERFACE
    } IMcastLeaseInfoVtbl;

    interface IMcastLeaseInfo
    {
        CONST_VTBL struct IMcastLeaseInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMcastLeaseInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMcastLeaseInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMcastLeaseInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMcastLeaseInfo_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMcastLeaseInfo_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMcastLeaseInfo_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMcastLeaseInfo_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMcastLeaseInfo_get_RequestID(This,ppRequestID)	\
    ( (This)->lpVtbl -> get_RequestID(This,ppRequestID) ) 

#define IMcastLeaseInfo_get_LeaseStartTime(This,pTime)	\
    ( (This)->lpVtbl -> get_LeaseStartTime(This,pTime) ) 

#define IMcastLeaseInfo_put_LeaseStartTime(This,time)	\
    ( (This)->lpVtbl -> put_LeaseStartTime(This,time) ) 

#define IMcastLeaseInfo_get_LeaseStopTime(This,pTime)	\
    ( (This)->lpVtbl -> get_LeaseStopTime(This,pTime) ) 

#define IMcastLeaseInfo_put_LeaseStopTime(This,time)	\
    ( (This)->lpVtbl -> put_LeaseStopTime(This,time) ) 

#define IMcastLeaseInfo_get_AddressCount(This,pCount)	\
    ( (This)->lpVtbl -> get_AddressCount(This,pCount) ) 

#define IMcastLeaseInfo_get_ServerAddress(This,ppAddress)	\
    ( (This)->lpVtbl -> get_ServerAddress(This,ppAddress) ) 

#define IMcastLeaseInfo_get_TTL(This,pTTL)	\
    ( (This)->lpVtbl -> get_TTL(This,pTTL) ) 

#define IMcastLeaseInfo_get_Addresses(This,pVariant)	\
    ( (This)->lpVtbl -> get_Addresses(This,pVariant) ) 

#define IMcastLeaseInfo_EnumerateAddresses(This,ppEnumAddresses)	\
    ( (This)->lpVtbl -> EnumerateAddresses(This,ppEnumAddresses) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastLeaseInfo_get_RequestID_Proxy( 
    IMcastLeaseInfo * This,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *ppRequestID);


void __RPC_STUB IMcastLeaseInfo_get_RequestID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastLeaseInfo_get_LeaseStartTime_Proxy( 
    IMcastLeaseInfo * This,
    /* [retval][out] */ __RPC__out DATE *pTime);


void __RPC_STUB IMcastLeaseInfo_get_LeaseStartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMcastLeaseInfo_put_LeaseStartTime_Proxy( 
    IMcastLeaseInfo * This,
    /* [in] */ DATE time);


void __RPC_STUB IMcastLeaseInfo_put_LeaseStartTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastLeaseInfo_get_LeaseStopTime_Proxy( 
    IMcastLeaseInfo * This,
    /* [retval][out] */ __RPC__out DATE *pTime);


void __RPC_STUB IMcastLeaseInfo_get_LeaseStopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IMcastLeaseInfo_put_LeaseStopTime_Proxy( 
    IMcastLeaseInfo * This,
    /* [in] */ DATE time);


void __RPC_STUB IMcastLeaseInfo_put_LeaseStopTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastLeaseInfo_get_AddressCount_Proxy( 
    IMcastLeaseInfo * This,
    /* [retval][out] */ __RPC__out long *pCount);


void __RPC_STUB IMcastLeaseInfo_get_AddressCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastLeaseInfo_get_ServerAddress_Proxy( 
    IMcastLeaseInfo * This,
    /* [retval][out] */ __RPC__deref_out_opt BSTR *ppAddress);


void __RPC_STUB IMcastLeaseInfo_get_ServerAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastLeaseInfo_get_TTL_Proxy( 
    IMcastLeaseInfo * This,
    /* [retval][out] */ __RPC__out long *pTTL);


void __RPC_STUB IMcastLeaseInfo_get_TTL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastLeaseInfo_get_Addresses_Proxy( 
    IMcastLeaseInfo * This,
    /* [retval][out] */ __RPC__out VARIANT *pVariant);


void __RPC_STUB IMcastLeaseInfo_get_Addresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE IMcastLeaseInfo_EnumerateAddresses_Proxy( 
    IMcastLeaseInfo * This,
    /* [retval][out] */ __RPC__deref_out_opt IEnumBstr **ppEnumAddresses);


void __RPC_STUB IMcastLeaseInfo_EnumerateAddresses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMcastLeaseInfo_INTERFACE_DEFINED__ */


#ifndef __IEnumMcastScope_INTERFACE_DEFINED__
#define __IEnumMcastScope_INTERFACE_DEFINED__

/* interface IEnumMcastScope */
/* [unique][helpstring][hidden][uuid][object] */ 


EXTERN_C const IID IID_IEnumMcastScope;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DF0DAF09-A289-11D1-8697-006008B0E5D2")
    IEnumMcastScope : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt IMcastScope **ppScopes,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ __RPC__deref_out_opt IEnumMcastScope **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMcastScopeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumMcastScope * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumMcastScope * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumMcastScope * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumMcastScope * This,
            /* [in] */ ULONG celt,
            /* [out] */ __RPC__deref_out_opt IMcastScope **ppScopes,
            /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumMcastScope * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumMcastScope * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumMcastScope * This,
            /* [retval][out] */ __RPC__deref_out_opt IEnumMcastScope **ppEnum);
        
        END_INTERFACE
    } IEnumMcastScopeVtbl;

    interface IEnumMcastScope
    {
        CONST_VTBL struct IEnumMcastScopeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMcastScope_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumMcastScope_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumMcastScope_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumMcastScope_Next(This,celt,ppScopes,pceltFetched)	\
    ( (This)->lpVtbl -> Next(This,celt,ppScopes,pceltFetched) ) 

#define IEnumMcastScope_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumMcastScope_Skip(This,celt)	\
    ( (This)->lpVtbl -> Skip(This,celt) ) 

#define IEnumMcastScope_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumMcastScope_Next_Proxy( 
    IEnumMcastScope * This,
    /* [in] */ ULONG celt,
    /* [out] */ __RPC__deref_out_opt IMcastScope **ppScopes,
    /* [full][out][in] */ __RPC__inout_opt ULONG *pceltFetched);


void __RPC_STUB IEnumMcastScope_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMcastScope_Reset_Proxy( 
    IEnumMcastScope * This);


void __RPC_STUB IEnumMcastScope_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMcastScope_Skip_Proxy( 
    IEnumMcastScope * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumMcastScope_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMcastScope_Clone_Proxy( 
    IEnumMcastScope * This,
    /* [retval][out] */ __RPC__deref_out_opt IEnumMcastScope **ppEnum);


void __RPC_STUB IEnumMcastScope_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumMcastScope_INTERFACE_DEFINED__ */


#ifndef __IMcastAddressAllocation_INTERFACE_DEFINED__
#define __IMcastAddressAllocation_INTERFACE_DEFINED__

/* interface IMcastAddressAllocation */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMcastAddressAllocation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("DF0DAEF1-A289-11D1-8697-006008B0E5D2")
    IMcastAddressAllocation : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Scopes( 
            /* [retval][out] */ __RPC__out VARIANT *pVariant) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE EnumerateScopes( 
            /* [out] */ __RPC__deref_out_opt IEnumMcastScope **ppEnumMcastScope) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RequestAddress( 
            /* [in] */ __RPC__in IMcastScope *pScope,
            /* [in] */ DATE LeaseStartTime,
            /* [in] */ DATE LeaseStopTime,
            /* [in] */ long NumAddresses,
            /* [retval][out] */ __RPC__deref_out_opt IMcastLeaseInfo **ppLeaseResponse) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RenewAddress( 
            /* [in] */ long lReserved,
            /* [in] */ __RPC__in IMcastLeaseInfo *pRenewRequest,
            /* [retval][out] */ __RPC__deref_out_opt IMcastLeaseInfo **ppRenewResponse) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseAddress( 
            /* [in] */ __RPC__in IMcastLeaseInfo *pReleaseRequest) = 0;
        
        virtual /* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE CreateLeaseInfo( 
            /* [in] */ DATE LeaseStartTime,
            /* [in] */ DATE LeaseStopTime,
            /* [in] */ DWORD dwNumAddresses,
            /* [in] */ __RPC__deref_in_opt LPWSTR *ppAddresses,
            /* [in] */ __RPC__in LPWSTR pRequestID,
            /* [in] */ __RPC__in LPWSTR pServerAddress,
            /* [retval][out] */ __RPC__deref_out_opt IMcastLeaseInfo **ppReleaseRequest) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateLeaseInfoFromVariant( 
            /* [in] */ DATE LeaseStartTime,
            /* [in] */ DATE LeaseStopTime,
            /* [in] */ VARIANT vAddresses,
            /* [in] */ __RPC__in BSTR pRequestID,
            /* [in] */ __RPC__in BSTR pServerAddress,
            /* [retval][out] */ __RPC__deref_out_opt IMcastLeaseInfo **ppReleaseRequest) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMcastAddressAllocationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMcastAddressAllocation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [iid_is][out] */ __RPC__deref_out_opt void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMcastAddressAllocation * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMcastAddressAllocation * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IMcastAddressAllocation * This,
            /* [out] */ __RPC__out UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IMcastAddressAllocation * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ __RPC__deref_out_opt ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IMcastAddressAllocation * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [size_is][in] */ __RPC__in_ecount_full(cNames) LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ __RPC__out_ecount_full(cNames) DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IMcastAddressAllocation * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Scopes )( 
            IMcastAddressAllocation * This,
            /* [retval][out] */ __RPC__out VARIANT *pVariant);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *EnumerateScopes )( 
            IMcastAddressAllocation * This,
            /* [out] */ __RPC__deref_out_opt IEnumMcastScope **ppEnumMcastScope);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RequestAddress )( 
            IMcastAddressAllocation * This,
            /* [in] */ __RPC__in IMcastScope *pScope,
            /* [in] */ DATE LeaseStartTime,
            /* [in] */ DATE LeaseStopTime,
            /* [in] */ long NumAddresses,
            /* [retval][out] */ __RPC__deref_out_opt IMcastLeaseInfo **ppLeaseResponse);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *RenewAddress )( 
            IMcastAddressAllocation * This,
            /* [in] */ long lReserved,
            /* [in] */ __RPC__in IMcastLeaseInfo *pRenewRequest,
            /* [retval][out] */ __RPC__deref_out_opt IMcastLeaseInfo **ppRenewResponse);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReleaseAddress )( 
            IMcastAddressAllocation * This,
            /* [in] */ __RPC__in IMcastLeaseInfo *pReleaseRequest);
        
        /* [helpstring][hidden][id] */ HRESULT ( STDMETHODCALLTYPE *CreateLeaseInfo )( 
            IMcastAddressAllocation * This,
            /* [in] */ DATE LeaseStartTime,
            /* [in] */ DATE LeaseStopTime,
            /* [in] */ DWORD dwNumAddresses,
            /* [in] */ __RPC__deref_in_opt LPWSTR *ppAddresses,
            /* [in] */ __RPC__in LPWSTR pRequestID,
            /* [in] */ __RPC__in LPWSTR pServerAddress,
            /* [retval][out] */ __RPC__deref_out_opt IMcastLeaseInfo **ppReleaseRequest);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *CreateLeaseInfoFromVariant )( 
            IMcastAddressAllocation * This,
            /* [in] */ DATE LeaseStartTime,
            /* [in] */ DATE LeaseStopTime,
            /* [in] */ VARIANT vAddresses,
            /* [in] */ __RPC__in BSTR pRequestID,
            /* [in] */ __RPC__in BSTR pServerAddress,
            /* [retval][out] */ __RPC__deref_out_opt IMcastLeaseInfo **ppReleaseRequest);
        
        END_INTERFACE
    } IMcastAddressAllocationVtbl;

    interface IMcastAddressAllocation
    {
        CONST_VTBL struct IMcastAddressAllocationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMcastAddressAllocation_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMcastAddressAllocation_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMcastAddressAllocation_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMcastAddressAllocation_GetTypeInfoCount(This,pctinfo)	\
    ( (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo) ) 

#define IMcastAddressAllocation_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    ( (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo) ) 

#define IMcastAddressAllocation_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    ( (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId) ) 

#define IMcastAddressAllocation_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    ( (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr) ) 


#define IMcastAddressAllocation_get_Scopes(This,pVariant)	\
    ( (This)->lpVtbl -> get_Scopes(This,pVariant) ) 

#define IMcastAddressAllocation_EnumerateScopes(This,ppEnumMcastScope)	\
    ( (This)->lpVtbl -> EnumerateScopes(This,ppEnumMcastScope) ) 

#define IMcastAddressAllocation_RequestAddress(This,pScope,LeaseStartTime,LeaseStopTime,NumAddresses,ppLeaseResponse)	\
    ( (This)->lpVtbl -> RequestAddress(This,pScope,LeaseStartTime,LeaseStopTime,NumAddresses,ppLeaseResponse) ) 

#define IMcastAddressAllocation_RenewAddress(This,lReserved,pRenewRequest,ppRenewResponse)	\
    ( (This)->lpVtbl -> RenewAddress(This,lReserved,pRenewRequest,ppRenewResponse) ) 

#define IMcastAddressAllocation_ReleaseAddress(This,pReleaseRequest)	\
    ( (This)->lpVtbl -> ReleaseAddress(This,pReleaseRequest) ) 

#define IMcastAddressAllocation_CreateLeaseInfo(This,LeaseStartTime,LeaseStopTime,dwNumAddresses,ppAddresses,pRequestID,pServerAddress,ppReleaseRequest)	\
    ( (This)->lpVtbl -> CreateLeaseInfo(This,LeaseStartTime,LeaseStopTime,dwNumAddresses,ppAddresses,pRequestID,pServerAddress,ppReleaseRequest) ) 

#define IMcastAddressAllocation_CreateLeaseInfoFromVariant(This,LeaseStartTime,LeaseStopTime,vAddresses,pRequestID,pServerAddress,ppReleaseRequest)	\
    ( (This)->lpVtbl -> CreateLeaseInfoFromVariant(This,LeaseStartTime,LeaseStopTime,vAddresses,pRequestID,pServerAddress,ppReleaseRequest) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMcastAddressAllocation_get_Scopes_Proxy( 
    IMcastAddressAllocation * This,
    /* [retval][out] */ __RPC__out VARIANT *pVariant);


void __RPC_STUB IMcastAddressAllocation_get_Scopes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE IMcastAddressAllocation_EnumerateScopes_Proxy( 
    IMcastAddressAllocation * This,
    /* [out] */ __RPC__deref_out_opt IEnumMcastScope **ppEnumMcastScope);


void __RPC_STUB IMcastAddressAllocation_EnumerateScopes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMcastAddressAllocation_RequestAddress_Proxy( 
    IMcastAddressAllocation * This,
    /* [in] */ __RPC__in IMcastScope *pScope,
    /* [in] */ DATE LeaseStartTime,
    /* [in] */ DATE LeaseStopTime,
    /* [in] */ long NumAddresses,
    /* [retval][out] */ __RPC__deref_out_opt IMcastLeaseInfo **ppLeaseResponse);


void __RPC_STUB IMcastAddressAllocation_RequestAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMcastAddressAllocation_RenewAddress_Proxy( 
    IMcastAddressAllocation * This,
    /* [in] */ long lReserved,
    /* [in] */ __RPC__in IMcastLeaseInfo *pRenewRequest,
    /* [retval][out] */ __RPC__deref_out_opt IMcastLeaseInfo **ppRenewResponse);


void __RPC_STUB IMcastAddressAllocation_RenewAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMcastAddressAllocation_ReleaseAddress_Proxy( 
    IMcastAddressAllocation * This,
    /* [in] */ __RPC__in IMcastLeaseInfo *pReleaseRequest);


void __RPC_STUB IMcastAddressAllocation_ReleaseAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][hidden][id] */ HRESULT STDMETHODCALLTYPE IMcastAddressAllocation_CreateLeaseInfo_Proxy( 
    IMcastAddressAllocation * This,
    /* [in] */ DATE LeaseStartTime,
    /* [in] */ DATE LeaseStopTime,
    /* [in] */ DWORD dwNumAddresses,
    /* [in] */ __RPC__deref_in_opt LPWSTR *ppAddresses,
    /* [in] */ __RPC__in LPWSTR pRequestID,
    /* [in] */ __RPC__in LPWSTR pServerAddress,
    /* [retval][out] */ __RPC__deref_out_opt IMcastLeaseInfo **ppReleaseRequest);


void __RPC_STUB IMcastAddressAllocation_CreateLeaseInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMcastAddressAllocation_CreateLeaseInfoFromVariant_Proxy( 
    IMcastAddressAllocation * This,
    /* [in] */ DATE LeaseStartTime,
    /* [in] */ DATE LeaseStopTime,
    /* [in] */ VARIANT vAddresses,
    /* [in] */ __RPC__in BSTR pRequestID,
    /* [in] */ __RPC__in BSTR pServerAddress,
    /* [retval][out] */ __RPC__deref_out_opt IMcastLeaseInfo **ppReleaseRequest);


void __RPC_STUB IMcastAddressAllocation_CreateLeaseInfoFromVariant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMcastAddressAllocation_INTERFACE_DEFINED__ */



#ifndef __McastLib_LIBRARY_DEFINED__
#define __McastLib_LIBRARY_DEFINED__

/* library McastLib */
/* [helpstring][version][uuid] */ 







EXTERN_C const IID LIBID_McastLib;

EXTERN_C const CLSID CLSID_McastAddressAllocation;

#ifdef __cplusplus

class DECLSPEC_UUID("DF0DAEF2-A289-11D1-8697-006008B0E5D2")
McastAddressAllocation;
#endif
#endif /* __McastLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\medparam.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for medparam.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __medparam_h__
#define __medparam_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMediaParamInfo_FWD_DEFINED__
#define __IMediaParamInfo_FWD_DEFINED__
typedef interface IMediaParamInfo IMediaParamInfo;
#endif 	/* __IMediaParamInfo_FWD_DEFINED__ */


#ifndef __IMediaParams_FWD_DEFINED__
#define __IMediaParams_FWD_DEFINED__
typedef interface IMediaParams IMediaParams;
#endif 	/* __IMediaParams_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
#include "strmif.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_medparam_0000_0000 */
/* [local] */ 

typedef float MP_DATA;

typedef 
enum _MP_Type
    {	MPT_INT	= 0,
	MPT_FLOAT	= ( MPT_INT + 1 ) ,
	MPT_BOOL	= ( MPT_FLOAT + 1 ) ,
	MPT_ENUM	= ( MPT_BOOL + 1 ) ,
	MPT_MAX	= ( MPT_ENUM + 1 ) 
    } 	MP_TYPE;

#define	MPBOOL_TRUE	( 1 )

#define	MPBOOL_FALSE	( 0 )

typedef 
enum _MP_CURVE_TYPE
    {	MP_CURVE_JUMP	= 0x1,
	MP_CURVE_LINEAR	= 0x2,
	MP_CURVE_SQUARE	= 0x4,
	MP_CURVE_INVSQUARE	= 0x8,
	MP_CURVE_SINE	= 0x10
    } 	MP_CURVE_TYPE;

typedef DWORD MP_CAPS;

#define	MP_CAPS_CURVE_JUMP	( MP_CURVE_JUMP )

#define	MP_CAPS_CURVE_LINEAR	( MP_CURVE_LINEAR )

#define	MP_CAPS_CURVE_SQUARE	( MP_CURVE_SQUARE )

#define	MP_CAPS_CURVE_INVSQUARE	( MP_CURVE_INVSQUARE )

#define	MP_CAPS_CURVE_SINE	( MP_CURVE_SINE )

typedef struct _MP_PARAMINFO
    {
    MP_TYPE mpType;
    MP_CAPS mopCaps;
    MP_DATA mpdMinValue;
    MP_DATA mpdMaxValue;
    MP_DATA mpdNeutralValue;
    WCHAR szUnitText[ 32 ];
    WCHAR szLabel[ 32 ];
    } 	MP_PARAMINFO;

typedef DWORD DWORD;

#define	DWORD_ALLPARAMS	( -1 )

typedef DWORD MP_TIMEDATA;

DEFINE_GUID(GUID_TIME_REFERENCE,
0x93ad712b, 0xdaa0, 0x4ffe, 0xbc, 0x81, 0xb0, 0xce, 0x50, 0xf, 0xcd, 0xd9);
DEFINE_GUID(GUID_TIME_MUSIC,
0x574c49d, 0x5b04, 0x4b15, 0xa5, 0x42, 0xae, 0x28, 0x20, 0x30, 0x11, 0x7b);
DEFINE_GUID(GUID_TIME_SAMPLES,
0xa8593d05, 0xc43, 0x4984, 0x9a, 0x63, 0x97, 0xaf, 0x9e, 0x2, 0xc4, 0xc0);
typedef DWORD MP_FLAGS;

#define	MPF_ENVLP_STANDARD	( 0 )

#define	MPF_ENVLP_BEGIN_CURRENTVAL	( 0x1 )

#define	MPF_ENVLP_BEGIN_NEUTRALVAL	( 0x2 )

typedef struct _MP_ENVELOPE_SEGMENT
    {
    REFERENCE_TIME rtStart;
    REFERENCE_TIME rtEnd;
    MP_DATA valStart;
    MP_DATA valEnd;
    MP_CURVE_TYPE iCurve;
    MP_FLAGS flags;
    } 	MP_ENVELOPE_SEGMENT;

#define	MPF_PUNCHIN_REFTIME	( 0 )

#define	MPF_PUNCHIN_NOW	( 0x1 )

#define	MPF_PUNCHIN_STOPPED	( 0x2 )



extern RPC_IF_HANDLE __MIDL_itf_medparam_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_medparam_0000_0000_v0_0_s_ifspec;

#ifndef __IMediaParamInfo_INTERFACE_DEFINED__
#define __IMediaParamInfo_INTERFACE_DEFINED__

/* interface IMediaParamInfo */
/* [version][uuid][object] */ 


EXTERN_C const IID IID_IMediaParamInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d6cbb60-a223-44aa-842f-a2f06750be6d")
    IMediaParamInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetParamCount( 
            /* [out] */ __RPC__out DWORD *pdwParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParamInfo( 
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ __RPC__out MP_PARAMINFO *pInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParamText( 
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ __RPC__deref_out_opt WCHAR **ppwchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNumTimeFormats( 
            /* [out] */ __RPC__out DWORD *pdwNumTimeFormats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSupportedTimeFormat( 
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ __RPC__out GUID *pguidTimeFormat) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentTimeFormat( 
            /* [out] */ __RPC__out GUID *pguidTimeFormat,
            /* [out] */ __RPC__out MP_TIMEDATA *pTimeData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaParamInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMediaParamInfo * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMediaParamInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMediaParamInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetParamCount )( 
            __RPC__in IMediaParamInfo * This,
            /* [out] */ __RPC__out DWORD *pdwParams);
        
        HRESULT ( STDMETHODCALLTYPE *GetParamInfo )( 
            __RPC__in IMediaParamInfo * This,
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ __RPC__out MP_PARAMINFO *pInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetParamText )( 
            __RPC__in IMediaParamInfo * This,
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ __RPC__deref_out_opt WCHAR **ppwchText);
        
        HRESULT ( STDMETHODCALLTYPE *GetNumTimeFormats )( 
            __RPC__in IMediaParamInfo * This,
            /* [out] */ __RPC__out DWORD *pdwNumTimeFormats);
        
        HRESULT ( STDMETHODCALLTYPE *GetSupportedTimeFormat )( 
            __RPC__in IMediaParamInfo * This,
            /* [in] */ DWORD dwFormatIndex,
            /* [out] */ __RPC__out GUID *pguidTimeFormat);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentTimeFormat )( 
            __RPC__in IMediaParamInfo * This,
            /* [out] */ __RPC__out GUID *pguidTimeFormat,
            /* [out] */ __RPC__out MP_TIMEDATA *pTimeData);
        
        END_INTERFACE
    } IMediaParamInfoVtbl;

    interface IMediaParamInfo
    {
        CONST_VTBL struct IMediaParamInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaParamInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaParamInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaParamInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaParamInfo_GetParamCount(This,pdwParams)	\
    ( (This)->lpVtbl -> GetParamCount(This,pdwParams) ) 

#define IMediaParamInfo_GetParamInfo(This,dwParamIndex,pInfo)	\
    ( (This)->lpVtbl -> GetParamInfo(This,dwParamIndex,pInfo) ) 

#define IMediaParamInfo_GetParamText(This,dwParamIndex,ppwchText)	\
    ( (This)->lpVtbl -> GetParamText(This,dwParamIndex,ppwchText) ) 

#define IMediaParamInfo_GetNumTimeFormats(This,pdwNumTimeFormats)	\
    ( (This)->lpVtbl -> GetNumTimeFormats(This,pdwNumTimeFormats) ) 

#define IMediaParamInfo_GetSupportedTimeFormat(This,dwFormatIndex,pguidTimeFormat)	\
    ( (This)->lpVtbl -> GetSupportedTimeFormat(This,dwFormatIndex,pguidTimeFormat) ) 

#define IMediaParamInfo_GetCurrentTimeFormat(This,pguidTimeFormat,pTimeData)	\
    ( (This)->lpVtbl -> GetCurrentTimeFormat(This,pguidTimeFormat,pTimeData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaParamInfo_INTERFACE_DEFINED__ */


#ifndef __IMediaParams_INTERFACE_DEFINED__
#define __IMediaParams_INTERFACE_DEFINED__

/* interface IMediaParams */
/* [version][uuid][object] */ 


EXTERN_C const IID IID_IMediaParams;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d6cbb61-a223-44aa-842f-a2f06750be6e")
    IMediaParams : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetParam( 
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ __RPC__out MP_DATA *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetParam( 
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ MP_DATA value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddEnvelope( 
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ DWORD cSegments,
            /* [in] */ __RPC__in MP_ENVELOPE_SEGMENT *pEnvelopeSegments) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushEnvelope( 
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ REFERENCE_TIME refTimeStart,
            /* [in] */ REFERENCE_TIME refTimeEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimeFormat( 
            /* [in] */ GUID guidTimeFormat,
            /* [in] */ MP_TIMEDATA mpTimeData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaParamsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMediaParams * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMediaParams * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMediaParams * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetParam )( 
            __RPC__in IMediaParams * This,
            /* [in] */ DWORD dwParamIndex,
            /* [out] */ __RPC__out MP_DATA *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetParam )( 
            __RPC__in IMediaParams * This,
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ MP_DATA value);
        
        HRESULT ( STDMETHODCALLTYPE *AddEnvelope )( 
            __RPC__in IMediaParams * This,
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ DWORD cSegments,
            /* [in] */ __RPC__in MP_ENVELOPE_SEGMENT *pEnvelopeSegments);
        
        HRESULT ( STDMETHODCALLTYPE *FlushEnvelope )( 
            __RPC__in IMediaParams * This,
            /* [in] */ DWORD dwParamIndex,
            /* [in] */ REFERENCE_TIME refTimeStart,
            /* [in] */ REFERENCE_TIME refTimeEnd);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeFormat )( 
            __RPC__in IMediaParams * This,
            /* [in] */ GUID guidTimeFormat,
            /* [in] */ MP_TIMEDATA mpTimeData);
        
        END_INTERFACE
    } IMediaParamsVtbl;

    interface IMediaParams
    {
        CONST_VTBL struct IMediaParamsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaParams_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaParams_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaParams_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaParams_GetParam(This,dwParamIndex,pValue)	\
    ( (This)->lpVtbl -> GetParam(This,dwParamIndex,pValue) ) 

#define IMediaParams_SetParam(This,dwParamIndex,value)	\
    ( (This)->lpVtbl -> SetParam(This,dwParamIndex,value) ) 

#define IMediaParams_AddEnvelope(This,dwParamIndex,cSegments,pEnvelopeSegments)	\
    ( (This)->lpVtbl -> AddEnvelope(This,dwParamIndex,cSegments,pEnvelopeSegments) ) 

#define IMediaParams_FlushEnvelope(This,dwParamIndex,refTimeStart,refTimeEnd)	\
    ( (This)->lpVtbl -> FlushEnvelope(This,dwParamIndex,refTimeStart,refTimeEnd) ) 

#define IMediaParams_SetTimeFormat(This,guidTimeFormat,mpTimeData)	\
    ( (This)->lpVtbl -> SetTimeFormat(This,guidTimeFormat,mpTimeData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaParams_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\mediaobj.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for mediaobj.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mediaobj_h__
#define __mediaobj_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMediaBuffer_FWD_DEFINED__
#define __IMediaBuffer_FWD_DEFINED__
typedef interface IMediaBuffer IMediaBuffer;
#endif 	/* __IMediaBuffer_FWD_DEFINED__ */


#ifndef __IMediaObject_FWD_DEFINED__
#define __IMediaObject_FWD_DEFINED__
typedef interface IMediaObject IMediaObject;
#endif 	/* __IMediaObject_FWD_DEFINED__ */


#ifndef __IEnumDMO_FWD_DEFINED__
#define __IEnumDMO_FWD_DEFINED__
typedef interface IEnumDMO IEnumDMO;
#endif 	/* __IEnumDMO_FWD_DEFINED__ */


#ifndef __IMediaObjectInPlace_FWD_DEFINED__
#define __IMediaObjectInPlace_FWD_DEFINED__
typedef interface IMediaObjectInPlace IMediaObjectInPlace;
#endif 	/* __IMediaObjectInPlace_FWD_DEFINED__ */


#ifndef __IDMOQualityControl_FWD_DEFINED__
#define __IDMOQualityControl_FWD_DEFINED__
typedef interface IDMOQualityControl IDMOQualityControl;
#endif 	/* __IDMOQualityControl_FWD_DEFINED__ */


#ifndef __IDMOVideoOutputOptimizations_FWD_DEFINED__
#define __IDMOVideoOutputOptimizations_FWD_DEFINED__
typedef interface IDMOVideoOutputOptimizations IDMOVideoOutputOptimizations;
#endif 	/* __IDMOVideoOutputOptimizations_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_mediaobj_0000_0000 */
/* [local] */ 

#ifdef __strmif_h__
typedef AM_MEDIA_TYPE DMO_MEDIA_TYPE;
#else
typedef struct _DMOMediaType
    {
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
    IUnknown *pUnk;
    ULONG cbFormat;
    BYTE *pbFormat;
    } 	DMO_MEDIA_TYPE;

typedef LONGLONG REFERENCE_TIME;

#endif

enum _DMO_INPUT_DATA_BUFFER_FLAGS
    {	DMO_INPUT_DATA_BUFFERF_SYNCPOINT	= 0x1,
	DMO_INPUT_DATA_BUFFERF_TIME	= 0x2,
	DMO_INPUT_DATA_BUFFERF_TIMELENGTH	= 0x4
    } ;

enum _DMO_OUTPUT_DATA_BUFFER_FLAGS
    {	DMO_OUTPUT_DATA_BUFFERF_SYNCPOINT	= 0x1,
	DMO_OUTPUT_DATA_BUFFERF_TIME	= 0x2,
	DMO_OUTPUT_DATA_BUFFERF_TIMELENGTH	= 0x4,
	DMO_OUTPUT_DATA_BUFFERF_INCOMPLETE	= 0x1000000
    } ;

enum _DMO_INPUT_STATUS_FLAGS
    {	DMO_INPUT_STATUSF_ACCEPT_DATA	= 0x1
    } ;

enum _DMO_INPUT_STREAM_INFO_FLAGS
    {	DMO_INPUT_STREAMF_WHOLE_SAMPLES	= 0x1,
	DMO_INPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER	= 0x2,
	DMO_INPUT_STREAMF_FIXED_SAMPLE_SIZE	= 0x4,
	DMO_INPUT_STREAMF_HOLDS_BUFFERS	= 0x8
    } ;

enum _DMO_OUTPUT_STREAM_INFO_FLAGS
    {	DMO_OUTPUT_STREAMF_WHOLE_SAMPLES	= 0x1,
	DMO_OUTPUT_STREAMF_SINGLE_SAMPLE_PER_BUFFER	= 0x2,
	DMO_OUTPUT_STREAMF_FIXED_SAMPLE_SIZE	= 0x4,
	DMO_OUTPUT_STREAMF_DISCARDABLE	= 0x8,
	DMO_OUTPUT_STREAMF_OPTIONAL	= 0x10
    } ;

enum _DMO_SET_TYPE_FLAGS
    {	DMO_SET_TYPEF_TEST_ONLY	= 0x1,
	DMO_SET_TYPEF_CLEAR	= 0x2
    } ;

enum _DMO_PROCESS_OUTPUT_FLAGS
    {	DMO_PROCESS_OUTPUT_DISCARD_WHEN_NO_BUFFER	= 0x1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0000_v0_0_s_ifspec;

#ifndef __IMediaBuffer_INTERFACE_DEFINED__
#define __IMediaBuffer_INTERFACE_DEFINED__

/* interface IMediaBuffer */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMediaBuffer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("59eff8b9-938c-4a26-82f2-95cb84cdc837")
    IMediaBuffer : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetLength( 
            DWORD cbLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxLength( 
            /* [annotation][out] */ 
            __out  DWORD *pcbMaxLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBufferAndLength( 
            /* [annotation][out] */ 
            __deref_opt_out_bcount(*pcbLength)  BYTE **ppBuffer,
            /* [annotation][out] */ 
            __out_opt  DWORD *pcbLength) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaBufferVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaBuffer * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaBuffer * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaBuffer * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetLength )( 
            IMediaBuffer * This,
            DWORD cbLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxLength )( 
            IMediaBuffer * This,
            /* [annotation][out] */ 
            __out  DWORD *pcbMaxLength);
        
        HRESULT ( STDMETHODCALLTYPE *GetBufferAndLength )( 
            IMediaBuffer * This,
            /* [annotation][out] */ 
            __deref_opt_out_bcount(*pcbLength)  BYTE **ppBuffer,
            /* [annotation][out] */ 
            __out_opt  DWORD *pcbLength);
        
        END_INTERFACE
    } IMediaBufferVtbl;

    interface IMediaBuffer
    {
        CONST_VTBL struct IMediaBufferVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaBuffer_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaBuffer_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaBuffer_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaBuffer_SetLength(This,cbLength)	\
    ( (This)->lpVtbl -> SetLength(This,cbLength) ) 

#define IMediaBuffer_GetMaxLength(This,pcbMaxLength)	\
    ( (This)->lpVtbl -> GetMaxLength(This,pcbMaxLength) ) 

#define IMediaBuffer_GetBufferAndLength(This,ppBuffer,pcbLength)	\
    ( (This)->lpVtbl -> GetBufferAndLength(This,ppBuffer,pcbLength) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaBuffer_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mediaobj_0000_0001 */
/* [local] */ 

typedef struct _DMO_OUTPUT_DATA_BUFFER
    {
    IMediaBuffer *pBuffer;
    DWORD dwStatus;
    REFERENCE_TIME rtTimestamp;
    REFERENCE_TIME rtTimelength;
    } 	DMO_OUTPUT_DATA_BUFFER;

typedef struct _DMO_OUTPUT_DATA_BUFFER *PDMO_OUTPUT_DATA_BUFFER;



extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0001_v0_0_s_ifspec;

#ifndef __IMediaObject_INTERFACE_DEFINED__
#define __IMediaObject_INTERFACE_DEFINED__

/* interface IMediaObject */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMediaObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d8ad0f58-5494-4102-97c5-ec798e59bcf4")
    IMediaObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetStreamCount( 
            /* [annotation][out] */ 
            __out  DWORD *pcInputStreams,
            /* [annotation][out] */ 
            __out  DWORD *pcOutputStreams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputStreamInfo( 
            DWORD dwInputStreamIndex,
            /* [annotation][out] */ 
            __out  DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputStreamInfo( 
            DWORD dwOutputStreamIndex,
            /* [annotation][out] */ 
            __out  DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputType( 
            DWORD dwInputStreamIndex,
            DWORD dwTypeIndex,
            /* [annotation][out] */ 
            __out_opt  DMO_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputType( 
            DWORD dwOutputStreamIndex,
            DWORD dwTypeIndex,
            /* [annotation][out] */ 
            __out_opt  DMO_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputType( 
            DWORD dwInputStreamIndex,
            /* [annotation][in] */ 
            __in_opt  const DMO_MEDIA_TYPE *pmt,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOutputType( 
            DWORD dwOutputStreamIndex,
            /* [annotation][in] */ 
            __in_opt  const DMO_MEDIA_TYPE *pmt,
            DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputCurrentType( 
            DWORD dwInputStreamIndex,
            /* [annotation][out] */ 
            __out  DMO_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputCurrentType( 
            DWORD dwOutputStreamIndex,
            /* [annotation][out] */ 
            __out  DMO_MEDIA_TYPE *pmt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputSizeInfo( 
            DWORD dwInputStreamIndex,
            /* [annotation][out] */ 
            __out  DWORD *pcbSize,
            /* [annotation][out] */ 
            __out  DWORD *pcbMaxLookahead,
            /* [annotation][out] */ 
            __out  DWORD *pcbAlignment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOutputSizeInfo( 
            DWORD dwOutputStreamIndex,
            /* [annotation][out] */ 
            __out  DWORD *pcbSize,
            /* [annotation][out] */ 
            __out  DWORD *pcbAlignment) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputMaxLatency( 
            DWORD dwInputStreamIndex,
            /* [annotation][out] */ 
            __out  REFERENCE_TIME *prtMaxLatency) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInputMaxLatency( 
            DWORD dwInputStreamIndex,
            REFERENCE_TIME rtMaxLatency) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Discontinuity( 
            DWORD dwInputStreamIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AllocateStreamingResources( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeStreamingResources( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInputStatus( 
            DWORD dwInputStreamIndex,
            /* [annotation][out] */ 
            __out  DWORD *dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessInput( 
            DWORD dwInputStreamIndex,
            IMediaBuffer *pBuffer,
            DWORD dwFlags,
            REFERENCE_TIME rtTimestamp,
            REFERENCE_TIME rtTimelength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessOutput( 
            DWORD dwFlags,
            DWORD cOutputBufferCount,
            /* [annotation][size_is][out][in] */ 
            __out_ecount(cOutputBufferCount)  DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
            /* [annotation][out] */ 
            __out  DWORD *pdwStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Lock( 
            LONG bLock) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaObject * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamCount )( 
            IMediaObject * This,
            /* [annotation][out] */ 
            __out  DWORD *pcInputStreams,
            /* [annotation][out] */ 
            __out  DWORD *pcOutputStreams);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputStreamInfo )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            /* [annotation][out] */ 
            __out  DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputStreamInfo )( 
            IMediaObject * This,
            DWORD dwOutputStreamIndex,
            /* [annotation][out] */ 
            __out  DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputType )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            DWORD dwTypeIndex,
            /* [annotation][out] */ 
            __out_opt  DMO_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputType )( 
            IMediaObject * This,
            DWORD dwOutputStreamIndex,
            DWORD dwTypeIndex,
            /* [annotation][out] */ 
            __out_opt  DMO_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *SetInputType )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            /* [annotation][in] */ 
            __in_opt  const DMO_MEDIA_TYPE *pmt,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *SetOutputType )( 
            IMediaObject * This,
            DWORD dwOutputStreamIndex,
            /* [annotation][in] */ 
            __in_opt  const DMO_MEDIA_TYPE *pmt,
            DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputCurrentType )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            /* [annotation][out] */ 
            __out  DMO_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputCurrentType )( 
            IMediaObject * This,
            DWORD dwOutputStreamIndex,
            /* [annotation][out] */ 
            __out  DMO_MEDIA_TYPE *pmt);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputSizeInfo )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            /* [annotation][out] */ 
            __out  DWORD *pcbSize,
            /* [annotation][out] */ 
            __out  DWORD *pcbMaxLookahead,
            /* [annotation][out] */ 
            __out  DWORD *pcbAlignment);
        
        HRESULT ( STDMETHODCALLTYPE *GetOutputSizeInfo )( 
            IMediaObject * This,
            DWORD dwOutputStreamIndex,
            /* [annotation][out] */ 
            __out  DWORD *pcbSize,
            /* [annotation][out] */ 
            __out  DWORD *pcbAlignment);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputMaxLatency )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            /* [annotation][out] */ 
            __out  REFERENCE_TIME *prtMaxLatency);
        
        HRESULT ( STDMETHODCALLTYPE *SetInputMaxLatency )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            REFERENCE_TIME rtMaxLatency);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            IMediaObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *Discontinuity )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex);
        
        HRESULT ( STDMETHODCALLTYPE *AllocateStreamingResources )( 
            IMediaObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *FreeStreamingResources )( 
            IMediaObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetInputStatus )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            /* [annotation][out] */ 
            __out  DWORD *dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessInput )( 
            IMediaObject * This,
            DWORD dwInputStreamIndex,
            IMediaBuffer *pBuffer,
            DWORD dwFlags,
            REFERENCE_TIME rtTimestamp,
            REFERENCE_TIME rtTimelength);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessOutput )( 
            IMediaObject * This,
            DWORD dwFlags,
            DWORD cOutputBufferCount,
            /* [annotation][size_is][out][in] */ 
            __out_ecount(cOutputBufferCount)  DMO_OUTPUT_DATA_BUFFER *pOutputBuffers,
            /* [annotation][out] */ 
            __out  DWORD *pdwStatus);
        
        HRESULT ( STDMETHODCALLTYPE *Lock )( 
            IMediaObject * This,
            LONG bLock);
        
        END_INTERFACE
    } IMediaObjectVtbl;

    interface IMediaObject
    {
        CONST_VTBL struct IMediaObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaObject_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaObject_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaObject_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaObject_GetStreamCount(This,pcInputStreams,pcOutputStreams)	\
    ( (This)->lpVtbl -> GetStreamCount(This,pcInputStreams,pcOutputStreams) ) 

#define IMediaObject_GetInputStreamInfo(This,dwInputStreamIndex,pdwFlags)	\
    ( (This)->lpVtbl -> GetInputStreamInfo(This,dwInputStreamIndex,pdwFlags) ) 

#define IMediaObject_GetOutputStreamInfo(This,dwOutputStreamIndex,pdwFlags)	\
    ( (This)->lpVtbl -> GetOutputStreamInfo(This,dwOutputStreamIndex,pdwFlags) ) 

#define IMediaObject_GetInputType(This,dwInputStreamIndex,dwTypeIndex,pmt)	\
    ( (This)->lpVtbl -> GetInputType(This,dwInputStreamIndex,dwTypeIndex,pmt) ) 

#define IMediaObject_GetOutputType(This,dwOutputStreamIndex,dwTypeIndex,pmt)	\
    ( (This)->lpVtbl -> GetOutputType(This,dwOutputStreamIndex,dwTypeIndex,pmt) ) 

#define IMediaObject_SetInputType(This,dwInputStreamIndex,pmt,dwFlags)	\
    ( (This)->lpVtbl -> SetInputType(This,dwInputStreamIndex,pmt,dwFlags) ) 

#define IMediaObject_SetOutputType(This,dwOutputStreamIndex,pmt,dwFlags)	\
    ( (This)->lpVtbl -> SetOutputType(This,dwOutputStreamIndex,pmt,dwFlags) ) 

#define IMediaObject_GetInputCurrentType(This,dwInputStreamIndex,pmt)	\
    ( (This)->lpVtbl -> GetInputCurrentType(This,dwInputStreamIndex,pmt) ) 

#define IMediaObject_GetOutputCurrentType(This,dwOutputStreamIndex,pmt)	\
    ( (This)->lpVtbl -> GetOutputCurrentType(This,dwOutputStreamIndex,pmt) ) 

#define IMediaObject_GetInputSizeInfo(This,dwInputStreamIndex,pcbSize,pcbMaxLookahead,pcbAlignment)	\
    ( (This)->lpVtbl -> GetInputSizeInfo(This,dwInputStreamIndex,pcbSize,pcbMaxLookahead,pcbAlignment) ) 

#define IMediaObject_GetOutputSizeInfo(This,dwOutputStreamIndex,pcbSize,pcbAlignment)	\
    ( (This)->lpVtbl -> GetOutputSizeInfo(This,dwOutputStreamIndex,pcbSize,pcbAlignment) ) 

#define IMediaObject_GetInputMaxLatency(This,dwInputStreamIndex,prtMaxLatency)	\
    ( (This)->lpVtbl -> GetInputMaxLatency(This,dwInputStreamIndex,prtMaxLatency) ) 

#define IMediaObject_SetInputMaxLatency(This,dwInputStreamIndex,rtMaxLatency)	\
    ( (This)->lpVtbl -> SetInputMaxLatency(This,dwInputStreamIndex,rtMaxLatency) ) 

#define IMediaObject_Flush(This)	\
    ( (This)->lpVtbl -> Flush(This) ) 

#define IMediaObject_Discontinuity(This,dwInputStreamIndex)	\
    ( (This)->lpVtbl -> Discontinuity(This,dwInputStreamIndex) ) 

#define IMediaObject_AllocateStreamingResources(This)	\
    ( (This)->lpVtbl -> AllocateStreamingResources(This) ) 

#define IMediaObject_FreeStreamingResources(This)	\
    ( (This)->lpVtbl -> FreeStreamingResources(This) ) 

#define IMediaObject_GetInputStatus(This,dwInputStreamIndex,dwFlags)	\
    ( (This)->lpVtbl -> GetInputStatus(This,dwInputStreamIndex,dwFlags) ) 

#define IMediaObject_ProcessInput(This,dwInputStreamIndex,pBuffer,dwFlags,rtTimestamp,rtTimelength)	\
    ( (This)->lpVtbl -> ProcessInput(This,dwInputStreamIndex,pBuffer,dwFlags,rtTimestamp,rtTimelength) ) 

#define IMediaObject_ProcessOutput(This,dwFlags,cOutputBufferCount,pOutputBuffers,pdwStatus)	\
    ( (This)->lpVtbl -> ProcessOutput(This,dwFlags,cOutputBufferCount,pOutputBuffers,pdwStatus) ) 

#define IMediaObject_Lock(This,bLock)	\
    ( (This)->lpVtbl -> Lock(This,bLock) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaObject_INTERFACE_DEFINED__ */


#ifndef __IEnumDMO_INTERFACE_DEFINED__
#define __IEnumDMO_INTERFACE_DEFINED__

/* interface IEnumDMO */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IEnumDMO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2c3cd98a-2bfa-4a53-9c27-5249ba64ba0f")
    IEnumDMO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            DWORD cItemsToFetch,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(cItemsToFetch, *pcItemsFetched)  CLSID *pCLSID,
            /* [annotation][string][length_is][size_is][out] */ 
            __out_ecount_part(cItemsToFetch, *pcItemsFetched)  LPWSTR *Names,
            /* [annotation][out] */ 
            __out  DWORD *pcItemsFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            DWORD cItemsToSkip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [annotation][out] */ 
            __out  IEnumDMO **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDMOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDMO * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDMO * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDMO * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDMO * This,
            DWORD cItemsToFetch,
            /* [annotation][length_is][size_is][out] */ 
            __out_ecount_part(cItemsToFetch, *pcItemsFetched)  CLSID *pCLSID,
            /* [annotation][string][length_is][size_is][out] */ 
            __out_ecount_part(cItemsToFetch, *pcItemsFetched)  LPWSTR *Names,
            /* [annotation][out] */ 
            __out  DWORD *pcItemsFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDMO * This,
            DWORD cItemsToSkip);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDMO * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDMO * This,
            /* [annotation][out] */ 
            __out  IEnumDMO **ppEnum);
        
        END_INTERFACE
    } IEnumDMOVtbl;

    interface IEnumDMO
    {
        CONST_VTBL struct IEnumDMOVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDMO_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IEnumDMO_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IEnumDMO_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IEnumDMO_Next(This,cItemsToFetch,pCLSID,Names,pcItemsFetched)	\
    ( (This)->lpVtbl -> Next(This,cItemsToFetch,pCLSID,Names,pcItemsFetched) ) 

#define IEnumDMO_Skip(This,cItemsToSkip)	\
    ( (This)->lpVtbl -> Skip(This,cItemsToSkip) ) 

#define IEnumDMO_Reset(This)	\
    ( (This)->lpVtbl -> Reset(This) ) 

#define IEnumDMO_Clone(This,ppEnum)	\
    ( (This)->lpVtbl -> Clone(This,ppEnum) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IEnumDMO_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mediaobj_0000_0003 */
/* [local] */ 


enum _DMO_INPLACE_PROCESS_FLAGS
    {	DMO_INPLACE_NORMAL	= 0,
	DMO_INPLACE_ZERO	= 0x1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0003_v0_0_s_ifspec;

#ifndef __IMediaObjectInPlace_INTERFACE_DEFINED__
#define __IMediaObjectInPlace_INTERFACE_DEFINED__

/* interface IMediaObjectInPlace */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMediaObjectInPlace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("651b9ad0-0fc7-4aa9-9538-d89931010741")
    IMediaObjectInPlace : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Process( 
            /* [in] */ ULONG ulSize,
            /* [annotation][size_is][out][in] */ 
            __out_bcount(ulSize)  BYTE *pData,
            /* [in] */ REFERENCE_TIME refTimeStart,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [annotation][out] */ 
            __out  IMediaObjectInPlace **ppMediaObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLatency( 
            /* [annotation][out] */ 
            __out  REFERENCE_TIME *pLatencyTime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaObjectInPlaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMediaObjectInPlace * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMediaObjectInPlace * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMediaObjectInPlace * This);
        
        HRESULT ( STDMETHODCALLTYPE *Process )( 
            IMediaObjectInPlace * This,
            /* [in] */ ULONG ulSize,
            /* [annotation][size_is][out][in] */ 
            __out_bcount(ulSize)  BYTE *pData,
            /* [in] */ REFERENCE_TIME refTimeStart,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IMediaObjectInPlace * This,
            /* [annotation][out] */ 
            __out  IMediaObjectInPlace **ppMediaObject);
        
        HRESULT ( STDMETHODCALLTYPE *GetLatency )( 
            IMediaObjectInPlace * This,
            /* [annotation][out] */ 
            __out  REFERENCE_TIME *pLatencyTime);
        
        END_INTERFACE
    } IMediaObjectInPlaceVtbl;

    interface IMediaObjectInPlace
    {
        CONST_VTBL struct IMediaObjectInPlaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaObjectInPlace_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMediaObjectInPlace_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMediaObjectInPlace_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMediaObjectInPlace_Process(This,ulSize,pData,refTimeStart,dwFlags)	\
    ( (This)->lpVtbl -> Process(This,ulSize,pData,refTimeStart,dwFlags) ) 

#define IMediaObjectInPlace_Clone(This,ppMediaObject)	\
    ( (This)->lpVtbl -> Clone(This,ppMediaObject) ) 

#define IMediaObjectInPlace_GetLatency(This,pLatencyTime)	\
    ( (This)->lpVtbl -> GetLatency(This,pLatencyTime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMediaObjectInPlace_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mediaobj_0000_0004 */
/* [local] */ 


enum _DMO_QUALITY_STATUS_FLAGS
    {	DMO_QUALITY_STATUS_ENABLED	= 0x1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0004_v0_0_s_ifspec;

#ifndef __IDMOQualityControl_INTERFACE_DEFINED__
#define __IDMOQualityControl_INTERFACE_DEFINED__

/* interface IDMOQualityControl */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IDMOQualityControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("65abea96-cf36-453f-af8a-705e98f16260")
    IDMOQualityControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetNow( 
            /* [in] */ REFERENCE_TIME rtNow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatus( 
            /* [annotation][out] */ 
            __out  DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDMOQualityControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDMOQualityControl * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDMOQualityControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDMOQualityControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetNow )( 
            IDMOQualityControl * This,
            /* [in] */ REFERENCE_TIME rtNow);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatus )( 
            IDMOQualityControl * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatus )( 
            IDMOQualityControl * This,
            /* [annotation][out] */ 
            __out  DWORD *pdwFlags);
        
        END_INTERFACE
    } IDMOQualityControlVtbl;

    interface IDMOQualityControl
    {
        CONST_VTBL struct IDMOQualityControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDMOQualityControl_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDMOQualityControl_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDMOQualityControl_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDMOQualityControl_SetNow(This,rtNow)	\
    ( (This)->lpVtbl -> SetNow(This,rtNow) ) 

#define IDMOQualityControl_SetStatus(This,dwFlags)	\
    ( (This)->lpVtbl -> SetStatus(This,dwFlags) ) 

#define IDMOQualityControl_GetStatus(This,pdwFlags)	\
    ( (This)->lpVtbl -> GetStatus(This,pdwFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDMOQualityControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mediaobj_0000_0005 */
/* [local] */ 


enum _DMO_VIDEO_OUTPUT_STREAM_FLAGS
    {	DMO_VOSF_NEEDS_PREVIOUS_SAMPLE	= 0x1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mediaobj_0000_0005_v0_0_s_ifspec;

#ifndef __IDMOVideoOutputOptimizations_INTERFACE_DEFINED__
#define __IDMOVideoOutputOptimizations_INTERFACE_DEFINED__

/* interface IDMOVideoOutputOptimizations */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IDMOVideoOutputOptimizations;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("be8f4f4e-5b16-4d29-b350-7f6b5d9298ac")
    IDMOVideoOutputOptimizations : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueryOperationModePreferences( 
            ULONG ulOutputStreamIndex,
            /* [annotation] */ 
            __out  DWORD *pdwRequestedCapabilities) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOperationMode( 
            ULONG ulOutputStreamIndex,
            DWORD dwEnabledFeatures) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentOperationMode( 
            ULONG ulOutputStreamIndex,
            /* [annotation] */ 
            __out  DWORD *pdwEnabledFeatures) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentSampleRequirements( 
            ULONG ulOutputStreamIndex,
            /* [annotation] */ 
            __out  DWORD *pdwRequestedFeatures) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDMOVideoOutputOptimizationsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDMOVideoOutputOptimizations * This,
            /* [in] */ REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDMOVideoOutputOptimizations * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDMOVideoOutputOptimizations * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueryOperationModePreferences )( 
            IDMOVideoOutputOptimizations * This,
            ULONG ulOutputStreamIndex,
            /* [annotation] */ 
            __out  DWORD *pdwRequestedCapabilities);
        
        HRESULT ( STDMETHODCALLTYPE *SetOperationMode )( 
            IDMOVideoOutputOptimizations * This,
            ULONG ulOutputStreamIndex,
            DWORD dwEnabledFeatures);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentOperationMode )( 
            IDMOVideoOutputOptimizations * This,
            ULONG ulOutputStreamIndex,
            /* [annotation] */ 
            __out  DWORD *pdwEnabledFeatures);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentSampleRequirements )( 
            IDMOVideoOutputOptimizations * This,
            ULONG ulOutputStreamIndex,
            /* [annotation] */ 
            __out  DWORD *pdwRequestedFeatures);
        
        END_INTERFACE
    } IDMOVideoOutputOptimizationsVtbl;

    interface IDMOVideoOutputOptimizations
    {
        CONST_VTBL struct IDMOVideoOutputOptimizationsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDMOVideoOutputOptimizations_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IDMOVideoOutputOptimizations_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IDMOVideoOutputOptimizations_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IDMOVideoOutputOptimizations_QueryOperationModePreferences(This,ulOutputStreamIndex,pdwRequestedCapabilities)	\
    ( (This)->lpVtbl -> QueryOperationModePreferences(This,ulOutputStreamIndex,pdwRequestedCapabilities) ) 

#define IDMOVideoOutputOptimizations_SetOperationMode(This,ulOutputStreamIndex,dwEnabledFeatures)	\
    ( (This)->lpVtbl -> SetOperationMode(This,ulOutputStreamIndex,dwEnabledFeatures) ) 

#define IDMOVideoOutputOptimizations_GetCurrentOperationMode(This,ulOutputStreamIndex,pdwEnabledFeatures)	\
    ( (This)->lpVtbl -> GetCurrentOperationMode(This,ulOutputStreamIndex,pdwEnabledFeatures) ) 

#define IDMOVideoOutputOptimizations_GetCurrentSampleRequirements(This,ulOutputStreamIndex,pdwRequestedFeatures)	\
    ( (This)->lpVtbl -> GetCurrentSampleRequirements(This,ulOutputStreamIndex,pdwRequestedFeatures) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDMOVideoOutputOptimizations_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\mergemod.h ===
/*****************************************************************************\
                                                                             
 mergemod.h - - Interface for MergeMod COM object                            
                                                                             
 Version 2.0                                                                 
                                                                             
 NOTES:  All strings are of type BSTR. For [in] strings, LPCWSTR may be      
 safely used instead, the object will not try to free this memory.           
 All [out] BSTR values must be released by the client.                       
                                                                             
 Copyright (c) Microsoft Corp. All rights reserved.          
                                                                             
\*****************************************************************************/

#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mergemod_h__
#define __mergemod_h__

#ifndef _WIN32_MSM
#define _WIN32_MSM   100
#endif // !_WIN32_MSM

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumMsmString_FWD_DEFINED__
#define __IEnumMsmString_FWD_DEFINED__
typedef interface IEnumMsmString IEnumMsmString;
#endif 	/* __IEnumMsmString_FWD_DEFINED__ */


#ifndef __IMsmStrings_FWD_DEFINED__
#define __IMsmStrings_FWD_DEFINED__
typedef interface IMsmStrings IMsmStrings;
#endif 	/* __IMsmStrings_FWD_DEFINED__ */


#ifndef __IMsmError_FWD_DEFINED__
#define __IMsmError_FWD_DEFINED__
typedef interface IMsmError IMsmError;
#endif 	/* __IMsmError_FWD_DEFINED__ */


#ifndef __IEnumMsmError_FWD_DEFINED__
#define __IEnumMsmError_FWD_DEFINED__
typedef interface IEnumMsmError IEnumMsmError;
#endif 	/* __IEnumMsmError_FWD_DEFINED__ */


#ifndef __IMsmErrors_FWD_DEFINED__
#define __IMsmErrors_FWD_DEFINED__
typedef interface IMsmErrors IMsmErrors;
#endif 	/* __IMsmErrors_FWD_DEFINED__ */


#ifndef __IMsmDependency_FWD_DEFINED__
#define __IMsmDependency_FWD_DEFINED__
typedef interface IMsmDependency IMsmDependency;
#endif 	/* __IMsmDependency_FWD_DEFINED__ */


#ifndef __IEnumMsmDependency_FWD_DEFINED__
#define __IEnumMsmDependency_FWD_DEFINED__
typedef interface IEnumMsmDependency IEnumMsmDependency;
#endif 	/* __IEnumMsmDependency_FWD_DEFINED__ */


#ifndef __IMsmDependencies_FWD_DEFINED__
#define __IMsmDependencies_FWD_DEFINED__
typedef interface IMsmDependencies IMsmDependencies;
#endif 	/* __IMsmDependencies_FWD_DEFINED__ */


#ifndef __IMsmMerge_FWD_DEFINED__
#define __IMsmMerge_FWD_DEFINED__
typedef interface IMsmMerge IMsmMerge;
#endif 	/* __IMsmMerge_FWD_DEFINED__ */


#ifndef __IMsmGetFiles_FWD_DEFINED__
#define __IMsmGetFiles_FWD_DEFINED__
typedef interface IMsmGetFiles IMsmGetFiles;
#endif 	/* __IMsmGetFiles_FWD_DEFINED__ */


#ifndef __IMsmStrings_FWD_DEFINED__
#define __IMsmStrings_FWD_DEFINED__
typedef interface IMsmStrings IMsmStrings;
#endif 	/* __IMsmStrings_FWD_DEFINED__ */


#ifndef __IMsmError_FWD_DEFINED__
#define __IMsmError_FWD_DEFINED__
typedef interface IMsmError IMsmError;
#endif 	/* __IMsmError_FWD_DEFINED__ */


#ifndef __IMsmErrors_FWD_DEFINED__
#define __IMsmErrors_FWD_DEFINED__
typedef interface IMsmErrors IMsmErrors;
#endif 	/* __IMsmErrors_FWD_DEFINED__ */


#ifndef __IMsmDependency_FWD_DEFINED__
#define __IMsmDependency_FWD_DEFINED__
typedef interface IMsmDependency IMsmDependency;
#endif 	/* __IMsmDependency_FWD_DEFINED__ */


#ifndef __IMsmDependencies_FWD_DEFINED__
#define __IMsmDependencies_FWD_DEFINED__
typedef interface IMsmDependencies IMsmDependencies;
#endif 	/* __IMsmDependencies_FWD_DEFINED__ */


#ifndef __IMsmGetFiles_FWD_DEFINED__
#define __IMsmGetFiles_FWD_DEFINED__
typedef interface IMsmGetFiles IMsmGetFiles;
#endif 	/* __IMsmGetFiles_FWD_DEFINED__ */

#if (_WIN32_MSM >= 150)

#ifndef __IMsmConfigurableItem_FWD_DEFINED__
#define __IMsmConfigurableItem_FWD_DEFINED__
typedef interface IMsmConfigurableItem IMsmConfigurableItem;
#endif 	/* __IMsmConfigurableItem_FWD_DEFINED__ */


#ifndef __IEnumMsmConfigurableItem_FWD_DEFINED__
#define __IEnumMsmConfigurableItem_FWD_DEFINED__
typedef interface IEnumMsmConfigurableItem IEnumMsmConfigurableItem;
#endif 	/* __IEnumMsmConfigurableItem_FWD_DEFINED__ */


#ifndef __IMsmConfigurableItems_FWD_DEFINED__
#define __IMsmConfigurableItems_FWD_DEFINED__
typedef interface IMsmConfigurableItems IMsmConfigurableItems;
#endif 	/* __IMsmConfigurableItems_FWD_DEFINED__ */

#ifndef __IMsmMerge2_FWD_DEFINED__
#define __IMsmMerge2_FWD_DEFINED__
typedef interface IMsmMerge2 IMsmMerge2;
#endif 	/* __IMsmMerge2_FWD_DEFINED__ */

#ifndef __IMsmConfigureModule_FWD_DEFINED__
#define __IMsmConfigureModule_FWD_DEFINED__
typedef interface IMsmConfigureModule IMsmConfigureModule;
#endif 	/* __IMsmConfigureModule_FWD_DEFINED__ */

#ifndef __MsmMerge2_FWD_DEFINED__
#define __MsmMerge2_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsmMerge2 MsmMerge2;
#else
typedef struct MsmMerge2 MsmMerge2;
#endif /* __cplusplus */

#endif 	/* __MsmMerge2_FWD_DEFINED__ */


#endif /* _WIN32_MSM */

#ifndef __MsmMerge_FWD_DEFINED__
#define __MsmMerge_FWD_DEFINED__

#ifdef __cplusplus
typedef class MsmMerge MsmMerge;
#else
typedef struct MsmMerge MsmMerge;
#endif /* __cplusplus */

#endif 	/* __MsmMerge_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __FORWARD_IID_IMSMMERGETYPELIB
#define __FORWARD_IID_IMSMMERGETYPELIB

// --------------------------------------------------------------------------
// MergeMod error types, returned from IMsmError::get_Type
// --------------------------------------------------------------------------
typedef /* [helpstring][uuid] */ 
enum msmErrorType
    {	
	msmErrorLanguageUnsupported	= 1,
	msmErrorLanguageFailed          = 2,
	msmErrorExclusion               = 3,
	msmErrorTableMerge              = 4,
	msmErrorResequenceMerge	        = 5,
	msmErrorFileCreate              = 6,
	msmErrorDirCreate               = 7,
	msmErrorFeatureRequired	        = 8,

#if (_WIN32_MSM >= 150)
	msmErrorBadNullSubstitution     = 9,
	msmErrorBadSubstitutionType     = 10,
	msmErrorMissingConfigItem       = 11,
	msmErrorBadNullResponse         = 12,
	msmErrorDataRequestFailed       = 13,    
	msmErrorPlatformMismatch        = 14    
#endif
	}	
	msmErrorType;

#if (_WIN32_MSM >= 150)

// --------------------------------------------------------------------------
// MergeMod formats for ModuleConfiguration items.
// --------------------------------------------------------------------------
typedef /* [helpstring][uuid] */ 
enum msmConfigurableItemFormat
    {
	msmConfigurableItemText = 0,
	msmConfigurableItemKey = 1,
	msmConfigurableItemInteger = 2,
	msmConfigurableItemBitfield = 3
    }
    msmConfigurableItemFormat;


// --------------------------------------------------------------------------
// MergeMod options for ModuleConfiguration items.
// --------------------------------------------------------------------------
typedef /* [helpstring][uuid] */   
enum msmConfigurableItemOptions
    {	
	msmConfigurableOptionKeyNoOrphan	= 1,
	msmConfigurableOptionNonNullable	= 2
    } 	
    msmConfigurableItemOptions;


#endif


#endif // __FORWARD_IID_IMSMMERGETYPELIB

extern RPC_IF_HANDLE __MIDL_itf_mergemod_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mergemod_0000_v0_0_s_ifspec;


// --------------------------------------------------------------------------
// IEnumMsmString - enumeration of BSTR
// --------------------------------------------------------------------------

#ifndef __IEnumMsmString_INTERFACE_DEFINED__
#define __IEnumMsmString_INTERFACE_DEFINED__


#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA826-2C26-11D2-AD65-00A0C9AF11A6")
    IEnumMsmString : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long cFetch,
            /* [out] */ BSTR __RPC_FAR *rgbstrStrings,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long cSkip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumMsmString __RPC_FAR *__RPC_FAR *pemsmStrings) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMsmStringVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumMsmString __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumMsmString __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumMsmString __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumMsmString __RPC_FAR * This,
            /* [in] */ unsigned long cFetch,
            /* [out] */ BSTR __RPC_FAR *rgbstrStrings,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumMsmString __RPC_FAR * This,
            /* [in] */ unsigned long cSkip);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumMsmString __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumMsmString __RPC_FAR * This,
            /* [retval][out] */ IEnumMsmString __RPC_FAR *__RPC_FAR *pemsmStrings);
        
        END_INTERFACE
    } IEnumMsmStringVtbl;

    interface IEnumMsmString
    {
        CONST_VTBL struct IEnumMsmStringVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMsmString_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMsmString_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMsmString_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMsmString_Next(This,cFetch,rgbstrStrings,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,rgbstrStrings,pcFetched)

#define IEnumMsmString_Skip(This,cSkip)	\
    (This)->lpVtbl -> Skip(This,cSkip)

#define IEnumMsmString_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMsmString_Clone(This,pemsmStrings)	\
    (This)->lpVtbl -> Clone(This,pemsmStrings)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumMsmString_Next_Proxy( 
    IEnumMsmString __RPC_FAR * This,
    /* [in] */ unsigned long cFetch,
    /* [out] */ BSTR __RPC_FAR *rgbstrStrings,
    /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);


void __RPC_STUB IEnumMsmString_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmString_Skip_Proxy( 
    IEnumMsmString __RPC_FAR * This,
    /* [in] */ unsigned long cSkip);


void __RPC_STUB IEnumMsmString_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmString_Reset_Proxy( 
    IEnumMsmString __RPC_FAR * This);


void __RPC_STUB IEnumMsmString_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmString_Clone_Proxy( 
    IEnumMsmString __RPC_FAR * This,
    /* [retval][out] */ IEnumMsmString __RPC_FAR *__RPC_FAR *pemsmStrings);


void __RPC_STUB IEnumMsmString_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumMsmString_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IMsmStrings - a collection of MergeMod BSTR
// --------------------------------------------------------------------------

#ifndef __IMsmStrings_INTERFACE_DEFINED__
#define __IMsmStrings_INTERFACE_DEFINED__


#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA827-2C26-11D2-AD65-00A0C9AF11A6")
    IMsmStrings : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Item,
            /* [retval][out] */ BSTR __RPC_FAR *Return) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmStringsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmStrings __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmStrings __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmStrings __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmStrings __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmStrings __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmStrings __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmStrings __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IMsmStrings __RPC_FAR * This,
            /* [in] */ long Item,
            /* [retval][out] */ BSTR __RPC_FAR *Return);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMsmStrings __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMsmStrings __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);
        
        END_INTERFACE
    } IMsmStringsVtbl;

    interface IMsmStrings
    {
        CONST_VTBL struct IMsmStringsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmStrings_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmStrings_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmStrings_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmStrings_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmStrings_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmStrings_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmStrings_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmStrings_get_Item(This,Item,Return)	\
    (This)->lpVtbl -> get_Item(This,Item,Return)

#define IMsmStrings_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IMsmStrings_get__NewEnum(This,NewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,NewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmStrings_get_Item_Proxy( 
    IMsmStrings __RPC_FAR * This,
    /* [in] */ long Item,
    /* [retval][out] */ BSTR __RPC_FAR *Return);


void __RPC_STUB IMsmStrings_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmStrings_get_Count_Proxy( 
    IMsmStrings __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IMsmStrings_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmStrings_get__NewEnum_Proxy( 
    IMsmStrings __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);


void __RPC_STUB IMsmStrings_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmStrings_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IMsmError - interface for retrieving details on a single merge error
// --------------------------------------------------------------------------

#ifndef __IMsmError_INTERFACE_DEFINED__
#define __IMsmError_INTERFACE_DEFINED__

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA828-2C26-11D2-AD65-00A0C9AF11A6")
    IMsmError : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ msmErrorType __RPC_FAR *ErrorType) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Path( 
            /* [retval][out] */ BSTR __RPC_FAR *ErrorPath) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Language( 
            /* [retval][out] */ short __RPC_FAR *ErrorLanguage) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DatabaseTable( 
            /* [retval][out] */ BSTR __RPC_FAR *ErrorTable) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DatabaseKeys( 
            /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *ErrorKeys) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModuleTable( 
            /* [retval][out] */ BSTR __RPC_FAR *ErrorTable) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModuleKeys( 
            /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *ErrorKeys) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmError __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmError __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmError __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ msmErrorType __RPC_FAR *ErrorType);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Path )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ErrorPath);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Language )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *ErrorLanguage);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DatabaseTable )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ErrorTable);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DatabaseKeys )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *ErrorKeys);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModuleTable )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *ErrorTable);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModuleKeys )( 
            IMsmError __RPC_FAR * This,
            /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *ErrorKeys);
        
        END_INTERFACE
    } IMsmErrorVtbl;

    interface IMsmError
    {
        CONST_VTBL struct IMsmErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmError_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmError_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmError_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmError_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmError_get_Type(This,ErrorType)	\
    (This)->lpVtbl -> get_Type(This,ErrorType)

#define IMsmError_get_Path(This,ErrorPath)	\
    (This)->lpVtbl -> get_Path(This,ErrorPath)

#define IMsmError_get_Language(This,ErrorLanguage)	\
    (This)->lpVtbl -> get_Language(This,ErrorLanguage)

#define IMsmError_get_DatabaseTable(This,ErrorTable)	\
    (This)->lpVtbl -> get_DatabaseTable(This,ErrorTable)

#define IMsmError_get_DatabaseKeys(This,ErrorKeys)	\
    (This)->lpVtbl -> get_DatabaseKeys(This,ErrorKeys)

#define IMsmError_get_ModuleTable(This,ErrorTable)	\
    (This)->lpVtbl -> get_ModuleTable(This,ErrorTable)

#define IMsmError_get_ModuleKeys(This,ErrorKeys)	\
    (This)->lpVtbl -> get_ModuleKeys(This,ErrorKeys)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_Type_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ msmErrorType __RPC_FAR *ErrorType);


void __RPC_STUB IMsmError_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_Path_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ErrorPath);


void __RPC_STUB IMsmError_get_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_Language_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *ErrorLanguage);


void __RPC_STUB IMsmError_get_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_DatabaseTable_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ErrorTable);


void __RPC_STUB IMsmError_get_DatabaseTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_DatabaseKeys_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *ErrorKeys);


void __RPC_STUB IMsmError_get_DatabaseKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_ModuleTable_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *ErrorTable);


void __RPC_STUB IMsmError_get_ModuleTable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmError_get_ModuleKeys_Proxy( 
    IMsmError __RPC_FAR * This,
    /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *ErrorKeys);


void __RPC_STUB IMsmError_get_ModuleKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmError_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IEnumMsmError - enumeration of IMsmError interfaces
// --------------------------------------------------------------------------

#ifndef __IEnumMsmError_INTERFACE_DEFINED__
#define __IEnumMsmError_INTERFACE_DEFINED__

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA829-2C26-11D2-AD65-00A0C9AF11A6")
    IEnumMsmError : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long cFetch,
            /* [out] */ IMsmError __RPC_FAR *__RPC_FAR *rgmsmErrors,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long cSkip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumMsmError __RPC_FAR *__RPC_FAR *pemsmErrors) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMsmErrorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumMsmError __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumMsmError __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumMsmError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumMsmError __RPC_FAR * This,
            /* [in] */ unsigned long cFetch,
            /* [out] */ IMsmError __RPC_FAR *__RPC_FAR *rgmsmErrors,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumMsmError __RPC_FAR * This,
            /* [in] */ unsigned long cSkip);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumMsmError __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumMsmError __RPC_FAR * This,
            /* [retval][out] */ IEnumMsmError __RPC_FAR *__RPC_FAR *pemsmErrors);
        
        END_INTERFACE
    } IEnumMsmErrorVtbl;

    interface IEnumMsmError
    {
        CONST_VTBL struct IEnumMsmErrorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMsmError_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMsmError_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMsmError_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMsmError_Next(This,cFetch,rgmsmErrors,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,rgmsmErrors,pcFetched)

#define IEnumMsmError_Skip(This,cSkip)	\
    (This)->lpVtbl -> Skip(This,cSkip)

#define IEnumMsmError_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMsmError_Clone(This,pemsmErrors)	\
    (This)->lpVtbl -> Clone(This,pemsmErrors)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumMsmError_Next_Proxy( 
    IEnumMsmError __RPC_FAR * This,
    /* [in] */ unsigned long cFetch,
    /* [out] */ IMsmError __RPC_FAR *__RPC_FAR *rgmsmErrors,
    /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);


void __RPC_STUB IEnumMsmError_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmError_Skip_Proxy( 
    IEnumMsmError __RPC_FAR * This,
    /* [in] */ unsigned long cSkip);


void __RPC_STUB IEnumMsmError_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmError_Reset_Proxy( 
    IEnumMsmError __RPC_FAR * This);


void __RPC_STUB IEnumMsmError_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmError_Clone_Proxy( 
    IEnumMsmError __RPC_FAR * This,
    /* [retval][out] */ IEnumMsmError __RPC_FAR *__RPC_FAR *pemsmErrors);


void __RPC_STUB IEnumMsmError_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IEnumMsmError_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IMsmErrors - collection of IMsmError interfaces
// --------------------------------------------------------------------------

#ifndef __IMsmErrors_INTERFACE_DEFINED__
#define __IMsmErrors_INTERFACE_DEFINED__

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA82A-2C26-11D2-AD65-00A0C9AF11A6")
    IMsmErrors : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Item,
            /* [retval][out] */ IMsmError __RPC_FAR *__RPC_FAR *Return) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmErrorsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmErrors __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmErrors __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmErrors __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmErrors __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmErrors __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmErrors __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmErrors __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IMsmErrors __RPC_FAR * This,
            /* [in] */ long Item,
            /* [retval][out] */ IMsmError __RPC_FAR *__RPC_FAR *Return);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMsmErrors __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMsmErrors __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);
        
        END_INTERFACE
    } IMsmErrorsVtbl;

    interface IMsmErrors
    {
        CONST_VTBL struct IMsmErrorsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmErrors_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmErrors_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmErrors_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmErrors_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmErrors_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmErrors_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmErrors_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmErrors_get_Item(This,Item,Return)	\
    (This)->lpVtbl -> get_Item(This,Item,Return)

#define IMsmErrors_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IMsmErrors_get__NewEnum(This,NewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,NewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmErrors_get_Item_Proxy( 
    IMsmErrors __RPC_FAR * This,
    /* [in] */ long Item,
    /* [retval][out] */ IMsmError __RPC_FAR *__RPC_FAR *Return);


void __RPC_STUB IMsmErrors_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmErrors_get_Count_Proxy( 
    IMsmErrors __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IMsmErrors_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmErrors_get__NewEnum_Proxy( 
    IMsmErrors __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);


void __RPC_STUB IMsmErrors_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmErrors_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IMsmDependency - interface for retrieving details on a single module 
//   dependency.
// --------------------------------------------------------------------------

#ifndef __IMsmDependency_INTERFACE_DEFINED__
#define __IMsmDependency_INTERFACE_DEFINED__

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA82B-2C26-11D2-AD65-00A0C9AF11A6")
    IMsmDependency : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Module( 
            /* [retval][out] */ BSTR __RPC_FAR *Module) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Language( 
            /* [retval][out] */ short __RPC_FAR *Language) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Version( 
            /* [retval][out] */ BSTR __RPC_FAR *Version) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmDependencyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmDependency __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmDependency __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmDependency __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmDependency __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmDependency __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmDependency __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmDependency __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Module )( 
            IMsmDependency __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Module);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Language )( 
            IMsmDependency __RPC_FAR * This,
            /* [retval][out] */ short __RPC_FAR *Language);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Version )( 
            IMsmDependency __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Version);
        
        END_INTERFACE
    } IMsmDependencyVtbl;

    interface IMsmDependency
    {
        CONST_VTBL struct IMsmDependencyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmDependency_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmDependency_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmDependency_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmDependency_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmDependency_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmDependency_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmDependency_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmDependency_get_Module(This,Module)	\
    (This)->lpVtbl -> get_Module(This,Module)

#define IMsmDependency_get_Language(This,Language)	\
    (This)->lpVtbl -> get_Language(This,Language)

#define IMsmDependency_get_Version(This,Version)	\
    (This)->lpVtbl -> get_Version(This,Version)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmDependency_get_Module_Proxy( 
    IMsmDependency __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Module);


void __RPC_STUB IMsmDependency_get_Module_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmDependency_get_Language_Proxy( 
    IMsmDependency __RPC_FAR * This,
    /* [retval][out] */ short __RPC_FAR *Language);


void __RPC_STUB IMsmDependency_get_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmDependency_get_Version_Proxy( 
    IMsmDependency __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Version);


void __RPC_STUB IMsmDependency_get_Version_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmDependency_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IEnumMsmDependency - enumeration of IMsmDependency interfaces
// --------------------------------------------------------------------------

#ifndef __IEnumMsmDependency_INTERFACE_DEFINED__
#define __IEnumMsmDependency_INTERFACE_DEFINED__

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA82C-2C26-11D2-AD65-00A0C9AF11A6")
    IEnumMsmDependency : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long cFetch,
            /* [out] */ IMsmDependency __RPC_FAR *__RPC_FAR *rgmsmDependencies,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long cSkip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumMsmDependency __RPC_FAR *__RPC_FAR *pemsmDependencies) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMsmDependencyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumMsmDependency __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumMsmDependency __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumMsmDependency __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumMsmDependency __RPC_FAR * This,
            /* [in] */ unsigned long cFetch,
            /* [out] */ IMsmDependency __RPC_FAR *__RPC_FAR *rgmsmDependencies,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumMsmDependency __RPC_FAR * This,
            /* [in] */ unsigned long cSkip);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumMsmDependency __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumMsmDependency __RPC_FAR * This,
            /* [retval][out] */ IEnumMsmDependency __RPC_FAR *__RPC_FAR *pemsmDependencies);
        
        END_INTERFACE
    } IEnumMsmDependencyVtbl;

    interface IEnumMsmDependency
    {
        CONST_VTBL struct IEnumMsmDependencyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumMsmDependency_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMsmDependency_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMsmDependency_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMsmDependency_Next(This,cFetch,rgmsmDependencies,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,rgmsmDependencies,pcFetched)

#define IEnumMsmDependency_Skip(This,cSkip)	\
    (This)->lpVtbl -> Skip(This,cSkip)

#define IEnumMsmDependency_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMsmDependency_Clone(This,pemsmDependencies)	\
    (This)->lpVtbl -> Clone(This,pemsmDependencies)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumMsmDependency_Next_Proxy( 
    IEnumMsmDependency __RPC_FAR * This,
    /* [in] */ unsigned long cFetch,
    /* [out] */ IMsmDependency __RPC_FAR *__RPC_FAR *rgmsmDependencies,
    /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);


void __RPC_STUB IEnumMsmDependency_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmDependency_Skip_Proxy( 
    IEnumMsmDependency __RPC_FAR * This,
    /* [in] */ unsigned long cSkip);


void __RPC_STUB IEnumMsmDependency_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmDependency_Reset_Proxy( 
    IEnumMsmDependency __RPC_FAR * This);


void __RPC_STUB IEnumMsmDependency_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmDependency_Clone_Proxy( 
    IEnumMsmDependency __RPC_FAR * This,
    /* [retval][out] */ IEnumMsmDependency __RPC_FAR *__RPC_FAR *pemsmDependencies);


void __RPC_STUB IEnumMsmDependency_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IEnumMsmDependency_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IMsmDependencies - collection of IMsmDependency interfaces
// --------------------------------------------------------------------------

#ifndef __IMsmDependencies_INTERFACE_DEFINED__
#define __IMsmDependencies_INTERFACE_DEFINED__

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA82D-2C26-11D2-AD65-00A0C9AF11A6")
    IMsmDependencies : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Item,
            /* [retval][out] */ IMsmDependency __RPC_FAR *__RPC_FAR *Return) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmDependenciesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmDependencies __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmDependencies __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmDependencies __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmDependencies __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmDependencies __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmDependencies __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmDependencies __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IMsmDependencies __RPC_FAR * This,
            /* [in] */ long Item,
            /* [retval][out] */ IMsmDependency __RPC_FAR *__RPC_FAR *Return);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMsmDependencies __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMsmDependencies __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);
        
        END_INTERFACE
    } IMsmDependenciesVtbl;

    interface IMsmDependencies
    {
        CONST_VTBL struct IMsmDependenciesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmDependencies_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmDependencies_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmDependencies_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmDependencies_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmDependencies_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmDependencies_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmDependencies_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmDependencies_get_Item(This,Item,Return)	\
    (This)->lpVtbl -> get_Item(This,Item,Return)

#define IMsmDependencies_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IMsmDependencies_get__NewEnum(This,NewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,NewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmDependencies_get_Item_Proxy( 
    IMsmDependencies __RPC_FAR * This,
    /* [in] */ long Item,
    /* [retval][out] */ IMsmDependency __RPC_FAR *__RPC_FAR *Return);


void __RPC_STUB IMsmDependencies_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmDependencies_get_Count_Proxy( 
    IMsmDependencies __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IMsmDependencies_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmDependencies_get__NewEnum_Proxy( 
    IMsmDependencies __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);


void __RPC_STUB IMsmDependencies_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmDependencies_INTERFACE_DEFINED__ */


// the following interfaces are available only on MergeMod v1.5 or later
#if (_WIN32_MSM >= 150)

// --------------------------------------------------------------------------
// IMsmConfigurableItem - object describing the properties of a single
// configurable item.
// --------------------------------------------------------------------------


#ifndef __IMsmConfigurableItem_INTERFACE_DEFINED__
#define __IMsmConfigurableItem_INTERFACE_DEFINED__


#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4D6E6284-D21D-401E-84F6-909E00B50F71")
    IMsmConfigurableItem : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR __RPC_FAR *Name) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Format( 
            /* [retval][out] */ msmConfigurableItemFormat __RPC_FAR *Format) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Type( 
            /* [retval][out] */ BSTR __RPC_FAR *Type) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Context( 
            /* [retval][out] */ BSTR __RPC_FAR *Context) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DefaultValue( 
            /* [retval][out] */ BSTR __RPC_FAR *DefaultValue) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Attributes( 
            /* [retval][out] */ long __RPC_FAR *Attributes) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_DisplayName( 
            /* [retval][out] */ BSTR __RPC_FAR *DisplayName) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Description( 
            /* [retval][out] */ BSTR __RPC_FAR *Description) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HelpLocation( 
            /* [retval][out] */ BSTR __RPC_FAR *HelpLocation) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_HelpKeyword( 
            /* [retval][out] */ BSTR __RPC_FAR *HelpKeyword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmConfigurableItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmConfigurableItem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmConfigurableItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Name )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Name);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Format )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ msmConfigurableItemFormat __RPC_FAR *Format);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Type )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Type);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Context )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Context);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultValue )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *DefaultValue);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Attributes )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Attributes);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayName )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *DisplayName);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Description )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *Description);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HelpLocation )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *HelpLocation);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HelpKeyword )( 
            IMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *HelpKeyword);
        
        END_INTERFACE
    } IMsmConfigurableItemVtbl;

    interface IMsmConfigurableItem
    {
        CONST_VTBL struct IMsmConfigurableItemVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmConfigurableItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmConfigurableItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmConfigurableItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmConfigurableItem_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmConfigurableItem_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmConfigurableItem_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmConfigurableItem_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmConfigurableItem_get_Name(This,Name)	\
    (This)->lpVtbl -> get_Name(This,Name)

#define IMsmConfigurableItem_get_Format(This,Format)	\
    (This)->lpVtbl -> get_Format(This,Format)

#define IMsmConfigurableItem_get_Type(This,Type)	\
    (This)->lpVtbl -> get_Type(This,Type)

#define IMsmConfigurableItem_get_Context(This,Context)	\
    (This)->lpVtbl -> get_Context(This,Context)

#define IMsmConfigurableItem_get_DefaultValue(This,DefaultValue)	\
    (This)->lpVtbl -> get_DefaultValue(This,DefaultValue)

#define IMsmConfigurableItem_get_Attributes(This,Attributes)	\
    (This)->lpVtbl -> get_Attributes(This,Attributes)

#define IMsmConfigurableItem_get_DisplayName(This,DisplayName)	\
    (This)->lpVtbl -> get_DisplayName(This,DisplayName)

#define IMsmConfigurableItem_get_Description(This,Description)	\
    (This)->lpVtbl -> get_Description(This,Description)

#define IMsmConfigurableItem_get_HelpLocation(This,HelpLocation)	\
    (This)->lpVtbl -> get_HelpLocation(This,HelpLocation)

#define IMsmConfigurableItem_get_HelpKeyword(This,HelpKeyword)	\
    (This)->lpVtbl -> get_HelpKeyword(This,HelpKeyword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_Name_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Name);


void __RPC_STUB IMsmConfigurableItem_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_Format_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ msmConfigurableItemFormat __RPC_FAR *Format);


void __RPC_STUB IMsmConfigurableItem_get_Format_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_Type_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Type);


void __RPC_STUB IMsmConfigurableItem_get_Type_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_Context_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Context);


void __RPC_STUB IMsmConfigurableItem_get_Context_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_DefaultValue_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *DefaultValue);


void __RPC_STUB IMsmConfigurableItem_get_DefaultValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_Attributes_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Attributes);


void __RPC_STUB IMsmConfigurableItem_get_Attributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_DisplayName_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *DisplayName);


void __RPC_STUB IMsmConfigurableItem_get_DisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_Description_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *Description);


void __RPC_STUB IMsmConfigurableItem_get_Description_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_HelpLocation_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *HelpLocation);


void __RPC_STUB IMsmConfigurableItem_get_HelpLocation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItem_get_HelpKeyword_Proxy( 
    IMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *HelpKeyword);


void __RPC_STUB IMsmConfigurableItem_get_HelpKeyword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsmConfigurableItem_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IEnumMsmConfigurableItem - enumerator for configurable items
// --------------------------------------------------------------------------

#ifndef __IEnumMsmConfigurableItem_INTERFACE_DEFINED__
#define __IEnumMsmConfigurableItem_INTERFACE_DEFINED__


#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("832C6969-4826-4C24-A397-B7002D8196E6")
    IEnumMsmConfigurableItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ unsigned long cFetch,
            /* [out] */ IMsmConfigurableItem __RPC_FAR *__RPC_FAR *rgmsmItems,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ unsigned long cSkip) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [retval][out] */ IEnumMsmConfigurableItem __RPC_FAR *__RPC_FAR *pemsmConfigurableItem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumMsmConfigurableItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumMsmConfigurableItem __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumMsmConfigurableItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ unsigned long cFetch,
            /* [out] */ IMsmConfigurableItem __RPC_FAR *__RPC_FAR *rgmsmItems,
            /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumMsmConfigurableItem __RPC_FAR * This,
            /* [in] */ unsigned long cSkip);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumMsmConfigurableItem __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumMsmConfigurableItem __RPC_FAR * This,
            /* [retval][out] */ IEnumMsmConfigurableItem __RPC_FAR *__RPC_FAR *pemsmConfigurableItem);
        
        END_INTERFACE
    } IEnumMsmConfigurableItemVtbl;

    interface IEnumMsmConfigurableItem
    {
        CONST_VTBL struct IEnumMsmConfigurableItemVtbl __RPC_FAR *lpVtbl;
    };

    
#ifdef COBJMACROS


#define IEnumMsmConfigurableItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumMsmConfigurableItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumMsmConfigurableItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumMsmConfigurableItem_Next(This,cFetch,rgmsmItems,pcFetched)	\
    (This)->lpVtbl -> Next(This,cFetch,rgmsmItems,pcFetched)

#define IEnumMsmConfigurableItem_Skip(This,cSkip)	\
    (This)->lpVtbl -> Skip(This,cSkip)

#define IEnumMsmConfigurableItem_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumMsmConfigurableItem_Clone(This,pemsmConfigurableItem)	\
    (This)->lpVtbl -> Clone(This,pemsmConfigurableItem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumMsmConfigurableItem_Next_Proxy( 
    IEnumMsmConfigurableItem __RPC_FAR * This,
    /* [in] */ unsigned long cFetch,
    /* [out] */ IMsmConfigurableItem __RPC_FAR *__RPC_FAR *rgmsmItems,
    /* [retval][out] */ unsigned long __RPC_FAR *pcFetched);


void __RPC_STUB IEnumMsmConfigurableItem_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmConfigurableItem_Skip_Proxy( 
    IEnumMsmConfigurableItem __RPC_FAR * This,
    /* [in] */ unsigned long cSkip);


void __RPC_STUB IEnumMsmConfigurableItem_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmConfigurableItem_Reset_Proxy( 
    IEnumMsmConfigurableItem __RPC_FAR * This);


void __RPC_STUB IEnumMsmConfigurableItem_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumMsmConfigurableItem_Clone_Proxy( 
    IEnumMsmConfigurableItem __RPC_FAR * This,
    /* [retval][out] */ IEnumMsmConfigurableItem __RPC_FAR *__RPC_FAR *pemsmConfigurableItem);


void __RPC_STUB IEnumMsmConfigurableItem_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumMsmConfigurableItem_INTERFACE_DEFINED__ */


// --------------------------------------------------------------------------
// IMsmConfigurableItems - collection of configurable items
// --------------------------------------------------------------------------


#ifndef __IMsmConfigurableItems_INTERFACE_DEFINED__
#define __IMsmConfigurableItems_INTERFACE_DEFINED__

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55BF723C-9A0D-463E-B42B-B4FBC7BE3C7C")
    IMsmConfigurableItems : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ long Item,
            /* [retval][out] */ IMsmConfigurableItem __RPC_FAR *__RPC_FAR *Return) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long __RPC_FAR *Count) = 0;
        
        virtual /* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmConfigurableItemsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmConfigurableItems __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmConfigurableItems __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [in] */ long Item,
            /* [retval][out] */ IMsmConfigurableItem __RPC_FAR *__RPC_FAR *Return);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *Count);
        
        /* [hidden][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IMsmConfigurableItems __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);
        
        END_INTERFACE
    } IMsmConfigurableItemsVtbl;

    interface IMsmConfigurableItems
    {
        CONST_VTBL struct IMsmConfigurableItemsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmConfigurableItems_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmConfigurableItems_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmConfigurableItems_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmConfigurableItems_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmConfigurableItems_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmConfigurableItems_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmConfigurableItems_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmConfigurableItems_get_Item(This,Item,Return)	\
    (This)->lpVtbl -> get_Item(This,Item,Return)

#define IMsmConfigurableItems_get_Count(This,Count)	\
    (This)->lpVtbl -> get_Count(This,Count)

#define IMsmConfigurableItems_get__NewEnum(This,NewEnum)	\
    (This)->lpVtbl -> get__NewEnum(This,NewEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItems_get_Item_Proxy( 
    IMsmConfigurableItems __RPC_FAR * This,
    /* [in] */ long Item,
    /* [retval][out] */ IMsmConfigurableItem __RPC_FAR *__RPC_FAR *Return);


void __RPC_STUB IMsmConfigurableItems_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItems_get_Count_Proxy( 
    IMsmConfigurableItems __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *Count);


void __RPC_STUB IMsmConfigurableItems_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmConfigurableItems_get__NewEnum_Proxy( 
    IMsmConfigurableItems __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *NewEnum);


void __RPC_STUB IMsmConfigurableItems_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsmConfigurableItems_INTERFACE_DEFINED__ */



// --------------------------------------------------------------------------
// IMsmConfigureModule - callback interface called by the MergeMod object. 
// Allows the client to provide merge configuration information during the
// merge process.
// --------------------------------------------------------------------------

#ifndef __IMsmConfigureModule_INTERFACE_DEFINED__
#define __IMsmConfigureModule_INTERFACE_DEFINED__

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AC013209-18A7-4851-8A21-2353443D70A0")
    IMsmConfigureModule : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProvideTextData( 
            /* [in] */ const BSTR Name,
            /* [retval][out] */ BSTR __RPC_FAR *ConfigData) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ProvideIntegerData( 
            /* [in] */ const BSTR Name,
            /* [retval][out] */ long __RPC_FAR *ConfigData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmConfigureModuleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmConfigureModule __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmConfigureModule __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProvideTextData )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [in] */ const BSTR Name,
            /* [retval][out] */ BSTR __RPC_FAR *ConfigData);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProvideIntegerData )( 
            IMsmConfigureModule __RPC_FAR * This,
            /* [in] */ const BSTR Name,
            /* [retval][out] */ long __RPC_FAR *ConfigData);
        
        END_INTERFACE
    } IMsmConfigureModuleVtbl;

    interface IMsmConfigureModule
    {
        CONST_VTBL struct IMsmConfigureModuleVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmConfigureModule_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmConfigureModule_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmConfigureModule_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmConfigureModule_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmConfigureModule_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmConfigureModule_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmConfigureModule_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmConfigureModule_ProvideTextData(This,Name,ConfigData)	\
    (This)->lpVtbl -> ProvideTextData(This,Name,ConfigData)

#define IMsmConfigureModule_ProvideIntegerData(This,Name,ConfigData)	\
    (This)->lpVtbl -> ProvideIntegerData(This,Name,ConfigData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmConfigureModule_ProvideTextData_Proxy( 
    IMsmConfigureModule __RPC_FAR * This,
    /* [in] */ const BSTR Name,
    /* [retval][out] */ BSTR __RPC_FAR *ConfigData);


void __RPC_STUB IMsmConfigureModule_ProvideTextData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmConfigureModule_ProvideIntegerData_Proxy( 
    IMsmConfigureModule __RPC_FAR * This,
    /* [in] */ const BSTR Name,
    /* [retval][out] */ long __RPC_FAR *ConfigData);


void __RPC_STUB IMsmConfigureModule_ProvideIntegerData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsmConfigureModule_INTERFACE_DEFINED__ */


#endif // _MSM_WIN32 >= 150

// --------------------------------------------------------------------------
// IMsmMerge - primary interface to the MergeMod object. Allows the client
// to open and close databases, perform merges, retrieve the results
// of a merge, control the creation of a debug-level log, and extract the
// files from a module to disk.
// --------------------------------------------------------------------------

#ifndef __IMsmMerge_INTERFACE_DEFINED__
#define __IMsmMerge_INTERFACE_DEFINED__

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("0ADDA82E-2C26-11D2-AD65-00A0C9AF11A6")
    IMsmMerge : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenDatabase( 
            /* [in] */ const BSTR Path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenModule( 
            /* [in] */ const BSTR Path,
            /* [in] */ const short Language) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseDatabase( 
            /* [in] */ const VARIANT_BOOL Commit) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseModule( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenLog( 
            /* [in] */ const BSTR Path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseLog( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ const BSTR Message) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Errors( 
            /* [retval][out] */ IMsmErrors __RPC_FAR *__RPC_FAR *Errors) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Dependencies( 
            /* [retval][out] */ IMsmDependencies __RPC_FAR *__RPC_FAR *Dependencies) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Merge( 
            /* [in] */ const BSTR Feature,
            /* [in] */ const BSTR RedirectDir) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ const BSTR Feature) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtractCAB( 
            /* [in] */ const BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtractFiles( 
            /* [in] */ const BSTR Path) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmMergeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmMerge __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmMerge __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmMerge __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDatabase )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenModule )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Path,
            /* [in] */ const short Language);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseDatabase )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const VARIANT_BOOL Commit);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseModule )( 
            IMsmMerge __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenLog )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseLog )( 
            IMsmMerge __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Log )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Message);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Errors )( 
            IMsmMerge __RPC_FAR * This,
            /* [retval][out] */ IMsmErrors __RPC_FAR *__RPC_FAR *Errors);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Dependencies )( 
            IMsmMerge __RPC_FAR * This,
            /* [retval][out] */ IMsmDependencies __RPC_FAR *__RPC_FAR *Dependencies);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Merge )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Feature,
            /* [in] */ const BSTR RedirectDir);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Feature);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExtractCAB )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExtractFiles )( 
            IMsmMerge __RPC_FAR * This,
            /* [in] */ const BSTR Path);
        
        END_INTERFACE
    } IMsmMergeVtbl;

    interface IMsmMerge
    {
        CONST_VTBL struct IMsmMergeVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmMerge_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmMerge_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmMerge_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmMerge_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmMerge_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmMerge_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmMerge_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmMerge_OpenDatabase(This,Path)	\
    (This)->lpVtbl -> OpenDatabase(This,Path)

#define IMsmMerge_OpenModule(This,Path,Language)	\
    (This)->lpVtbl -> OpenModule(This,Path,Language)

#define IMsmMerge_CloseDatabase(This,Commit)	\
    (This)->lpVtbl -> CloseDatabase(This,Commit)

#define IMsmMerge_CloseModule(This)	\
    (This)->lpVtbl -> CloseModule(This)

#define IMsmMerge_OpenLog(This,Path)	\
    (This)->lpVtbl -> OpenLog(This,Path)

#define IMsmMerge_CloseLog(This)	\
    (This)->lpVtbl -> CloseLog(This)

#define IMsmMerge_Log(This,Message)	\
    (This)->lpVtbl -> Log(This,Message)

#define IMsmMerge_get_Errors(This,Errors)	\
    (This)->lpVtbl -> get_Errors(This,Errors)

#define IMsmMerge_get_Dependencies(This,Dependencies)	\
    (This)->lpVtbl -> get_Dependencies(This,Dependencies)

#define IMsmMerge_Merge(This,Feature,RedirectDir)	\
    (This)->lpVtbl -> Merge(This,Feature,RedirectDir)

#define IMsmMerge_Connect(This,Feature)	\
    (This)->lpVtbl -> Connect(This,Feature)

#define IMsmMerge_ExtractCAB(This,FileName)	\
    (This)->lpVtbl -> ExtractCAB(This,FileName)

#define IMsmMerge_ExtractFiles(This,Path)	\
    (This)->lpVtbl -> ExtractFiles(This,Path)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_OpenDatabase_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Path);


void __RPC_STUB IMsmMerge_OpenDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_OpenModule_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Path,
    /* [in] */ const short Language);


void __RPC_STUB IMsmMerge_OpenModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_CloseDatabase_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const VARIANT_BOOL Commit);


void __RPC_STUB IMsmMerge_CloseDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_CloseModule_Proxy( 
    IMsmMerge __RPC_FAR * This);


void __RPC_STUB IMsmMerge_CloseModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_OpenLog_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Path);


void __RPC_STUB IMsmMerge_OpenLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_CloseLog_Proxy( 
    IMsmMerge __RPC_FAR * This);


void __RPC_STUB IMsmMerge_CloseLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_Log_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Message);


void __RPC_STUB IMsmMerge_Log_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmMerge_get_Errors_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [retval][out] */ IMsmErrors __RPC_FAR *__RPC_FAR *Errors);


void __RPC_STUB IMsmMerge_get_Errors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmMerge_get_Dependencies_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [retval][out] */ IMsmDependencies __RPC_FAR *__RPC_FAR *Dependencies);


void __RPC_STUB IMsmMerge_get_Dependencies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_Merge_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Feature,
    /* [in] */ const BSTR RedirectDir);


void __RPC_STUB IMsmMerge_Merge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_Connect_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Feature);


void __RPC_STUB IMsmMerge_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_ExtractCAB_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR FileName);


void __RPC_STUB IMsmMerge_ExtractCAB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge_ExtractFiles_Proxy( 
    IMsmMerge __RPC_FAR * This,
    /* [in] */ const BSTR Path);


void __RPC_STUB IMsmMerge_ExtractFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMsmMerge_INTERFACE_DEFINED__ */

// --------------------------------------------------------------------------
// IMsmGetFiles - secondary interface to the MergeMod object, allows
// the client to retrieve the files needed in a particular language of the
// module. Requires certain actions be performed via the IMsmMerge interface
// before some calls on this interface will return valid results.
// --------------------------------------------------------------------------


#ifndef __IMsmGetFiles_INTERFACE_DEFINED__
#define __IMsmGetFiles_INTERFACE_DEFINED__


#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("7041AE26-2D78-11d2-888A-00A0C981B015")
    IMsmGetFiles : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModuleFiles( 
            /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *Files) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMsmGetFilesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmGetFiles __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmGetFiles __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmGetFiles __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmGetFiles __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmGetFiles __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmGetFiles __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmGetFiles __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ModuleFiles )( 
            IMsmGetFiles __RPC_FAR * This,
            /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *Files);
        
        END_INTERFACE
    } IMsmGetFilesVtbl;

    interface IMsmGetFiles
    {
        CONST_VTBL struct IMsmGetFilesVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmGetFiles_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmGetFiles_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmGetFiles_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmGetFiles_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmGetFiles_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmGetFiles_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmGetFiles_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmGetFiles_get_ModuleFiles(This,Files)	\
    (This)->lpVtbl -> get_ModuleFiles(This,Files)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmGetFiles_get_ModuleFiles_Proxy( 
    IMsmGetFiles __RPC_FAR * This,
    /* [retval][out] */ IMsmStrings __RPC_FAR *__RPC_FAR *Files);


void __RPC_STUB IMsmGetFiles_get_ModuleFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmGetFiles_INTERFACE_DEFINED__ */



// The following interface is available only on MergeMod v1.5 and later
#if (_WIN32_MSM >= 150)

// --------------------------------------------------------------------------
// IMsmMerge2 - primary interface to the MsmMerge2 object. Allows the client
// to open and close databases, perform merges, retrieve the results
// of a merge, control the creation of a debug-level log, and extract the
// files from a module to disk. Extends the original object by adding
// LFN support and configurable module support.
// --------------------------------------------------------------------------

#ifndef __IMsmMerge2_INTERFACE_DEFINED__
#define __IMsmMerge2_INTERFACE_DEFINED__




#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("351A72AB-21CB-47AB-B7AA-C4D7B02EA305")
    IMsmMerge2 : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenDatabase( 
            /* [in] */ const BSTR Path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenModule( 
            /* [in] */ const BSTR Path,
            /* [in] */ const short Language) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseDatabase( 
            /* [in] */ const VARIANT_BOOL Commit) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseModule( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE OpenLog( 
            /* [in] */ const BSTR Path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CloseLog( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Log( 
            /* [in] */ const BSTR Message) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Errors( 
            /* [retval][out] */ IMsmErrors __RPC_FAR *__RPC_FAR *Errors) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Dependencies( 
            /* [retval][out] */ IMsmDependencies __RPC_FAR *__RPC_FAR *Dependencies) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Merge( 
            /* [in] */ const BSTR Feature,
            /* [in] */ const BSTR RedirectDir) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ const BSTR Feature) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtractCAB( 
            /* [in] */ const BSTR FileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtractFiles( 
            /* [in] */ const BSTR Path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE MergeEx( 
            /* [in] */ const BSTR Feature,
            /* [in] */ const BSTR RedirectDir,
            /* [in] */ IUnknown __RPC_FAR *pConfiguration) = 0;
        
      
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ExtractFilesEx( 
            /* [in] */ const BSTR Path,
            /* [in] */ VARIANT_BOOL fLongFileNames,
            /* [out] */ IMsmStrings __RPC_FAR *__RPC_FAR *pFilePaths) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ConfigurableItems( 
            /* [retval][out] */ IMsmConfigurableItems __RPC_FAR *__RPC_FAR *ConfigurableItems) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CreateSourceImage( 
            /* [in] */ const BSTR Path,
            /* [in] */ VARIANT_BOOL fLongFileNames,
            /* [out] */ IMsmStrings __RPC_FAR *__RPC_FAR *pFilePaths) = 0;

        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ModuleFiles( 
            /* [retval][out] */ IMsmStrings **Files) = 0;        
    };
    
#else 	/* C style interface */

    typedef struct IMsmMerge2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMsmMerge2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMsmMerge2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenDatabase )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenModule )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Path,
            /* [in] */ const short Language);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseDatabase )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const VARIANT_BOOL Commit);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseModule )( 
            IMsmMerge2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenLog )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseLog )( 
            IMsmMerge2 __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Log )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Message);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Errors )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [retval][out] */ IMsmErrors __RPC_FAR *__RPC_FAR *Errors);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Dependencies )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [retval][out] */ IMsmDependencies __RPC_FAR *__RPC_FAR *Dependencies);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Merge )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Feature,
            /* [in] */ const BSTR RedirectDir);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Connect )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Feature);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExtractCAB )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR FileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExtractFiles )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MergeEx )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Feature,
            /* [in] */ const BSTR RedirectDir,
            /* [in] */ IMsmConfigureModule __RPC_FAR *pConfiguration);
   
      /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExtractFilesEx )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Path,
            /* [in] */ VARIANT_BOOL fLongFileNames,
            /* [out] */ IMsmStrings __RPC_FAR *__RPC_FAR *pFilePaths);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConfigurableItems )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [retval][out] */ IMsmConfigurableItems __RPC_FAR *__RPC_FAR *ConfigurableItems);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSourceImage )( 
            IMsmMerge2 __RPC_FAR * This,
            /* [in] */ const BSTR Path,
            /* [in] */ VARIANT_BOOL fLongFileNames,
            /* [out] */ IMsmStrings __RPC_FAR *__RPC_FAR *pFilePaths);

        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_ModuleFiles )( 
            IMsmMerge2 * This,
            /* [retval][out] */ IMsmStrings **Files);
        
        END_INTERFACE
    } IMsmMerge2Vtbl;

    interface IMsmMerge2
    {
        CONST_VTBL struct IMsmMerge2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMsmMerge2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMsmMerge2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMsmMerge2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMsmMerge2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMsmMerge2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMsmMerge2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMsmMerge2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMsmMerge2_OpenDatabase(This,Path)	\
    (This)->lpVtbl -> OpenDatabase(This,Path)

#define IMsmMerge2_OpenModule(This,Path,Language)	\
    (This)->lpVtbl -> OpenModule(This,Path,Language)

#define IMsmMerge2_CloseDatabase(This,Commit)	\
    (This)->lpVtbl -> CloseDatabase(This,Commit)

#define IMsmMerge2_CloseModule(This)	\
    (This)->lpVtbl -> CloseModule(This)

#define IMsmMerge2_OpenLog(This,Path)	\
    (This)->lpVtbl -> OpenLog(This,Path)

#define IMsmMerge2_CloseLog(This)	\
    (This)->lpVtbl -> CloseLog(This)

#define IMsmMerge2_Log(This,Message)	\
    (This)->lpVtbl -> Log(This,Message)

#define IMsmMerge2_get_Errors(This,Errors)	\
    (This)->lpVtbl -> get_Errors(This,Errors)

#define IMsmMerge2_get_Dependencies(This,Dependencies)	\
    (This)->lpVtbl -> get_Dependencies(This,Dependencies)

#define IMsmMerge2_Merge(This,Feature,RedirectDir)	\
    (This)->lpVtbl -> Merge(This,Feature,RedirectDir)

#define IMsmMerge2_Connect(This,Feature)	\
    (This)->lpVtbl -> Connect(This,Feature)

#define IMsmMerge2_ExtractCAB(This,FileName)	\
    (This)->lpVtbl -> ExtractCAB(This,FileName)

#define IMsmMerge2_ExtractFiles(This,Path)	\
    (This)->lpVtbl -> ExtractFiles(This,Path)

#define IMsmMerge2_MergeEx(This,Feature,RedirectDir,pConfiguration)	\
    (This)->lpVtbl -> MergeEx(This,Feature,RedirectDir,pConfiguration)

#define IMsmMerge2_ExtractFilesEx(This,Path,fLongFileNames,pFilePaths)	\
    (This)->lpVtbl -> ExtractFilesEx(This,Path,fLongFileNames,pFilePaths)

#define IMsmMerge2_get_ConfigurableItems(This,ConfigurableItems)	\
    (This)->lpVtbl -> get_ConfigurableItems(This,ConfigurableItems)

#define IMsmMerge2_CreateSourceImage(This,Path,fLongFileNames,pFilePaths)	\
    (This)->lpVtbl -> CreateSourceImage(This,Path,fLongFileNames,pFilePaths)

#define IMsmMerge2_get_ModuleFiles(This,Files)	\
    (This)->lpVtbl -> get_ModuleFiles(This,Files)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_OpenDatabase_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Path);


void __RPC_STUB IMsmMerge2_OpenDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_OpenModule_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Path,
    /* [in] */ const short Language);


void __RPC_STUB IMsmMerge2_OpenModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_CloseDatabase_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const VARIANT_BOOL Commit);


void __RPC_STUB IMsmMerge2_CloseDatabase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_CloseModule_Proxy( 
    IMsmMerge2 __RPC_FAR * This);


void __RPC_STUB IMsmMerge2_CloseModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_OpenLog_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Path);


void __RPC_STUB IMsmMerge2_OpenLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_CloseLog_Proxy( 
    IMsmMerge2 __RPC_FAR * This);


void __RPC_STUB IMsmMerge2_CloseLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_Log_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Message);


void __RPC_STUB IMsmMerge2_Log_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_get_Errors_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [retval][out] */ IMsmErrors __RPC_FAR *__RPC_FAR *Errors);


void __RPC_STUB IMsmMerge2_get_Errors_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_get_Dependencies_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [retval][out] */ IMsmDependencies __RPC_FAR *__RPC_FAR *Dependencies);


void __RPC_STUB IMsmMerge2_get_Dependencies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_Merge_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Feature,
    /* [in] */ const BSTR RedirectDir);


void __RPC_STUB IMsmMerge2_Merge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_Connect_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Feature);


void __RPC_STUB IMsmMerge2_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_ExtractCAB_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR FileName);


void __RPC_STUB IMsmMerge2_ExtractCAB_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_ExtractFiles_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Path);


void __RPC_STUB IMsmMerge2_ExtractFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_MergeEx_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Feature,
    /* [in] */ const BSTR RedirectDir,
    /* [in] */ IMsmConfigureModule __RPC_FAR *pConfiguration);


void __RPC_STUB IMsmMerge2_MergeEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_ExtractFilesEx_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Path,
    /* [in] */ VARIANT_BOOL fLongFileNames,
    /* [out] */ IMsmStrings __RPC_FAR *__RPC_FAR *pFilePaths);


void __RPC_STUB IMsmMerge2_ExtractFilesEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_get_ConfigurableItems_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [retval][out] */ IMsmConfigurableItems __RPC_FAR *__RPC_FAR *
ConfigurableItems);


void __RPC_STUB IMsmMerge2_get_ConfigurableItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE 
IMsmMerge2_CreateSourceImage_Proxy( 
    IMsmMerge2 __RPC_FAR * This,
    /* [in] */ const BSTR Path,
    /* [in] */ VARIANT_BOOL fLongFileNames,
    /* [out] */ IMsmStrings __RPC_FAR *__RPC_FAR *pFilePaths);


void __RPC_STUB IMsmMerge2_CreateSourceImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMsmMerge2_get_ModuleFiles_Proxy( 
    IMsmMerge2 * This,
    /* [retval][out] */ IMsmStrings **Files);


void __RPC_STUB IMsmMerge2_get_ModuleFiles_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);

#endif 	/* __IMsmMerge2_INTERFACE_DEFINED__ */


#endif // _WIN32_MSM >= 150


// --------------------------------------------------------------------------
// TypeLib definitions
// --------------------------------------------------------------------------

#ifndef __MsmMergeTypeLib_LIBRARY_DEFINED__
#define __MsmMergeTypeLib_LIBRARY_DEFINED__

#ifdef __cplusplus
class DECLSPEC_UUID("0ADDA830-2C26-11D2-AD65-00A0C9AF11A6")
MsmMerge;
#endif

// the following class is available only on MergeMod v1.5 or later
#if (_WIN32_MSM >= 150)

#ifdef __cplusplus

class DECLSPEC_UUID("F94985D5-29F9-4743-9805-99BC3F35B678")
MsmMerge2;
#endif
#endif // _WIN32_MSM >= 150

#endif /* __MsmMergeTypeLib_LIBRARY_DEFINED__ */


// --------------------------------------------------------------------------
// Additional Prototypes for ALL interfaces
// --------------------------------------------------------------------------

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 


#ifdef __cplusplus
}
#endif

// --------------------------------------------------------------------------
// MergeMod Interface IDs
// --------------------------------------------------------------------------
/* [local] */ 


DEFINE_GUID(IID_IEnumMsmString, 0x0ADDA826,0x2C26,0x11D2, 0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6);
DEFINE_GUID(IID_IMsmStrings, 0x0ADDA827,0x2C26,0x11D2, 0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6);
DEFINE_GUID(IID_IMsmError, 0x0ADDA828,0x2C26,0x11D2, 0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6);
DEFINE_GUID(IID_IEnumMsmError, 0x0ADDA829,0x2C26,0x11D2, 0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6);
DEFINE_GUID(IID_IMsmErrors, 0x0ADDA82A,0x2C26,0x11D2, 0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6);
DEFINE_GUID(IID_IMsmDependency, 0x0ADDA82B,0x2C26,0x11D2, 0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6);
DEFINE_GUID(IID_IEnumMsmDependency, 0x0ADDA82C,0x2C26,0x11D2, 0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6);
DEFINE_GUID(IID_IMsmDependencies, 0x0ADDA82D,0x2C26,0x11D2, 0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6);
DEFINE_GUID(IID_IMsmMerge, 0x0ADDA82E,0x2C26,0x11D2, 0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6);
DEFINE_GUID(IID_IMsmGetFiles, 0x7041ae26, 0x2d78, 0x11d2, 0x88, 0x8a, 0x0, 0xa0, 0xc9, 0x81, 0xb0, 0x15);

DEFINE_GUID(LIBID_MsmMergeTypeLib, 0x0ADDA82F,0x2C26,0x11D2, 0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6);
DEFINE_GUID(CLSID_MsmMerge, 0x0ADDA830,0x2C26,0x11D2, 0xAD,0x65,0x00,0xA0,0xC9,0xAF,0x11,0xA6);

#if (_WIN32_MSM >= 150)
DEFINE_GUID(IID_IMsmMerge2, 0x351A72AB, 0x21CB, 0x47AB, 0xB7, 0xAA, 0xC4, 0xD7, 0xB0, 0x2E, 0xA3, 0x05);
DEFINE_GUID(IID_IMsmConfigurableItem, 0x4D6E6284, 0xD21D, 0x401E, 0x84, 0xF6, 0x90, 0x9E, 0x00, 0xB5, 0x0F, 0x71);
DEFINE_GUID(IID_IEnumMsmConfigurableItem, 0x832C6969, 0x4826, 0x4C24, 0xA3, 0x97, 0xB7, 0x00, 0x2D, 0x81, 0x96, 0xE6);
DEFINE_GUID(IID_IMsmConfigurableItems, 0x55BF723C, 0x9A0D, 0x463E, 0xB4, 0x2B, 0xB4, 0xFB, 0xC7, 0xBE, 0x3C, 0x7C);
DEFINE_GUID(IID_IMsmConfigureModule, 0xAC013209, 0x18A7, 0x4851, 0x8A, 0x21, 0x23, 0x53, 0x44, 0x3D, 0x70, 0xA0);
DEFINE_GUID(CLSID_MsmMerge2, 0xF94985D5,0x29F9,0x4743, 0x98,0x05,0x99,0xBC,0x3F,0x35,0xB6,0x78);
#endif

#endif // __mergemod_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\metahost.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0499 */
/* Compiler settings for metahost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __metahost_h__
#define __metahost_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICLRMetaHost_FWD_DEFINED__
#define __ICLRMetaHost_FWD_DEFINED__
typedef interface ICLRMetaHost ICLRMetaHost;
#endif 	/* __ICLRMetaHost_FWD_DEFINED__ */


#ifndef __ICLRMetaHostPolicy_FWD_DEFINED__
#define __ICLRMetaHostPolicy_FWD_DEFINED__
typedef interface ICLRMetaHostPolicy ICLRMetaHostPolicy;
#endif 	/* __ICLRMetaHostPolicy_FWD_DEFINED__ */


#ifndef __ICLRProfiling_FWD_DEFINED__
#define __ICLRProfiling_FWD_DEFINED__
typedef interface ICLRProfiling ICLRProfiling;
#endif 	/* __ICLRProfiling_FWD_DEFINED__ */


#ifndef __ICLRDebuggingLibraryProvider_FWD_DEFINED__
#define __ICLRDebuggingLibraryProvider_FWD_DEFINED__
typedef interface ICLRDebuggingLibraryProvider ICLRDebuggingLibraryProvider;
#endif 	/* __ICLRDebuggingLibraryProvider_FWD_DEFINED__ */


#ifndef __ICLRDebugging_FWD_DEFINED__
#define __ICLRDebugging_FWD_DEFINED__
typedef interface ICLRDebugging ICLRDebugging;
#endif 	/* __ICLRDebugging_FWD_DEFINED__ */


#ifndef __ICLRRuntimeInfo_FWD_DEFINED__
#define __ICLRRuntimeInfo_FWD_DEFINED__
typedef interface ICLRRuntimeInfo ICLRRuntimeInfo;
#endif 	/* __ICLRRuntimeInfo_FWD_DEFINED__ */


#ifndef __ICLRStrongName_FWD_DEFINED__
#define __ICLRStrongName_FWD_DEFINED__
typedef interface ICLRStrongName ICLRStrongName;
#endif 	/* __ICLRStrongName_FWD_DEFINED__ */


#ifndef __ICLRMetaHost_FWD_DEFINED__
#define __ICLRMetaHost_FWD_DEFINED__
typedef interface ICLRMetaHost ICLRMetaHost;
#endif 	/* __ICLRMetaHost_FWD_DEFINED__ */


#ifndef __ICLRMetaHostPolicy_FWD_DEFINED__
#define __ICLRMetaHostPolicy_FWD_DEFINED__
typedef interface ICLRMetaHostPolicy ICLRMetaHostPolicy;
#endif 	/* __ICLRMetaHostPolicy_FWD_DEFINED__ */


#ifndef __ICLRProfiling_FWD_DEFINED__
#define __ICLRProfiling_FWD_DEFINED__
typedef interface ICLRProfiling ICLRProfiling;
#endif 	/* __ICLRProfiling_FWD_DEFINED__ */


#ifndef __ICLRDebuggingLibraryProvider_FWD_DEFINED__
#define __ICLRDebuggingLibraryProvider_FWD_DEFINED__
typedef interface ICLRDebuggingLibraryProvider ICLRDebuggingLibraryProvider;
#endif 	/* __ICLRDebuggingLibraryProvider_FWD_DEFINED__ */


#ifndef __ICLRDebugging_FWD_DEFINED__
#define __ICLRDebugging_FWD_DEFINED__
typedef interface ICLRDebugging ICLRDebugging;
#endif 	/* __ICLRDebugging_FWD_DEFINED__ */


#ifndef __ICLRRuntimeInfo_FWD_DEFINED__
#define __ICLRRuntimeInfo_FWD_DEFINED__
typedef interface ICLRRuntimeInfo ICLRRuntimeInfo;
#endif 	/* __ICLRRuntimeInfo_FWD_DEFINED__ */


#ifndef __ICLRStrongName_FWD_DEFINED__
#define __ICLRStrongName_FWD_DEFINED__
typedef interface ICLRStrongName ICLRStrongName;
#endif 	/* __ICLRStrongName_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "ocidl.h"
#include "mscoree.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_metahost_0000_0000 */
/* [local] */ 

STDAPI CLRCreateInstance(REFCLSID clsid, REFIID riid, /*iid_is(riid)*/ LPVOID *ppInterface);
EXTERN_GUID(CLSID_CLRStrongName, 0xB79B0ACD, 0xF5CD, 0x409b, 0xB5, 0xA5, 0xA1, 0x62, 0x44, 0x61, 0x0B, 0x92);
EXTERN_GUID(IID_ICLRMetaHost, 0xD332DB9E, 0xB9B3, 0x4125, 0x82, 0x07, 0xA1, 0x48, 0x84, 0xF5, 0x32, 0x16);
EXTERN_GUID(CLSID_CLRMetaHost, 0x9280188d, 0xe8e, 0x4867, 0xb3, 0xc, 0x7f, 0xa8, 0x38, 0x84, 0xe8, 0xde);
EXTERN_GUID(IID_ICLRMetaHostPolicy, 0xE2190695, 0x77B2, 0x492e, 0x8E, 0x14, 0xC4, 0xB3, 0xA7, 0xFD, 0xD5, 0x93);
EXTERN_GUID(CLSID_CLRMetaHostPolicy, 0x2ebcd49a, 0x1b47, 0x4a61, 0xb1, 0x3a, 0x4a, 0x3, 0x70, 0x1e, 0x59, 0x4b);
EXTERN_GUID(IID_ICLRDebugging, 0xd28f3c5a, 0x9634, 0x4206, 0xa5, 0x9, 0x47, 0x75, 0x52, 0xee, 0xfb, 0x10);
EXTERN_GUID(CLSID_CLRDebugging, 0xbacc578d, 0xfbdd, 0x48a4, 0x96, 0x9f, 0x2, 0xd9, 0x32, 0xb7, 0x46, 0x34);
EXTERN_GUID(IID_ICLRRuntimeInfo, 0xBD39D1D2, 0xBA2F, 0x486a, 0x89, 0xB0, 0xB4, 0xB0, 0xCB, 0x46, 0x68, 0x91);
EXTERN_GUID(IID_ICLRStrongName, 0x9FD93CCF, 0x3280, 0x4391, 0xB3, 0xA9, 0x96, 0xE1, 0xCD, 0xE7, 0x7C, 0x8D);
EXTERN_GUID(CLSID_CLRDebuggingLegacy, 0xDF8395B5, 0xA4BA, 0x450b, 0xA7, 0x7C, 0xA9, 0xA4, 0x77, 0x62, 0xC5, 0x20);
EXTERN_GUID(CLSID_CLRProfiling, 0xbd097ed8, 0x733e, 0x43fe, 0x8e, 0xd7, 0xa9, 0x5f, 0xf9, 0xa8, 0x44, 0x8c);
EXTERN_GUID(IID_ICLRProfiling, 0xb349abe3, 0xb56f, 0x4689, 0xbf, 0xcd, 0x76, 0xbf, 0x39, 0xd8, 0x88, 0xea);
EXTERN_GUID(IID_ICLRDebuggingLibraryProvider, 0x3151c08d, 0x4d09, 0x4f9b, 0x88, 0x38, 0x28, 0x80, 0xbf, 0x18, 0xfe, 0x51);
typedef HRESULT ( __stdcall *CLRCreateInstanceFnPtr )( 
    REFCLSID clsid,
    REFIID riid,
    LPVOID *ppInterface);

typedef HRESULT ( __stdcall *CreateInterfaceFnPtr )( 
    REFCLSID clsid,
    REFIID riid,
    LPVOID *ppInterface);


typedef HRESULT ( __stdcall *CallbackThreadSetFnPtr )( void);

typedef HRESULT ( __stdcall *CallbackThreadUnsetFnPtr )( void);

typedef void ( __stdcall *RuntimeLoadedCallbackFnPtr )( 
    ICLRRuntimeInfo *pRuntimeInfo,
    CallbackThreadSetFnPtr pfnCallbackThreadSet,
    CallbackThreadUnsetFnPtr pfnCallbackThreadUnset);



extern RPC_IF_HANDLE __MIDL_itf_metahost_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_metahost_0000_0000_v0_0_s_ifspec;

#ifndef __ICLRMetaHost_INTERFACE_DEFINED__
#define __ICLRMetaHost_INTERFACE_DEFINED__

/* interface ICLRMetaHost */
/* [object][local][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRMetaHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D332DB9E-B9B3-4125-8207-A14884F53216")
    ICLRMetaHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRuntime( 
            /* [in] */ LPCWSTR pwzVersion,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID *ppRuntime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionFromFile( 
            /* [in] */ LPCWSTR pwzFilePath,
            /* [size_is][out] */ 
            __out_ecount_full(*pcchBuffer)  LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateInstalledRuntimes( 
            /* [retval][out] */ IEnumUnknown **ppEnumerator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateLoadedRuntimes( 
            /* [in] */ HANDLE hndProcess,
            /* [retval][out] */ IEnumUnknown **ppEnumerator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RequestRuntimeLoadedNotification( 
            /* [in] */ RuntimeLoadedCallbackFnPtr pCallbackFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryLegacyV2RuntimeBinding( 
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID *ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExitProcess( 
            /* [in] */ INT32 iExitCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRMetaHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRMetaHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRMetaHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRMetaHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRuntime )( 
            ICLRMetaHost * This,
            /* [in] */ LPCWSTR pwzVersion,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID *ppRuntime);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionFromFile )( 
            ICLRMetaHost * This,
            /* [in] */ LPCWSTR pwzFilePath,
            /* [size_is][out] */ 
            __out_ecount_full(*pcchBuffer)  LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateInstalledRuntimes )( 
            ICLRMetaHost * This,
            /* [retval][out] */ IEnumUnknown **ppEnumerator);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateLoadedRuntimes )( 
            ICLRMetaHost * This,
            /* [in] */ HANDLE hndProcess,
            /* [retval][out] */ IEnumUnknown **ppEnumerator);
        
        HRESULT ( STDMETHODCALLTYPE *RequestRuntimeLoadedNotification )( 
            ICLRMetaHost * This,
            /* [in] */ RuntimeLoadedCallbackFnPtr pCallbackFunction);
        
        HRESULT ( STDMETHODCALLTYPE *QueryLegacyV2RuntimeBinding )( 
            ICLRMetaHost * This,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID *ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *ExitProcess )( 
            ICLRMetaHost * This,
            /* [in] */ INT32 iExitCode);
        
        END_INTERFACE
    } ICLRMetaHostVtbl;

    interface ICLRMetaHost
    {
        CONST_VTBL struct ICLRMetaHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRMetaHost_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICLRMetaHost_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICLRMetaHost_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICLRMetaHost_GetRuntime(This,pwzVersion,riid,ppRuntime)	\
    ( (This)->lpVtbl -> GetRuntime(This,pwzVersion,riid,ppRuntime) ) 

#define ICLRMetaHost_GetVersionFromFile(This,pwzFilePath,pwzBuffer,pcchBuffer)	\
    ( (This)->lpVtbl -> GetVersionFromFile(This,pwzFilePath,pwzBuffer,pcchBuffer) ) 

#define ICLRMetaHost_EnumerateInstalledRuntimes(This,ppEnumerator)	\
    ( (This)->lpVtbl -> EnumerateInstalledRuntimes(This,ppEnumerator) ) 

#define ICLRMetaHost_EnumerateLoadedRuntimes(This,hndProcess,ppEnumerator)	\
    ( (This)->lpVtbl -> EnumerateLoadedRuntimes(This,hndProcess,ppEnumerator) ) 

#define ICLRMetaHost_RequestRuntimeLoadedNotification(This,pCallbackFunction)	\
    ( (This)->lpVtbl -> RequestRuntimeLoadedNotification(This,pCallbackFunction) ) 

#define ICLRMetaHost_QueryLegacyV2RuntimeBinding(This,riid,ppUnk)	\
    ( (This)->lpVtbl -> QueryLegacyV2RuntimeBinding(This,riid,ppUnk) ) 

#define ICLRMetaHost_ExitProcess(This,iExitCode)	\
    ( (This)->lpVtbl -> ExitProcess(This,iExitCode) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICLRMetaHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_metahost_0000_0001 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_metahost_0000_0001_0001
    {	METAHOST_POLICY_HIGHCOMPAT	= 0,
	METAHOST_POLICY_APPLY_UPGRADE_POLICY	= 0x8,
	METAHOST_POLICY_EMULATE_EXE_LAUNCH	= 0x10,
	METAHOST_POLICY_SHOW_ERROR_DIALOG	= 0x20,
	METAHOST_POLICY_USE_PROCESS_IMAGE_PATH	= 0x40,
	METAHOST_POLICY_ENSURE_SKU_SUPPORTED	= 0x80
    } 	METAHOST_POLICY_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_metahost_0000_0001_0002
    {	METAHOST_CONFIG_FLAGS_LEGACY_V2_ACTIVATION_POLICY_UNSET	= 0,
	METAHOST_CONFIG_FLAGS_LEGACY_V2_ACTIVATION_POLICY_TRUE	= 0x1,
	METAHOST_CONFIG_FLAGS_LEGACY_V2_ACTIVATION_POLICY_FALSE	= 0x2,
	METAHOST_CONFIG_FLAGS_LEGACY_V2_ACTIVATION_POLICY_MASK	= 0x3
    } 	METAHOST_CONFIG_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_metahost_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_metahost_0000_0001_v0_0_s_ifspec;

#ifndef __ICLRMetaHostPolicy_INTERFACE_DEFINED__
#define __ICLRMetaHostPolicy_INTERFACE_DEFINED__

/* interface ICLRMetaHostPolicy */
/* [object][local][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRMetaHostPolicy;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E2190695-77B2-492e-8E14-C4B3A7FDD593")
    ICLRMetaHostPolicy : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRequestedRuntime( 
            /* [in] */ METAHOST_POLICY_FLAGS dwPolicyFlags,
            /* [in] */ LPCWSTR pwzBinary,
            /* [in] */ IStream *pCfgStream,
            /* [size_is][out][in] */ 
            __inout_ecount_full_opt(*pcchVersion)  LPWSTR pwzVersion,
            /* [out][in] */ DWORD *pcchVersion,
            /* [size_is][out] */ 
            __out_ecount_full_opt(*pcchImageVersion)  LPWSTR pwzImageVersion,
            /* [out][in] */ DWORD *pcchImageVersion,
            /* [out] */ DWORD *pdwConfigFlags,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID *ppRuntime) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRMetaHostPolicyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRMetaHostPolicy * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRMetaHostPolicy * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRMetaHostPolicy * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRequestedRuntime )( 
            ICLRMetaHostPolicy * This,
            /* [in] */ METAHOST_POLICY_FLAGS dwPolicyFlags,
            /* [in] */ LPCWSTR pwzBinary,
            /* [in] */ IStream *pCfgStream,
            /* [size_is][out][in] */ 
            __inout_ecount_full_opt(*pcchVersion)  LPWSTR pwzVersion,
            /* [out][in] */ DWORD *pcchVersion,
            /* [size_is][out] */ 
            __out_ecount_full_opt(*pcchImageVersion)  LPWSTR pwzImageVersion,
            /* [out][in] */ DWORD *pcchImageVersion,
            /* [out] */ DWORD *pdwConfigFlags,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID *ppRuntime);
        
        END_INTERFACE
    } ICLRMetaHostPolicyVtbl;

    interface ICLRMetaHostPolicy
    {
        CONST_VTBL struct ICLRMetaHostPolicyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRMetaHostPolicy_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICLRMetaHostPolicy_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICLRMetaHostPolicy_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICLRMetaHostPolicy_GetRequestedRuntime(This,dwPolicyFlags,pwzBinary,pCfgStream,pwzVersion,pcchVersion,pwzImageVersion,pcchImageVersion,pdwConfigFlags,riid,ppRuntime)	\
    ( (This)->lpVtbl -> GetRequestedRuntime(This,dwPolicyFlags,pwzBinary,pCfgStream,pwzVersion,pcchVersion,pwzImageVersion,pcchImageVersion,pdwConfigFlags,riid,ppRuntime) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICLRMetaHostPolicy_INTERFACE_DEFINED__ */


#ifndef __ICLRProfiling_INTERFACE_DEFINED__
#define __ICLRProfiling_INTERFACE_DEFINED__

/* interface ICLRProfiling */
/* [object][local][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRProfiling;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B349ABE3-B56F-4689-BFCD-76BF39D888EA")
    ICLRProfiling : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AttachProfiler( 
            /* [in] */ DWORD dwProfileeProcessID,
            /* [in] */ DWORD dwMillisecondsMax,
            /* [in] */ const CLSID *pClsidProfiler,
            /* [in] */ LPCWSTR wszProfilerPath,
            /* [size_is][in] */ void *pvClientData,
            /* [in] */ UINT cbClientData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRProfilingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRProfiling * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRProfiling * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRProfiling * This);
        
        HRESULT ( STDMETHODCALLTYPE *AttachProfiler )( 
            ICLRProfiling * This,
            /* [in] */ DWORD dwProfileeProcessID,
            /* [in] */ DWORD dwMillisecondsMax,
            /* [in] */ const CLSID *pClsidProfiler,
            /* [in] */ LPCWSTR wszProfilerPath,
            /* [size_is][in] */ void *pvClientData,
            /* [in] */ UINT cbClientData);
        
        END_INTERFACE
    } ICLRProfilingVtbl;

    interface ICLRProfiling
    {
        CONST_VTBL struct ICLRProfilingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRProfiling_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICLRProfiling_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICLRProfiling_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICLRProfiling_AttachProfiler(This,dwProfileeProcessID,dwMillisecondsMax,pClsidProfiler,wszProfilerPath,pvClientData,cbClientData)	\
    ( (This)->lpVtbl -> AttachProfiler(This,dwProfileeProcessID,dwMillisecondsMax,pClsidProfiler,wszProfilerPath,pvClientData,cbClientData) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICLRProfiling_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_metahost_0000_0003 */
/* [local] */ 

typedef struct _CLR_DEBUGGING_VERSION
    {
    WORD wStructVersion;
    WORD wMajor;
    WORD wMinor;
    WORD wBuild;
    WORD wRevision;
    } 	CLR_DEBUGGING_VERSION;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_metahost_0000_0003_0001
    {	CLR_DEBUGGING_MANAGED_EVENT_PENDING	= 1
    } 	CLR_DEBUGGING_PROCESS_FLAGS;



extern RPC_IF_HANDLE __MIDL_itf_metahost_0000_0003_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_metahost_0000_0003_v0_0_s_ifspec;

#ifndef __ICLRDebuggingLibraryProvider_INTERFACE_DEFINED__
#define __ICLRDebuggingLibraryProvider_INTERFACE_DEFINED__

/* interface ICLRDebuggingLibraryProvider */
/* [object][local][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRDebuggingLibraryProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3151C08D-4D09-4f9b-8838-2880BF18FE51")
    ICLRDebuggingLibraryProvider : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProvideLibrary( 
            /* [in] */ const WCHAR *pwszFileName,
            /* [in] */ DWORD dwTimestamp,
            /* [in] */ DWORD dwSizeOfImage,
            /* [out] */ HMODULE *phModule) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDebuggingLibraryProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDebuggingLibraryProvider * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDebuggingLibraryProvider * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDebuggingLibraryProvider * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideLibrary )( 
            ICLRDebuggingLibraryProvider * This,
            /* [in] */ const WCHAR *pwszFileName,
            /* [in] */ DWORD dwTimestamp,
            /* [in] */ DWORD dwSizeOfImage,
            /* [out] */ HMODULE *phModule);
        
        END_INTERFACE
    } ICLRDebuggingLibraryProviderVtbl;

    interface ICLRDebuggingLibraryProvider
    {
        CONST_VTBL struct ICLRDebuggingLibraryProviderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDebuggingLibraryProvider_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICLRDebuggingLibraryProvider_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICLRDebuggingLibraryProvider_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICLRDebuggingLibraryProvider_ProvideLibrary(This,pwszFileName,dwTimestamp,dwSizeOfImage,phModule)	\
    ( (This)->lpVtbl -> ProvideLibrary(This,pwszFileName,dwTimestamp,dwSizeOfImage,phModule) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICLRDebuggingLibraryProvider_INTERFACE_DEFINED__ */


#ifndef __ICLRDebugging_INTERFACE_DEFINED__
#define __ICLRDebugging_INTERFACE_DEFINED__

/* interface ICLRDebugging */
/* [object][local][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRDebugging;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D28F3C5A-9634-4206-A509-477552EEFB10")
    ICLRDebugging : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenVirtualProcess( 
            /* [in] */ ULONG64 moduleBaseAddress,
            /* [in] */ IUnknown *pDataTarget,
            /* [in] */ ICLRDebuggingLibraryProvider *pLibraryProvider,
            /* [in] */ CLR_DEBUGGING_VERSION *pMaxDebuggerSupportedVersion,
            /* [in] */ REFIID riidProcess,
            /* [iid_is][out] */ IUnknown **ppProcess,
            /* [out][in] */ CLR_DEBUGGING_VERSION *pVersion,
            /* [out] */ CLR_DEBUGGING_PROCESS_FLAGS *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanUnloadNow( 
            HMODULE hModule) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDebuggingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDebugging * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDebugging * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDebugging * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenVirtualProcess )( 
            ICLRDebugging * This,
            /* [in] */ ULONG64 moduleBaseAddress,
            /* [in] */ IUnknown *pDataTarget,
            /* [in] */ ICLRDebuggingLibraryProvider *pLibraryProvider,
            /* [in] */ CLR_DEBUGGING_VERSION *pMaxDebuggerSupportedVersion,
            /* [in] */ REFIID riidProcess,
            /* [iid_is][out] */ IUnknown **ppProcess,
            /* [out][in] */ CLR_DEBUGGING_VERSION *pVersion,
            /* [out] */ CLR_DEBUGGING_PROCESS_FLAGS *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *CanUnloadNow )( 
            ICLRDebugging * This,
            HMODULE hModule);
        
        END_INTERFACE
    } ICLRDebuggingVtbl;

    interface ICLRDebugging
    {
        CONST_VTBL struct ICLRDebuggingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDebugging_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICLRDebugging_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICLRDebugging_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICLRDebugging_OpenVirtualProcess(This,moduleBaseAddress,pDataTarget,pLibraryProvider,pMaxDebuggerSupportedVersion,riidProcess,ppProcess,pVersion,pdwFlags)	\
    ( (This)->lpVtbl -> OpenVirtualProcess(This,moduleBaseAddress,pDataTarget,pLibraryProvider,pMaxDebuggerSupportedVersion,riidProcess,ppProcess,pVersion,pdwFlags) ) 

#define ICLRDebugging_CanUnloadNow(This,hModule)	\
    ( (This)->lpVtbl -> CanUnloadNow(This,hModule) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICLRDebugging_INTERFACE_DEFINED__ */


#ifndef __ICLRRuntimeInfo_INTERFACE_DEFINED__
#define __ICLRRuntimeInfo_INTERFACE_DEFINED__

/* interface ICLRRuntimeInfo */
/* [object][local][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRRuntimeInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BD39D1D2-BA2F-486a-89B0-B4B0CB466891")
    ICLRRuntimeInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVersionString( 
            /* [size_is][out] */ 
            __out_ecount_full_opt(*pcchBuffer)  LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRuntimeDirectory( 
            /* [size_is][out] */ 
            __out_ecount_full(*pcchBuffer)  LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsLoaded( 
            /* [in] */ HANDLE hndProcess,
            /* [retval][out] */ BOOL *pbLoaded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadErrorString( 
            /* [in] */ UINT iResourceID,
            /* [size_is][out] */ 
            __out_ecount_full(*pcchBuffer)  LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBuffer,
            /* [lcid][in] */ LONG iLocaleID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadLibrary( 
            /* [in] */ LPCWSTR pwzDllName,
            /* [retval][out] */ HMODULE *phndModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcAddress( 
            /* [in] */ LPCSTR pszProcName,
            /* [retval][out] */ LPVOID *ppProc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterface( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID *ppUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsLoadable( 
            /* [retval][out] */ BOOL *pbLoadable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDefaultStartupFlags( 
            /* [in] */ DWORD dwStartupFlags,
            /* [in] */ LPCWSTR pwzHostConfigFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultStartupFlags( 
            /* [out] */ DWORD *pdwStartupFlags,
            /* [size_is][out] */ 
            __out_ecount_full_opt(*pcchHostConfigFile)  LPWSTR pwzHostConfigFile,
            /* [out][in] */ DWORD *pcchHostConfigFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BindAsLegacyV2Runtime( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsStarted( 
            /* [out] */ BOOL *pbStarted,
            /* [out] */ DWORD *pdwStartupFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRRuntimeInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRRuntimeInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRRuntimeInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRRuntimeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionString )( 
            ICLRRuntimeInfo * This,
            /* [size_is][out] */ 
            __out_ecount_full_opt(*pcchBuffer)  LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *GetRuntimeDirectory )( 
            ICLRRuntimeInfo * This,
            /* [size_is][out] */ 
            __out_ecount_full(*pcchBuffer)  LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *IsLoaded )( 
            ICLRRuntimeInfo * This,
            /* [in] */ HANDLE hndProcess,
            /* [retval][out] */ BOOL *pbLoaded);
        
        HRESULT ( STDMETHODCALLTYPE *LoadErrorString )( 
            ICLRRuntimeInfo * This,
            /* [in] */ UINT iResourceID,
            /* [size_is][out] */ 
            __out_ecount_full(*pcchBuffer)  LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBuffer,
            /* [lcid][in] */ LONG iLocaleID);
        
        HRESULT ( STDMETHODCALLTYPE *LoadLibrary )( 
            ICLRRuntimeInfo * This,
            /* [in] */ LPCWSTR pwzDllName,
            /* [retval][out] */ HMODULE *phndModule);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcAddress )( 
            ICLRRuntimeInfo * This,
            /* [in] */ LPCSTR pszProcName,
            /* [retval][out] */ LPVOID *ppProc);
        
        HRESULT ( STDMETHODCALLTYPE *GetInterface )( 
            ICLRRuntimeInfo * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ REFIID riid,
            /* [retval][iid_is][out] */ LPVOID *ppUnk);
        
        HRESULT ( STDMETHODCALLTYPE *IsLoadable )( 
            ICLRRuntimeInfo * This,
            /* [retval][out] */ BOOL *pbLoadable);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultStartupFlags )( 
            ICLRRuntimeInfo * This,
            /* [in] */ DWORD dwStartupFlags,
            /* [in] */ LPCWSTR pwzHostConfigFile);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultStartupFlags )( 
            ICLRRuntimeInfo * This,
            /* [out] */ DWORD *pdwStartupFlags,
            /* [size_is][out] */ 
            __out_ecount_full_opt(*pcchHostConfigFile)  LPWSTR pwzHostConfigFile,
            /* [out][in] */ DWORD *pcchHostConfigFile);
        
        HRESULT ( STDMETHODCALLTYPE *BindAsLegacyV2Runtime )( 
            ICLRRuntimeInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsStarted )( 
            ICLRRuntimeInfo * This,
            /* [out] */ BOOL *pbStarted,
            /* [out] */ DWORD *pdwStartupFlags);
        
        END_INTERFACE
    } ICLRRuntimeInfoVtbl;

    interface ICLRRuntimeInfo
    {
        CONST_VTBL struct ICLRRuntimeInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRRuntimeInfo_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICLRRuntimeInfo_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICLRRuntimeInfo_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICLRRuntimeInfo_GetVersionString(This,pwzBuffer,pcchBuffer)	\
    ( (This)->lpVtbl -> GetVersionString(This,pwzBuffer,pcchBuffer) ) 

#define ICLRRuntimeInfo_GetRuntimeDirectory(This,pwzBuffer,pcchBuffer)	\
    ( (This)->lpVtbl -> GetRuntimeDirectory(This,pwzBuffer,pcchBuffer) ) 

#define ICLRRuntimeInfo_IsLoaded(This,hndProcess,pbLoaded)	\
    ( (This)->lpVtbl -> IsLoaded(This,hndProcess,pbLoaded) ) 

#define ICLRRuntimeInfo_LoadErrorString(This,iResourceID,pwzBuffer,pcchBuffer,iLocaleID)	\
    ( (This)->lpVtbl -> LoadErrorString(This,iResourceID,pwzBuffer,pcchBuffer,iLocaleID) ) 

#define ICLRRuntimeInfo_LoadLibrary(This,pwzDllName,phndModule)	\
    ( (This)->lpVtbl -> LoadLibrary(This,pwzDllName,phndModule) ) 

#define ICLRRuntimeInfo_GetProcAddress(This,pszProcName,ppProc)	\
    ( (This)->lpVtbl -> GetProcAddress(This,pszProcName,ppProc) ) 

#define ICLRRuntimeInfo_GetInterface(This,rclsid,riid,ppUnk)	\
    ( (This)->lpVtbl -> GetInterface(This,rclsid,riid,ppUnk) ) 

#define ICLRRuntimeInfo_IsLoadable(This,pbLoadable)	\
    ( (This)->lpVtbl -> IsLoadable(This,pbLoadable) ) 

#define ICLRRuntimeInfo_SetDefaultStartupFlags(This,dwStartupFlags,pwzHostConfigFile)	\
    ( (This)->lpVtbl -> SetDefaultStartupFlags(This,dwStartupFlags,pwzHostConfigFile) ) 

#define ICLRRuntimeInfo_GetDefaultStartupFlags(This,pdwStartupFlags,pwzHostConfigFile,pcchHostConfigFile)	\
    ( (This)->lpVtbl -> GetDefaultStartupFlags(This,pdwStartupFlags,pwzHostConfigFile,pcchHostConfigFile) ) 

#define ICLRRuntimeInfo_BindAsLegacyV2Runtime(This)	\
    ( (This)->lpVtbl -> BindAsLegacyV2Runtime(This) ) 

#define ICLRRuntimeInfo_IsStarted(This,pbStarted,pdwStartupFlags)	\
    ( (This)->lpVtbl -> IsStarted(This,pbStarted,pdwStartupFlags) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICLRRuntimeInfo_INTERFACE_DEFINED__ */


#ifndef __ICLRStrongName_INTERFACE_DEFINED__
#define __ICLRStrongName_INTERFACE_DEFINED__

/* interface ICLRStrongName */
/* [object][local][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRStrongName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")
    ICLRStrongName : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHashFromAssemblyFile( 
            /* [in] */ LPCSTR pszFilePath,
            /* [out][in] */ unsigned int *piHashAlg,
            /* [length_is][size_is][out] */ BYTE *pbHash,
            /* [in] */ DWORD cchHash,
            /* [out] */ DWORD *pchHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHashFromAssemblyFileW( 
            /* [in] */ LPCWSTR pwzFilePath,
            /* [out][in] */ unsigned int *piHashAlg,
            /* [length_is][size_is][out] */ BYTE *pbHash,
            /* [in] */ DWORD cchHash,
            /* [out] */ DWORD *pchHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHashFromBlob( 
            /* [in] */ BYTE *pbBlob,
            /* [in] */ DWORD cchBlob,
            /* [out][in] */ unsigned int *piHashAlg,
            /* [length_is][size_is][out] */ BYTE *pbHash,
            /* [in] */ DWORD cchHash,
            /* [out] */ DWORD *pchHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHashFromFile( 
            /* [in] */ LPCSTR pszFilePath,
            /* [out][in] */ unsigned int *piHashAlg,
            /* [length_is][size_is][out] */ BYTE *pbHash,
            /* [in] */ DWORD cchHash,
            /* [out] */ DWORD *pchHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHashFromFileW( 
            /* [in] */ LPCWSTR pwzFilePath,
            /* [out][in] */ unsigned int *piHashAlg,
            /* [length_is][size_is][out] */ BYTE *pbHash,
            /* [in] */ DWORD cchHash,
            /* [out] */ DWORD *pchHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHashFromHandle( 
            /* [in] */ HANDLE hFile,
            /* [out][in] */ unsigned int *piHashAlg,
            /* [length_is][size_is][out] */ BYTE *pbHash,
            /* [in] */ DWORD cchHash,
            /* [out] */ DWORD *pchHash) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameCompareAssemblies( 
            /* [in] */ LPCWSTR pwzAssembly1,
            /* [in] */ LPCWSTR pwzAssembly2,
            /* [retval][out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameFreeBuffer( 
            /* [in] */ BYTE *pbMemory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameGetBlob( 
            /* [in] */ LPCWSTR pwzFilePath,
            /* [length_is][size_is][out][in] */ BYTE *pbBlob,
            /* [out][in] */ DWORD *pcbBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameGetBlobFromImage( 
            /* [size_is][in] */ BYTE *pbBase,
            /* [in] */ DWORD dwLength,
            /* [length_is][size_is][out] */ BYTE *pbBlob,
            /* [out][in] */ DWORD *pcbBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameGetPublicKey( 
            /* [in] */ LPCWSTR pwzKeyContainer,
            /* [in] */ BYTE *pbKeyBlob,
            /* [in] */ ULONG cbKeyBlob,
            /* [out] */ BYTE **ppbPublicKeyBlob,
            /* [out] */ ULONG *pcbPublicKeyBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameHashSize( 
            /* [in] */ ULONG ulHashAlg,
            /* [retval][out] */ DWORD *pcbSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameKeyDelete( 
            /* [in] */ LPCWSTR pwzKeyContainer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameKeyGen( 
            /* [in] */ LPCWSTR pwzKeyContainer,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BYTE **ppbKeyBlob,
            /* [out] */ ULONG *pcbKeyBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameKeyGenEx( 
            /* [in] */ LPCWSTR pwzKeyContainer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwKeySize,
            /* [out] */ BYTE **ppbKeyBlob,
            /* [out] */ ULONG *pcbKeyBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameKeyInstall( 
            /* [in] */ LPCWSTR pwzKeyContainer,
            /* [in] */ BYTE *pbKeyBlob,
            /* [in] */ ULONG cbKeyBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameSignatureGeneration( 
            /* [in] */ LPCWSTR pwzFilePath,
            /* [in] */ LPCWSTR pwzKeyContainer,
            /* [in] */ BYTE *pbKeyBlob,
            /* [in] */ ULONG cbKeyBlob,
            /* [out] */ BYTE **ppbSignatureBlob,
            /* [out] */ ULONG *pcbSignatureBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameSignatureGenerationEx( 
            /* [in] */ LPCWSTR wszFilePath,
            /* [in] */ LPCWSTR wszKeyContainer,
            /* [in] */ BYTE *pbKeyBlob,
            /* [in] */ ULONG cbKeyBlob,
            /* [out] */ BYTE **ppbSignatureBlob,
            /* [out] */ ULONG *pcbSignatureBlob,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameSignatureSize( 
            /* [in] */ BYTE *pbPublicKeyBlob,
            /* [in] */ ULONG cbPublicKeyBlob,
            /* [in] */ DWORD *pcbSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameSignatureVerification( 
            /* [in] */ LPCWSTR pwzFilePath,
            /* [in] */ DWORD dwInFlags,
            /* [retval][out] */ DWORD *pdwOutFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameSignatureVerificationEx( 
            /* [in] */ LPCWSTR pwzFilePath,
            /* [in] */ BOOLEAN fForceVerification,
            /* [retval][out] */ BOOLEAN *pfWasVerified) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameSignatureVerificationFromImage( 
            /* [in] */ BYTE *pbBase,
            /* [in] */ DWORD dwLength,
            /* [in] */ DWORD dwInFlags,
            /* [retval][out] */ DWORD *pdwOutFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameTokenFromAssembly( 
            /* [in] */ LPCWSTR pwzFilePath,
            /* [out] */ BYTE **ppbStrongNameToken,
            /* [out] */ ULONG *pcbStrongNameToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameTokenFromAssemblyEx( 
            /* [in] */ LPCWSTR pwzFilePath,
            /* [out] */ BYTE **ppbStrongNameToken,
            /* [out] */ ULONG *pcbStrongNameToken,
            /* [out] */ BYTE **ppbPublicKeyBlob,
            /* [out] */ ULONG *pcbPublicKeyBlob) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StrongNameTokenFromPublicKey( 
            /* [in] */ BYTE *pbPublicKeyBlob,
            /* [in] */ ULONG cbPublicKeyBlob,
            /* [out] */ BYTE **ppbStrongNameToken,
            /* [out] */ ULONG *pcbStrongNameToken) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRStrongNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRStrongName * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRStrongName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRStrongName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetHashFromAssemblyFile )( 
            ICLRStrongName * This,
            /* [in] */ LPCSTR pszFilePath,
            /* [out][in] */ unsigned int *piHashAlg,
            /* [length_is][size_is][out] */ BYTE *pbHash,
            /* [in] */ DWORD cchHash,
            /* [out] */ DWORD *pchHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetHashFromAssemblyFileW )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzFilePath,
            /* [out][in] */ unsigned int *piHashAlg,
            /* [length_is][size_is][out] */ BYTE *pbHash,
            /* [in] */ DWORD cchHash,
            /* [out] */ DWORD *pchHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetHashFromBlob )( 
            ICLRStrongName * This,
            /* [in] */ BYTE *pbBlob,
            /* [in] */ DWORD cchBlob,
            /* [out][in] */ unsigned int *piHashAlg,
            /* [length_is][size_is][out] */ BYTE *pbHash,
            /* [in] */ DWORD cchHash,
            /* [out] */ DWORD *pchHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetHashFromFile )( 
            ICLRStrongName * This,
            /* [in] */ LPCSTR pszFilePath,
            /* [out][in] */ unsigned int *piHashAlg,
            /* [length_is][size_is][out] */ BYTE *pbHash,
            /* [in] */ DWORD cchHash,
            /* [out] */ DWORD *pchHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetHashFromFileW )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzFilePath,
            /* [out][in] */ unsigned int *piHashAlg,
            /* [length_is][size_is][out] */ BYTE *pbHash,
            /* [in] */ DWORD cchHash,
            /* [out] */ DWORD *pchHash);
        
        HRESULT ( STDMETHODCALLTYPE *GetHashFromHandle )( 
            ICLRStrongName * This,
            /* [in] */ HANDLE hFile,
            /* [out][in] */ unsigned int *piHashAlg,
            /* [length_is][size_is][out] */ BYTE *pbHash,
            /* [in] */ DWORD cchHash,
            /* [out] */ DWORD *pchHash);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameCompareAssemblies )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzAssembly1,
            /* [in] */ LPCWSTR pwzAssembly2,
            /* [retval][out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameFreeBuffer )( 
            ICLRStrongName * This,
            /* [in] */ BYTE *pbMemory);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameGetBlob )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzFilePath,
            /* [length_is][size_is][out][in] */ BYTE *pbBlob,
            /* [out][in] */ DWORD *pcbBlob);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameGetBlobFromImage )( 
            ICLRStrongName * This,
            /* [size_is][in] */ BYTE *pbBase,
            /* [in] */ DWORD dwLength,
            /* [length_is][size_is][out] */ BYTE *pbBlob,
            /* [out][in] */ DWORD *pcbBlob);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameGetPublicKey )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzKeyContainer,
            /* [in] */ BYTE *pbKeyBlob,
            /* [in] */ ULONG cbKeyBlob,
            /* [out] */ BYTE **ppbPublicKeyBlob,
            /* [out] */ ULONG *pcbPublicKeyBlob);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameHashSize )( 
            ICLRStrongName * This,
            /* [in] */ ULONG ulHashAlg,
            /* [retval][out] */ DWORD *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameKeyDelete )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzKeyContainer);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameKeyGen )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzKeyContainer,
            /* [in] */ DWORD dwFlags,
            /* [out] */ BYTE **ppbKeyBlob,
            /* [out] */ ULONG *pcbKeyBlob);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameKeyGenEx )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzKeyContainer,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwKeySize,
            /* [out] */ BYTE **ppbKeyBlob,
            /* [out] */ ULONG *pcbKeyBlob);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameKeyInstall )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzKeyContainer,
            /* [in] */ BYTE *pbKeyBlob,
            /* [in] */ ULONG cbKeyBlob);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameSignatureGeneration )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzFilePath,
            /* [in] */ LPCWSTR pwzKeyContainer,
            /* [in] */ BYTE *pbKeyBlob,
            /* [in] */ ULONG cbKeyBlob,
            /* [out] */ BYTE **ppbSignatureBlob,
            /* [out] */ ULONG *pcbSignatureBlob);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameSignatureGenerationEx )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR wszFilePath,
            /* [in] */ LPCWSTR wszKeyContainer,
            /* [in] */ BYTE *pbKeyBlob,
            /* [in] */ ULONG cbKeyBlob,
            /* [out] */ BYTE **ppbSignatureBlob,
            /* [out] */ ULONG *pcbSignatureBlob,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameSignatureSize )( 
            ICLRStrongName * This,
            /* [in] */ BYTE *pbPublicKeyBlob,
            /* [in] */ ULONG cbPublicKeyBlob,
            /* [in] */ DWORD *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameSignatureVerification )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzFilePath,
            /* [in] */ DWORD dwInFlags,
            /* [retval][out] */ DWORD *pdwOutFlags);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameSignatureVerificationEx )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzFilePath,
            /* [in] */ BOOLEAN fForceVerification,
            /* [retval][out] */ BOOLEAN *pfWasVerified);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameSignatureVerificationFromImage )( 
            ICLRStrongName * This,
            /* [in] */ BYTE *pbBase,
            /* [in] */ DWORD dwLength,
            /* [in] */ DWORD dwInFlags,
            /* [retval][out] */ DWORD *pdwOutFlags);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameTokenFromAssembly )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzFilePath,
            /* [out] */ BYTE **ppbStrongNameToken,
            /* [out] */ ULONG *pcbStrongNameToken);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameTokenFromAssemblyEx )( 
            ICLRStrongName * This,
            /* [in] */ LPCWSTR pwzFilePath,
            /* [out] */ BYTE **ppbStrongNameToken,
            /* [out] */ ULONG *pcbStrongNameToken,
            /* [out] */ BYTE **ppbPublicKeyBlob,
            /* [out] */ ULONG *pcbPublicKeyBlob);
        
        HRESULT ( STDMETHODCALLTYPE *StrongNameTokenFromPublicKey )( 
            ICLRStrongName * This,
            /* [in] */ BYTE *pbPublicKeyBlob,
            /* [in] */ ULONG cbPublicKeyBlob,
            /* [out] */ BYTE **ppbStrongNameToken,
            /* [out] */ ULONG *pcbStrongNameToken);
        
        END_INTERFACE
    } ICLRStrongNameVtbl;

    interface ICLRStrongName
    {
        CONST_VTBL struct ICLRStrongNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRStrongName_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define ICLRStrongName_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define ICLRStrongName_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define ICLRStrongName_GetHashFromAssemblyFile(This,pszFilePath,piHashAlg,pbHash,cchHash,pchHash)	\
    ( (This)->lpVtbl -> GetHashFromAssemblyFile(This,pszFilePath,piHashAlg,pbHash,cchHash,pchHash) ) 

#define ICLRStrongName_GetHashFromAssemblyFileW(This,pwzFilePath,piHashAlg,pbHash,cchHash,pchHash)	\
    ( (This)->lpVtbl -> GetHashFromAssemblyFileW(This,pwzFilePath,piHashAlg,pbHash,cchHash,pchHash) ) 

#define ICLRStrongName_GetHashFromBlob(This,pbBlob,cchBlob,piHashAlg,pbHash,cchHash,pchHash)	\
    ( (This)->lpVtbl -> GetHashFromBlob(This,pbBlob,cchBlob,piHashAlg,pbHash,cchHash,pchHash) ) 

#define ICLRStrongName_GetHashFromFile(This,pszFilePath,piHashAlg,pbHash,cchHash,pchHash)	\
    ( (This)->lpVtbl -> GetHashFromFile(This,pszFilePath,piHashAlg,pbHash,cchHash,pchHash) ) 

#define ICLRStrongName_GetHashFromFileW(This,pwzFilePath,piHashAlg,pbHash,cchHash,pchHash)	\
    ( (This)->lpVtbl -> GetHashFromFileW(This,pwzFilePath,piHashAlg,pbHash,cchHash,pchHash) ) 

#define ICLRStrongName_GetHashFromHandle(This,hFile,piHashAlg,pbHash,cchHash,pchHash)	\
    ( (This)->lpVtbl -> GetHashFromHandle(This,hFile,piHashAlg,pbHash,cchHash,pchHash) ) 

#define ICLRStrongName_StrongNameCompareAssemblies(This,pwzAssembly1,pwzAssembly2,pdwResult)	\
    ( (This)->lpVtbl -> StrongNameCompareAssemblies(This,pwzAssembly1,pwzAssembly2,pdwResult) ) 

#define ICLRStrongName_StrongNameFreeBuffer(This,pbMemory)	\
    ( (This)->lpVtbl -> StrongNameFreeBuffer(This,pbMemory) ) 

#define ICLRStrongName_StrongNameGetBlob(This,pwzFilePath,pbBlob,pcbBlob)	\
    ( (This)->lpVtbl -> StrongNameGetBlob(This,pwzFilePath,pbBlob,pcbBlob) ) 

#define ICLRStrongName_StrongNameGetBlobFromImage(This,pbBase,dwLength,pbBlob,pcbBlob)	\
    ( (This)->lpVtbl -> StrongNameGetBlobFromImage(This,pbBase,dwLength,pbBlob,pcbBlob) ) 

#define ICLRStrongName_StrongNameGetPublicKey(This,pwzKeyContainer,pbKeyBlob,cbKeyBlob,ppbPublicKeyBlob,pcbPublicKeyBlob)	\
    ( (This)->lpVtbl -> StrongNameGetPublicKey(This,pwzKeyContainer,pbKeyBlob,cbKeyBlob,ppbPublicKeyBlob,pcbPublicKeyBlob) ) 

#define ICLRStrongName_StrongNameHashSize(This,ulHashAlg,pcbSize)	\
    ( (This)->lpVtbl -> StrongNameHashSize(This,ulHashAlg,pcbSize) ) 

#define ICLRStrongName_StrongNameKeyDelete(This,pwzKeyContainer)	\
    ( (This)->lpVtbl -> StrongNameKeyDelete(This,pwzKeyContainer) ) 

#define ICLRStrongName_StrongNameKeyGen(This,pwzKeyContainer,dwFlags,ppbKeyBlob,pcbKeyBlob)	\
    ( (This)->lpVtbl -> StrongNameKeyGen(This,pwzKeyContainer,dwFlags,ppbKeyBlob,pcbKeyBlob) ) 

#define ICLRStrongName_StrongNameKeyGenEx(This,pwzKeyContainer,dwFlags,dwKeySize,ppbKeyBlob,pcbKeyBlob)	\
    ( (This)->lpVtbl -> StrongNameKeyGenEx(This,pwzKeyContainer,dwFlags,dwKeySize,ppbKeyBlob,pcbKeyBlob) ) 

#define ICLRStrongName_StrongNameKeyInstall(This,pwzKeyContainer,pbKeyBlob,cbKeyBlob)	\
    ( (This)->lpVtbl -> StrongNameKeyInstall(This,pwzKeyContainer,pbKeyBlob,cbKeyBlob) ) 

#define ICLRStrongName_StrongNameSignatureGeneration(This,pwzFilePath,pwzKeyContainer,pbKeyBlob,cbKeyBlob,ppbSignatureBlob,pcbSignatureBlob)	\
    ( (This)->lpVtbl -> StrongNameSignatureGeneration(This,pwzFilePath,pwzKeyContainer,pbKeyBlob,cbKeyBlob,ppbSignatureBlob,pcbSignatureBlob) ) 

#define ICLRStrongName_StrongNameSignatureGenerationEx(This,wszFilePath,wszKeyContainer,pbKeyBlob,cbKeyBlob,ppbSignatureBlob,pcbSignatureBlob,dwFlags)	\
    ( (This)->lpVtbl -> StrongNameSignatureGenerationEx(This,wszFilePath,wszKeyContainer,pbKeyBlob,cbKeyBlob,ppbSignatureBlob,pcbSignatureBlob,dwFlags) ) 

#define ICLRStrongName_StrongNameSignatureSize(This,pbPublicKeyBlob,cbPublicKeyBlob,pcbSize)	\
    ( (This)->lpVtbl -> StrongNameSignatureSize(This,pbPublicKeyBlob,cbPublicKeyBlob,pcbSize) ) 

#define ICLRStrongName_StrongNameSignatureVerification(This,pwzFilePath,dwInFlags,pdwOutFlags)	\
    ( (This)->lpVtbl -> StrongNameSignatureVerification(This,pwzFilePath,dwInFlags,pdwOutFlags) ) 

#define ICLRStrongName_StrongNameSignatureVerificationEx(This,pwzFilePath,fForceVerification,pfWasVerified)	\
    ( (This)->lpVtbl -> StrongNameSignatureVerificationEx(This,pwzFilePath,fForceVerification,pfWasVerified) ) 

#define ICLRStrongName_StrongNameSignatureVerificationFromImage(This,pbBase,dwLength,dwInFlags,pdwOutFlags)	\
    ( (This)->lpVtbl -> StrongNameSignatureVerificationFromImage(This,pbBase,dwLength,dwInFlags,pdwOutFlags) ) 

#define ICLRStrongName_StrongNameTokenFromAssembly(This,pwzFilePath,ppbStrongNameToken,pcbStrongNameToken)	\
    ( (This)->lpVtbl -> StrongNameTokenFromAssembly(This,pwzFilePath,ppbStrongNameToken,pcbStrongNameToken) ) 

#define ICLRStrongName_StrongNameTokenFromAssemblyEx(This,pwzFilePath,ppbStrongNameToken,pcbStrongNameToken,ppbPublicKeyBlob,pcbPublicKeyBlob)	\
    ( (This)->lpVtbl -> StrongNameTokenFromAssemblyEx(This,pwzFilePath,ppbStrongNameToken,pcbStrongNameToken,ppbPublicKeyBlob,pcbPublicKeyBlob) ) 

#define ICLRStrongName_StrongNameTokenFromPublicKey(This,pbPublicKeyBlob,cbPublicKeyBlob,ppbStrongNameToken,pcbStrongNameToken)	\
    ( (This)->lpVtbl -> StrongNameTokenFromPublicKey(This,pbPublicKeyBlob,cbPublicKeyBlob,ppbStrongNameToken,pcbStrongNameToken) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICLRStrongName_INTERFACE_DEFINED__ */



#ifndef __CLRMetaHost_LIBRARY_DEFINED__
#define __CLRMetaHost_LIBRARY_DEFINED__

/* library CLRMetaHost */
/* [version][uuid] */ 









EXTERN_C const IID LIBID_CLRMetaHost;
#endif /* __CLRMetaHost_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\MethodCo.h ===
//***************************************************************************
//
//  Copyright (c) Microsoft Corporation.  All rights reserved.
//
//  MethodCo.h
//
//  Purpose: declaration of MethodContext class
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _METHOD_CONTEXT_H__
#define _METHOD_CONTEXT_H__

//#include "ThrdBase.h"
//#include "refptrco.h"

#ifdef PROVIDER_INSTRUMENTATION
    #include <stopwatch.h>
#endif

class CInstance;
class Provider;
class MethodContext;
class CWbemProviderGlue;
class InternalMethodContextAsynch;

typedef HRESULT (WINAPI *LPProviderInstanceCallback)(Provider *pProvider, CInstance *pInstance, MethodContext *pContext, void *pUserData);

//////////////////////////////////////////////////////
//
//  STRUCT MethodContext
//
// a little something to make sure we can keep our threads from getting tangled
// idea is that there is one MethodContext for each request from CIMOM or another provider
// pointers are passed around.
//////////////////////////////////////////////////////
class POLARITY MethodContext : public CThreadBase
{
public:
    friend InternalMethodContextAsynch;
    friend CWbemProviderGlue;

    MethodContext(IWbemContext   __RPC_FAR *piContext, CWbemProviderGlue *pGlue);
    ~MethodContext();
    
    virtual HRESULT Commit(CInstance *pInstance) = 0;
    virtual IWbemContext __RPC_FAR *GetIWBEMContext();
    
    LONG AddRef(void);
    LONG Release(void);
    virtual void QueryPostProcess(void);
        
    bool SetStatusObject(IWbemClassObject *pObj);
    IWbemClassObject __RPC_FAR *GetStatusObject();

#ifdef PROVIDER_INSTRUMENTATION
    StopWatch *pStopWatch;
#endif
    
private:
    CWbemProviderGlue* GetProviderGlue();
    CWbemProviderGlue   *m_pGlue;
    IWbemContext        __RPC_FAR *m_pContext;
    IWbemClassObject    __RPC_FAR *m_pStatusObject;

};

// for queries and suchlike that originate in CIMOM
class 
__declspec(uuid("9113D3B4-D114-11d2-B35D-00104BC97924")) 
ExternalMethodContext  : public MethodContext
{
public:
    ExternalMethodContext(IWbemObjectSink __RPC_FAR *pResponseHandler,
                          IWbemContext    __RPC_FAR *pContext,
                          CWbemProviderGlue *pGlue,
                          void                      *pReserved = NULL
                          );
    
    HRESULT Commit(CInstance *pInstance);
    virtual void QueryPostProcess(void);
    
    LONG AddRef(void);
    LONG Release(void);
    
private:
    IWbemObjectSink __RPC_FAR *m_pResponseHandler;
    void                      *m_pReserved;
};

// for queries and suchlike that come from within.
// contains a list of objects returned. 
class 
__declspec(uuid("6AF4B074-D121-11d2-B35D-00104BC97924"))
InternalMethodContext : public MethodContext
{
public:
    InternalMethodContext(TRefPointerCollection<CInstance> *pList ,
                          IWbemContext    __RPC_FAR *pContext,
                          CWbemProviderGlue *pGlue);
    ~InternalMethodContext();
    
    HRESULT Commit(CInstance *pInstance);
    
    LONG AddRef(void);
    LONG Release(void);
    
private:
    TRefPointerCollection<CInstance> *m_pInstances;
};

// for queries and suchlike that come from within.
// "Asynch" is a bit of a misnomer - but it does help support
// asynchronous calls, in that each instance committed is routed
// to a callback function supplied by the requester
class 
__declspec(uuid("D98A82E8-D121-11d2-B35D-00104BC97924"))
InternalMethodContextAsynch : public MethodContext
{
public:
    InternalMethodContextAsynch(Provider *pThat,
                                LPProviderInstanceCallback pCallback,
                                IWbemContext __RPC_FAR *pContext,
                                MethodContext *pUsersContext,
                                void *pUserData);
    ~InternalMethodContextAsynch();
    
    HRESULT Commit(CInstance *pInstance);
    
    LONG AddRef(void);
    LONG Release(void);
    
private:
    Provider *m_pThat;
    LPProviderInstanceCallback m_pCallback;
    void *m_pUserData;
    MethodContext *m_pUsersContext;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\metadatadeviceservice.h ===
/*
 *  MetadataDeviceService.h
 *
 *  Contains definitions of the Device Metadata Service
 *
 *  Copyright (c) Microsoft Corporation, All Rights Reserved.
 *
 */

#ifndef _METADATADEVICESERVICE_H_
#define _METADATADEVICESERVICE_H_

#include <DeviceServices.h>

/*****************************************************************************/
/*  Device Metadata Service Info                                             */
/*****************************************************************************/

DEFINE_DEVSVCGUID(SERVICE_DeviceMetadata,
    0x332ffe6a, 0xaf65, 0x41e1, 0xa0, 0xaf, 0xd3, 0xe2, 0x62, 0x7b, 0xdf, 0x54);

#define NAME_DeviceMetadataSvc              L"Metadata"
#define TYPE_DeviceMetadataSvc              DEVSVCTYPE_DEFAULT


/*****************************************************************************/
/*  Device Metadata Service Object Formats                                   */
/*****************************************************************************/

/*  FORMAT_DeviceMetadataCAB
 *
 *  CAB object format
 */

DEFINE_DEVSVCGUID(FORMAT_DeviceMetadataCAB,
    0xe1809599, 0x4303, 0x4e3b, 0x92, 0x44, 0x99, 0xc6, 0x2c, 0x25, 0x45, 0x51);

#define NAME_DeviceMetadataCAB              L"DeviceMetadataCAB"


/*****************************************************************************/
/*  Device Metadata Service Object Property Keys                             */
/*****************************************************************************/

DEFINE_DEVSVCGUID(NAMESPACE_DeviceMetadataObj,
    0x68bb7eeb, 0x9eef, 0x45bd, 0x8d, 0xe6, 0x3b, 0x92, 0xa5, 0x7c, 0xae, 0x1e);


/*  PKEY_DeviceMetadataObj_ContentID
 *
 *  Contains the GUID that uniquely identifies the object cab contents.
 *
 *  Type: UInt128
 *  Form: None
 */

DEFINE_DEVSVCPROPKEY(PKEY_DeviceMetadataObj_ContentID,
    0x68bb7eeb, 0x9eef, 0x45bd, 0x8d, 0xe6, 0x3b, 0x92, 0xa5, 0x7c, 0xae, 0x1e,
    3);

#define NAME_DeviceMetadataObj_ContentID    L"ContentID"


/*  PKEY_DeviceMetadataObj_DefaultCAB
 *
 *  Indicates whether this object is the default cab.  Each service shall have
 *  only one object marked as default.
 *
 *  Type: UInt8 Boolean
 *  Form: Enum
 */

DEFINE_DEVSVCPROPKEY(PKEY_DeviceMetadataObj_DefaultCAB,
    0x68bb7eeb, 0x9eef, 0x45bd, 0x8d, 0xe6, 0x3b, 0x92, 0xa5, 0x7c, 0xae, 0x1e,
    4);

#define NAME_DeviceMetadataObj_DefaultCAB   L"DefaultCAB"

#define ENUM_DeviceMetadataObj_DefaultCABFalse  0
#define ENUM_DeviceMetadataObj_DefaultCABTrue   1

#endif  /* _METADATADEVICESERVICE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\messagedeviceservice.h ===
/*
 *  MessageDeviceService.h
 *
 *  Contains declarations for the Message Device Service
 *
 *  Copyright (c) Microsoft Corporation, All Rights Reserved.
 *
 */

#ifndef _MESSAGEDEVICESERVICE_H_
#define _MESSAGEDEVICESERVICE_H_

#include <DeviceServices.h>

/*****************************************************************************/
/*  Message Service Info                                                     */
/*****************************************************************************/

DEFINE_DEVSVCGUID(SERVICE_Message,
    0x29b43bd0, 0x6b16, 0x49af, 0xb7, 0x2e, 0x85, 0x77, 0x0a, 0xdf, 0xeb, 0xdd);

#define NAME_MessageSvc                 L"Message"
#define TYPE_MessageSvc                 DEVSVCTYPE_DEFAULT


/*****************************************************************************/
/*  Message Service Object Formats                                           */
/*****************************************************************************/

/*  FORMAT_AbstractMessage
 *
 *  MTP Format: Abstract Message (0xBB01)
 *  Suggested MIME Type:
 */

DEFINE_DEVSVCGUID(FORMAT_AbstractMessage,
    0xBB010000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7);

#define NAME_AbstractMessage            L"AbstractMessage"


/*  FORMAT_AbstractMessageFolder
 *
 *  MTP Format: Abstract Message Folder (0xBA07)
 *  Suggested MIME Type:
 */

DEFINE_DEVSVCGUID(FORMAT_AbstractMessageFolder,
    0xBA070000, 0xAE6C, 0x4804, 0x98, 0xBA, 0xC5, 0x7B, 0x46, 0x96, 0x5F, 0xE7);

#define NAME_AbstractMessageFolder          L"AbstractMessageFolder"


/*****************************************************************************/
/*  Message Service Object Property Keys                                     */
/*****************************************************************************/

DEFINE_DEVSVCGUID(MESSAGESVC_OBJECT_PROPERTIES,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F);


/*  MessageObj.Subject
 *
 *  MTP Property: Subject (0xDCE2)
 *  Type: String/AUInt16
 *  Form: None/LongString
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_Subject,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    2);

#define NAME_MessageObj_Subject             L"Subject"


/*  MessageObj.Body
 *
 *  MTP Property: Body Text (0xDCE1)
 *  Type: AUInt16
 *  Form: LongString
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_Body,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    3);

#define NAME_MessageObj_Body                L"Body"


/*  MessageObj.Priority
 *
 *  Type: UInt16
 *  Form: Enum
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_Priority,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    4);

#define NAME_MessageObj_Priority            L"Priority"

#define ENUM_MessageObj_PriorityHighest     2
#define ENUM_MessageObj_PriorityNormal      1
#define ENUM_MessageObj_PriorityLowest      0


/*  MessageObj.Category
 *
 *  MTP Property:  ()
 *  Type: String/AUInt16
 *  Form: None/LongString
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_Category,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    10);

#define NAME_MessageObj_Category            L"Category"


/*  MessageObj.Sender
 *
 *  MTP Property: Message Sender (0xDD45)
 *  Type: String/AUInt16
 *  Form: None/LongString
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_Sender,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    18);

#define NAME_MessageObj_Sender              L"Sender"


/*  MessageObj.To
 *
 *  MTP Property: Message To (0xDD40)
 *  Type: AUInt16
 *  Form: LongString
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_To,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    20);

#define NAME_MessageObj_To                  L"To"


/*  MessageObj.CC
 *
 *  MTP Property: Message CC (0xDD41)
 *  Type: AUInt16
 *  Form: LongString
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_CC,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    21);

#define NAME_MessageObj_CC                  L"CC"


/*  MessageObj.BCC
 *
 *  MTP Property: Message BCC (0xDD42)
 *  Type: AUInt16
 *  Form: LongString
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_BCC,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    22);

#define NAME_MessageObj_BCC                 L"BCC"


/*  MessageObj.Read
 *
 *  MTP Property: Message Read (0xDD43)
 *  Type: UInt16
 *  Form: Enum
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_Read,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    23);

#define NAME_MessageObj_Read                L"Read"

#define ENUM_MessageObj_ReadFalse           0x00
#define ENUM_MessageObj_ReadTrue            0xff


/*  MessageObj.ReceivedTime
 *
 *  MTP Property: Message Received Time (0xDD44)
 *  Type: String
 *  Form: DateTime
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_ReceivedTime,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    24);

#define NAME_MessageObj_ReceivedTime        L"ReceivedTime"


/*  MessageObj.PatternOriginalDateTime
 *
 *  Contains the original UTC time that a recurring item was to take place.
 *
 *  Type: String
 *  Form: DateTime
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_PatternOriginalDateTime,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    26);

#define NAME_MessageObj_PatternOriginalDateTime L"PatternOriginalDateTime"


/*  MessageObj.PatternType
 *
 *  Contains the pattern type of the recurring item.
 *
 *  Type: UInt32
 *  Form: Enum
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_PatternType,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    27);

#define NAME_MessageObj_PatternType         L"PatternType"

#define ENUM_MessageObj_PatternTypeDaily    0x00000001
#define ENUM_MessageObj_PatternTypeWeekly   0x00000002
#define ENUM_MessageObj_PatternTypeMonthly  0x00000003
#define ENUM_MessageObj_PatternTypeYearly   0x00000004


/*  MessageObj.PatternValidStartDate
 *
 *  Contains the first date on which the recurrence pattern is valid.  The
 *  first instance of the recurring item is on or after this date.  The date
 *  is in the time reference of the recurring item.
 *
 *  Type: String
 *  Form: ISO 8601 Date
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_PatternValidStartDate,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    28);

#define NAME_MessageObj_PatternValidStartDate   L"PatternValidStartDate"


/*  MessageObj.PatternValidEndDate
 *
 *  Contains the last date on which the recurrence pattern is valid.  The
 *  last instance of the recurring item is on or before this date.  The date
 *  is in the time reference of the recurring item.
 *
 *  Type: String
 *  Form: ISO 8601 Date
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_PatternValidEndDate,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    29);

#define NAME_MessageObj_PatternValidEndDate L"PatternValidEndDate"


/*  MessageObj.PatternPeriod
 *
 *  Contains the period of the repeating recurrence pattern.  The units of this
 *  property are determined by the value of MessageObj.PatternType.
 *
 *  Type: UInt32
 *  Form: None
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_PatternPeriod,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    31);

#define NAME_MessageObj_PatternPeriod       L"PatternPeriod"


/*  MessageObj.PatternDayOfWeek
 *
 *  Contains the day of week mask for weekly, monthly, and yearly recurrence
 *  patterns.
 *
 *  Type: UInt16
 *  Form: None
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_PatternDayOfWeek,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    32);

#define NAME_MessageObj_PatternDayOfWeek    L"PatternDayOfWeek"

#define FLAG_MessageObj_DayOfWeekNone       0x0000
#define FLAG_MessageObj_DayOfWeekSunday     0x0001
#define FLAG_MessageObj_DayOfWeekMonday     0x0002
#define FLAG_MessageObj_DayOfWeekTuesday    0x0004
#define FLAG_MessageObj_DayOfWeekWednesday  0x0008
#define FLAG_MessageObj_DayOfWeekThursday   0x0010
#define FLAG_MessageObj_DayOfWeekFriday     0x0020
#define FLAG_MessageObj_DayOfWeekSaturday   0x0040


/*  MessageObj.PatternDayOfMonth
 *
 *  Contains the day of the month for monthly and yearly recurrence patterns.
 *  If day specified is greater than the number of days in the month the
 *  value is interpreted as the last valid day of the month.
 *
 *  Type: UInt8
 *  Form: Range
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_PatternDayOfMonth,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    33);

#define NAME_MessageObj_PatternDayOfMonth   L"PatternDayOfMonth"

#define RANGEMIN_MessageObj_PatternDayOfMonth   1
#define RANGEMAX_MessageObj_PatternDayOfMonth   31
#define RANGESTEP_MessageObj_PatternDayOfMonth  1

/*  MessageObj.PatternMonthOfYear
 *
 *  Contains the month of the year for yearly recurrence patterns.
 *
 *  Type: UInt8
 *  Form: Range
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_PatternMonthOfYear,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    34);

#define NAME_MessageObj_PatternMonthOfYear  L"PatternMonthOfYear"

#define RANGEMIN_MessageObj_PatternMonthOfYear  1
#define RANGEMAX_MessageObj_PatternMonthOfYear  12
#define RANGESTEP_MessageObj_PatternMonthOfYear 1


/*  MessageObj.PatternInstance
 *
 *  Contains the instance of the recurring pattern that is to be matched.
 *
 *  Type: UInt8
 *  Form: Enum
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_PatternInstance,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    35);

#define NAME_MessageObj_PatternInstance     L"PatternInstance"

#define ENUM_MessageObj_PatternInstanceNone     0x00
#define ENUM_MessageObj_PatternInstanceFirst    0x01
#define ENUM_MessageObj_PatternInstanceSecond   0x02
#define ENUM_MessageObj_PatternInstanceThird    0x03
#define ENUM_MessageObj_PatternInstanceFourth   0x04
#define ENUM_MessageObj_PatternInstanceLast     0x05


/*  MessageObj.PatternDeleteDates
 *
 *  Contains a semi-colon separated list of the the dates on which instances
 *  of the recurring item have been deleted.  Does not contain the original
 *  dates for items which have been moved.  The date specified is in the
 *  time reference of the recurrence.
 *
 *  Type: AUInt16
 *  Form: LongString
 */

DEFINE_DEVSVCPROPKEY(PKEY_MessageObj_PatternDeleteDates,
    0xB28AE94B, 0x05A4, 0x4E8E, 0xBE, 0x01, 0x72, 0xCC, 0x7E, 0x09, 0x9D, 0x8F,
    36);

#define NAME_MessageObj_PatternDeleteDates  L"PatternDeleteDates"

#endif  /* _MESSAGEDEVICESERVICE_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\mfapi.h ===
//*@@@+++@@@@******************************************************************
//
// Microsoft Windows Media Foundation
// Copyright (C) Microsoft Corporation. All rights reserved.
//
//*@@@---@@@@******************************************************************
//

//
// MFAPI.h is the header containing the APIs for using the MF platform.
//

#pragma once
#if !defined(__MFAPI_H__)
#define __MFAPI_H__

#pragma pack(push, mfhrds)
#include <mfobjects.h>
#pragma pack(pop, mfhrds)

#include "mmreg.h"

#include <avrt.h>
#ifndef AVRT_DATA
#define AVRT_DATA
#endif
#ifndef AVRT_BSS
#define AVRT_BSS
#endif

#if !defined(MF_VERSION)

#if (WINVER >= _WIN32_WINNT_WIN7)

#define MF_SDK_VERSION 0x0002

#else // Vista

#define MF_SDK_VERSION 0x0001

#endif // (WINVER >= _WIN32_WINNT_WIN7)

#define MF_API_VERSION 0x0070 // This value is unused in the Win7 release and left at its Vista release value
#define MF_VERSION (MF_SDK_VERSION << 16 | MF_API_VERSION)

#endif //!defined(MF_VERSION)


#define MFSTARTUP_NOSOCKET 0x1
#define MFSTARTUP_LITE (MFSTARTUP_NOSOCKET)
#define MFSTARTUP_FULL 0

#if defined(__cplusplus)
extern "C" {
#endif

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////   Startup/Shutdown  ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// Initializes the platform object.
// Must be called before using Media Foundation.
// A matching MFShutdown call must be made when the application is done using
// Media Foundation.
// The "Version" parameter should be set to MF_API_VERSION.
// Application should not call MFStartup / MFShutdown from workqueue threads
//
#if defined(__cplusplus)
STDAPI MFStartup( ULONG Version, DWORD dwFlags = MFSTARTUP_FULL );
#else
STDAPI MFStartup( ULONG Version, DWORD dwFlags );
#endif

//
// Shuts down the platform object.
// Releases all resources including threads.
// Application should call MFShutdown the same number of times as MFStartup
// Application should not call MFStartup / MFShutdown from workqueue threads
//
STDAPI MFShutdown();


////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////    Platform    ///////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// These functions can be used to keep the MF platform object in place.
// Every call to MFLockPlatform should have a matching call to MFUnlockPlatform
//
STDAPI MFLockPlatform();
STDAPI MFUnlockPlatform();

///////////////////////////////////////////////////////////////////////////////

//
// MF workitem functions
//
typedef unsigned __int64 MFWORKITEM_KEY;

STDAPI MFPutWorkItem(
            DWORD dwQueue,
            IMFAsyncCallback * pCallback,
            IUnknown * pState);

STDAPI MFPutWorkItemEx(
            DWORD dwQueue,
            IMFAsyncResult * pResult);

STDAPI MFScheduleWorkItem(
            IMFAsyncCallback * pCallback,
            IUnknown * pState,
            INT64 Timeout,
            __out_opt MFWORKITEM_KEY * pKey);

STDAPI MFScheduleWorkItemEx(
            IMFAsyncResult * pResult,
            INT64 Timeout,
            __out_opt MFWORKITEM_KEY * pKey);

//
//   The CancelWorkItem method is used by objects to cancel scheduled operation
//   Due to asynchronous nature of timers, application might still get a
//   timer callback after MFCancelWorkItem has returned.
//
STDAPI MFCancelWorkItem(
            MFWORKITEM_KEY Key);


///////////////////////////////////////////////////////////////////////////////

//
// MF periodic callbacks
//
STDAPI MFGetTimerPeriodicity(
            __out DWORD * Periodicity);

typedef void (*MFPERIODICCALLBACK)(IUnknown* pContext);

STDAPI MFAddPeriodicCallback(
            MFPERIODICCALLBACK Callback,
            IUnknown * pContext,
            __out_opt DWORD * pdwKey);

STDAPI MFRemovePeriodicCallback(
            DWORD dwKey);

///////////////////////////////////////////////////////////////////////////////

//
// MF work queues
//

#if (WINVER >= _WIN32_WINNT_WIN7)
//
// MFASYNC_WORKQUEUE_TYPE: types of work queue used by MFAllocateWorkQueueEx
//
typedef enum
{
    // MF_STANDARD_WORKQUEUE: Work queue in a thread without Window 
    // message loop.
    MF_STANDARD_WORKQUEUE = 0,

    // MF_WINDOW_WORKQUEUE: Work queue in a thread running Window 
    // Message loop that calls PeekMessage() / DispatchMessage()..
    MF_WINDOW_WORKQUEUE = 1,
}   MFASYNC_WORKQUEUE_TYPE;

STDAPI MFAllocateWorkQueueEx(
            __in MFASYNC_WORKQUEUE_TYPE WorkQueueType,
            __out OUT DWORD * pdwWorkQueue);
#endif // (WINVER >= _WIN32_WINNT_WIN7)

//
// Allocate a standard work queue. the behaviour is the same with:
// MFAllocateWorkQueueEx( MF_STANDARD_WORKQUEUE, pdwWorkQueue )
//
STDAPI MFAllocateWorkQueue(
            __out OUT DWORD * pdwWorkQueue);


STDAPI MFLockWorkQueue(
            __in DWORD dwWorkQueue);

STDAPI MFUnlockWorkQueue(
            __in DWORD dwWorkQueue);

STDAPI MFBeginRegisterWorkQueueWithMMCSS(
            DWORD dwWorkQueueId,
            __in LPCWSTR wszClass,
            DWORD dwTaskId,
            __in IMFAsyncCallback * pDoneCallback,
            __in IUnknown * pDoneState );

STDAPI MFEndRegisterWorkQueueWithMMCSS(
            __in IMFAsyncResult * pResult,
            __out DWORD * pdwTaskId );

STDAPI MFBeginUnregisterWorkQueueWithMMCSS(
            DWORD dwWorkQueueId,
            __in IMFAsyncCallback * pDoneCallback,
            __in IUnknown * pDoneState );

STDAPI MFEndUnregisterWorkQueueWithMMCSS(
            __in IMFAsyncResult * pResult );

STDAPI MFGetWorkQueueMMCSSClass(
            DWORD dwWorkQueueId,
            __out_ecount_part_opt(*pcchClass,*pcchClass)  LPWSTR pwszClass,
            __inout  DWORD *pcchClass );

STDAPI MFGetWorkQueueMMCSSTaskId(
            DWORD dwWorkQueueId,
            __out LPDWORD pdwTaskId );

///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////    Async Model //////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//
// Instantiates the MF-provided Async Result implementation
//
STDAPI MFCreateAsyncResult(
    IUnknown * punkObject,
    IMFAsyncCallback * pCallback,
    IUnknown * punkState,
    __out IMFAsyncResult ** ppAsyncResult );

//
// Helper for calling IMFAsyncCallback::Invoke
//
STDAPI MFInvokeCallback(
    IMFAsyncResult * pAsyncResult );


//
// MFASYNCRESULT struct.
// Any implementation of IMFAsyncResult must inherit from this struct;
// the Media Foundation workqueue implementation depends on this.
//
#if defined(__cplusplus) && !defined(CINTERFACE)
typedef struct tagMFASYNCRESULT : public IMFAsyncResult
{
    OVERLAPPED overlapped;
    IMFAsyncCallback * pCallback;
    HRESULT hrStatusResult;
    DWORD dwBytesTransferred;
    HANDLE hEvent;
}   MFASYNCRESULT;
#else /* C style interface */
typedef struct tagMFASYNCRESULT
{
    IMFAsyncResult AsyncResult;
    OVERLAPPED overlapped;
    IMFAsyncCallback * pCallback;
    HRESULT hrStatusResult;
    DWORD dwBytesTransferred;
    HANDLE hEvent;
}   MFASYNCRESULT;
#endif /* C style interface */


///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////    Files       //////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//
// Regardless of the access mode with which the file is opened, the sharing
// permissions will allow shared reading and deleting.
//
STDAPI MFCreateFile(
    MF_FILE_ACCESSMODE  AccessMode,
    MF_FILE_OPENMODE    OpenMode,
    MF_FILE_FLAGS       fFlags,
    LPCWSTR             pwszFileURL,
    __out IMFByteStream       **ppIByteStream );

STDAPI MFCreateTempFile(
    MF_FILE_ACCESSMODE  AccessMode,
    MF_FILE_OPENMODE    OpenMode,
    MF_FILE_FLAGS       fFlags,
    __out IMFByteStream       **ppIByteStream );

STDAPI MFBeginCreateFile(
    MF_FILE_ACCESSMODE  AccessMode,
    MF_FILE_OPENMODE    OpenMode,
    MF_FILE_FLAGS       fFlags,
    LPCWSTR             pwszFilePath,
    IMFAsyncCallback *  pCallback,
    IUnknown *          pState,
    __out IUnknown ** ppCancelCookie);

STDAPI MFEndCreateFile(
    IMFAsyncResult * pResult,
    __out IMFByteStream **ppFile );

STDAPI MFCancelCreateFile(
    IUnknown * pCancelCookie);


///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////    Buffers     //////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//
// Creates an IMFMediaBuffer in memory
//
STDAPI MFCreateMemoryBuffer(
    __in DWORD                      cbMaxLength,
    __out IMFMediaBuffer **         ppBuffer );

//
// Creates an IMFMediaBuffer wrapper at the given offset and length
// within an existing IMFMediaBuffer
//
STDAPI MFCreateMediaBufferWrapper(
    __in IMFMediaBuffer *           pBuffer,
    __in DWORD                      cbOffset,
    __in DWORD                      dwLength,
    __out IMFMediaBuffer **         ppBuffer );

//
// Creates a legacy buffer (IMediaBuffer) wrapper at the given offset within
// an existing IMFMediaBuffer.
// pSample is optional.  It can point to the original IMFSample from which this
// IMFMediaBuffer came.  If provided, then *ppMediaBuffer will succeed
// QueryInterface for IID_IMFSample, from which the original sample's attributes
// can be obtained
//
STDAPI MFCreateLegacyMediaBufferOnMFMediaBuffer(
    __in_opt IMFSample *            pSample,
    __in IMFMediaBuffer *           pMFMediaBuffer,
    __in DWORD                      cbOffset,
    __deref_out IMediaBuffer **     ppMediaBuffer );

//
// Create a DirectX surface buffer
//
STDAPI MFCreateDXSurfaceBuffer(
    __in REFIID                     riid,
    __in IUnknown *                 punkSurface,
    __in BOOL                       fBottomUpWhenLinear,
    __deref_out IMFMediaBuffer **   ppBuffer );


//
// Create an aligned memory buffer.
// The following constants were chosen for parity with the alignment constants
// in ntioapi.h
// 
#define MF_1_BYTE_ALIGNMENT       0x00000000 
#define MF_2_BYTE_ALIGNMENT       0x00000001
#define MF_4_BYTE_ALIGNMENT       0x00000003
#define MF_8_BYTE_ALIGNMENT       0x00000007 
#define MF_16_BYTE_ALIGNMENT      0x0000000f
#define MF_32_BYTE_ALIGNMENT      0x0000001f
#define MF_64_BYTE_ALIGNMENT      0x0000003f
#define MF_128_BYTE_ALIGNMENT     0x0000007f
#define MF_256_BYTE_ALIGNMENT     0x000000ff
#define MF_512_BYTE_ALIGNMENT     0x000001ff

STDAPI MFCreateAlignedMemoryBuffer(
    __in DWORD                      cbMaxLength,
    __in DWORD                      cbAligment, 
    __out IMFMediaBuffer **         ppBuffer );

//
// This GUID is used in IMFGetService::GetService calls to retrieve 
// interfaces from the buffer.  Its value is defined in evr.h
// 
EXTERN_C const GUID MR_BUFFER_SERVICE;

///////////////////////////////////////////////////////////////////////////////
/////////////////////////////////    Events      //////////////////////////////
///////////////////////////////////////////////////////////////////////////////

//
// Instantiates the MF-provided Media Event implementation.
//
STDAPI MFCreateMediaEvent(
    __in MediaEventType met,
    __in REFGUID guidExtendedType,
    __in HRESULT hrStatus,
    __in_opt const PROPVARIANT * pvValue,
    __out IMFMediaEvent ** ppEvent );

//
// Instantiates an object that implements IMFMediaEventQueue.
// Components that provide an IMFMediaEventGenerator can use this object
// internally to do their Media Event Generator work for them.
// IMFMediaEventGenerator calls should be forwarded to the similar call
// on this object's IMFMediaEventQueue interface (e.g. BeginGetEvent,
// EndGetEvent), and the various IMFMediaEventQueue::QueueEventXXX methods
// can be used to queue events that the caller will consume.
//
STDAPI MFCreateEventQueue(
    __out IMFMediaEventQueue **ppMediaEventQueue );

//
// Event attributes
// Some of the common Media Foundation events have associated attributes
// that go in their IMFAttributes stores
//

//
// MESessionCapabilitiesChanged attributes
//

// MF_EVENT_SESSIONCAPS {7E5EBCD0-11B8-4abe-AFAD-10F6599A7F42}
// Type: UINT32
DEFINE_GUID(MF_EVENT_SESSIONCAPS,
0x7e5ebcd0, 0x11b8, 0x4abe, 0xaf, 0xad, 0x10, 0xf6, 0x59, 0x9a, 0x7f, 0x42);

// MF_EVENT_SESSIONCAPS_DELTA {7E5EBCD1-11B8-4abe-AFAD-10F6599A7F42}
// Type: UINT32
DEFINE_GUID(MF_EVENT_SESSIONCAPS_DELTA,
0x7e5ebcd1, 0x11b8, 0x4abe, 0xaf, 0xad, 0x10, 0xf6, 0x59, 0x9a, 0x7f, 0x42);

// Session capabilities bitflags
#define MFSESSIONCAP_START              0x00000001
#define MFSESSIONCAP_SEEK               0x00000002
#define MFSESSIONCAP_PAUSE              0x00000004
#define MFSESSIONCAP_RATE_FORWARD       0x00000010
#define MFSESSIONCAP_RATE_REVERSE       0x00000020

//
// MESessionTopologyStatus attributes
//

// Possible values for MF_EVENT_TOPOLOGY_STATUS attribute.
//
// For a given topology, these status values will arrive via
// MESessionTopologyStatus in the order below.
//
// However, there are no guarantees about how these status values will be
// ordered between two consecutive topologies.  For example,
// MF_TOPOSTATUS_READY could arrive for topology n+1 before
// MF_TOPOSTATUS_ENDED arrives for topology n if the application called
// IMFMediaSession::SetTopology for topology n+1 well enough in advance of the
// end of topology n.  Conversely, if topology n ends before the application
// calls IMFMediaSession::SetTopology for topology n+1, then
// MF_TOPOSTATUS_ENDED will arrive for topology n before MF_TOPOSTATUS_READY
// arrives for topology n+1.
typedef enum
{
    // MF_TOPOSTATUS_INVALID: Invalid value; will not be sent
    MF_TOPOSTATUS_INVALID = 0,

    // MF_TOPOSTATUS_READY: The topology has been put in place and is
    // ready to start.  All GetService calls to the Media Session will use
    // this topology.
    MF_TOPOSTATUS_READY     = 100,

    // MF_TOPOSTATUS_STARTED_SOURCE: The Media Session has started to read
    // and process data from the Media Source(s) in this topology.
    MF_TOPOSTATUS_STARTED_SOURCE = 200,


#if (WINVER >= _WIN32_WINNT_WIN7)
    // MF_TOPOSTATUS_DYNAMIC_CHANGED: The topology has been dynamic changed
    // due to the format change.
    MF_TOPOSTATUS_DYNAMIC_CHANGED = 210,
#endif // (WINVER >= _WIN32_WINNT_WIN7) 

    // MF_TOPOSTATUS_SINK_SWITCHED: The Media Sinks in the pipeline have
    // switched from a previous topology to this topology.
    // Note that this status does not get sent for the first topology;
    // applications can assume that the sinks are playing the first
    // topology when they receive MESessionStarted.
    MF_TOPOSTATUS_SINK_SWITCHED = 300,
    
    // MF_TOPOSTATUS_ENDED: Playback of this topology is complete.
    // Before deleting this topology, however, the application should wait
    // for either MESessionEnded or the MF_TOPOSTATUS_STARTED_SOURCE status
    // on the next topology to ensure that the Media Session is no longer
    // using this topology.
    MF_TOPOSTATUS_ENDED = 400,

}   MF_TOPOSTATUS;

// MF_EVENT_TOPOLOGY_STATUS {30C5018D-9A53-454b-AD9E-6D5F8FA7C43B}
// Type: UINT32 {MF_TOPOLOGY_STATUS}
DEFINE_GUID(MF_EVENT_TOPOLOGY_STATUS,
0x30c5018d, 0x9a53, 0x454b, 0xad, 0x9e, 0x6d, 0x5f, 0x8f, 0xa7, 0xc4, 0x3b);

//
// MESessionNotifyPresentationTime attributes
//

// MF_EVENT_START_PRESENTATION_TIME {5AD914D0-9B45-4a8d-A2C0-81D1E50BFB07}
// Type: UINT64
DEFINE_GUID(MF_EVENT_START_PRESENTATION_TIME,
0x5ad914d0, 0x9b45, 0x4a8d, 0xa2, 0xc0, 0x81, 0xd1, 0xe5, 0xb, 0xfb, 0x7);

// MF_EVENT_PRESENTATION_TIME_OFFSET {5AD914D1-9B45-4a8d-A2C0-81D1E50BFB07}
// Type: UINT64
DEFINE_GUID(MF_EVENT_PRESENTATION_TIME_OFFSET,
0x5ad914d1, 0x9b45, 0x4a8d, 0xa2, 0xc0, 0x81, 0xd1, 0xe5, 0xb, 0xfb, 0x7);

// MF_EVENT_START_PRESENTATION_TIME_AT_OUTPUT {5AD914D2-9B45-4a8d-A2C0-81D1E50BFB07}
// Type: UINT64
DEFINE_GUID(MF_EVENT_START_PRESENTATION_TIME_AT_OUTPUT,
0x5ad914d2, 0x9b45, 0x4a8d, 0xa2, 0xc0, 0x81, 0xd1, 0xe5, 0xb, 0xfb, 0x7);

//

//
// MESourceStarted attributes
//

// MF_EVENT_SOURCE_FAKE_START {a8cc55a7-6b31-419f-845d-ffb351a2434b}
// Type: UINT32
DEFINE_GUID(MF_EVENT_SOURCE_FAKE_START,
0xa8cc55a7, 0x6b31, 0x419f, 0x84, 0x5d, 0xff, 0xb3, 0x51, 0xa2, 0x43, 0x4b);

// MF_EVENT_SOURCE_PROJECTSTART {a8cc55a8-6b31-419f-845d-ffb351a2434b}
// Type: UINT64
DEFINE_GUID(MF_EVENT_SOURCE_PROJECTSTART,
0xa8cc55a8, 0x6b31, 0x419f, 0x84, 0x5d, 0xff, 0xb3, 0x51, 0xa2, 0x43, 0x4b);

// MF_EVENT_SOURCE_ACTUAL_START {a8cc55a9-6b31-419f-845d-ffb351a2434b}
// Type: UINT64
DEFINE_GUID(MF_EVENT_SOURCE_ACTUAL_START,
0xa8cc55a9, 0x6b31, 0x419f, 0x84, 0x5d, 0xff, 0xb3, 0x51, 0xa2, 0x43, 0x4b);

//
// MEEndOfPresentationSegment attributes
//

// MF_EVENT_SOURCE_TOPOLOGY_CANCELED {DB62F650-9A5E-4704-ACF3-563BC6A73364}
// Type: UINT32
DEFINE_GUID(MF_EVENT_SOURCE_TOPOLOGY_CANCELED,
0xdb62f650, 0x9a5e, 0x4704, 0xac, 0xf3, 0x56, 0x3b, 0xc6, 0xa7, 0x33, 0x64);

//
// MESourceCharacteristicsChanged attributes
//

// MF_EVENT_SOURCE_CHARACTERISTICS {47DB8490-8B22-4f52-AFDA-9CE1B2D3CFA8}
// Type: UINT32
DEFINE_GUID(MF_EVENT_SOURCE_CHARACTERISTICS,
0x47db8490, 0x8b22, 0x4f52, 0xaf, 0xda, 0x9c, 0xe1, 0xb2, 0xd3, 0xcf, 0xa8);

// MF_EVENT_SOURCE_CHARACTERISTICS_OLD {47DB8491-8B22-4f52-AFDA-9CE1B2D3CFA8}
// Type: UINT32
DEFINE_GUID(MF_EVENT_SOURCE_CHARACTERISTICS_OLD,
0x47db8491, 0x8b22, 0x4f52, 0xaf, 0xda, 0x9c, 0xe1, 0xb2, 0xd3, 0xcf, 0xa8);

//
// MESourceRateChangeRequested attributes
//

// MF_EVENT_DO_THINNING {321EA6FB-DAD9-46e4-B31D-D2EAE7090E30}
// Type: UINT32
DEFINE_GUID(MF_EVENT_DO_THINNING,
0x321ea6fb, 0xdad9, 0x46e4, 0xb3, 0x1d, 0xd2, 0xea, 0xe7, 0x9, 0xe, 0x30);

//
// MEStreamSinkScrubSampleComplete attributes
//

// MF_EVENT_SCRUBSAMPLE_TIME {9AC712B3-DCB8-44d5-8D0C-37455A2782E3}
// Type: UINT64
DEFINE_GUID(MF_EVENT_SCRUBSAMPLE_TIME,
0x9ac712b3, 0xdcb8, 0x44d5, 0x8d, 0xc, 0x37, 0x45, 0x5a, 0x27, 0x82, 0xe3);

//
// MESinkInvalidated and MESessionStreamSinkFormatChanged attributes
//

// MF_EVENT_OUTPUT_NODE {830f1a8b-c060-46dd-a801-1c95dec9b107}
// Type: UINT64
DEFINE_GUID(MF_EVENT_OUTPUT_NODE,
0x830f1a8b, 0xc060, 0x46dd, 0xa8, 0x01, 0x1c, 0x95, 0xde, 0xc9, 0xb1, 0x07);

#if (WINVER >= _WIN32_WINNT_WIN7)
//
// METransformNeedInput attributes
// 

// MF_EVENT_MFT_INPUT_STREAM_ID {F29C2CCA-7AE6-42d2-B284-BF837CC874E2}
// Type: UINT32
DEFINE_GUID(MF_EVENT_MFT_INPUT_STREAM_ID, 
0xf29c2cca, 0x7ae6, 0x42d2, 0xb2, 0x84, 0xbf, 0x83, 0x7c, 0xc8, 0x74, 0xe2);

//
// METransformDrainComplete and METransformMarker attributes
//

// MF_EVENT_MFT_CONTEXT {B7CD31F1-899E-4b41-80C9-26A896D32977}
// Type: UINT64
DEFINE_GUID(MF_EVENT_MFT_CONTEXT, 
0xb7cd31f1, 0x899e, 0x4b41, 0x80, 0xc9, 0x26, 0xa8, 0x96, 0xd3, 0x29, 0x77);

#endif // (WINVER >= _WIN32_WINNT_WIN7)

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////  Samples  //////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// Creates an instance of the Media Foundation implementation of IMFSample
//
STDAPI MFCreateSample( __out IMFSample **ppIMFSample );

//
// Sample attributes
// These are the well-known attributes that can be present on an MF Sample's
// IMFAttributes store
//

// MFSampleExtension_CleanPoint {9cdf01d8-a0f0-43ba-b077-eaa06cbd728a}
// Type: UINT32
// If present and nonzero, indicates that the sample is a clean point (key
// frame), and decoding can begin at this sample.
DEFINE_GUID(MFSampleExtension_CleanPoint,
0x9cdf01d8, 0xa0f0, 0x43ba, 0xb0, 0x77, 0xea, 0xa0, 0x6c, 0xbd, 0x72, 0x8a);

// MFSampleExtension_Discontinuity {9cdf01d9-a0f0-43ba-b077-eaa06cbd728a}
// Type: UINT32
// If present and nonzero, indicates that the sample data represents the first
// sample following a discontinuity (gap) in the stream of samples.
// This can happen, for instance, if the previous sample was lost in
// transmission.
DEFINE_GUID(MFSampleExtension_Discontinuity,
0x9cdf01d9, 0xa0f0, 0x43ba, 0xb0, 0x77, 0xea, 0xa0, 0x6c, 0xbd, 0x72, 0x8a);

// MFSampleExtension_Token {8294da66-f328-4805-b551-00deb4c57a61}
// Type: IUNKNOWN
// When an IMFMediaStream delivers a sample via MEMediaStream, this attribute
// should be set to the IUnknown *pToken argument that was passed with the
// IMFMediaStream::RequestSample call to which this sample corresponds.
DEFINE_GUID(MFSampleExtension_Token,
0x8294da66, 0xf328, 0x4805, 0xb5, 0x51, 0x00, 0xde, 0xb4, 0xc5, 0x7a, 0x61);

//
// The following four sample attributes are used for encrypted samples
//
DEFINE_GUID(MFSampleExtension_DescrambleData,   // UINT64
0x43483be6, 0x4903, 0x4314, 0xb0, 0x32, 0x29, 0x51, 0x36, 0x59, 0x36, 0xfc);
DEFINE_GUID(MFSampleExtension_SampleKeyID,      // UINT32
0x9ed713c8, 0x9b87, 0x4b26, 0x82, 0x97, 0xa9, 0x3b, 0x0c, 0x5a, 0x8a, 0xcc);
DEFINE_GUID(MFSampleExtension_GenKeyFunc,       // UINT64
0x441ca1ee, 0x6b1f, 0x4501, 0x90, 0x3a, 0xde, 0x87, 0xdf, 0x42, 0xf6, 0xed);
DEFINE_GUID(MFSampleExtension_GenKeyCtx,        // UINT64
0x188120cb, 0xd7da, 0x4b59, 0x9b, 0x3e, 0x92, 0x52, 0xfd, 0x37, 0x30, 0x1c);
DEFINE_GUID(MFSampleExtension_PacketCrossOffsets,        // BLOB
0x2789671d, 0x389f, 0x40bb, 0x90, 0xd9, 0xc2, 0x82, 0xf7, 0x7f, 0x9a, 0xbd);

/////////////////////////////////////////////////////////////////////////////
//
// MFSample STANDARD EXTENSION ATTRIBUTE GUIDs
//
/////////////////////////////////////////////////////////////////////////////

// {b1d5830a-deb8-40e3-90fa-389943716461}   MFSampleExtension_Interlaced                {UINT32 (BOOL)}
DEFINE_GUID(MFSampleExtension_Interlaced,
0xb1d5830a, 0xdeb8, 0x40e3, 0x90, 0xfa, 0x38, 0x99, 0x43, 0x71, 0x64, 0x61);

// {941ce0a3-6ae3-4dda-9a08-a64298340617}   MFSampleExtension_BottomFieldFirst          {UINT32 (BOOL)}
DEFINE_GUID(MFSampleExtension_BottomFieldFirst,
0x941ce0a3, 0x6ae3, 0x4dda, 0x9a, 0x08, 0xa6, 0x42, 0x98, 0x34, 0x06, 0x17);

// {304d257c-7493-4fbd-b149-9228de8d9a99}   MFSampleExtension_RepeatFirstField          {UINT32 (BOOL)}
DEFINE_GUID(MFSampleExtension_RepeatFirstField,
0x304d257c, 0x7493, 0x4fbd, 0xb1, 0x49, 0x92, 0x28, 0xde, 0x8d, 0x9a, 0x99);

// {9d85f816-658b-455a-bde0-9fa7e15ab8f9}   MFSampleExtension_SingleField               {UINT32 (BOOL)}
DEFINE_GUID(MFSampleExtension_SingleField,
0x9d85f816, 0x658b, 0x455a, 0xbd, 0xe0, 0x9f, 0xa7, 0xe1, 0x5a, 0xb8, 0xf9);

// {6852465a-ae1c-4553-8e9b-c3420fcb1637}   MFSampleExtension_DerivedFromTopField       {UINT32 (BOOL)}
DEFINE_GUID(MFSampleExtension_DerivedFromTopField,
0x6852465a, 0xae1c, 0x4553, 0x8e, 0x9b, 0xc3, 0x42, 0x0f, 0xcb, 0x16, 0x37);



///////////////////////////////////////////////////////////////////////////////////////////////////////////////  Attributes ////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

STDAPI
MFCreateAttributes(
    __out   IMFAttributes** ppMFAttributes,
    __in    UINT32          cInitialSize
    );

STDAPI
MFInitAttributesFromBlob(
    __in                    IMFAttributes*  pAttributes,
    __in_bcount(cbBufSize)  const UINT8*    pBuf,
    __in                    UINT            cbBufSize
    );

STDAPI
MFGetAttributesAsBlobSize(
    __in    IMFAttributes*  pAttributes,
    __out   UINT32*         pcbBufSize
    );

STDAPI
MFGetAttributesAsBlob(
    __in                    IMFAttributes*  pAttributes,
    __out_bcount(cbBufSize) UINT8*          pBuf,
    __in                    UINT            cbBufSize
    );

///////////////////////////////////////////////////////////////////////////////////////////////////////////////  MFT Register & Enum ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// MFT Registry categories
//

#ifdef MF_INIT_GUIDS
#include <initguid.h>
#endif

// {d6c02d4b-6833-45b4-971a-05a4b04bab91}   MFT_CATEGORY_VIDEO_DECODER
DEFINE_GUID(MFT_CATEGORY_VIDEO_DECODER,
0xd6c02d4b, 0x6833, 0x45b4, 0x97, 0x1a, 0x05, 0xa4, 0xb0, 0x4b, 0xab, 0x91);

// {f79eac7d-e545-4387-bdee-d647d7bde42a}   MFT_CATEGORY_VIDEO_ENCODER
DEFINE_GUID(MFT_CATEGORY_VIDEO_ENCODER,
0xf79eac7d, 0xe545, 0x4387, 0xbd, 0xee, 0xd6, 0x47, 0xd7, 0xbd, 0xe4, 0x2a);

// {12e17c21-532c-4a6e-8a1c-40825a736397}   MFT_CATEGORY_VIDEO_EFFECT
DEFINE_GUID(MFT_CATEGORY_VIDEO_EFFECT,
0x12e17c21, 0x532c, 0x4a6e, 0x8a, 0x1c, 0x40, 0x82, 0x5a, 0x73, 0x63, 0x97);

// {059c561e-05ae-4b61-b69d-55b61ee54a7b}   MFT_CATEGORY_MULTIPLEXER
DEFINE_GUID(MFT_CATEGORY_MULTIPLEXER,
0x059c561e, 0x05ae, 0x4b61, 0xb6, 0x9d, 0x55, 0xb6, 0x1e, 0xe5, 0x4a, 0x7b);

// {a8700a7a-939b-44c5-99d7-76226b23b3f1}   MFT_CATEGORY_DEMULTIPLEXER
DEFINE_GUID(MFT_CATEGORY_DEMULTIPLEXER,
0xa8700a7a, 0x939b, 0x44c5, 0x99, 0xd7, 0x76, 0x22, 0x6b, 0x23, 0xb3, 0xf1);

// {9ea73fb4-ef7a-4559-8d5d-719d8f0426c7}   MFT_CATEGORY_AUDIO_DECODER
DEFINE_GUID(MFT_CATEGORY_AUDIO_DECODER,
0x9ea73fb4, 0xef7a, 0x4559, 0x8d, 0x5d, 0x71, 0x9d, 0x8f, 0x04, 0x26, 0xc7);

// {91c64bd0-f91e-4d8c-9276-db248279d975}   MFT_CATEGORY_AUDIO_ENCODER
DEFINE_GUID(MFT_CATEGORY_AUDIO_ENCODER,
0x91c64bd0, 0xf91e, 0x4d8c, 0x92, 0x76, 0xdb, 0x24, 0x82, 0x79, 0xd9, 0x75);

// {11064c48-3648-4ed0-932e-05ce8ac811b7}   MFT_CATEGORY_AUDIO_EFFECT
DEFINE_GUID(MFT_CATEGORY_AUDIO_EFFECT,
0x11064c48, 0x3648, 0x4ed0, 0x93, 0x2e, 0x05, 0xce, 0x8a, 0xc8, 0x11, 0xb7);

#if (WINVER >= _WIN32_WINNT_WIN7)
// {302EA3FC-AA5F-47f9-9F7A-C2188BB163021}...MFT_CATEGORY_VIDEO_PROCESSOR
DEFINE_GUID(MFT_CATEGORY_VIDEO_PROCESSOR, 
0x302ea3fc, 0xaa5f, 0x47f9, 0x9f, 0x7a, 0xc2, 0x18, 0x8b, 0xb1, 0x63, 0x2);
#endif // (WINVER >= _WIN32_WINNT_WIN7)

// {90175d57-b7ea-4901-aeb3-933a8747756f}   MFT_CATEGORY_OTHER
DEFINE_GUID(MFT_CATEGORY_OTHER,
0x90175d57, 0xb7ea, 0x4901, 0xae, 0xb3, 0x93, 0x3a, 0x87, 0x47, 0x75, 0x6f);

//
// "Flags" is for future expansion - for now must be 0
//
STDAPI
MFTRegister(
    __in                            CLSID                   clsidMFT,
    __in                            GUID                    guidCategory,
    __in                            LPWSTR                  pszName,
    __in                            UINT32                  Flags,
    __in                            UINT32                  cInputTypes,
    __in_ecount_opt(cInputTypes)    MFT_REGISTER_TYPE_INFO* pInputTypes,
    __in                            UINT32                  cOutputTypes,
    __in_ecount_opt(cOutputTypes)   MFT_REGISTER_TYPE_INFO* pOutputTypes,
    __in_opt                        IMFAttributes*          pAttributes
    );

STDAPI
MFTUnregister(
    __in    CLSID   clsidMFT
    );

#if (WINVER >= _WIN32_WINNT_WIN7)
//  Register an MFT class in-process
STDAPI
MFTRegisterLocal(
   __in                        IClassFactory*          pClassFactory,
   __in                        REFGUID                 guidCategory,
   __in                        LPCWSTR                 pszName,
   __in                        UINT32                  Flags,
   __in                        UINT32                  cInputTypes,
   __in_ecount_opt(cInputTypes)const MFT_REGISTER_TYPE_INFO* pInputTypes,
   __in                        UINT32                  cOutputTypes,
   __in_ecount_opt(cOutputTypes)const MFT_REGISTER_TYPE_INFO* pOutputTypes
    );

//  Unregister locally registered MFT
//  If pClassFactory is NULL all local MFTs are unregistered
STDAPI
MFTUnregisterLocal(
    __in_opt    IClassFactory *   pClassFactory
    );

// Register an MFT class in-process, by CLSID
STDAPI
MFTRegisterLocalByCLSID(
   __in                        REFCLSID                clisdMFT,
   __in                        REFGUID                 guidCategory,
   __in                        LPCWSTR                 pszName,
   __in                        UINT32                  Flags,
   __in                        UINT32                  cInputTypes,
   __in_ecount_opt(cInputTypes)const MFT_REGISTER_TYPE_INFO* pInputTypes,
   __in                        UINT32                  cOutputTypes,
   __in_ecount_opt(cOutputTypes)const MFT_REGISTER_TYPE_INFO* pOutputTypes
    );

// Unregister locally registered MFT by CLSID
STDAPI
MFTUnregisterLocalByCLSID(
    __in    CLSID   clsidMFT
    );
#endif // (WINVER >= _WIN32_WINNT_WIN7)

//
// result *ppclsidMFT must be freed with CoTaskMemFree.
//
STDAPI
MFTEnum(
    __in                    GUID                    guidCategory,
    __in                    UINT32                  Flags,
    __in_opt                MFT_REGISTER_TYPE_INFO* pInputType,
    __in_opt                MFT_REGISTER_TYPE_INFO* pOutputType,
    __in_opt                IMFAttributes*          pAttributes,
    __deref_out_ecount(*pcMFTs)   CLSID**           ppclsidMFT, // must be freed with CoTaskMemFree
    __out                   UINT32*                 pcMFTs
    );

#if (WINVER >= _WIN32_WINNT_WIN7)

enum _MFT_ENUM_FLAG
{
    MFT_ENUM_FLAG_SYNCMFT        = 0x00000001,   // Enumerates V1 MFTs. This is default.
    MFT_ENUM_FLAG_ASYNCMFT       = 0x00000002,   // Enumerates only software async MFTs also known as V2 MFTs
    MFT_ENUM_FLAG_HARDWARE       = 0x00000004,   // Enumerates V2 hardware async MFTs
    MFT_ENUM_FLAG_FIELDOFUSE     = 0x00000008,   // Enumerates MFTs that require unlocking
    MFT_ENUM_FLAG_LOCALMFT       = 0x00000010,   // Enumerates Locally (in-process) registered MFTs
    MFT_ENUM_FLAG_TRANSCODE_ONLY = 0x00000020,   // Enumerates decoder MFTs used by transcode only    
    MFT_ENUM_FLAG_SORTANDFILTER  = 0x00000040,   // Apply system local, do not use and preferred sorting and filtering
    MFT_ENUM_FLAG_ALL            = 0x0000003F    // Enumerates all MFTs including SW and HW MFTs and applies filtering
};

//
// result *pppMFTActivate must be freed with CoTaskMemFree. Each IMFActivate pointer inside this
// buffer should be released.
//

STDAPI
MFTEnumEx(
    __in                                GUID                            guidCategory,
    __in                                UINT32                          Flags,
    __in_opt                            const MFT_REGISTER_TYPE_INFO*   pInputType,
    __in_opt                            const MFT_REGISTER_TYPE_INFO*   pOutputType,
    __deref_out_ecount(*pnumMFTActivate) IMFActivate***                 pppMFTActivate,
    __out                               UINT32*                         pnumMFTActivate
);
#endif // (WINVER >= _WIN32_WINNT_WIN7)

//
// results *pszName, *ppInputTypes, and *ppOutputTypes must be freed with CoTaskMemFree.
// *ppAttributes must be released.
//
STDAPI
MFTGetInfo(
    __in                                   CLSID                       clsidMFT,
    __out_opt                              LPWSTR*                     pszName,
    __deref_opt_out_ecount(*pcInputTypes)  MFT_REGISTER_TYPE_INFO**    ppInputTypes,
    __out_opt                              UINT32*                     pcInputTypes,
    __deref_opt_out_ecount(*pcOutputTypes) MFT_REGISTER_TYPE_INFO**    ppOutputTypes,
    __out_opt                              UINT32*                     pcOutputTypes,
    __deref_opt_out_opt                    IMFAttributes**             ppAttributes
    );


#if (WINVER >= _WIN32_WINNT_WIN7)

//
//  Get the plugin control API
//
STDAPI
MFGetPluginControl(
    __out IMFPluginControl **ppPluginControl
    );

//
//  Get MFT's merit - checking that is has a valid certificate
//
STDAPI
MFGetMFTMerit(
    __inout IUnknown *pMFT,
    __in    UINT32   cbVerifier,
    __in_bcount(cbVerifier) const BYTE * verifier,
    __out   DWORD   *merit
    );

#endif // (WINVER >= _WIN32_WINNT_WIN7)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////  MFT  Attributes GUIDs ////////////////////////////
// {53476A11-3F13-49fb-AC42-EE2733C96741} MFT_SUPPORT_DYNAMIC_FORMAT_CHANGE {UINT32 (BOOL)}
DEFINE_GUID(MFT_SUPPORT_DYNAMIC_FORMAT_CHANGE,
0x53476a11, 0x3f13, 0x49fb, 0xac, 0x42, 0xee, 0x27, 0x33, 0xc9, 0x67, 0x41);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////  Media Type GUIDs ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// GUIDs for media types
//

//
// In MF, media types for uncompressed video formats MUST be composed from a FourCC or D3DFORMAT combined with
// the "base GUID" {00000000-0000-0010-8000-00AA00389B71} by replacing the initial 32 bits with the FourCC/D3DFORMAT
//
// Audio media types for types which already have a defined wFormatTag value can be constructed similarly, by
// putting the wFormatTag (zero-extended to 32 bits) into the first 32 bits of the base GUID.
//
// Compressed video or audio can also use any well-known GUID that exists, or can create a new GUID.
//
// GUIDs for common media types are defined below.
//


#ifndef FCC
#define FCC(ch4) ((((DWORD)(ch4) & 0xFF) << 24) |     \
                  (((DWORD)(ch4) & 0xFF00) << 8) |    \
                  (((DWORD)(ch4) & 0xFF0000) >> 8) |  \
                  (((DWORD)(ch4) & 0xFF000000) >> 24))
#endif


//
// this macro creates a media type GUID from a FourCC, D3DFMT, or WAVE_FORMAT
//
#ifndef DEFINE_MEDIATYPE_GUID
#define DEFINE_MEDIATYPE_GUID(name, format) \
    DEFINE_GUID(name,                       \
    format, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
#endif

//
// video media types
//

//
// If no D3D headers have been included yet, define local versions of D3DFMT constants we use.
// We can't include D3D headers from this header because we need it to be compatible with all versions
// of D3D.
//
#ifndef DIRECT3D_VERSION
#define D3DFMT_R8G8B8       20
#define D3DFMT_A8R8G8B8     21
#define D3DFMT_X8R8G8B8     22
#define D3DFMT_R5G6B5       23
#define D3DFMT_X1R5G5B5     24
#define D3DFMT_P8           41
#define LOCAL_D3DFMT_DEFINES 1
#endif

DEFINE_MEDIATYPE_GUID( MFVideoFormat_Base,      0x00000000 );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_RGB32,     D3DFMT_X8R8G8B8 );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_ARGB32,    D3DFMT_A8R8G8B8 );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_RGB24,     D3DFMT_R8G8B8 );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_RGB555,    D3DFMT_X1R5G5B5 );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_RGB565,    D3DFMT_R5G6B5 );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_RGB8,      D3DFMT_P8 );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_AI44,      FCC('AI44') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_AYUV,      FCC('AYUV') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_YUY2,      FCC('YUY2') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_YVYU,      FCC('YVYU') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_YVU9,      FCC('YVU9') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_UYVY,      FCC('UYVY') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_NV11,      FCC('NV11') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_NV12,      FCC('NV12') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_YV12,      FCC('YV12') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_I420,      FCC('I420') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_IYUV,      FCC('IYUV') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_Y210,      FCC('Y210') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_Y216,      FCC('Y216') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_Y410,      FCC('Y410') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_Y416,      FCC('Y416') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_Y41P,      FCC('Y41P') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_Y41T,      FCC('Y41T') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_Y42T,      FCC('Y42T') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_P210,      FCC('P210') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_P216,      FCC('P216') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_P010,      FCC('P010') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_P016,      FCC('P016') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_v210,      FCC('v210') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_v216,      FCC('v216') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_v410,      FCC('v410') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_MP43,      FCC('MP43') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_MP4S,      FCC('MP4S') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_M4S2,      FCC('M4S2') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_MP4V,      FCC('MP4V') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_WMV1,      FCC('WMV1') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_WMV2,      FCC('WMV2') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_WMV3,      FCC('WMV3') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_WVC1,      FCC('WVC1') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_MSS1,      FCC('MSS1') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_MSS2,      FCC('MSS2') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_MPG1,      FCC('MPG1') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_DVSL,      FCC('dvsl') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_DVSD,      FCC('dvsd') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_DVHD,      FCC('dvhd') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_DV25,      FCC('dv25') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_DV50,      FCC('dv50') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_DVH1,      FCC('dvh1') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_DVC,       FCC('dvc ') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_H264,      FCC('H264') );
DEFINE_MEDIATYPE_GUID( MFVideoFormat_MJPG,      FCC('MJPG') );

//
// undef the local D3DFMT definitions to avoid later clashes with D3D headers
//
#ifdef LOCAL_D3DFMT_DEFINES
#undef D3DFMT_R8G8B8
#undef D3DFMT_A8R8G8B8
#undef D3DFMT_X8R8G8B8
#undef D3DFMT_R5G6B5
#undef D3DFMT_X1R5G5B5
#undef D3DFMT_P8
#undef LOCAL_D3DFMT_DEFINES
#endif

//
// some legacy formats that don't fit the common pattern
//

// {e06d8026-db46-11cf-b4d1-00805f6cbbea}       MFVideoFormat_MPEG2
DEFINE_GUID(MFVideoFormat_MPEG2,
0xe06d8026, 0xdb46, 0x11cf, 0xb4, 0xd1, 0x00, 0x80, 0x5f, 0x6c, 0xbb, 0xea);

#define MFVideoFormat_MPG2 MFVideoFormat_MPEG2

//
// audio media types
//
DEFINE_MEDIATYPE_GUID( MFAudioFormat_Base,              0x00000000 );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_PCM,               WAVE_FORMAT_PCM );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_Float,             WAVE_FORMAT_IEEE_FLOAT );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_DTS,               WAVE_FORMAT_DTS );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_Dolby_AC3_SPDIF,   WAVE_FORMAT_DOLBY_AC3_SPDIF );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_DRM,               WAVE_FORMAT_DRM );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_WMAudioV8,         WAVE_FORMAT_WMAUDIO2 );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_WMAudioV9,         WAVE_FORMAT_WMAUDIO3 );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_WMAudio_Lossless,  WAVE_FORMAT_WMAUDIO_LOSSLESS );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_WMASPDIF,          WAVE_FORMAT_WMASPDIF );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_MSP1,              WAVE_FORMAT_WMAVOICE9 );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_MP3,               WAVE_FORMAT_MPEGLAYER3 );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_MPEG,              WAVE_FORMAT_MPEG );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_AAC,               WAVE_FORMAT_MPEG_HEAAC );
DEFINE_MEDIATYPE_GUID( MFAudioFormat_ADTS,              WAVE_FORMAT_MPEG_ADTS_AAC );

//
// MPEG-4 media types
//

// {00000000-767a-494d-b478-f29d25dc9037}       MFMPEG4Format_Base
DEFINE_GUID(MFMPEG4Format_Base,
0x00000000, 0x767a, 0x494d, 0xb4, 0x78, 0xf2, 0x9d, 0x25, 0xdc, 0x90, 0x37);

///////////////////////////////////////////////////////////////////////////////////////////////////////////////  Media Type Attributes GUIDs ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// GUIDs for IMFMediaType properties - prefix 'MF_MT_' - basic prop type in {},
// with type to cast to in ().
//


//
// core info for all types
//
// {48eba18e-f8c9-4687-bf11-0a74c9f96a8f}   MF_MT_MAJOR_TYPE                {GUID}
DEFINE_GUID(MF_MT_MAJOR_TYPE,
0x48eba18e, 0xf8c9, 0x4687, 0xbf, 0x11, 0x0a, 0x74, 0xc9, 0xf9, 0x6a, 0x8f);

// {f7e34c9a-42e8-4714-b74b-cb29d72c35e5}   MF_MT_SUBTYPE                   {GUID}
DEFINE_GUID(MF_MT_SUBTYPE,
0xf7e34c9a, 0x42e8, 0x4714, 0xb7, 0x4b, 0xcb, 0x29, 0xd7, 0x2c, 0x35, 0xe5);

// {c9173739-5e56-461c-b713-46fb995cb95f}   MF_MT_ALL_SAMPLES_INDEPENDENT   {UINT32 (BOOL)}
DEFINE_GUID(MF_MT_ALL_SAMPLES_INDEPENDENT,
0xc9173739, 0x5e56, 0x461c, 0xb7, 0x13, 0x46, 0xfb, 0x99, 0x5c, 0xb9, 0x5f);

// {b8ebefaf-b718-4e04-b0a9-116775e3321b}   MF_MT_FIXED_SIZE_SAMPLES        {UINT32 (BOOL)}
DEFINE_GUID(MF_MT_FIXED_SIZE_SAMPLES,
0xb8ebefaf, 0xb718, 0x4e04, 0xb0, 0xa9, 0x11, 0x67, 0x75, 0xe3, 0x32, 0x1b);

// {3afd0cee-18f2-4ba5-a110-8bea502e1f92}   MF_MT_COMPRESSED                {UINT32 (BOOL)}
DEFINE_GUID(MF_MT_COMPRESSED,
0x3afd0cee, 0x18f2, 0x4ba5, 0xa1, 0x10, 0x8b, 0xea, 0x50, 0x2e, 0x1f, 0x92);

//
// MF_MT_SAMPLE_SIZE is only valid if MF_MT_FIXED_SIZED_SAMPLES is TRUE
//
// {dad3ab78-1990-408b-bce2-eba673dacc10}   MF_MT_SAMPLE_SIZE               {UINT32}
DEFINE_GUID(MF_MT_SAMPLE_SIZE,
0xdad3ab78, 0x1990, 0x408b, 0xbc, 0xe2, 0xeb, 0xa6, 0x73, 0xda, 0xcc, 0x10);

// 4d3f7b23-d02f-4e6c-9bee-e4bf2c6c695d     MF_MT_WRAPPED_TYPE              {Blob}
DEFINE_GUID(MF_MT_WRAPPED_TYPE,
0x4d3f7b23, 0xd02f, 0x4e6c, 0x9b, 0xee, 0xe4, 0xbf, 0x2c, 0x6c, 0x69, 0x5d);

//
// AUDIO data
//

// {37e48bf5-645e-4c5b-89de-ada9e29b696a}   MF_MT_AUDIO_NUM_CHANNELS            {UINT32}
DEFINE_GUID(MF_MT_AUDIO_NUM_CHANNELS,
0x37e48bf5, 0x645e, 0x4c5b, 0x89, 0xde, 0xad, 0xa9, 0xe2, 0x9b, 0x69, 0x6a);

// {5faeeae7-0290-4c31-9e8a-c534f68d9dba}   MF_MT_AUDIO_SAMPLES_PER_SECOND      {UINT32}
DEFINE_GUID(MF_MT_AUDIO_SAMPLES_PER_SECOND,
0x5faeeae7, 0x0290, 0x4c31, 0x9e, 0x8a, 0xc5, 0x34, 0xf6, 0x8d, 0x9d, 0xba);

// {fb3b724a-cfb5-4319-aefe-6e42b2406132}   MF_MT_AUDIO_FLOAT_SAMPLES_PER_SECOND {double}
DEFINE_GUID(MF_MT_AUDIO_FLOAT_SAMPLES_PER_SECOND,
0xfb3b724a, 0xcfb5, 0x4319, 0xae, 0xfe, 0x6e, 0x42, 0xb2, 0x40, 0x61, 0x32);

// {1aab75c8-cfef-451c-ab95-ac034b8e1731}   MF_MT_AUDIO_AVG_BYTES_PER_SECOND    {UINT32}
DEFINE_GUID(MF_MT_AUDIO_AVG_BYTES_PER_SECOND,
0x1aab75c8, 0xcfef, 0x451c, 0xab, 0x95, 0xac, 0x03, 0x4b, 0x8e, 0x17, 0x31);

// {322de230-9eeb-43bd-ab7a-ff412251541d}   MF_MT_AUDIO_BLOCK_ALIGNMENT         {UINT32}
DEFINE_GUID(MF_MT_AUDIO_BLOCK_ALIGNMENT,
0x322de230, 0x9eeb, 0x43bd, 0xab, 0x7a, 0xff, 0x41, 0x22, 0x51, 0x54, 0x1d);

// {f2deb57f-40fa-4764-aa33-ed4f2d1ff669}   MF_MT_AUDIO_BITS_PER_SAMPLE         {UINT32}
DEFINE_GUID(MF_MT_AUDIO_BITS_PER_SAMPLE,
0xf2deb57f, 0x40fa, 0x4764, 0xaa, 0x33, 0xed, 0x4f, 0x2d, 0x1f, 0xf6, 0x69);

// {d9bf8d6a-9530-4b7c-9ddf-ff6fd58bbd06}   MF_MT_AUDIO_VALID_BITS_PER_SAMPLE   {UINT32}
DEFINE_GUID(MF_MT_AUDIO_VALID_BITS_PER_SAMPLE,
0xd9bf8d6a, 0x9530, 0x4b7c, 0x9d, 0xdf, 0xff, 0x6f, 0xd5, 0x8b, 0xbd, 0x06);

// {aab15aac-e13a-4995-9222-501ea15c6877}   MF_MT_AUDIO_SAMPLES_PER_BLOCK       {UINT32}
DEFINE_GUID(MF_MT_AUDIO_SAMPLES_PER_BLOCK,
0xaab15aac, 0xe13a, 0x4995, 0x92, 0x22, 0x50, 0x1e, 0xa1, 0x5c, 0x68, 0x77);

// {55fb5765-644a-4caf-8479-938983bb1588}`  MF_MT_AUDIO_CHANNEL_MASK            {UINT32}
DEFINE_GUID(MF_MT_AUDIO_CHANNEL_MASK,
0x55fb5765, 0x644a, 0x4caf, 0x84, 0x79, 0x93, 0x89, 0x83, 0xbb, 0x15, 0x88);

//
// MF_MT_AUDIO_FOLDDOWN_MATRIX stores folddown structure from multichannel to stereo
//
typedef struct _MFFOLDDOWN_MATRIX
{
    UINT32 cbSize;
    UINT32 cSrcChannels; // number of source channels
    UINT32 cDstChannels; // number of destination channels
    UINT32 dwChannelMask; // mask
    LONG Coeff[64];
} MFFOLDDOWN_MATRIX;

// {9d62927c-36be-4cf2-b5c4-a3926e3e8711}`  MF_MT_AUDIO_FOLDDOWN_MATRIX         {BLOB, MFFOLDDOWN_MATRIX}
DEFINE_GUID(MF_MT_AUDIO_FOLDDOWN_MATRIX,
0x9d62927c, 0x36be, 0x4cf2, 0xb5, 0xc4, 0xa3, 0x92, 0x6e, 0x3e, 0x87, 0x11);

// {0x9d62927d-36be-4cf2-b5c4-a3926e3e8711}`  MF_MT_AUDIO_WMADRC_PEAKREF         {UINT32}
DEFINE_GUID(MF_MT_AUDIO_WMADRC_PEAKREF,
0x9d62927d, 0x36be, 0x4cf2, 0xb5, 0xc4, 0xa3, 0x92, 0x6e, 0x3e, 0x87, 0x11);

// {0x9d62927e-36be-4cf2-b5c4-a3926e3e8711}`  MF_MT_AUDIO_WMADRC_PEAKTARGET        {UINT32}
DEFINE_GUID(MF_MT_AUDIO_WMADRC_PEAKTARGET,
0x9d62927e, 0x36be, 0x4cf2, 0xb5, 0xc4, 0xa3, 0x92, 0x6e, 0x3e, 0x87, 0x11);


// {0x9d62927f-36be-4cf2-b5c4-a3926e3e8711}`  MF_MT_AUDIO_WMADRC_AVGREF         {UINT32}
DEFINE_GUID(MF_MT_AUDIO_WMADRC_AVGREF,
0x9d62927f, 0x36be, 0x4cf2, 0xb5, 0xc4, 0xa3, 0x92, 0x6e, 0x3e, 0x87, 0x11);

// {0x9d629280-36be-4cf2-b5c4-a3926e3e8711}`  MF_MT_AUDIO_WMADRC_AVGTARGET      {UINT32}
DEFINE_GUID(MF_MT_AUDIO_WMADRC_AVGTARGET,
0x9d629280, 0x36be, 0x4cf2, 0xb5, 0xc4, 0xa3, 0x92, 0x6e, 0x3e, 0x87, 0x11);

//
// MF_MT_AUDIO_PREFER_WAVEFORMATEX tells the converter to prefer a plain WAVEFORMATEX rather than
// a WAVEFORMATEXTENSIBLE when converting to a legacy type. It is set by the WAVEFORMATEX->IMFMediaType
// conversion routines when the original format block is a non-extensible WAVEFORMATEX.
//
// This preference can be overridden and does not guarantee that the type can be correctly expressed
// by a non-extensible type.
//
// {a901aaba-e037-458a-bdf6-545be2074042}   MF_MT_AUDIO_PREFER_WAVEFORMATEX     {UINT32 (BOOL)}
DEFINE_GUID(MF_MT_AUDIO_PREFER_WAVEFORMATEX,
0xa901aaba, 0xe037, 0x458a, 0xbd, 0xf6, 0x54, 0x5b, 0xe2, 0x07, 0x40, 0x42);

#if (WINVER >= _WIN32_WINNT_WIN7)
//
// AUDIO - AAC extra data
//

// {BFBABE79-7434-4d1c-94F0-72A3B9E17188} MF_MT_AAC_PAYLOAD_TYPE       {UINT32}
DEFINE_GUID(MF_MT_AAC_PAYLOAD_TYPE,
0xbfbabe79, 0x7434, 0x4d1c, 0x94, 0xf0, 0x72, 0xa3, 0xb9, 0xe1, 0x71, 0x88);

// {7632F0E6-9538-4d61-ACDA-EA29C8C14456} MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION       {UINT32}
DEFINE_GUID(MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION,
0x7632f0e6, 0x9538, 0x4d61, 0xac, 0xda, 0xea, 0x29, 0xc8, 0xc1, 0x44, 0x56);

#endif // (WINVER >= _WIN32_WINNT_WIN7)

//
// VIDEO core data
//

// {1652c33d-d6b2-4012-b834-72030849a37d}   MF_MT_FRAME_SIZE                {UINT64 (HI32(Width),LO32(Height))}
DEFINE_GUID(MF_MT_FRAME_SIZE,
0x1652c33d, 0xd6b2, 0x4012, 0xb8, 0x34, 0x72, 0x03, 0x08, 0x49, 0xa3, 0x7d);

// {c459a2e8-3d2c-4e44-b132-fee5156c7bb0}   MF_MT_FRAME_RATE                {UINT64 (HI32(Numerator),LO32(Denominator))}
DEFINE_GUID(MF_MT_FRAME_RATE,
0xc459a2e8, 0x3d2c, 0x4e44, 0xb1, 0x32, 0xfe, 0xe5, 0x15, 0x6c, 0x7b, 0xb0);

// {c6376a1e-8d0a-4027-be45-6d9a0ad39bb6}   MF_MT_PIXEL_ASPECT_RATIO        {UINT64 (HI32(Numerator),LO32(Denominator))}
DEFINE_GUID(MF_MT_PIXEL_ASPECT_RATIO,
0xc6376a1e, 0x8d0a, 0x4027, 0xbe, 0x45, 0x6d, 0x9a, 0x0a, 0xd3, 0x9b, 0xb6);

// {8772f323-355a-4cc7-bb78-6d61a048ae82}   MF_MT_DRM_FLAGS                 {UINT32 (anyof MFVideoDRMFlags)}
DEFINE_GUID(MF_MT_DRM_FLAGS,
0x8772f323, 0x355a, 0x4cc7, 0xbb, 0x78, 0x6d, 0x61, 0xa0, 0x48, 0xae, 0x82);

typedef enum _MFVideoDRMFlags {
    MFVideoDRMFlag_None                 = 0,
    MFVideoDRMFlag_AnalogProtected      = 1,
    MFVideoDRMFlag_DigitallyProtected   = 2,
} MFVideoDRMFlags;


// {4d0e73e5-80ea-4354-a9d0-1176ceb028ea}   MF_MT_PAD_CONTROL_FLAGS         {UINT32 (oneof MFVideoPadFlags)}
DEFINE_GUID(MF_MT_PAD_CONTROL_FLAGS,
0x4d0e73e5, 0x80ea, 0x4354, 0xa9, 0xd0, 0x11, 0x76, 0xce, 0xb0, 0x28, 0xea);

typedef enum _MFVideoPadFlags {
    MFVideoPadFlag_PAD_TO_None  = 0,
    MFVideoPadFlag_PAD_TO_4x3   = 1,
    MFVideoPadFlag_PAD_TO_16x9  = 2
} MFVideoPadFlags;

// {68aca3cc-22d0-44e6-85f8-28167197fa38}   MF_MT_SOURCE_CONTENT_HINT       {UINT32 (oneof MFVideoSrcContentHintFlags)}
DEFINE_GUID(MF_MT_SOURCE_CONTENT_HINT,
0x68aca3cc, 0x22d0, 0x44e6, 0x85, 0xf8, 0x28, 0x16, 0x71, 0x97, 0xfa, 0x38);

typedef enum _MFVideoSrcContentHintFlags {
    MFVideoSrcContentHintFlag_None  = 0,
    MFVideoSrcContentHintFlag_16x9  = 1,
    MFVideoSrcContentHintFlag_235_1 = 2
} MFVideoSrcContentHintFlags;

// {65df2370-c773-4c33-aa64-843e068efb0c}   MF_MT_CHROMA_SITING             {UINT32 (anyof MFVideoChromaSubsampling)}
DEFINE_GUID(MF_MT_VIDEO_CHROMA_SITING,
0x65df2370, 0xc773, 0x4c33, 0xaa, 0x64, 0x84, 0x3e, 0x06, 0x8e, 0xfb, 0x0c);

// {e2724bb8-e676-4806-b4b2-a8d6efb44ccd}   MF_MT_INTERLACE_MODE            {UINT32 (oneof MFVideoInterlaceMode)}
DEFINE_GUID(MF_MT_INTERLACE_MODE,
0xe2724bb8, 0xe676, 0x4806, 0xb4, 0xb2, 0xa8, 0xd6, 0xef, 0xb4, 0x4c, 0xcd);

// {5fb0fce9-be5c-4935-a811-ec838f8eed93}   MF_MT_TRANSFER_FUNCTION         {UINT32 (oneof MFVideoTransferFunction)}
DEFINE_GUID(MF_MT_TRANSFER_FUNCTION,
0x5fb0fce9, 0xbe5c, 0x4935, 0xa8, 0x11, 0xec, 0x83, 0x8f, 0x8e, 0xed, 0x93);

// {dbfbe4d7-0740-4ee0-8192-850ab0e21935}   MF_MT_VIDEO_PRIMARIES           {UINT32 (oneof MFVideoPrimaries)}
DEFINE_GUID(MF_MT_VIDEO_PRIMARIES,
0xdbfbe4d7, 0x0740, 0x4ee0, 0x81, 0x92, 0x85, 0x0a, 0xb0, 0xe2, 0x19, 0x35);

// {47537213-8cfb-4722-aa34-fbc9e24d77b8}   MF_MT_CUSTOM_VIDEO_PRIMARIES    {BLOB (MT_CUSTOM_VIDEO_PRIMARIES)}
DEFINE_GUID(MF_MT_CUSTOM_VIDEO_PRIMARIES,
0x47537213, 0x8cfb, 0x4722, 0xaa, 0x34, 0xfb, 0xc9, 0xe2, 0x4d, 0x77, 0xb8);

typedef struct _MT_CUSTOM_VIDEO_PRIMARIES {
    float fRx;
    float fRy;
    float fGx;
    float fGy;
    float fBx;
    float fBy;
    float fWx;
    float fWy;
} MT_CUSTOM_VIDEO_PRIMARIES;

// {3e23d450-2c75-4d25-a00e-b91670d12327}   MF_MT_YUV_MATRIX                {UINT32 (oneof MFVideoTransferMatrix)}
DEFINE_GUID(MF_MT_YUV_MATRIX,
0x3e23d450, 0x2c75, 0x4d25, 0xa0, 0x0e, 0xb9, 0x16, 0x70, 0xd1, 0x23, 0x27);

// {53a0529c-890b-4216-8bf9-599367ad6d20}   MF_MT_VIDEO_LIGHTING            {UINT32 (oneof MFVideoLighting)}
DEFINE_GUID(MF_MT_VIDEO_LIGHTING,
0x53a0529c, 0x890b, 0x4216, 0x8b, 0xf9, 0x59, 0x93, 0x67, 0xad, 0x6d, 0x20);

// {c21b8ee5-b956-4071-8daf-325edf5cab11}   MF_MT_VIDEO_NOMINAL_RANGE       {UINT32 (oneof MFNominalRange)}
DEFINE_GUID(MF_MT_VIDEO_NOMINAL_RANGE,
0xc21b8ee5, 0xb956, 0x4071, 0x8d, 0xaf, 0x32, 0x5e, 0xdf, 0x5c, 0xab, 0x11);

// {66758743-7e5f-400d-980a-aa8596c85696}   MF_MT_GEOMETRIC_APERTURE        {BLOB (MFVideoArea)}
DEFINE_GUID(MF_MT_GEOMETRIC_APERTURE,
0x66758743, 0x7e5f, 0x400d, 0x98, 0x0a, 0xaa, 0x85, 0x96, 0xc8, 0x56, 0x96);

// {d7388766-18fe-48c6-a177-ee894867c8c4}   MF_MT_MINIMUM_DISPLAY_APERTURE  {BLOB (MFVideoArea)}
DEFINE_GUID(MF_MT_MINIMUM_DISPLAY_APERTURE,
0xd7388766, 0x18fe, 0x48c6, 0xa1, 0x77, 0xee, 0x89, 0x48, 0x67, 0xc8, 0xc4);

// {79614dde-9187-48fb-b8c7-4d52689de649}   MF_MT_PAN_SCAN_APERTURE         {BLOB (MFVideoArea)}
DEFINE_GUID(MF_MT_PAN_SCAN_APERTURE,
0x79614dde, 0x9187, 0x48fb, 0xb8, 0xc7, 0x4d, 0x52, 0x68, 0x9d, 0xe6, 0x49);

// {4b7f6bc3-8b13-40b2-a993-abf630b8204e}   MF_MT_PAN_SCAN_ENABLED          {UINT32 (BOOL)}
DEFINE_GUID(MF_MT_PAN_SCAN_ENABLED,
0x4b7f6bc3, 0x8b13, 0x40b2, 0xa9, 0x93, 0xab, 0xf6, 0x30, 0xb8, 0x20, 0x4e);

// {20332624-fb0d-4d9e-bd0d-cbf6786c102e}   MF_MT_AVG_BITRATE               {UINT32}
DEFINE_GUID(MF_MT_AVG_BITRATE,
0x20332624, 0xfb0d, 0x4d9e, 0xbd, 0x0d, 0xcb, 0xf6, 0x78, 0x6c, 0x10, 0x2e);

// {799cabd6-3508-4db4-a3c7-569cd533deb1}   MF_MT_AVG_BIT_ERROR_RATE        {UINT32}
DEFINE_GUID(MF_MT_AVG_BIT_ERROR_RATE,
0x799cabd6, 0x3508, 0x4db4, 0xa3, 0xc7, 0x56, 0x9c, 0xd5, 0x33, 0xde, 0xb1);

// {c16eb52b-73a1-476f-8d62-839d6a020652}   MF_MT_MAX_KEYFRAME_SPACING      {UINT32}
DEFINE_GUID(MF_MT_MAX_KEYFRAME_SPACING,
0xc16eb52b, 0x73a1, 0x476f, 0x8d, 0x62, 0x83, 0x9d, 0x6a, 0x02, 0x06, 0x52);

//
// VIDEO - uncompressed format data
//

// {644b4e48-1e02-4516-b0eb-c01ca9d49ac6}   MF_MT_DEFAULT_STRIDE            {UINT32 (INT32)} // in bytes
DEFINE_GUID(MF_MT_DEFAULT_STRIDE,
0x644b4e48, 0x1e02, 0x4516, 0xb0, 0xeb, 0xc0, 0x1c, 0xa9, 0xd4, 0x9a, 0xc6);

// {6d283f42-9846-4410-afd9-654d503b1a54}   MF_MT_PALETTE                   {BLOB (array of MFPaletteEntry - usually 256)}
DEFINE_GUID(MF_MT_PALETTE,
0x6d283f42, 0x9846, 0x4410, 0xaf, 0xd9, 0x65, 0x4d, 0x50, 0x3b, 0x1a, 0x54);

//
// the following is only used for legacy data that was stuck at the end of the format block when the type
// was converted from a VIDEOINFOHEADER or VIDEOINFOHEADER2 block in an AM_MEDIA_TYPE.
//
// {b6bc765f-4c3b-40a4-bd51-2535b66fe09d}   MF_MT_USER_DATA                 {BLOB}
DEFINE_GUID(MF_MT_USER_DATA,
0xb6bc765f, 0x4c3b, 0x40a4, 0xbd, 0x51, 0x25, 0x35, 0xb6, 0x6f, 0xe0, 0x9d);

// {73d1072d-1870-4174-a063-29ff4ff6c11e}
DEFINE_GUID(MF_MT_AM_FORMAT_TYPE,
0x73d1072d, 0x1870, 0x4174, 0xa0, 0x63, 0x29, 0xff, 0x4f, 0xf6, 0xc1, 0x1e);

//
// VIDEO - MPEG1/2 extra data
//

// {91f67885-4333-4280-97cd-bd5a6c03a06e}   MF_MT_MPEG_START_TIME_CODE      {UINT32}
DEFINE_GUID(MF_MT_MPEG_START_TIME_CODE,
0x91f67885, 0x4333, 0x4280, 0x97, 0xcd, 0xbd, 0x5a, 0x6c, 0x03, 0xa0, 0x6e);

// {ad76a80b-2d5c-4e0b-b375-64e520137036}   MF_MT_MPEG2_PROFILE             {UINT32 (oneof AM_MPEG2Profile)}
DEFINE_GUID(MF_MT_MPEG2_PROFILE,
0xad76a80b, 0x2d5c, 0x4e0b, 0xb3, 0x75, 0x64, 0xe5, 0x20, 0x13, 0x70, 0x36);

// {96f66574-11c5-4015-8666-bff516436da7}   MF_MT_MPEG2_LEVEL               {UINT32 (oneof AM_MPEG2Level)}
DEFINE_GUID(MF_MT_MPEG2_LEVEL,
0x96f66574, 0x11c5, 0x4015, 0x86, 0x66, 0xbf, 0xf5, 0x16, 0x43, 0x6d, 0xa7);

// {31e3991d-f701-4b2f-b426-8ae3bda9e04b}   MF_MT_MPEG2_FLAGS               {UINT32 (anyof AMMPEG2_xxx flags)}
DEFINE_GUID(MF_MT_MPEG2_FLAGS,
0x31e3991d, 0xf701, 0x4b2f, 0xb4, 0x26, 0x8a, 0xe3, 0xbd, 0xa9, 0xe0, 0x4b);

// {3c036de7-3ad0-4c9e-9216-ee6d6ac21cb3}   MF_MT_MPEG_SEQUENCE_HEADER      {BLOB}
DEFINE_GUID(MF_MT_MPEG_SEQUENCE_HEADER,
0x3c036de7, 0x3ad0, 0x4c9e, 0x92, 0x16, 0xee, 0x6d, 0x6a, 0xc2, 0x1c, 0xb3);

//
// INTERLEAVED - DV extra data
//
// {84bd5d88-0fb8-4ac8-be4b-a8848bef98f3}   MF_MT_DV_AAUX_SRC_PACK_0        {UINT32}
DEFINE_GUID(MF_MT_DV_AAUX_SRC_PACK_0,
0x84bd5d88, 0x0fb8, 0x4ac8, 0xbe, 0x4b, 0xa8, 0x84, 0x8b, 0xef, 0x98, 0xf3);

// {f731004e-1dd1-4515-aabe-f0c06aa536ac}   MF_MT_DV_AAUX_CTRL_PACK_0       {UINT32}
DEFINE_GUID(MF_MT_DV_AAUX_CTRL_PACK_0,
0xf731004e, 0x1dd1, 0x4515, 0xaa, 0xbe, 0xf0, 0xc0, 0x6a, 0xa5, 0x36, 0xac);

// {720e6544-0225-4003-a651-0196563a958e}   MF_MT_DV_AAUX_SRC_PACK_1        {UINT32}
DEFINE_GUID(MF_MT_DV_AAUX_SRC_PACK_1,
0x720e6544, 0x0225, 0x4003, 0xa6, 0x51, 0x01, 0x96, 0x56, 0x3a, 0x95, 0x8e);

// {cd1f470d-1f04-4fe0-bfb9-d07ae0386ad8}   MF_MT_DV_AAUX_CTRL_PACK_1       {UINT32}
DEFINE_GUID(MF_MT_DV_AAUX_CTRL_PACK_1,
0xcd1f470d, 0x1f04, 0x4fe0, 0xbf, 0xb9, 0xd0, 0x7a, 0xe0, 0x38, 0x6a, 0xd8);

// {41402d9d-7b57-43c6-b129-2cb997f15009}   MF_MT_DV_VAUX_SRC_PACK          {UINT32}
DEFINE_GUID(MF_MT_DV_VAUX_SRC_PACK,
0x41402d9d, 0x7b57, 0x43c6, 0xb1, 0x29, 0x2c, 0xb9, 0x97, 0xf1, 0x50, 0x09);

// {2f84e1c4-0da1-4788-938e-0dfbfbb34b48}   MF_MT_DV_VAUX_CTRL_PACK         {UINT32}
DEFINE_GUID(MF_MT_DV_VAUX_CTRL_PACK,
0x2f84e1c4, 0x0da1, 0x4788, 0x93, 0x8e, 0x0d, 0xfb, 0xfb, 0xb3, 0x4b, 0x48);


#if (WINVER >= _WIN32_WINNT_WIN7)
//
// ARBITRARY
//

//
// MT_ARBITRARY_HEADER stores information about the format of an arbitrary media type
//
typedef struct _MT_ARBITRARY_HEADER
{
    GUID majortype;
    GUID subtype;
    BOOL bFixedSizeSamples;
    BOOL bTemporalCompression;
    ULONG lSampleSize;
    GUID formattype;
}
MT_ARBITRARY_HEADER;

// {9E6BD6F5-0109-4f95-84AC-9309153A19FC}   MF_MT_ARBITRARY_HEADER          {MT_ARBITRARY_HEADER}
DEFINE_GUID(MF_MT_ARBITRARY_HEADER,
0x9e6bd6f5, 0x109, 0x4f95, 0x84, 0xac, 0x93, 0x9, 0x15, 0x3a, 0x19, 0xfc );

// {5A75B249-0D7D-49a1-A1C3-E0D87F0CADE5}   MF_MT_ARBITRARY_FORMAT          {Blob}
DEFINE_GUID(MF_MT_ARBITRARY_FORMAT,
0x5a75b249, 0xd7d, 0x49a1, 0xa1, 0xc3, 0xe0, 0xd8, 0x7f, 0xc, 0xad, 0xe5);


//
// IMAGE
//
// {ED062CF4-E34E-4922-BE99-934032133D7C}   MF_MT_IMAGE_LOSS_TOLERANT       {UINT32 (BOOL)}
DEFINE_GUID(MF_MT_IMAGE_LOSS_TOLERANT, 
0xed062cf4, 0xe34e, 0x4922, 0xbe, 0x99, 0x93, 0x40, 0x32, 0x13, 0x3d, 0x7c);


//
// MPEG-4 Media Type Attributes
//
// {261E9D83-9529-4B8F-A111-8B9C950A81A9}   MF_MT_MPEG4_SAMPLE_DESCRIPTION   {BLOB}
DEFINE_GUID(MF_MT_MPEG4_SAMPLE_DESCRIPTION,
0x261e9d83, 0x9529, 0x4b8f, 0xa1, 0x11, 0x8b, 0x9c, 0x95, 0x0a, 0x81, 0xa9);

// {9aa7e155-b64a-4c1d-a500-455d600b6560}   MF_MT_MPEG4_CURRENT_SAMPLE_ENTRY {UINT32}
DEFINE_GUID(MF_MT_MPEG4_CURRENT_SAMPLE_ENTRY,
0x9aa7e155, 0xb64a, 0x4c1d, 0xa5, 0x00, 0x45, 0x5d, 0x60, 0x0b, 0x65, 0x60);

//
// Save original format information for AVI and WAV files
//
// {d7be3fe0-2bc7-492d-b843-61a1919b70c3}   MF_MT_ORIGINAL_4CC               (UINT32)
DEFINE_GUID(MF_MT_ORIGINAL_4CC, 
0xd7be3fe0, 0x2bc7, 0x492d, 0xb8, 0x43, 0x61, 0xa1, 0x91, 0x9b, 0x70, 0xc3);

// {8cbbc843-9fd9-49c2-882f-a72586c408ad}   MF_MT_ORIGINAL_WAVE_FORMAT_TAG   (UINT32)
DEFINE_GUID(MF_MT_ORIGINAL_WAVE_FORMAT_TAG,
0x8cbbc843, 0x9fd9, 0x49c2, 0x88, 0x2f, 0xa7, 0x25, 0x86, 0xc4, 0x08, 0xad);


//
// Video Capture Media Type Attributes
//

// {D2E7558C-DC1F-403f-9A72-D28BB1EB3B5E}   MF_MT_FRAME_RATE_RANGE_MIN      {UINT64 (HI32(Numerator),LO32(Denominator))}
DEFINE_GUID(MF_MT_FRAME_RATE_RANGE_MIN, 
0xd2e7558c, 0xdc1f, 0x403f, 0x9a, 0x72, 0xd2, 0x8b, 0xb1, 0xeb, 0x3b, 0x5e);

// {E3371D41-B4CF-4a05-BD4E-20B88BB2C4D6}   MF_MT_FRAME_RATE_RANGE_MAX      {UINT64 (HI32(Numerator),LO32(Denominator))}
DEFINE_GUID(MF_MT_FRAME_RATE_RANGE_MAX, 
0xe3371d41, 0xb4cf, 0x4a05, 0xbd, 0x4e, 0x20, 0xb8, 0x8b, 0xb2, 0xc4, 0xd6);


#endif // (WINVER >= _WIN32_WINNT_WIN7)

////////////////////////////////////////////////////////////////////////////////
///////////////////////////////  Media Type GUIDs //////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// Major types
//
DEFINE_GUID(MFMediaType_Default,
0x81A412E6, 0x8103, 0x4B06, 0x85, 0x7F, 0x18, 0x62, 0x78, 0x10, 0x24, 0xAC);
DEFINE_GUID(MFMediaType_Audio,
0x73647561, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71);
DEFINE_GUID(MFMediaType_Video,
0x73646976, 0x0000, 0x0010, 0x80, 0x00, 0x00, 0xAA, 0x00, 0x38, 0x9B, 0x71);
DEFINE_GUID(MFMediaType_Protected,
0x7b4b6fe6, 0x9d04, 0x4494, 0xbe, 0x14, 0x7e, 0x0b, 0xd0, 0x76, 0xc8, 0xe4);
DEFINE_GUID(MFMediaType_SAMI,
0xe69669a0, 0x3dcd, 0x40cb, 0x9e, 0x2e, 0x37, 0x08, 0x38, 0x7c, 0x06, 0x16);
DEFINE_GUID(MFMediaType_Script,
0x72178C22, 0xE45B, 0x11D5, 0xBC, 0x2A, 0x00, 0xB0, 0xD0, 0xF3, 0xF4, 0xAB);
DEFINE_GUID(MFMediaType_Image,
0x72178C23, 0xE45B, 0x11D5, 0xBC, 0x2A, 0x00, 0xB0, 0xD0, 0xF3, 0xF4, 0xAB);
DEFINE_GUID(MFMediaType_HTML,
0x72178C24, 0xE45B, 0x11D5, 0xBC, 0x2A, 0x00, 0xB0, 0xD0, 0xF3, 0xF4, 0xAB);
DEFINE_GUID(MFMediaType_Binary,
0x72178C25, 0xE45B, 0x11D5, 0xBC, 0x2A, 0x00, 0xB0, 0xD0, 0xF3, 0xF4, 0xAB);
DEFINE_GUID(MFMediaType_FileTransfer,
0x72178C26, 0xE45B, 0x11D5, 0xBC, 0x2A, 0x00, 0xB0, 0xD0, 0xF3, 0xF4, 0xAB);

//
// Representations
//
DEFINE_GUID(AM_MEDIA_TYPE_REPRESENTATION,
0xe2e42ad2, 0x132c, 0x491e, 0xa2, 0x68, 0x3c, 0x7c, 0x2d, 0xca, 0x18, 0x1f);
DEFINE_GUID(FORMAT_MFVideoFormat,
0xaed4ab2d, 0x7326, 0x43cb, 0x94, 0x64, 0xc8, 0x79, 0xca, 0xb9, 0xc4, 0x3d);


///////////////////////////////////////////////////////////////////////////////////////////////////////////////  Media Type functions //////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// Forward declaration
//
struct tagVIDEOINFOHEADER;
typedef struct tagVIDEOINFOHEADER VIDEOINFOHEADER;
struct tagVIDEOINFOHEADER2;
typedef struct tagVIDEOINFOHEADER2 VIDEOINFOHEADER2;
struct tagMPEG1VIDEOINFO;
typedef struct tagMPEG1VIDEOINFO MPEG1VIDEOINFO;
struct tagMPEG2VIDEOINFO;
typedef struct tagMPEG2VIDEOINFO MPEG2VIDEOINFO;
struct _AMMediaType;
typedef struct _AMMediaType AM_MEDIA_TYPE;

STDAPI
MFValidateMediaTypeSize(
    __in                    GUID    FormatType,
    __in_bcount_opt(cbSize) UINT8*  pBlock,
    __in                    UINT32  cbSize
    );

STDAPI
MFCreateMediaType(
    __deref_out IMFMediaType**  ppMFType
    );

STDAPI
MFCreateMFVideoFormatFromMFMediaType(
    __in        IMFMediaType*           pMFType,
    __out       MFVIDEOFORMAT**         ppMFVF, // must be deleted with CoTaskMemFree
    __out_opt   UINT32*                 pcbSize
    );

typedef enum _MFWaveFormatExConvertFlags {
    MFWaveFormatExConvertFlag_Normal            = 0,
    MFWaveFormatExConvertFlag_ForceExtensible   = 1
} MFWaveFormatExConvertFlags;

#ifdef __cplusplus

//
// declarations with default parameters
//

STDAPI
MFCreateWaveFormatExFromMFMediaType(
    __in        IMFMediaType*   pMFType,
    __out       WAVEFORMATEX**  ppWF,
    __out_opt   UINT32*         pcbSize,
    __in        UINT32          Flags = MFWaveFormatExConvertFlag_Normal
    );

STDAPI
MFInitMediaTypeFromVideoInfoHeader(
    __in                    IMFMediaType*           pMFType,
    __in_bcount(cbBufSize)  const VIDEOINFOHEADER*  pVIH,
    __in                    UINT32                  cbBufSize,
    __in_opt                const GUID*             pSubtype = NULL
    );

STDAPI
MFInitMediaTypeFromVideoInfoHeader2(
    __in                    IMFMediaType*           pMFType,
    __in_bcount(cbBufSize)  const VIDEOINFOHEADER2* pVIH2,
    __in                    UINT32                  cbBufSize,
    __in_opt                const GUID*             pSubtype = NULL
    );

STDAPI
MFInitMediaTypeFromMPEG1VideoInfo(
    __in                    IMFMediaType*           pMFType,
    __in_bcount(cbBufSize)  const MPEG1VIDEOINFO*   pMP1VI,
    __in                    UINT32                  cbBufSize,
    __in_opt                const GUID*             pSubtype = NULL
    );

STDAPI
MFInitMediaTypeFromMPEG2VideoInfo(
    __in                    IMFMediaType*           pMFType,
    __in_bcount(cbBufSize)  const MPEG2VIDEOINFO*   pMP2VI,
    __in                    UINT32                  cbBufSize,
    __in_opt                const GUID*             pSubtype = NULL
    );

STDAPI
MFCalculateBitmapImageSize(
    __in_bcount(cbBufSize)  const BITMAPINFOHEADER* pBMIH,
    __in                    UINT32                  cbBufSize,
    __out                   UINT32*                 pcbImageSize,
    __out_opt               BOOL*                   pbKnown = NULL
    );

#else

//
// same declarations without default parameters
//

STDAPI
MFCreateWaveFormatExFromMFMediaType(
    __in        IMFMediaType*   pMFType,
    __out       WAVEFORMATEX**  ppWF,
    __out_opt   UINT32*         pcbSize,
    __in        UINT32          Flags
    );

STDAPI
MFInitMediaTypeFromVideoInfoHeader(
    __in                    IMFMediaType*           pMFType,
    __in_bcount(cbBufSize)  const VIDEOINFOHEADER*  pVIH,
    __in                    UINT32                  cbBufSize,
    __in_opt                const GUID*             pSubtype
    );

STDAPI
MFInitMediaTypeFromVideoInfoHeader2(
    __in                    IMFMediaType*           pMFType,
    __in_bcount(cbBufSize)  const VIDEOINFOHEADER2* pVIH2,
    __in                    UINT32                  cbBufSize,
    __in_opt                const GUID*             pSubtype
    );

STDAPI
MFInitMediaTypeFromMPEG1VideoInfo(
    __in                    IMFMediaType*           pMFType,
    __in_bcount(cbBufSize)  const MPEG1VIDEOINFO*   pMP1VI,
    __in                    UINT32                  cbBufSize,
    __in_opt                const GUID*             pSubtype
    );

STDAPI
MFInitMediaTypeFromMPEG2VideoInfo(
    __in                    IMFMediaType*           pMFType,
    __in_bcount(cbBufSize)  const MPEG2VIDEOINFO*   pMP2VI,
    __in                    UINT32                  cbBufSize,
    __in_opt                const GUID*             pSubtype
    );

STDAPI
MFCalculateBitmapImageSize(
    __in_bcount(cbBufSize)  const BITMAPINFOHEADER* pBMIH,
    __in                    UINT32                  cbBufSize,
    __out                   UINT32*                 pcbImageSize,
    __out_opt               BOOL*                   pbKnown
    );

#endif

STDAPI
MFCalculateImageSize(
    __in                    REFGUID                 guidSubtype,
    __in                    UINT32                  unWidth,
    __in                    UINT32                  unHeight,
    __out                   UINT32*                 pcbImageSize
    );

STDAPI
MFFrameRateToAverageTimePerFrame(
    __in                    UINT32                  unNumerator,
    __in                    UINT32                  unDenominator,
    __out                   UINT64*                 punAverageTimePerFrame
    );

STDAPI
MFAverageTimePerFrameToFrameRate(
    __in                    UINT64                  unAverageTimePerFrame,
    __out                   UINT32*                 punNumerator,
    __out                   UINT32*                 punDenominator
    );

STDAPI
MFInitMediaTypeFromMFVideoFormat(
    __in                    IMFMediaType*           pMFType,
    __in_bcount(cbBufSize)  const MFVIDEOFORMAT*    pMFVF,
    __in                    UINT32                  cbBufSize
    );

STDAPI
MFInitMediaTypeFromWaveFormatEx(
    __in                    IMFMediaType*           pMFType,
    __in_bcount(cbBufSize)  const WAVEFORMATEX*     pWaveFormat,
    __in                    UINT32                  cbBufSize
    );

STDAPI
MFInitMediaTypeFromAMMediaType(
    __in    IMFMediaType*           pMFType,
    __in    const AM_MEDIA_TYPE*    pAMType
    );

STDAPI
MFInitAMMediaTypeFromMFMediaType(
    __in    IMFMediaType*           pMFType,
    __in    GUID                    guidFormatBlockType,
    __inout AM_MEDIA_TYPE*          pAMType
    );

STDAPI
MFCreateAMMediaTypeFromMFMediaType(
    __in    IMFMediaType*           pMFType,
    __in    GUID                    guidFormatBlockType,
    __inout AM_MEDIA_TYPE**         ppAMType // delete with DeleteMediaType
    );


//
// This function compares a full media type to a partial media type.
//
// A "partial" media type is one that is given out by a component as a possible
// media type it could accept. Many attributes may be unset, which represents
// a "don't care" status for that attribute.
//
// For example, a video effect may report that it supports YV12,
// but not want to specify a particular size. It simply creates a media type and sets
// the major type to MFMediaType_Video and the subtype to MEDIASUBTYPE_YV12.
//
// The comparison function succeeds if the partial type contains at least a major type,
// and all of the attributes in the partial type exist in the full type and are set to
// the same value.
//
STDAPI_(BOOL)
MFCompareFullToPartialMediaType(
    __in    IMFMediaType*   pMFTypeFull,
    __in    IMFMediaType*   pMFTypePartial
    );


STDAPI
MFWrapMediaType(
    __in    IMFMediaType*    pOrig,
    __in    REFGUID          MajorType,
    __in    REFGUID          SubType,
    __out   IMFMediaType **  ppWrap
    );

STDAPI
MFUnwrapMediaType(
    __in    IMFMediaType*    pWrap,
    __out   IMFMediaType **  ppOrig
    );


//
// MFCreateVideoMediaType
//

#ifdef _KSMEDIA_
STDAPI MFCreateVideoMediaTypeFromVideoInfoHeader(
    __in const KS_VIDEOINFOHEADER* pVideoInfoHeader,
    DWORD cbVideoInfoHeader,
    DWORD dwPixelAspectRatioX,
    DWORD dwPixelAspectRatioY,
    MFVideoInterlaceMode InterlaceMode,
    QWORD VideoFlags,
    __in_opt const GUID * pSubtype,
    __out IMFVideoMediaType** ppIVideoMediaType
    );

STDAPI MFCreateVideoMediaTypeFromVideoInfoHeader2(
    __in const KS_VIDEOINFOHEADER2* pVideoInfoHeader,
    DWORD cbVideoInfoHeader,
    QWORD AdditionalVideoFlags,
    __in_opt const GUID * pSubtype,
    __out IMFVideoMediaType** ppIVideoMediaType
    );

#endif

STDAPI MFCreateVideoMediaType(
    __in const MFVIDEOFORMAT* pVideoFormat,
    __out IMFVideoMediaType** ppIVideoMediaType
    );

STDAPI MFCreateVideoMediaTypeFromSubtype(
    __in const GUID * pAMSubtype,
    __out IMFVideoMediaType  **ppIVideoMediaType
    );

STDAPI_(BOOL)
MFIsFormatYUV(
    DWORD Format
    );

//
//  These depend on BITMAPINFOHEADER being defined
//
STDAPI MFCreateVideoMediaTypeFromBitMapInfoHeader(
    __in const BITMAPINFOHEADER* pbmihBitMapInfoHeader,
    DWORD dwPixelAspectRatioX,
    DWORD dwPixelAspectRatioY,
    MFVideoInterlaceMode InterlaceMode,
    QWORD VideoFlags,
    QWORD qwFramesPerSecondNumerator,
    QWORD qwFramesPerSecondDenominator,
    DWORD dwMaxBitRate,
    __out IMFVideoMediaType** ppIVideoMediaType
    );

STDAPI MFGetStrideForBitmapInfoHeader(
    DWORD format,
    DWORD dwWidth,
    __out LONG* pStride
    );

STDAPI MFGetPlaneSize(
    DWORD format,
    DWORD dwWidth,
    DWORD dwHeight,
    __out DWORD* pdwPlaneSize
    );

#if (WINVER >= _WIN32_WINNT_WIN7)
//
// MFCreateVideoMediaTypeFromBitMapInfoHeaderEx
//

STDAPI MFCreateVideoMediaTypeFromBitMapInfoHeaderEx(
    __in_bcount(cbBitMapInfoHeader) const BITMAPINFOHEADER* pbmihBitMapInfoHeader,
    __in    UINT32                  cbBitMapInfoHeader,
    DWORD dwPixelAspectRatioX,
    DWORD dwPixelAspectRatioY,
    MFVideoInterlaceMode InterlaceMode,
    QWORD VideoFlags,
    DWORD dwFramesPerSecondNumerator,
    DWORD dwFramesPerSecondDenominator,
    DWORD dwMaxBitRate,
    __out IMFVideoMediaType** ppIVideoMediaType
    );
#endif // (WINVER >= _WIN32_WINNT_WIN7)

//
// MFCreateMediaTypeFromRepresentation
//

STDAPI MFCreateMediaTypeFromRepresentation(
    GUID guidRepresentation,
    __in LPVOID pvRepresentation,
    __out IMFMediaType** ppIMediaType
    );


//
// MFCreateAudioMediaType
//

STDAPI
MFCreateAudioMediaType(
    __in    const WAVEFORMATEX* pAudioFormat,
    __out   IMFAudioMediaType** ppIAudioMediaType
    );


DWORD
STDMETHODCALLTYPE
MFGetUncompressedVideoFormat(
    __in    const MFVIDEOFORMAT* pVideoFormat
    );

STDAPI 
MFInitVideoFormat(
    __in    MFVIDEOFORMAT*          pVideoFormat,
    __in    MFStandardVideoFormat   type
    );

STDAPI
MFInitVideoFormat_RGB(
    __in    MFVIDEOFORMAT*  pVideoFormat,
    __in    DWORD           dwWidth,
    __in    DWORD           dwHeight,
    __in    DWORD           D3Dfmt /* 0 indicates sRGB */
    );

STDAPI 
MFConvertColorInfoToDXVA(
    __out DWORD* pdwToDXVA,
    __in  const MFVIDEOFORMAT* pFromFormat
    );
STDAPI
MFConvertColorInfoFromDXVA(
    __inout MFVIDEOFORMAT* pToFormat,
    __in    DWORD dwFromDXVA
    );

//
// Optimized stride copy function
//
STDAPI MFCopyImage(
    __out_bcount(abs(lDestStride) *  dwLines) BYTE* pDest,
    LONG    lDestStride,
    __in_bcount(abs(lSrcStride) * dwLines) const BYTE* pSrc,
    LONG    lSrcStride,
    __out_range(<=, min(abs(lSrcStride), abs(lDestStride)))  DWORD dwWidthInBytes,
    DWORD   dwLines
    );

STDAPI MFConvertFromFP16Array(
    __out_ecount(dwCount) float* pDest,
    __in_ecount(dwCount) const WORD* pSrc,
    DWORD dwCount
    );

STDAPI MFConvertToFP16Array(
    __out_ecount(dwCount) WORD* pDest,
    __in_ecount(dwCount) const float* pSrc,
    DWORD dwCount
    );




///////////////////////////////////////////////////////////////////////////////////////////////////////////////  Attributes Utility functions ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus

//
// IMFAttributes inline UTILITY FUNCTIONS - used for IMFMediaType as well
//
inline
UINT32
HI32(UINT64 unPacked)
{
    return (UINT32)(unPacked >> 32);
}

inline
UINT32
LO32(UINT64 unPacked)
{
    return (UINT32)unPacked;
}

inline
UINT64
Pack2UINT32AsUINT64(UINT32 unHigh, UINT32 unLow)
{
    return ((UINT64)unHigh << 32) | unLow;
}

inline
void
Unpack2UINT32AsUINT64(UINT64 unPacked, __out UINT32* punHigh, __out UINT32* punLow)
{
    *punHigh = HI32(unPacked);
    *punLow = LO32(unPacked);
}

inline
UINT64
PackSize(UINT32 unWidth, UINT32 unHeight)
{
    return Pack2UINT32AsUINT64(unWidth, unHeight);
}

inline
void
UnpackSize(UINT64 unPacked, __out UINT32* punWidth, __out UINT32* punHeight)
{
    Unpack2UINT32AsUINT64(unPacked, punWidth, punHeight);
}

inline
UINT64
PackRatio(INT32 nNumerator, UINT32 unDenominator)
{
    return Pack2UINT32AsUINT64((UINT32)nNumerator, unDenominator);
}

inline
void
UnpackRatio(UINT64 unPacked, __out INT32* pnNumerator, __out UINT32* punDenominator)
{
    Unpack2UINT32AsUINT64(unPacked, (UINT32*)pnNumerator, punDenominator);
}


//
// "failsafe" inline get methods - return the stored value or return a default
//
inline
UINT32
MFGetAttributeUINT32(
    IMFAttributes*  pAttributes,
    REFGUID         guidKey,
    UINT32          unDefault
    )
{
    UINT32 unRet;
    if (FAILED(pAttributes->GetUINT32(guidKey, &unRet))) {
        unRet = unDefault;
    }
    return unRet;
}

inline
UINT64
MFGetAttributeUINT64(
    IMFAttributes*  pAttributes,
    REFGUID         guidKey,
    UINT64          unDefault
    )
{
    UINT64 unRet;
    if (FAILED(pAttributes->GetUINT64(guidKey, &unRet))) {
        unRet = unDefault;
    }
    return unRet;
}

inline
double
MFGetAttributeDouble(
    IMFAttributes*  pAttributes,
    REFGUID         guidKey,
    double          fDefault
    )
{
    double fRet;
    if (FAILED(pAttributes->GetDouble(guidKey, &fRet))) {
        fRet = fDefault;
    }
    return fRet;
}

//
// helpers for getting/setting ratios and sizes
//

inline
HRESULT
MFGetAttribute2UINT32asUINT64(
    IMFAttributes*  pAttributes,
    REFGUID         guidKey,
    __out UINT32*   punHigh32,
    __out UINT32*   punLow32
    )
{
    UINT64 unPacked;
    HRESULT hr = S_OK;

    hr = pAttributes->GetUINT64(guidKey, &unPacked);
    if (FAILED(hr)) {
        return hr;
    }
    Unpack2UINT32AsUINT64(unPacked, punHigh32, punLow32);

    return hr;
}

inline
HRESULT
MFSetAttribute2UINT32asUINT64(
    IMFAttributes*  pAttributes,
    REFGUID         guidKey,
    UINT32          unHigh32,
    UINT32          unLow32
    )
{
    return pAttributes->SetUINT64(guidKey, Pack2UINT32AsUINT64(unHigh32, unLow32));
}

inline
HRESULT
MFGetAttributeRatio(
    IMFAttributes*  pAttributes,
    REFGUID         guidKey,
    __out UINT32*   punNumerator,
    __out UINT32*   punDenominator
    )
{
    return MFGetAttribute2UINT32asUINT64(pAttributes, guidKey, punNumerator, punDenominator);
}

inline
HRESULT
MFGetAttributeSize(
    IMFAttributes*  pAttributes,
    REFGUID         guidKey,
    __out UINT32*   punWidth,
    __out UINT32*   punHeight
    )
{
    return MFGetAttribute2UINT32asUINT64(pAttributes, guidKey, punWidth, punHeight);
}

inline
HRESULT
MFSetAttributeRatio(
    IMFAttributes*  pAttributes,
    REFGUID         guidKey,
    UINT32          unNumerator,
    UINT32          unDenominator
    )
{
    return MFSetAttribute2UINT32asUINT64(pAttributes, guidKey, unNumerator, unDenominator);
}

inline
HRESULT
MFSetAttributeSize(
    IMFAttributes*  pAttributes,
    REFGUID         guidKey,
    UINT32          unWidth,
    UINT32          unHeight
    )
{
    return MFSetAttribute2UINT32asUINT64(pAttributes, guidKey, unWidth, unHeight);
}
#endif

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////  Memory Management ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// Heap alloc/free
//
typedef enum _EAllocationType
{
    eAllocationTypeDynamic,
    eAllocationTypeRT,
    eAllocationTypePageable,
    eAllocationTypeIgnore
}   EAllocationType;

EXTERN_C void* WINAPI MFHeapAlloc( size_t nSize,
                            ULONG dwFlags,
                            __in_opt char *pszFile,
                            int line,
                            EAllocationType eat);
EXTERN_C void WINAPI MFHeapFree( void * pv );

///////////////////////////////  Collection         ////////////////////////////
////////////////////////////////////////////////////////////////////////////////

//
// Instantiates the MF-provided IMFCollection implementation
//
STDAPI MFCreateCollection(
    __out IMFCollection **ppIMFCollection );


//////////////////////////       SourceResolver     ////////////////////////////
////////////////////////////////////////////////////////////////////////////////
DEFINE_GUID(CLSID_MFSourceResolver,
    0x90eab60f,
    0xe43a,
    0x4188,
    0xbc, 0xc4, 0xe4, 0x7f, 0xdf, 0x04, 0x86, 0x8c);

#if (WINVER >= _WIN32_WINNT_WIN7)
//  Return (a * b + d) / c
//  Returns _I64_MAX or LLONG_MIN on failure or _I64_MAX if mplat.dll is not available
LONGLONG WINAPI MFllMulDiv(LONGLONG a, LONGLONG b, LONGLONG c, LONGLONG d);
#endif // (WINVER >= _WIN32_WINNT_WIN7)

#if defined(__cplusplus)
}
#endif

#endif //#if !defined(__MFAPI_H__)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\Mferror.h ===
/*++

  Microsoft Windows Media Foundation
  Copyright (C) Microsoft Corporation. All rights reserved.

Module Name:

    mferror.mc

Abstract:

    Definitions for MediaFoundation events.

Author:


Revision History:

Notes:

    This file is used by the MC tool to generate the mferror.h file

**************************** READ ME ******************************************

 Here are the commented error ranges for the Windows Media Technologies Group


 RANGES

 14000 - 14999 = General Media Foundation errors

 15000 - 15999 = ASF parsing errors

 16000 - 16999 = Media Source errors

 17000 - 17999 = MEDIAFOUNDATION Network Error Events

 18000 - 18999 = MEDIAFOUNDATION WMContainer Error Events

 19000 - 19999 = MEDIAFOUNDATION Media Sink Error Events

 20000 - 20999 = Renderer errors

 21000 - 21999 = Topology Errors

 25000 - 25999 = Timeline Errors

 26000 - 26999 = Unused

 28000 - 28999 = Transform errors

 29000 - 29999 = Content Protection errors
 
 40000 - 40999 = Clock errors
 
 41000 - 41999 = MF Quality Management Errors

 42000 - 42999 = MF Transcode API Errors

**************************** READ ME ******************************************

--*/

#ifndef _MFERROR_H
#define _MFERROR_H


#define STATUS_SEVERITY(hr)  (((hr) >> 30) & 0x3)

#ifdef RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) _sc
#else // RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)
#endif // RC_INVOKED


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Success Events
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Warning Events
//
/////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Error Events
//
/////////////////////////////////////////////////////////////////////////

//
//  Values are 32 bit values laid out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//
#define FACILITY_MF_WIN32                0x7
#define FACILITY_MF                      0xD


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: MF_E_PLATFORM_NOT_INITIALIZED
//
// MessageText:
//
// Platform not initialized. Please call MFStartup().%0
//
#define MF_E_PLATFORM_NOT_INITIALIZED    _HRESULT_TYPEDEF_(0xC00D36B0L)

//
// MessageId: MF_E_BUFFERTOOSMALL
//
// MessageText:
//
// The buffer was too small to carry out the requested action.%0
//
#define MF_E_BUFFERTOOSMALL              _HRESULT_TYPEDEF_(0xC00D36B1L)

//
// MessageId: MF_E_INVALIDREQUEST
//
// MessageText:
//
// The request is invalid in the current state.%0
//
#define MF_E_INVALIDREQUEST              _HRESULT_TYPEDEF_(0xC00D36B2L)

//
// MessageId: MF_E_INVALIDSTREAMNUMBER
//
// MessageText:
//
// The stream number provided was invalid.%0
//
#define MF_E_INVALIDSTREAMNUMBER         _HRESULT_TYPEDEF_(0xC00D36B3L)

//
// MessageId: MF_E_INVALIDMEDIATYPE
//
// MessageText:
//
// The data specified for the media type is invalid, inconsistent, or not supported by this object.%0
//
#define MF_E_INVALIDMEDIATYPE            _HRESULT_TYPEDEF_(0xC00D36B4L)

//
// MessageId: MF_E_NOTACCEPTING
//
// MessageText:
//
// The callee is currently not accepting further input.%0
//
#define MF_E_NOTACCEPTING                _HRESULT_TYPEDEF_(0xC00D36B5L)

//
// MessageId: MF_E_NOT_INITIALIZED
//
// MessageText:
//
// This object needs to be initialized before the requested operation can be carried out.%0
//
#define MF_E_NOT_INITIALIZED             _HRESULT_TYPEDEF_(0xC00D36B6L)

//
// MessageId: MF_E_UNSUPPORTED_REPRESENTATION
//
// MessageText:
//
// The requested representation is not supported by this object.%0
//
#define MF_E_UNSUPPORTED_REPRESENTATION  _HRESULT_TYPEDEF_(0xC00D36B7L)

//
// MessageId: MF_E_NO_MORE_TYPES
//
// MessageText:
//
// An object ran out of media types to suggest therefore the requested chain of streaming objects cannot be completed.%0
//
#define MF_E_NO_MORE_TYPES               _HRESULT_TYPEDEF_(0xC00D36B9L)

//
// MessageId: MF_E_UNSUPPORTED_SERVICE
//
// MessageText:
//
// The object does not support the specified service.%0
//
#define MF_E_UNSUPPORTED_SERVICE         _HRESULT_TYPEDEF_(0xC00D36BAL)

//
// MessageId: MF_E_UNEXPECTED
//
// MessageText:
//
// An unexpected error has occurred in the operation requested.%0
//
#define MF_E_UNEXPECTED                  _HRESULT_TYPEDEF_(0xC00D36BBL)

//
// MessageId: MF_E_INVALIDNAME
//
// MessageText:
//
// Invalid name.%0
//
#define MF_E_INVALIDNAME                 _HRESULT_TYPEDEF_(0xC00D36BCL)

//
// MessageId: MF_E_INVALIDTYPE
//
// MessageText:
//
// Invalid type.%0
//
#define MF_E_INVALIDTYPE                 _HRESULT_TYPEDEF_(0xC00D36BDL)

//
// MessageId: MF_E_INVALID_FILE_FORMAT
//
// MessageText:
//
// The file does not conform to the relevant file format specification.
//
#define MF_E_INVALID_FILE_FORMAT         _HRESULT_TYPEDEF_(0xC00D36BEL)

//
// MessageId: MF_E_INVALIDINDEX
//
// MessageText:
//
// Invalid index.%0
//
#define MF_E_INVALIDINDEX                _HRESULT_TYPEDEF_(0xC00D36BFL)

//
// MessageId: MF_E_INVALID_TIMESTAMP
//
// MessageText:
//
// An invalid timestamp was given.%0
//
#define MF_E_INVALID_TIMESTAMP           _HRESULT_TYPEDEF_(0xC00D36C0L)

//
// MessageId: MF_E_UNSUPPORTED_SCHEME
//
// MessageText:
//
// The scheme of the given URL is unsupported.%0
//
#define MF_E_UNSUPPORTED_SCHEME          _HRESULT_TYPEDEF_(0xC00D36C3L)

//
// MessageId: MF_E_UNSUPPORTED_BYTESTREAM_TYPE
//
// MessageText:
//
// The byte stream type of the given URL is unsupported.%0
//
#define MF_E_UNSUPPORTED_BYTESTREAM_TYPE _HRESULT_TYPEDEF_(0xC00D36C4L)

//
// MessageId: MF_E_UNSUPPORTED_TIME_FORMAT
//
// MessageText:
//
// The given time format is unsupported.%0
//
#define MF_E_UNSUPPORTED_TIME_FORMAT     _HRESULT_TYPEDEF_(0xC00D36C5L)

//
// MessageId: MF_E_NO_SAMPLE_TIMESTAMP
//
// MessageText:
//
// The Media Sample does not have a timestamp.%0
//
#define MF_E_NO_SAMPLE_TIMESTAMP         _HRESULT_TYPEDEF_(0xC00D36C8L)

//
// MessageId: MF_E_NO_SAMPLE_DURATION
//
// MessageText:
//
// The Media Sample does not have a duration.%0
//
#define MF_E_NO_SAMPLE_DURATION          _HRESULT_TYPEDEF_(0xC00D36C9L)

//
// MessageId: MF_E_INVALID_STREAM_DATA
//
// MessageText:
//
// The request failed because the data in the stream is corrupt.%0\n.
//
#define MF_E_INVALID_STREAM_DATA         _HRESULT_TYPEDEF_(0xC00D36CBL)

//
// MessageId: MF_E_RT_UNAVAILABLE
//
// MessageText:
//
// Real time services are not available.%0
//
#define MF_E_RT_UNAVAILABLE              _HRESULT_TYPEDEF_(0xC00D36CFL)

//
// MessageId: MF_E_UNSUPPORTED_RATE
//
// MessageText:
//
// The specified rate is not supported.%0
//
#define MF_E_UNSUPPORTED_RATE            _HRESULT_TYPEDEF_(0xC00D36D0L)

//
// MessageId: MF_E_THINNING_UNSUPPORTED
//
// MessageText:
//
// This component does not support stream-thinning.%0
//
#define MF_E_THINNING_UNSUPPORTED        _HRESULT_TYPEDEF_(0xC00D36D1L)

//
// MessageId: MF_E_REVERSE_UNSUPPORTED
//
// MessageText:
//
// The call failed because no reverse playback rates are available.%0
//
#define MF_E_REVERSE_UNSUPPORTED         _HRESULT_TYPEDEF_(0xC00D36D2L)

//
// MessageId: MF_E_UNSUPPORTED_RATE_TRANSITION
//
// MessageText:
//
// The requested rate transition cannot occur in the current state.%0
//
#define MF_E_UNSUPPORTED_RATE_TRANSITION _HRESULT_TYPEDEF_(0xC00D36D3L)

//
// MessageId: MF_E_RATE_CHANGE_PREEMPTED
//
// MessageText:
//
// The requested rate change has been pre-empted and will not occur.%0
//
#define MF_E_RATE_CHANGE_PREEMPTED       _HRESULT_TYPEDEF_(0xC00D36D4L)

//
// MessageId: MF_E_NOT_FOUND
//
// MessageText:
//
// The specified object or value does not exist.%0
//
#define MF_E_NOT_FOUND                   _HRESULT_TYPEDEF_(0xC00D36D5L)

//
// MessageId: MF_E_NOT_AVAILABLE
//
// MessageText:
//
// The requested value is not available.%0
//
#define MF_E_NOT_AVAILABLE               _HRESULT_TYPEDEF_(0xC00D36D6L)

//
// MessageId: MF_E_NO_CLOCK
//
// MessageText:
//
// The specified operation requires a clock and no clock is available.%0
//
#define MF_E_NO_CLOCK                    _HRESULT_TYPEDEF_(0xC00D36D7L)

//
// MessageId: MF_S_MULTIPLE_BEGIN
//
// MessageText:
//
// This callback and state had already been passed in to this event generator earlier.%0
//
#define MF_S_MULTIPLE_BEGIN              _HRESULT_TYPEDEF_(0x000D36D8L)

//
// MessageId: MF_E_MULTIPLE_BEGIN
//
// MessageText:
//
// This callback has already been passed in to this event generator.%0
//
#define MF_E_MULTIPLE_BEGIN              _HRESULT_TYPEDEF_(0xC00D36D9L)

//
// MessageId: MF_E_MULTIPLE_SUBSCRIBERS
//
// MessageText:
//
// Some component is already listening to events on this event generator.%0
//
#define MF_E_MULTIPLE_SUBSCRIBERS        _HRESULT_TYPEDEF_(0xC00D36DAL)

//
// MessageId: MF_E_TIMER_ORPHANED
//
// MessageText:
//
// This timer was orphaned before its callback time arrived.%0
//
#define MF_E_TIMER_ORPHANED              _HRESULT_TYPEDEF_(0xC00D36DBL)

//
// MessageId: MF_E_STATE_TRANSITION_PENDING
//
// MessageText:
//
// A state transition is already pending.%0
//
#define MF_E_STATE_TRANSITION_PENDING    _HRESULT_TYPEDEF_(0xC00D36DCL)

//
// MessageId: MF_E_UNSUPPORTED_STATE_TRANSITION
//
// MessageText:
//
// The requested state transition is unsupported.%0
//
#define MF_E_UNSUPPORTED_STATE_TRANSITION _HRESULT_TYPEDEF_(0xC00D36DDL)

//
// MessageId: MF_E_UNRECOVERABLE_ERROR_OCCURRED
//
// MessageText:
//
// An unrecoverable error has occurred.%0
//
#define MF_E_UNRECOVERABLE_ERROR_OCCURRED _HRESULT_TYPEDEF_(0xC00D36DEL)

//
// MessageId: MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS
//
// MessageText:
//
// The provided sample has too many buffers.%0
//
#define MF_E_SAMPLE_HAS_TOO_MANY_BUFFERS _HRESULT_TYPEDEF_(0xC00D36DFL)

//
// MessageId: MF_E_SAMPLE_NOT_WRITABLE
//
// MessageText:
//
// The provided sample is not writable.%0
//
#define MF_E_SAMPLE_NOT_WRITABLE         _HRESULT_TYPEDEF_(0xC00D36E0L)

//
// MessageId: MF_E_INVALID_KEY
//
// MessageText:
//
// The specified key is not valid.
//
#define MF_E_INVALID_KEY                 _HRESULT_TYPEDEF_(0xC00D36E2L)

//
// MessageId: MF_E_BAD_STARTUP_VERSION
//
// MessageText:
//
// You are calling MFStartup with the wrong MF_VERSION. Mismatched bits?
//
#define MF_E_BAD_STARTUP_VERSION         _HRESULT_TYPEDEF_(0xC00D36E3L)

//
// MessageId: MF_E_UNSUPPORTED_CAPTION
//
// MessageText:
//
// The caption of the given URL is unsupported.%0
//
#define MF_E_UNSUPPORTED_CAPTION         _HRESULT_TYPEDEF_(0xC00D36E4L)

//
// MessageId: MF_E_INVALID_POSITION
//
// MessageText:
//
// The operation on the current offset is not permitted.%0
//
#define MF_E_INVALID_POSITION            _HRESULT_TYPEDEF_(0xC00D36E5L)

//
// MessageId: MF_E_ATTRIBUTENOTFOUND
//
// MessageText:
//
// The requested attribute was not found.%0
//
#define MF_E_ATTRIBUTENOTFOUND           _HRESULT_TYPEDEF_(0xC00D36E6L)

//
// MessageId: MF_E_PROPERTY_TYPE_NOT_ALLOWED
//
// MessageText:
//
// The specified property type is not allowed in this context.%0
//
#define MF_E_PROPERTY_TYPE_NOT_ALLOWED   _HRESULT_TYPEDEF_(0xC00D36E7L)

//
// MessageId: MF_E_PROPERTY_TYPE_NOT_SUPPORTED
//
// MessageText:
//
// The specified property type is not supported.%0
//
#define MF_E_PROPERTY_TYPE_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D36E8L)

//
// MessageId: MF_E_PROPERTY_EMPTY
//
// MessageText:
//
// The specified property is empty.%0
//
#define MF_E_PROPERTY_EMPTY              _HRESULT_TYPEDEF_(0xC00D36E9L)

//
// MessageId: MF_E_PROPERTY_NOT_EMPTY
//
// MessageText:
//
// The specified property is not empty.%0
//
#define MF_E_PROPERTY_NOT_EMPTY          _HRESULT_TYPEDEF_(0xC00D36EAL)

//
// MessageId: MF_E_PROPERTY_VECTOR_NOT_ALLOWED
//
// MessageText:
//
// The vector property specified is not allowed in this context.%0
//
#define MF_E_PROPERTY_VECTOR_NOT_ALLOWED _HRESULT_TYPEDEF_(0xC00D36EBL)

//
// MessageId: MF_E_PROPERTY_VECTOR_REQUIRED
//
// MessageText:
//
// A vector property is required in this context.%0
//
#define MF_E_PROPERTY_VECTOR_REQUIRED    _HRESULT_TYPEDEF_(0xC00D36ECL)

//
// MessageId: MF_E_OPERATION_CANCELLED
//
// MessageText:
//
// The operation is cancelled.%0
//
#define MF_E_OPERATION_CANCELLED         _HRESULT_TYPEDEF_(0xC00D36EDL)

//
// MessageId: MF_E_BYTESTREAM_NOT_SEEKABLE
//
// MessageText:
//
// The provided bytestream was expected to be seekable and it is not.%0
//
#define MF_E_BYTESTREAM_NOT_SEEKABLE     _HRESULT_TYPEDEF_(0xC00D36EEL)

//
// MessageId: MF_E_DISABLED_IN_SAFEMODE
//
// MessageText:
//
// The Media Foundation platform is disabled when the system is running in Safe Mode.%0
//
#define MF_E_DISABLED_IN_SAFEMODE        _HRESULT_TYPEDEF_(0xC00D36EFL)

//
// MessageId: MF_E_CANNOT_PARSE_BYTESTREAM
//
// MessageText:
//
// The Media Source could not parse the byte stream.%0
//
#define MF_E_CANNOT_PARSE_BYTESTREAM     _HRESULT_TYPEDEF_(0xC00D36F0L)

//
// MessageId: MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS
//
// MessageText:
//
// Mutually exclusive flags have been specified to source resolver. This flag combination is invalid.%0
//
#define MF_E_SOURCERESOLVER_MUTUALLY_EXCLUSIVE_FLAGS _HRESULT_TYPEDEF_(0xC00D36F1L)

//
// MessageId: MF_E_MEDIAPROC_WRONGSTATE
//
// MessageText:
//
// MediaProc is in the wrong state%0
//
#define MF_E_MEDIAPROC_WRONGSTATE        _HRESULT_TYPEDEF_(0xC00D36F2L)

//
// MessageId: MF_E_RT_THROUGHPUT_NOT_AVAILABLE
//
// MessageText:
//
// Real time I/O service can not provide requested throughput.%0
//
#define MF_E_RT_THROUGHPUT_NOT_AVAILABLE _HRESULT_TYPEDEF_(0xC00D36F3L)

//
// MessageId: MF_E_RT_TOO_MANY_CLASSES
//
// MessageText:
//
// The workqueue cannot be registered with more classes.%0
//
#define MF_E_RT_TOO_MANY_CLASSES         _HRESULT_TYPEDEF_(0xC00D36F4L)

//
// MessageId: MF_E_RT_WOULDBLOCK
//
// MessageText:
//
// This operation cannot succeed because another thread owns this object.%0
//
#define MF_E_RT_WOULDBLOCK               _HRESULT_TYPEDEF_(0xC00D36F5L)

//
// MessageId: MF_E_NO_BITPUMP
//
// MessageText:
//
// Internal. Bitpump not found.%0
//
#define MF_E_NO_BITPUMP                  _HRESULT_TYPEDEF_(0xC00D36F6L)

//
// MessageId: MF_E_RT_OUTOFMEMORY
//
// MessageText:
//
// No more RT memory available.%0
//
#define MF_E_RT_OUTOFMEMORY              _HRESULT_TYPEDEF_(0xC00D36F7L)

//
// MessageId: MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED
//
// MessageText:
//
// An MMCSS class has not been set for this work queue.%0
//
#define MF_E_RT_WORKQUEUE_CLASS_NOT_SPECIFIED _HRESULT_TYPEDEF_(0xC00D36F8L)

//
// MessageId: MF_E_INSUFFICIENT_BUFFER
//
// MessageText:
//
// Insufficient memory for response.%0
//
#define MF_E_INSUFFICIENT_BUFFER         _HRESULT_TYPEDEF_(0xC00D7170L)

//
// MessageId: MF_E_CANNOT_CREATE_SINK
//
// MessageText:
//
// Activate failed to create mediasink. Call OutputNode::GetUINT32(MF_TOPONODE_MAJORTYPE) for more information. %0
//
#define MF_E_CANNOT_CREATE_SINK          _HRESULT_TYPEDEF_(0xC00D36FAL)

//
// MessageId: MF_E_BYTESTREAM_UNKNOWN_LENGTH
//
// MessageText:
//
// The length of the provided bytestream is unknown.%0
//
#define MF_E_BYTESTREAM_UNKNOWN_LENGTH   _HRESULT_TYPEDEF_(0xC00D36FBL)

//
// MessageId: MF_E_SESSION_PAUSEWHILESTOPPED
//
// MessageText:
//
// The media session cannot pause from a stopped state.%0
//
#define MF_E_SESSION_PAUSEWHILESTOPPED   _HRESULT_TYPEDEF_(0xC00D36FCL)

//
// MessageId: MF_S_ACTIVATE_REPLACED
//
// MessageText:
//
// The activate could not be created in the remote process for some reason it was replaced with empty one.%0
//
#define MF_S_ACTIVATE_REPLACED           _HRESULT_TYPEDEF_(0x000D36FDL)

//
// MessageId: MF_E_FORMAT_CHANGE_NOT_SUPPORTED
//
// MessageText:
//
// The data specified for the media type is supported, but would require a format change, which is not supported by this object.%0
//
#define MF_E_FORMAT_CHANGE_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D36FEL)

//
// MessageId: MF_E_INVALID_WORKQUEUE
//
// MessageText:
//
// The operation failed because an invalid combination of workqueue ID and flags was specified.%0
//
#define MF_E_INVALID_WORKQUEUE           _HRESULT_TYPEDEF_(0xC00D36FFL)

//
// MessageId: MF_E_DRM_UNSUPPORTED
//
// MessageText:
//
// No DRM support is available.%0
//
#define MF_E_DRM_UNSUPPORTED             _HRESULT_TYPEDEF_(0xC00D3700L)

//
// MessageId: MF_E_UNAUTHORIZED
//
// MessageText:
//
// This operation is not authorized.%0
//
#define MF_E_UNAUTHORIZED                _HRESULT_TYPEDEF_(0xC00D3701L)

//
// MessageId: MF_E_OUT_OF_RANGE
//
// MessageText:
//
// The value is not in the specified or valid range.%0
//
#define MF_E_OUT_OF_RANGE                _HRESULT_TYPEDEF_(0xC00D3702L)

//
// MessageId: MF_E_INVALID_CODEC_MERIT
//
// MessageText:
//
// The registered codec merit is not valid.%0
//
#define MF_E_INVALID_CODEC_MERIT         _HRESULT_TYPEDEF_(0xC00D3703L)

//
// MessageId: MF_E_HW_MFT_FAILED_START_STREAMING
//
// MessageText:
//
// Hardware MFT failed to start streaming due to lack of hardware resources.%0
//
#define MF_E_HW_MFT_FAILED_START_STREAMING _HRESULT_TYPEDEF_(0xC00D3704L)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION ASF Parsing Informational Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_S_ASF_PARSEINPROGRESS
//
// MessageText:
//
// Parsing is still in progress and is not yet complete.%0
//
#define MF_S_ASF_PARSEINPROGRESS         _HRESULT_TYPEDEF_(0x400D3A98L)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION ASF Parsing Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_ASF_PARSINGINCOMPLETE
//
// MessageText:
//
// Not enough data have been parsed to carry out the requested action.%0
//
#define MF_E_ASF_PARSINGINCOMPLETE       _HRESULT_TYPEDEF_(0xC00D3A98L)

//
// MessageId: MF_E_ASF_MISSINGDATA
//
// MessageText:
//
// There is a gap in the ASF data provided.%0
//
#define MF_E_ASF_MISSINGDATA             _HRESULT_TYPEDEF_(0xC00D3A99L)

//
// MessageId: MF_E_ASF_INVALIDDATA
//
// MessageText:
//
// The data provided are not valid ASF.%0
//
#define MF_E_ASF_INVALIDDATA             _HRESULT_TYPEDEF_(0xC00D3A9AL)

//
// MessageId: MF_E_ASF_OPAQUEPACKET
//
// MessageText:
//
// The packet is opaque, so the requested information cannot be returned.%0
//
#define MF_E_ASF_OPAQUEPACKET            _HRESULT_TYPEDEF_(0xC00D3A9BL)

//
// MessageId: MF_E_ASF_NOINDEX
//
// MessageText:
//
// The requested operation failed since there is no appropriate ASF index.%0
//
#define MF_E_ASF_NOINDEX                 _HRESULT_TYPEDEF_(0xC00D3A9CL)

//
// MessageId: MF_E_ASF_OUTOFRANGE
//
// MessageText:
//
// The value supplied is out of range for this operation.%0
//
#define MF_E_ASF_OUTOFRANGE              _HRESULT_TYPEDEF_(0xC00D3A9DL)

//
// MessageId: MF_E_ASF_INDEXNOTLOADED
//
// MessageText:
//
// The index entry requested needs to be loaded before it can be available.%0
//
#define MF_E_ASF_INDEXNOTLOADED          _HRESULT_TYPEDEF_(0xC00D3A9EL)    

//
// MessageId: MF_E_ASF_TOO_MANY_PAYLOADS
//
// MessageText:
//
// The packet has reached the maximum number of payloads.%0
//
#define MF_E_ASF_TOO_MANY_PAYLOADS       _HRESULT_TYPEDEF_(0xC00D3A9FL)    

//
// MessageId: MF_E_ASF_UNSUPPORTED_STREAM_TYPE
//
// MessageText:
//
// Stream type is not supported.%0
//
#define MF_E_ASF_UNSUPPORTED_STREAM_TYPE _HRESULT_TYPEDEF_(0xC00D3AA0L)    

//
// MessageId: MF_E_ASF_DROPPED_PACKET
//
// MessageText:
//
// One or more ASF packets were dropped.%0
//
#define MF_E_ASF_DROPPED_PACKET          _HRESULT_TYPEDEF_(0xC00D3AA1L)    


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Media Source Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_NO_EVENTS_AVAILABLE
//
// MessageText:
//
// There are no events available in the queue.%0
//
#define MF_E_NO_EVENTS_AVAILABLE         _HRESULT_TYPEDEF_(0xC00D3E80L)

//
// MessageId: MF_E_INVALID_STATE_TRANSITION
//
// MessageText:
//
// A media source cannot go from the stopped state to the paused state.%0
//
#define MF_E_INVALID_STATE_TRANSITION    _HRESULT_TYPEDEF_(0xC00D3E82L)

//
// MessageId: MF_E_END_OF_STREAM
//
// MessageText:
//
// The media stream cannot process any more samples because there are no more samples in the stream.%0
//
#define MF_E_END_OF_STREAM               _HRESULT_TYPEDEF_(0xC00D3E84L)

//
// MessageId: MF_E_SHUTDOWN
//
// MessageText:
//
// The request is invalid because Shutdown() has been called.%0
//
#define MF_E_SHUTDOWN                    _HRESULT_TYPEDEF_(0xC00D3E85L)

//
// MessageId: MF_E_MP3_NOTFOUND
//
// MessageText:
//
// The MP3 object was not found.%0
//
#define MF_E_MP3_NOTFOUND                _HRESULT_TYPEDEF_(0xC00D3E86L)

//
// MessageId: MF_E_MP3_OUTOFDATA
//
// MessageText:
//
// The MP3 parser ran out of data before finding the MP3 object.%0
//
#define MF_E_MP3_OUTOFDATA               _HRESULT_TYPEDEF_(0xC00D3E87L)

//
// MessageId: MF_E_MP3_NOTMP3
//
// MessageText:
//
// The file is not really a MP3 file.%0
//
#define MF_E_MP3_NOTMP3                  _HRESULT_TYPEDEF_(0xC00D3E88L)

//
// MessageId: MF_E_MP3_NOTSUPPORTED
//
// MessageText:
//
// The MP3 file is not supported.%0
//
#define MF_E_MP3_NOTSUPPORTED            _HRESULT_TYPEDEF_(0xC00D3E89L)

//
// MessageId: MF_E_NO_DURATION
//
// MessageText:
//
// The Media stream has no duration.%0
//
#define MF_E_NO_DURATION                 _HRESULT_TYPEDEF_(0xC00D3E8AL)

//
// MessageId: MF_E_INVALID_FORMAT
//
// MessageText:
//
// The Media format is recognized but is invalid.%0
//
#define MF_E_INVALID_FORMAT              _HRESULT_TYPEDEF_(0xC00D3E8CL)

//
// MessageId: MF_E_PROPERTY_NOT_FOUND
//
// MessageText:
//
// The property requested was not found.%0
//
#define MF_E_PROPERTY_NOT_FOUND          _HRESULT_TYPEDEF_(0xC00D3E8DL)

//
// MessageId: MF_E_PROPERTY_READ_ONLY
//
// MessageText:
//
// The property is read only.%0
//
#define MF_E_PROPERTY_READ_ONLY          _HRESULT_TYPEDEF_(0xC00D3E8EL)

//
// MessageId: MF_E_PROPERTY_NOT_ALLOWED
//
// MessageText:
//
// The specified property is not allowed in this context.%0
//
#define MF_E_PROPERTY_NOT_ALLOWED        _HRESULT_TYPEDEF_(0xC00D3E8FL)

//
// MessageId: MF_E_MEDIA_SOURCE_NOT_STARTED
//
// MessageText:
//
// The media source is not started.%0
//
#define MF_E_MEDIA_SOURCE_NOT_STARTED    _HRESULT_TYPEDEF_(0xC00D3E91L)

//
// MessageId: MF_E_UNSUPPORTED_FORMAT
//
// MessageText:
//
// The Media format is recognized but not supported.%0
//
#define MF_E_UNSUPPORTED_FORMAT          _HRESULT_TYPEDEF_(0xC00D3E98L)

//
// MessageId: MF_E_MP3_BAD_CRC
//
// MessageText:
//
// The MPEG frame has bad CRC.%0
//
#define MF_E_MP3_BAD_CRC                 _HRESULT_TYPEDEF_(0xC00D3E99L)

//
// MessageId: MF_E_NOT_PROTECTED
//
// MessageText:
//
// The file is not protected.%0
//
#define MF_E_NOT_PROTECTED               _HRESULT_TYPEDEF_(0xC00D3E9AL)

//
// MessageId: MF_E_MEDIA_SOURCE_WRONGSTATE
//
// MessageText:
//
// The media source is in the wrong state%0
//
#define MF_E_MEDIA_SOURCE_WRONGSTATE     _HRESULT_TYPEDEF_(0xC00D3E9BL)

//
// MessageId: MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED
//
// MessageText:
//
// No streams are selected in source presentation descriptor.%0
//
#define MF_E_MEDIA_SOURCE_NO_STREAMS_SELECTED _HRESULT_TYPEDEF_(0xC00D3E9CL)

//
// MessageId: MF_E_CANNOT_FIND_KEYFRAME_SAMPLE
//
// MessageText:
//
// No key frame sample was found.%0
//
#define MF_E_CANNOT_FIND_KEYFRAME_SAMPLE _HRESULT_TYPEDEF_(0xC00D3E9DL)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Network Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_NETWORK_RESOURCE_FAILURE
//
// MessageText:
//
// An attempt to acquire a network resource failed.%0
//
#define MF_E_NETWORK_RESOURCE_FAILURE    _HRESULT_TYPEDEF_(0xC00D4268L)

//
// MessageId: MF_E_NET_WRITE
//
// MessageText:
//
// Error writing to the network.%0
//
#define MF_E_NET_WRITE                   _HRESULT_TYPEDEF_(0xC00D4269L)

//
// MessageId: MF_E_NET_READ
//
// MessageText:
//
// Error reading from the network.%0
//
#define MF_E_NET_READ                    _HRESULT_TYPEDEF_(0xC00D426AL)

//
// MessageId: MF_E_NET_REQUIRE_NETWORK
//
// MessageText:
//
// Internal. Entry cannot complete operation without network.%0
//
#define MF_E_NET_REQUIRE_NETWORK         _HRESULT_TYPEDEF_(0xC00D426BL)

//
// MessageId: MF_E_NET_REQUIRE_ASYNC
//
// MessageText:
//
// Internal. Async op is required.%0
//
#define MF_E_NET_REQUIRE_ASYNC           _HRESULT_TYPEDEF_(0xC00D426CL)

//
// MessageId: MF_E_NET_BWLEVEL_NOT_SUPPORTED
//
// MessageText:
//
// Internal. Bandwidth levels are not supported.%0
//
#define MF_E_NET_BWLEVEL_NOT_SUPPORTED   _HRESULT_TYPEDEF_(0xC00D426DL)

//
// MessageId: MF_E_NET_STREAMGROUPS_NOT_SUPPORTED
//
// MessageText:
//
// Internal. Stream groups are not supported.%0
//
#define MF_E_NET_STREAMGROUPS_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D426EL)

//
// MessageId: MF_E_NET_MANUALSS_NOT_SUPPORTED
//
// MessageText:
//
// Manual stream selection is not supported.%0
//
#define MF_E_NET_MANUALSS_NOT_SUPPORTED  _HRESULT_TYPEDEF_(0xC00D426FL)

//
// MessageId: MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR
//
// MessageText:
//
// Invalid presentation descriptor.%0
//
#define MF_E_NET_INVALID_PRESENTATION_DESCRIPTOR _HRESULT_TYPEDEF_(0xC00D4270L)

//
// MessageId: MF_E_NET_CACHESTREAM_NOT_FOUND
//
// MessageText:
//
// Cannot find cache stream.%0
//
#define MF_E_NET_CACHESTREAM_NOT_FOUND   _HRESULT_TYPEDEF_(0xC00D4271L)

//
// MessageId: MF_I_MANUAL_PROXY
//
// MessageText:
//
// The proxy setting is manual.%0
//
#define MF_I_MANUAL_PROXY                _HRESULT_TYPEDEF_(0x400D4272L)

//duplicate removed
//MessageId=17011 Severity=Informational Facility=MEDIAFOUNDATION SymbolicName=MF_E_INVALID_REQUEST
//Language=English
//The request is invalid in the current state.%0
//.
//
// MessageId: MF_E_NET_REQUIRE_INPUT
//
// MessageText:
//
// Internal. Entry cannot complete operation without input.%0
//
#define MF_E_NET_REQUIRE_INPUT           _HRESULT_TYPEDEF_(0xC00D4274L)

//
// MessageId: MF_E_NET_REDIRECT
//
// MessageText:
//
// The client redirected to another server.%0
//
#define MF_E_NET_REDIRECT                _HRESULT_TYPEDEF_(0xC00D4275L)

//
// MessageId: MF_E_NET_REDIRECT_TO_PROXY
//
// MessageText:
//
// The client is redirected to a proxy server.%0
//
#define MF_E_NET_REDIRECT_TO_PROXY       _HRESULT_TYPEDEF_(0xC00D4276L)

//
// MessageId: MF_E_NET_TOO_MANY_REDIRECTS
//
// MessageText:
//
// The client reached maximum redirection limit.%0
//
#define MF_E_NET_TOO_MANY_REDIRECTS      _HRESULT_TYPEDEF_(0xC00D4277L)

//
// MessageId: MF_E_NET_TIMEOUT
//
// MessageText:
//
// The server, a computer set up to offer multimedia content to other computers, could not handle your request for multimedia content in a timely manner.  Please try again later.%0
//
#define MF_E_NET_TIMEOUT                 _HRESULT_TYPEDEF_(0xC00D4278L)

//
// MessageId: MF_E_NET_CLIENT_CLOSE
//
// MessageText:
//
// The control socket is closed by the client.%0
//
#define MF_E_NET_CLIENT_CLOSE            _HRESULT_TYPEDEF_(0xC00D4279L)

//
// MessageId: MF_E_NET_BAD_CONTROL_DATA
//
// MessageText:
//
// The server received invalid data from the client on the control connection.%0
//
#define MF_E_NET_BAD_CONTROL_DATA        _HRESULT_TYPEDEF_(0xC00D427AL)

//
// MessageId: MF_E_NET_INCOMPATIBLE_SERVER
//
// MessageText:
//
// The server is not a compatible streaming media server.%0
//
#define MF_E_NET_INCOMPATIBLE_SERVER     _HRESULT_TYPEDEF_(0xC00D427BL)

//
// MessageId: MF_E_NET_UNSAFE_URL
//
// MessageText:
//
// Url.%0
//
#define MF_E_NET_UNSAFE_URL              _HRESULT_TYPEDEF_(0xC00D427CL)

//
// MessageId: MF_E_NET_CACHE_NO_DATA
//
// MessageText:
//
// Data is not available.%0
//
#define MF_E_NET_CACHE_NO_DATA           _HRESULT_TYPEDEF_(0xC00D427DL)

//
// MessageId: MF_E_NET_EOL
//
// MessageText:
//
// End of line.%0
//
#define MF_E_NET_EOL                     _HRESULT_TYPEDEF_(0xC00D427EL)

//
// MessageId: MF_E_NET_BAD_REQUEST
//
// MessageText:
//
// The request could not be understood by the server.%0
//
#define MF_E_NET_BAD_REQUEST             _HRESULT_TYPEDEF_(0xC00D427FL)

//
// MessageId: MF_E_NET_INTERNAL_SERVER_ERROR
//
// MessageText:
//
// The server encountered an unexpected condition which prevented it from fulfilling the request.%0
//
#define MF_E_NET_INTERNAL_SERVER_ERROR   _HRESULT_TYPEDEF_(0xC00D4280L)

//
// MessageId: MF_E_NET_SESSION_NOT_FOUND
//
// MessageText:
//
// Session not found.%0
//
#define MF_E_NET_SESSION_NOT_FOUND       _HRESULT_TYPEDEF_(0xC00D4281L)

//
// MessageId: MF_E_NET_NOCONNECTION
//
// MessageText:
//
// There is no connection established with the Windows Media server. The operation failed.%0
//
#define MF_E_NET_NOCONNECTION            _HRESULT_TYPEDEF_(0xC00D4282L)

//
// MessageId: MF_E_NET_CONNECTION_FAILURE
//
// MessageText:
//
// The network connection has failed.%0
//
#define MF_E_NET_CONNECTION_FAILURE      _HRESULT_TYPEDEF_(0xC00D4283L)

//
// MessageId: MF_E_NET_INCOMPATIBLE_PUSHSERVER
//
// MessageText:
//
// The Server service that received the HTTP push request is not a compatible version of Windows Media Services (WMS).  This error may indicate the push request was received by IIS instead of WMS.  Ensure WMS is started and has the HTTP Server control protocol properly enabled and try again.%0
//
#define MF_E_NET_INCOMPATIBLE_PUSHSERVER _HRESULT_TYPEDEF_(0xC00D4284L)

//
// MessageId: MF_E_NET_SERVER_ACCESSDENIED
//
// MessageText:
//
// The Windows Media server is denying access.  The username and/or password might be incorrect.%0
//
#define MF_E_NET_SERVER_ACCESSDENIED     _HRESULT_TYPEDEF_(0xC00D4285L)

//
// MessageId: MF_E_NET_PROXY_ACCESSDENIED
//
// MessageText:
//
// The proxy server is denying access.  The username and/or password might be incorrect.%0
//
#define MF_E_NET_PROXY_ACCESSDENIED      _HRESULT_TYPEDEF_(0xC00D4286L)

//
// MessageId: MF_E_NET_CANNOTCONNECT
//
// MessageText:
//
// Unable to establish a connection to the server.%0
//
#define MF_E_NET_CANNOTCONNECT           _HRESULT_TYPEDEF_(0xC00D4287L)

//
// MessageId: MF_E_NET_INVALID_PUSH_TEMPLATE
//
// MessageText:
//
// The specified push template is invalid.%0
//
#define MF_E_NET_INVALID_PUSH_TEMPLATE   _HRESULT_TYPEDEF_(0xC00D4288L)

//
// MessageId: MF_E_NET_INVALID_PUSH_PUBLISHING_POINT
//
// MessageText:
//
// The specified push publishing point is invalid.%0
//
#define MF_E_NET_INVALID_PUSH_PUBLISHING_POINT _HRESULT_TYPEDEF_(0xC00D4289L)

//
// MessageId: MF_E_NET_BUSY
//
// MessageText:
//
// The requested resource is in use.%0
//
#define MF_E_NET_BUSY                    _HRESULT_TYPEDEF_(0xC00D428AL)

//
// MessageId: MF_E_NET_RESOURCE_GONE
//
// MessageText:
//
// The Publishing Point or file on the Windows Media Server is no longer available.%0
//
#define MF_E_NET_RESOURCE_GONE           _HRESULT_TYPEDEF_(0xC00D428BL)

//
// MessageId: MF_E_NET_ERROR_FROM_PROXY
//
// MessageText:
//
// The proxy experienced an error while attempting to contact the media server.%0
//
#define MF_E_NET_ERROR_FROM_PROXY        _HRESULT_TYPEDEF_(0xC00D428CL)

//
// MessageId: MF_E_NET_PROXY_TIMEOUT
//
// MessageText:
//
// The proxy did not receive a timely response while attempting to contact the media server.%0
//
#define MF_E_NET_PROXY_TIMEOUT           _HRESULT_TYPEDEF_(0xC00D428DL)

//
// MessageId: MF_E_NET_SERVER_UNAVAILABLE
//
// MessageText:
//
// The server is currently unable to handle the request due to a temporary overloading or maintenance of the server.%0
//
#define MF_E_NET_SERVER_UNAVAILABLE      _HRESULT_TYPEDEF_(0xC00D428EL)

//
// MessageId: MF_E_NET_TOO_MUCH_DATA
//
// MessageText:
//
// The encoding process was unable to keep up with the amount of supplied data.%0
//
#define MF_E_NET_TOO_MUCH_DATA           _HRESULT_TYPEDEF_(0xC00D428FL)

//
// MessageId: MF_E_NET_SESSION_INVALID
//
// MessageText:
//
// Session not found.%0
//
#define MF_E_NET_SESSION_INVALID         _HRESULT_TYPEDEF_(0xC00D4290L)

//
// MessageId: MF_E_OFFLINE_MODE
//
// MessageText:
//
// The requested URL is not available in offline mode.%0
//
#define MF_E_OFFLINE_MODE                _HRESULT_TYPEDEF_(0xC00D4291L)

//
// MessageId: MF_E_NET_UDP_BLOCKED
//
// MessageText:
//
// A device in the network is blocking UDP traffic.%0
//
#define MF_E_NET_UDP_BLOCKED             _HRESULT_TYPEDEF_(0xC00D4292L)

//
// MessageId: MF_E_NET_UNSUPPORTED_CONFIGURATION
//
// MessageText:
//
// The specified configuration value is not supported.%0
//
#define MF_E_NET_UNSUPPORTED_CONFIGURATION _HRESULT_TYPEDEF_(0xC00D4293L)

//
// MessageId: MF_E_NET_PROTOCOL_DISABLED
//
// MessageText:
//
// The networking protocol is disabled.%0
//
#define MF_E_NET_PROTOCOL_DISABLED       _HRESULT_TYPEDEF_(0xC00D4294L)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION WMContainer Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_ALREADY_INITIALIZED
//
// MessageText:
//
// This object has already been initialized and cannot be re-initialized at this time.%0
//
#define MF_E_ALREADY_INITIALIZED         _HRESULT_TYPEDEF_(0xC00D4650L)

//
// MessageId: MF_E_BANDWIDTH_OVERRUN
//
// MessageText:
//
// The amount of data passed in exceeds the given bitrate and buffer window.%0
//
#define MF_E_BANDWIDTH_OVERRUN           _HRESULT_TYPEDEF_(0xC00D4651L)

//
// MessageId: MF_E_LATE_SAMPLE
//
// MessageText:
//
// The sample was passed in too late to be correctly processed.%0
//
#define MF_E_LATE_SAMPLE                 _HRESULT_TYPEDEF_(0xC00D4652L)

//
// MessageId: MF_E_FLUSH_NEEDED
//
// MessageText:
//
// The requested action cannot be carried out until the object is flushed and the queue is emptied.%0
//
#define MF_E_FLUSH_NEEDED                _HRESULT_TYPEDEF_(0xC00D4653L)

//
// MessageId: MF_E_INVALID_PROFILE
//
// MessageText:
//
// The profile is invalid.%0
//
#define MF_E_INVALID_PROFILE             _HRESULT_TYPEDEF_(0xC00D4654L)

//
// MessageId: MF_E_INDEX_NOT_COMMITTED
//
// MessageText:
//
// The index that is being generated needs to be committed before the requested action can be carried out.%0
//
#define MF_E_INDEX_NOT_COMMITTED         _HRESULT_TYPEDEF_(0xC00D4655L)

//
// MessageId: MF_E_NO_INDEX
//
// MessageText:
//
// The index that is necessary for the requested action is not found.%0
//
#define MF_E_NO_INDEX                    _HRESULT_TYPEDEF_(0xC00D4656L)

//
// MessageId: MF_E_CANNOT_INDEX_IN_PLACE
//
// MessageText:
//
// The requested index cannot be added in-place to the specified ASF content.%0
//
#define MF_E_CANNOT_INDEX_IN_PLACE       _HRESULT_TYPEDEF_(0xC00D4657L)

//
// MessageId: MF_E_MISSING_ASF_LEAKYBUCKET
//
// MessageText:
//
// The ASF leaky bucket parameters must be specified in order to carry out this request.%0
//
#define MF_E_MISSING_ASF_LEAKYBUCKET     _HRESULT_TYPEDEF_(0xC00D4658L)

//
// MessageId: MF_E_INVALID_ASF_STREAMID
//
// MessageText:
//
// The stream id is invalid. The valid range for ASF stream id is from 1 to 127.%0
//
#define MF_E_INVALID_ASF_STREAMID        _HRESULT_TYPEDEF_(0xC00D4659L)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Media Sink Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_STREAMSINK_REMOVED
//
// MessageText:
//
// The requested Stream Sink has been removed and cannot be used.%0
//
#define MF_E_STREAMSINK_REMOVED          _HRESULT_TYPEDEF_(0xC00D4A38L)

//
// MessageId: MF_E_STREAMSINKS_OUT_OF_SYNC
//
// MessageText:
//
// The various Stream Sinks in this Media Sink are too far out of sync for the requested action to take place.%0
//
#define MF_E_STREAMSINKS_OUT_OF_SYNC     _HRESULT_TYPEDEF_(0xC00D4A3AL)

//
// MessageId: MF_E_STREAMSINKS_FIXED
//
// MessageText:
//
// Stream Sinks cannot be added to or removed from this Media Sink because its set of streams is fixed.%0
//
#define MF_E_STREAMSINKS_FIXED           _HRESULT_TYPEDEF_(0xC00D4A3BL)

//
// MessageId: MF_E_STREAMSINK_EXISTS
//
// MessageText:
//
// The given Stream Sink already exists.%0
//
#define MF_E_STREAMSINK_EXISTS           _HRESULT_TYPEDEF_(0xC00D4A3CL)

//
// MessageId: MF_E_SAMPLEALLOCATOR_CANCELED
//
// MessageText:
//
// Sample allocations have been canceled.%0
//
#define MF_E_SAMPLEALLOCATOR_CANCELED    _HRESULT_TYPEDEF_(0xC00D4A3DL)

//
// MessageId: MF_E_SAMPLEALLOCATOR_EMPTY
//
// MessageText:
//
// The sample allocator is currently empty, due to outstanding requests.%0
//
#define MF_E_SAMPLEALLOCATOR_EMPTY       _HRESULT_TYPEDEF_(0xC00D4A3EL)

//
// MessageId: MF_E_SINK_ALREADYSTOPPED
//
// MessageText:
//
// When we try to sopt a stream sink, it is already stopped %0
//
#define MF_E_SINK_ALREADYSTOPPED         _HRESULT_TYPEDEF_(0xC00D4A3FL)

//
// MessageId: MF_E_ASF_FILESINK_BITRATE_UNKNOWN
//
// MessageText:
//
// The ASF file sink could not reserve AVIO because the bitrate is unknown.%0
//
#define MF_E_ASF_FILESINK_BITRATE_UNKNOWN _HRESULT_TYPEDEF_(0xC00D4A40L)

//
// MessageId: MF_E_SINK_NO_STREAMS
//
// MessageText:
//
// No streams are selected in sink presentation descriptor.%0
//
#define MF_E_SINK_NO_STREAMS             _HRESULT_TYPEDEF_(0xC00D4A41L)

//
// MessageId: MF_S_SINK_NOT_FINALIZED
//
// MessageText:
//
// The sink has not been finalized before shut down. This may cause sink generate a corrupted content.%0
//
#define MF_S_SINK_NOT_FINALIZED          _HRESULT_TYPEDEF_(0x000D4A42L)

//
// MessageId: MF_E_METADATA_TOO_LONG
//
// MessageText:
//
// A metadata item was too long to write to the output container.%0
//
#define MF_E_METADATA_TOO_LONG           _HRESULT_TYPEDEF_(0xC00D4A43L)

//
// MessageId: MF_E_SINK_NO_SAMPLES_PROCESSED
//
// MessageText:
//
// The operation failed because no samples were processed by the sink.%0
//
#define MF_E_SINK_NO_SAMPLES_PROCESSED   _HRESULT_TYPEDEF_(0xC00D4A44L)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Renderer Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_VIDEO_REN_NO_PROCAMP_HW
//
// MessageText:
//
// There is no available procamp hardware with which to perform color correction.%0
//
#define MF_E_VIDEO_REN_NO_PROCAMP_HW     _HRESULT_TYPEDEF_(0xC00D4E20L)

//
// MessageId: MF_E_VIDEO_REN_NO_DEINTERLACE_HW
//
// MessageText:
//
// There is no available deinterlacing hardware with which to deinterlace the video stream.%0
//
#define MF_E_VIDEO_REN_NO_DEINTERLACE_HW _HRESULT_TYPEDEF_(0xC00D4E21L)

//
// MessageId: MF_E_VIDEO_REN_COPYPROT_FAILED
//
// MessageText:
//
// A video stream requires copy protection to be enabled, but there was a failure in attempting to enable copy protection.%0
//
#define MF_E_VIDEO_REN_COPYPROT_FAILED   _HRESULT_TYPEDEF_(0xC00D4E22L)

//
// MessageId: MF_E_VIDEO_REN_SURFACE_NOT_SHARED
//
// MessageText:
//
// A component is attempting to access a surface for sharing that is not shared.%0
//
#define MF_E_VIDEO_REN_SURFACE_NOT_SHARED _HRESULT_TYPEDEF_(0xC00D4E23L)

//
// MessageId: MF_E_VIDEO_DEVICE_LOCKED
//
// MessageText:
//
// A component is attempting to access a shared device that is already locked by another component.%0
//
#define MF_E_VIDEO_DEVICE_LOCKED         _HRESULT_TYPEDEF_(0xC00D4E24L)

//
// MessageId: MF_E_NEW_VIDEO_DEVICE
//
// MessageText:
//
// The device is no longer available. The handle should be closed and a new one opened.%0
//
#define MF_E_NEW_VIDEO_DEVICE            _HRESULT_TYPEDEF_(0xC00D4E25L)

//
// MessageId: MF_E_NO_VIDEO_SAMPLE_AVAILABLE
//
// MessageText:
//
// A video sample is not currently queued on a stream that is required for mixing.%0
//
#define MF_E_NO_VIDEO_SAMPLE_AVAILABLE   _HRESULT_TYPEDEF_(0xC00D4E26L)

//
// MessageId: MF_E_NO_AUDIO_PLAYBACK_DEVICE
//
// MessageText:
//
// No audio playback device was found.%0
//
#define MF_E_NO_AUDIO_PLAYBACK_DEVICE    _HRESULT_TYPEDEF_(0xC00D4E84L)

//
// MessageId: MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE
//
// MessageText:
//
// The requested audio playback device is currently in use.%0
//
#define MF_E_AUDIO_PLAYBACK_DEVICE_IN_USE _HRESULT_TYPEDEF_(0xC00D4E85L)

//
// MessageId: MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED
//
// MessageText:
//
// The audio playback device is no longer present.%0
//
#define MF_E_AUDIO_PLAYBACK_DEVICE_INVALIDATED _HRESULT_TYPEDEF_(0xC00D4E86L)

//
// MessageId: MF_E_AUDIO_SERVICE_NOT_RUNNING
//
// MessageText:
//
// The audio service is not running.%0
//
#define MF_E_AUDIO_SERVICE_NOT_RUNNING   _HRESULT_TYPEDEF_(0xC00D4E87L)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Topology Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_TOPO_INVALID_OPTIONAL_NODE
//
// MessageText:
//
// The topology contains an invalid optional node.  Possible reasons are incorrect number of outputs and inputs or optional node is at the beginning or end of a segment. %0
//
#define MF_E_TOPO_INVALID_OPTIONAL_NODE  _HRESULT_TYPEDEF_(0xC00D520EL)

//
// MessageId: MF_E_TOPO_CANNOT_FIND_DECRYPTOR
//
// MessageText:
//
// No suitable transform was found to decrypt the content. %0
//
#define MF_E_TOPO_CANNOT_FIND_DECRYPTOR  _HRESULT_TYPEDEF_(0xC00D5211L)

//
// MessageId: MF_E_TOPO_CODEC_NOT_FOUND
//
// MessageText:
//
// No suitable transform was found to encode or decode the content. %0
//
#define MF_E_TOPO_CODEC_NOT_FOUND        _HRESULT_TYPEDEF_(0xC00D5212L)

//
// MessageId: MF_E_TOPO_CANNOT_CONNECT
//
// MessageText:
//
// Unable to find a way to connect nodes%0
//
#define MF_E_TOPO_CANNOT_CONNECT         _HRESULT_TYPEDEF_(0xC00D5213L)

//
// MessageId: MF_E_TOPO_UNSUPPORTED
//
// MessageText:
//
// Unsupported operations in topoloader%0
//
#define MF_E_TOPO_UNSUPPORTED            _HRESULT_TYPEDEF_(0xC00D5214L)

//
// MessageId: MF_E_TOPO_INVALID_TIME_ATTRIBUTES
//
// MessageText:
//
// The topology or its nodes contain incorrectly set time attributes%0
//
#define MF_E_TOPO_INVALID_TIME_ATTRIBUTES _HRESULT_TYPEDEF_(0xC00D5215L)

//
// MessageId: MF_E_TOPO_LOOPS_IN_TOPOLOGY
//
// MessageText:
//
// The topology contains loops, which are unsupported in media foundation topologies%0
//
#define MF_E_TOPO_LOOPS_IN_TOPOLOGY      _HRESULT_TYPEDEF_(0xC00D5216L)

//
// MessageId: MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR
//
// MessageText:
//
// A source stream node in the topology does not have a presentation descriptor%0
//
#define MF_E_TOPO_MISSING_PRESENTATION_DESCRIPTOR _HRESULT_TYPEDEF_(0xC00D5217L)

//
// MessageId: MF_E_TOPO_MISSING_STREAM_DESCRIPTOR
//
// MessageText:
//
// A source stream node in the topology does not have a stream descriptor%0
//
#define MF_E_TOPO_MISSING_STREAM_DESCRIPTOR _HRESULT_TYPEDEF_(0xC00D5218L)

//
// MessageId: MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED
//
// MessageText:
//
// A stream descriptor was set on a source stream node but it was not selected on the presentation descriptor%0
//
#define MF_E_TOPO_STREAM_DESCRIPTOR_NOT_SELECTED _HRESULT_TYPEDEF_(0xC00D5219L)

//
// MessageId: MF_E_TOPO_MISSING_SOURCE
//
// MessageText:
//
// A source stream node in the topology does not have a source%0
//
#define MF_E_TOPO_MISSING_SOURCE         _HRESULT_TYPEDEF_(0xC00D521AL)

//
// MessageId: MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED
//
// MessageText:
//
// The topology loader does not support sink activates on output nodes.%0
//
#define MF_E_TOPO_SINK_ACTIVATES_UNSUPPORTED _HRESULT_TYPEDEF_(0xC00D521BL)


/////////////////////////////////////////////////////////////////////////
//
// MEDIAFOUNDATION Timeline Error Events
//
/////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID
//
// MessageText:
//
// The sequencer cannot find a segment with the given ID.%0\n.
//
#define MF_E_SEQUENCER_UNKNOWN_SEGMENT_ID _HRESULT_TYPEDEF_(0xC00D61ACL)

//
// MessageId: MF_S_SEQUENCER_CONTEXT_CANCELED
//
// MessageText:
//
// The context was canceled.%0\n.
//
#define MF_S_SEQUENCER_CONTEXT_CANCELED  _HRESULT_TYPEDEF_(0x000D61ADL)

//
// MessageId: MF_E_NO_SOURCE_IN_CACHE
//
// MessageText:
//
// Cannot find source in source cache.%0\n.
//
#define MF_E_NO_SOURCE_IN_CACHE          _HRESULT_TYPEDEF_(0xC00D61AEL)

//
// MessageId: MF_S_SEQUENCER_SEGMENT_AT_END_OF_STREAM
//
// MessageText:
//
// Cannot update topology flags.%0\n.
//
#define MF_S_SEQUENCER_SEGMENT_AT_END_OF_STREAM _HRESULT_TYPEDEF_(0x000D61AFL)


//////////////////////////////////////////////////////////////////////////////
//
// Transform errors
//
//////////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_TRANSFORM_TYPE_NOT_SET
//
// MessageText:
//
// A valid type has not been set for this stream or a stream that it depends on.%0
//
#define MF_E_TRANSFORM_TYPE_NOT_SET      _HRESULT_TYPEDEF_(0xC00D6D60L)

//
// MessageId: MF_E_TRANSFORM_STREAM_CHANGE
//
// MessageText:
//
// A stream change has occurred. Output cannot be produced until the streams have been renegotiated.%0
//
#define MF_E_TRANSFORM_STREAM_CHANGE     _HRESULT_TYPEDEF_(0xC00D6D61L)

//
// MessageId: MF_E_TRANSFORM_INPUT_REMAINING
//
// MessageText:
//
// The transform cannot take the requested action until all of the input data it currently holds is processed or flushed.%0
//
#define MF_E_TRANSFORM_INPUT_REMAINING   _HRESULT_TYPEDEF_(0xC00D6D62L)

//
// MessageId: MF_E_TRANSFORM_PROFILE_MISSING
//
// MessageText:
//
// The transform requires a profile but no profile was supplied or found.%0
//
#define MF_E_TRANSFORM_PROFILE_MISSING   _HRESULT_TYPEDEF_(0xC00D6D63L)

//
// MessageId: MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT
//
// MessageText:
//
// The transform requires a profile but the supplied profile was invalid or corrupt.%0
//
#define MF_E_TRANSFORM_PROFILE_INVALID_OR_CORRUPT _HRESULT_TYPEDEF_(0xC00D6D64L)

//
// MessageId: MF_E_TRANSFORM_PROFILE_TRUNCATED
//
// MessageText:
//
// The transform requires a profile but the supplied profile ended unexpectedly while parsing.%0
//
#define MF_E_TRANSFORM_PROFILE_TRUNCATED _HRESULT_TYPEDEF_(0xC00D6D65L)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED
//
// MessageText:
//
// The property ID does not match any property supported by the transform.%0
//
#define MF_E_TRANSFORM_PROPERTY_PID_NOT_RECOGNIZED _HRESULT_TYPEDEF_(0xC00D6D66L)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG
//
// MessageText:
//
// The variant does not have the type expected for this property ID.%0
//
#define MF_E_TRANSFORM_PROPERTY_VARIANT_TYPE_WRONG _HRESULT_TYPEDEF_(0xC00D6D67L)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE
//
// MessageText:
//
// An attempt was made to set the value on a read-only property.%0
//
#define MF_E_TRANSFORM_PROPERTY_NOT_WRITEABLE _HRESULT_TYPEDEF_(0xC00D6D68L)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM
//
// MessageText:
//
// The array property value has an unexpected number of dimensions.%0
//
#define MF_E_TRANSFORM_PROPERTY_ARRAY_VALUE_WRONG_NUM_DIM _HRESULT_TYPEDEF_(0xC00D6D69L)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG
//
// MessageText:
//
// The array or blob property value has an unexpected size.%0
//
#define MF_E_TRANSFORM_PROPERTY_VALUE_SIZE_WRONG _HRESULT_TYPEDEF_(0xC00D6D6AL)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE
//
// MessageText:
//
// The property value is out of range for this transform.%0
//
#define MF_E_TRANSFORM_PROPERTY_VALUE_OUT_OF_RANGE _HRESULT_TYPEDEF_(0xC00D6D6BL)

//
// MessageId: MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE
//
// MessageText:
//
// The property value is incompatible with some other property or mediatype set on the transform.%0
//
#define MF_E_TRANSFORM_PROPERTY_VALUE_INCOMPATIBLE _HRESULT_TYPEDEF_(0xC00D6D6CL)

//
// MessageId: MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE
//
// MessageText:
//
// The requested operation is not supported for the currently set output mediatype.%0
//
#define MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_OUTPUT_MEDIATYPE _HRESULT_TYPEDEF_(0xC00D6D6DL)

//
// MessageId: MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE
//
// MessageText:
//
// The requested operation is not supported for the currently set input mediatype.%0
//
#define MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_INPUT_MEDIATYPE _HRESULT_TYPEDEF_(0xC00D6D6EL)

//
// MessageId: MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION
//
// MessageText:
//
// The requested operation is not supported for the currently set combination of mediatypes.%0
//
#define MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_MEDIATYPE_COMBINATION _HRESULT_TYPEDEF_(0xC00D6D6FL)

//
// MessageId: MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES
//
// MessageText:
//
// The requested feature is not supported in combination with some other currently enabled feature.%0
//
#define MF_E_TRANSFORM_CONFLICTS_WITH_OTHER_CURRENTLY_ENABLED_FEATURES _HRESULT_TYPEDEF_(0xC00D6D70L)

//
// MessageId: MF_E_TRANSFORM_NEED_MORE_INPUT
//
// MessageText:
//
// The transform cannot produce output until it gets more input samples.%0
//
#define MF_E_TRANSFORM_NEED_MORE_INPUT   _HRESULT_TYPEDEF_(0xC00D6D72L)

//
// MessageId: MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG
//
// MessageText:
//
// The requested operation is not supported for the current speaker configuration.%0
//
#define MF_E_TRANSFORM_NOT_POSSIBLE_FOR_CURRENT_SPKR_CONFIG _HRESULT_TYPEDEF_(0xC00D6D73L)

//
// MessageId: MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING
//
// MessageText:
//
// The transform cannot accept mediatype changes in the middle of processing.%0
//
#define MF_E_TRANSFORM_CANNOT_CHANGE_MEDIATYPE_WHILE_PROCESSING _HRESULT_TYPEDEF_(0xC00D6D74L)

//
// MessageId: MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT
//
// MessageText:
//
// The caller should not propagate this event to downstream components.%0
//
#define MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT _HRESULT_TYPEDEF_(0x000D6D75L)

//
// MessageId: MF_E_UNSUPPORTED_D3D_TYPE
//
// MessageText:
//
// The input type is not supported for D3D device.%0
//
#define MF_E_UNSUPPORTED_D3D_TYPE        _HRESULT_TYPEDEF_(0xC00D6D76L)

//
// MessageId: MF_E_TRANSFORM_ASYNC_LOCKED
//
// MessageText:
//
// The caller does not appear to support this transform's asynchronous capabilities.%0
//
#define MF_E_TRANSFORM_ASYNC_LOCKED      _HRESULT_TYPEDEF_(0xC00D6D77L)

//
// MessageId: MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER
//
// MessageText:
//
// An audio compression manager driver could not be initialized by the transform.%0
//
#define MF_E_TRANSFORM_CANNOT_INITIALIZE_ACM_DRIVER _HRESULT_TYPEDEF_(0xC00D6D78L)


//////////////////////////////////////////////////////////////////////////////
//
// Content Protection errors
//
//////////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_LICENSE_INCORRECT_RIGHTS
//
// MessageText:
//
// You are not allowed to open this file. Contact the content provider for further assistance.%0
//
#define MF_E_LICENSE_INCORRECT_RIGHTS    _HRESULT_TYPEDEF_(0xC00D7148L)

//
// MessageId: MF_E_LICENSE_OUTOFDATE
//
// MessageText:
//
// The license for this media file has expired. Get a new license or contact the content provider for further assistance.%0
//
#define MF_E_LICENSE_OUTOFDATE           _HRESULT_TYPEDEF_(0xC00D7149L)

//
// MessageId: MF_E_LICENSE_REQUIRED
//
// MessageText:
//
// You need a license to perform the requested operation on this media file.%0
//
#define MF_E_LICENSE_REQUIRED            _HRESULT_TYPEDEF_(0xC00D714AL)

//
// MessageId: MF_E_DRM_HARDWARE_INCONSISTENT
//
// MessageText:
//
// The licenses for your media files are corrupted. Contact Microsoft product support.%0
//
#define MF_E_DRM_HARDWARE_INCONSISTENT   _HRESULT_TYPEDEF_(0xC00D714BL)

//
// MessageId: MF_E_NO_CONTENT_PROTECTION_MANAGER
//
// MessageText:
//
// The APP needs to provide IMFContentProtectionManager callback to access the protected media file.%0
//
#define MF_E_NO_CONTENT_PROTECTION_MANAGER _HRESULT_TYPEDEF_(0xC00D714CL)

//
// MessageId: MF_E_LICENSE_RESTORE_NO_RIGHTS
//
// MessageText:
//
// Client does not have rights to restore licenses.%0
//
#define MF_E_LICENSE_RESTORE_NO_RIGHTS   _HRESULT_TYPEDEF_(0xC00D714DL)

//
// MessageId: MF_E_BACKUP_RESTRICTED_LICENSE
//
// MessageText:
//
// Licenses are restricted and hence can not be backed up.%0
//
#define MF_E_BACKUP_RESTRICTED_LICENSE   _HRESULT_TYPEDEF_(0xC00D714EL)

//
// MessageId: MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION
//
// MessageText:
//
// License restore requires machine to be individualized.%0
//
#define MF_E_LICENSE_RESTORE_NEEDS_INDIVIDUALIZATION _HRESULT_TYPEDEF_(0xC00D714FL)

//
// MessageId: MF_S_PROTECTION_NOT_REQUIRED
//
// MessageText:
//
// Protection for stream is not required.%0
//
#define MF_S_PROTECTION_NOT_REQUIRED     _HRESULT_TYPEDEF_(0x000D7150L)

//
// MessageId: MF_E_COMPONENT_REVOKED
//
// MessageText:
//
// Component is revoked.%0
//
#define MF_E_COMPONENT_REVOKED           _HRESULT_TYPEDEF_(0xC00D7151L)

//
// MessageId: MF_E_TRUST_DISABLED
//
// MessageText:
//
// Trusted functionality is currently disabled on this component.%0
//
#define MF_E_TRUST_DISABLED              _HRESULT_TYPEDEF_(0xC00D7152L)

//
// MessageId: MF_E_WMDRMOTA_NO_ACTION
//
// MessageText:
//
// No Action is set on WMDRM Output Trust Authority.%0
//
#define MF_E_WMDRMOTA_NO_ACTION          _HRESULT_TYPEDEF_(0xC00D7153L)

//
// MessageId: MF_E_WMDRMOTA_ACTION_ALREADY_SET
//
// MessageText:
//
// Action is already set on WMDRM Output Trust Authority.%0
//
#define MF_E_WMDRMOTA_ACTION_ALREADY_SET _HRESULT_TYPEDEF_(0xC00D7154L)

//
// MessageId: MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE
//
// MessageText:
//
// DRM Heaader is not available.%0
//
#define MF_E_WMDRMOTA_DRM_HEADER_NOT_AVAILABLE _HRESULT_TYPEDEF_(0xC00D7155L)

//
// MessageId: MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED
//
// MessageText:
//
// Current encryption scheme is not supported.%0
//
#define MF_E_WMDRMOTA_DRM_ENCRYPTION_SCHEME_NOT_SUPPORTED _HRESULT_TYPEDEF_(0xC00D7156L)

//
// MessageId: MF_E_WMDRMOTA_ACTION_MISMATCH
//
// MessageText:
//
// Action does not match with current configuration.%0
//
#define MF_E_WMDRMOTA_ACTION_MISMATCH    _HRESULT_TYPEDEF_(0xC00D7157L)

//
// MessageId: MF_E_WMDRMOTA_INVALID_POLICY
//
// MessageText:
//
// Invalid policy for WMDRM Output Trust Authority.%0
//
#define MF_E_WMDRMOTA_INVALID_POLICY     _HRESULT_TYPEDEF_(0xC00D7158L)

//
// MessageId: MF_E_POLICY_UNSUPPORTED
//
// MessageText:
//
// The policies that the Input Trust Authority requires to be enforced are unsupported by the outputs.%0
//
#define MF_E_POLICY_UNSUPPORTED          _HRESULT_TYPEDEF_(0xC00D7159L)

//
// MessageId: MF_E_OPL_NOT_SUPPORTED
//
// MessageText:
//
// The OPL that the license requires to be enforced are not supported by the Input Trust Authority.%0
//
#define MF_E_OPL_NOT_SUPPORTED           _HRESULT_TYPEDEF_(0xC00D715AL)

//
// MessageId: MF_E_TOPOLOGY_VERIFICATION_FAILED
//
// MessageText:
//
// The topology could not be successfully verified.%0
//
#define MF_E_TOPOLOGY_VERIFICATION_FAILED _HRESULT_TYPEDEF_(0xC00D715BL)

//
// MessageId: MF_E_SIGNATURE_VERIFICATION_FAILED
//
// MessageText:
//
// Signature verification could not be completed successfully for this component.%0
//
#define MF_E_SIGNATURE_VERIFICATION_FAILED _HRESULT_TYPEDEF_(0xC00D715CL)

//
// MessageId: MF_E_DEBUGGING_NOT_ALLOWED
//
// MessageText:
//
// Running this process under a debugger while using protected content is not allowed.%0
//
#define MF_E_DEBUGGING_NOT_ALLOWED       _HRESULT_TYPEDEF_(0xC00D715DL)

//
// MessageId: MF_E_CODE_EXPIRED
//
// MessageText:
//
// MF component has expired.%0
//
#define MF_E_CODE_EXPIRED                _HRESULT_TYPEDEF_(0xC00D715EL)

//
// MessageId: MF_E_GRL_VERSION_TOO_LOW
//
// MessageText:
//
// The current GRL on the machine does not meet the minimum version requirements.%0
//
#define MF_E_GRL_VERSION_TOO_LOW         _HRESULT_TYPEDEF_(0xC00D715FL)

//
// MessageId: MF_E_GRL_RENEWAL_NOT_FOUND
//
// MessageText:
//
// The current GRL on the machine does not contain any renewal entries for the specified revocation.%0
//
#define MF_E_GRL_RENEWAL_NOT_FOUND       _HRESULT_TYPEDEF_(0xC00D7160L)

//
// MessageId: MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND
//
// MessageText:
//
// The current GRL on the machine does not contain any extensible entries for the specified extension GUID.%0
//
#define MF_E_GRL_EXTENSIBLE_ENTRY_NOT_FOUND _HRESULT_TYPEDEF_(0xC00D7161L)

//
// MessageId: MF_E_KERNEL_UNTRUSTED
//
// MessageText:
//
// The kernel isn't secure for high security level content.%0
//
#define MF_E_KERNEL_UNTRUSTED            _HRESULT_TYPEDEF_(0xC00D7162L)

//
// MessageId: MF_E_PEAUTH_UNTRUSTED
//
// MessageText:
//
// The response from protected environment driver isn't valid.%0
//
#define MF_E_PEAUTH_UNTRUSTED            _HRESULT_TYPEDEF_(0xC00D7163L)

//
// MessageId: MF_E_NON_PE_PROCESS
//
// MessageText:
//
// A non-PE process tried to talk to PEAuth.%0
//
#define MF_E_NON_PE_PROCESS              _HRESULT_TYPEDEF_(0xC00D7165L)

//
// MessageId: MF_E_REBOOT_REQUIRED
//
// MessageText:
//
// We need to reboot the machine.%0
//
#define MF_E_REBOOT_REQUIRED             _HRESULT_TYPEDEF_(0xC00D7167L)

//
// MessageId: MF_S_WAIT_FOR_POLICY_SET
//
// MessageText:
//
// Protection for this stream is not guaranteed to be enforced until the MEPolicySet event is fired.%0
//
#define MF_S_WAIT_FOR_POLICY_SET         _HRESULT_TYPEDEF_(0x000D7168L)

//
// MessageId: MF_S_VIDEO_DISABLED_WITH_UNKNOWN_SOFTWARE_OUTPUT
//
// MessageText:
//
// This video stream is disabled because it is being sent to an unknown software output.%0
//
#define MF_S_VIDEO_DISABLED_WITH_UNKNOWN_SOFTWARE_OUTPUT _HRESULT_TYPEDEF_(0x000D7169L)

//
// MessageId: MF_E_GRL_INVALID_FORMAT
//
// MessageText:
//
// The GRL file is not correctly formed, it may have been corrupted or overwritten.%0
//
#define MF_E_GRL_INVALID_FORMAT          _HRESULT_TYPEDEF_(0xC00D716AL)

//
// MessageId: MF_E_GRL_UNRECOGNIZED_FORMAT
//
// MessageText:
//
// The GRL file is in a format newer than those recognized by this GRL Reader.%0
//
#define MF_E_GRL_UNRECOGNIZED_FORMAT     _HRESULT_TYPEDEF_(0xC00D716BL)

//
// MessageId: MF_E_ALL_PROCESS_RESTART_REQUIRED
//
// MessageText:
//
// The GRL was reloaded and required all processes that can run protected media to restart.%0
//
#define MF_E_ALL_PROCESS_RESTART_REQUIRED _HRESULT_TYPEDEF_(0xC00D716CL)

//
// MessageId: MF_E_PROCESS_RESTART_REQUIRED
//
// MessageText:
//
// The GRL was reloaded and the current process needs to restart.%0
//
#define MF_E_PROCESS_RESTART_REQUIRED    _HRESULT_TYPEDEF_(0xC00D716DL)

//
// MessageId: MF_E_USERMODE_UNTRUSTED
//
// MessageText:
//
// The user space is untrusted for protected content play.%0
//
#define MF_E_USERMODE_UNTRUSTED          _HRESULT_TYPEDEF_(0xC00D716EL)

//
// MessageId: MF_E_PEAUTH_SESSION_NOT_STARTED
//
// MessageText:
//
// PEAuth communication session hasn't been started.%0
//
#define MF_E_PEAUTH_SESSION_NOT_STARTED  _HRESULT_TYPEDEF_(0xC00D716FL)

//
// MessageId: MF_E_PEAUTH_PUBLICKEY_REVOKED
//
// MessageText:
//
// PEAuth's public key is revoked.%0
//
#define MF_E_PEAUTH_PUBLICKEY_REVOKED    _HRESULT_TYPEDEF_(0xC00D7171L)

//
// MessageId: MF_E_GRL_ABSENT
//
// MessageText:
//
// The GRL is absent.%0
//
#define MF_E_GRL_ABSENT                  _HRESULT_TYPEDEF_(0xC00D7172L)

//
// MessageId: MF_S_PE_TRUSTED
//
// MessageText:
//
// The Protected Environment is trusted.%0
//
#define MF_S_PE_TRUSTED                  _HRESULT_TYPEDEF_(0x000D7173L)

//
// MessageId: MF_E_PE_UNTRUSTED
//
// MessageText:
//
// The Protected Environment is untrusted.%0
//
#define MF_E_PE_UNTRUSTED                _HRESULT_TYPEDEF_(0xC00D7174L)

//
// MessageId: MF_E_PEAUTH_NOT_STARTED
//
// MessageText:
//
// The Protected Environment Authorization service (PEAUTH) has not been started.%0
//
#define MF_E_PEAUTH_NOT_STARTED          _HRESULT_TYPEDEF_(0xC00D7175L)

//
// MessageId: MF_E_INCOMPATIBLE_SAMPLE_PROTECTION
//
// MessageText:
//
// The sample protection algorithms supported by components are not compatible.%0
//
#define MF_E_INCOMPATIBLE_SAMPLE_PROTECTION _HRESULT_TYPEDEF_(0xC00D7176L)

//
// MessageId: MF_E_PE_SESSIONS_MAXED
//
// MessageText:
//
// No more protected environment sessions can be supported.%0
//
#define MF_E_PE_SESSIONS_MAXED           _HRESULT_TYPEDEF_(0xC00D7177L)

//
// MessageId: MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED
//
// MessageText:
//
// WMDRM ITA does not allow protected content with high security level for this release.%0
//
#define MF_E_HIGH_SECURITY_LEVEL_CONTENT_NOT_ALLOWED _HRESULT_TYPEDEF_(0xC00D7178L)

//
// MessageId: MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED
//
// MessageText:
//
// WMDRM ITA cannot allow the requested action for the content as one or more components is not properly signed.%0
//
#define MF_E_TEST_SIGNED_COMPONENTS_NOT_ALLOWED _HRESULT_TYPEDEF_(0xC00D7179L)

//
// MessageId: MF_E_ITA_UNSUPPORTED_ACTION
//
// MessageText:
//
// WMDRM ITA does not support the requested action.%0
//
#define MF_E_ITA_UNSUPPORTED_ACTION      _HRESULT_TYPEDEF_(0xC00D717AL)

//
// MessageId: MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS
//
// MessageText:
//
// WMDRM ITA encountered an error in parsing the Secure Audio Path parameters.%0
//
#define MF_E_ITA_ERROR_PARSING_SAP_PARAMETERS _HRESULT_TYPEDEF_(0xC00D717BL)

//
// MessageId: MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS
//
// MessageText:
//
// The Policy Manager action passed in is invalid.%0
//
#define MF_E_POLICY_MGR_ACTION_OUTOFBOUNDS _HRESULT_TYPEDEF_(0xC00D717CL)

//
// MessageId: MF_E_BAD_OPL_STRUCTURE_FORMAT
//
// MessageText:
//
// The structure specifying Output Protection Level is not the correct format.%0
//
#define MF_E_BAD_OPL_STRUCTURE_FORMAT    _HRESULT_TYPEDEF_(0xC00D717DL)

//
// MessageId: MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID
//
// MessageText:
//
// WMDRM ITA does not recognize the Explicite Analog Video Output Protection guid specified in the license.%0
//
#define MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_PROTECTION_GUID _HRESULT_TYPEDEF_(0xC00D717EL)

//
// MessageId: MF_E_NO_PMP_HOST
//
// MessageText:
//
// IMFPMPHost object not available.%0
//
#define MF_E_NO_PMP_HOST                 _HRESULT_TYPEDEF_(0xC00D717FL)

//
// MessageId: MF_E_ITA_OPL_DATA_NOT_INITIALIZED
//
// MessageText:
//
// WMDRM ITA could not initialize the Output Protection Level data.%0
//
#define MF_E_ITA_OPL_DATA_NOT_INITIALIZED _HRESULT_TYPEDEF_(0xC00D7180L)

//
// MessageId: MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT
//
// MessageText:
//
// WMDRM ITA does not recognize the Analog Video Output specified by the OTA.%0
//
#define MF_E_ITA_UNRECOGNIZED_ANALOG_VIDEO_OUTPUT _HRESULT_TYPEDEF_(0xC00D7181L)

//
// MessageId: MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT
//
// MessageText:
//
// WMDRM ITA does not recognize the Digital Video Output specified by the OTA.%0
//
#define MF_E_ITA_UNRECOGNIZED_DIGITAL_VIDEO_OUTPUT _HRESULT_TYPEDEF_(0xC00D7182L)


//////////////////////////////////////////////////////////////////////////////
//
// Clock errors
//
//////////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_CLOCK_INVALID_CONTINUITY_KEY
//
// MessageText:
//
// The continuity key supplied is not currently valid.%0
//
#define MF_E_CLOCK_INVALID_CONTINUITY_KEY _HRESULT_TYPEDEF_(0xC00D9C40L)

//
// MessageId: MF_E_CLOCK_NO_TIME_SOURCE
//
// MessageText:
//
// No Presentation Time Source has been specified.%0
//
#define MF_E_CLOCK_NO_TIME_SOURCE        _HRESULT_TYPEDEF_(0xC00D9C41L)

//
// MessageId: MF_E_CLOCK_STATE_ALREADY_SET
//
// MessageText:
//
// The clock is already in the requested state.%0
//
#define MF_E_CLOCK_STATE_ALREADY_SET     _HRESULT_TYPEDEF_(0xC00D9C42L)

//
// MessageId: MF_E_CLOCK_NOT_SIMPLE
//
// MessageText:
//
// The clock has too many advanced features to carry out the request.%0
//
#define MF_E_CLOCK_NOT_SIMPLE            _HRESULT_TYPEDEF_(0xC00D9C43L)

//
// MessageId: MF_S_CLOCK_STOPPED
//
// MessageText:
//
// Timer::SetTimer returns this success code if called happened while timer is stopped. Timer is not going to be dispatched until clock is running%0
//
#define MF_S_CLOCK_STOPPED               _HRESULT_TYPEDEF_(0x000D9C44L)


//////////////////////////////////////////////////////////////////////////////
//
// MF Quality Management errors
//
//////////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_NO_MORE_DROP_MODES
//
// MessageText:
//
// The component does not support any more drop modes.%0
//
#define MF_E_NO_MORE_DROP_MODES          _HRESULT_TYPEDEF_(0xC00DA028L)

//
// MessageId: MF_E_NO_MORE_QUALITY_LEVELS
//
// MessageText:
//
// The component does not support any more quality levels.%0
//
#define MF_E_NO_MORE_QUALITY_LEVELS      _HRESULT_TYPEDEF_(0xC00DA029L)

//
// MessageId: MF_E_DROPTIME_NOT_SUPPORTED
//
// MessageText:
//
// The component does not support drop time functionality.%0
//
#define MF_E_DROPTIME_NOT_SUPPORTED      _HRESULT_TYPEDEF_(0xC00DA02AL)

//
// MessageId: MF_E_QUALITYKNOB_WAIT_LONGER
//
// MessageText:
//
// Quality Manager needs to wait longer before bumping the Quality Level up.%0
//
#define MF_E_QUALITYKNOB_WAIT_LONGER     _HRESULT_TYPEDEF_(0xC00DA02BL)

//
// MessageId: MF_E_QM_INVALIDSTATE
//
// MessageText:
//
// Quality Manager is in an invalid state. Quality Management is off at this moment.%0
//
#define MF_E_QM_INVALIDSTATE             _HRESULT_TYPEDEF_(0xC00DA02CL)


//////////////////////////////////////////////////////////////////////////////
//
// MF Transcode errors
//
//////////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_TRANSCODE_NO_CONTAINERTYPE
//
// MessageText:
//
// No transcode output container type is specified.%0
//
#define MF_E_TRANSCODE_NO_CONTAINERTYPE  _HRESULT_TYPEDEF_(0xC00DA410L)

//
// MessageId: MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS
//
// MessageText:
//
// The profile does not have a media type configuration for any selected source streams.%0
//
#define MF_E_TRANSCODE_PROFILE_NO_MATCHING_STREAMS _HRESULT_TYPEDEF_(0xC00DA411L)

//
// MessageId: MF_E_TRANSCODE_NO_MATCHING_ENCODER
//
// MessageText:
//
// Cannot find an encoder MFT that accepts the user preferred output type.%0
//
#define MF_E_TRANSCODE_NO_MATCHING_ENCODER _HRESULT_TYPEDEF_(0xC00DA412L)


//////////////////////////////////////////////////////////////////////////////
//
// MF HW Device Proxy errors
//
//////////////////////////////////////////////////////////////////////////////

//
// MessageId: MF_E_ALLOCATOR_NOT_INITIALIZED
//
// MessageText:
//
// Memory allocator is not initialized.%0
//
#define MF_E_ALLOCATOR_NOT_INITIALIZED   _HRESULT_TYPEDEF_(0xC00DA7F8L)

//
// MessageId: MF_E_ALLOCATOR_NOT_COMMITED
//
// MessageText:
//
// Memory allocator is not committed yet.%0
//
#define MF_E_ALLOCATOR_NOT_COMMITED      _HRESULT_TYPEDEF_(0xC00DA7F9L)

//
// MessageId: MF_E_ALLOCATOR_ALREADY_COMMITED
//
// MessageText:
//
// Memory allocator has already been committed.%0
//
#define MF_E_ALLOCATOR_ALREADY_COMMITED  _HRESULT_TYPEDEF_(0xC00DA7FAL)

//
// MessageId: MF_E_STREAM_ERROR
//
// MessageText:
//
// An error occurred in media stream.%0
//
#define MF_E_STREAM_ERROR                _HRESULT_TYPEDEF_(0xC00DA7FBL)

//
// MessageId: MF_E_INVALID_STREAM_STATE
//
// MessageText:
//
// Stream is not in a state to handle the request.%0
//
#define MF_E_INVALID_STREAM_STATE        _HRESULT_TYPEDEF_(0xC00DA7FCL)

//
// MessageId: MF_E_HW_STREAM_NOT_CONNECTED
//
// MessageText:
//
// Hardware stream is not connected yet.%0
//
#define MF_E_HW_STREAM_NOT_CONNECTED     _HRESULT_TYPEDEF_(0xC00DA7FDL)

#endif // _MFERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\sdk\vs10rtm\SDK\include\mfidl.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 7.00.0555 */
/* Compiler settings for mfidl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run), target_arch=X86 7.00.0555 
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
/* @@MIDL_FILE_HEADING(  ) */

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 500
#endif

/* verify that the <rpcsal.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCSAL_H_VERSION__
#define __REQUIRED_RPCSAL_H_VERSION__ 100
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mfidl_h__
#define __mfidl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IMFMediaSession_FWD_DEFINED__
#define __IMFMediaSession_FWD_DEFINED__
typedef interface IMFMediaSession IMFMediaSession;
#endif 	/* __IMFMediaSession_FWD_DEFINED__ */


#ifndef __IMFSourceResolver_FWD_DEFINED__
#define __IMFSourceResolver_FWD_DEFINED__
typedef interface IMFSourceResolver IMFSourceResolver;
#endif 	/* __IMFSourceResolver_FWD_DEFINED__ */


#ifndef __IMFMediaSource_FWD_DEFINED__
#define __IMFMediaSource_FWD_DEFINED__
typedef interface IMFMediaSource IMFMediaSource;
#endif 	/* __IMFMediaSource_FWD_DEFINED__ */


#ifndef __IMFMediaStream_FWD_DEFINED__
#define __IMFMediaStream_FWD_DEFINED__
typedef interface IMFMediaStream IMFMediaStream;
#endif 	/* __IMFMediaStream_FWD_DEFINED__ */


#ifndef __IMFMediaSink_FWD_DEFINED__
#define __IMFMediaSink_FWD_DEFINED__
typedef interface IMFMediaSink IMFMediaSink;
#endif 	/* __IMFMediaSink_FWD_DEFINED__ */


#ifndef __IMFStreamSink_FWD_DEFINED__
#define __IMFStreamSink_FWD_DEFINED__
typedef interface IMFStreamSink IMFStreamSink;
#endif 	/* __IMFStreamSink_FWD_DEFINED__ */


#ifndef __IMFVideoSampleAllocator_FWD_DEFINED__
#define __IMFVideoSampleAllocator_FWD_DEFINED__
typedef interface IMFVideoSampleAllocator IMFVideoSampleAllocator;
#endif 	/* __IMFVideoSampleAllocator_FWD_DEFINED__ */


#ifndef __IMFVideoSampleAllocatorNotify_FWD_DEFINED__
#define __IMFVideoSampleAllocatorNotify_FWD_DEFINED__
typedef interface IMFVideoSampleAllocatorNotify IMFVideoSampleAllocatorNotify;
#endif 	/* __IMFVideoSampleAllocatorNotify_FWD_DEFINED__ */


#ifndef __IMFVideoSampleAllocatorCallback_FWD_DEFINED__
#define __IMFVideoSampleAllocatorCallback_FWD_DEFINED__
typedef interface IMFVideoSampleAllocatorCallback IMFVideoSampleAllocatorCallback;
#endif 	/* __IMFVideoSampleAllocatorCallback_FWD_DEFINED__ */


#ifndef __IMFTopology_FWD_DEFINED__
#define __IMFTopology_FWD_DEFINED__
typedef interface IMFTopology IMFTopology;
#endif 	/* __IMFTopology_FWD_DEFINED__ */


#ifndef __IMFTopologyNode_FWD_DEFINED__
#define __IMFTopologyNode_FWD_DEFINED__
typedef interface IMFTopologyNode IMFTopologyNode;
#endif 	/* __IMFTopologyNode_FWD_DEFINED__ */


#ifndef __IMFGetService_FWD_DEFINED__
#define __IMFGetService_FWD_DEFINED__
typedef interface IMFGetService IMFGetService;
#endif 	/* __IMFGetService_FWD_DEFINED__ */


#ifndef __IMFClock_FWD_DEFINED__
#define __IMFClock_FWD_DEFINED__
typedef interface IMFClock IMFClock;
#endif 	/* __IMFClock_FWD_DEFINED__ */


#ifndef __IMFPresentationClock_FWD_DEFINED__
#define __IMFPresentationClock_FWD_DEFINED__
typedef interface IMFPresentationClock IMFPresentationClock;
#endif 	/* __IMFPresentationClock_FWD_DEFINED__ */


#ifndef __IMFPresentationTimeSource_FWD_DEFINED__
#define __IMFPresentationTimeSource_FWD_DEFINED__
typedef interface IMFPresentationTimeSource IMFPresentationTimeSource;
#endif 	/* __IMFPresentationTimeSource_FWD_DEFINED__ */


#ifndef __IMFClockStateSink_FWD_DEFINED__
#define __IMFClockStateSink_FWD_DEFINED__
typedef interface IMFClockStateSink IMFClockStateSink;
#endif 	/* __IMFClockStateSink_FWD_DEFINED__ */


#ifndef __IMFPresentationDescriptor_FWD_DEFINED__
#define __IMFPresentationDescriptor_FWD_DEFINED__
typedef interface IMFPresentationDescriptor IMFPresentationDescriptor;
#endif 	/* __IMFPresentationDescriptor_FWD_DEFINED__ */


#ifndef __IMFStreamDescriptor_FWD_DEFINED__
#define __IMFStreamDescriptor_FWD_DEFINED__
typedef interface IMFStreamDescriptor IMFStreamDescriptor;
#endif 	/* __IMFStreamDescriptor_FWD_DEFINED__ */


#ifndef __IMFMediaTypeHandler_FWD_DEFINED__
#define __IMFMediaTypeHandler_FWD_DEFINED__
typedef interface IMFMediaTypeHandler IMFMediaTypeHandler;
#endif 	/* __IMFMediaTypeHandler_FWD_DEFINED__ */


#ifndef __IMFTimer_FWD_DEFINED__
#define __IMFTimer_FWD_DEFINED__
typedef interface IMFTimer IMFTimer;
#endif 	/* __IMFTimer_FWD_DEFINED__ */


#ifndef __IMFShutdown_FWD_DEFINED__
#define __IMFShutdown_FWD_DEFINED__
typedef interface IMFShutdown IMFShutdown;
#endif 	/* __IMFShutdown_FWD_DEFINED__ */


#ifndef __IMFTopoLoader_FWD_DEFINED__
#define __IMFTopoLoader_FWD_DEFINED__
typedef interface IMFTopoLoader IMFTopoLoader;
#endif 	/* __IMFTopoLoader_FWD_DEFINED__ */


#ifndef __IMFContentProtectionManager_FWD_DEFINED__
#define __IMFContentProtectionManager_FWD_DEFINED__
typedef interface IMFContentProtectionManager IMFContentProtectionManager;
#endif 	/* __IMFContentProtectionManager_FWD_DEFINED__ */


#ifndef __IMFContentEnabler_FWD_DEFINED__
#define __IMFContentEnabler_FWD_DEFINED__
typedef interface IMFContentEnabler IMFContentEnabler;
#endif 	/* __IMFContentEnabler_FWD_DEFINED__ */


#ifndef __IMFMetadata_FWD_DEFINED__
#define __IMFMetadata_FWD_DEFINED__
typedef interface IMFMetadata IMFMetadata;
#endif 	/* __IMFMetadata_FWD_DEFINED__ */


#ifndef __IMFMetadataProvider_FWD_DEFINED__
#define __IMFMetadataProvider_FWD_DEFINED__
typedef interface IMFMetadataProvider IMFMetadataProvider;
#endif 	/* __IMFMetadataProvider_FWD_DEFINED__ */


#ifndef __IMFRateSupport_FWD_DEFINED__
#define __IMFRateSupport_FWD_DEFINED__
typedef interface IMFRateSupport IMFRateSupport;
#endif 	/* __IMFRateSupport_FWD_DEFINED__ */


#ifndef __IMFRateControl_FWD_DEFINED__
#define __IMFRateControl_FWD_DEFINED__
typedef interface IMFRateControl IMFRateControl;
#endif 	/* __IMFRateControl_FWD_DEFINED__ */


#ifndef __IMFTimecodeTranslate_FWD_DEFINED__
#define __IMFTimecodeTranslate_FWD_DEFINED__
typedef interface IMFTimecodeTranslate IMFTimecodeTranslate;
#endif 	/* __IMFTimecodeTranslate_FWD_DEFINED__ */


#ifndef __IMFSimpleAudioVolume_FWD_DEFINED__
#define __IMFSimpleAudioVolume_FWD_DEFINED__
typedef interface IMFSimpleAudioVolume IMFSimpleAudioVolume;
#endif 	/* __IMFSimpleAudioVolume_FWD_DEFINED__ */


#ifndef __IMFAudioStreamVolume_FWD_DEFINED__
#define __IMFAudioStreamVolume_FWD_DEFINED__
typedef interface IMFAudioStreamVolume IMFAudioStreamVolume;
#endif 	/* __IMFAudioStreamVolume_FWD_DEFINED__ */


#ifndef __IMFAudioPolicy_FWD_DEFINED__
#define __IMFAudioPolicy_FWD_DEFINED__
typedef interface IMFAudioPolicy IMFAudioPolicy;
#endif 	/* __IMFAudioPolicy_FWD_DEFINED__ */


#ifndef __IMFSampleGrabberSinkCallback_FWD_DEFINED__
#define __IMFSampleGrabberSinkCallback_FWD_DEFINED__
typedef interface IMFSampleGrabberSinkCallback IMFSampleGrabberSinkCallback;
#endif 	/* __IMFSampleGrabberSinkCallback_FWD_DEFINED__ */


#ifndef __IMFSampleGrabberSinkCallback2_FWD_DEFINED__
#define __IMFSampleGrabberSinkCallback2_FWD_DEFINED__
typedef interface IMFSampleGrabberSinkCallback2 IMFSampleGrabberSinkCallback2;
#endif 	/* __IMFSampleGrabberSinkCallback2_FWD_DEFINED__ */


#ifndef __IMFWorkQueueServices_FWD_DEFINED__
#define __IMFWorkQueueServices_FWD_DEFINED__
typedef interface IMFWorkQueueServices IMFWorkQueueServices;
#endif 	/* __IMFWorkQueueServices_FWD_DEFINED__ */


#ifndef __IMFQualityManager_FWD_DEFINED__
#define __IMFQualityManager_FWD_DEFINED__
typedef interface IMFQualityManager IMFQualityManager;
#endif 	/* __IMFQualityManager_FWD_DEFINED__ */


#ifndef __IMFQualityAdvise_FWD_DEFINED__
#define __IMFQualityAdvise_FWD_DEFINED__
typedef interface IMFQualityAdvise IMFQualityAdvise;
#endif 	/* __IMFQualityAdvise_FWD_DEFINED__ */


#ifndef __IMFQualityAdvise2_FWD_DEFINED__
#define __IMFQualityAdvise2_FWD_DEFINED__
typedef interface IMFQualityAdvise2 IMFQualityAdvise2;
#endif 	/* __IMFQualityAdvise2_FWD_DEFINED__ */


#ifndef __IMFQualityAdviseLimits_FWD_DEFINED__
#define __IMFQualityAdviseLimits_FWD_DEFINED__
typedef interface IMFQualityAdviseLimits IMFQualityAdviseLimits;
#endif 	/* __IMFQualityAdviseLimits_FWD_DEFINED__ */


#ifndef __IMFRealTimeClient_FWD_DEFINED__
#define __IMFRealTimeClient_FWD_DEFINED__
typedef interface IMFRealTimeClient IMFRealTimeClient;
#endif 	/* __IMFRealTimeClient_FWD_DEFINED__ */


#ifndef __IMFSequencerSource_FWD_DEFINED__
#define __IMFSequencerSource_FWD_DEFINED__
typedef interface IMFSequencerSource IMFSequencerSource;
#endif 	/* __IMFSequencerSource_FWD_DEFINED__ */


#ifndef __IMFMediaSourceTopologyProvider_FWD_DEFINED__
#define __IMFMediaSourceTopologyProvider_FWD_DEFINED__
typedef interface IMFMediaSourceTopologyProvider IMFMediaSourceTopologyProvider;
#endif 	/* __IMFMediaSourceTopologyProvider_FWD_DEFINED__ */


#ifndef __IMFMediaSourcePresentationProvider_FWD_DEFINED__
#define __IMFMediaSourcePresentationProvider_FWD_DEFINED__
typedef interface IMFMediaSourcePresentationProvider IMFMediaSourcePresentationProvider;
#endif 	/* __IMFMediaSourcePresentationProvider_FWD_DEFINED__ */


#ifndef __IMFTopologyNodeAttributeEditor_FWD_DEFINED__
#define __IMFTopologyNodeAttributeEditor_FWD_DEFINED__
typedef interface IMFTopologyNodeAttributeEditor IMFTopologyNodeAttributeEditor;
#endif 	/* __IMFTopologyNodeAttributeEditor_FWD_DEFINED__ */


#ifndef __IMFByteStreamBuffering_FWD_DEFINED__
#define __IMFByteStreamBuffering_FWD_DEFINED__
typedef interface IMFByteStreamBuffering IMFByteStreamBuffering;
#endif 	/* __IMFByteStreamBuffering_FWD_DEFINED__ */


#ifndef __IMFByteStreamCacheControl_FWD_DEFINED__
#define __IMFByteStreamCacheControl_FWD_DEFINED__
typedef interface IMFByteStreamCacheControl IMFByteStreamCacheControl;
#endif 	/* __IMFByteStreamCacheControl_FWD_DEFINED__ */


#ifndef __IMFNetCredential_FWD_DEFINED__
#define __IMFNetCredential_FWD_DEFINED__
typedef interface IMFNetCredential IMFNetCredential;
#endif 	/* __IMFNetCredential_FWD_DEFINED__ */


#ifndef __IMFNetCredentialManager_FWD_DEFINED__
#define __IMFNetCredentialManager_FWD_DEFINED__
typedef interface IMFNetCredentialManager IMFNetCredentialManager;
#endif 	/* __IMFNetCredentialManager_FWD_DEFINED__ */


#ifndef __IMFNetCredentialCache_FWD_DEFINED__
#define __IMFNetCredentialCache_FWD_DEFINED__
typedef interface IMFNetCredentialCache IMFNetCredentialCache;
#endif 	/* __IMFNetCredentialCache_FWD_DEFINED__ */


#ifndef __IMFSSLCertificateManager_FWD_DEFINED__
#define __IMFSSLCertificateManager_FWD_DEFINED__
typedef interface IMFSSLCertificateManager IMFSSLCertificateManager;
#endif 	/* __IMFSSLCertificateManager_FWD_DEFINED__ */


#ifndef __IMFSourceOpenMonitor_FWD_DEFINED__
#define __IMFSourceOpenMonitor_FWD_DEFINED__
typedef interface IMFSourceOpenMonitor IMFSourceOpenMonitor;
#endif 	/* __IMFSourceOpenMonitor_FWD_DEFINED__ */


#ifndef __IMFNetProxyLocator_FWD_DEFINED__
#define __IMFNetProxyLocator_FWD_DEFINED__
typedef interface IMFNetProxyLocator IMFNetProxyLocator;
#endif 	/* __IMFNetProxyLocator_FWD_DEFINED__ */


#ifndef __IMFNetProxyLocatorFactory_FWD_DEFINED__
#define __IMFNetProxyLocatorFactory_FWD_DEFINED__
typedef interface IMFNetProxyLocatorFactory IMFNetProxyLocatorFactory;
#endif 	/* __IMFNetProxyLocatorFactory_FWD_DEFINED__ */


#ifndef __IMFSaveJob_FWD_DEFINED__
#define __IMFSaveJob_FWD_DEFINED__
typedef interface IMFSaveJob IMFSaveJob;
#endif 	/* __IMFSaveJob_FWD_DEFINED__ */


#ifndef __IMFNetSchemeHandlerConfig_FWD_DEFINED__
#define __IMFNetSchemeHandlerConfig_FWD_DEFINED__
typedef interface IMFNetSchemeHandlerConfig IMFNetSchemeHandlerConfig;
#endif 	/* __IMFNetSchemeHandlerConfig_FWD_DEFINED__ */


#ifndef __IMFSchemeHandler_FWD_DEFINED__
#define __IMFSchemeHandler_FWD_DEFINED__
typedef interface IMFSchemeHandler IMFSchemeHandler;
#endif 	/* __IMFSchemeHandler_FWD_DEFINED__ */


#ifndef __IMFByteStreamHandler_FWD_DEFINED__
#define __IMFByteStreamHandler_FWD_DEFINED__
typedef interface IMFByteStreamHandler IMFByteStreamHandler;
#endif 	/* __IMFByteStreamHandler_FWD_DEFINED__ */


#ifndef __IMFTrustedInput_FWD_DEFINED__
#define __IMFTrustedInput_FWD_DEFINED__
typedef interface IMFTrustedInput IMFTrustedInput;
#endif 	/* __IMFTrustedInput_FWD_DEFINED__ */


#ifndef __IMFInputTrustAuthority_FWD_DEFINED__
#define __IMFInputTrustAuthority_FWD_DEFINED__
typedef interface IMFInputTrustAuthority IMFInputTrustAuthority;
#endif 	/* __IMFInputTrustAuthority_FWD_DEFINED__ */


#ifndef __IMFTrustedOutput_FWD_DEFINED__
#define __IMFTrustedOutput_FWD_DEFINED__
typedef interface IMFTrustedOutput IMFTrustedOutput;
#endif 	/* __IMFTrustedOutput_FWD_DEFINED__ */


#ifndef __IMFOutputTrustAuthority_FWD_DEFINED__
#define __IMFOutputTrustAuthority_FWD_DEFINED__
typedef interface IMFOutputTrustAuthority IMFOutputTrustAuthority;
#endif 	/* __IMFOutputTrustAuthority_FWD_DEFINED__ */


#ifndef __IMFOutputPolicy_FWD_DEFINED__
#define __IMFOutputPolicy_FWD_DEFINED__
typedef interface IMFOutputPolicy IMFOutputPolicy;
#endif 	/* __IMFOutputPolicy_FWD_DEFINED__ */


#ifndef __IMFOutputSchema_FWD_DEFINED__
#define __IMFOutputSchema_FWD_DEFINED__
typedef interface IMFOutputSchema IMFOutputSchema;
#endif 	/* __IMFOutputSchema_FWD_DEFINED__ */


#ifndef __IMFSecureChannel_FWD_DEFINED__
#define __IMFSecureChannel_FWD_DEFINED__
typedef interface IMFSecureChannel IMFSecureChannel;
#endif 	/* __IMFSecureChannel_FWD_DEFINED__ */


#ifndef __IMFSampleProtection_FWD_DEFINED__
#define __IMFSampleProtection_FWD_DEFINED__
typedef interface IMFSampleProtection IMFSampleProtection;
#endif 	/* __IMFSampleProtection_FWD_DEFINED__ */


#ifndef __IMFMediaSinkPreroll_FWD_DEFINED__
#define __IMFMediaSinkPreroll_FWD_DEFINED__
typedef interface IMFMediaSinkPreroll IMFMediaSinkPreroll;
#endif 	/* __IMFMediaSinkPreroll_FWD_DEFINED__ */


#ifndef __IMFFinalizableMediaSink_FWD_DEFINED__
#define __IMFFinalizableMediaSink_FWD_DEFINED__
typedef interface IMFFinalizableMediaSink IMFFinalizableMediaSink;
#endif 	/* __IMFFinalizableMediaSink_FWD_DEFINED__ */


#ifndef __IMFStreamingSinkConfig_FWD_DEFINED__
#define __IMFStreamingSinkConfig_FWD_DEFINED__
typedef interface IMFStreamingSinkConfig IMFStreamingSinkConfig;
#endif 	/* __IMFStreamingSinkConfig_FWD_DEFINED__ */


#ifndef __IMFRemoteProxy_FWD_DEFINED__
#define __IMFRemoteProxy_FWD_DEFINED__
typedef interface IMFRemoteProxy IMFRemoteProxy;
#endif 	/* __IMFRemoteProxy_FWD_DEFINED__ */


#ifndef __IMFObjectReferenceStream_FWD_DEFINED__
#define __IMFObjectReferenceStream_FWD_DEFINED__
typedef interface IMFObjectReferenceStream IMFObjectReferenceStream;
#endif 	/* __IMFObjectReferenceStream_FWD_DEFINED__ */


#ifndef __IMFPMPHost_FWD_DEFINED__
#define __IMFPMPHost_FWD_DEFINED__
typedef interface IMFPMPHost IMFPMPHost;
#endif 	/* __IMFPMPHost_FWD_DEFINED__ */


#ifndef __IMFPMPClient_FWD_DEFINED__
#define __IMFPMPClient_FWD_DEFINED__
typedef interface IMFPMPClient IMFPMPClient;
#endif 	/* __IMFPMPClient_FWD_DEFINED__ */


#ifndef __IMFPMPServer_FWD_DEFINED__
#define __IMFPMPServer_FWD_DEFINED__
typedef interface IMFPMPServer IMFPMPServer;
#endif 	/* __IMFPMPServer_FWD_DEFINED__ */


#ifndef __IMFRemoteDesktopPlugin_FWD_DEFINED__
#define __IMFRemoteDesktopPlugin_FWD_DEFINED__
typedef interface IMFRemoteDesktopPlugin IMFRemoteDesktopPlugin;
#endif 	/* __IMFRemoteDesktopPlugin_FWD_DEFINED__ */


#ifndef __IMFSAMIStyle_FWD_DEFINED__
#define __IMFSAMIStyle_FWD_DEFINED__
typedef interface IMFSAMIStyle IMFSAMIStyle;
#endif 	/* __IMFSAMIStyle_FWD_DEFINED__ */


#ifndef __IMFTranscodeProfile_FWD_DEFINED__
#define __IMFTranscodeProfile_FWD_DEFINED__
typedef interface IMFTranscodeProfile IMFTranscodeProfile;
#endif 	/* __IMFTranscodeProfile_FWD_DEFINED__ */


#ifndef __IMFTranscodeSinkInfoProvider_FWD_DEFINED__
#define __IMFTranscodeSinkInfoProvider_FWD_DEFINED__
typedef interface IMFTranscodeSinkInfoProvider IMFTranscodeSinkInfoProvider;
#endif 	/* __IMFTranscodeSinkInfoProvider_FWD_DEFINED__ */


#ifndef __IMFFieldOfUseMFTUnlock_FWD_DEFINED__
#define __IMFFieldOfUseMFTUnlock_FWD_DEFINED__
typedef interface IMFFieldOfUseMFTUnlock IMFFieldOfUseMFTUnlock;
#endif 	/* __IMFFieldOfUseMFTUnlock_FWD_DEFINED__ */


#ifndef __IMFLocalMFTRegistration_FWD_DEFINED__
#define __IMFLocalMFTRegistration_FWD_DEFINED__
typedef interface IMFLocalMFTRegistration IMFLocalMFTRegistration;
#endif 	/* __IMFLocalMFTRegistration_FWD_DEFINED__ */


/* header files for imported files */
#include "mfobjects.h"
#include "mftransform.h"

#ifdef __cplusplus
extern "C"{
#endif 


/* interface __MIDL_itf_mfidl_0000_0000 */
/* [local] */ 

#include <windef.h>
typedef 
enum MFSESSION_SETTOPOLOGY_FLAGS
    {	MFSESSION_SETTOPOLOGY_IMMEDIATE	= 0x1,
	MFSESSION_SETTOPOLOGY_NORESOLUTION	= 0x2,
	MFSESSION_SETTOPOLOGY_CLEAR_CURRENT	= 0x4
    } 	MFSESSION_SETTOPOLOGY_FLAGS;

typedef 
enum MFSESSION_GETFULLTOPOLOGY_FLAGS
    {	MFSESSION_GETFULLTOPOLOGY_CURRENT	= 0x1
    } 	MFSESSION_GETFULLTOPOLOGY_FLAGS;

typedef 
enum MFPMPSESSION_CREATION_FLAGS
    {	MFPMPSESSION_UNPROTECTED_PROCESS	= 0x1
    } 	MFPMPSESSION_CREATION_FLAGS;

typedef unsigned __int64 TOPOID;






extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0000_v0_0_s_ifspec;

#ifndef __IMFMediaSession_INTERFACE_DEFINED__
#define __IMFMediaSession_INTERFACE_DEFINED__

/* interface IMFMediaSession */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFMediaSession;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("90377834-21D0-4dee-8214-BA2E3E6C1127")
    IMFMediaSession : public IMFMediaEventGenerator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetTopology( 
            /* [in] */ DWORD dwSetTopologyFlags,
            /* [in] */ __RPC__in_opt IMFTopology *pTopology) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearTopologies( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [unique][in] */ __RPC__in_opt const GUID *pguidTimeFormat,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarStartPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClock( 
            /* [out] */ __RPC__deref_out_opt IMFClock **ppClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSessionCapabilities( 
            /* [out] */ __RPC__out DWORD *pdwCaps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFullTopology( 
            /* [in] */ DWORD dwGetFullTopologyFlags,
            /* [in] */ TOPOID TopoId,
            /* [out] */ __RPC__deref_out_opt IMFTopology **ppFullTopology) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaSessionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMFMediaSession * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMFMediaSession * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMFMediaSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            __RPC__in IMFMediaSession * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IMFMediaEvent **ppEvent);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginGetEvent )( 
            IMFMediaSession * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndGetEvent )( 
            IMFMediaSession * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFMediaEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *QueueEvent )( 
            __RPC__in IMFMediaSession * This,
            /* [in] */ MediaEventType met,
            /* [in] */ __RPC__in REFGUID guidExtendedType,
            /* [in] */ HRESULT hrStatus,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetTopology )( 
            __RPC__in IMFMediaSession * This,
            /* [in] */ DWORD dwSetTopologyFlags,
            /* [in] */ __RPC__in_opt IMFTopology *pTopology);
        
        HRESULT ( STDMETHODCALLTYPE *ClearTopologies )( 
            __RPC__in IMFMediaSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            __RPC__in IMFMediaSession * This,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidTimeFormat,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarStartPosition);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            __RPC__in IMFMediaSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            __RPC__in IMFMediaSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            __RPC__in IMFMediaSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            __RPC__in IMFMediaSession * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClock )( 
            __RPC__in IMFMediaSession * This,
            /* [out] */ __RPC__deref_out_opt IMFClock **ppClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetSessionCapabilities )( 
            __RPC__in IMFMediaSession * This,
            /* [out] */ __RPC__out DWORD *pdwCaps);
        
        HRESULT ( STDMETHODCALLTYPE *GetFullTopology )( 
            __RPC__in IMFMediaSession * This,
            /* [in] */ DWORD dwGetFullTopologyFlags,
            /* [in] */ TOPOID TopoId,
            /* [out] */ __RPC__deref_out_opt IMFTopology **ppFullTopology);
        
        END_INTERFACE
    } IMFMediaSessionVtbl;

    interface IMFMediaSession
    {
        CONST_VTBL struct IMFMediaSessionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaSession_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaSession_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaSession_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaSession_GetEvent(This,dwFlags,ppEvent)	\
    ( (This)->lpVtbl -> GetEvent(This,dwFlags,ppEvent) ) 

#define IMFMediaSession_BeginGetEvent(This,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginGetEvent(This,pCallback,punkState) ) 

#define IMFMediaSession_EndGetEvent(This,pResult,ppEvent)	\
    ( (This)->lpVtbl -> EndGetEvent(This,pResult,ppEvent) ) 

#define IMFMediaSession_QueueEvent(This,met,guidExtendedType,hrStatus,pvValue)	\
    ( (This)->lpVtbl -> QueueEvent(This,met,guidExtendedType,hrStatus,pvValue) ) 


#define IMFMediaSession_SetTopology(This,dwSetTopologyFlags,pTopology)	\
    ( (This)->lpVtbl -> SetTopology(This,dwSetTopologyFlags,pTopology) ) 

#define IMFMediaSession_ClearTopologies(This)	\
    ( (This)->lpVtbl -> ClearTopologies(This) ) 

#define IMFMediaSession_Start(This,pguidTimeFormat,pvarStartPosition)	\
    ( (This)->lpVtbl -> Start(This,pguidTimeFormat,pvarStartPosition) ) 

#define IMFMediaSession_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMFMediaSession_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMFMediaSession_Close(This)	\
    ( (This)->lpVtbl -> Close(This) ) 

#define IMFMediaSession_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#define IMFMediaSession_GetClock(This,ppClock)	\
    ( (This)->lpVtbl -> GetClock(This,ppClock) ) 

#define IMFMediaSession_GetSessionCapabilities(This,pdwCaps)	\
    ( (This)->lpVtbl -> GetSessionCapabilities(This,pdwCaps) ) 

#define IMFMediaSession_GetFullTopology(This,dwGetFullTopologyFlags,TopoId,ppFullTopology)	\
    ( (This)->lpVtbl -> GetFullTopology(This,dwGetFullTopologyFlags,TopoId,ppFullTopology) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFMediaSession_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0001 */
/* [local] */ 

EXTERN_GUID( MF_SESSION_TOPOLOADER, 0x1e83d482, 0x1f1c, 0x4571, 0x84, 0x5, 0x88, 0xf4, 0xb2, 0x18, 0x1f, 0x71);
EXTERN_GUID( MF_SESSION_GLOBAL_TIME, 0x1e83d482, 0x1f1c, 0x4571, 0x84, 0x5, 0x88, 0xf4, 0xb2, 0x18, 0x1f, 0x72);
EXTERN_GUID( MF_SESSION_QUALITY_MANAGER, 0x1e83d482, 0x1f1c, 0x4571, 0x84, 0x5, 0x88, 0xf4, 0xb2, 0x18, 0x1f, 0x73);
EXTERN_GUID( MF_SESSION_CONTENT_PROTECTION_MANAGER, 0x1e83d482, 0x1f1c, 0x4571, 0x84, 0x5, 0x88, 0xf4, 0xb2, 0x18, 0x1f, 0x74);
EXTERN_GUID( MF_SESSION_SERVER_CONTEXT, 0xafe5b291, 0x50fa, 0x46e8, 0xb9, 0xbe, 0xc, 0xc, 0x3c, 0xe4, 0xb3, 0xa5);
EXTERN_GUID( MF_SESSION_REMOTE_SOURCE_MODE, 0xf4033ef4, 0x9bb3, 0x4378, 0x94, 0x1f, 0x85, 0xa0, 0x85, 0x6b, 0xc2, 0x44);
EXTERN_GUID( MF_SESSION_APPROX_EVENT_OCCURRENCE_TIME, 0x190e852f, 0x6238, 0x42d1, 0xb5, 0xaf, 0x69, 0xea, 0x33, 0x8e, 0xf8, 0x50);
EXTERN_GUID( MF_PMP_SERVER_CONTEXT, 0x2f00c910, 0xd2cf, 0x4278, 0x8b, 0x6a, 0xd0, 0x77, 0xfa, 0xc3, 0xa2, 0x5f);
STDAPI MFCreateMediaSession(
    IMFAttributes* pConfiguration,
    __out IMFMediaSession** ppMediaSession
    );
STDAPI MFCreatePMPMediaSession(
    DWORD dwCreationFlags,
    IMFAttributes *pConfiguration,
    __out IMFMediaSession** ppMediaSession,
    __out_opt IMFActivate **ppEnablerActivate
    );
typedef 
enum MF_OBJECT_TYPE
    {	MF_OBJECT_MEDIASOURCE	= 0,
	MF_OBJECT_BYTESTREAM	= ( MF_OBJECT_MEDIASOURCE + 1 ) ,
	MF_OBJECT_INVALID	= ( MF_OBJECT_BYTESTREAM + 1 ) 
    } 	MF_OBJECT_TYPE;


enum __MIDL___MIDL_itf_mfidl_0000_0001_0001
    {	MF_RESOLUTION_MEDIASOURCE	= 0x1,
	MF_RESOLUTION_BYTESTREAM	= 0x2,
	MF_RESOLUTION_CONTENT_DOES_NOT_HAVE_TO_MATCH_EXTENSION_OR_MIME_TYPE	= 0x10,
	MF_RESOLUTION_KEEP_BYTE_STREAM_ALIVE_ON_FAIL	= 0x20,
	MF_RESOLUTION_READ	= 0x10000,
	MF_RESOLUTION_WRITE	= 0x20000
    } ;
typedef 
enum _MF_CONNECT_METHOD
    {	MF_CONNECT_DIRECT	= 0,
	MF_CONNECT_ALLOW_CONVERTER	= 0x1,
	MF_CONNECT_ALLOW_DECODER	= 0x3,
	MF_CONNECT_RESOLVE_INDEPENDENT_OUTPUTTYPES	= 0x4,
	MF_CONNECT_AS_OPTIONAL	= 0x10000,
	MF_CONNECT_AS_OPTIONAL_BRANCH	= 0x20000
    } 	MF_CONNECT_METHOD;

typedef 
enum _MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS
    {	MF_TOPOLOGY_RESOLUTION_SUCCEEDED	= 0,
	MF_OPTIONAL_NODE_REJECTED_MEDIA_TYPE	= 0x1,
	MF_OPTIONAL_NODE_REJECTED_PROTECTED_PROCESS	= 0x2
    } 	MF_TOPOLOGY_RESOLUTION_STATUS_FLAGS;




extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0001_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0001_v0_0_s_ifspec;

#ifndef __IMFSourceResolver_INTERFACE_DEFINED__
#define __IMFSourceResolver_INTERFACE_DEFINED__

/* interface IMFSourceResolver */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFSourceResolver;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FBE5A32D-A497-4b61-BB85-97B1A848A6E3")
    IMFSourceResolver : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateObjectFromURL( 
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreateObjectFromByteStream( 
            /* [in] */ IMFByteStream *pByteStream,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE BeginCreateObjectFromURL( 
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out_opt  IUnknown **ppIUnknownCancelCookie,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EndCreateObjectFromURL( 
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE BeginCreateObjectFromByteStream( 
            /* [in] */ IMFByteStream *pByteStream,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out_opt  IUnknown **ppIUnknownCancelCookie,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EndCreateObjectFromByteStream( 
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CancelObjectCreation( 
            /* [in] */ IUnknown *pIUnknownCancelCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFSourceResolverVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMFSourceResolver * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMFSourceResolver * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMFSourceResolver * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateObjectFromURL )( 
            IMFSourceResolver * This,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreateObjectFromByteStream )( 
            IMFSourceResolver * This,
            /* [in] */ IMFByteStream *pByteStream,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginCreateObjectFromURL )( 
            IMFSourceResolver * This,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out_opt  IUnknown **ppIUnknownCancelCookie,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndCreateObjectFromURL )( 
            IMFSourceResolver * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginCreateObjectFromByteStream )( 
            IMFSourceResolver * This,
            /* [in] */ IMFByteStream *pByteStream,
            /* [in] */ LPCWSTR pwszURL,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IPropertyStore *pProps,
            /* [annotation][out] */ 
            __out_opt  IUnknown **ppIUnknownCancelCookie,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndCreateObjectFromByteStream )( 
            IMFSourceResolver * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  MF_OBJECT_TYPE *pObjectType,
            /* [annotation][out] */ 
            __out  IUnknown **ppObject);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CancelObjectCreation )( 
            IMFSourceResolver * This,
            /* [in] */ IUnknown *pIUnknownCancelCookie);
        
        END_INTERFACE
    } IMFSourceResolverVtbl;

    interface IMFSourceResolver
    {
        CONST_VTBL struct IMFSourceResolverVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFSourceResolver_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFSourceResolver_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFSourceResolver_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFSourceResolver_CreateObjectFromURL(This,pwszURL,dwFlags,pProps,pObjectType,ppObject)	\
    ( (This)->lpVtbl -> CreateObjectFromURL(This,pwszURL,dwFlags,pProps,pObjectType,ppObject) ) 

#define IMFSourceResolver_CreateObjectFromByteStream(This,pByteStream,pwszURL,dwFlags,pProps,pObjectType,ppObject)	\
    ( (This)->lpVtbl -> CreateObjectFromByteStream(This,pByteStream,pwszURL,dwFlags,pProps,pObjectType,ppObject) ) 

#define IMFSourceResolver_BeginCreateObjectFromURL(This,pwszURL,dwFlags,pProps,ppIUnknownCancelCookie,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginCreateObjectFromURL(This,pwszURL,dwFlags,pProps,ppIUnknownCancelCookie,pCallback,punkState) ) 

#define IMFSourceResolver_EndCreateObjectFromURL(This,pResult,pObjectType,ppObject)	\
    ( (This)->lpVtbl -> EndCreateObjectFromURL(This,pResult,pObjectType,ppObject) ) 

#define IMFSourceResolver_BeginCreateObjectFromByteStream(This,pByteStream,pwszURL,dwFlags,pProps,ppIUnknownCancelCookie,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginCreateObjectFromByteStream(This,pByteStream,pwszURL,dwFlags,pProps,ppIUnknownCancelCookie,pCallback,punkState) ) 

#define IMFSourceResolver_EndCreateObjectFromByteStream(This,pResult,pObjectType,ppObject)	\
    ( (This)->lpVtbl -> EndCreateObjectFromByteStream(This,pResult,pObjectType,ppObject) ) 

#define IMFSourceResolver_CancelObjectCreation(This,pIUnknownCancelCookie)	\
    ( (This)->lpVtbl -> CancelObjectCreation(This,pIUnknownCancelCookie) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFSourceResolver_RemoteBeginCreateObjectFromURL_Proxy( 
    __RPC__in IMFSourceResolver * This,
    /* [string][in] */ __RPC__in_string LPCWSTR pwszURL,
    /* [in] */ DWORD dwFlags,
    /* [in] */ __RPC__in_opt IPropertyStore *pProps,
    /* [in] */ __RPC__in_opt IMFRemoteAsyncCallback *pCallback);


void __RPC_STUB IMFSourceResolver_RemoteBeginCreateObjectFromURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFSourceResolver_RemoteEndCreateObjectFromURL_Proxy( 
    __RPC__in IMFSourceResolver * This,
    /* [in] */ __RPC__in_opt IUnknown *pResult,
    /* [out] */ __RPC__out MF_OBJECT_TYPE *pObjectType,
    /* [out] */ __RPC__deref_out_opt IUnknown **ppObject);


void __RPC_STUB IMFSourceResolver_RemoteEndCreateObjectFromURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFSourceResolver_RemoteBeginCreateObjectFromByteStream_Proxy( 
    __RPC__in IMFSourceResolver * This,
    /* [in] */ __RPC__in_opt IMFByteStream *pByteStream,
    /* [in] */ __RPC__in LPCWSTR pwszURL,
    /* [in] */ DWORD dwFlags,
    /* [in] */ __RPC__in_opt IPropertyStore *pProps,
    /* [in] */ __RPC__in_opt IMFRemoteAsyncCallback *pCallback);


void __RPC_STUB IMFSourceResolver_RemoteBeginCreateObjectFromByteStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFSourceResolver_RemoteEndCreateObjectFromByteStream_Proxy( 
    __RPC__in IMFSourceResolver * This,
    /* [in] */ __RPC__in_opt IUnknown *pResult,
    /* [out] */ __RPC__out MF_OBJECT_TYPE *pObjectType,
    /* [out] */ __RPC__deref_out_opt IUnknown **ppObject);


void __RPC_STUB IMFSourceResolver_RemoteEndCreateObjectFromByteStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMFSourceResolver_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0002 */
/* [local] */ 

STDAPI MFCreateSourceResolver( 
        /* out */     __out IMFSourceResolver     **ppISourceResolver);
STDAPI CreatePropertyStore( 
        /* out */     __out IPropertyStore        **ppStore);
STDAPI MFGetSupportedSchemes(                      
       __out PROPVARIANT* pPropVarSchemeArray  );  
STDAPI MFGetSupportedMimeTypes(                      
       __out PROPVARIANT* pPropVarMimeTypeArray  );  
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_SourceOpenMonitor = { { 0x074d4637, 0xb5ae, 0x465d, 0xaf, 0x17, 0x1a, 0x53, 0x8d, 0x28, 0x59, 0xdd}, 0x02 }; 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_ASFMediaSource_ApproxSeek = { { 0xb4cd270f, 0x244d, 0x4969, 0xbb, 0x92, 0x3f, 0x0f, 0xb8, 0x31, 0x6f, 0x10}, 0x01 }; 
#if (WINVER >= _WIN32_WINNT_WIN7) 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_ASFMediaSource_IterativeSeekIfNoIndex = { { 0x170b65dc, 0x4a4e, 0x407a, 0xac, 0x22, 0x57, 0x7f, 0x50, 0xe4, 0xa3, 0x7c }, 0x01 }; 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_ASFMediaSource_IterativeSeek_Max_Count = { { 0x170b65dc, 0x4a4e, 0x407a, 0xac, 0x22, 0x57, 0x7f, 0x50, 0xe4, 0xa3, 0x7c }, 0x02 }; 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_ASFMediaSource_IterativeSeek_Tolerance_In_MilliSecond = { { 0x170b65dc, 0x4a4e, 0x407a, 0xac, 0x22, 0x57, 0x7f, 0x50, 0xe4, 0xa3, 0x7c }, 0x03 }; 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_Content_DLNA_Profile_ID = { { 0xcfa31b45, 0x525d, 0x4998, 0xbb, 0x44, 0x3f, 0x7d, 0x81, 0x54, 0x2f, 0xa4 }, 0x01 }; 
EXTERN_C const DECLSPEC_SELECTANY PROPERTYKEY MFPKEY_MediaSource_DisableReadAhead = { { 0x26366c14, 0xc5bf, 0x4c76, 0x88, 0x7b, 0x9f, 0x17, 0x54, 0xdb, 0x5f, 0x9}, 0x01 }; 
#endif // (WINVER >= _WIN32_WINNT_WIN7) 
typedef 
enum _MFMEDIASOURCE_CHARACTERISTICS
    {	MFMEDIASOURCE_IS_LIVE	= 0x1,
	MFMEDIASOURCE_CAN_SEEK	= 0x2,
	MFMEDIASOURCE_CAN_PAUSE	= 0x4,
	MFMEDIASOURCE_HAS_SLOW_SEEK	= 0x8,
	MFMEDIASOURCE_HAS_MULTIPLE_PRESENTATIONS	= 0x10,
	MFMEDIASOURCE_CAN_SKIPFORWARD	= 0x20,
	MFMEDIASOURCE_CAN_SKIPBACKWARD	= 0x40
    } 	MFMEDIASOURCE_CHARACTERISTICS;

#if (WINVER >= _WIN32_WINNT_WIN7) 
EXTERN_GUID( MF_TIME_FORMAT_ENTRY_RELATIVE, 0x4399f178, 0x46d3, 0x4504, 0xaf, 0xda, 0x20, 0xd3, 0x2e, 0x9b, 0xa3, 0x60 );
#endif // (WINVER >= _WIN32_WINNT_WIN7) 




extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0002_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0002_v0_0_s_ifspec;

#ifndef __IMFMediaSource_INTERFACE_DEFINED__
#define __IMFMediaSource_INTERFACE_DEFINED__

/* interface IMFMediaSource */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFMediaSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("279a808d-aec7-40c8-9c6b-a6b492c78a66")
    IMFMediaSource : public IMFMediaEventGenerator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCharacteristics( 
            /* [out] */ __RPC__out DWORD *pdwCharacteristics) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE CreatePresentationDescriptor( 
            /* [annotation][out] */ 
            __out  IMFPresentationDescriptor **ppPresentationDescriptor) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( 
            /* [in] */ __RPC__in_opt IMFPresentationDescriptor *pPresentationDescriptor,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidTimeFormat,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarStartPosition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMFMediaSource * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMFMediaSource * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMFMediaSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            __RPC__in IMFMediaSource * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IMFMediaEvent **ppEvent);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginGetEvent )( 
            IMFMediaSource * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndGetEvent )( 
            IMFMediaSource * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFMediaEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *QueueEvent )( 
            __RPC__in IMFMediaSource * This,
            /* [in] */ MediaEventType met,
            /* [in] */ __RPC__in REFGUID guidExtendedType,
            /* [in] */ HRESULT hrStatus,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetCharacteristics )( 
            __RPC__in IMFMediaSource * This,
            /* [out] */ __RPC__out DWORD *pdwCharacteristics);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *CreatePresentationDescriptor )( 
            IMFMediaSource * This,
            /* [annotation][out] */ 
            __out  IMFPresentationDescriptor **ppPresentationDescriptor);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            __RPC__in IMFMediaSource * This,
            /* [in] */ __RPC__in_opt IMFPresentationDescriptor *pPresentationDescriptor,
            /* [unique][in] */ __RPC__in_opt const GUID *pguidTimeFormat,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvarStartPosition);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            __RPC__in IMFMediaSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            __RPC__in IMFMediaSource * This);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            __RPC__in IMFMediaSource * This);
        
        END_INTERFACE
    } IMFMediaSourceVtbl;

    interface IMFMediaSource
    {
        CONST_VTBL struct IMFMediaSourceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaSource_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaSource_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaSource_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaSource_GetEvent(This,dwFlags,ppEvent)	\
    ( (This)->lpVtbl -> GetEvent(This,dwFlags,ppEvent) ) 

#define IMFMediaSource_BeginGetEvent(This,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginGetEvent(This,pCallback,punkState) ) 

#define IMFMediaSource_EndGetEvent(This,pResult,ppEvent)	\
    ( (This)->lpVtbl -> EndGetEvent(This,pResult,ppEvent) ) 

#define IMFMediaSource_QueueEvent(This,met,guidExtendedType,hrStatus,pvValue)	\
    ( (This)->lpVtbl -> QueueEvent(This,met,guidExtendedType,hrStatus,pvValue) ) 


#define IMFMediaSource_GetCharacteristics(This,pdwCharacteristics)	\
    ( (This)->lpVtbl -> GetCharacteristics(This,pdwCharacteristics) ) 

#define IMFMediaSource_CreatePresentationDescriptor(This,ppPresentationDescriptor)	\
    ( (This)->lpVtbl -> CreatePresentationDescriptor(This,ppPresentationDescriptor) ) 

#define IMFMediaSource_Start(This,pPresentationDescriptor,pguidTimeFormat,pvarStartPosition)	\
    ( (This)->lpVtbl -> Start(This,pPresentationDescriptor,pguidTimeFormat,pvarStartPosition) ) 

#define IMFMediaSource_Stop(This)	\
    ( (This)->lpVtbl -> Stop(This) ) 

#define IMFMediaSource_Pause(This)	\
    ( (This)->lpVtbl -> Pause(This) ) 

#define IMFMediaSource_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFMediaSource_RemoteCreatePresentationDescriptor_Proxy( 
    __RPC__in IMFMediaSource * This,
    /* [out] */ __RPC__out DWORD *pcbPD,
    /* [size_is][size_is][out] */ __RPC__deref_out_ecount_full_opt(*pcbPD) BYTE **pbPD,
    /* [out] */ __RPC__deref_out_opt IMFPresentationDescriptor **ppRemotePD);


void __RPC_STUB IMFMediaSource_RemoteCreatePresentationDescriptor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMFMediaSource_INTERFACE_DEFINED__ */


#ifndef __IMFMediaStream_INTERFACE_DEFINED__
#define __IMFMediaStream_INTERFACE_DEFINED__

/* interface IMFMediaStream */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFMediaStream;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D182108F-4EC6-443f-AA42-A71106EC825F")
    IMFMediaStream : public IMFMediaEventGenerator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMediaSource( 
            /* [out] */ __RPC__deref_out_opt IMFMediaSource **ppMediaSource) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamDescriptor( 
            /* [out] */ __RPC__deref_out_opt IMFStreamDescriptor **ppStreamDescriptor) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE RequestSample( 
            /* [in] */ IUnknown *pToken) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaStreamVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMFMediaStream * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMFMediaStream * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMFMediaStream * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            __RPC__in IMFMediaStream * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IMFMediaEvent **ppEvent);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginGetEvent )( 
            IMFMediaStream * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndGetEvent )( 
            IMFMediaStream * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFMediaEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *QueueEvent )( 
            __RPC__in IMFMediaStream * This,
            /* [in] */ MediaEventType met,
            /* [in] */ __RPC__in REFGUID guidExtendedType,
            /* [in] */ HRESULT hrStatus,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaSource )( 
            __RPC__in IMFMediaStream * This,
            /* [out] */ __RPC__deref_out_opt IMFMediaSource **ppMediaSource);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamDescriptor )( 
            __RPC__in IMFMediaStream * This,
            /* [out] */ __RPC__deref_out_opt IMFStreamDescriptor **ppStreamDescriptor);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *RequestSample )( 
            IMFMediaStream * This,
            /* [in] */ IUnknown *pToken);
        
        END_INTERFACE
    } IMFMediaStreamVtbl;

    interface IMFMediaStream
    {
        CONST_VTBL struct IMFMediaStreamVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaStream_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaStream_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaStream_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaStream_GetEvent(This,dwFlags,ppEvent)	\
    ( (This)->lpVtbl -> GetEvent(This,dwFlags,ppEvent) ) 

#define IMFMediaStream_BeginGetEvent(This,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginGetEvent(This,pCallback,punkState) ) 

#define IMFMediaStream_EndGetEvent(This,pResult,ppEvent)	\
    ( (This)->lpVtbl -> EndGetEvent(This,pResult,ppEvent) ) 

#define IMFMediaStream_QueueEvent(This,met,guidExtendedType,hrStatus,pvValue)	\
    ( (This)->lpVtbl -> QueueEvent(This,met,guidExtendedType,hrStatus,pvValue) ) 


#define IMFMediaStream_GetMediaSource(This,ppMediaSource)	\
    ( (This)->lpVtbl -> GetMediaSource(This,ppMediaSource) ) 

#define IMFMediaStream_GetStreamDescriptor(This,ppStreamDescriptor)	\
    ( (This)->lpVtbl -> GetStreamDescriptor(This,ppStreamDescriptor) ) 

#define IMFMediaStream_RequestSample(This,pToken)	\
    ( (This)->lpVtbl -> RequestSample(This,pToken) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IMFMediaStream_RemoteRequestSample_Proxy( 
    __RPC__in IMFMediaStream * This);


void __RPC_STUB IMFMediaStream_RemoteRequestSample_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMFMediaStream_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0004 */
/* [local] */ 

#define MEDIASINK_FIXED_STREAMS         0x00000001
#define MEDIASINK_CANNOT_MATCH_CLOCK    0x00000002
#define MEDIASINK_RATELESS              0x00000004
#define MEDIASINK_CLOCK_REQUIRED        0x00000008
#define MEDIASINK_CAN_PREROLL           0x00000010
#define MEDIASINK_REQUIRE_REFERENCE_MEDIATYPE 0x00000020




extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0004_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0004_v0_0_s_ifspec;

#ifndef __IMFMediaSink_INTERFACE_DEFINED__
#define __IMFMediaSink_INTERFACE_DEFINED__

/* interface IMFMediaSink */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFMediaSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6ef2a660-47c0-4666-b13d-cbb717f2fa2c")
    IMFMediaSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCharacteristics( 
            /* [out] */ __RPC__out DWORD *pdwCharacteristics) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddStreamSink( 
            /* [in] */ DWORD dwStreamSinkIdentifier,
            /* [in] */ __RPC__in_opt IMFMediaType *pMediaType,
            /* [out] */ __RPC__deref_out_opt IMFStreamSink **ppStreamSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveStreamSink( 
            /* [in] */ DWORD dwStreamSinkIdentifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSinkCount( 
            /* [out] */ __RPC__out DWORD *pcStreamSinkCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSinkByIndex( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IMFStreamSink **ppStreamSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStreamSinkById( 
            /* [in] */ DWORD dwStreamSinkIdentifier,
            /* [out] */ __RPC__deref_out_opt IMFStreamSink **ppStreamSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPresentationClock( 
            /* [in] */ __RPC__in_opt IMFPresentationClock *pPresentationClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPresentationClock( 
            /* [out] */ __RPC__deref_out_opt IMFPresentationClock **ppPresentationClock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFMediaSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMFMediaSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMFMediaSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMFMediaSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCharacteristics )( 
            __RPC__in IMFMediaSink * This,
            /* [out] */ __RPC__out DWORD *pdwCharacteristics);
        
        HRESULT ( STDMETHODCALLTYPE *AddStreamSink )( 
            __RPC__in IMFMediaSink * This,
            /* [in] */ DWORD dwStreamSinkIdentifier,
            /* [in] */ __RPC__in_opt IMFMediaType *pMediaType,
            /* [out] */ __RPC__deref_out_opt IMFStreamSink **ppStreamSink);
        
        HRESULT ( STDMETHODCALLTYPE *RemoveStreamSink )( 
            __RPC__in IMFMediaSink * This,
            /* [in] */ DWORD dwStreamSinkIdentifier);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSinkCount )( 
            __RPC__in IMFMediaSink * This,
            /* [out] */ __RPC__out DWORD *pcStreamSinkCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSinkByIndex )( 
            __RPC__in IMFMediaSink * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ __RPC__deref_out_opt IMFStreamSink **ppStreamSink);
        
        HRESULT ( STDMETHODCALLTYPE *GetStreamSinkById )( 
            __RPC__in IMFMediaSink * This,
            /* [in] */ DWORD dwStreamSinkIdentifier,
            /* [out] */ __RPC__deref_out_opt IMFStreamSink **ppStreamSink);
        
        HRESULT ( STDMETHODCALLTYPE *SetPresentationClock )( 
            __RPC__in IMFMediaSink * This,
            /* [in] */ __RPC__in_opt IMFPresentationClock *pPresentationClock);
        
        HRESULT ( STDMETHODCALLTYPE *GetPresentationClock )( 
            __RPC__in IMFMediaSink * This,
            /* [out] */ __RPC__deref_out_opt IMFPresentationClock **ppPresentationClock);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            __RPC__in IMFMediaSink * This);
        
        END_INTERFACE
    } IMFMediaSinkVtbl;

    interface IMFMediaSink
    {
        CONST_VTBL struct IMFMediaSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFMediaSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFMediaSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFMediaSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFMediaSink_GetCharacteristics(This,pdwCharacteristics)	\
    ( (This)->lpVtbl -> GetCharacteristics(This,pdwCharacteristics) ) 

#define IMFMediaSink_AddStreamSink(This,dwStreamSinkIdentifier,pMediaType,ppStreamSink)	\
    ( (This)->lpVtbl -> AddStreamSink(This,dwStreamSinkIdentifier,pMediaType,ppStreamSink) ) 

#define IMFMediaSink_RemoveStreamSink(This,dwStreamSinkIdentifier)	\
    ( (This)->lpVtbl -> RemoveStreamSink(This,dwStreamSinkIdentifier) ) 

#define IMFMediaSink_GetStreamSinkCount(This,pcStreamSinkCount)	\
    ( (This)->lpVtbl -> GetStreamSinkCount(This,pcStreamSinkCount) ) 

#define IMFMediaSink_GetStreamSinkByIndex(This,dwIndex,ppStreamSink)	\
    ( (This)->lpVtbl -> GetStreamSinkByIndex(This,dwIndex,ppStreamSink) ) 

#define IMFMediaSink_GetStreamSinkById(This,dwStreamSinkIdentifier,ppStreamSink)	\
    ( (This)->lpVtbl -> GetStreamSinkById(This,dwStreamSinkIdentifier,ppStreamSink) ) 

#define IMFMediaSink_SetPresentationClock(This,pPresentationClock)	\
    ( (This)->lpVtbl -> SetPresentationClock(This,pPresentationClock) ) 

#define IMFMediaSink_GetPresentationClock(This,ppPresentationClock)	\
    ( (This)->lpVtbl -> GetPresentationClock(This,ppPresentationClock) ) 

#define IMFMediaSink_Shutdown(This)	\
    ( (This)->lpVtbl -> Shutdown(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFMediaSink_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mfidl_0000_0005 */
/* [local] */ 

typedef 
enum _MFSTREAMSINK_MARKER_TYPE
    {	MFSTREAMSINK_MARKER_DEFAULT	= 0,
	MFSTREAMSINK_MARKER_ENDOFSEGMENT	= ( MFSTREAMSINK_MARKER_DEFAULT + 1 ) ,
	MFSTREAMSINK_MARKER_TICK	= ( MFSTREAMSINK_MARKER_ENDOFSEGMENT + 1 ) ,
	MFSTREAMSINK_MARKER_EVENT	= ( MFSTREAMSINK_MARKER_TICK + 1 ) 
    } 	MFSTREAMSINK_MARKER_TYPE;




extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0005_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mfidl_0000_0005_v0_0_s_ifspec;

#ifndef __IMFStreamSink_INTERFACE_DEFINED__
#define __IMFStreamSink_INTERFACE_DEFINED__

/* interface IMFStreamSink */
/* [uuid][object] */ 


EXTERN_C const IID IID_IMFStreamSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0A97B3CF-8E7C-4a3d-8F8C-0C843DC247FB")
    IMFStreamSink : public IMFMediaEventGenerator
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMediaSink( 
            /* [out] */ __RPC__deref_out_opt IMFMediaSink **ppMediaSink) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIdentifier( 
            /* [out] */ __RPC__out DWORD *pdwIdentifier) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMediaTypeHandler( 
            /* [out] */ __RPC__deref_out_opt IMFMediaTypeHandler **ppHandler) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessSample( 
            /* [in] */ __RPC__in_opt IMFSample *pSample) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PlaceMarker( 
            /* [in] */ MFSTREAMSINK_MARKER_TYPE eMarkerType,
            /* [in] */ __RPC__in const PROPVARIANT *pvarMarkerValue,
            /* [in] */ __RPC__in const PROPVARIANT *pvarContextValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMFStreamSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            __RPC__in IMFStreamSink * This,
            /* [in] */ __RPC__in REFIID riid,
            /* [annotation][iid_is][out] */ 
            __RPC__deref_out  void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            __RPC__in IMFStreamSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            __RPC__in IMFStreamSink * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetEvent )( 
            __RPC__in IMFStreamSink * This,
            /* [in] */ DWORD dwFlags,
            /* [out] */ __RPC__deref_out_opt IMFMediaEvent **ppEvent);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *BeginGetEvent )( 
            IMFStreamSink * This,
            /* [in] */ IMFAsyncCallback *pCallback,
            /* [in] */ IUnknown *punkState);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *EndGetEvent )( 
            IMFStreamSink * This,
            /* [in] */ IMFAsyncResult *pResult,
            /* [annotation][out] */ 
            __out  IMFMediaEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *QueueEvent )( 
            __RPC__in IMFStreamSink * This,
            /* [in] */ MediaEventType met,
            /* [in] */ __RPC__in REFGUID guidExtendedType,
            /* [in] */ HRESULT hrStatus,
            /* [unique][in] */ __RPC__in_opt const PROPVARIANT *pvValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaSink )( 
            __RPC__in IMFStreamSink * This,
            /* [out] */ __RPC__deref_out_opt IMFMediaSink **ppMediaSink);
        
        HRESULT ( STDMETHODCALLTYPE *GetIdentifier )( 
            __RPC__in IMFStreamSink * This,
            /* [out] */ __RPC__out DWORD *pdwIdentifier);
        
        HRESULT ( STDMETHODCALLTYPE *GetMediaTypeHandler )( 
            __RPC__in IMFStreamSink * This,
            /* [out] */ __RPC__deref_out_opt IMFMediaTypeHandler **ppHandler);
        
        HRESULT ( STDMETHODCALLTYPE *ProcessSample )( 
            __RPC__in IMFStreamSink * This,
            /* [in] */ __RPC__in_opt IMFSample *pSample);
        
        HRESULT ( STDMETHODCALLTYPE *PlaceMarker )( 
            __RPC__in IMFStreamSink * This,
            /* [in] */ MFSTREAMSINK_MARKER_TYPE eMarkerType,
            /* [in] */ __RPC__in const PROPVARIANT *pvarMarkerValue,
            /* [in] */ __RPC__in const PROPVARIANT *pvarContextValue);
        
        HRESULT ( STDMETHODCALLTYPE *Flush )( 
            __RPC__in IMFStreamSink * This);
        
        END_INTERFACE
    } IMFStreamSinkVtbl;

    interface IMFStreamSink
    {
        CONST_VTBL struct IMFStreamSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMFStreamSink_QueryInterface(This,riid,ppvObject)	\
    ( (This)->lpVtbl -> QueryInterface(This,riid,ppvObject) ) 

#define IMFStreamSink_AddRef(This)	\
    ( (This)->lpVtbl -> AddRef(This) ) 

#define IMFStreamSink_Release(This)	\
    ( (This)->lpVtbl -> Release(This) ) 


#define IMFStreamSink_GetEvent(This,dwFlags,ppEvent)	\
    ( (This)->lpVtbl -> GetEvent(This,dwFlags,ppEvent) ) 

#define IMFStreamSink_BeginGetEvent(This,pCallback,punkState)	\
    ( (This)->lpVtbl -> BeginGetEvent(This,pCallback,punkState) ) 

#define IMFStreamSink_EndGetEvent(This,pResult,ppEvent)	\
    ( (This)->lpVtbl -> EndGetEvent(This,pResult,ppEvent) ) 

#define IMFStreamSink_QueueEvent(This,met,guidExtendedType,hrStatus,pvValue)	\
    ( (This)->lpVtbl -> QueueEvent(This,met,guidExtendedType,hrStatus,pvValue) ) 


#define IMFStreamSink_GetMediaSink(This,ppMediaSink)	\
    ( (This)->lpVtbl -> GetMediaSink(This,ppMediaSink) ) 

#define IMFStreamSink_GetIdentifier(This,pdwIdentifier)	\
    ( (This)->lpVtbl -> GetIdentifier(This,pdwIdentifier) ) 

#define IMFStreamSink_GetMediaTypeHandler(This,ppHandler)	\
    ( (This)->lpVtbl -> GetMediaTypeHandler(This,ppHandler) ) 

#define IMFStreamSink_ProcessSample(This,pSample)	\
    ( (This)->lpVtbl -> ProcessSample(This,pSample) ) 

#define IMFStreamSink_PlaceMarker(This,eMarkerType,pvarMarkerValue,pvarContextValue)	\
    ( (This)->lpVtbl -> PlaceMarker(This,eMarkerType,pvarMarkerValue,pvarContextValue) ) 

#define IMFStreamSink_Flush(This)	\
    ( (This)->lpVtbl -> Flush(This) ) 

#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IMFStreamSink_INTERFACE_DEFINED__ */


#ifndef __IMFVideoSampleAllocator_INTERFACE_DEFINED__
#define __IMFVideoSampleAllocator_INTERFACE_DEFINED__

/* interface IMFVideoSampleAllocator */
/* [local][uuid][object] */ 


EXTERN_C const IID IID_IMFVideoSampleAllocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("86cbc910-e533-4751-8e3b-f19b5b806a03")
    IMFVideoSampleAllocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetD