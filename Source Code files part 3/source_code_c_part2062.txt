erty token  

    STDMETHOD(DefineParam)(
        mdMethodDef md,                     // [IN] Owning method   
        ULONG       ulParamSeq,             // [IN] Which param 
        LPCWSTR     szName,                 // [IN] Optional param name 
        DWORD       dwParamFlags,           // [IN] Optional param flags    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdParamDef  *ppd) PURE;             // [OUT] Put param token here   

    STDMETHOD(SetFieldProps)(               // S_OK or error.
        mdFieldDef  fd,                     // [IN] The FieldDef.
        DWORD       dwFieldFlags,           // [IN] Field attributes.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue) PURE;         // [IN] size of constant value (string, in wide chars).

    STDMETHOD(SetPropertyProps)(            // S_OK or error.
        mdProperty  pr,                     // [IN] Property token.
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] Setter of the property.
        mdMethodDef mdGetter,               // [IN] Getter of the property.
        mdMethodDef rmdOtherMethods[]) PURE;// [IN] Array of other methods.

    STDMETHOD(SetParamProps)(               // Return code.
        mdParamDef  pd,                     // [IN] Param token.   
        LPCWSTR     szName,                 // [IN] Param name.
        DWORD       dwParamFlags,           // [IN] Param flags.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type. selected ELEMENT_TYPE_*.
        void const  *pValue,                // [OUT] Constant value.
        ULONG       cchValue) PURE;         // [IN] size of constant value (string, in wide chars).

    // Specialized Custom Attributes for security.
    STDMETHOD(DefineSecurityAttributeSet)(  // Return code.
        mdToken     tkObj,                  // [IN] Class or method requiring security attributes.
        COR_SECATTR rSecAttrs[],            // [IN] Array of security attribute descriptions.
        ULONG       cSecAttrs,              // [IN] Count of elements in above array.
        ULONG       *pulErrorAttr) PURE;    // [OUT] On error, index of attribute causing problem.

    STDMETHOD(ApplyEditAndContinue)(        // S_OK or error.
        IUnknown    *pImport) PURE;         // [IN] Metadata from the delta PE.

    STDMETHOD(TranslateSigWithScope)(
        IMetaDataAssemblyImport *pAssemImport, // [IN] importing assembly interface
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *import,            // [IN] importing interface
        PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
        ULONG       cbSigBlob,              // [IN] count of bytes of signature
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] emit assembly interface
        IMetaDataEmit *emit,                // [IN] emit interface
        PCOR_SIGNATURE pvTranslatedSig,     // [OUT] buffer to hold translated signature
        ULONG       cbTranslatedSigMax,
        ULONG       *pcbTranslatedSig) PURE;// [OUT] count of bytes in the translated signature

    STDMETHOD(SetMethodImplFlags)(          // [IN] S_OK or error.  
        mdMethodDef md,                     // [IN] Method for which to set ImplFlags 
        DWORD       dwImplFlags) PURE;  

    STDMETHOD(SetFieldRVA)(                 // [IN] S_OK or error.  
        mdFieldDef  fd,                     // [IN] Field for which to set offset  
        ULONG       ulRVA) PURE;            // [IN] The offset  

    STDMETHOD(Merge)(                       // S_OK or error.
        IMetaDataImport *pImport,           // [IN] The scope to be merged.
        IMapToken   *pHostMapToken,         // [IN] Host IMapToken interface to receive token remap notification
        IUnknown    *pHandler) PURE;        // [IN] An object to receive to receive error notification.

    STDMETHOD(MergeEnd)() PURE;             // S_OK or error.

    // This interface is sealed.  Do not change, add, or remove anything.  Instead, derive a new iterface.

};      // IMetaDataEmit

//-------------------------------------
//--- IMetaDataEmit2
//-------------------------------------
// {F5DD9950-F693-42e6-830E-7B833E8146A9}
EXTERN_GUID(IID_IMetaDataEmit2, 0xf5dd9950, 0xf693, 0x42e6, 0x83, 0xe, 0x7b, 0x83, 0x3e, 0x81, 0x46, 0xa9);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataEmit2
DECLARE_INTERFACE_(IMetaDataEmit2, IMetaDataEmit)
{
    STDMETHOD(DefineMethodSpec)(
        mdToken     tkParent,               // [IN] MethodDef or MemberRef
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMethodSpec *pmi) PURE;            // [OUT] method instantiation token

    STDMETHOD(GetDeltaSaveSize)(            // S_OK or error.
        CorSaveSize fSave,                  // [IN] cssAccurate or cssQuick.
        DWORD       *pdwSaveSize) PURE;     // [OUT] Put the size here.

    STDMETHOD(SaveDelta)(                   // S_OK or error.
        LPCWSTR     szFile,                 // [IN] The filename to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(SaveDeltaToStream)(           // S_OK or error.
        IStream     *pIStream,              // [IN] A writable stream to save to.
        DWORD       dwSaveFlags) PURE;      // [IN] Flags for the save.

    STDMETHOD(SaveDeltaToMemory)(           // S_OK or error.
        void        *pbData,                // [OUT] Location to write data.
        ULONG       cbData) PURE;           // [IN] Max size of data buffer.

    STDMETHOD(DefineGenericParam)(          // S_OK or error.
        mdToken      tk,                    // [IN] TypeDef or MethodDef
        ULONG        ulParamSeq,            // [IN] Index of the type parameter
        DWORD        dwParamFlags,          // [IN] Flags, for future use (e.g. variance)
        LPCWSTR      szname,                // [IN] Name
        DWORD        reserved,              // [IN] For future use (e.g. non-type parameters)
        mdToken      rtkConstraints[],      // [IN] Array of type constraints (TypeDef,TypeRef,TypeSpec)
        mdGenericParam *pgp) PURE;          // [OUT] Put GenericParam token here

    STDMETHOD(SetGenericParamProps)(        // S_OK or error.
        mdGenericParam gp,                  // [IN] GenericParam
        DWORD        dwParamFlags,          // [IN] Flags, for future use (e.g. variance)
        LPCWSTR      szName,                // [IN] Optional name
        DWORD        reserved,              // [IN] For future use (e.g. non-type parameters)
        mdToken      rtkConstraints[]) PURE;// [IN] Array of type constraints (TypeDef,TypeRef,TypeSpec)
    
    STDMETHOD(ResetENCLog)() PURE;          // S_OK or error.

};

//-------------------------------------
//--- IMetaDataImport
//-------------------------------------
// {7DAC8207-D3AE-4c75-9B67-92801A497D44}
EXTERN_GUID(IID_IMetaDataImport, 0x7dac8207, 0xd3ae, 0x4c75, 0x9b, 0x67, 0x92, 0x80, 0x1a, 0x49, 0x7d, 0x44);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataImport
DECLARE_INTERFACE_(IMetaDataImport, IUnknown)
{
    STDMETHOD_(void, CloseEnum)(HCORENUM hEnum) PURE;
    STDMETHOD(CountEnum)(HCORENUM hEnum, ULONG *pulCount) PURE;
    STDMETHOD(ResetEnum)(HCORENUM hEnum, ULONG ulPos) PURE;
    STDMETHOD(EnumTypeDefs)(HCORENUM *phEnum, mdTypeDef rTypeDefs[],
                            ULONG cMax, ULONG *pcTypeDefs) PURE;
    STDMETHOD(EnumInterfaceImpls)(HCORENUM *phEnum, mdTypeDef td,
                            mdInterfaceImpl rImpls[], ULONG cMax,
                            ULONG* pcImpls) PURE;
    STDMETHOD(EnumTypeRefs)(HCORENUM *phEnum, mdTypeRef rTypeRefs[],
                            ULONG cMax, ULONG* pcTypeRefs) PURE;

    STDMETHOD(FindTypeDefByName)(           // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of the Type.
        mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef for Enclosing class.
        mdTypeDef   *ptd) PURE;             // [OUT] Put the TypeDef token here.

    STDMETHOD(GetScopeProps)(               // S_OK or error.
      __out_ecount_part_opt(cchName, *pchName)
        LPWSTR      szName,                 // [OUT] Put the name here.
        ULONG       cchName,                // [IN] Size of name buffer in wide chars.
        ULONG       *pchName,               // [OUT] Put size of name (wide chars) here.
        GUID        *pmvid) PURE;           // [OUT, OPTIONAL] Put MVID here.

    STDMETHOD(GetModuleFromScope)(          // S_OK.
        mdModule    *pmd) PURE;             // [OUT] Put mdModule token here.

    STDMETHOD(GetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] TypeDef token for inquiry.
      __out_ecount_part_opt(cchTypeDef, pchTypeDef)
        LPWSTR      szTypeDef,              // [OUT] Put name here.
        ULONG       cchTypeDef,             // [IN] size of name buffer in wide chars.
        ULONG       *pchTypeDef,            // [OUT] put size of name (wide chars) here.
        DWORD       *pdwTypeDefFlags,       // [OUT] Put flags here.
        mdToken     *ptkExtends) PURE;      // [OUT] Put base class TypeDef/TypeRef here.

    STDMETHOD(GetInterfaceImplProps)(       // S_OK or error.
        mdInterfaceImpl iiImpl,             // [IN] InterfaceImpl token.
        mdTypeDef   *pClass,                // [OUT] Put implementing class token here.
        mdToken     *ptkIface) PURE;        // [OUT] Put implemented interface token here.  
            
    STDMETHOD(GetTypeRefProps)(             // S_OK or error.
        mdTypeRef   tr,                     // [IN] TypeRef token.
        mdToken     *ptkResolutionScope,    // [OUT] Resolution scope, ModuleRef or AssemblyRef.
      __out_ecount_part_opt(cchName, *pchName)
        LPWSTR      szName,                 // [OUT] Name of the TypeRef.
        ULONG       cchName,                // [IN] Size of buffer.
        ULONG       *pchName) PURE;         // [OUT] Size of Name.

    STDMETHOD(ResolveTypeRef)(mdTypeRef tr, REFIID riid, IUnknown **ppIScope, mdTypeDef *ptd) PURE;

    STDMETHOD(EnumMembers)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMembersWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethods)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdMethodDef rMethods[],             // [OUT] Put MethodDefs here.   
        ULONG       cMax,                   // [IN] Max MethodDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodsWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdMethodDef rMethods[],             // [OU] Put MethodDefs here.    
        ULONG       cMax,                   // [IN] Max MethodDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFields)(                  // S_OK, S_FALSE, or error.  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdFieldDef  rFields[],              // [OUT] Put FieldDefs here.    
        ULONG       cMax,                   // [IN] Max FieldDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumFieldsWithName)(          // S_OK, S_FALSE, or error.              
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdFieldDef  rFields[],              // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    


    STDMETHOD(EnumParams)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdParamDef  rParams[],              // [OUT] Put ParamDefs here.    
        ULONG       cMax,                   // [IN] Max ParamDefs to put.   
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMemberRefs)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tkParent,               // [IN] Parent token to scope the enumeration.  
        mdMemberRef rMemberRefs[],          // [OUT] Put MemberRefs here.   
        ULONG       cMax,                   // [IN] Max MemberRefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumMethodImpls)(             // S_OK, S_FALSE, or error  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMethodBody[],          // [OUT] Put Method Body tokens here.   
        mdToken     rMethodDecl[],          // [OUT] Put Method Declaration tokens here.
        ULONG       cMax,                   // [IN] Max tokens to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(EnumPermissionSets)(          // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tk,                     // [IN] if !NIL, token to scope the enumeration.    
        DWORD       dwActions,              // [IN] if !0, return only these actions.   
        mdPermission rPermission[],         // [OUT] Put Permissions here.  
        ULONG       cMax,                   // [IN] Max Permissions to put. 
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(FindMember)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdToken     *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMethod)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMethodDef *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindField)(   
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdFieldDef  *pmb) PURE;             // [OUT] matching memberdef 

    STDMETHOD(FindMemberRef)(   
        mdTypeRef   td,                     // [IN] given typeRef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of CLR signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr) PURE;             // [OUT] matching memberref 

    STDMETHOD (GetMethodProps)( 
        mdMethodDef mb,                     // The method for which to get props.   
        mdTypeDef   *pClass,                // Put method's class here. 
      __out_ecount_part_opt(cchMethod, *pchMethod)
        LPWSTR      szMethod,               // Put method's name here.  
        ULONG       cchMethod,              // Size of szMethod buffer in wide chars.   
        ULONG       *pchMethod,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags) PURE;    // [OUT] Impl. Flags    

    STDMETHOD(GetMemberRefProps)(           // S_OK or error.   
        mdMemberRef mr,                     // [IN] given memberref 
        mdToken     *ptk,                   // [OUT] Put classref or classdef here. 
      __out_ecount_part_opt(cchMember, *pchMember)
        LPWSTR      szMember,               // [OUT] buffer to fill for member's name   
        ULONG       cchMember,              // [IN] the count of char of szMember   
        ULONG       *pchMember,             // [OUT] actual count of char in member name    
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to meta data blob value  
        ULONG       *pbSig) PURE;           // [OUT] actual size of signature blob  

    STDMETHOD(EnumProperties)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdProperty  rProperties[],          // [OUT] Put Properties here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcProperties) PURE;    // [OUT] Put # put here.    

    STDMETHOD(EnumEvents)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdEvent     rEvents[],              // [OUT] Put events here.
        ULONG       cMax,                   // [IN] Max events to put.  
        ULONG       *pcEvents) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetEventProps)(               // S_OK, S_FALSE, or error. 
        mdEvent     ev,                     // [IN] event token 
        mdTypeDef   *pClass,                // [OUT] typedef containing the event declarion.    
        LPCWSTR     szEvent,                // [OUT] Event name 
        ULONG       cchEvent,               // [IN] the count of wchar of szEvent   
        ULONG       *pchEvent,              // [OUT] actual count of wchar for event's name 
        DWORD       *pdwEventFlags,         // [OUT] Event flags.   
        mdToken     *ptkEventType,          // [OUT] EventType class    
        mdMethodDef *pmdAddOn,              // [OUT] AddOn method of the event  
        mdMethodDef *pmdRemoveOn,           // [OUT] RemoveOn method of the event   
        mdMethodDef *pmdFire,               // [OUT] Fire method of the event   
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the event  
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod) PURE;   // [OUT] total number of other method of this event 

    STDMETHOD(EnumMethodSemantics)(         // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdToken     rEventProp[],           // [OUT] Put Event/Property here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcEventProp) PURE;     // [OUT] Put # put here.    

    STDMETHOD(GetMethodSemantics)(          // S_OK, S_FALSE, or error. 
        mdMethodDef mb,                     // [IN] method token    
        mdToken     tkEventProp,            // [IN] event/property token.   
        DWORD       *pdwSemanticsFlags) PURE; // [OUT] the role flags for the method/propevent pair 

    STDMETHOD(GetClassLayout) ( 
        mdTypeDef   td,                     // [IN] give typedef    
        DWORD       *pdwPackSize,           // [OUT] 1, 2, 4, 8, or 16  
        COR_FIELD_OFFSET rFieldOffset[],    // [OUT] field offset array 
        ULONG       cMax,                   // [IN] size of the array   
        ULONG       *pcFieldOffset,         // [OUT] needed array size  
        ULONG       *pulClassSize) PURE;        // [OUT] the size of the class  

    STDMETHOD(GetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a field's memberdef   
        PCCOR_SIGNATURE *ppvNativeType,     // [OUT] native type of this field  
        ULONG       *pcbNativeType) PURE;   // [OUT] the count of bytes of *ppvNativeType   

    STDMETHOD(GetRVA)(                      // S_OK or error.   
        mdToken     tk,                     // Member for which to set offset   
        ULONG       *pulCodeRVA,            // The offset   
        DWORD       *pdwImplFlags) PURE;    // the implementation flags 

    STDMETHOD(GetPermissionSetProps) (  
        mdPermission pm,                    // [IN] the permission token.   
        DWORD       *pdwAction,             // [OUT] CorDeclSecurity.   
        void const  **ppvPermission,        // [OUT] permission blob.   
        ULONG       *pcbPermission) PURE;   // [OUT] count of bytes of pvPermission.    

    STDMETHOD(GetSigFromToken)(             // S_OK or error.   
        mdSignature mdSig,                  // [IN] Signature token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.   
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetModuleRefProps)(           // S_OK or error.   
        mdModuleRef mur,                    // [IN] moduleref token.    
      __out_ecount_part_opt(cchName, *pchName)
        LPWSTR      szName,                 // [OUT] buffer to fill with the moduleref name.    
        ULONG       cchName,                // [IN] size of szName in wide characters.  
        ULONG       *pchName) PURE;         // [OUT] actual count of characters in the name.    

    STDMETHOD(EnumModuleRefs)(              // S_OK or error.   
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdModuleRef rModuleRefs[],          // [OUT] put modulerefs here.   
        ULONG       cmax,                   // [IN] max memberrefs to put.  
        ULONG       *pcModuleRefs) PURE;    // [OUT] put # put here.    

    STDMETHOD(GetTypeSpecFromToken)(        // S_OK or error.   
        mdTypeSpec typespec,                // [IN] TypeSpec token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to TypeSpec signature  
        ULONG       *pcbSig) PURE;          // [OUT] return size of signature.  

    STDMETHOD(GetNameFromToken)(            // Not Recommended! May be removed!
        mdToken     tk,                     // [IN] Token to get name from.  Must have a name.
        MDUTF8CSTR  *pszUtf8NamePtr) PURE;  // [OUT] Return pointer to UTF8 name in heap.

    STDMETHOD(EnumUnresolvedMethods)(       // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     rMethods[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.    

    STDMETHOD(GetUserString)(               // S_OK or error.
        mdString    stk,                    // [IN] String token.
      __out_ecount_part_opt(cchString, *pchString)
        LPWSTR      szString,               // [OUT] Copy of string.
        ULONG       cchString,              // [IN] Max chars of room in szString.
        ULONG       *pchString) PURE;       // [OUT] How many chars in actual string.

    STDMETHOD(GetPinvokeMap)(               // S_OK or error.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
      __out_ecount_part_opt(cchImportName, *pchImportName)
        LPWSTR      szImportName,           // [OUT] Import name.
        ULONG       cchImportName,          // [IN] Size of the name buffer.
        ULONG       *pchImportName,         // [OUT] Actual number of characters stored.
        mdModuleRef *pmrImportDLL) PURE;    // [OUT] ModuleRef token for the target DLL.

    STDMETHOD(EnumSignatures)(              // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdSignature rSignatures[],          // [OUT] put signatures here.   
        ULONG       cmax,                   // [IN] max signatures to put.  
        ULONG       *pcSignatures) PURE;    // [OUT] put # put here.

    STDMETHOD(EnumTypeSpecs)(               // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdTypeSpec  rTypeSpecs[],           // [OUT] put TypeSpecs here.   
        ULONG       cmax,                   // [IN] max TypeSpecs to put.  
        ULONG       *pcTypeSpecs) PURE;     // [OUT] put # put here.

    STDMETHOD(EnumUserStrings)(             // S_OK or error.
        HCORENUM    *phEnum,                // [IN/OUT] pointer to the enum.
        mdString    rStrings[],             // [OUT] put Strings here.
        ULONG       cmax,                   // [IN] max Strings to put.
        ULONG       *pcStrings) PURE;       // [OUT] put # put here.

    STDMETHOD(GetParamForMethodIndex)(      // S_OK or error.
        mdMethodDef md,                     // [IN] Method token.
        ULONG       ulParamSeq,             // [IN] Parameter sequence.
        mdParamDef  *ppd) PURE;             // [IN] Put Param token here.

    STDMETHOD(EnumCustomAttributes)(        // S_OK or error.
        HCORENUM    *phEnum,                // [IN, OUT] COR enumerator.
        mdToken     tk,                     // [IN] Token to scope the enumeration, 0 for all.
        mdToken     tkType,                 // [IN] Type of interest, 0 for all.
        mdCustomAttribute rCustomAttributes[], // [OUT] Put custom attribute tokens here.
        ULONG       cMax,                   // [IN] Size of rCustomAttributes.
        ULONG       *pcCustomAttributes) PURE;  // [OUT, OPTIONAL] Put count of token values here.

    STDMETHOD(GetCustomAttributeProps)(     // S_OK or error.
        mdCustomAttribute cv,               // [IN] CustomAttribute token.
        mdToken     *ptkObj,                // [OUT, OPTIONAL] Put object token here.
        mdToken     *ptkType,               // [OUT, OPTIONAL] Put AttrType token here.
        void const  **ppBlob,               // [OUT, OPTIONAL] Put pointer to data here.
        ULONG       *pcbSize) PURE;         // [OUT, OPTIONAL] Put size of date here.

    STDMETHOD(FindTypeRef)(   
        mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
        LPCWSTR     szName,                 // [IN] TypeRef Name.
        mdTypeRef   *ptr) PURE;             // [OUT] matching TypeRef.

    STDMETHOD(GetMemberProps)(  
        mdToken     mb,                     // The member for which to get props.   
        mdTypeDef   *pClass,                // Put member's class here. 
      __out_ecount_part_opt(cchMember, *pchMember)
        LPWSTR      szMember,               // Put member's name here.  
        ULONG       cchMember,              // Size of szMember buffer in wide chars.   
        ULONG       *pchMember,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags,          // [OUT] Impl. Flags    
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        UVCP_CONSTANT *ppValue,             // [OUT] constant value 
        ULONG       *pcchValue) PURE;       // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetFieldProps)(  
        mdFieldDef  mb,                     // The field for which to get props.    
        mdTypeDef   *pClass,                // Put field's class here.  
      __out_ecount_part_opt(cchField, *pchField)
        LPWSTR      szField,                // Put field's name here.   
        ULONG       cchField,               // Size of szField buffer in wide chars.    
        ULONG       *pchField,              // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        UVCP_CONSTANT *ppValue,             // [OUT] constant value 
        ULONG       *pcchValue) PURE;       // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetPropertyProps)(            // S_OK, S_FALSE, or error. 
        mdProperty  prop,                   // [IN] property token  
        mdTypeDef   *pClass,                // [OUT] typedef containing the property declarion. 
        LPCWSTR     szProperty,             // [OUT] Property name  
        ULONG       cchProperty,            // [IN] the count of wchar of szProperty    
        ULONG       *pchProperty,           // [OUT] actual count of wchar for property name    
        DWORD       *pdwPropFlags,          // [OUT] property flags.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob 
        ULONG       *pbSig,                 // [OUT] count of bytes in *ppvSig  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        UVCP_CONSTANT *ppDefaultValue,      // [OUT] constant value 
        ULONG       *pcchDefaultValue,      // [OUT] size of constant string in chars, 0 for non-strings.
        mdMethodDef *pmdSetter,             // [OUT] setter method of the property  
        mdMethodDef *pmdGetter,             // [OUT] getter method of the property  
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the property   
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod) PURE;   // [OUT] total number of other method of this property  

    STDMETHOD(GetParamProps)(               // S_OK or error.
        mdParamDef  tk,                     // [IN]The Parameter.
        mdMethodDef *pmd,                   // [OUT] Parent Method token.
        ULONG       *pulSequence,           // [OUT] Parameter sequence.
      __out_ecount_part_opt(cchName, *pchName)
        LPWSTR      szName,                 // [OUT] Put name here.
        ULONG       cchName,                // [OUT] Size of name buffer.
        ULONG       *pchName,               // [OUT] Put actual size of name here.
        DWORD       *pdwAttr,               // [OUT] Put flags here.
        DWORD       *pdwCPlusTypeFlag,      // [OUT] Flag for value type. selected ELEMENT_TYPE_*.
        UVCP_CONSTANT *ppValue,             // [OUT] Constant value.
        ULONG       *pcchValue) PURE;       // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetCustomAttributeByName)(    // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCWSTR     szName,                 // [IN] Name of desired Custom Attribute.
        const void  **ppData,               // [OUT] Put pointer to data here.
        ULONG       *pcbData) PURE;         // [OUT] Put size of data here.

    STDMETHOD_(BOOL, IsValidToken)(         // True or False.
        mdToken     tk) PURE;               // [IN] Given token.

    STDMETHOD(GetNestedClassProps)(         // S_OK or error.
        mdTypeDef   tdNestedClass,          // [IN] NestedClass token.
        mdTypeDef   *ptdEnclosingClass) PURE; // [OUT] EnclosingClass token.

    STDMETHOD(GetNativeCallConvFromSig)(    // S_OK or error.
        void const  *pvSig,                 // [IN] Pointer to signature.
        ULONG       cbSig,                  // [IN] Count of signature bytes.
        ULONG       *pCallConv) PURE;       // [OUT] Put calling conv here (see CorPinvokemap).                                                                                        

    STDMETHOD(IsGlobal)(                    // S_OK or error.
        mdToken     pd,                     // [IN] Type, Field, or Method token.
        int         *pbGlobal) PURE;        // [OUT] Put 1 if global, 0 otherwise.

    // This interface is sealed.  Do not change, add, or remove anything.  Instead, derive a new iterface.

};      // IMetaDataImport

//-------------------------------------
//--- IMetaDataImport2
//-------------------------------------
// {FCE5EFA0-8BBA-4f8e-A036-8F2022B08466}
EXTERN_GUID(IID_IMetaDataImport2, 0xfce5efa0, 0x8bba, 0x4f8e, 0xa0, 0x36, 0x8f, 0x20, 0x22, 0xb0, 0x84, 0x66);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataImport2
DECLARE_INTERFACE_(IMetaDataImport2, IMetaDataImport)
{
    STDMETHOD(EnumGenericParams)(
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken      tk,                    // [IN] TypeDef or MethodDef whose generic parameters are requested
        mdGenericParam rGenericParams[],    // [OUT] Put GenericParams here.   
        ULONG       cMax,                   // [IN] Max GenericParams to put.  
        ULONG       *pcGenericParams) PURE; // [OUT] Put # put here.    

    STDMETHOD(GetGenericParamProps)(        // S_OK or error.
        mdGenericParam gp,                  // [IN] GenericParam
        ULONG        *pulParamSeq,          // [OUT] Index of the type parameter
        DWORD        *pdwParamFlags,        // [OUT] Flags, for future use (e.g. variance)
        mdToken      *ptOwner,              // [OUT] Owner (TypeDef or MethodDef)
        DWORD       *reserved,              // [OUT] For future use (e.g. non-type parameters)
      __out_ecount_part_opt(cchName, *pchName)
        LPWSTR       wzname,                // [OUT] Put name here
        ULONG        cchName,               // [IN] Size of buffer
        ULONG        *pchName) PURE;        // [OUT] Put size of name (wide chars) here.

    STDMETHOD(GetMethodSpecProps)(
        mdMethodSpec mi,                    // [IN] The method instantiation
        mdToken *tkParent,                  // [OUT] MethodDef or MemberRef
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob) PURE;      // [OUT] actual size of signature blob  

    STDMETHOD(EnumGenericParamConstraints)(
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdGenericParam tk,                  // [IN] GenericParam whose constraints are requested
        mdGenericParamConstraint rGenericParamConstraints[],    // [OUT] Put GenericParamConstraints here.   
        ULONG       cMax,                   // [IN] Max GenericParamConstraints to put.  
        ULONG       *pcGenericParamConstraints) PURE; // [OUT] Put # put here.

    STDMETHOD(GetGenericParamConstraintProps)( // S_OK or error.
        mdGenericParamConstraint gpc,       // [IN] GenericParamConstraint
        mdGenericParam *ptGenericParam,     // [OUT] GenericParam that is constrained
        mdToken      *ptkConstraintType) PURE; // [OUT] TypeDef/Ref/Spec constraint

    STDMETHOD(GetPEKind)(                   // S_OK or error.
        DWORD* pdwPEKind,                   // [OUT] The kind of PE (0 - not a PE)
        DWORD* pdwMAchine) PURE;            // [OUT] Machine as defined in NT header

    STDMETHOD(GetVersionString)(            // S_OK or error.
      __out_ecount_part_opt(cchBufSize, pccBufSize)
        LPWSTR      pwzBuf,                 // [OUT[ Put version string here.
        DWORD       ccBufSize,              // [IN] size of the buffer, in wide chars
        DWORD       *pccBufSize) PURE;      // [OUT] Size of the version string, wide chars, including terminating nul.

    STDMETHOD(EnumMethodSpecs)(
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken      tk,                    // [IN] MethodDef or MemberRef whose MethodSpecs are requested
        mdMethodSpec rMethodSpecs[],        // [OUT] Put MethodSpecs here.   
        ULONG       cMax,                   // [IN] Max tokens to put.  
        ULONG       *pcMethodSpecs) PURE;   // [OUT] Put actual count here.    

}; // IMetaDataImport2

//-------------------------------------
//--- IMetaDataFilter
//-------------------------------------
// {D0E80DD1-12D4-11d3-B39D-00C04FF81795}
EXTERN_GUID(IID_IMetaDataFilter, 0xd0e80dd1, 0x12d4, 0x11d3, 0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95);

//---
#undef  INTERFACE
#define INTERFACE IMetaDataFilter
DECLARE_INTERFACE_(IMetaDataFilter, IUnknown)
{
    STDMETHOD(UnmarkAll)() PURE;
    STDMETHOD(MarkToken)(mdToken tk) PURE;
    STDMETHOD(IsTokenMarked)(mdToken tk, BOOL *pIsMarked) PURE;
};



//-------------------------------------
//--- IHostFilter
//-------------------------------------
// {D0E80DD3-12D4-11d3-B39D-00C04FF81795}
EXTERN_GUID(IID_IHostFilter, 0xd0e80dd3, 0x12d4, 0x11d3, 0xb3, 0x9d, 0x0, 0xc0, 0x4f, 0xf8, 0x17, 0x95);

//---
#undef  INTERFACE
#define INTERFACE IHostFilter
DECLARE_INTERFACE_(IHostFilter, IUnknown)
{
    STDMETHOD(MarkToken)(mdToken tk) PURE;
};


//--------------------------------------
//--- IMetaDataConverter
//--------------------------------------
// {D9DEBD79-2992-11d3-8BC1-0000F8083A57}
EXTERN_GUID(IID_IMetaDataConverter, 0xd9debd79, 0x2992, 0x11d3, 0x8b, 0xc1, 0x0, 0x0, 0xf8, 0x8, 0x3a, 0x57);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataConverter
DECLARE_INTERFACE_(IMetaDataConverter, IUnknown)
{
    STDMETHOD(GetMetaDataFromTypeInfo)(
        ITypeInfo* pITI,                    // [in] Type info
        IMetaDataImport** ppMDI) PURE;      // [out] return IMetaDataImport on success

    STDMETHOD(GetMetaDataFromTypeLib)(
        ITypeLib* pITL,                     // [in] Type library
        IMetaDataImport** ppMDI) PURE;      // [out] return IMetaDataImport on success

    STDMETHOD(GetTypeLibFromMetaData)(
        BSTR strModule,                     // [in] Module name
        BSTR strTlbName,                    // [in] Type library name
        ITypeLib** ppITL) PURE;             // [out] return ITypeLib on success
};


//*****************************************************************************
// Assembly Declarations
//*****************************************************************************

typedef struct
{
    DWORD       dwOSPlatformId;         // Operating system platform.
    DWORD       dwOSMajorVersion;       // OS Major version.
    DWORD       dwOSMinorVersion;       // OS Minor version.
} OSINFO;


typedef struct
{
    USHORT      usMajorVersion;         // Major Version.   
    USHORT      usMinorVersion;         // Minor Version.
    USHORT      usBuildNumber;          // Build Number.
    USHORT      usRevisionNumber;       // Revision Number.
    LPWSTR      szLocale;               // Locale.
    ULONG       cbLocale;               // [IN/OUT] Size of the buffer in wide chars/Actual size.
    DWORD       *rProcessor;            // Processor ID array.
    ULONG       ulProcessor;            // [IN/OUT] Size of the Processor ID array/Actual # of entries filled in.
    OSINFO      *rOS;                   // OSINFO array.
    ULONG       ulOS;                   // [IN/OUT]Size of the OSINFO array/Actual # of entries filled in.
} ASSEMBLYMETADATA;


// {211EF15B-5317-4438-B196-DEC87B887693}
EXTERN_GUID(IID_IMetaDataAssemblyEmit, 0x211ef15b, 0x5317, 0x4438, 0xb1, 0x96, 0xde, 0xc8, 0x7b, 0x88, 0x76, 0x93);

//---
#undef  INTERFACE
#define INTERFACE IMetaDataAssemblyEmit
DECLARE_INTERFACE_(IMetaDataAssemblyEmit, IUnknown)
{
    STDMETHOD(DefineAssembly)(              // S_OK or error.
        const void  *pbPublicKey,           // [IN] Public key of the assembly.
        ULONG       cbPublicKey,            // [IN] Count of bytes in the public key.
        ULONG       ulHashAlgId,            // [IN] Hash algorithm used to hash the files.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        DWORD       dwAssemblyFlags,        // [IN] Flags.
        mdAssembly  *pma) PURE;             // [OUT] Returned Assembly token.

    STDMETHOD(DefineAssemblyRef)(           // S_OK or error.
        const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
        ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwAssemblyRefFlags,     // [IN] Flags.
        mdAssemblyRef *pmdar) PURE;         // [OUT] Returned AssemblyRef token.

    STDMETHOD(DefineFile)(                  // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the file.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags,            // [IN] Flags.
        mdFile      *pmdf) PURE;            // [OUT] Returned File token.

    STDMETHOD(DefineExportedType)(          // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the Com Type.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef or mdExportedType
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        DWORD       dwExportedTypeFlags,    // [IN] Flags.
        mdExportedType   *pmdct) PURE;      // [OUT] Returned ExportedType token.

    STDMETHOD(DefineManifestResource)(      // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the resource.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        DWORD       dwResourceFlags,        // [IN] Flags.
        mdManifestResource  *pmdmr) PURE;   // [OUT] Returned ManifestResource token.

    STDMETHOD(SetAssemblyProps)(            // S_OK or error.
        mdAssembly  pma,                    // [IN] Assembly token.
        const void  *pbPublicKey,           // [IN] Public key of the assembly.
        ULONG       cbPublicKey,            // [IN] Count of bytes in the public key.
        ULONG       ulHashAlgId,            // [IN] Hash algorithm used to hash the files.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        DWORD       dwAssemblyFlags) PURE;  // [IN] Flags.

    STDMETHOD(SetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef ar,                   // [IN] AssemblyRefToken.
        const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
        ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwAssemblyRefFlags) PURE; // [IN] Token for Execution Location.

    STDMETHOD(SetFileProps)(                // S_OK or error.
        mdFile      file,                   // [IN] File token.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags) PURE;      // [IN] Flags.

    STDMETHOD(SetExportedTypeProps)(        // S_OK or error.
        mdExportedType   ct,                // [IN] ExportedType token.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef or mdExportedType.
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        DWORD       dwExportedTypeFlags) PURE;   // [IN] Flags.

    STDMETHOD(SetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mr,             // [IN] ManifestResource token.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        DWORD       dwResourceFlags) PURE;  // [IN] Flags.

};  // IMetaDataAssemblyEmit


// {EE62470B-E94B-424e-9B7C-2F00C9249F93}
EXTERN_GUID(IID_IMetaDataAssemblyImport, 0xee62470b, 0xe94b, 0x424e, 0x9b, 0x7c, 0x2f, 0x0, 0xc9, 0x24, 0x9f, 0x93);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataAssemblyImport
DECLARE_INTERFACE_(IMetaDataAssemblyImport, IUnknown)
{
    STDMETHOD(GetAssemblyProps)(            // S_OK or error.
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbPublicKey,         // [OUT] Pointer to the public key.
        ULONG       *pcbPublicKey,          // [OUT] Count of bytes in the public key.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        __out_ecount_part_opt(cchName, *pchName) LPWSTR  szName, // [OUT] Buffer to fill with assembly's simply name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        DWORD       *pdwAssemblyFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetAssemblyRefProps)(         // S_OK or error.
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        const void  **ppbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
        ULONG       *pcbPublicKeyOrToken,   // [OUT] Count of bytes in the public key or token.
        __out_ecount_part_opt(cchName, *pchName)LPWSTR szName, // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        DWORD       *pdwAssemblyRefFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetFileProps)(                // S_OK or error.
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        __out_ecount_part_opt(cchName, *pchName) LPWSTR      szName, // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags) PURE;    // [OUT] Flags.

    STDMETHOD(GetExportedTypeProps)(        // S_OK or error.
        mdExportedType   mdct,              // [IN] The ExportedType for which to get the properties.
        __out_ecount_part_opt(cchName, *pchName) LPWSTR      szName, // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef or mdExportedType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        DWORD       *pdwExportedTypeFlags) PURE; // [OUT] Flags.

    STDMETHOD(GetManifestResourceProps)(    // S_OK or error.
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        __out_ecount_part_opt(cchName, *pchName)LPWSTR      szName,  // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ManifestResource.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        DWORD       *pdwResourceFlags) PURE;// [OUT] Flags.

    STDMETHOD(EnumAssemblyRefs)(            // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdAssemblyRef rAssemblyRefs[],      // [OUT] Put AssemblyRefs here.
        ULONG       cMax,                   // [IN] Max AssemblyRefs to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumFiles)(                   // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdFile      rFiles[],               // [OUT] Put Files here.
        ULONG       cMax,                   // [IN] Max Files to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumExportedTypes)(           // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdExportedType   rExportedTypes[],  // [OUT] Put ExportedTypes here.
        ULONG       cMax,                   // [IN] Max ExportedTypes to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(EnumManifestResources)(       // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdManifestResource  rManifestResources[],   // [OUT] Put ManifestResources here.
        ULONG       cMax,                   // [IN] Max Resources to put.
        ULONG       *pcTokens) PURE;        // [OUT] Put # put here.

    STDMETHOD(GetAssemblyFromScope)(        // S_OK or error
        mdAssembly  *ptkAssembly) PURE;     // [OUT] Put token here.

    STDMETHOD(FindExportedTypeByName)(      // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ExportedType.
        mdToken     mdtExportedType,        // [IN] ExportedType for the enclosing class.
        mdExportedType   *ptkExportedType) PURE; // [OUT] Put the ExportedType token here.

    STDMETHOD(FindManifestResourceByName)(  // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ManifestResource.
        mdManifestResource *ptkManifestResource) PURE;  // [OUT] Put the ManifestResource token here.

    STDMETHOD_(void, CloseEnum)(
        HCORENUM hEnum) PURE;               // Enum to be closed.

    STDMETHOD(FindAssembliesByName)(        // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        IUnknown *ppIUnk[],                 // [OUT] put IMetaDataAssemblyImport pointers here
        ULONG    cMax,                      // [IN] The max number to put
        ULONG    *pcAssemblies) PURE;       // [OUT] The number of assemblies returned.
};  // IMetaDataAssemblyImport


//*****************************************************************************
// End Assembly Declarations
//*****************************************************************************

//*****************************************************************************
// MetaData Validator Declarations
//*****************************************************************************

// Specifies the type of the module, PE file vs. .obj file.
typedef enum
{
    ValidatorModuleTypeInvalid      = 0x0,
    ValidatorModuleTypeMin          = 0x00000001,
    ValidatorModuleTypePE           = 0x00000001,
    ValidatorModuleTypeObj          = 0x00000002,
    ValidatorModuleTypeEnc          = 0x00000003,
    ValidatorModuleTypeIncr         = 0x00000004,
    ValidatorModuleTypeMax          = 0x00000004,
} CorValidatorModuleType;


// {4709C9C6-81FF-11D3-9FC7-00C04F79A0A3}
EXTERN_GUID(IID_IMetaDataValidate, 0x4709c9c6, 0x81ff, 0x11d3, 0x9f, 0xc7, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3);

//---
#undef  INTERFACE   
#define INTERFACE IMetaDataValidate
DECLARE_INTERFACE_(IMetaDataValidate, IUnknown)
{
    STDMETHOD(ValidatorInit)(               // S_OK or error.
        DWORD       dwModuleType,           // [IN] Specifies the type of the module.
        IUnknown    *pUnk) PURE;            // [IN] Validation error handler.

    STDMETHOD(ValidateMetaData)(            // S_OK or error.
        ) PURE;
};  // IMetaDataValidate

//*****************************************************************************
// End MetaData Validator Declarations
//*****************************************************************************

//*****************************************************************************
// IMetaDataDispenserEx declarations.
//*****************************************************************************

// {31BCFCE2-DAFB-11D2-9F81-00C04F79A0A3}
EXTERN_GUID(IID_IMetaDataDispenserEx, 0x31bcfce2, 0xdafb, 0x11d2, 0x9f, 0x81, 0x0, 0xc0, 0x4f, 0x79, 0xa0, 0xa3);

#undef  INTERFACE
#define INTERFACE IMetaDataDispenserEx
DECLARE_INTERFACE_(IMetaDataDispenserEx, IMetaDataDispenser)
{
    STDMETHOD(SetOption)(                   // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        const VARIANT *value) PURE;         // [in] Value to which the option is to be set.

    STDMETHOD(GetOption)(                   // Return code.
        REFGUID     optionid,               // [in] GUID for the option to be set.
        VARIANT *pvalue) PURE;              // [out] Value to which the option is currently set.

    STDMETHOD(OpenScopeOnITypeInfo)(        // Return code.
        ITypeInfo   *pITI,                  // [in] ITypeInfo to open.
        DWORD       dwOpenFlags,            // [in] Open mode flags.
        REFIID      riid,                   // [in] The interface desired.
        IUnknown    **ppIUnk) PURE;         // [out] Return interface on success.

    STDMETHOD(GetCORSystemDirectory)(       // Return code.
       __out_ecount_part_opt(cchBuffer, *pchBuffer)
         LPWSTR      szBuffer,              // [out] Buffer for the directory name
         DWORD       cchBuffer,             // [in] Size of the buffer
         DWORD*      pchBuffer) PURE;       // [OUT] Number of characters returned

    STDMETHOD(FindAssembly)(                // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN] the name buffer's size
        ULONG    *pcName) PURE;             // [OUT] the number of characters returend in the buffer

    STDMETHOD(FindAssemblyModule)(          // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szGlobalBin,               // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        LPCWSTR  szModuleName,              // [IN] required - the name of the module
      __out_ecount_part_opt(cchName, *pcName)
        LPWSTR   szName,                    // [OUT] buffer - to hold name 
        ULONG    cchName,                   // [IN]  the name buffer's size
        ULONG    *pcName) PURE;             // [OUT] the number of characters returend in the buffer

};

//*****************************************************************************
//*****************************************************************************
//
// Registration declarations.  Will be replace by Services' Registration
//  implementation. 
//
//*****************************************************************************
//*****************************************************************************
// Various flags for use in installing a module or a composite
typedef enum 
{
    regNoCopy = 0x00000001,         // Don't copy files into destination    
    regConfig = 0x00000002,         // Is a configuration   
    regHasRefs = 0x00000004         // Has class references 
} CorRegFlags;

typedef GUID CVID;

typedef struct {
    short Major;    
    short Minor;    
    short Sub;  
    short Build;    
} CVStruct;


//*****************************************************************************
//*****************************************************************************
//
// CeeGen interfaces for generating in-memory Common Language Runtime files
//
//*****************************************************************************
//*****************************************************************************

typedef void *HCEESECTION;

typedef enum  {
    sdNone =        0,
    sdReadOnly =    IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_INITIALIZED_DATA,
    sdReadWrite =   sdReadOnly | IMAGE_SCN_MEM_WRITE,
    sdExecute =     IMAGE_SCN_MEM_READ | IMAGE_SCN_CNT_CODE | IMAGE_SCN_MEM_EXECUTE
} CeeSectionAttr;

//
// Relocation types.
//

typedef enum  {
    // generate only a section-relative reloc, nothing into .reloc section
    srRelocAbsolute,

    // generate a .reloc for a pointer sized location, 
    // This is transformed into BASED_HIGHLOW or BASED_DIR64 based on the platform
    srRelocHighLow      = 3,

    // generate a .reloc for the top 16-bits of a 32 bit number, where the
    // bottom 16 bits are included in the next word in the .reloc table
    srRelocHighAdj,     // Never Used

    // generate a token map relocation, nothing into .reloc section 
    srRelocMapToken,

    // relative address fixup
    srRelocRelative,

    // Generate only a section-relative reloc, nothing into .reloc
    // section.  This reloc is relative to the file position of the
    // section, not the section's virtual address.
    srRelocFilePos,

    // code relative address fixup
    srRelocCodeRelative,

    // generate a .reloc for a 64 bit address in an ia64 movl instruction 
    srRelocIA64Imm64,

    // generate a .reloc for a 64 bit address
    srRelocDir64,

    // generate a .reloc for a 25-bit PC relative address in an ia64 br.call instruction 
    srRelocIA64PcRel25,

    // generate a .reloc for a 64-bit PC relative address in an ia64 brl.call instruction 
    srRelocIA64PcRel64,

    // generate a 30-bit section-relative reloc, used for tagged pointer values
    srRelocAbsoluteTagged,


    // A sentinel value to help ensure any additions to this enum are reflected 
    // in PEWriter.cpp's RelocName array.
    srRelocSentinel,

    // Flags that can be used with the above reloc types

    // do not emit base reloc
    srNoBaseReloc = 0x4000,
    
    // pre-fixup contents of memory are ptr rather than a section offset
    srRelocPtr = 0x8000,

    // legal enums which include the Ptr flag
    srRelocAbsolutePtr  = srRelocPtr + srRelocAbsolute,
    srRelocHighLowPtr   = srRelocPtr + srRelocHighLow,
    srRelocRelativePtr  = srRelocPtr + srRelocRelative,
    srRelocIA64Imm64Ptr = srRelocPtr + srRelocIA64Imm64,
    srRelocDir64Ptr     = srRelocPtr + srRelocDir64,

} CeeSectionRelocType;

#define IMAGE_REL_BASED_REL32            7
#define IMAGE_REL_BASED_IA64_PCREL21    11
#define IMAGE_REL_BASED_IA64_PCREL60    12

typedef union  {
    USHORT highAdj;
} CeeSectionRelocExtra;

//-------------------------------------
//--- ICeeGen
//-------------------------------------
// {7ED1BDFF-8E36-11d2-9C56-00A0C9B7CC45}
EXTERN_GUID(IID_ICeeGen, 0x7ed1bdff, 0x8e36, 0x11d2, 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45);

DECLARE_INTERFACE_(ICeeGen, IUnknown)
{
    STDMETHOD (EmitString) (    
      __in
        LPWSTR lpString,                    // [IN] String to emit
        ULONG *RVA) PURE;                   // [OUT] RVA for string emitted string  

    STDMETHOD (GetString) (     
        ULONG RVA,                          // [IN] RVA for string to return    
      __out_opt
        LPWSTR *lpString) PURE;             // [OUT] Returned string

    STDMETHOD (AllocateMethodBuffer) (  
        ULONG cchBuffer,                    // [IN] Length of buffer to create  
        UCHAR **lpBuffer,                   // [OUT] Returned buffer    
        ULONG *RVA) PURE;                   // [OUT] RVA for method 

    STDMETHOD (GetMethodBuffer) (   
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

    STDMETHOD (GetIMapTokenIface) (     
        IUnknown **pIMapToken) PURE;    

    STDMETHOD (GenerateCeeFile) () PURE;

    STDMETHOD (GetIlSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (GetStringSection) (
        HCEESECTION *section) PURE; 

    STDMETHOD (AddSectionReloc) (
        HCEESECTION section,    
        ULONG offset,   
        HCEESECTION relativeTo,     
        CeeSectionRelocType relocType) PURE;    

    // use these only if you have special section requirements not handled  
    // by other APIs    
    STDMETHOD (GetSectionCreate) (
        const char *name,   
        DWORD flags,    
        HCEESECTION *section) PURE; 

    STDMETHOD (GetSectionDataLen) (
        HCEESECTION section,    
        ULONG *dataLen) PURE;   

    STDMETHOD (GetSectionBlock) (
        HCEESECTION section,    
        ULONG len,  
        ULONG align=1,  
        void **ppBytes=0) PURE; 

    STDMETHOD (TruncateSection) (
        HCEESECTION section,    
        ULONG len) PURE;  

    STDMETHOD (GenerateCeeMemoryImage) (
        void **ppImage) PURE;

    STDMETHOD (ComputePointer) (   
        HCEESECTION section,    
        ULONG RVA,                          // [IN] RVA for method to return    
        UCHAR **lpBuffer) PURE;             // [OUT] Returned buffer    

};

//*****************************************************************************
//*****************************************************************************
//
// End of CeeGen declarations.
//
//*****************************************************************************

//*****************************************************************************
//*****************************************************************************
//
// CorModule interfaces for generating in-memory modules
//
//*****************************************************************************
//*****************************************************************************

typedef enum {
    CORMODULE_MATCH             =   0x00,   // find an existing module that matches interfaces supported    
    CORMODULE_NEW               =   0x01,   // always create a new module and interfaces    
} ICorModuleInitializeFlags;

//-------------------------------------
//--- ICorModule
//-------------------------------------
// {2629F8E1-95E5-11d2-9C56-00A0C9B7CC45}
EXTERN_GUID(IID_ICorModule, 0x2629f8e1, 0x95e5, 0x11d2, 0x9c, 0x56, 0x0, 0xa0, 0xc9, 0xb7, 0xcc, 0x45);

DECLARE_INTERFACE_(ICorModule, IUnknown)
{
    STDMETHOD (Initialize) (
        DWORD flags,                        // [IN] flags to control emitter returned   
        REFIID riidCeeGen,                  // [IN] type of cee generator to initialize with    
        REFIID riidEmitter) PURE;           // [IN] type of emitter to initialize with

    STDMETHOD (GetCeeGen) ( 
        ICeeGen **pCeeGen) PURE;            // [OUT] cee generator

    STDMETHOD (GetMetaDataEmit) (   
        IMetaDataEmit **pEmitter) PURE;     // [OUT] emitter    
};

//*****************************************************************************
//*****************************************************************************
//
// End of CorModule declarations.
//
//*****************************************************************************

//**********************************************************************
//**********************************************************************
//--- IMetaDataTables
//-------------------------------------
// This API isn't big endian friendly since it indexes directly into the memory that
// is stored in little endian format.
// {D8F579AB-402D-4b8e-82D9-5D63B1065C68}
EXTERN_GUID(IID_IMetaDataTables, 0xd8f579ab, 0x402d, 0x4b8e, 0x82, 0xd9, 0x5d, 0x63, 0xb1, 0x6, 0x5c, 0x68);

DECLARE_INTERFACE_(IMetaDataTables, IUnknown)
{
    STDMETHOD (GetStringHeapSize) (    
        ULONG   *pcbStrings) PURE;          // [OUT] Size of the string heap.

    STDMETHOD (GetBlobHeapSize) (    
        ULONG   *pcbBlobs) PURE;            // [OUT] Size of the Blob heap.

    STDMETHOD (GetGuidHeapSize) (    
        ULONG   *pcbGuids) PURE;            // [OUT] Size of the Guid heap.

    STDMETHOD (GetUserStringHeapSize) (  
        ULONG   *pcbBlobs) PURE;            // [OUT] Size of the User String heap.

    STDMETHOD (GetNumTables) (    
        ULONG   *pcTables) PURE;            // [OUT] Count of tables.

    STDMETHOD (GetTableIndex) (   
        ULONG   token,                      // [IN] Token for which to get table index.
        ULONG   *pixTbl) PURE;              // [OUT] Put table index here.

    STDMETHOD (GetTableInfo) (    
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   *pcbRow,                    // [OUT] Size of a row, bytes.
        ULONG   *pcRows,                    // [OUT] Number of rows.
        ULONG   *pcCols,                    // [OUT] Number of columns in each row.
        ULONG   *piKey,                     // [OUT] Key column, or -1 if none.
        const char **ppName) PURE;          // [OUT] Name of the table.

    STDMETHOD (GetColumnInfo) (   
        ULONG   ixTbl,                      // [IN] Which Table
        ULONG   ixCol,                      // [IN] Which Column in the table
        ULONG   *poCol,                     // [OUT] Offset of the column in the row.
        ULONG   *pcbCol,                    // [OUT] Size of a column, bytes.
        ULONG   *pType,                     // [OUT] Type of the column.
        const char **ppName) PURE;          // [OUT] Name of the Column.

    STDMETHOD (GetCodedTokenInfo) (   
        ULONG   ixCdTkn,                    // [IN] Which kind of coded token.
        ULONG   *pcTokens,                  // [OUT] Count of tokens.
        ULONG   **ppTokens,                 // [OUT] List of tokens.
        const char **ppName) PURE;          // [OUT] Name of the CodedToken.

    STDMETHOD (GetRow) (      
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   rid,                        // [IN] Which row.
        void    **ppRow) PURE;              // [OUT] Put pointer to row here.

    STDMETHOD (GetColumn) (   
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   ixCol,                      // [IN] Which column.
        ULONG   rid,                        // [IN] Which row.
        ULONG   *pVal) PURE;                // [OUT] Put the column contents here.

    STDMETHOD (GetString) (   
        ULONG   ixString,                   // [IN] Value from a string column.
        const char **ppString) PURE;        // [OUT] Put a pointer to the string here.

    STDMETHOD (GetBlob) (     
        ULONG   ixBlob,                     // [IN] Value from a blob column.
        ULONG   *pcbData,                   // [OUT] Put size of the blob here.
        const void **ppData) PURE;          // [OUT] Put a pointer to the blob here.

    STDMETHOD (GetGuid) (     
        ULONG   ixGuid,                     // [IN] Value from a guid column.
        const GUID **ppGUID) PURE;          // [OUT] Put a pointer to the GUID here.

    STDMETHOD (GetUserString) (   
        ULONG   ixUserString,               // [IN] Value from a UserString column.
        ULONG   *pcbData,                   // [OUT] Put size of the UserString here.
        const void **ppData) PURE;          // [OUT] Put a pointer to the UserString here.

    STDMETHOD (GetNextString) (   
        ULONG   ixString,                   // [IN] Value from a string column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the next string here.

    STDMETHOD (GetNextBlob) (     
        ULONG   ixBlob,                     // [IN] Value from a blob column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the netxt blob here.

    STDMETHOD (GetNextGuid) (     
        ULONG   ixGuid,                     // [IN] Value from a guid column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the next guid here.

    STDMETHOD (GetNextUserString) (   
        ULONG   ixUserString,               // [IN] Value from a UserString column.
        ULONG   *pNext) PURE;               // [OUT] Put the index of the next user string here.

    // Interface is sealed.

};
// This API isn't big endian friendly since it indexes directly into the memory that
// is stored in little endian format.
// {BADB5F70-58DA-43a9-A1C6-D74819F19B15}
EXTERN_GUID(IID_IMetaDataTables2, 0xbadb5f70, 0x58da, 0x43a9, 0xa1, 0xc6, 0xd7, 0x48, 0x19, 0xf1, 0x9b, 0x15);

DECLARE_INTERFACE_(IMetaDataTables2, IMetaDataTables)
{
    STDMETHOD (GetMetaDataStorage) (        //@todo: name?
        const void **ppvMd,                 // [OUT] put pointer to MD section here (aka, 'BSJB').
        ULONG   *pcbMd) PURE;               // [OUT] put size of the stream here.

    STDMETHOD (GetMetaDataStreamInfo) (     // Get info about the MD stream.
        ULONG   ix,                         // [IN] Stream ordinal desired.
        const char **ppchName,              // [OUT] put pointer to stream name here.
        const void **ppv,                   // [OUT] put pointer to MD stream here.
        ULONG   *pcb) PURE;                 // [OUT] put size of the stream here.

}; // IMetaDataTables2

#ifdef _DEFINE_META_DATA_META_CONSTANTS
#ifndef _META_DATA_META_CONSTANTS_DEFINED
#define _META_DATA_META_CONSTANTS_DEFINED
const unsigned int iRidMax          = 63;
const unsigned int iCodedToken      = 64;   // base of coded tokens.
const unsigned int iCodedTokenMax   = 95;
const unsigned int iSHORT           = 96;   // fixed types.
const unsigned int iUSHORT          = 97;
const unsigned int iLONG            = 98;
const unsigned int iULONG           = 99;
const unsigned int iBYTE            = 100;
const unsigned int iSTRING          = 101;  // pool types.
const unsigned int iGUID            = 102;
const unsigned int iBLOB            = 103;

inline int IsRidType(ULONG ix) { return ix <= iRidMax; }
inline int IsCodedTokenType(ULONG ix) { return (ix >= iCodedToken) && (ix <= iCodedTokenMax); }
inline int IsRidOrToken(ULONG ix) { return ix <= iCodedTokenMax; }
inline int IsHeapType(ULONG ix) { return ix >= iSTRING; }
inline int IsFixedType(ULONG ix) { return (ix < iSTRING) && (ix > iCodedTokenMax); }
#endif
#endif

//**********************************************************************
// End of IMetaDataTables.
//**********************************************************************
// Gets the dependancies of a native image. If these change, then
// the native image cannot be used.
//
// IMetaDataImport::GetAssemblyRefProps() can be used to obtain information about
// the mdAssemblyRefs.
//*****************************************************************************

// {814C9E35-3F3F-4975-977A-371F0A878AC7}
EXTERN_GUID(IID_INativeImageDependency, 0x814c9e35, 0x3f3f, 0x4975, 0x97, 0x7a, 0x37, 0x1f, 0xa, 0x87, 0x8a, 0xc7);

struct CORCOMPILE_ASSEMBLY_SIGNATURE;
typedef GUID CORCOMPILE_NGEN_SIGNATURE;

DECLARE_INTERFACE_(INativeImageDependency, IUnknown)
{
    // Get the referenced assembly
    STDMETHOD (GetILAssemblyRef) (
        mdAssemblyRef * pAssemblyRef        // [OUT]
        ) PURE;

    // Get the post-policy assembly actually used
    STDMETHOD (GetILAssemblyDef) (
        mdAssemblyRef * ppAssemblyDef,          // [OUT]
        CORCOMPILE_ASSEMBLY_SIGNATURE * pSign   // [OUT]
        ) PURE;

    // Get the native image corresponding to GetILAssemblyDef() IF
    // there is a hard-bound (directly-referenced) native dependancy
    //
    // We do not need the configStrig because configStrings have to
    // be an exact part. Any partial matches are factored out into GetConfigMask()
    STDMETHOD (GetNativeAssemblyDef) (
        CORCOMPILE_NGEN_SIGNATURE * pNativeSign // [OUT] INVALID_NGEN_SIGNATURE if there is no hard-bound dependancy
        ) PURE;
};

//*****************************************************************************
//
// Fusion uses IFusionNativeImageInfo to obtain (and cache) informaton
// about a native image being installed into the native image cache.
// This allows Fusion to bind directly to native images
// without requiring (expensively) binding to the IL assembly first.
//
// IMetaDataAssemblyImport can be queried for this interface
//
//*****************************************************************************
// {0EA273D0-B4DA-4008-A60D-8D6EFFDD6E91}
EXTERN_GUID(IID_INativeImageInstallInfo, 0xea273d0, 0xb4da, 0x4008, 0xa6, 0xd, 0x8d, 0x6e, 0xff, 0xdd, 0x6e, 0x91);

DECLARE_INTERFACE_(INativeImageInstallInfo, IUnknown)
{
    // Signature of the ngen image
    // This matches the argument type of INativeImageDependency::GetNativeAssemblyDef
    
    STDMETHOD (GetSignature) (
        CORCOMPILE_NGEN_SIGNATURE * pNgenSign // [OUT]
        ) PURE;

    // Signature of the source IL assembly. This can be used to
    // verify that the IL image matches a candidate ngen image.
    // This matches the argument type of IAssemblyRuntimeSignature::CheckSignature
    //

    STDMETHOD (GetILSignature) (
        CORCOMPILE_ASSEMBLY_SIGNATURE * pILSign // [OUT]
        ) PURE;

    // Returns the equivalent of ISNAssemblySignature::GetSNAssemblySignature,
    // except for unsigned assemblies where the GetSNAssemblySignature will fail.
    // This can be used for matching the IL assembly in the GAC when the
    // native-image is generated/installed.
    //
    // Sets *pcbSig and returns ERROR_INSUFFICIENT_BUFFER for insufficient buffer.
    // Returns CORSEC_E_MISSING_STRONGNAME if the IL assembly is not strongly-named
    
    STDMETHOD (GetILStrongSignature) (
        BYTE        *pbSig,                 // [IN, OUT] Buffer to write signature
        DWORD       *pcbSig                 // [IN, OUT] Size of buffer, bytes written
        ) PURE;

    // Information about the contents/dependancies/assumptions of NativeImage
    // All of this information has to match for the current NativeImage to
    // be valid
    // Sets *pdwLength and returns ERROR_INSUFFICIENT_BUFFER for 
    // insufficient szConfigString

    STDMETHOD (GetConfigString) (
        __out_ecount_part_opt (*pdwLength, *pdwLength) LPWSTR szConfigString, // [OUT]
        __inout DWORD * pdwLength                   // [IN|OUT] - Number of WCHARs written including terminating NULL
        ) PURE;

    // A partial match is allowed for the current NativeImage to be valid
    
    STDMETHOD (GetConfigMask) (
        DWORD * pConfigMask // [OUT]
        ) PURE;

    // Cache data that the CLR will need to determine if the NativeImage
    // can be used (after the GetConfigString checks are satisfied)
    // Sets *pdwBufferSize and returns ERROR_INSUFFICIENT_BUFFER for insufficient ppbBuffer

    STDMETHOD (GetEvaluationDataToCache) (
        BYTE * ppbBuffer,                   // [OUT]
        DWORD * pdwBufferSize               // [IN|OUT] Total number of bytes written to *ppbBuffer
        ) PURE;

    //
    // Dependancy assemblies. The native image is only valid
    // if the dependancies have not changed.
    //

    STDMETHOD (EnumDependencies) (
        HCORENUM * phEnum,                  // [IN/OUT] - Pointer to the enum
        INativeImageDependency *rDeps[],    // [OUT]
        ULONG cMax,                         // [IN] Max dependancies to enumerate in this iteration
        DWORD * pdwCount                    // [OUT] - Number of dependancies actually enumerated
        ) PURE;
};

//*****************************************************************************
//
// Runtime callback made by Fusion into the CLR to determine if the NativeAssembly
// can be used. The pUnkBindSink argument of CAssemblyName::BindToObject() can
// be queried for this interface
//
//*****************************************************************************
// {065AA013-9BDC-447c-922F-FEE929908447}
EXTERN_GUID(IID_INativeImageEvaluate, 0x65aa013, 0x9bdc, 0x447c, 0x92, 0x2f, 0xfe, 0xe9, 0x29, 0x90, 0x84, 0x47);

interface IAssembly;

DECLARE_INTERFACE_(INativeImageEvaluate, IUnknown)
{
    // This will be called before the assemblies are actually loaded.
    //
    // Returns S_FALSE if the native-image cannot be used.
    
    STDMETHOD (Evaluate) (
        IAssembly *pILAssembly,             // [IN] IL assembly in question
        IAssembly *pNativeAssembly,         // [IN] NGen image we are trying to use for pILAssembly 
        BYTE * pbCachedData,                // [IN] Data cached when the native-image was generated
        DWORD dwDataSize                    // [IN] Size of the pbCachedData buffer
        ) PURE;
};

//**********************************************************************

//**********************************************************************
//
// Predefined CustomAttribute and structures for these custom value
//
//**********************************************************************

//
// Native Link method custom value definitions. This is for N-direct support.
//

#define COR_NATIVE_LINK_CUSTOM_VALUE        L"COMPLUS_NativeLink"   
#define COR_NATIVE_LINK_CUSTOM_VALUE_ANSI   "COMPLUS_NativeLink"    

// count of chars for COR_NATIVE_LINK_CUSTOM_VALUE(_ANSI)
#define COR_NATIVE_LINK_CUSTOM_VALUE_CC     18  

#include <pshpack1.h>
typedef struct 
{
    BYTE        m_linkType;       // see CorNativeLinkType below    
    BYTE        m_flags;          // see CorNativeLinkFlags below   
    mdMemberRef m_entryPoint;     // member ref token giving entry point, format is lib:entrypoint  
} COR_NATIVE_LINK;
#include <poppack.h>

typedef enum 
{
    nltNone         = 1,    // none of the keywords are specified   
    nltAnsi         = 2,    // ansi keyword specified   
    nltUnicode      = 3,    // unicode keyword specified    
    nltAuto         = 4,    // auto keyword specified   
    nltOle          = 5,    // ole keyword specified  
    nltMaxValue     = 7,    // used so we can assert how many bits are required for this enum
} CorNativeLinkType;

typedef enum 
{
    nlfNone         = 0x00,     // no flags 
    nlfLastError    = 0x01,     // setLastError keyword specified   
    nlfNoMangle     = 0x02,     // nomangle keyword specified
    nlfMaxValue     = 0x03,     // used so we can assert how many bits are required for this enum
} CorNativeLinkFlags;


#define COR_DUAL_CUSTOM_VALUE L"IsDual"
#define COR_DUAL_CUSTOM_VALUE_ANSI "IsDual"

#define COR_DISPATCH_CUSTOM_VALUE L"DISPID"
#define COR_DISPATCH_CUSTOM_VALUE_ANSI "DISPID"

//
// Security custom value definitions (these are all deprecated).
//

#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE L"SecPermReq_Reqd"
#define COR_PERM_REQUEST_REQD_CUSTOM_VALUE_ANSI "SecPermReq_Reqd"

#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE L"SecPermReq_Opt"
#define COR_PERM_REQUEST_OPT_CUSTOM_VALUE_ANSI "SecPermReq_Opt"

#define COR_PERM_REQUEST_REFUSE_CUSTOM_VALUE L"SecPermReq_Refuse"
#define COR_PERM_REQUEST_REFUSE_CUSTOM_VALUE_ANSI "SecPermReq_Refuse"

//
// Base class for security custom attributes.
//

#define COR_BASE_SECURITY_ATTRIBUTE_CLASS L"System.Security.Permissions.SecurityAttribute"
#define COR_BASE_SECURITY_ATTRIBUTE_CLASS_ANSI "System.Security.Permissions.SecurityAttribute"

//
// Name of custom attribute used to indicate that per-call security checks should
// be disabled for P/Invoke calls.
//

#define COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE L"System.Security.SuppressUnmanagedCodeSecurityAttribute"
#define COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE_ANSI "System.Security.SuppressUnmanagedCodeSecurityAttribute"

//
// Name of custom attribute tagged on module to indicate it contains
// unverifiable code.
//

#define COR_UNVER_CODE_ATTRIBUTE L"System.Security.UnverifiableCodeAttribute"
#define COR_UNVER_CODE_ATTRIBUTE_ANSI "System.Security.UnverifiableCodeAttribute"

//
// Name of custom attribute indicating that a method requires a security object
// slot on the caller's stack.
//

#define COR_REQUIRES_SECOBJ_ATTRIBUTE L"System.Security.DynamicSecurityMethodAttribute"
#define COR_REQUIRES_SECOBJ_ATTRIBUTE_ANSI "System.Security.DynamicSecurityMethodAttribute"

#define COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE L"System.Runtime.CompilerServices.DiscardableAttribute"
#define COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE_ASNI "System.Runtime.CompilerServices.DiscardableAttribute"


#ifdef __cplusplus
}

//*****************************************************************************
//*****************************************************************************
//
// C O M +   s i g n a t u r e   s u p p o r t  
//
//*****************************************************************************
//*****************************************************************************

#ifndef FORCEINLINE
 #if _MSC_VER < 1200
   #define FORCEINLINE inline
 #else
   #define FORCEINLINE __forceinline
 #endif
#endif

// return true if it is a primitive type, i.e. only need to store CorElementType
FORCEINLINE int CorIsPrimitiveType(CorElementType elementtype)
{
    return (elementtype < ELEMENT_TYPE_PTR || elementtype == ELEMENT_TYPE_I || elementtype == ELEMENT_TYPE_U);    
}


// Return true if element type is a modifier, i.e. ELEMENT_TYPE_MODIFIER bits are 
// turned on. For now, it is checking for ELEMENT_TYPE_PTR and ELEMENT_TYPE_BYREF
// as well. This will be removed when we turn on ELEMENT_TYPE_MODIFIER bits for 
// these two enum members.
//
FORCEINLINE int CorIsModifierElementType(CorElementType elementtype)
{
    if (elementtype == ELEMENT_TYPE_PTR || elementtype == ELEMENT_TYPE_BYREF)   
        return 1;   
    return  (elementtype & ELEMENT_TYPE_MODIFIER);  
}

// Given a compress byte (*pData), return the size of the uncompressed data.
inline ULONG CorSigUncompressedDataSize(
    PCCOR_SIGNATURE pData)
{
    if ((*pData & 0x80) == 0)
        return 1;
    else if ((*pData & 0xC0) == 0x80)
        return 2;
    else
        return 4;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given a compressed integer(*pData), expand the compressed int to *pDataOut.
// Return value is the number of bytes that the integer occupies in the compressed format
// It is caller's responsibility to ensure pDataOut has at least 4 bytes to be written to.
//
// This function returns -1 if pass in with an incorrectly compressed data, such as
// (*pBytes & 0xE0) == 0XE0.
/////////////////////////////////////////////////////////////////////////////////////////////
inline ULONG CorSigUncompressBigData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    ULONG res;

    // 1 byte data is handled in CorSigUncompressData   
    //  _ASSERTE(*pData & 0x80);    

    // Medium.  
    if ((*pData & 0xC0) == 0x80)  // 10?? ????  
    {   
        res = (ULONG)((*pData++ & 0x3f) << 8);
        res |= *pData++;
    }   
    else // 110? ???? 
    {
        res = (*pData++ & 0x1f) << 24;
        res |= *pData++ << 16;
        res |= *pData++ << 8;
        res |= *pData++;
    }
    return res; 
}
FORCEINLINE ULONG CorSigUncompressData(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    // Handle smallest data inline. 
    if ((*pData & 0x80) == 0x00)        // 0??? ????    
        return *pData++;    
    return CorSigUncompressBigData(pData);  
}

inline HRESULT CorSigUncompressData(      // return S_OK or E_BADIMAGEFORMAT if the signature is bad 
    PCCOR_SIGNATURE pData,              // [IN] compressed data
    DWORD       len,                    // [IN] length of the signature
    ULONG       *pDataOut,              // [OUT] the expanded *pData
    ULONG       *pDataLen)              // [OUT] length of the expanded *pData    
{   
    HRESULT hr = S_OK;        
    BYTE const  *pBytes = reinterpret_cast<BYTE const*>(pData); 

    // Smallest.    
    if ((*pBytes & 0x80) == 0x00)       // 0??? ????    
    {   
        if (len < 1)
            hr = META_E_BAD_SIGNATURE;
        else
        {
            *pDataOut = *pBytes;    
            *pDataLen = 1; 
        }
    }    
    // Medium.  
    else if ((*pBytes & 0xC0) == 0x80)  // 10?? ????    
    {   
        if (len < 2)
            hr = META_E_BAD_SIGNATURE;
        else
        {
            *pDataOut = (ULONG)(((*pBytes & 0x3f) << 8 | *(pBytes+1)));    
            *pDataLen = 2; 
        }
    }   
    else if ((*pBytes & 0xE0) == 0xC0)      // 110? ????    
    {   
        if (len < 4)
            hr = META_E_BAD_SIGNATURE;
        else
        {
            *pDataOut = (ULONG)(((*pBytes & 0x1f) << 24 | *(pBytes+1) << 16 | *(pBytes+2) << 8 | *(pBytes+3)));  
            *pDataLen = 4; 
        }
    }   
    else // We don't recognize this encoding
        hr = META_E_BAD_SIGNATURE;
    
    return hr;  

}

inline ULONG CorSigUncompressData(      // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    ULONG       *pDataOut)              // [OUT] the expanded *pData    
{   

    ULONG dwSizeOfData = 0;

    // We don't know how big the signature is, so we'll just say that it's big enough
    if (FAILED(CorSigUncompressData(pData, 0xff, pDataOut, &dwSizeOfData)))
        return (ULONG)-1;


    return dwSizeOfData;
}




const static mdToken g_tkCorEncodeToken[4] ={mdtTypeDef, mdtTypeRef, mdtTypeSpec, mdtBaseType};

// uncompress a token
inline mdToken CorSigUncompressToken(   // return the token.    
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    mdToken     tk; 
    mdToken     tkType; 

    tk = CorSigUncompressData(pData);   
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    return tk;  
}


inline ULONG CorSigUncompressToken(     // return number of bytes of that compressed data occupied in pData 
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    mdToken     *pToken)                // [OUT] the expanded *pData    
{
    ULONG       cb; 
    mdToken     tk; 
    mdToken     tkType; 

    cb = CorSigUncompressData(pData, (ULONG *)&tk); 
    tkType = g_tkCorEncodeToken[tk & 0x3];  
    tk = TokenFromRid(tk >> 2, tkType); 
    *pToken = tk;   
    return cb;  
}

inline HRESULT CorSigUncompressToken(      
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    DWORD       dwLen,                  // [IN] Remaining length of sigature
    mdToken     *pToken,                // [OUT] the expanded *pData
    DWORD       *dwTokenLength)         // [OUT] The length of the token in the sigature    
{
    mdToken     tk; 
    mdToken     tkType; 

    HRESULT hr = CorSigUncompressData(pData, dwLen, (ULONG *)&tk, dwTokenLength);

    if (SUCCEEDED(hr))
    {
        tkType = g_tkCorEncodeToken[tk & 0x3];  
        tk = TokenFromRid(tk >> 2, tkType); 
        *pToken = tk;   
    }
    return hr;  
}



FORCEINLINE ULONG CorSigUncompressCallingConv(
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return *pData++;    
}

FORCEINLINE HRESULT CorSigUncompressCallingConv(
    PCCOR_SIGNATURE pData,              // [IN] Signature
    DWORD           dwLen,              // [IN] Length of signature
    ULONG           *data)             // [OUT] compressed data 
{
    if (dwLen > 0)
    {
        *data = *pData;
        return S_OK;
    }
    else
        return META_E_BAD_SIGNATURE;
}


enum {
    SIGN_MASK_ONEBYTE  = 0xffffffc0,        // Mask the same size as the missing bits.  
    SIGN_MASK_TWOBYTE  = 0xffffe000,        // Mask the same size as the missing bits.  
    SIGN_MASK_FOURBYTE = 0xf0000000,        // Mask the same size as the missing bits.  
};

// uncompress a signed integer
inline ULONG CorSigUncompressSignedInt( // return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    int         *pInt)                  // [OUT] the expanded *pInt 
{
    ULONG       cb; 
    ULONG       ulSigned;   
    ULONG       iData;  

    cb = CorSigUncompressData(pData, &iData);   
    if (cb == (ULONG) -1) return cb;
    ulSigned = iData & 0x1; 
    iData = iData >> 1; 
    if (ulSigned)   
    {   
        if (cb == 1)    
        {   
            iData |= SIGN_MASK_ONEBYTE; 
        }   
        else if (cb == 2)   
        {   
            iData |= SIGN_MASK_TWOBYTE; 
        }   
        else    
        {   
            iData |= SIGN_MASK_FOURBYTE;    
        }   
    }   
    *pInt = (int)iData;  
    return cb;  
}


// uncompress encoded element type
FORCEINLINE CorElementType CorSigUncompressElementType(//Element type
    PCCOR_SIGNATURE &pData)             // [IN,OUT] compressed data 
{
    return (CorElementType)*pData++;    
}

inline ULONG CorSigUncompressElementType(// return number of bytes of that compressed data occupied in pData
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    CorElementType *pElementType)       // [OUT] the expanded *pData    
{   
    *pElementType = (CorElementType)(*pData & 0x7f);    
    return 1;   
}


/////////////////////////////////////////////////////////////////////////////////////////////
//
// Given an uncompressed unsigned integer (iLen), Store it to pDataOut in a compressed format.
// Return value is the number of bytes that the integer occupies in the compressed format.
// It is caller's responsibilityt to ensure *pDataOut has at least 4 bytes to write to.
//
// Note that this function returns -1 if iLen is too big to be compressed. We currently can
// only represent to 0x1FFFFFFF.
//
/////////////////////////////////////////////////////////////////////////////////////////////
inline ULONG CorSigCompressData(        // return number of bytes that compressed form of iLen will take    
    ULONG       iLen,                   // [IN] given uncompressed data 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{   
    BYTE        *pBytes = reinterpret_cast<BYTE *>(pDataOut);   

    if (iLen <= 0x7F)   
    {   
        *pBytes = BYTE(iLen);    
        return 1;   
    }   

    if (iLen <= 0x3FFF) 
    {   
        *pBytes     = BYTE((iLen >> 8) | 0x80);   
        *(pBytes+1) = BYTE(iLen & 0xff);
        return 2;   
    }   

    if (iLen <= 0x1FFFFFFF) 
    {   
        *pBytes     = BYTE((iLen >> 24) | 0xC0);  
        *(pBytes+1) = BYTE((iLen >> 16) & 0xff);
        *(pBytes+2) = BYTE((iLen >> 8)  & 0xff);
        *(pBytes+3) = BYTE(iLen & 0xff);
        return 4;   
    }   
    return (ULONG) -1;  

}

// compress a token
// The least significant bit of the first compress byte will indicate the token type.
//
inline ULONG CorSigCompressToken(       // return number of bytes that compressed form of iLen will take    
    mdToken     tk,                     // [IN] given token 
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    RID         rid = RidFromToken(tk); 
    ULONG32     ulTyp = TypeFromToken(tk);  

    if (rid > 0x3FFFFFF)    
        // token is too big to be compressed    
        return (ULONG) -1;  

    rid = (rid << 2);   

    // TypeDef is encoded with low bits 00  
    // TypeRef is encoded with low bits 01  
    // TypeSpec is encoded with low bits 10    
    // BaseType is encoded with low bit 11
    //
    if (ulTyp == g_tkCorEncodeToken[1]) 
    {   
        // make the last two bits 01    
        rid |= 0x1; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[2])    
    {   
        // make last two bits 0 
        rid |= 0x2; 
    }   
    else if (ulTyp == g_tkCorEncodeToken[3])
    {
        rid |= 0x3;
    }
    return CorSigCompressData((ULONG)rid, pDataOut);   
}

// compress a signed integer
// The least significant bit of the first compress byte will be the signed bit.
//
inline ULONG CorSigCompressSignedInt(   // return number of bytes that compressed form of iData will take   
    int         iData,                  // [IN] given integer   
    void        *pDataOut)              // [OUT] buffer where iLen will be compressed and stored.   
{
    ULONG       isSigned = 0;   

    if (iData < 0)  
        isSigned = 0x1; 

    if ((iData & SIGN_MASK_ONEBYTE) == 0 || (iData & SIGN_MASK_ONEBYTE) == SIGN_MASK_ONEBYTE)   
    {   
        iData &= ~SIGN_MASK_ONEBYTE;    
    }   
    else if ((iData & SIGN_MASK_TWOBYTE) == 0 || (iData & SIGN_MASK_TWOBYTE) == SIGN_MASK_TWOBYTE)  
    {   
        iData &= ~SIGN_MASK_TWOBYTE;    
    }   

    else if ((iData & SIGN_MASK_FOURBYTE) == 0 || (iData & SIGN_MASK_FOURBYTE) == SIGN_MASK_FOURBYTE)   
    {   
        iData &= ~SIGN_MASK_FOURBYTE;   
    }   
    else    
    {   
        // out of compressable range    
        return (ULONG) -1;  
    }   
    iData = (int) (iData << 1 | isSigned);  
    return CorSigCompressData((ULONG)iData, pDataOut); 
}



// uncompress encoded element type
inline ULONG CorSigCompressElementType(// return number of bytes of that compressed data occupied in pData
    CorElementType et,                 // [OUT] the expanded *pData 
    void        *pData)                // [IN] compressed data  
{   
    BYTE        *pBytes = (BYTE *)(pData);  

    *pBytes = BYTE(et);   
    return 1;   

}

// Compress a pointer (used for internal element types only, never for persisted
// signatures).
inline ULONG CorSigCompressPointer(     // return number of bytes of that compressed data occupied
    void        *pvPointer,             // [IN] given uncompressed data 
    void        *pData)                 // [OUT] buffer where iLen will be compressed and stored.   
{   
    *((void* UNALIGNED *)pData) = pvPointer;
    return sizeof(void*);
}

// Uncompress a pointer (see above for comments).
inline ULONG CorSigUncompressPointer(   // return number of bytes of that compressed data occupied
    PCCOR_SIGNATURE pData,              // [IN] compressed data 
    void            **ppvPointer)       // [OUT] the expanded *pData    
{   
    *ppvPointer = *(void* UNALIGNED *)pData;
    return sizeof(void*);
}

#endif  // __cplusplus

#endif // _COR_H_
// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\clrdata.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for clrdata.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __clrdata_h__
#define __clrdata_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICLRDataTarget_FWD_DEFINED__
#define __ICLRDataTarget_FWD_DEFINED__
typedef interface ICLRDataTarget ICLRDataTarget;
#endif 	/* __ICLRDataTarget_FWD_DEFINED__ */


#ifndef __ICLRDataTarget2_FWD_DEFINED__
#define __ICLRDataTarget2_FWD_DEFINED__
typedef interface ICLRDataTarget2 ICLRDataTarget2;
#endif 	/* __ICLRDataTarget2_FWD_DEFINED__ */


#ifndef __ICLRMetadataLocator_FWD_DEFINED__
#define __ICLRMetadataLocator_FWD_DEFINED__
typedef interface ICLRMetadataLocator ICLRMetadataLocator;
#endif 	/* __ICLRMetadataLocator_FWD_DEFINED__ */


#ifndef __ICLRDataEnumMemoryRegionsCallback_FWD_DEFINED__
#define __ICLRDataEnumMemoryRegionsCallback_FWD_DEFINED__
typedef interface ICLRDataEnumMemoryRegionsCallback ICLRDataEnumMemoryRegionsCallback;
#endif 	/* __ICLRDataEnumMemoryRegionsCallback_FWD_DEFINED__ */


#ifndef __ICLRDataEnumMemoryRegions_FWD_DEFINED__
#define __ICLRDataEnumMemoryRegions_FWD_DEFINED__
typedef interface ICLRDataEnumMemoryRegions ICLRDataEnumMemoryRegions;
#endif 	/* __ICLRDataEnumMemoryRegions_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_clrdata_0000 */
/* [local] */ 






typedef ULONG64 CLRDATA_ADDRESS;

STDAPI CLRDataCreateInstance(REFIID iid, ICLRDataTarget* target, void** iface);
typedef HRESULT (STDAPICALLTYPE* PFN_CLRDataCreateInstance)(REFIID iid, ICLRDataTarget* target, void** iface);


extern RPC_IF_HANDLE __MIDL_itf_clrdata_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_clrdata_0000_v0_0_s_ifspec;

#ifndef __ICLRDataTarget_INTERFACE_DEFINED__
#define __ICLRDataTarget_INTERFACE_DEFINED__

/* interface ICLRDataTarget */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRDataTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3E11CCEE-D08B-43e5-AF01-32717A64DA03")
    ICLRDataTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMachineType( 
            /* [out] */ ULONG32 *machineType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPointerSize( 
            /* [out] */ ULONG32 *pointerSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageBase( 
            /* [string][in] */ LPCWSTR imagePath,
            /* [out] */ CLRDATA_ADDRESS *baseAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadVirtual( 
            /* [in] */ CLRDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteVirtual( 
            /* [in] */ CLRDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTLSValue( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [out] */ CLRDATA_ADDRESS *value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTLSValue( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [in] */ CLRDATA_ADDRESS value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadID( 
            /* [out] */ ULONG32 *threadID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadContext( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Request( 
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataTarget * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataTarget * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineType )( 
            ICLRDataTarget * This,
            /* [out] */ ULONG32 *machineType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointerSize )( 
            ICLRDataTarget * This,
            /* [out] */ ULONG32 *pointerSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageBase )( 
            ICLRDataTarget * This,
            /* [string][in] */ LPCWSTR imagePath,
            /* [out] */ CLRDATA_ADDRESS *baseAddress);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVirtual )( 
            ICLRDataTarget * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesRead);
        
        HRESULT ( STDMETHODCALLTYPE *WriteVirtual )( 
            ICLRDataTarget * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesWritten);
        
        HRESULT ( STDMETHODCALLTYPE *GetTLSValue )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [out] */ CLRDATA_ADDRESS *value);
        
        HRESULT ( STDMETHODCALLTYPE *SetTLSValue )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [in] */ CLRDATA_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadID )( 
            ICLRDataTarget * This,
            /* [out] */ ULONG32 *threadID);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer);
        
        END_INTERFACE
    } ICLRDataTargetVtbl;

    interface ICLRDataTarget
    {
        CONST_VTBL struct ICLRDataTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataTarget_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataTarget_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataTarget_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataTarget_GetMachineType(This,machineType)	\
    (This)->lpVtbl -> GetMachineType(This,machineType)

#define ICLRDataTarget_GetPointerSize(This,pointerSize)	\
    (This)->lpVtbl -> GetPointerSize(This,pointerSize)

#define ICLRDataTarget_GetImageBase(This,imagePath,baseAddress)	\
    (This)->lpVtbl -> GetImageBase(This,imagePath,baseAddress)

#define ICLRDataTarget_ReadVirtual(This,address,buffer,bytesRequested,bytesRead)	\
    (This)->lpVtbl -> ReadVirtual(This,address,buffer,bytesRequested,bytesRead)

#define ICLRDataTarget_WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)	\
    (This)->lpVtbl -> WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)

#define ICLRDataTarget_GetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> GetTLSValue(This,threadID,index,value)

#define ICLRDataTarget_SetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> SetTLSValue(This,threadID,index,value)

#define ICLRDataTarget_GetCurrentThreadID(This,threadID)	\
    (This)->lpVtbl -> GetCurrentThreadID(This,threadID)

#define ICLRDataTarget_GetThreadContext(This,threadID,contextFlags,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,threadID,contextFlags,contextSize,context)

#define ICLRDataTarget_SetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,threadID,contextSize,context)

#define ICLRDataTarget_Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)	\
    (This)->lpVtbl -> Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetMachineType_Proxy( 
    ICLRDataTarget * This,
    /* [out] */ ULONG32 *machineType);


void __RPC_STUB ICLRDataTarget_GetMachineType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetPointerSize_Proxy( 
    ICLRDataTarget * This,
    /* [out] */ ULONG32 *pointerSize);


void __RPC_STUB ICLRDataTarget_GetPointerSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetImageBase_Proxy( 
    ICLRDataTarget * This,
    /* [string][in] */ LPCWSTR imagePath,
    /* [out] */ CLRDATA_ADDRESS *baseAddress);


void __RPC_STUB ICLRDataTarget_GetImageBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_ReadVirtual_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ CLRDATA_ADDRESS address,
    /* [length_is][size_is][out] */ BYTE *buffer,
    /* [in] */ ULONG32 bytesRequested,
    /* [out] */ ULONG32 *bytesRead);


void __RPC_STUB ICLRDataTarget_ReadVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_WriteVirtual_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ CLRDATA_ADDRESS address,
    /* [size_is][in] */ BYTE *buffer,
    /* [in] */ ULONG32 bytesRequested,
    /* [out] */ ULONG32 *bytesWritten);


void __RPC_STUB ICLRDataTarget_WriteVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetTLSValue_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 index,
    /* [out] */ CLRDATA_ADDRESS *value);


void __RPC_STUB ICLRDataTarget_GetTLSValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_SetTLSValue_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 index,
    /* [in] */ CLRDATA_ADDRESS value);


void __RPC_STUB ICLRDataTarget_SetTLSValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetCurrentThreadID_Proxy( 
    ICLRDataTarget * This,
    /* [out] */ ULONG32 *threadID);


void __RPC_STUB ICLRDataTarget_GetCurrentThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetThreadContext_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 contextFlags,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][out] */ BYTE *context);


void __RPC_STUB ICLRDataTarget_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_SetThreadContext_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][in] */ BYTE *context);


void __RPC_STUB ICLRDataTarget_SetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_Request_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 reqCode,
    /* [in] */ ULONG32 inBufferSize,
    /* [size_is][in] */ BYTE *inBuffer,
    /* [in] */ ULONG32 outBufferSize,
    /* [size_is][out] */ BYTE *outBuffer);


void __RPC_STUB ICLRDataTarget_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataTarget_INTERFACE_DEFINED__ */


#ifndef __ICLRDataTarget2_INTERFACE_DEFINED__
#define __ICLRDataTarget2_INTERFACE_DEFINED__

/* interface ICLRDataTarget2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRDataTarget2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d05fae3-189c-4630-a6dc-1c251e1c01ab")
    ICLRDataTarget2 : public ICLRDataTarget
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocVirtual( 
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags,
            /* [in] */ ULONG32 protectFlags,
            /* [out] */ CLRDATA_ADDRESS *virt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeVirtual( 
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataTarget2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataTarget2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataTarget2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataTarget2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineType )( 
            ICLRDataTarget2 * This,
            /* [out] */ ULONG32 *machineType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointerSize )( 
            ICLRDataTarget2 * This,
            /* [out] */ ULONG32 *pointerSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageBase )( 
            ICLRDataTarget2 * This,
            /* [string][in] */ LPCWSTR imagePath,
            /* [out] */ CLRDATA_ADDRESS *baseAddress);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesRead);
        
        HRESULT ( STDMETHODCALLTYPE *WriteVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesWritten);
        
        HRESULT ( STDMETHODCALLTYPE *GetTLSValue )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [out] */ CLRDATA_ADDRESS *value);
        
        HRESULT ( STDMETHODCALLTYPE *SetTLSValue )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [in] */ CLRDATA_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadID )( 
            ICLRDataTarget2 * This,
            /* [out] */ ULONG32 *threadID);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *AllocVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags,
            /* [in] */ ULONG32 protectFlags,
            /* [out] */ CLRDATA_ADDRESS *virt);
        
        HRESULT ( STDMETHODCALLTYPE *FreeVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags);
        
        END_INTERFACE
    } ICLRDataTarget2Vtbl;

    interface ICLRDataTarget2
    {
        CONST_VTBL struct ICLRDataTarget2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataTarget2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataTarget2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataTarget2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataTarget2_GetMachineType(This,machineType)	\
    (This)->lpVtbl -> GetMachineType(This,machineType)

#define ICLRDataTarget2_GetPointerSize(This,pointerSize)	\
    (This)->lpVtbl -> GetPointerSize(This,pointerSize)

#define ICLRDataTarget2_GetImageBase(This,imagePath,baseAddress)	\
    (This)->lpVtbl -> GetImageBase(This,imagePath,baseAddress)

#define ICLRDataTarget2_ReadVirtual(This,address,buffer,bytesRequested,bytesRead)	\
    (This)->lpVtbl -> ReadVirtual(This,address,buffer,bytesRequested,bytesRead)

#define ICLRDataTarget2_WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)	\
    (This)->lpVtbl -> WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)

#define ICLRDataTarget2_GetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> GetTLSValue(This,threadID,index,value)

#define ICLRDataTarget2_SetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> SetTLSValue(This,threadID,index,value)

#define ICLRDataTarget2_GetCurrentThreadID(This,threadID)	\
    (This)->lpVtbl -> GetCurrentThreadID(This,threadID)

#define ICLRDataTarget2_GetThreadContext(This,threadID,contextFlags,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,threadID,contextFlags,contextSize,context)

#define ICLRDataTarget2_SetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,threadID,contextSize,context)

#define ICLRDataTarget2_Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)	\
    (This)->lpVtbl -> Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)


#define ICLRDataTarget2_AllocVirtual(This,addr,size,typeFlags,protectFlags,virt)	\
    (This)->lpVtbl -> AllocVirtual(This,addr,size,typeFlags,protectFlags,virt)

#define ICLRDataTarget2_FreeVirtual(This,addr,size,typeFlags)	\
    (This)->lpVtbl -> FreeVirtual(This,addr,size,typeFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataTarget2_AllocVirtual_Proxy( 
    ICLRDataTarget2 * This,
    /* [in] */ CLRDATA_ADDRESS addr,
    /* [in] */ ULONG32 size,
    /* [in] */ ULONG32 typeFlags,
    /* [in] */ ULONG32 protectFlags,
    /* [out] */ CLRDATA_ADDRESS *virt);


void __RPC_STUB ICLRDataTarget2_AllocVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget2_FreeVirtual_Proxy( 
    ICLRDataTarget2 * This,
    /* [in] */ CLRDATA_ADDRESS addr,
    /* [in] */ ULONG32 size,
    /* [in] */ ULONG32 typeFlags);


void __RPC_STUB ICLRDataTarget2_FreeVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataTarget2_INTERFACE_DEFINED__ */


#ifndef __ICLRMetadataLocator_INTERFACE_DEFINED__
#define __ICLRMetadataLocator_INTERFACE_DEFINED__

/* interface ICLRMetadataLocator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRMetadataLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa8fa804-bc05-4642-b2c5-c353ed22fc63")
    ICLRMetadataLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMetadata( 
            /* [in] */ LPCWSTR imagePath,
            /* [in] */ ULONG32 imageTimestamp,
            /* [in] */ ULONG32 imageSize,
            /* [in] */ GUID *mvid,
            /* [in] */ ULONG32 mdRva,
            /* [in] */ ULONG32 flags,
            /* [in] */ ULONG32 bufferSize,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [out] */ ULONG32 *dataSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRMetadataLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRMetadataLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRMetadataLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRMetadataLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadata )( 
            ICLRMetadataLocator * This,
            /* [in] */ LPCWSTR imagePath,
            /* [in] */ ULONG32 imageTimestamp,
            /* [in] */ ULONG32 imageSize,
            /* [in] */ GUID *mvid,
            /* [in] */ ULONG32 mdRva,
            /* [in] */ ULONG32 flags,
            /* [in] */ ULONG32 bufferSize,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [out] */ ULONG32 *dataSize);
        
        END_INTERFACE
    } ICLRMetadataLocatorVtbl;

    interface ICLRMetadataLocator
    {
        CONST_VTBL struct ICLRMetadataLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRMetadataLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRMetadataLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRMetadataLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRMetadataLocator_GetMetadata(This,imagePath,imageTimestamp,imageSize,mvid,mdRva,flags,bufferSize,buffer,dataSize)	\
    (This)->lpVtbl -> GetMetadata(This,imagePath,imageTimestamp,imageSize,mvid,mdRva,flags,bufferSize,buffer,dataSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRMetadataLocator_GetMetadata_Proxy( 
    ICLRMetadataLocator * This,
    /* [in] */ LPCWSTR imagePath,
    /* [in] */ ULONG32 imageTimestamp,
    /* [in] */ ULONG32 imageSize,
    /* [in] */ GUID *mvid,
    /* [in] */ ULONG32 mdRva,
    /* [in] */ ULONG32 flags,
    /* [in] */ ULONG32 bufferSize,
    /* [length_is][size_is][out] */ BYTE *buffer,
    /* [out] */ ULONG32 *dataSize);


void __RPC_STUB ICLRMetadataLocator_GetMetadata_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRMetadataLocator_INTERFACE_DEFINED__ */


#ifndef __ICLRDataEnumMemoryRegionsCallback_INTERFACE_DEFINED__
#define __ICLRDataEnumMemoryRegionsCallback_INTERFACE_DEFINED__

/* interface ICLRDataEnumMemoryRegionsCallback */
/* [uuid][object] */ 


EXTERN_C const IID IID_ICLRDataEnumMemoryRegionsCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BCDD6908-BA2D-4ec5-96CF-DF4D5CDCB4A4")
    ICLRDataEnumMemoryRegionsCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumMemoryRegion( 
            /* [in] */ CLRDATA_ADDRESS address,
            /* [in] */ ULONG32 size) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataEnumMemoryRegionsCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataEnumMemoryRegionsCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataEnumMemoryRegionsCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataEnumMemoryRegionsCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMemoryRegion )( 
            ICLRDataEnumMemoryRegionsCallback * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [in] */ ULONG32 size);
        
        END_INTERFACE
    } ICLRDataEnumMemoryRegionsCallbackVtbl;

    interface ICLRDataEnumMemoryRegionsCallback
    {
        CONST_VTBL struct ICLRDataEnumMemoryRegionsCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataEnumMemoryRegionsCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataEnumMemoryRegionsCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataEnumMemoryRegionsCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataEnumMemoryRegionsCallback_EnumMemoryRegion(This,address,size)	\
    (This)->lpVtbl -> EnumMemoryRegion(This,address,size)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataEnumMemoryRegionsCallback_EnumMemoryRegion_Proxy( 
    ICLRDataEnumMemoryRegionsCallback * This,
    /* [in] */ CLRDATA_ADDRESS address,
    /* [in] */ ULONG32 size);


void __RPC_STUB ICLRDataEnumMemoryRegionsCallback_EnumMemoryRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataEnumMemoryRegionsCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_clrdata_0012 */
/* [local] */ 

typedef 
enum CLRDataEnumMemoryFlags
    {	CLRDATA_ENUM_MEM_DEFAULT	= 0,
	CLRDATA_ENUM_MEM_MINI	= CLRDATA_ENUM_MEM_DEFAULT,
	CLRDATA_ENUM_MEM_HEAP	= 0x1
    } 	CLRDataEnumMemoryFlags;



extern RPC_IF_HANDLE __MIDL_itf_clrdata_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_clrdata_0012_v0_0_s_ifspec;

#ifndef __ICLRDataEnumMemoryRegions_INTERFACE_DEFINED__
#define __ICLRDataEnumMemoryRegions_INTERFACE_DEFINED__

/* interface ICLRDataEnumMemoryRegions */
/* [uuid][object] */ 


EXTERN_C const IID IID_ICLRDataEnumMemoryRegions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("471c35b4-7c2f-4ef0-a945-00f8c38056f1")
    ICLRDataEnumMemoryRegions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumMemoryRegions( 
            /* [in] */ ICLRDataEnumMemoryRegionsCallback *callback,
            /* [in] */ ULONG32 miniDumpFlags,
            /* [in] */ CLRDataEnumMemoryFlags clrFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataEnumMemoryRegionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataEnumMemoryRegions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataEnumMemoryRegions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataEnumMemoryRegions * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMemoryRegions )( 
            ICLRDataEnumMemoryRegions * This,
            /* [in] */ ICLRDataEnumMemoryRegionsCallback *callback,
            /* [in] */ ULONG32 miniDumpFlags,
            /* [in] */ CLRDataEnumMemoryFlags clrFlags);
        
        END_INTERFACE
    } ICLRDataEnumMemoryRegionsVtbl;

    interface ICLRDataEnumMemoryRegions
    {
        CONST_VTBL struct ICLRDataEnumMemoryRegionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataEnumMemoryRegions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataEnumMemoryRegions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataEnumMemoryRegions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataEnumMemoryRegions_EnumMemoryRegions(This,callback,miniDumpFlags,clrFlags)	\
    (This)->lpVtbl -> EnumMemoryRegions(This,callback,miniDumpFlags,clrFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataEnumMemoryRegions_EnumMemoryRegions_Proxy( 
    ICLRDataEnumMemoryRegions * This,
    /* [in] */ ICLRDataEnumMemoryRegionsCallback *callback,
    /* [in] */ ULONG32 miniDumpFlags,
    /* [in] */ CLRDataEnumMemoryFlags clrFlags);


void __RPC_STUB ICLRDataEnumMemoryRegions_EnumMemoryRegions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataEnumMemoryRegions_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\cordebug.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for cordebug.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __cordebug_h__
#define __cordebug_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICorDebugManagedCallback_FWD_DEFINED__
#define __ICorDebugManagedCallback_FWD_DEFINED__
typedef interface ICorDebugManagedCallback ICorDebugManagedCallback;
#endif 	/* __ICorDebugManagedCallback_FWD_DEFINED__ */


#ifndef __ICorDebugManagedCallback2_FWD_DEFINED__
#define __ICorDebugManagedCallback2_FWD_DEFINED__
typedef interface ICorDebugManagedCallback2 ICorDebugManagedCallback2;
#endif 	/* __ICorDebugManagedCallback2_FWD_DEFINED__ */


#ifndef __ICorDebugUnmanagedCallback_FWD_DEFINED__
#define __ICorDebugUnmanagedCallback_FWD_DEFINED__
typedef interface ICorDebugUnmanagedCallback ICorDebugUnmanagedCallback;
#endif 	/* __ICorDebugUnmanagedCallback_FWD_DEFINED__ */


#ifndef __ICorDebug_FWD_DEFINED__
#define __ICorDebug_FWD_DEFINED__
typedef interface ICorDebug ICorDebug;
#endif 	/* __ICorDebug_FWD_DEFINED__ */


#ifndef __ICorDebug2_FWD_DEFINED__
#define __ICorDebug2_FWD_DEFINED__
typedef interface ICorDebug2 ICorDebug2;
#endif 	/* __ICorDebug2_FWD_DEFINED__ */


#ifndef __ICorDebugController_FWD_DEFINED__
#define __ICorDebugController_FWD_DEFINED__
typedef interface ICorDebugController ICorDebugController;
#endif 	/* __ICorDebugController_FWD_DEFINED__ */


#ifndef __ICorDebugAppDomain_FWD_DEFINED__
#define __ICorDebugAppDomain_FWD_DEFINED__
typedef interface ICorDebugAppDomain ICorDebugAppDomain;
#endif 	/* __ICorDebugAppDomain_FWD_DEFINED__ */


#ifndef __ICorDebugAppDomain2_FWD_DEFINED__
#define __ICorDebugAppDomain2_FWD_DEFINED__
typedef interface ICorDebugAppDomain2 ICorDebugAppDomain2;
#endif 	/* __ICorDebugAppDomain2_FWD_DEFINED__ */


#ifndef __ICorDebugAssembly_FWD_DEFINED__
#define __ICorDebugAssembly_FWD_DEFINED__
typedef interface ICorDebugAssembly ICorDebugAssembly;
#endif 	/* __ICorDebugAssembly_FWD_DEFINED__ */


#ifndef __ICorDebugAssembly2_FWD_DEFINED__
#define __ICorDebugAssembly2_FWD_DEFINED__
typedef interface ICorDebugAssembly2 ICorDebugAssembly2;
#endif 	/* __ICorDebugAssembly2_FWD_DEFINED__ */


#ifndef __ICorDebugProcess_FWD_DEFINED__
#define __ICorDebugProcess_FWD_DEFINED__
typedef interface ICorDebugProcess ICorDebugProcess;
#endif 	/* __ICorDebugProcess_FWD_DEFINED__ */


#ifndef __ICorDebugProcess2_FWD_DEFINED__
#define __ICorDebugProcess2_FWD_DEFINED__
typedef interface ICorDebugProcess2 ICorDebugProcess2;
#endif 	/* __ICorDebugProcess2_FWD_DEFINED__ */


#ifndef __ICorDebugBreakpoint_FWD_DEFINED__
#define __ICorDebugBreakpoint_FWD_DEFINED__
typedef interface ICorDebugBreakpoint ICorDebugBreakpoint;
#endif 	/* __ICorDebugBreakpoint_FWD_DEFINED__ */


#ifndef __ICorDebugFunctionBreakpoint_FWD_DEFINED__
#define __ICorDebugFunctionBreakpoint_FWD_DEFINED__
typedef interface ICorDebugFunctionBreakpoint ICorDebugFunctionBreakpoint;
#endif 	/* __ICorDebugFunctionBreakpoint_FWD_DEFINED__ */


#ifndef __ICorDebugModuleBreakpoint_FWD_DEFINED__
#define __ICorDebugModuleBreakpoint_FWD_DEFINED__
typedef interface ICorDebugModuleBreakpoint ICorDebugModuleBreakpoint;
#endif 	/* __ICorDebugModuleBreakpoint_FWD_DEFINED__ */


#ifndef __ICorDebugValueBreakpoint_FWD_DEFINED__
#define __ICorDebugValueBreakpoint_FWD_DEFINED__
typedef interface ICorDebugValueBreakpoint ICorDebugValueBreakpoint;
#endif 	/* __ICorDebugValueBreakpoint_FWD_DEFINED__ */


#ifndef __ICorDebugStepper_FWD_DEFINED__
#define __ICorDebugStepper_FWD_DEFINED__
typedef interface ICorDebugStepper ICorDebugStepper;
#endif 	/* __ICorDebugStepper_FWD_DEFINED__ */


#ifndef __ICorDebugStepper2_FWD_DEFINED__
#define __ICorDebugStepper2_FWD_DEFINED__
typedef interface ICorDebugStepper2 ICorDebugStepper2;
#endif 	/* __ICorDebugStepper2_FWD_DEFINED__ */


#ifndef __ICorDebugRegisterSet_FWD_DEFINED__
#define __ICorDebugRegisterSet_FWD_DEFINED__
typedef interface ICorDebugRegisterSet ICorDebugRegisterSet;
#endif 	/* __ICorDebugRegisterSet_FWD_DEFINED__ */


#ifndef __ICorDebugRegisterSet2_FWD_DEFINED__
#define __ICorDebugRegisterSet2_FWD_DEFINED__
typedef interface ICorDebugRegisterSet2 ICorDebugRegisterSet2;
#endif 	/* __ICorDebugRegisterSet2_FWD_DEFINED__ */


#ifndef __ICorDebugThread_FWD_DEFINED__
#define __ICorDebugThread_FWD_DEFINED__
typedef interface ICorDebugThread ICorDebugThread;
#endif 	/* __ICorDebugThread_FWD_DEFINED__ */


#ifndef __ICorDebugThread2_FWD_DEFINED__
#define __ICorDebugThread2_FWD_DEFINED__
typedef interface ICorDebugThread2 ICorDebugThread2;
#endif 	/* __ICorDebugThread2_FWD_DEFINED__ */


#ifndef __ICorDebugChain_FWD_DEFINED__
#define __ICorDebugChain_FWD_DEFINED__
typedef interface ICorDebugChain ICorDebugChain;
#endif 	/* __ICorDebugChain_FWD_DEFINED__ */


#ifndef __ICorDebugFrame_FWD_DEFINED__
#define __ICorDebugFrame_FWD_DEFINED__
typedef interface ICorDebugFrame ICorDebugFrame;
#endif 	/* __ICorDebugFrame_FWD_DEFINED__ */


#ifndef __ICorDebugInternalFrame_FWD_DEFINED__
#define __ICorDebugInternalFrame_FWD_DEFINED__
typedef interface ICorDebugInternalFrame ICorDebugInternalFrame;
#endif 	/* __ICorDebugInternalFrame_FWD_DEFINED__ */


#ifndef __ICorDebugILFrame_FWD_DEFINED__
#define __ICorDebugILFrame_FWD_DEFINED__
typedef interface ICorDebugILFrame ICorDebugILFrame;
#endif 	/* __ICorDebugILFrame_FWD_DEFINED__ */


#ifndef __ICorDebugILFrame2_FWD_DEFINED__
#define __ICorDebugILFrame2_FWD_DEFINED__
typedef interface ICorDebugILFrame2 ICorDebugILFrame2;
#endif 	/* __ICorDebugILFrame2_FWD_DEFINED__ */


#ifndef __ICorDebugNativeFrame_FWD_DEFINED__
#define __ICorDebugNativeFrame_FWD_DEFINED__
typedef interface ICorDebugNativeFrame ICorDebugNativeFrame;
#endif 	/* __ICorDebugNativeFrame_FWD_DEFINED__ */


#ifndef __ICorDebugModule_FWD_DEFINED__
#define __ICorDebugModule_FWD_DEFINED__
typedef interface ICorDebugModule ICorDebugModule;
#endif 	/* __ICorDebugModule_FWD_DEFINED__ */


#ifndef __ICorDebugModule2_FWD_DEFINED__
#define __ICorDebugModule2_FWD_DEFINED__
typedef interface ICorDebugModule2 ICorDebugModule2;
#endif 	/* __ICorDebugModule2_FWD_DEFINED__ */


#ifndef __ICorDebugFunction_FWD_DEFINED__
#define __ICorDebugFunction_FWD_DEFINED__
typedef interface ICorDebugFunction ICorDebugFunction;
#endif 	/* __ICorDebugFunction_FWD_DEFINED__ */


#ifndef __ICorDebugFunction2_FWD_DEFINED__
#define __ICorDebugFunction2_FWD_DEFINED__
typedef interface ICorDebugFunction2 ICorDebugFunction2;
#endif 	/* __ICorDebugFunction2_FWD_DEFINED__ */


#ifndef __ICorDebugCode_FWD_DEFINED__
#define __ICorDebugCode_FWD_DEFINED__
typedef interface ICorDebugCode ICorDebugCode;
#endif 	/* __ICorDebugCode_FWD_DEFINED__ */


#ifndef __ICorDebugCode2_FWD_DEFINED__
#define __ICorDebugCode2_FWD_DEFINED__
typedef interface ICorDebugCode2 ICorDebugCode2;
#endif 	/* __ICorDebugCode2_FWD_DEFINED__ */


#ifndef __ICorDebugClass_FWD_DEFINED__
#define __ICorDebugClass_FWD_DEFINED__
typedef interface ICorDebugClass ICorDebugClass;
#endif 	/* __ICorDebugClass_FWD_DEFINED__ */


#ifndef __ICorDebugClass2_FWD_DEFINED__
#define __ICorDebugClass2_FWD_DEFINED__
typedef interface ICorDebugClass2 ICorDebugClass2;
#endif 	/* __ICorDebugClass2_FWD_DEFINED__ */


#ifndef __ICorDebugEval_FWD_DEFINED__
#define __ICorDebugEval_FWD_DEFINED__
typedef interface ICorDebugEval ICorDebugEval;
#endif 	/* __ICorDebugEval_FWD_DEFINED__ */


#ifndef __ICorDebugEval2_FWD_DEFINED__
#define __ICorDebugEval2_FWD_DEFINED__
typedef interface ICorDebugEval2 ICorDebugEval2;
#endif 	/* __ICorDebugEval2_FWD_DEFINED__ */


#ifndef __ICorDebugValue_FWD_DEFINED__
#define __ICorDebugValue_FWD_DEFINED__
typedef interface ICorDebugValue ICorDebugValue;
#endif 	/* __ICorDebugValue_FWD_DEFINED__ */


#ifndef __ICorDebugValue2_FWD_DEFINED__
#define __ICorDebugValue2_FWD_DEFINED__
typedef interface ICorDebugValue2 ICorDebugValue2;
#endif 	/* __ICorDebugValue2_FWD_DEFINED__ */


#ifndef __ICorDebugGenericValue_FWD_DEFINED__
#define __ICorDebugGenericValue_FWD_DEFINED__
typedef interface ICorDebugGenericValue ICorDebugGenericValue;
#endif 	/* __ICorDebugGenericValue_FWD_DEFINED__ */


#ifndef __ICorDebugReferenceValue_FWD_DEFINED__
#define __ICorDebugReferenceValue_FWD_DEFINED__
typedef interface ICorDebugReferenceValue ICorDebugReferenceValue;
#endif 	/* __ICorDebugReferenceValue_FWD_DEFINED__ */


#ifndef __ICorDebugHeapValue_FWD_DEFINED__
#define __ICorDebugHeapValue_FWD_DEFINED__
typedef interface ICorDebugHeapValue ICorDebugHeapValue;
#endif 	/* __ICorDebugHeapValue_FWD_DEFINED__ */


#ifndef __ICorDebugHeapValue2_FWD_DEFINED__
#define __ICorDebugHeapValue2_FWD_DEFINED__
typedef interface ICorDebugHeapValue2 ICorDebugHeapValue2;
#endif 	/* __ICorDebugHeapValue2_FWD_DEFINED__ */


#ifndef __ICorDebugObjectValue_FWD_DEFINED__
#define __ICorDebugObjectValue_FWD_DEFINED__
typedef interface ICorDebugObjectValue ICorDebugObjectValue;
#endif 	/* __ICorDebugObjectValue_FWD_DEFINED__ */


#ifndef __ICorDebugObjectValue2_FWD_DEFINED__
#define __ICorDebugObjectValue2_FWD_DEFINED__
typedef interface ICorDebugObjectValue2 ICorDebugObjectValue2;
#endif 	/* __ICorDebugObjectValue2_FWD_DEFINED__ */


#ifndef __ICorDebugBoxValue_FWD_DEFINED__
#define __ICorDebugBoxValue_FWD_DEFINED__
typedef interface ICorDebugBoxValue ICorDebugBoxValue;
#endif 	/* __ICorDebugBoxValue_FWD_DEFINED__ */


#ifndef __ICorDebugStringValue_FWD_DEFINED__
#define __ICorDebugStringValue_FWD_DEFINED__
typedef interface ICorDebugStringValue ICorDebugStringValue;
#endif 	/* __ICorDebugStringValue_FWD_DEFINED__ */


#ifndef __ICorDebugArrayValue_FWD_DEFINED__
#define __ICorDebugArrayValue_FWD_DEFINED__
typedef interface ICorDebugArrayValue ICorDebugArrayValue;
#endif 	/* __ICorDebugArrayValue_FWD_DEFINED__ */


#ifndef __ICorDebugHandleValue_FWD_DEFINED__
#define __ICorDebugHandleValue_FWD_DEFINED__
typedef interface ICorDebugHandleValue ICorDebugHandleValue;
#endif 	/* __ICorDebugHandleValue_FWD_DEFINED__ */


#ifndef __ICorDebugContext_FWD_DEFINED__
#define __ICorDebugContext_FWD_DEFINED__
typedef interface ICorDebugContext ICorDebugContext;
#endif 	/* __ICorDebugContext_FWD_DEFINED__ */


#ifndef __ICorDebugEnum_FWD_DEFINED__
#define __ICorDebugEnum_FWD_DEFINED__
typedef interface ICorDebugEnum ICorDebugEnum;
#endif 	/* __ICorDebugEnum_FWD_DEFINED__ */


#ifndef __ICorDebugObjectEnum_FWD_DEFINED__
#define __ICorDebugObjectEnum_FWD_DEFINED__
typedef interface ICorDebugObjectEnum ICorDebugObjectEnum;
#endif 	/* __ICorDebugObjectEnum_FWD_DEFINED__ */


#ifndef __ICorDebugBreakpointEnum_FWD_DEFINED__
#define __ICorDebugBreakpointEnum_FWD_DEFINED__
typedef interface ICorDebugBreakpointEnum ICorDebugBreakpointEnum;
#endif 	/* __ICorDebugBreakpointEnum_FWD_DEFINED__ */


#ifndef __ICorDebugStepperEnum_FWD_DEFINED__
#define __ICorDebugStepperEnum_FWD_DEFINED__
typedef interface ICorDebugStepperEnum ICorDebugStepperEnum;
#endif 	/* __ICorDebugStepperEnum_FWD_DEFINED__ */


#ifndef __ICorDebugProcessEnum_FWD_DEFINED__
#define __ICorDebugProcessEnum_FWD_DEFINED__
typedef interface ICorDebugProcessEnum ICorDebugProcessEnum;
#endif 	/* __ICorDebugProcessEnum_FWD_DEFINED__ */


#ifndef __ICorDebugThreadEnum_FWD_DEFINED__
#define __ICorDebugThreadEnum_FWD_DEFINED__
typedef interface ICorDebugThreadEnum ICorDebugThreadEnum;
#endif 	/* __ICorDebugThreadEnum_FWD_DEFINED__ */


#ifndef __ICorDebugFrameEnum_FWD_DEFINED__
#define __ICorDebugFrameEnum_FWD_DEFINED__
typedef interface ICorDebugFrameEnum ICorDebugFrameEnum;
#endif 	/* __ICorDebugFrameEnum_FWD_DEFINED__ */


#ifndef __ICorDebugChainEnum_FWD_DEFINED__
#define __ICorDebugChainEnum_FWD_DEFINED__
typedef interface ICorDebugChainEnum ICorDebugChainEnum;
#endif 	/* __ICorDebugChainEnum_FWD_DEFINED__ */


#ifndef __ICorDebugModuleEnum_FWD_DEFINED__
#define __ICorDebugModuleEnum_FWD_DEFINED__
typedef interface ICorDebugModuleEnum ICorDebugModuleEnum;
#endif 	/* __ICorDebugModuleEnum_FWD_DEFINED__ */


#ifndef __ICorDebugValueEnum_FWD_DEFINED__
#define __ICorDebugValueEnum_FWD_DEFINED__
typedef interface ICorDebugValueEnum ICorDebugValueEnum;
#endif 	/* __ICorDebugValueEnum_FWD_DEFINED__ */


#ifndef __ICorDebugCodeEnum_FWD_DEFINED__
#define __ICorDebugCodeEnum_FWD_DEFINED__
typedef interface ICorDebugCodeEnum ICorDebugCodeEnum;
#endif 	/* __ICorDebugCodeEnum_FWD_DEFINED__ */


#ifndef __ICorDebugTypeEnum_FWD_DEFINED__
#define __ICorDebugTypeEnum_FWD_DEFINED__
typedef interface ICorDebugTypeEnum ICorDebugTypeEnum;
#endif 	/* __ICorDebugTypeEnum_FWD_DEFINED__ */


#ifndef __ICorDebugType_FWD_DEFINED__
#define __ICorDebugType_FWD_DEFINED__
typedef interface ICorDebugType ICorDebugType;
#endif 	/* __ICorDebugType_FWD_DEFINED__ */


#ifndef __ICorDebugErrorInfoEnum_FWD_DEFINED__
#define __ICorDebugErrorInfoEnum_FWD_DEFINED__
typedef interface ICorDebugErrorInfoEnum ICorDebugErrorInfoEnum;
#endif 	/* __ICorDebugErrorInfoEnum_FWD_DEFINED__ */


#ifndef __ICorDebugAppDomainEnum_FWD_DEFINED__
#define __ICorDebugAppDomainEnum_FWD_DEFINED__
typedef interface ICorDebugAppDomainEnum ICorDebugAppDomainEnum;
#endif 	/* __ICorDebugAppDomainEnum_FWD_DEFINED__ */


#ifndef __ICorDebugAssemblyEnum_FWD_DEFINED__
#define __ICorDebugAssemblyEnum_FWD_DEFINED__
typedef interface ICorDebugAssemblyEnum ICorDebugAssemblyEnum;
#endif 	/* __ICorDebugAssemblyEnum_FWD_DEFINED__ */


#ifndef __ICorDebugMDA_FWD_DEFINED__
#define __ICorDebugMDA_FWD_DEFINED__
typedef interface ICorDebugMDA ICorDebugMDA;
#endif 	/* __ICorDebugMDA_FWD_DEFINED__ */


#ifndef __ICorDebugEditAndContinueErrorInfo_FWD_DEFINED__
#define __ICorDebugEditAndContinueErrorInfo_FWD_DEFINED__
typedef interface ICorDebugEditAndContinueErrorInfo ICorDebugEditAndContinueErrorInfo;
#endif 	/* __ICorDebugEditAndContinueErrorInfo_FWD_DEFINED__ */


#ifndef __ICorDebugEditAndContinueSnapshot_FWD_DEFINED__
#define __ICorDebugEditAndContinueSnapshot_FWD_DEFINED__
typedef interface ICorDebugEditAndContinueSnapshot ICorDebugEditAndContinueSnapshot;
#endif 	/* __ICorDebugEditAndContinueSnapshot_FWD_DEFINED__ */


#ifndef __CorDebug_FWD_DEFINED__
#define __CorDebug_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorDebug CorDebug;
#else
typedef struct CorDebug CorDebug;
#endif /* __cplusplus */

#endif 	/* __CorDebug_FWD_DEFINED__ */


#ifndef __EmbeddedCLRCorDebug_FWD_DEFINED__
#define __EmbeddedCLRCorDebug_FWD_DEFINED__

#ifdef __cplusplus
typedef class EmbeddedCLRCorDebug EmbeddedCLRCorDebug;
#else
typedef struct EmbeddedCLRCorDebug EmbeddedCLRCorDebug;
#endif /* __cplusplus */

#endif 	/* __EmbeddedCLRCorDebug_FWD_DEFINED__ */


#ifndef __ICorDebugValue_FWD_DEFINED__
#define __ICorDebugValue_FWD_DEFINED__
typedef interface ICorDebugValue ICorDebugValue;
#endif 	/* __ICorDebugValue_FWD_DEFINED__ */


#ifndef __ICorDebugReferenceValue_FWD_DEFINED__
#define __ICorDebugReferenceValue_FWD_DEFINED__
typedef interface ICorDebugReferenceValue ICorDebugReferenceValue;
#endif 	/* __ICorDebugReferenceValue_FWD_DEFINED__ */


#ifndef __ICorDebugHeapValue_FWD_DEFINED__
#define __ICorDebugHeapValue_FWD_DEFINED__
typedef interface ICorDebugHeapValue ICorDebugHeapValue;
#endif 	/* __ICorDebugHeapValue_FWD_DEFINED__ */


#ifndef __ICorDebugStringValue_FWD_DEFINED__
#define __ICorDebugStringValue_FWD_DEFINED__
typedef interface ICorDebugStringValue ICorDebugStringValue;
#endif 	/* __ICorDebugStringValue_FWD_DEFINED__ */


#ifndef __ICorDebugGenericValue_FWD_DEFINED__
#define __ICorDebugGenericValue_FWD_DEFINED__
typedef interface ICorDebugGenericValue ICorDebugGenericValue;
#endif 	/* __ICorDebugGenericValue_FWD_DEFINED__ */


#ifndef __ICorDebugBoxValue_FWD_DEFINED__
#define __ICorDebugBoxValue_FWD_DEFINED__
typedef interface ICorDebugBoxValue ICorDebugBoxValue;
#endif 	/* __ICorDebugBoxValue_FWD_DEFINED__ */


#ifndef __ICorDebugArrayValue_FWD_DEFINED__
#define __ICorDebugArrayValue_FWD_DEFINED__
typedef interface ICorDebugArrayValue ICorDebugArrayValue;
#endif 	/* __ICorDebugArrayValue_FWD_DEFINED__ */


#ifndef __ICorDebugFrame_FWD_DEFINED__
#define __ICorDebugFrame_FWD_DEFINED__
typedef interface ICorDebugFrame ICorDebugFrame;
#endif 	/* __ICorDebugFrame_FWD_DEFINED__ */


#ifndef __ICorDebugILFrame_FWD_DEFINED__
#define __ICorDebugILFrame_FWD_DEFINED__
typedef interface ICorDebugILFrame ICorDebugILFrame;
#endif 	/* __ICorDebugILFrame_FWD_DEFINED__ */


#ifndef __ICorDebugInternalFrame_FWD_DEFINED__
#define __ICorDebugInternalFrame_FWD_DEFINED__
typedef interface ICorDebugInternalFrame ICorDebugInternalFrame;
#endif 	/* __ICorDebugInternalFrame_FWD_DEFINED__ */


#ifndef __ICorDebugNativeFrame_FWD_DEFINED__
#define __ICorDebugNativeFrame_FWD_DEFINED__
typedef interface ICorDebugNativeFrame ICorDebugNativeFrame;
#endif 	/* __ICorDebugNativeFrame_FWD_DEFINED__ */


#ifndef __ICorDebugManagedCallback2_FWD_DEFINED__
#define __ICorDebugManagedCallback2_FWD_DEFINED__
typedef interface ICorDebugManagedCallback2 ICorDebugManagedCallback2;
#endif 	/* __ICorDebugManagedCallback2_FWD_DEFINED__ */


#ifndef __ICorDebugAppDomain2_FWD_DEFINED__
#define __ICorDebugAppDomain2_FWD_DEFINED__
typedef interface ICorDebugAppDomain2 ICorDebugAppDomain2;
#endif 	/* __ICorDebugAppDomain2_FWD_DEFINED__ */


#ifndef __ICorDebugAssembly2_FWD_DEFINED__
#define __ICorDebugAssembly2_FWD_DEFINED__
typedef interface ICorDebugAssembly2 ICorDebugAssembly2;
#endif 	/* __ICorDebugAssembly2_FWD_DEFINED__ */


#ifndef __ICorDebugProcess2_FWD_DEFINED__
#define __ICorDebugProcess2_FWD_DEFINED__
typedef interface ICorDebugProcess2 ICorDebugProcess2;
#endif 	/* __ICorDebugProcess2_FWD_DEFINED__ */


#ifndef __ICorDebugStepper2_FWD_DEFINED__
#define __ICorDebugStepper2_FWD_DEFINED__
typedef interface ICorDebugStepper2 ICorDebugStepper2;
#endif 	/* __ICorDebugStepper2_FWD_DEFINED__ */


#ifndef __ICorDebugThread2_FWD_DEFINED__
#define __ICorDebugThread2_FWD_DEFINED__
typedef interface ICorDebugThread2 ICorDebugThread2;
#endif 	/* __ICorDebugThread2_FWD_DEFINED__ */


#ifndef __ICorDebugILFrame2_FWD_DEFINED__
#define __ICorDebugILFrame2_FWD_DEFINED__
typedef interface ICorDebugILFrame2 ICorDebugILFrame2;
#endif 	/* __ICorDebugILFrame2_FWD_DEFINED__ */


#ifndef __ICorDebugModule2_FWD_DEFINED__
#define __ICorDebugModule2_FWD_DEFINED__
typedef interface ICorDebugModule2 ICorDebugModule2;
#endif 	/* __ICorDebugModule2_FWD_DEFINED__ */


#ifndef __ICorDebugFunction2_FWD_DEFINED__
#define __ICorDebugFunction2_FWD_DEFINED__
typedef interface ICorDebugFunction2 ICorDebugFunction2;
#endif 	/* __ICorDebugFunction2_FWD_DEFINED__ */


#ifndef __ICorDebugClass2_FWD_DEFINED__
#define __ICorDebugClass2_FWD_DEFINED__
typedef interface ICorDebugClass2 ICorDebugClass2;
#endif 	/* __ICorDebugClass2_FWD_DEFINED__ */


#ifndef __ICorDebugEval2_FWD_DEFINED__
#define __ICorDebugEval2_FWD_DEFINED__
typedef interface ICorDebugEval2 ICorDebugEval2;
#endif 	/* __ICorDebugEval2_FWD_DEFINED__ */


#ifndef __ICorDebugValue2_FWD_DEFINED__
#define __ICorDebugValue2_FWD_DEFINED__
typedef interface ICorDebugValue2 ICorDebugValue2;
#endif 	/* __ICorDebugValue2_FWD_DEFINED__ */


#ifndef __ICorDebugObjectValue2_FWD_DEFINED__
#define __ICorDebugObjectValue2_FWD_DEFINED__
typedef interface ICorDebugObjectValue2 ICorDebugObjectValue2;
#endif 	/* __ICorDebugObjectValue2_FWD_DEFINED__ */


#ifndef __ICorDebugHandleValue_FWD_DEFINED__
#define __ICorDebugHandleValue_FWD_DEFINED__
typedef interface ICorDebugHandleValue ICorDebugHandleValue;
#endif 	/* __ICorDebugHandleValue_FWD_DEFINED__ */


#ifndef __ICorDebugHeapValue2_FWD_DEFINED__
#define __ICorDebugHeapValue2_FWD_DEFINED__
typedef interface ICorDebugHeapValue2 ICorDebugHeapValue2;
#endif 	/* __ICorDebugHeapValue2_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_cordebug_0000 */
/* [local] */ 

#if 0
typedef UINT32 mdToken;

typedef mdToken mdModule;

typedef SIZE_T mdScope;

typedef mdToken mdTypeDef;

typedef mdToken mdSourceFile;

typedef mdToken mdMemberRef;

typedef mdToken mdMethodDef;

typedef mdToken mdFieldDef;

typedef mdToken mdSignature;

typedef ULONG CorElementType;

typedef SIZE_T PCCOR_SIGNATURE;

typedef SIZE_T LPDEBUG_EVENT;

typedef SIZE_T LPSTARTUPINFOW;

typedef SIZE_T LPPROCESS_INFORMATION;

#endif
typedef /* [wire_marshal] */ void *HPROCESS;

typedef /* [wire_marshal] */ void *HTHREAD;

typedef UINT64 TASKID;

typedef DWORD CONNID;

#ifndef _COR_IL_MAP
#define _COR_IL_MAP
typedef struct _COR_IL_MAP
    {
    ULONG32 oldOffset;
    ULONG32 newOffset;
    BOOL fAccurate;
    } 	COR_IL_MAP;

#endif //_COR_IL_MAP
#ifndef _COR_DEBUG_IL_TO_NATIVE_MAP_
#define _COR_DEBUG_IL_TO_NATIVE_MAP_
typedef 
enum CorDebugIlToNativeMappingTypes
    {	NO_MAPPING	= -1,
	PROLOG	= -2,
	EPILOG	= -3
    } 	CorDebugIlToNativeMappingTypes;

typedef struct COR_DEBUG_IL_TO_NATIVE_MAP
    {
    ULONG32 ilOffset;
    ULONG32 nativeStartOffset;
    ULONG32 nativeEndOffset;
    } 	COR_DEBUG_IL_TO_NATIVE_MAP;

#endif // _COR_DEBUG_IL_TO_NATIVE_MAP_
#define REMOTE_DEBUGGING_DLL_ENTRY L"Software\\Microsoft\\.NETFramework\\Debugger\\ActivateRemoteDebugging"
typedef 
enum CorDebugJITCompilerFlags
    {	CORDEBUG_JIT_DEFAULT	= 0x1,
	CORDEBUG_JIT_DISABLE_OPTIMIZATION	= 0x3,
	CORDEBUG_JIT_ENABLE_ENC	= 0x7
    } 	CorDebugJITCompilerFlags;

typedef 
enum CorDebugJITCompilerFlagsDecprecated
    {	CORDEBUG_JIT_TRACK_DEBUG_INFO	= 0x1
    } 	CorDebugJITCompilerFlagsDeprecated;
























































typedef ULONG64 CORDB_ADDRESS;

typedef ULONG64 CORDB_REGISTER;



extern RPC_IF_HANDLE __MIDL_itf_cordebug_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cordebug_0000_v0_0_s_ifspec;

#ifndef __ICorDebugManagedCallback_INTERFACE_DEFINED__
#define __ICorDebugManagedCallback_INTERFACE_DEFINED__

/* interface ICorDebugManagedCallback */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugStepReason
    {	STEP_NORMAL	= 0,
	STEP_RETURN	= STEP_NORMAL + 1,
	STEP_CALL	= STEP_RETURN + 1,
	STEP_EXCEPTION_FILTER	= STEP_CALL + 1,
	STEP_EXCEPTION_HANDLER	= STEP_EXCEPTION_FILTER + 1,
	STEP_INTERCEPT	= STEP_EXCEPTION_HANDLER + 1,
	STEP_EXIT	= STEP_INTERCEPT + 1
    } 	CorDebugStepReason;

typedef 
enum LoggingLevelEnum
    {	LTraceLevel0	= 0,
	LTraceLevel1	= LTraceLevel0 + 1,
	LTraceLevel2	= LTraceLevel1 + 1,
	LTraceLevel3	= LTraceLevel2 + 1,
	LTraceLevel4	= LTraceLevel3 + 1,
	LStatusLevel0	= 20,
	LStatusLevel1	= LStatusLevel0 + 1,
	LStatusLevel2	= LStatusLevel1 + 1,
	LStatusLevel3	= LStatusLevel2 + 1,
	LStatusLevel4	= LStatusLevel3 + 1,
	LWarningLevel	= 40,
	LErrorLevel	= 50,
	LPanicLevel	= 100
    } 	LoggingLevelEnum;

typedef 
enum LogSwitchCallReason
    {	SWITCH_CREATE	= 0,
	SWITCH_MODIFY	= SWITCH_CREATE + 1,
	SWITCH_DELETE	= SWITCH_MODIFY + 1
    } 	LogSwitchCallReason;


EXTERN_C const IID IID_ICorDebugManagedCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f60-7538-11d3-8d5b-00104b35e7ef")
    ICorDebugManagedCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Breakpoint( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugBreakpoint *pBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepComplete( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugStepper *pStepper,
            /* [in] */ CorDebugStepReason reason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Break( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exception( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ BOOL unhandled) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EvalComplete( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugEval *pEval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EvalException( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugEval *pEval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateProcess( 
            /* [in] */ ICorDebugProcess *pProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExitProcess( 
            /* [in] */ ICorDebugProcess *pProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateThread( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExitThread( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadModule( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadModule( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadClass( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugClass *c) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadClass( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugClass *c) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DebuggerError( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ HRESULT errorHR,
            /* [in] */ DWORD errorCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogMessage( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ LONG lLevel,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ WCHAR *pMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LogSwitch( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ LONG lLevel,
            /* [in] */ ULONG ulReason,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ WCHAR *pParentName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAppDomain( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ ICorDebugAppDomain *pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExitAppDomain( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ ICorDebugAppDomain *pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadAssembly( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugAssembly *pAssembly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadAssembly( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugAssembly *pAssembly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ControlCTrap( 
            /* [in] */ ICorDebugProcess *pProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NameChange( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateModuleSymbols( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule,
            /* [in] */ IStream *pSymbolStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EditAndContinueRemap( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ BOOL fAccurate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BreakpointSetError( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugBreakpoint *pBreakpoint,
            /* [in] */ DWORD dwError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugManagedCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugManagedCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugManagedCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugManagedCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Breakpoint )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugBreakpoint *pBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *StepComplete )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugStepper *pStepper,
            /* [in] */ CorDebugStepReason reason);
        
        HRESULT ( STDMETHODCALLTYPE *Break )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread);
        
        HRESULT ( STDMETHODCALLTYPE *Exception )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ BOOL unhandled);
        
        HRESULT ( STDMETHODCALLTYPE *EvalComplete )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugEval *pEval);
        
        HRESULT ( STDMETHODCALLTYPE *EvalException )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugEval *pEval);
        
        HRESULT ( STDMETHODCALLTYPE *CreateProcess )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess);
        
        HRESULT ( STDMETHODCALLTYPE *ExitProcess )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess);
        
        HRESULT ( STDMETHODCALLTYPE *CreateThread )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread);
        
        HRESULT ( STDMETHODCALLTYPE *ExitThread )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *thread);
        
        HRESULT ( STDMETHODCALLTYPE *LoadModule )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadModule )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule);
        
        HRESULT ( STDMETHODCALLTYPE *LoadClass )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugClass *c);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadClass )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugClass *c);
        
        HRESULT ( STDMETHODCALLTYPE *DebuggerError )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ HRESULT errorHR,
            /* [in] */ DWORD errorCode);
        
        HRESULT ( STDMETHODCALLTYPE *LogMessage )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ LONG lLevel,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ WCHAR *pMessage);
        
        HRESULT ( STDMETHODCALLTYPE *LogSwitch )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ LONG lLevel,
            /* [in] */ ULONG ulReason,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ WCHAR *pParentName);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAppDomain )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ ICorDebugAppDomain *pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *ExitAppDomain )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ ICorDebugAppDomain *pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *LoadAssembly )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugAssembly *pAssembly);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadAssembly )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugAssembly *pAssembly);
        
        HRESULT ( STDMETHODCALLTYPE *ControlCTrap )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugProcess *pProcess);
        
        HRESULT ( STDMETHODCALLTYPE *NameChange )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateModuleSymbols )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugModule *pModule,
            /* [in] */ IStream *pSymbolStream);
        
        HRESULT ( STDMETHODCALLTYPE *EditAndContinueRemap )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ BOOL fAccurate);
        
        HRESULT ( STDMETHODCALLTYPE *BreakpointSetError )( 
            ICorDebugManagedCallback * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugBreakpoint *pBreakpoint,
            /* [in] */ DWORD dwError);
        
        END_INTERFACE
    } ICorDebugManagedCallbackVtbl;

    interface ICorDebugManagedCallback
    {
        CONST_VTBL struct ICorDebugManagedCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugManagedCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugManagedCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugManagedCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugManagedCallback_Breakpoint(This,pAppDomain,pThread,pBreakpoint)	\
    (This)->lpVtbl -> Breakpoint(This,pAppDomain,pThread,pBreakpoint)

#define ICorDebugManagedCallback_StepComplete(This,pAppDomain,pThread,pStepper,reason)	\
    (This)->lpVtbl -> StepComplete(This,pAppDomain,pThread,pStepper,reason)

#define ICorDebugManagedCallback_Break(This,pAppDomain,thread)	\
    (This)->lpVtbl -> Break(This,pAppDomain,thread)

#define ICorDebugManagedCallback_Exception(This,pAppDomain,pThread,unhandled)	\
    (This)->lpVtbl -> Exception(This,pAppDomain,pThread,unhandled)

#define ICorDebugManagedCallback_EvalComplete(This,pAppDomain,pThread,pEval)	\
    (This)->lpVtbl -> EvalComplete(This,pAppDomain,pThread,pEval)

#define ICorDebugManagedCallback_EvalException(This,pAppDomain,pThread,pEval)	\
    (This)->lpVtbl -> EvalException(This,pAppDomain,pThread,pEval)

#define ICorDebugManagedCallback_CreateProcess(This,pProcess)	\
    (This)->lpVtbl -> CreateProcess(This,pProcess)

#define ICorDebugManagedCallback_ExitProcess(This,pProcess)	\
    (This)->lpVtbl -> ExitProcess(This,pProcess)

#define ICorDebugManagedCallback_CreateThread(This,pAppDomain,thread)	\
    (This)->lpVtbl -> CreateThread(This,pAppDomain,thread)

#define ICorDebugManagedCallback_ExitThread(This,pAppDomain,thread)	\
    (This)->lpVtbl -> ExitThread(This,pAppDomain,thread)

#define ICorDebugManagedCallback_LoadModule(This,pAppDomain,pModule)	\
    (This)->lpVtbl -> LoadModule(This,pAppDomain,pModule)

#define ICorDebugManagedCallback_UnloadModule(This,pAppDomain,pModule)	\
    (This)->lpVtbl -> UnloadModule(This,pAppDomain,pModule)

#define ICorDebugManagedCallback_LoadClass(This,pAppDomain,c)	\
    (This)->lpVtbl -> LoadClass(This,pAppDomain,c)

#define ICorDebugManagedCallback_UnloadClass(This,pAppDomain,c)	\
    (This)->lpVtbl -> UnloadClass(This,pAppDomain,c)

#define ICorDebugManagedCallback_DebuggerError(This,pProcess,errorHR,errorCode)	\
    (This)->lpVtbl -> DebuggerError(This,pProcess,errorHR,errorCode)

#define ICorDebugManagedCallback_LogMessage(This,pAppDomain,pThread,lLevel,pLogSwitchName,pMessage)	\
    (This)->lpVtbl -> LogMessage(This,pAppDomain,pThread,lLevel,pLogSwitchName,pMessage)

#define ICorDebugManagedCallback_LogSwitch(This,pAppDomain,pThread,lLevel,ulReason,pLogSwitchName,pParentName)	\
    (This)->lpVtbl -> LogSwitch(This,pAppDomain,pThread,lLevel,ulReason,pLogSwitchName,pParentName)

#define ICorDebugManagedCallback_CreateAppDomain(This,pProcess,pAppDomain)	\
    (This)->lpVtbl -> CreateAppDomain(This,pProcess,pAppDomain)

#define ICorDebugManagedCallback_ExitAppDomain(This,pProcess,pAppDomain)	\
    (This)->lpVtbl -> ExitAppDomain(This,pProcess,pAppDomain)

#define ICorDebugManagedCallback_LoadAssembly(This,pAppDomain,pAssembly)	\
    (This)->lpVtbl -> LoadAssembly(This,pAppDomain,pAssembly)

#define ICorDebugManagedCallback_UnloadAssembly(This,pAppDomain,pAssembly)	\
    (This)->lpVtbl -> UnloadAssembly(This,pAppDomain,pAssembly)

#define ICorDebugManagedCallback_ControlCTrap(This,pProcess)	\
    (This)->lpVtbl -> ControlCTrap(This,pProcess)

#define ICorDebugManagedCallback_NameChange(This,pAppDomain,pThread)	\
    (This)->lpVtbl -> NameChange(This,pAppDomain,pThread)

#define ICorDebugManagedCallback_UpdateModuleSymbols(This,pAppDomain,pModule,pSymbolStream)	\
    (This)->lpVtbl -> UpdateModuleSymbols(This,pAppDomain,pModule,pSymbolStream)

#define ICorDebugManagedCallback_EditAndContinueRemap(This,pAppDomain,pThread,pFunction,fAccurate)	\
    (This)->lpVtbl -> EditAndContinueRemap(This,pAppDomain,pThread,pFunction,fAccurate)

#define ICorDebugManagedCallback_BreakpointSetError(This,pAppDomain,pThread,pBreakpoint,dwError)	\
    (This)->lpVtbl -> BreakpointSetError(This,pAppDomain,pThread,pBreakpoint,dwError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_Breakpoint_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugBreakpoint *pBreakpoint);


void __RPC_STUB ICorDebugManagedCallback_Breakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_StepComplete_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugStepper *pStepper,
    /* [in] */ CorDebugStepReason reason);


void __RPC_STUB ICorDebugManagedCallback_StepComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_Break_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *thread);


void __RPC_STUB ICorDebugManagedCallback_Break_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_Exception_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ BOOL unhandled);


void __RPC_STUB ICorDebugManagedCallback_Exception_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_EvalComplete_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugEval *pEval);


void __RPC_STUB ICorDebugManagedCallback_EvalComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_EvalException_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugEval *pEval);


void __RPC_STUB ICorDebugManagedCallback_EvalException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_CreateProcess_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess);


void __RPC_STUB ICorDebugManagedCallback_CreateProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_ExitProcess_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess);


void __RPC_STUB ICorDebugManagedCallback_ExitProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_CreateThread_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *thread);


void __RPC_STUB ICorDebugManagedCallback_CreateThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_ExitThread_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *thread);


void __RPC_STUB ICorDebugManagedCallback_ExitThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LoadModule_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugModule *pModule);


void __RPC_STUB ICorDebugManagedCallback_LoadModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_UnloadModule_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugModule *pModule);


void __RPC_STUB ICorDebugManagedCallback_UnloadModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LoadClass_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugClass *c);


void __RPC_STUB ICorDebugManagedCallback_LoadClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_UnloadClass_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugClass *c);


void __RPC_STUB ICorDebugManagedCallback_UnloadClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_DebuggerError_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ HRESULT errorHR,
    /* [in] */ DWORD errorCode);


void __RPC_STUB ICorDebugManagedCallback_DebuggerError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LogMessage_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ LONG lLevel,
    /* [in] */ WCHAR *pLogSwitchName,
    /* [in] */ WCHAR *pMessage);


void __RPC_STUB ICorDebugManagedCallback_LogMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LogSwitch_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ LONG lLevel,
    /* [in] */ ULONG ulReason,
    /* [in] */ WCHAR *pLogSwitchName,
    /* [in] */ WCHAR *pParentName);


void __RPC_STUB ICorDebugManagedCallback_LogSwitch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_CreateAppDomain_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ ICorDebugAppDomain *pAppDomain);


void __RPC_STUB ICorDebugManagedCallback_CreateAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_ExitAppDomain_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ ICorDebugAppDomain *pAppDomain);


void __RPC_STUB ICorDebugManagedCallback_ExitAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_LoadAssembly_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugAssembly *pAssembly);


void __RPC_STUB ICorDebugManagedCallback_LoadAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_UnloadAssembly_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugAssembly *pAssembly);


void __RPC_STUB ICorDebugManagedCallback_UnloadAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_ControlCTrap_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugProcess *pProcess);


void __RPC_STUB ICorDebugManagedCallback_ControlCTrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_NameChange_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread);


void __RPC_STUB ICorDebugManagedCallback_NameChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_UpdateModuleSymbols_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugModule *pModule,
    /* [in] */ IStream *pSymbolStream);


void __RPC_STUB ICorDebugManagedCallback_UpdateModuleSymbols_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_EditAndContinueRemap_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugFunction *pFunction,
    /* [in] */ BOOL fAccurate);


void __RPC_STUB ICorDebugManagedCallback_EditAndContinueRemap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback_BreakpointSetError_Proxy( 
    ICorDebugManagedCallback * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugBreakpoint *pBreakpoint,
    /* [in] */ DWORD dwError);


void __RPC_STUB ICorDebugManagedCallback_BreakpointSetError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugManagedCallback_INTERFACE_DEFINED__ */


#ifndef __ICorDebugManagedCallback2_INTERFACE_DEFINED__
#define __ICorDebugManagedCallback2_INTERFACE_DEFINED__

/* interface ICorDebugManagedCallback2 */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugExceptionCallbackType
    {	DEBUG_EXCEPTION_FIRST_CHANCE	= 1,
	DEBUG_EXCEPTION_USER_FIRST_CHANCE	= 2,
	DEBUG_EXCEPTION_CATCH_HANDLER_FOUND	= 3,
	DEBUG_EXCEPTION_UNHANDLED	= 4
    } 	CorDebugExceptionCallbackType;

typedef 
enum CorDebugExceptionFlags
    {	DEBUG_EXCEPTION_CAN_BE_INTERCEPTED	= 0x1
    } 	CorDebugExceptionFlags;

typedef 
enum CorDebugExceptionUnwindCallbackType
    {	DEBUG_EXCEPTION_UNWIND_BEGIN	= 1,
	DEBUG_EXCEPTION_INTERCEPTED	= 2
    } 	CorDebugExceptionUnwindCallbackType;


EXTERN_C const IID IID_ICorDebugManagedCallback2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("250E5EEA-DB5C-4C76-B6F3-8C46F12E3203")
    ICorDebugManagedCallback2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FunctionRemapOpportunity( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pOldFunction,
            /* [in] */ ICorDebugFunction *pNewFunction,
            /* [in] */ ULONG32 oldILOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateConnection( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ CONNID dwConnectionId,
            /* [in] */ WCHAR *pConnName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangeConnection( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ CONNID dwConnectionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyConnection( 
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ CONNID dwConnectionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Exception( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [in] */ ULONG32 nOffset,
            /* [in] */ CorDebugExceptionCallbackType dwEventType,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwind( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ CorDebugExceptionUnwindCallbackType dwEventType,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FunctionRemapComplete( 
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MDANotification( 
            /* [in] */ ICorDebugController *pController,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugMDA *pMDA) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugManagedCallback2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugManagedCallback2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugManagedCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *FunctionRemapOpportunity )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pOldFunction,
            /* [in] */ ICorDebugFunction *pNewFunction,
            /* [in] */ ULONG32 oldILOffset);
        
        HRESULT ( STDMETHODCALLTYPE *CreateConnection )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ CONNID dwConnectionId,
            /* [in] */ WCHAR *pConnName);
        
        HRESULT ( STDMETHODCALLTYPE *ChangeConnection )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ CONNID dwConnectionId);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyConnection )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugProcess *pProcess,
            /* [in] */ CONNID dwConnectionId);
        
        HRESULT ( STDMETHODCALLTYPE *Exception )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [in] */ ULONG32 nOffset,
            /* [in] */ CorDebugExceptionCallbackType dwEventType,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwind )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ CorDebugExceptionUnwindCallbackType dwEventType,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *FunctionRemapComplete )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugAppDomain *pAppDomain,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugFunction *pFunction);
        
        HRESULT ( STDMETHODCALLTYPE *MDANotification )( 
            ICorDebugManagedCallback2 * This,
            /* [in] */ ICorDebugController *pController,
            /* [in] */ ICorDebugThread *pThread,
            /* [in] */ ICorDebugMDA *pMDA);
        
        END_INTERFACE
    } ICorDebugManagedCallback2Vtbl;

    interface ICorDebugManagedCallback2
    {
        CONST_VTBL struct ICorDebugManagedCallback2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugManagedCallback2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugManagedCallback2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugManagedCallback2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugManagedCallback2_FunctionRemapOpportunity(This,pAppDomain,pThread,pOldFunction,pNewFunction,oldILOffset)	\
    (This)->lpVtbl -> FunctionRemapOpportunity(This,pAppDomain,pThread,pOldFunction,pNewFunction,oldILOffset)

#define ICorDebugManagedCallback2_CreateConnection(This,pProcess,dwConnectionId,pConnName)	\
    (This)->lpVtbl -> CreateConnection(This,pProcess,dwConnectionId,pConnName)

#define ICorDebugManagedCallback2_ChangeConnection(This,pProcess,dwConnectionId)	\
    (This)->lpVtbl -> ChangeConnection(This,pProcess,dwConnectionId)

#define ICorDebugManagedCallback2_DestroyConnection(This,pProcess,dwConnectionId)	\
    (This)->lpVtbl -> DestroyConnection(This,pProcess,dwConnectionId)

#define ICorDebugManagedCallback2_Exception(This,pAppDomain,pThread,pFrame,nOffset,dwEventType,dwFlags)	\
    (This)->lpVtbl -> Exception(This,pAppDomain,pThread,pFrame,nOffset,dwEventType,dwFlags)

#define ICorDebugManagedCallback2_ExceptionUnwind(This,pAppDomain,pThread,dwEventType,dwFlags)	\
    (This)->lpVtbl -> ExceptionUnwind(This,pAppDomain,pThread,dwEventType,dwFlags)

#define ICorDebugManagedCallback2_FunctionRemapComplete(This,pAppDomain,pThread,pFunction)	\
    (This)->lpVtbl -> FunctionRemapComplete(This,pAppDomain,pThread,pFunction)

#define ICorDebugManagedCallback2_MDANotification(This,pController,pThread,pMDA)	\
    (This)->lpVtbl -> MDANotification(This,pController,pThread,pMDA)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_FunctionRemapOpportunity_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugFunction *pOldFunction,
    /* [in] */ ICorDebugFunction *pNewFunction,
    /* [in] */ ULONG32 oldILOffset);


void __RPC_STUB ICorDebugManagedCallback2_FunctionRemapOpportunity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_CreateConnection_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ CONNID dwConnectionId,
    /* [in] */ WCHAR *pConnName);


void __RPC_STUB ICorDebugManagedCallback2_CreateConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_ChangeConnection_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ CONNID dwConnectionId);


void __RPC_STUB ICorDebugManagedCallback2_ChangeConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_DestroyConnection_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugProcess *pProcess,
    /* [in] */ CONNID dwConnectionId);


void __RPC_STUB ICorDebugManagedCallback2_DestroyConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_Exception_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugFrame *pFrame,
    /* [in] */ ULONG32 nOffset,
    /* [in] */ CorDebugExceptionCallbackType dwEventType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICorDebugManagedCallback2_Exception_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_ExceptionUnwind_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ CorDebugExceptionUnwindCallbackType dwEventType,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICorDebugManagedCallback2_ExceptionUnwind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_FunctionRemapComplete_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugAppDomain *pAppDomain,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugFunction *pFunction);


void __RPC_STUB ICorDebugManagedCallback2_FunctionRemapComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugManagedCallback2_MDANotification_Proxy( 
    ICorDebugManagedCallback2 * This,
    /* [in] */ ICorDebugController *pController,
    /* [in] */ ICorDebugThread *pThread,
    /* [in] */ ICorDebugMDA *pMDA);


void __RPC_STUB ICorDebugManagedCallback2_MDANotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugManagedCallback2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugUnmanagedCallback_INTERFACE_DEFINED__
#define __ICorDebugUnmanagedCallback_INTERFACE_DEFINED__

/* interface ICorDebugUnmanagedCallback */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugUnmanagedCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5263E909-8CB5-11d3-BD2F-0000F80849BD")
    ICorDebugUnmanagedCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DebugEvent( 
            /* [in] */ LPDEBUG_EVENT pDebugEvent,
            /* [in] */ BOOL fOutOfBand) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugUnmanagedCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugUnmanagedCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugUnmanagedCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugUnmanagedCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *DebugEvent )( 
            ICorDebugUnmanagedCallback * This,
            /* [in] */ LPDEBUG_EVENT pDebugEvent,
            /* [in] */ BOOL fOutOfBand);
        
        END_INTERFACE
    } ICorDebugUnmanagedCallbackVtbl;

    interface ICorDebugUnmanagedCallback
    {
        CONST_VTBL struct ICorDebugUnmanagedCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugUnmanagedCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugUnmanagedCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugUnmanagedCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugUnmanagedCallback_DebugEvent(This,pDebugEvent,fOutOfBand)	\
    (This)->lpVtbl -> DebugEvent(This,pDebugEvent,fOutOfBand)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugUnmanagedCallback_DebugEvent_Proxy( 
    ICorDebugUnmanagedCallback * This,
    /* [in] */ LPDEBUG_EVENT pDebugEvent,
    /* [in] */ BOOL fOutOfBand);


void __RPC_STUB ICorDebugUnmanagedCallback_DebugEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugUnmanagedCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cordebug_0096 */
/* [local] */ 

typedef 
enum CorDebugCreateProcessFlags
    {	DEBUG_NO_SPECIAL_OPTIONS	= 0
    } 	CorDebugCreateProcessFlags;

typedef 
enum CorDebugHandleType
    {	HANDLE_STRONG	= 1,
	HANDLE_WEAK_TRACK_RESURRECTION	= 2
    } 	CorDebugHandleType;



extern RPC_IF_HANDLE __MIDL_itf_cordebug_0096_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cordebug_0096_v0_0_s_ifspec;

#ifndef __ICorDebug_INTERFACE_DEFINED__
#define __ICorDebug_INTERFACE_DEFINED__

/* interface ICorDebug */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ICorDebug;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f61-7538-11d3-8d5b-00104b35e7ef")
    ICorDebug : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetManagedHandler( 
            /* [in] */ ICorDebugManagedCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnmanagedHandler( 
            /* [in] */ ICorDebugUnmanagedCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateProcess( 
            /* [in] */ LPCWSTR lpApplicationName,
            /* [in] */ LPWSTR lpCommandLine,
            /* [in] */ LPSECURITY_ATTRIBUTES lpProcessAttributes,
            /* [in] */ LPSECURITY_ATTRIBUTES lpThreadAttributes,
            /* [in] */ BOOL bInheritHandles,
            /* [in] */ DWORD dwCreationFlags,
            /* [in] */ PVOID lpEnvironment,
            /* [in] */ LPCWSTR lpCurrentDirectory,
            /* [in] */ LPSTARTUPINFOW lpStartupInfo,
            /* [in] */ LPPROCESS_INFORMATION lpProcessInformation,
            /* [in] */ CorDebugCreateProcessFlags debuggingFlags,
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DebugActiveProcess( 
            /* [in] */ DWORD id,
            /* [in] */ BOOL win32Attach,
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateProcesses( 
            /* [out] */ ICorDebugProcessEnum **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [in] */ DWORD dwProcessId,
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanLaunchOrAttach( 
            /* [in] */ DWORD dwProcessId,
            /* [in] */ BOOL win32DebuggingEnabled) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebug * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebug * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICorDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            ICorDebug * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetManagedHandler )( 
            ICorDebug * This,
            /* [in] */ ICorDebugManagedCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnmanagedHandler )( 
            ICorDebug * This,
            /* [in] */ ICorDebugUnmanagedCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *CreateProcess )( 
            ICorDebug * This,
            /* [in] */ LPCWSTR lpApplicationName,
            /* [in] */ LPWSTR lpCommandLine,
            /* [in] */ LPSECURITY_ATTRIBUTES lpProcessAttributes,
            /* [in] */ LPSECURITY_ATTRIBUTES lpThreadAttributes,
            /* [in] */ BOOL bInheritHandles,
            /* [in] */ DWORD dwCreationFlags,
            /* [in] */ PVOID lpEnvironment,
            /* [in] */ LPCWSTR lpCurrentDirectory,
            /* [in] */ LPSTARTUPINFOW lpStartupInfo,
            /* [in] */ LPPROCESS_INFORMATION lpProcessInformation,
            /* [in] */ CorDebugCreateProcessFlags debuggingFlags,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *DebugActiveProcess )( 
            ICorDebug * This,
            /* [in] */ DWORD id,
            /* [in] */ BOOL win32Attach,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateProcesses )( 
            ICorDebug * This,
            /* [out] */ ICorDebugProcessEnum **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebug * This,
            /* [in] */ DWORD dwProcessId,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *CanLaunchOrAttach )( 
            ICorDebug * This,
            /* [in] */ DWORD dwProcessId,
            /* [in] */ BOOL win32DebuggingEnabled);
        
        END_INTERFACE
    } ICorDebugVtbl;

    interface ICorDebug
    {
        CONST_VTBL struct ICorDebugVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebug_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebug_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebug_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebug_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define ICorDebug_Terminate(This)	\
    (This)->lpVtbl -> Terminate(This)

#define ICorDebug_SetManagedHandler(This,pCallback)	\
    (This)->lpVtbl -> SetManagedHandler(This,pCallback)

#define ICorDebug_SetUnmanagedHandler(This,pCallback)	\
    (This)->lpVtbl -> SetUnmanagedHandler(This,pCallback)

#define ICorDebug_CreateProcess(This,lpApplicationName,lpCommandLine,lpProcessAttributes,lpThreadAttributes,bInheritHandles,dwCreationFlags,lpEnvironment,lpCurrentDirectory,lpStartupInfo,lpProcessInformation,debuggingFlags,ppProcess)	\
    (This)->lpVtbl -> CreateProcess(This,lpApplicationName,lpCommandLine,lpProcessAttributes,lpThreadAttributes,bInheritHandles,dwCreationFlags,lpEnvironment,lpCurrentDirectory,lpStartupInfo,lpProcessInformation,debuggingFlags,ppProcess)

#define ICorDebug_DebugActiveProcess(This,id,win32Attach,ppProcess)	\
    (This)->lpVtbl -> DebugActiveProcess(This,id,win32Attach,ppProcess)

#define ICorDebug_EnumerateProcesses(This,ppProcess)	\
    (This)->lpVtbl -> EnumerateProcesses(This,ppProcess)

#define ICorDebug_GetProcess(This,dwProcessId,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,dwProcessId,ppProcess)

#define ICorDebug_CanLaunchOrAttach(This,dwProcessId,win32DebuggingEnabled)	\
    (This)->lpVtbl -> CanLaunchOrAttach(This,dwProcessId,win32DebuggingEnabled)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebug_Initialize_Proxy( 
    ICorDebug * This);


void __RPC_STUB ICorDebug_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_Terminate_Proxy( 
    ICorDebug * This);


void __RPC_STUB ICorDebug_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_SetManagedHandler_Proxy( 
    ICorDebug * This,
    /* [in] */ ICorDebugManagedCallback *pCallback);


void __RPC_STUB ICorDebug_SetManagedHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_SetUnmanagedHandler_Proxy( 
    ICorDebug * This,
    /* [in] */ ICorDebugUnmanagedCallback *pCallback);


void __RPC_STUB ICorDebug_SetUnmanagedHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_CreateProcess_Proxy( 
    ICorDebug * This,
    /* [in] */ LPCWSTR lpApplicationName,
    /* [in] */ LPWSTR lpCommandLine,
    /* [in] */ LPSECURITY_ATTRIBUTES lpProcessAttributes,
    /* [in] */ LPSECURITY_ATTRIBUTES lpThreadAttributes,
    /* [in] */ BOOL bInheritHandles,
    /* [in] */ DWORD dwCreationFlags,
    /* [in] */ PVOID lpEnvironment,
    /* [in] */ LPCWSTR lpCurrentDirectory,
    /* [in] */ LPSTARTUPINFOW lpStartupInfo,
    /* [in] */ LPPROCESS_INFORMATION lpProcessInformation,
    /* [in] */ CorDebugCreateProcessFlags debuggingFlags,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebug_CreateProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_DebugActiveProcess_Proxy( 
    ICorDebug * This,
    /* [in] */ DWORD id,
    /* [in] */ BOOL win32Attach,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebug_DebugActiveProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_EnumerateProcesses_Proxy( 
    ICorDebug * This,
    /* [out] */ ICorDebugProcessEnum **ppProcess);


void __RPC_STUB ICorDebug_EnumerateProcesses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_GetProcess_Proxy( 
    ICorDebug * This,
    /* [in] */ DWORD dwProcessId,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebug_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebug_CanLaunchOrAttach_Proxy( 
    ICorDebug * This,
    /* [in] */ DWORD dwProcessId,
    /* [in] */ BOOL win32DebuggingEnabled);


void __RPC_STUB ICorDebug_CanLaunchOrAttach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebug_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cordebug_0097 */
/* [local] */ 

typedef struct _COR_VERSION
    {
    DWORD dwMajor;
    DWORD dwMinor;
    DWORD dwBuild;
    DWORD dwSubBuild;
    } 	COR_VERSION;



extern RPC_IF_HANDLE __MIDL_itf_cordebug_0097_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cordebug_0097_v0_0_s_ifspec;

#ifndef __ICorDebug2_INTERFACE_DEFINED__
#define __ICorDebug2_INTERFACE_DEFINED__

/* interface ICorDebug2 */
/* [unique][uuid][local][object] */ 

typedef 
enum CorDebugInterfaceVersion
    {	CorDebugInvalidVersion	= 0,
	CorDebugVersion_1_0	= CorDebugInvalidVersion + 1,
	ver_ICorDebugManagedCallback	= CorDebugVersion_1_0,
	ver_ICorDebugUnmanagedCallback	= CorDebugVersion_1_0,
	ver_ICorDebug	= CorDebugVersion_1_0,
	ver_ICorDebugController	= CorDebugVersion_1_0,
	ver_ICorDebugAppDomain	= CorDebugVersion_1_0,
	ver_ICorDebugAssembly	= CorDebugVersion_1_0,
	ver_ICorDebugProcess	= CorDebugVersion_1_0,
	ver_ICorDebugBreakpoint	= CorDebugVersion_1_0,
	ver_ICorDebugFunctionBreakpoint	= CorDebugVersion_1_0,
	ver_ICorDebugModuleBreakpoint	= CorDebugVersion_1_0,
	ver_ICorDebugValueBreakpoint	= CorDebugVersion_1_0,
	ver_ICorDebugStepper	= CorDebugVersion_1_0,
	ver_ICorDebugRegisterSet	= CorDebugVersion_1_0,
	ver_ICorDebugThread	= CorDebugVersion_1_0,
	ver_ICorDebugChain	= CorDebugVersion_1_0,
	ver_ICorDebugFrame	= CorDebugVersion_1_0,
	ver_ICorDebugILFrame	= CorDebugVersion_1_0,
	ver_ICorDebugNativeFrame	= CorDebugVersion_1_0,
	ver_ICorDebugModule	= CorDebugVersion_1_0,
	ver_ICorDebugFunction	= CorDebugVersion_1_0,
	ver_ICorDebugCode	= CorDebugVersion_1_0,
	ver_ICorDebugClass	= CorDebugVersion_1_0,
	ver_ICorDebugEval	= CorDebugVersion_1_0,
	ver_ICorDebugValue	= CorDebugVersion_1_0,
	ver_ICorDebugGenericValue	= CorDebugVersion_1_0,
	ver_ICorDebugReferenceValue	= CorDebugVersion_1_0,
	ver_ICorDebugHeapValue	= CorDebugVersion_1_0,
	ver_ICorDebugObjectValue	= CorDebugVersion_1_0,
	ver_ICorDebugBoxValue	= CorDebugVersion_1_0,
	ver_ICorDebugStringValue	= CorDebugVersion_1_0,
	ver_ICorDebugArrayValue	= CorDebugVersion_1_0,
	ver_ICorDebugContext	= CorDebugVersion_1_0,
	ver_ICorDebugEnum	= CorDebugVersion_1_0,
	ver_ICorDebugObjectEnum	= CorDebugVersion_1_0,
	ver_ICorDebugBreakpointEnum	= CorDebugVersion_1_0,
	ver_ICorDebugStepperEnum	= CorDebugVersion_1_0,
	ver_ICorDebugProcessEnum	= CorDebugVersion_1_0,
	ver_ICorDebugThreadEnum	= CorDebugVersion_1_0,
	ver_ICorDebugFrameEnum	= CorDebugVersion_1_0,
	ver_ICorDebugChainEnum	= CorDebugVersion_1_0,
	ver_ICorDebugModuleEnum	= CorDebugVersion_1_0,
	ver_ICorDebugValueEnum	= CorDebugVersion_1_0,
	ver_ICorDebugCodeEnum	= CorDebugVersion_1_0,
	ver_ICorDebugTypeEnum	= CorDebugVersion_1_0,
	ver_ICorDebugErrorInfoEnum	= CorDebugVersion_1_0,
	ver_ICorDebugAppDomainEnum	= CorDebugVersion_1_0,
	ver_ICorDebugAssemblyEnum	= CorDebugVersion_1_0,
	ver_ICorDebugEditAndContinueErrorInfo	= CorDebugVersion_1_0,
	ver_ICorDebugEditAndContinueSnapshot	= CorDebugVersion_1_0,
	CorDebugVersion_1_1	= CorDebugVersion_1_0 + 1,
	CorDebugVersion_2_0	= CorDebugVersion_1_1 + 1,
	ver_ICorDebugManagedCallback2	= CorDebugVersion_2_0,
	ver_ICorDebugAppDomain2	= CorDebugVersion_2_0,
	ver_ICorDebugAssembly2	= CorDebugVersion_2_0,
	ver_ICorDebugProcess2	= CorDebugVersion_2_0,
	ver_ICorDebugStepper2	= CorDebugVersion_2_0,
	ver_ICorDebugRegisterSet2	= CorDebugVersion_2_0,
	ver_ICorDebugThread2	= CorDebugVersion_2_0,
	ver_ICorDebugILFrame2	= CorDebugVersion_2_0,
	ver_ICorDebugModule2	= CorDebugVersion_2_0,
	ver_ICorDebugFunction2	= CorDebugVersion_2_0,
	ver_ICorDebugCode2	= CorDebugVersion_2_0,
	ver_ICorDebugClass2	= CorDebugVersion_2_0,
	ver_ICorDebugValue2	= CorDebugVersion_2_0,
	ver_ICorDebugEval2	= CorDebugVersion_2_0,
	ver_ICorDebugObjectValue2	= CorDebugVersion_2_0,
	CorDebugLatestVersion	= CorDebugVersion_2_0
    } 	CorDebugInterfaceVersion;


EXTERN_C const IID IID_ICorDebug2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ECCCCF2E-B286-4b3e-A983-860A8793D105")
    ICorDebug2 : public IUnknown
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICorDebug2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebug2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebug2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebug2 * This);
        
        END_INTERFACE
    } ICorDebug2Vtbl;

    interface ICorDebug2
    {
        CONST_VTBL struct ICorDebug2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebug2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebug2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebug2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICorDebug2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_cordebug_0098 */
/* [local] */ 

typedef 
enum CorDebugThreadState
    {	THREAD_RUN	= 0,
	THREAD_SUSPEND	= THREAD_RUN + 1
    } 	CorDebugThreadState;



extern RPC_IF_HANDLE __MIDL_itf_cordebug_0098_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_cordebug_0098_v0_0_s_ifspec;

#ifndef __ICorDebugController_INTERFACE_DEFINED__
#define __ICorDebugController_INTERFACE_DEFINED__

/* interface ICorDebugController */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugController;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f62-7538-11d3-8d5b-00104b35e7ef")
    ICorDebugController : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Stop( 
            /* [in] */ DWORD dwTimeoutIgnored) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Continue( 
            /* [in] */ BOOL fIsOutOfBand) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsRunning( 
            /* [out] */ BOOL *pbRunning) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasQueuedCallbacks( 
            /* [in] */ ICorDebugThread *pThread,
            /* [out] */ BOOL *pbQueued) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateThreads( 
            /* [out] */ ICorDebugThreadEnum **ppThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAllThreadsDebugState( 
            /* [in] */ CorDebugThreadState state,
            /* [in] */ ICorDebugThread *pExceptThisThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Detach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Terminate( 
            /* [in] */ UINT exitCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanCommitChanges( 
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CommitChanges( 
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugControllerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugController * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugController * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugController * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ICorDebugController * This,
            /* [in] */ DWORD dwTimeoutIgnored);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            ICorDebugController * This,
            /* [in] */ BOOL fIsOutOfBand);
        
        HRESULT ( STDMETHODCALLTYPE *IsRunning )( 
            ICorDebugController * This,
            /* [out] */ BOOL *pbRunning);
        
        HRESULT ( STDMETHODCALLTYPE *HasQueuedCallbacks )( 
            ICorDebugController * This,
            /* [in] */ ICorDebugThread *pThread,
            /* [out] */ BOOL *pbQueued);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateThreads )( 
            ICorDebugController * This,
            /* [out] */ ICorDebugThreadEnum **ppThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllThreadsDebugState )( 
            ICorDebugController * This,
            /* [in] */ CorDebugThreadState state,
            /* [in] */ ICorDebugThread *pExceptThisThread);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            ICorDebugController * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            ICorDebugController * This,
            /* [in] */ UINT exitCode);
        
        HRESULT ( STDMETHODCALLTYPE *CanCommitChanges )( 
            ICorDebugController * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChanges )( 
            ICorDebugController * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        END_INTERFACE
    } ICorDebugControllerVtbl;

    interface ICorDebugController
    {
        CONST_VTBL struct ICorDebugControllerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugController_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugController_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugController_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugController_Stop(This,dwTimeoutIgnored)	\
    (This)->lpVtbl -> Stop(This,dwTimeoutIgnored)

#define ICorDebugController_Continue(This,fIsOutOfBand)	\
    (This)->lpVtbl -> Continue(This,fIsOutOfBand)

#define ICorDebugController_IsRunning(This,pbRunning)	\
    (This)->lpVtbl -> IsRunning(This,pbRunning)

#define ICorDebugController_HasQueuedCallbacks(This,pThread,pbQueued)	\
    (This)->lpVtbl -> HasQueuedCallbacks(This,pThread,pbQueued)

#define ICorDebugController_EnumerateThreads(This,ppThreads)	\
    (This)->lpVtbl -> EnumerateThreads(This,ppThreads)

#define ICorDebugController_SetAllThreadsDebugState(This,state,pExceptThisThread)	\
    (This)->lpVtbl -> SetAllThreadsDebugState(This,state,pExceptThisThread)

#define ICorDebugController_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define ICorDebugController_Terminate(This,exitCode)	\
    (This)->lpVtbl -> Terminate(This,exitCode)

#define ICorDebugController_CanCommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CanCommitChanges(This,cSnapshots,pSnapshots,pError)

#define ICorDebugController_CommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CommitChanges(This,cSnapshots,pSnapshots,pError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugController_Stop_Proxy( 
    ICorDebugController * This,
    /* [in] */ DWORD dwTimeoutIgnored);


void __RPC_STUB ICorDebugController_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_Continue_Proxy( 
    ICorDebugController * This,
    /* [in] */ BOOL fIsOutOfBand);


void __RPC_STUB ICorDebugController_Continue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_IsRunning_Proxy( 
    ICorDebugController * This,
    /* [out] */ BOOL *pbRunning);


void __RPC_STUB ICorDebugController_IsRunning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_HasQueuedCallbacks_Proxy( 
    ICorDebugController * This,
    /* [in] */ ICorDebugThread *pThread,
    /* [out] */ BOOL *pbQueued);


void __RPC_STUB ICorDebugController_HasQueuedCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_EnumerateThreads_Proxy( 
    ICorDebugController * This,
    /* [out] */ ICorDebugThreadEnum **ppThreads);


void __RPC_STUB ICorDebugController_EnumerateThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_SetAllThreadsDebugState_Proxy( 
    ICorDebugController * This,
    /* [in] */ CorDebugThreadState state,
    /* [in] */ ICorDebugThread *pExceptThisThread);


void __RPC_STUB ICorDebugController_SetAllThreadsDebugState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_Detach_Proxy( 
    ICorDebugController * This);


void __RPC_STUB ICorDebugController_Detach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_Terminate_Proxy( 
    ICorDebugController * This,
    /* [in] */ UINT exitCode);


void __RPC_STUB ICorDebugController_Terminate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_CanCommitChanges_Proxy( 
    ICorDebugController * This,
    /* [in] */ ULONG cSnapshots,
    /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
    /* [out] */ ICorDebugErrorInfoEnum **pError);


void __RPC_STUB ICorDebugController_CanCommitChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugController_CommitChanges_Proxy( 
    ICorDebugController * This,
    /* [in] */ ULONG cSnapshots,
    /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
    /* [out] */ ICorDebugErrorInfoEnum **pError);


void __RPC_STUB ICorDebugController_CommitChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugController_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAppDomain_INTERFACE_DEFINED__
#define __ICorDebugAppDomain_INTERFACE_DEFINED__

/* interface ICorDebugAppDomain */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAppDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f63-7538-11d3-8d5b-00104b35e7ef")
    ICorDebugAppDomain : public ICorDebugController
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateAssemblies( 
            /* [out] */ ICorDebugAssemblyEnum **ppAssemblies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleFromMetaDataInterface( 
            /* [in] */ IUnknown *pIMetaData,
            /* [out] */ ICorDebugModule **ppModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateBreakpoints( 
            /* [out] */ ICorDebugBreakpointEnum **ppBreakpoints) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateSteppers( 
            /* [out] */ ICorDebugStepperEnum **ppSteppers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAttached( 
            /* [out] */ BOOL *pbAttached) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ ICorDebugValue **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Attach( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ ULONG32 *pId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAppDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAppDomain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAppDomain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAppDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ICorDebugAppDomain * This,
            /* [in] */ DWORD dwTimeoutIgnored);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            ICorDebugAppDomain * This,
            /* [in] */ BOOL fIsOutOfBand);
        
        HRESULT ( STDMETHODCALLTYPE *IsRunning )( 
            ICorDebugAppDomain * This,
            /* [out] */ BOOL *pbRunning);
        
        HRESULT ( STDMETHODCALLTYPE *HasQueuedCallbacks )( 
            ICorDebugAppDomain * This,
            /* [in] */ ICorDebugThread *pThread,
            /* [out] */ BOOL *pbQueued);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateThreads )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugThreadEnum **ppThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllThreadsDebugState )( 
            ICorDebugAppDomain * This,
            /* [in] */ CorDebugThreadState state,
            /* [in] */ ICorDebugThread *pExceptThisThread);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            ICorDebugAppDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            ICorDebugAppDomain * This,
            /* [in] */ UINT exitCode);
        
        HRESULT ( STDMETHODCALLTYPE *CanCommitChanges )( 
            ICorDebugAppDomain * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChanges )( 
            ICorDebugAppDomain * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateAssemblies )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugAssemblyEnum **ppAssemblies);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleFromMetaDataInterface )( 
            ICorDebugAppDomain * This,
            /* [in] */ IUnknown *pIMetaData,
            /* [out] */ ICorDebugModule **ppModule);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateBreakpoints )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugBreakpointEnum **ppBreakpoints);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateSteppers )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugStepperEnum **ppSteppers);
        
        HRESULT ( STDMETHODCALLTYPE *IsAttached )( 
            ICorDebugAppDomain * This,
            /* [out] */ BOOL *pbAttached);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorDebugAppDomain * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ICorDebugAppDomain * This,
            /* [out] */ ICorDebugValue **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *Attach )( 
            ICorDebugAppDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ICorDebugAppDomain * This,
            /* [out] */ ULONG32 *pId);
        
        END_INTERFACE
    } ICorDebugAppDomainVtbl;

    interface ICorDebugAppDomain
    {
        CONST_VTBL struct ICorDebugAppDomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAppDomain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAppDomain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAppDomain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAppDomain_Stop(This,dwTimeoutIgnored)	\
    (This)->lpVtbl -> Stop(This,dwTimeoutIgnored)

#define ICorDebugAppDomain_Continue(This,fIsOutOfBand)	\
    (This)->lpVtbl -> Continue(This,fIsOutOfBand)

#define ICorDebugAppDomain_IsRunning(This,pbRunning)	\
    (This)->lpVtbl -> IsRunning(This,pbRunning)

#define ICorDebugAppDomain_HasQueuedCallbacks(This,pThread,pbQueued)	\
    (This)->lpVtbl -> HasQueuedCallbacks(This,pThread,pbQueued)

#define ICorDebugAppDomain_EnumerateThreads(This,ppThreads)	\
    (This)->lpVtbl -> EnumerateThreads(This,ppThreads)

#define ICorDebugAppDomain_SetAllThreadsDebugState(This,state,pExceptThisThread)	\
    (This)->lpVtbl -> SetAllThreadsDebugState(This,state,pExceptThisThread)

#define ICorDebugAppDomain_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define ICorDebugAppDomain_Terminate(This,exitCode)	\
    (This)->lpVtbl -> Terminate(This,exitCode)

#define ICorDebugAppDomain_CanCommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CanCommitChanges(This,cSnapshots,pSnapshots,pError)

#define ICorDebugAppDomain_CommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CommitChanges(This,cSnapshots,pSnapshots,pError)


#define ICorDebugAppDomain_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define ICorDebugAppDomain_EnumerateAssemblies(This,ppAssemblies)	\
    (This)->lpVtbl -> EnumerateAssemblies(This,ppAssemblies)

#define ICorDebugAppDomain_GetModuleFromMetaDataInterface(This,pIMetaData,ppModule)	\
    (This)->lpVtbl -> GetModuleFromMetaDataInterface(This,pIMetaData,ppModule)

#define ICorDebugAppDomain_EnumerateBreakpoints(This,ppBreakpoints)	\
    (This)->lpVtbl -> EnumerateBreakpoints(This,ppBreakpoints)

#define ICorDebugAppDomain_EnumerateSteppers(This,ppSteppers)	\
    (This)->lpVtbl -> EnumerateSteppers(This,ppSteppers)

#define ICorDebugAppDomain_IsAttached(This,pbAttached)	\
    (This)->lpVtbl -> IsAttached(This,pbAttached)

#define ICorDebugAppDomain_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ICorDebugAppDomain_GetObject(This,ppObject)	\
    (This)->lpVtbl -> GetObject(This,ppObject)

#define ICorDebugAppDomain_Attach(This)	\
    (This)->lpVtbl -> Attach(This)

#define ICorDebugAppDomain_GetID(This,pId)	\
    (This)->lpVtbl -> GetID(This,pId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetProcess_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebugAppDomain_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_EnumerateAssemblies_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugAssemblyEnum **ppAssemblies);


void __RPC_STUB ICorDebugAppDomain_EnumerateAssemblies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetModuleFromMetaDataInterface_Proxy( 
    ICorDebugAppDomain * This,
    /* [in] */ IUnknown *pIMetaData,
    /* [out] */ ICorDebugModule **ppModule);


void __RPC_STUB ICorDebugAppDomain_GetModuleFromMetaDataInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_EnumerateBreakpoints_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugBreakpointEnum **ppBreakpoints);


void __RPC_STUB ICorDebugAppDomain_EnumerateBreakpoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_EnumerateSteppers_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugStepperEnum **ppSteppers);


void __RPC_STUB ICorDebugAppDomain_EnumerateSteppers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_IsAttached_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ BOOL *pbAttached);


void __RPC_STUB ICorDebugAppDomain_IsAttached_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetName_Proxy( 
    ICorDebugAppDomain * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugAppDomain_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetObject_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ICorDebugValue **ppObject);


void __RPC_STUB ICorDebugAppDomain_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_Attach_Proxy( 
    ICorDebugAppDomain * This);


void __RPC_STUB ICorDebugAppDomain_Attach_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain_GetID_Proxy( 
    ICorDebugAppDomain * This,
    /* [out] */ ULONG32 *pId);


void __RPC_STUB ICorDebugAppDomain_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAppDomain_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAppDomain2_INTERFACE_DEFINED__
#define __ICorDebugAppDomain2_INTERFACE_DEFINED__

/* interface ICorDebugAppDomain2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAppDomain2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("096E81D5-ECDA-4202-83F5-C65980A9EF75")
    ICorDebugAppDomain2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetArrayOrPointerType( 
            /* [in] */ CorElementType elementType,
            /* [in] */ ULONG32 nRank,
            /* [in] */ ICorDebugType *pTypeArg,
            /* [out] */ ICorDebugType **ppType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionPointerType( 
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [out] */ ICorDebugType **ppType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAppDomain2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAppDomain2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAppDomain2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAppDomain2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetArrayOrPointerType )( 
            ICorDebugAppDomain2 * This,
            /* [in] */ CorElementType elementType,
            /* [in] */ ULONG32 nRank,
            /* [in] */ ICorDebugType *pTypeArg,
            /* [out] */ ICorDebugType **ppType);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionPointerType )( 
            ICorDebugAppDomain2 * This,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [out] */ ICorDebugType **ppType);
        
        END_INTERFACE
    } ICorDebugAppDomain2Vtbl;

    interface ICorDebugAppDomain2
    {
        CONST_VTBL struct ICorDebugAppDomain2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAppDomain2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAppDomain2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAppDomain2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAppDomain2_GetArrayOrPointerType(This,elementType,nRank,pTypeArg,ppType)	\
    (This)->lpVtbl -> GetArrayOrPointerType(This,elementType,nRank,pTypeArg,ppType)

#define ICorDebugAppDomain2_GetFunctionPointerType(This,nTypeArgs,ppTypeArgs,ppType)	\
    (This)->lpVtbl -> GetFunctionPointerType(This,nTypeArgs,ppTypeArgs,ppType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAppDomain2_GetArrayOrPointerType_Proxy( 
    ICorDebugAppDomain2 * This,
    /* [in] */ CorElementType elementType,
    /* [in] */ ULONG32 nRank,
    /* [in] */ ICorDebugType *pTypeArg,
    /* [out] */ ICorDebugType **ppType);


void __RPC_STUB ICorDebugAppDomain2_GetArrayOrPointerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAppDomain2_GetFunctionPointerType_Proxy( 
    ICorDebugAppDomain2 * This,
    /* [in] */ ULONG32 nTypeArgs,
    /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
    /* [out] */ ICorDebugType **ppType);


void __RPC_STUB ICorDebugAppDomain2_GetFunctionPointerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAppDomain2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAssembly_INTERFACE_DEFINED__
#define __ICorDebugAssembly_INTERFACE_DEFINED__

/* interface ICorDebugAssembly */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAssembly;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("df59507c-d47a-459e-bce2-6427eac8fd06")
    ICorDebugAssembly : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppDomain( 
            /* [out] */ ICorDebugAppDomain **ppAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateModules( 
            /* [out] */ ICorDebugModuleEnum **ppModules) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeBase( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAssemblyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAssembly * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAssembly * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAssembly * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebugAssembly * This,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppDomain )( 
            ICorDebugAssembly * This,
            /* [out] */ ICorDebugAppDomain **ppAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateModules )( 
            ICorDebugAssembly * This,
            /* [out] */ ICorDebugModuleEnum **ppModules);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeBase )( 
            ICorDebugAssembly * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorDebugAssembly * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        END_INTERFACE
    } ICorDebugAssemblyVtbl;

    interface ICorDebugAssembly
    {
        CONST_VTBL struct ICorDebugAssemblyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAssembly_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAssembly_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAssembly_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAssembly_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define ICorDebugAssembly_GetAppDomain(This,ppAppDomain)	\
    (This)->lpVtbl -> GetAppDomain(This,ppAppDomain)

#define ICorDebugAssembly_EnumerateModules(This,ppModules)	\
    (This)->lpVtbl -> EnumerateModules(This,ppModules)

#define ICorDebugAssembly_GetCodeBase(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetCodeBase(This,cchName,pcchName,szName)

#define ICorDebugAssembly_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAssembly_GetProcess_Proxy( 
    ICorDebugAssembly * This,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebugAssembly_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAssembly_GetAppDomain_Proxy( 
    ICorDebugAssembly * This,
    /* [out] */ ICorDebugAppDomain **ppAppDomain);


void __RPC_STUB ICorDebugAssembly_GetAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAssembly_EnumerateModules_Proxy( 
    ICorDebugAssembly * This,
    /* [out] */ ICorDebugModuleEnum **ppModules);


void __RPC_STUB ICorDebugAssembly_EnumerateModules_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAssembly_GetCodeBase_Proxy( 
    ICorDebugAssembly * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugAssembly_GetCodeBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugAssembly_GetName_Proxy( 
    ICorDebugAssembly * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugAssembly_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAssembly_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAssembly2_INTERFACE_DEFINED__
#define __ICorDebugAssembly2_INTERFACE_DEFINED__

/* interface ICorDebugAssembly2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAssembly2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("426d1f9e-6dd4-44c8-aec7-26cdbaf4e398")
    ICorDebugAssembly2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsFullyTrusted( 
            /* [out] */ BOOL *pbFullyTrusted) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAssembly2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAssembly2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAssembly2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAssembly2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsFullyTrusted )( 
            ICorDebugAssembly2 * This,
            /* [out] */ BOOL *pbFullyTrusted);
        
        END_INTERFACE
    } ICorDebugAssembly2Vtbl;

    interface ICorDebugAssembly2
    {
        CONST_VTBL struct ICorDebugAssembly2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAssembly2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAssembly2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAssembly2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAssembly2_IsFullyTrusted(This,pbFullyTrusted)	\
    (This)->lpVtbl -> IsFullyTrusted(This,pbFullyTrusted)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAssembly2_IsFullyTrusted_Proxy( 
    ICorDebugAssembly2 * This,
    /* [out] */ BOOL *pbFullyTrusted);


void __RPC_STUB ICorDebugAssembly2_IsFullyTrusted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAssembly2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugProcess_INTERFACE_DEFINED__
#define __ICorDebugProcess_INTERFACE_DEFINED__

/* interface ICorDebugProcess */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3d6f5f64-7538-11d3-8d5b-00104b35e7ef")
    ICorDebugProcess : public ICorDebugController
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ DWORD *pdwProcessId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandle( 
            /* [out] */ HPROCESS *phProcessHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThread( 
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ICorDebugThread **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateObjects( 
            /* [out] */ ICorDebugObjectEnum **ppObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsTransitionStub( 
            /* [in] */ CORDB_ADDRESS address,
            /* [out] */ BOOL *pbTransitionStub) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsOSSuspended( 
            /* [in] */ DWORD threadID,
            /* [out] */ BOOL *pbSuspended) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ DWORD threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][out][in] */ BYTE context[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadContext( 
            /* [in] */ DWORD threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][in] */ BYTE context[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadMemory( 
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ DWORD size,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ SIZE_T *read) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteMemory( 
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ DWORD size,
            /* [size_is][in] */ BYTE buffer[  ],
            /* [out] */ SIZE_T *written) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearCurrentException( 
            /* [in] */ DWORD threadID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableLogMessages( 
            /* [in] */ BOOL fOnOff) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModifyLogSwitch( 
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ LONG lLevel) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateAppDomains( 
            /* [out] */ ICorDebugAppDomainEnum **ppAppDomains) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ ICorDebugValue **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadForFiberCookie( 
            /* [in] */ DWORD fiberCookie,
            /* [out] */ ICorDebugThread **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHelperThreadID( 
            /* [out] */ DWORD *pThreadID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugProcess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugProcess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugProcess * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD dwTimeoutIgnored);
        
        HRESULT ( STDMETHODCALLTYPE *Continue )( 
            ICorDebugProcess * This,
            /* [in] */ BOOL fIsOutOfBand);
        
        HRESULT ( STDMETHODCALLTYPE *IsRunning )( 
            ICorDebugProcess * This,
            /* [out] */ BOOL *pbRunning);
        
        HRESULT ( STDMETHODCALLTYPE *HasQueuedCallbacks )( 
            ICorDebugProcess * This,
            /* [in] */ ICorDebugThread *pThread,
            /* [out] */ BOOL *pbQueued);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateThreads )( 
            ICorDebugProcess * This,
            /* [out] */ ICorDebugThreadEnum **ppThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetAllThreadsDebugState )( 
            ICorDebugProcess * This,
            /* [in] */ CorDebugThreadState state,
            /* [in] */ ICorDebugThread *pExceptThisThread);
        
        HRESULT ( STDMETHODCALLTYPE *Detach )( 
            ICorDebugProcess * This);
        
        HRESULT ( STDMETHODCALLTYPE *Terminate )( 
            ICorDebugProcess * This,
            /* [in] */ UINT exitCode);
        
        HRESULT ( STDMETHODCALLTYPE *CanCommitChanges )( 
            ICorDebugProcess * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *CommitChanges )( 
            ICorDebugProcess * This,
            /* [in] */ ULONG cSnapshots,
            /* [size_is][in] */ ICorDebugEditAndContinueSnapshot *pSnapshots[  ],
            /* [out] */ ICorDebugErrorInfoEnum **pError);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ICorDebugProcess * This,
            /* [out] */ DWORD *pdwProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandle )( 
            ICorDebugProcess * This,
            /* [out] */ HPROCESS *phProcessHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetThread )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD dwThreadId,
            /* [out] */ ICorDebugThread **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateObjects )( 
            ICorDebugProcess * This,
            /* [out] */ ICorDebugObjectEnum **ppObjects);
        
        HRESULT ( STDMETHODCALLTYPE *IsTransitionStub )( 
            ICorDebugProcess * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [out] */ BOOL *pbTransitionStub);
        
        HRESULT ( STDMETHODCALLTYPE *IsOSSuspended )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD threadID,
            /* [out] */ BOOL *pbSuspended);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][out][in] */ BYTE context[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][in] */ BYTE context[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ReadMemory )( 
            ICorDebugProcess * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ DWORD size,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ SIZE_T *read);
        
        HRESULT ( STDMETHODCALLTYPE *WriteMemory )( 
            ICorDebugProcess * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ DWORD size,
            /* [size_is][in] */ BYTE buffer[  ],
            /* [out] */ SIZE_T *written);
        
        HRESULT ( STDMETHODCALLTYPE *ClearCurrentException )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD threadID);
        
        HRESULT ( STDMETHODCALLTYPE *EnableLogMessages )( 
            ICorDebugProcess * This,
            /* [in] */ BOOL fOnOff);
        
        HRESULT ( STDMETHODCALLTYPE *ModifyLogSwitch )( 
            ICorDebugProcess * This,
            /* [in] */ WCHAR *pLogSwitchName,
            /* [in] */ LONG lLevel);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateAppDomains )( 
            ICorDebugProcess * This,
            /* [out] */ ICorDebugAppDomainEnum **ppAppDomains);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ICorDebugProcess * This,
            /* [out] */ ICorDebugValue **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadForFiberCookie )( 
            ICorDebugProcess * This,
            /* [in] */ DWORD fiberCookie,
            /* [out] */ ICorDebugThread **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetHelperThreadID )( 
            ICorDebugProcess * This,
            /* [out] */ DWORD *pThreadID);
        
        END_INTERFACE
    } ICorDebugProcessVtbl;

    interface ICorDebugProcess
    {
        CONST_VTBL struct ICorDebugProcessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugProcess_Stop(This,dwTimeoutIgnored)	\
    (This)->lpVtbl -> Stop(This,dwTimeoutIgnored)

#define ICorDebugProcess_Continue(This,fIsOutOfBand)	\
    (This)->lpVtbl -> Continue(This,fIsOutOfBand)

#define ICorDebugProcess_IsRunning(This,pbRunning)	\
    (This)->lpVtbl -> IsRunning(This,pbRunning)

#define ICorDebugProcess_HasQueuedCallbacks(This,pThread,pbQueued)	\
    (This)->lpVtbl -> HasQueuedCallbacks(This,pThread,pbQueued)

#define ICorDebugProcess_EnumerateThreads(This,ppThreads)	\
    (This)->lpVtbl -> EnumerateThreads(This,ppThreads)

#define ICorDebugProcess_SetAllThreadsDebugState(This,state,pExceptThisThread)	\
    (This)->lpVtbl -> SetAllThreadsDebugState(This,state,pExceptThisThread)

#define ICorDebugProcess_Detach(This)	\
    (This)->lpVtbl -> Detach(This)

#define ICorDebugProcess_Terminate(This,exitCode)	\
    (This)->lpVtbl -> Terminate(This,exitCode)

#define ICorDebugProcess_CanCommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CanCommitChanges(This,cSnapshots,pSnapshots,pError)

#define ICorDebugProcess_CommitChanges(This,cSnapshots,pSnapshots,pError)	\
    (This)->lpVtbl -> CommitChanges(This,cSnapshots,pSnapshots,pError)


#define ICorDebugProcess_GetID(This,pdwProcessId)	\
    (This)->lpVtbl -> GetID(This,pdwProcessId)

#define ICorDebugProcess_GetHandle(This,phProcessHandle)	\
    (This)->lpVtbl -> GetHandle(This,phProcessHandle)

#define ICorDebugProcess_GetThread(This,dwThreadId,ppThread)	\
    (This)->lpVtbl -> GetThread(This,dwThreadId,ppThread)

#define ICorDebugProcess_EnumerateObjects(This,ppObjects)	\
    (This)->lpVtbl -> EnumerateObjects(This,ppObjects)

#define ICorDebugProcess_IsTransitionStub(This,address,pbTransitionStub)	\
    (This)->lpVtbl -> IsTransitionStub(This,address,pbTransitionStub)

#define ICorDebugProcess_IsOSSuspended(This,threadID,pbSuspended)	\
    (This)->lpVtbl -> IsOSSuspended(This,threadID,pbSuspended)

#define ICorDebugProcess_GetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,threadID,contextSize,context)

#define ICorDebugProcess_SetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,threadID,contextSize,context)

#define ICorDebugProcess_ReadMemory(This,address,size,buffer,read)	\
    (This)->lpVtbl -> ReadMemory(This,address,size,buffer,read)

#define ICorDebugProcess_WriteMemory(This,address,size,buffer,written)	\
    (This)->lpVtbl -> WriteMemory(This,address,size,buffer,written)

#define ICorDebugProcess_ClearCurrentException(This,threadID)	\
    (This)->lpVtbl -> ClearCurrentException(This,threadID)

#define ICorDebugProcess_EnableLogMessages(This,fOnOff)	\
    (This)->lpVtbl -> EnableLogMessages(This,fOnOff)

#define ICorDebugProcess_ModifyLogSwitch(This,pLogSwitchName,lLevel)	\
    (This)->lpVtbl -> ModifyLogSwitch(This,pLogSwitchName,lLevel)

#define ICorDebugProcess_EnumerateAppDomains(This,ppAppDomains)	\
    (This)->lpVtbl -> EnumerateAppDomains(This,ppAppDomains)

#define ICorDebugProcess_GetObject(This,ppObject)	\
    (This)->lpVtbl -> GetObject(This,ppObject)

#define ICorDebugProcess_ThreadForFiberCookie(This,fiberCookie,ppThread)	\
    (This)->lpVtbl -> ThreadForFiberCookie(This,fiberCookie,ppThread)

#define ICorDebugProcess_GetHelperThreadID(This,pThreadID)	\
    (This)->lpVtbl -> GetHelperThreadID(This,pThreadID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetID_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ DWORD *pdwProcessId);


void __RPC_STUB ICorDebugProcess_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetHandle_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ HPROCESS *phProcessHandle);


void __RPC_STUB ICorDebugProcess_GetHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetThread_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD dwThreadId,
    /* [out] */ ICorDebugThread **ppThread);


void __RPC_STUB ICorDebugProcess_GetThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_EnumerateObjects_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ ICorDebugObjectEnum **ppObjects);


void __RPC_STUB ICorDebugProcess_EnumerateObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_IsTransitionStub_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [out] */ BOOL *pbTransitionStub);


void __RPC_STUB ICorDebugProcess_IsTransitionStub_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_IsOSSuspended_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD threadID,
    /* [out] */ BOOL *pbSuspended);


void __RPC_STUB ICorDebugProcess_IsOSSuspended_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetThreadContext_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD threadID,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][length_is][out][in] */ BYTE context[  ]);


void __RPC_STUB ICorDebugProcess_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_SetThreadContext_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD threadID,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][length_is][in] */ BYTE context[  ]);


void __RPC_STUB ICorDebugProcess_SetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_ReadMemory_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [in] */ DWORD size,
    /* [length_is][size_is][out] */ BYTE buffer[  ],
    /* [out] */ SIZE_T *read);


void __RPC_STUB ICorDebugProcess_ReadMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_WriteMemory_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [in] */ DWORD size,
    /* [size_is][in] */ BYTE buffer[  ],
    /* [out] */ SIZE_T *written);


void __RPC_STUB ICorDebugProcess_WriteMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_ClearCurrentException_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD threadID);


void __RPC_STUB ICorDebugProcess_ClearCurrentException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_EnableLogMessages_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ BOOL fOnOff);


void __RPC_STUB ICorDebugProcess_EnableLogMessages_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_ModifyLogSwitch_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ WCHAR *pLogSwitchName,
    /* [in] */ LONG lLevel);


void __RPC_STUB ICorDebugProcess_ModifyLogSwitch_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_EnumerateAppDomains_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ ICorDebugAppDomainEnum **ppAppDomains);


void __RPC_STUB ICorDebugProcess_EnumerateAppDomains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetObject_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ ICorDebugValue **ppObject);


void __RPC_STUB ICorDebugProcess_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_ThreadForFiberCookie_Proxy( 
    ICorDebugProcess * This,
    /* [in] */ DWORD fiberCookie,
    /* [out] */ ICorDebugThread **ppThread);


void __RPC_STUB ICorDebugProcess_ThreadForFiberCookie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess_GetHelperThreadID_Proxy( 
    ICorDebugProcess * This,
    /* [out] */ DWORD *pThreadID);


void __RPC_STUB ICorDebugProcess_GetHelperThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugProcess_INTERFACE_DEFINED__ */


#ifndef __ICorDebugProcess2_INTERFACE_DEFINED__
#define __ICorDebugProcess2_INTERFACE_DEFINED__

/* interface ICorDebugProcess2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugProcess2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AD1B3588-0EF0-4744-A496-AA09A9F80371")
    ICorDebugProcess2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetThreadForTaskID( 
            /* [in] */ TASKID taskid,
            /* [out] */ ICorDebugThread2 **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ COR_VERSION *version) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnmanagedBreakpoint( 
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ ULONG32 bufsize,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ ULONG32 *bufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearUnmanagedBreakpoint( 
            /* [in] */ CORDB_ADDRESS address) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDesiredNGENCompilerFlags( 
            /* [in] */ DWORD pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDesiredNGENCompilerFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReferenceValueFromGCHandle( 
            /* [in] */ UINT_PTR handle,
            /* [out] */ ICorDebugReferenceValue **pOutValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugProcess2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugProcess2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugProcess2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugProcess2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadForTaskID )( 
            ICorDebugProcess2 * This,
            /* [in] */ TASKID taskid,
            /* [out] */ ICorDebugThread2 **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            ICorDebugProcess2 * This,
            /* [out] */ COR_VERSION *version);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnmanagedBreakpoint )( 
            ICorDebugProcess2 * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ ULONG32 bufsize,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ ULONG32 *bufLen);
        
        HRESULT ( STDMETHODCALLTYPE *ClearUnmanagedBreakpoint )( 
            ICorDebugProcess2 * This,
            /* [in] */ CORDB_ADDRESS address);
        
        HRESULT ( STDMETHODCALLTYPE *SetDesiredNGENCompilerFlags )( 
            ICorDebugProcess2 * This,
            /* [in] */ DWORD pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetDesiredNGENCompilerFlags )( 
            ICorDebugProcess2 * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetReferenceValueFromGCHandle )( 
            ICorDebugProcess2 * This,
            /* [in] */ UINT_PTR handle,
            /* [out] */ ICorDebugReferenceValue **pOutValue);
        
        END_INTERFACE
    } ICorDebugProcess2Vtbl;

    interface ICorDebugProcess2
    {
        CONST_VTBL struct ICorDebugProcess2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugProcess2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugProcess2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugProcess2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugProcess2_GetThreadForTaskID(This,taskid,ppThread)	\
    (This)->lpVtbl -> GetThreadForTaskID(This,taskid,ppThread)

#define ICorDebugProcess2_GetVersion(This,version)	\
    (This)->lpVtbl -> GetVersion(This,version)

#define ICorDebugProcess2_SetUnmanagedBreakpoint(This,address,bufsize,buffer,bufLen)	\
    (This)->lpVtbl -> SetUnmanagedBreakpoint(This,address,bufsize,buffer,bufLen)

#define ICorDebugProcess2_ClearUnmanagedBreakpoint(This,address)	\
    (This)->lpVtbl -> ClearUnmanagedBreakpoint(This,address)

#define ICorDebugProcess2_SetDesiredNGENCompilerFlags(This,pdwFlags)	\
    (This)->lpVtbl -> SetDesiredNGENCompilerFlags(This,pdwFlags)

#define ICorDebugProcess2_GetDesiredNGENCompilerFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetDesiredNGENCompilerFlags(This,pdwFlags)

#define ICorDebugProcess2_GetReferenceValueFromGCHandle(This,handle,pOutValue)	\
    (This)->lpVtbl -> GetReferenceValueFromGCHandle(This,handle,pOutValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugProcess2_GetThreadForTaskID_Proxy( 
    ICorDebugProcess2 * This,
    /* [in] */ TASKID taskid,
    /* [out] */ ICorDebugThread2 **ppThread);


void __RPC_STUB ICorDebugProcess2_GetThreadForTaskID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess2_GetVersion_Proxy( 
    ICorDebugProcess2 * This,
    /* [out] */ COR_VERSION *version);


void __RPC_STUB ICorDebugProcess2_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess2_SetUnmanagedBreakpoint_Proxy( 
    ICorDebugProcess2 * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [in] */ ULONG32 bufsize,
    /* [length_is][size_is][out] */ BYTE buffer[  ],
    /* [out] */ ULONG32 *bufLen);


void __RPC_STUB ICorDebugProcess2_SetUnmanagedBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess2_ClearUnmanagedBreakpoint_Proxy( 
    ICorDebugProcess2 * This,
    /* [in] */ CORDB_ADDRESS address);


void __RPC_STUB ICorDebugProcess2_ClearUnmanagedBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess2_SetDesiredNGENCompilerFlags_Proxy( 
    ICorDebugProcess2 * This,
    /* [in] */ DWORD pdwFlags);


void __RPC_STUB ICorDebugProcess2_SetDesiredNGENCompilerFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess2_GetDesiredNGENCompilerFlags_Proxy( 
    ICorDebugProcess2 * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB ICorDebugProcess2_GetDesiredNGENCompilerFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugProcess2_GetReferenceValueFromGCHandle_Proxy( 
    ICorDebugProcess2 * This,
    /* [in] */ UINT_PTR handle,
    /* [out] */ ICorDebugReferenceValue **pOutValue);


void __RPC_STUB ICorDebugProcess2_GetReferenceValueFromGCHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugProcess2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugBreakpoint_INTERFACE_DEFINED__
#define __ICorDebugBreakpoint_INTERFACE_DEFINED__

/* interface ICorDebugBreakpoint */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAE8-8A68-11d2-983C-0000F808342D")
    ICorDebugBreakpoint : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL bActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsActive( 
            /* [out] */ BOOL *pbActive) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ICorDebugBreakpoint * This,
            /* [in] */ BOOL bActive);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugBreakpoint * This,
            /* [out] */ BOOL *pbActive);
        
        END_INTERFACE
    } ICorDebugBreakpointVtbl;

    interface ICorDebugBreakpoint
    {
        CONST_VTBL struct ICorDebugBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugBreakpoint_Activate(This,bActive)	\
    (This)->lpVtbl -> Activate(This,bActive)

#define ICorDebugBreakpoint_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugBreakpoint_Activate_Proxy( 
    ICorDebugBreakpoint * This,
    /* [in] */ BOOL bActive);


void __RPC_STUB ICorDebugBreakpoint_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugBreakpoint_IsActive_Proxy( 
    ICorDebugBreakpoint * This,
    /* [out] */ BOOL *pbActive);


void __RPC_STUB ICorDebugBreakpoint_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugBreakpoint_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFunctionBreakpoint_INTERFACE_DEFINED__
#define __ICorDebugFunctionBreakpoint_INTERFACE_DEFINED__

/* interface ICorDebugFunctionBreakpoint */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFunctionBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAE9-8A68-11d2-983C-0000F808342D")
    ICorDebugFunctionBreakpoint : public ICorDebugBreakpoint
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFunction( 
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOffset( 
            /* [out] */ ULONG32 *pnOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFunctionBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFunctionBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFunctionBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFunctionBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ICorDebugFunctionBreakpoint * This,
            /* [in] */ BOOL bActive);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugFunctionBreakpoint * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugFunctionBreakpoint * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetOffset )( 
            ICorDebugFunctionBreakpoint * This,
            /* [out] */ ULONG32 *pnOffset);
        
        END_INTERFACE
    } ICorDebugFunctionBreakpointVtbl;

    interface ICorDebugFunctionBreakpoint
    {
        CONST_VTBL struct ICorDebugFunctionBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFunctionBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFunctionBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFunctionBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFunctionBreakpoint_Activate(This,bActive)	\
    (This)->lpVtbl -> Activate(This,bActive)

#define ICorDebugFunctionBreakpoint_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)


#define ICorDebugFunctionBreakpoint_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugFunctionBreakpoint_GetOffset(This,pnOffset)	\
    (This)->lpVtbl -> GetOffset(This,pnOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFunctionBreakpoint_GetFunction_Proxy( 
    ICorDebugFunctionBreakpoint * This,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugFunctionBreakpoint_GetFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunctionBreakpoint_GetOffset_Proxy( 
    ICorDebugFunctionBreakpoint * This,
    /* [out] */ ULONG32 *pnOffset);


void __RPC_STUB ICorDebugFunctionBreakpoint_GetOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFunctionBreakpoint_INTERFACE_DEFINED__ */


#ifndef __ICorDebugModuleBreakpoint_INTERFACE_DEFINED__
#define __ICorDebugModuleBreakpoint_INTERFACE_DEFINED__

/* interface ICorDebugModuleBreakpoint */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugModuleBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEA-8A68-11d2-983C-0000F808342D")
    ICorDebugModuleBreakpoint : public ICorDebugBreakpoint
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ ICorDebugModule **ppModule) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugModuleBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugModuleBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugModuleBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugModuleBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ICorDebugModuleBreakpoint * This,
            /* [in] */ BOOL bActive);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugModuleBreakpoint * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            ICorDebugModuleBreakpoint * This,
            /* [out] */ ICorDebugModule **ppModule);
        
        END_INTERFACE
    } ICorDebugModuleBreakpointVtbl;

    interface ICorDebugModuleBreakpoint
    {
        CONST_VTBL struct ICorDebugModuleBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugModuleBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugModuleBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugModuleBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugModuleBreakpoint_Activate(This,bActive)	\
    (This)->lpVtbl -> Activate(This,bActive)

#define ICorDebugModuleBreakpoint_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)


#define ICorDebugModuleBreakpoint_GetModule(This,ppModule)	\
    (This)->lpVtbl -> GetModule(This,ppModule)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugModuleBreakpoint_GetModule_Proxy( 
    ICorDebugModuleBreakpoint * This,
    /* [out] */ ICorDebugModule **ppModule);


void __RPC_STUB ICorDebugModuleBreakpoint_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugModuleBreakpoint_INTERFACE_DEFINED__ */


#ifndef __ICorDebugValueBreakpoint_INTERFACE_DEFINED__
#define __ICorDebugValueBreakpoint_INTERFACE_DEFINED__

/* interface ICorDebugValueBreakpoint */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugValueBreakpoint;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEB-8A68-11d2-983C-0000F808342D")
    ICorDebugValueBreakpoint : public ICorDebugBreakpoint
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugValueBreakpointVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugValueBreakpoint * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugValueBreakpoint * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugValueBreakpoint * This);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            ICorDebugValueBreakpoint * This,
            /* [in] */ BOOL bActive);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugValueBreakpoint * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICorDebugValueBreakpoint * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugValueBreakpointVtbl;

    interface ICorDebugValueBreakpoint
    {
        CONST_VTBL struct ICorDebugValueBreakpointVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugValueBreakpoint_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugValueBreakpoint_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugValueBreakpoint_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugValueBreakpoint_Activate(This,bActive)	\
    (This)->lpVtbl -> Activate(This,bActive)

#define ICorDebugValueBreakpoint_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)


#define ICorDebugValueBreakpoint_GetValue(This,ppValue)	\
    (This)->lpVtbl -> GetValue(This,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugValueBreakpoint_GetValue_Proxy( 
    ICorDebugValueBreakpoint * This,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugValueBreakpoint_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugValueBreakpoint_INTERFACE_DEFINED__ */


#ifndef __ICorDebugStepper_INTERFACE_DEFINED__
#define __ICorDebugStepper_INTERFACE_DEFINED__

/* interface ICorDebugStepper */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugIntercept
    {	INTERCEPT_NONE	= 0,
	INTERCEPT_CLASS_INIT	= 0x1,
	INTERCEPT_EXCEPTION_FILTER	= 0x2,
	INTERCEPT_SECURITY	= 0x4,
	INTERCEPT_CONTEXT_POLICY	= 0x8,
	INTERCEPT_INTERCEPTION	= 0x10,
	INTERCEPT_ALL	= 0xffff
    } 	CorDebugIntercept;

typedef 
enum CorDebugUnmappedStop
    {	STOP_NONE	= 0,
	STOP_PROLOG	= 0x1,
	STOP_EPILOG	= 0x2,
	STOP_NO_MAPPING_INFO	= 0x4,
	STOP_OTHER_UNMAPPED	= 0x8,
	STOP_UNMANAGED	= 0x10,
	STOP_ALL	= 0xffff
    } 	CorDebugUnmappedStop;

typedef struct COR_DEBUG_STEP_RANGE
    {
    ULONG32 startOffset;
    ULONG32 endOffset;
    } 	COR_DEBUG_STEP_RANGE;


EXTERN_C const IID IID_ICorDebugStepper;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEC-8A68-11d2-983C-0000F808342D")
    ICorDebugStepper : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsActive( 
            /* [out] */ BOOL *pbActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInterceptMask( 
            /* [in] */ CorDebugIntercept mask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnmappedStopMask( 
            /* [in] */ CorDebugUnmappedStop mask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Step( 
            /* [in] */ BOOL bStepIn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepRange( 
            /* [in] */ BOOL bStepIn,
            /* [size_is][in] */ COR_DEBUG_STEP_RANGE ranges[  ],
            /* [in] */ ULONG32 cRangeCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StepOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRangeIL( 
            /* [in] */ BOOL bIL) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugStepperVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugStepper * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugStepper * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugStepper * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugStepper * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            ICorDebugStepper * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetInterceptMask )( 
            ICorDebugStepper * This,
            /* [in] */ CorDebugIntercept mask);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnmappedStopMask )( 
            ICorDebugStepper * This,
            /* [in] */ CorDebugUnmappedStop mask);
        
        HRESULT ( STDMETHODCALLTYPE *Step )( 
            ICorDebugStepper * This,
            /* [in] */ BOOL bStepIn);
        
        HRESULT ( STDMETHODCALLTYPE *StepRange )( 
            ICorDebugStepper * This,
            /* [in] */ BOOL bStepIn,
            /* [size_is][in] */ COR_DEBUG_STEP_RANGE ranges[  ],
            /* [in] */ ULONG32 cRangeCount);
        
        HRESULT ( STDMETHODCALLTYPE *StepOut )( 
            ICorDebugStepper * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetRangeIL )( 
            ICorDebugStepper * This,
            /* [in] */ BOOL bIL);
        
        END_INTERFACE
    } ICorDebugStepperVtbl;

    interface ICorDebugStepper
    {
        CONST_VTBL struct ICorDebugStepperVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugStepper_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugStepper_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugStepper_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugStepper_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)

#define ICorDebugStepper_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define ICorDebugStepper_SetInterceptMask(This,mask)	\
    (This)->lpVtbl -> SetInterceptMask(This,mask)

#define ICorDebugStepper_SetUnmappedStopMask(This,mask)	\
    (This)->lpVtbl -> SetUnmappedStopMask(This,mask)

#define ICorDebugStepper_Step(This,bStepIn)	\
    (This)->lpVtbl -> Step(This,bStepIn)

#define ICorDebugStepper_StepRange(This,bStepIn,ranges,cRangeCount)	\
    (This)->lpVtbl -> StepRange(This,bStepIn,ranges,cRangeCount)

#define ICorDebugStepper_StepOut(This)	\
    (This)->lpVtbl -> StepOut(This)

#define ICorDebugStepper_SetRangeIL(This,bIL)	\
    (This)->lpVtbl -> SetRangeIL(This,bIL)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugStepper_IsActive_Proxy( 
    ICorDebugStepper * This,
    /* [out] */ BOOL *pbActive);


void __RPC_STUB ICorDebugStepper_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_Deactivate_Proxy( 
    ICorDebugStepper * This);


void __RPC_STUB ICorDebugStepper_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_SetInterceptMask_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ CorDebugIntercept mask);


void __RPC_STUB ICorDebugStepper_SetInterceptMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_SetUnmappedStopMask_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ CorDebugUnmappedStop mask);


void __RPC_STUB ICorDebugStepper_SetUnmappedStopMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_Step_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ BOOL bStepIn);


void __RPC_STUB ICorDebugStepper_Step_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_StepRange_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ BOOL bStepIn,
    /* [size_is][in] */ COR_DEBUG_STEP_RANGE ranges[  ],
    /* [in] */ ULONG32 cRangeCount);


void __RPC_STUB ICorDebugStepper_StepRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_StepOut_Proxy( 
    ICorDebugStepper * This);


void __RPC_STUB ICorDebugStepper_StepOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStepper_SetRangeIL_Proxy( 
    ICorDebugStepper * This,
    /* [in] */ BOOL bIL);


void __RPC_STUB ICorDebugStepper_SetRangeIL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugStepper_INTERFACE_DEFINED__ */


#ifndef __ICorDebugStepper2_INTERFACE_DEFINED__
#define __ICorDebugStepper2_INTERFACE_DEFINED__

/* interface ICorDebugStepper2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugStepper2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C5B6E9C3-E7D1-4a8e-873B-7F047F0706F7")
    ICorDebugStepper2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetJMC( 
            /* [in] */ BOOL fIsJMCStepper) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugStepper2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugStepper2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugStepper2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugStepper2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetJMC )( 
            ICorDebugStepper2 * This,
            /* [in] */ BOOL fIsJMCStepper);
        
        END_INTERFACE
    } ICorDebugStepper2Vtbl;

    interface ICorDebugStepper2
    {
        CONST_VTBL struct ICorDebugStepper2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugStepper2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugStepper2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugStepper2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugStepper2_SetJMC(This,fIsJMCStepper)	\
    (This)->lpVtbl -> SetJMC(This,fIsJMCStepper)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugStepper2_SetJMC_Proxy( 
    ICorDebugStepper2 * This,
    /* [in] */ BOOL fIsJMCStepper);


void __RPC_STUB ICorDebugStepper2_SetJMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugStepper2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugRegisterSet_INTERFACE_DEFINED__
#define __ICorDebugRegisterSet_INTERFACE_DEFINED__

/* interface ICorDebugRegisterSet */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugRegister
    {	REGISTER_INSTRUCTION_POINTER	= 0,
	REGISTER_STACK_POINTER	= REGISTER_INSTRUCTION_POINTER + 1,
	REGISTER_FRAME_POINTER	= REGISTER_STACK_POINTER + 1,
	REGISTER_X86_EIP	= 0,
	REGISTER_X86_ESP	= REGISTER_X86_EIP + 1,
	REGISTER_X86_EBP	= REGISTER_X86_ESP + 1,
	REGISTER_X86_EAX	= REGISTER_X86_EBP + 1,
	REGISTER_X86_ECX	= REGISTER_X86_EAX + 1,
	REGISTER_X86_EDX	= REGISTER_X86_ECX + 1,
	REGISTER_X86_EBX	= REGISTER_X86_EDX + 1,
	REGISTER_X86_ESI	= REGISTER_X86_EBX + 1,
	REGISTER_X86_EDI	= REGISTER_X86_ESI + 1,
	REGISTER_X86_FPSTACK_0	= REGISTER_X86_EDI + 1,
	REGISTER_X86_FPSTACK_1	= REGISTER_X86_FPSTACK_0 + 1,
	REGISTER_X86_FPSTACK_2	= REGISTER_X86_FPSTACK_1 + 1,
	REGISTER_X86_FPSTACK_3	= REGISTER_X86_FPSTACK_2 + 1,
	REGISTER_X86_FPSTACK_4	= REGISTER_X86_FPSTACK_3 + 1,
	REGISTER_X86_FPSTACK_5	= REGISTER_X86_FPSTACK_4 + 1,
	REGISTER_X86_FPSTACK_6	= REGISTER_X86_FPSTACK_5 + 1,
	REGISTER_X86_FPSTACK_7	= REGISTER_X86_FPSTACK_6 + 1,
	REGISTER_AMD64_RIP	= 0,
	REGISTER_AMD64_RSP	= REGISTER_AMD64_RIP + 1,
	REGISTER_AMD64_RBP	= REGISTER_AMD64_RSP + 1,
	REGISTER_AMD64_RAX	= REGISTER_AMD64_RBP + 1,
	REGISTER_AMD64_RCX	= REGISTER_AMD64_RAX + 1,
	REGISTER_AMD64_RDX	= REGISTER_AMD64_RCX + 1,
	REGISTER_AMD64_RBX	= REGISTER_AMD64_RDX + 1,
	REGISTER_AMD64_RSI	= REGISTER_AMD64_RBX + 1,
	REGISTER_AMD64_RDI	= REGISTER_AMD64_RSI + 1,
	REGISTER_AMD64_R8	= REGISTER_AMD64_RDI + 1,
	REGISTER_AMD64_R9	= REGISTER_AMD64_R8 + 1,
	REGISTER_AMD64_R10	= REGISTER_AMD64_R9 + 1,
	REGISTER_AMD64_R11	= REGISTER_AMD64_R10 + 1,
	REGISTER_AMD64_R12	= REGISTER_AMD64_R11 + 1,
	REGISTER_AMD64_R13	= REGISTER_AMD64_R12 + 1,
	REGISTER_AMD64_R14	= REGISTER_AMD64_R13 + 1,
	REGISTER_AMD64_R15	= REGISTER_AMD64_R14 + 1,
	REGISTER_AMD64_XMM0	= REGISTER_AMD64_R15 + 1,
	REGISTER_AMD64_XMM1	= REGISTER_AMD64_XMM0 + 1,
	REGISTER_AMD64_XMM2	= REGISTER_AMD64_XMM1 + 1,
	REGISTER_AMD64_XMM3	= REGISTER_AMD64_XMM2 + 1,
	REGISTER_AMD64_XMM4	= REGISTER_AMD64_XMM3 + 1,
	REGISTER_AMD64_XMM5	= REGISTER_AMD64_XMM4 + 1,
	REGISTER_AMD64_XMM6	= REGISTER_AMD64_XMM5 + 1,
	REGISTER_AMD64_XMM7	= REGISTER_AMD64_XMM6 + 1,
	REGISTER_AMD64_XMM8	= REGISTER_AMD64_XMM7 + 1,
	REGISTER_AMD64_XMM9	= REGISTER_AMD64_XMM8 + 1,
	REGISTER_AMD64_XMM10	= REGISTER_AMD64_XMM9 + 1,
	REGISTER_AMD64_XMM11	= REGISTER_AMD64_XMM10 + 1,
	REGISTER_AMD64_XMM12	= REGISTER_AMD64_XMM11 + 1,
	REGISTER_AMD64_XMM13	= REGISTER_AMD64_XMM12 + 1,
	REGISTER_AMD64_XMM14	= REGISTER_AMD64_XMM13 + 1,
	REGISTER_AMD64_XMM15	= REGISTER_AMD64_XMM14 + 1,
	REGISTER_IA64_BSP	= REGISTER_FRAME_POINTER,
	REGISTER_IA64_R0	= REGISTER_IA64_BSP + 1,
	REGISTER_IA64_F0	= REGISTER_IA64_R0 + 128
    } 	CorDebugRegister;


EXTERN_C const IID IID_ICorDebugRegisterSet;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB0B-8A68-11d2-983C-0000F808342D")
    ICorDebugRegisterSet : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRegistersAvailable( 
            /* [out] */ ULONG64 *pAvailable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisters( 
            /* [in] */ ULONG64 mask,
            /* [in] */ ULONG32 regCount,
            /* [length_is][size_is][out] */ CORDB_REGISTER regBuffer[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRegisters( 
            /* [in] */ ULONG64 mask,
            /* [in] */ ULONG32 regCount,
            /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][out][in] */ BYTE context[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadContext( 
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][in] */ BYTE context[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugRegisterSetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugRegisterSet * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugRegisterSet * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugRegisterSet * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegistersAvailable )( 
            ICorDebugRegisterSet * This,
            /* [out] */ ULONG64 *pAvailable);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisters )( 
            ICorDebugRegisterSet * This,
            /* [in] */ ULONG64 mask,
            /* [in] */ ULONG32 regCount,
            /* [length_is][size_is][out] */ CORDB_REGISTER regBuffer[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetRegisters )( 
            ICorDebugRegisterSet * This,
            /* [in] */ ULONG64 mask,
            /* [in] */ ULONG32 regCount,
            /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICorDebugRegisterSet * This,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][out][in] */ BYTE context[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICorDebugRegisterSet * This,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][length_is][in] */ BYTE context[  ]);
        
        END_INTERFACE
    } ICorDebugRegisterSetVtbl;

    interface ICorDebugRegisterSet
    {
        CONST_VTBL struct ICorDebugRegisterSetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugRegisterSet_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugRegisterSet_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugRegisterSet_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugRegisterSet_GetRegistersAvailable(This,pAvailable)	\
    (This)->lpVtbl -> GetRegistersAvailable(This,pAvailable)

#define ICorDebugRegisterSet_GetRegisters(This,mask,regCount,regBuffer)	\
    (This)->lpVtbl -> GetRegisters(This,mask,regCount,regBuffer)

#define ICorDebugRegisterSet_SetRegisters(This,mask,regCount,regBuffer)	\
    (This)->lpVtbl -> SetRegisters(This,mask,regCount,regBuffer)

#define ICorDebugRegisterSet_GetThreadContext(This,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,contextSize,context)

#define ICorDebugRegisterSet_SetThreadContext(This,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,contextSize,context)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_GetRegistersAvailable_Proxy( 
    ICorDebugRegisterSet * This,
    /* [out] */ ULONG64 *pAvailable);


void __RPC_STUB ICorDebugRegisterSet_GetRegistersAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_GetRegisters_Proxy( 
    ICorDebugRegisterSet * This,
    /* [in] */ ULONG64 mask,
    /* [in] */ ULONG32 regCount,
    /* [length_is][size_is][out] */ CORDB_REGISTER regBuffer[  ]);


void __RPC_STUB ICorDebugRegisterSet_GetRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_SetRegisters_Proxy( 
    ICorDebugRegisterSet * This,
    /* [in] */ ULONG64 mask,
    /* [in] */ ULONG32 regCount,
    /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]);


void __RPC_STUB ICorDebugRegisterSet_SetRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_GetThreadContext_Proxy( 
    ICorDebugRegisterSet * This,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][length_is][out][in] */ BYTE context[  ]);


void __RPC_STUB ICorDebugRegisterSet_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet_SetThreadContext_Proxy( 
    ICorDebugRegisterSet * This,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][length_is][in] */ BYTE context[  ]);


void __RPC_STUB ICorDebugRegisterSet_SetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugRegisterSet_INTERFACE_DEFINED__ */


#ifndef __ICorDebugRegisterSet2_INTERFACE_DEFINED__
#define __ICorDebugRegisterSet2_INTERFACE_DEFINED__

/* interface ICorDebugRegisterSet2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugRegisterSet2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DC7BA3F-89BA-4459-9EC1-9D60937B468D")
    ICorDebugRegisterSet2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetRegistersAvailable( 
            /* [in] */ ULONG32 numChunks,
            /* [size_is][out] */ BYTE availableRegChunks[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisters( 
            /* [in] */ ULONG32 maskCount,
            /* [size_is][in] */ BYTE mask[  ],
            /* [in] */ ULONG32 regCount,
            /* [size_is][out] */ CORDB_REGISTER regBuffer[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRegisters( 
            /* [in] */ ULONG32 maskCount,
            /* [size_is][in] */ BYTE mask[  ],
            /* [in] */ ULONG32 regCount,
            /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugRegisterSet2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugRegisterSet2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugRegisterSet2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugRegisterSet2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegistersAvailable )( 
            ICorDebugRegisterSet2 * This,
            /* [in] */ ULONG32 numChunks,
            /* [size_is][out] */ BYTE availableRegChunks[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisters )( 
            ICorDebugRegisterSet2 * This,
            /* [in] */ ULONG32 maskCount,
            /* [size_is][in] */ BYTE mask[  ],
            /* [in] */ ULONG32 regCount,
            /* [size_is][out] */ CORDB_REGISTER regBuffer[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetRegisters )( 
            ICorDebugRegisterSet2 * This,
            /* [in] */ ULONG32 maskCount,
            /* [size_is][in] */ BYTE mask[  ],
            /* [in] */ ULONG32 regCount,
            /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]);
        
        END_INTERFACE
    } ICorDebugRegisterSet2Vtbl;

    interface ICorDebugRegisterSet2
    {
        CONST_VTBL struct ICorDebugRegisterSet2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugRegisterSet2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugRegisterSet2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugRegisterSet2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugRegisterSet2_GetRegistersAvailable(This,numChunks,availableRegChunks)	\
    (This)->lpVtbl -> GetRegistersAvailable(This,numChunks,availableRegChunks)

#define ICorDebugRegisterSet2_GetRegisters(This,maskCount,mask,regCount,regBuffer)	\
    (This)->lpVtbl -> GetRegisters(This,maskCount,mask,regCount,regBuffer)

#define ICorDebugRegisterSet2_SetRegisters(This,maskCount,mask,regCount,regBuffer)	\
    (This)->lpVtbl -> SetRegisters(This,maskCount,mask,regCount,regBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet2_GetRegistersAvailable_Proxy( 
    ICorDebugRegisterSet2 * This,
    /* [in] */ ULONG32 numChunks,
    /* [size_is][out] */ BYTE availableRegChunks[  ]);


void __RPC_STUB ICorDebugRegisterSet2_GetRegistersAvailable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet2_GetRegisters_Proxy( 
    ICorDebugRegisterSet2 * This,
    /* [in] */ ULONG32 maskCount,
    /* [size_is][in] */ BYTE mask[  ],
    /* [in] */ ULONG32 regCount,
    /* [size_is][out] */ CORDB_REGISTER regBuffer[  ]);


void __RPC_STUB ICorDebugRegisterSet2_GetRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugRegisterSet2_SetRegisters_Proxy( 
    ICorDebugRegisterSet2 * This,
    /* [in] */ ULONG32 maskCount,
    /* [size_is][in] */ BYTE mask[  ],
    /* [in] */ ULONG32 regCount,
    /* [size_is][in] */ CORDB_REGISTER regBuffer[  ]);


void __RPC_STUB ICorDebugRegisterSet2_SetRegisters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugRegisterSet2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugThread_INTERFACE_DEFINED__
#define __ICorDebugThread_INTERFACE_DEFINED__

/* interface ICorDebugThread */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugUserState
    {	USER_STOP_REQUESTED	= 0x1,
	USER_SUSPEND_REQUESTED	= 0x2,
	USER_BACKGROUND	= 0x4,
	USER_UNSTARTED	= 0x8,
	USER_STOPPED	= 0x10,
	USER_WAIT_SLEEP_JOIN	= 0x20,
	USER_SUSPENDED	= 0x40,
	USER_UNSAFE_POINT	= 0x80
    } 	CorDebugUserState;


EXTERN_C const IID IID_ICorDebugThread;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("938c6d66-7fb6-4f69-b389-425b8987329b")
    ICorDebugThread : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ DWORD *pdwThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandle( 
            /* [out] */ HTHREAD *phThreadHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppDomain( 
            /* [out] */ ICorDebugAppDomain **ppAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebugState( 
            /* [in] */ CorDebugThreadState state) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugState( 
            /* [out] */ CorDebugThreadState *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserState( 
            /* [out] */ CorDebugUserState *pState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentException( 
            /* [out] */ ICorDebugValue **ppExceptionObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearCurrentException( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStepper( 
            /* [out] */ ICorDebugStepper **ppStepper) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateChains( 
            /* [out] */ ICorDebugChainEnum **ppChains) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveChain( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveFrame( 
            /* [out] */ ICorDebugFrame **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterSet( 
            /* [out] */ ICorDebugRegisterSet **ppRegisters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEval( 
            /* [out] */ ICorDebugEval **ppEval) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ ICorDebugValue **ppObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugThreadVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugThread * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugThread * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugThread * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ICorDebugThread * This,
            /* [out] */ DWORD *pdwThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandle )( 
            ICorDebugThread * This,
            /* [out] */ HTHREAD *phThreadHandle);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppDomain )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugAppDomain **ppAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *SetDebugState )( 
            ICorDebugThread * This,
            /* [in] */ CorDebugThreadState state);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugState )( 
            ICorDebugThread * This,
            /* [out] */ CorDebugThreadState *pState);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserState )( 
            ICorDebugThread * This,
            /* [out] */ CorDebugUserState *pState);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentException )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugValue **ppExceptionObject);
        
        HRESULT ( STDMETHODCALLTYPE *ClearCurrentException )( 
            ICorDebugThread * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateChains )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugChainEnum **ppChains);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveChain )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveFrame )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterSet )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugRegisterSet **ppRegisters);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEval )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugEval **ppEval);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ICorDebugThread * This,
            /* [out] */ ICorDebugValue **ppObject);
        
        END_INTERFACE
    } ICorDebugThreadVtbl;

    interface ICorDebugThread
    {
        CONST_VTBL struct ICorDebugThreadVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugThread_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugThread_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugThread_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugThread_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define ICorDebugThread_GetID(This,pdwThreadId)	\
    (This)->lpVtbl -> GetID(This,pdwThreadId)

#define ICorDebugThread_GetHandle(This,phThreadHandle)	\
    (This)->lpVtbl -> GetHandle(This,phThreadHandle)

#define ICorDebugThread_GetAppDomain(This,ppAppDomain)	\
    (This)->lpVtbl -> GetAppDomain(This,ppAppDomain)

#define ICorDebugThread_SetDebugState(This,state)	\
    (This)->lpVtbl -> SetDebugState(This,state)

#define ICorDebugThread_GetDebugState(This,pState)	\
    (This)->lpVtbl -> GetDebugState(This,pState)

#define ICorDebugThread_GetUserState(This,pState)	\
    (This)->lpVtbl -> GetUserState(This,pState)

#define ICorDebugThread_GetCurrentException(This,ppExceptionObject)	\
    (This)->lpVtbl -> GetCurrentException(This,ppExceptionObject)

#define ICorDebugThread_ClearCurrentException(This)	\
    (This)->lpVtbl -> ClearCurrentException(This)

#define ICorDebugThread_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)

#define ICorDebugThread_EnumerateChains(This,ppChains)	\
    (This)->lpVtbl -> EnumerateChains(This,ppChains)

#define ICorDebugThread_GetActiveChain(This,ppChain)	\
    (This)->lpVtbl -> GetActiveChain(This,ppChain)

#define ICorDebugThread_GetActiveFrame(This,ppFrame)	\
    (This)->lpVtbl -> GetActiveFrame(This,ppFrame)

#define ICorDebugThread_GetRegisterSet(This,ppRegisters)	\
    (This)->lpVtbl -> GetRegisterSet(This,ppRegisters)

#define ICorDebugThread_CreateEval(This,ppEval)	\
    (This)->lpVtbl -> CreateEval(This,ppEval)

#define ICorDebugThread_GetObject(This,ppObject)	\
    (This)->lpVtbl -> GetObject(This,ppObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugThread_GetProcess_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebugThread_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetID_Proxy( 
    ICorDebugThread * This,
    /* [out] */ DWORD *pdwThreadId);


void __RPC_STUB ICorDebugThread_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetHandle_Proxy( 
    ICorDebugThread * This,
    /* [out] */ HTHREAD *phThreadHandle);


void __RPC_STUB ICorDebugThread_GetHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetAppDomain_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugAppDomain **ppAppDomain);


void __RPC_STUB ICorDebugThread_GetAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_SetDebugState_Proxy( 
    ICorDebugThread * This,
    /* [in] */ CorDebugThreadState state);


void __RPC_STUB ICorDebugThread_SetDebugState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetDebugState_Proxy( 
    ICorDebugThread * This,
    /* [out] */ CorDebugThreadState *pState);


void __RPC_STUB ICorDebugThread_GetDebugState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetUserState_Proxy( 
    ICorDebugThread * This,
    /* [out] */ CorDebugUserState *pState);


void __RPC_STUB ICorDebugThread_GetUserState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetCurrentException_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugValue **ppExceptionObject);


void __RPC_STUB ICorDebugThread_GetCurrentException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_ClearCurrentException_Proxy( 
    ICorDebugThread * This);


void __RPC_STUB ICorDebugThread_ClearCurrentException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_CreateStepper_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugStepper **ppStepper);


void __RPC_STUB ICorDebugThread_CreateStepper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_EnumerateChains_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugChainEnum **ppChains);


void __RPC_STUB ICorDebugThread_EnumerateChains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetActiveChain_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugThread_GetActiveChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetActiveFrame_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugFrame **ppFrame);


void __RPC_STUB ICorDebugThread_GetActiveFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetRegisterSet_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugRegisterSet **ppRegisters);


void __RPC_STUB ICorDebugThread_GetRegisterSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_CreateEval_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugEval **ppEval);


void __RPC_STUB ICorDebugThread_CreateEval_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread_GetObject_Proxy( 
    ICorDebugThread * This,
    /* [out] */ ICorDebugValue **ppObject);


void __RPC_STUB ICorDebugThread_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugThread_INTERFACE_DEFINED__ */


#ifndef __ICorDebugThread2_INTERFACE_DEFINED__
#define __ICorDebugThread2_INTERFACE_DEFINED__

/* interface ICorDebugThread2 */
/* [unique][uuid][object] */ 

typedef struct _COR_ACTIVE_FUNCTION
    {
    ICorDebugAppDomain *pAppDomain;
    ICorDebugModule *pModule;
    ICorDebugFunction2 *pFunction;
    ULONG32 ilOffset;
    ULONG32 flags;
    } 	COR_ACTIVE_FUNCTION;


EXTERN_C const IID IID_ICorDebugThread2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2BD956D9-7B07-4bef-8A98-12AA862417C5")
    ICorDebugThread2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetActiveFunctions( 
            /* [in] */ ULONG32 cFunctions,
            /* [out] */ ULONG32 *pcFunctions,
            /* [length_is][size_is][out][in] */ COR_ACTIVE_FUNCTION pFunctions[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConnectionID( 
            /* [out] */ CONNID *pdwConnectionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTaskID( 
            /* [out] */ TASKID *pTaskId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVolatileOSThreadID( 
            /* [out] */ DWORD *pdwTid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InterceptCurrentException( 
            /* [in] */ ICorDebugFrame *pFrame) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugThread2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugThread2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugThread2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugThread2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveFunctions )( 
            ICorDebugThread2 * This,
            /* [in] */ ULONG32 cFunctions,
            /* [out] */ ULONG32 *pcFunctions,
            /* [length_is][size_is][out][in] */ COR_ACTIVE_FUNCTION pFunctions[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetConnectionID )( 
            ICorDebugThread2 * This,
            /* [out] */ CONNID *pdwConnectionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetTaskID )( 
            ICorDebugThread2 * This,
            /* [out] */ TASKID *pTaskId);
        
        HRESULT ( STDMETHODCALLTYPE *GetVolatileOSThreadID )( 
            ICorDebugThread2 * This,
            /* [out] */ DWORD *pdwTid);
        
        HRESULT ( STDMETHODCALLTYPE *InterceptCurrentException )( 
            ICorDebugThread2 * This,
            /* [in] */ ICorDebugFrame *pFrame);
        
        END_INTERFACE
    } ICorDebugThread2Vtbl;

    interface ICorDebugThread2
    {
        CONST_VTBL struct ICorDebugThread2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugThread2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugThread2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugThread2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugThread2_GetActiveFunctions(This,cFunctions,pcFunctions,pFunctions)	\
    (This)->lpVtbl -> GetActiveFunctions(This,cFunctions,pcFunctions,pFunctions)

#define ICorDebugThread2_GetConnectionID(This,pdwConnectionId)	\
    (This)->lpVtbl -> GetConnectionID(This,pdwConnectionId)

#define ICorDebugThread2_GetTaskID(This,pTaskId)	\
    (This)->lpVtbl -> GetTaskID(This,pTaskId)

#define ICorDebugThread2_GetVolatileOSThreadID(This,pdwTid)	\
    (This)->lpVtbl -> GetVolatileOSThreadID(This,pdwTid)

#define ICorDebugThread2_InterceptCurrentException(This,pFrame)	\
    (This)->lpVtbl -> InterceptCurrentException(This,pFrame)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugThread2_GetActiveFunctions_Proxy( 
    ICorDebugThread2 * This,
    /* [in] */ ULONG32 cFunctions,
    /* [out] */ ULONG32 *pcFunctions,
    /* [length_is][size_is][out][in] */ COR_ACTIVE_FUNCTION pFunctions[  ]);


void __RPC_STUB ICorDebugThread2_GetActiveFunctions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread2_GetConnectionID_Proxy( 
    ICorDebugThread2 * This,
    /* [out] */ CONNID *pdwConnectionId);


void __RPC_STUB ICorDebugThread2_GetConnectionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread2_GetTaskID_Proxy( 
    ICorDebugThread2 * This,
    /* [out] */ TASKID *pTaskId);


void __RPC_STUB ICorDebugThread2_GetTaskID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread2_GetVolatileOSThreadID_Proxy( 
    ICorDebugThread2 * This,
    /* [out] */ DWORD *pdwTid);


void __RPC_STUB ICorDebugThread2_GetVolatileOSThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugThread2_InterceptCurrentException_Proxy( 
    ICorDebugThread2 * This,
    /* [in] */ ICorDebugFrame *pFrame);


void __RPC_STUB ICorDebugThread2_InterceptCurrentException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugThread2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugChain_INTERFACE_DEFINED__
#define __ICorDebugChain_INTERFACE_DEFINED__

/* interface ICorDebugChain */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugChainReason
    {	CHAIN_NONE	= 0,
	CHAIN_CLASS_INIT	= 0x1,
	CHAIN_EXCEPTION_FILTER	= 0x2,
	CHAIN_SECURITY	= 0x4,
	CHAIN_CONTEXT_POLICY	= 0x8,
	CHAIN_INTERCEPTION	= 0x10,
	CHAIN_PROCESS_START	= 0x20,
	CHAIN_THREAD_START	= 0x40,
	CHAIN_ENTER_MANAGED	= 0x80,
	CHAIN_ENTER_UNMANAGED	= 0x100,
	CHAIN_DEBUGGER_EVAL	= 0x200,
	CHAIN_CONTEXT_SWITCH	= 0x400,
	CHAIN_FUNC_EVAL	= 0x800
    } 	CorDebugChainReason;


EXTERN_C const IID IID_ICorDebugChain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEE-8A68-11d2-983C-0000F808342D")
    ICorDebugChain : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetThread( 
            /* [out] */ ICorDebugThread **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackRange( 
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ ICorDebugContext **ppContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCaller( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallee( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPrevious( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNext( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsManaged( 
            /* [out] */ BOOL *pManaged) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateFrames( 
            /* [out] */ ICorDebugFrameEnum **ppFrames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActiveFrame( 
            /* [out] */ ICorDebugFrame **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterSet( 
            /* [out] */ ICorDebugRegisterSet **ppRegisters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReason( 
            /* [out] */ CorDebugChainReason *pReason) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugChainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugChain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugChain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugChain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetThread )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugThread **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugChain * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetPrevious )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetNext )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *IsManaged )( 
            ICorDebugChain * This,
            /* [out] */ BOOL *pManaged);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateFrames )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugFrameEnum **ppFrames);
        
        HRESULT ( STDMETHODCALLTYPE *GetActiveFrame )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterSet )( 
            ICorDebugChain * This,
            /* [out] */ ICorDebugRegisterSet **ppRegisters);
        
        HRESULT ( STDMETHODCALLTYPE *GetReason )( 
            ICorDebugChain * This,
            /* [out] */ CorDebugChainReason *pReason);
        
        END_INTERFACE
    } ICorDebugChainVtbl;

    interface ICorDebugChain
    {
        CONST_VTBL struct ICorDebugChainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugChain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugChain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugChain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugChain_GetThread(This,ppThread)	\
    (This)->lpVtbl -> GetThread(This,ppThread)

#define ICorDebugChain_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugChain_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#define ICorDebugChain_GetCaller(This,ppChain)	\
    (This)->lpVtbl -> GetCaller(This,ppChain)

#define ICorDebugChain_GetCallee(This,ppChain)	\
    (This)->lpVtbl -> GetCallee(This,ppChain)

#define ICorDebugChain_GetPrevious(This,ppChain)	\
    (This)->lpVtbl -> GetPrevious(This,ppChain)

#define ICorDebugChain_GetNext(This,ppChain)	\
    (This)->lpVtbl -> GetNext(This,ppChain)

#define ICorDebugChain_IsManaged(This,pManaged)	\
    (This)->lpVtbl -> IsManaged(This,pManaged)

#define ICorDebugChain_EnumerateFrames(This,ppFrames)	\
    (This)->lpVtbl -> EnumerateFrames(This,ppFrames)

#define ICorDebugChain_GetActiveFrame(This,ppFrame)	\
    (This)->lpVtbl -> GetActiveFrame(This,ppFrame)

#define ICorDebugChain_GetRegisterSet(This,ppRegisters)	\
    (This)->lpVtbl -> GetRegisterSet(This,ppRegisters)

#define ICorDebugChain_GetReason(This,pReason)	\
    (This)->lpVtbl -> GetReason(This,pReason)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugChain_GetThread_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugThread **ppThread);


void __RPC_STUB ICorDebugChain_GetThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetStackRange_Proxy( 
    ICorDebugChain * This,
    /* [out] */ CORDB_ADDRESS *pStart,
    /* [out] */ CORDB_ADDRESS *pEnd);


void __RPC_STUB ICorDebugChain_GetStackRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetContext_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugContext **ppContext);


void __RPC_STUB ICorDebugChain_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetCaller_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugChain_GetCaller_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetCallee_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugChain_GetCallee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetPrevious_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugChain_GetPrevious_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetNext_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugChain_GetNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_IsManaged_Proxy( 
    ICorDebugChain * This,
    /* [out] */ BOOL *pManaged);


void __RPC_STUB ICorDebugChain_IsManaged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_EnumerateFrames_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugFrameEnum **ppFrames);


void __RPC_STUB ICorDebugChain_EnumerateFrames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetActiveFrame_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugFrame **ppFrame);


void __RPC_STUB ICorDebugChain_GetActiveFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetRegisterSet_Proxy( 
    ICorDebugChain * This,
    /* [out] */ ICorDebugRegisterSet **ppRegisters);


void __RPC_STUB ICorDebugChain_GetRegisterSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugChain_GetReason_Proxy( 
    ICorDebugChain * This,
    /* [out] */ CorDebugChainReason *pReason);


void __RPC_STUB ICorDebugChain_GetReason_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugChain_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFrame_INTERFACE_DEFINED__
#define __ICorDebugFrame_INTERFACE_DEFINED__

/* interface ICorDebugFrame */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAEF-8A68-11d2-983C-0000F808342D")
    ICorDebugFrame : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetChain( 
            /* [out] */ ICorDebugChain **ppChain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCode( 
            /* [out] */ ICorDebugCode **ppCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunction( 
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionToken( 
            /* [out] */ mdMethodDef *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackRange( 
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCaller( 
            /* [out] */ ICorDebugFrame **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCallee( 
            /* [out] */ ICorDebugFrame **ppFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateStepper( 
            /* [out] */ ICorDebugStepper **ppStepper) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChain )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionToken )( 
            ICorDebugFrame * This,
            /* [out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugFrame * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugFrame * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        END_INTERFACE
    } ICorDebugFrameVtbl;

    interface ICorDebugFrame
    {
        CONST_VTBL struct ICorDebugFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFrame_GetChain(This,ppChain)	\
    (This)->lpVtbl -> GetChain(This,ppChain)

#define ICorDebugFrame_GetCode(This,ppCode)	\
    (This)->lpVtbl -> GetCode(This,ppCode)

#define ICorDebugFrame_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugFrame_GetFunctionToken(This,pToken)	\
    (This)->lpVtbl -> GetFunctionToken(This,pToken)

#define ICorDebugFrame_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugFrame_GetCaller(This,ppFrame)	\
    (This)->lpVtbl -> GetCaller(This,ppFrame)

#define ICorDebugFrame_GetCallee(This,ppFrame)	\
    (This)->lpVtbl -> GetCallee(This,ppFrame)

#define ICorDebugFrame_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetChain_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugChain **ppChain);


void __RPC_STUB ICorDebugFrame_GetChain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetCode_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugCode **ppCode);


void __RPC_STUB ICorDebugFrame_GetCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetFunction_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugFrame_GetFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetFunctionToken_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ mdMethodDef *pToken);


void __RPC_STUB ICorDebugFrame_GetFunctionToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetStackRange_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ CORDB_ADDRESS *pStart,
    /* [out] */ CORDB_ADDRESS *pEnd);


void __RPC_STUB ICorDebugFrame_GetStackRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetCaller_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugFrame **ppFrame);


void __RPC_STUB ICorDebugFrame_GetCaller_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_GetCallee_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugFrame **ppFrame);


void __RPC_STUB ICorDebugFrame_GetCallee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFrame_CreateStepper_Proxy( 
    ICorDebugFrame * This,
    /* [out] */ ICorDebugStepper **ppStepper);


void __RPC_STUB ICorDebugFrame_CreateStepper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFrame_INTERFACE_DEFINED__ */


#ifndef __ICorDebugInternalFrame_INTERFACE_DEFINED__
#define __ICorDebugInternalFrame_INTERFACE_DEFINED__

/* interface ICorDebugInternalFrame */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugInternalFrameType
    {	STUBFRAME_NONE	= 0,
	STUBFRAME_M2U	= 0x1,
	STUBFRAME_U2M	= 0x2,
	STUBFRAME_APPDOMAIN_TRANSITION	= 0x3,
	STUBFRAME_LIGHTWEIGHT_FUNCTION	= 0x4,
	STUBFRAME_FUNC_EVAL	= 0x5,
	STUBFRAME_INTERNALCALL	= 0x6
    } 	CorDebugInternalFrameType;


EXTERN_C const IID IID_ICorDebugInternalFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B92CC7F7-9D2D-45c4-BC2B-621FCC9DFBF4")
    ICorDebugInternalFrame : public ICorDebugFrame
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFrameType( 
            /* [out] */ CorDebugInternalFrameType *pType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugInternalFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugInternalFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugInternalFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugInternalFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChain )( 
            ICorDebugInternalFrame * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugInternalFrame * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugInternalFrame * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionToken )( 
            ICorDebugInternalFrame * This,
            /* [out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugInternalFrame * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugInternalFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugInternalFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugInternalFrame * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        HRESULT ( STDMETHODCALLTYPE *GetFrameType )( 
            ICorDebugInternalFrame * This,
            /* [out] */ CorDebugInternalFrameType *pType);
        
        END_INTERFACE
    } ICorDebugInternalFrameVtbl;

    interface ICorDebugInternalFrame
    {
        CONST_VTBL struct ICorDebugInternalFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugInternalFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugInternalFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugInternalFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugInternalFrame_GetChain(This,ppChain)	\
    (This)->lpVtbl -> GetChain(This,ppChain)

#define ICorDebugInternalFrame_GetCode(This,ppCode)	\
    (This)->lpVtbl -> GetCode(This,ppCode)

#define ICorDebugInternalFrame_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugInternalFrame_GetFunctionToken(This,pToken)	\
    (This)->lpVtbl -> GetFunctionToken(This,pToken)

#define ICorDebugInternalFrame_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugInternalFrame_GetCaller(This,ppFrame)	\
    (This)->lpVtbl -> GetCaller(This,ppFrame)

#define ICorDebugInternalFrame_GetCallee(This,ppFrame)	\
    (This)->lpVtbl -> GetCallee(This,ppFrame)

#define ICorDebugInternalFrame_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)


#define ICorDebugInternalFrame_GetFrameType(This,pType)	\
    (This)->lpVtbl -> GetFrameType(This,pType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugInternalFrame_GetFrameType_Proxy( 
    ICorDebugInternalFrame * This,
    /* [out] */ CorDebugInternalFrameType *pType);


void __RPC_STUB ICorDebugInternalFrame_GetFrameType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugInternalFrame_INTERFACE_DEFINED__ */


#ifndef __ICorDebugILFrame_INTERFACE_DEFINED__
#define __ICorDebugILFrame_INTERFACE_DEFINED__

/* interface ICorDebugILFrame */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugMappingResult
    {	MAPPING_PROLOG	= 0x1,
	MAPPING_EPILOG	= 0x2,
	MAPPING_NO_INFO	= 0x4,
	MAPPING_UNMAPPED_ADDRESS	= 0x8,
	MAPPING_EXACT	= 0x10,
	MAPPING_APPROXIMATE	= 0x20
    } 	CorDebugMappingResult;


EXTERN_C const IID IID_ICorDebugILFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03E26311-4F76-11d3-88C6-006097945418")
    ICorDebugILFrame : public ICorDebugFrame
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIP( 
            /* [out] */ ULONG32 *pnOffset,
            /* [out] */ CorDebugMappingResult *pMappingResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIP( 
            /* [in] */ ULONG32 nOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateLocalVariables( 
            /* [out] */ ICorDebugValueEnum **ppValueEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalVariable( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateArguments( 
            /* [out] */ ICorDebugValueEnum **ppValueEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetArgument( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackDepth( 
            /* [out] */ ULONG32 *pDepth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackValue( 
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSetIP( 
            /* [in] */ ULONG32 nOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugILFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugILFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugILFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugILFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChain )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionToken )( 
            ICorDebugILFrame * This,
            /* [out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugILFrame * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        HRESULT ( STDMETHODCALLTYPE *GetIP )( 
            ICorDebugILFrame * This,
            /* [out] */ ULONG32 *pnOffset,
            /* [out] */ CorDebugMappingResult *pMappingResult);
        
        HRESULT ( STDMETHODCALLTYPE *SetIP )( 
            ICorDebugILFrame * This,
            /* [in] */ ULONG32 nOffset);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateLocalVariables )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugValueEnum **ppValueEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalVariable )( 
            ICorDebugILFrame * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateArguments )( 
            ICorDebugILFrame * This,
            /* [out] */ ICorDebugValueEnum **ppValueEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetArgument )( 
            ICorDebugILFrame * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackDepth )( 
            ICorDebugILFrame * This,
            /* [out] */ ULONG32 *pDepth);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackValue )( 
            ICorDebugILFrame * This,
            /* [in] */ DWORD dwIndex,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *CanSetIP )( 
            ICorDebugILFrame * This,
            /* [in] */ ULONG32 nOffset);
        
        END_INTERFACE
    } ICorDebugILFrameVtbl;

    interface ICorDebugILFrame
    {
        CONST_VTBL struct ICorDebugILFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugILFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugILFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugILFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugILFrame_GetChain(This,ppChain)	\
    (This)->lpVtbl -> GetChain(This,ppChain)

#define ICorDebugILFrame_GetCode(This,ppCode)	\
    (This)->lpVtbl -> GetCode(This,ppCode)

#define ICorDebugILFrame_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugILFrame_GetFunctionToken(This,pToken)	\
    (This)->lpVtbl -> GetFunctionToken(This,pToken)

#define ICorDebugILFrame_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugILFrame_GetCaller(This,ppFrame)	\
    (This)->lpVtbl -> GetCaller(This,ppFrame)

#define ICorDebugILFrame_GetCallee(This,ppFrame)	\
    (This)->lpVtbl -> GetCallee(This,ppFrame)

#define ICorDebugILFrame_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)


#define ICorDebugILFrame_GetIP(This,pnOffset,pMappingResult)	\
    (This)->lpVtbl -> GetIP(This,pnOffset,pMappingResult)

#define ICorDebugILFrame_SetIP(This,nOffset)	\
    (This)->lpVtbl -> SetIP(This,nOffset)

#define ICorDebugILFrame_EnumerateLocalVariables(This,ppValueEnum)	\
    (This)->lpVtbl -> EnumerateLocalVariables(This,ppValueEnum)

#define ICorDebugILFrame_GetLocalVariable(This,dwIndex,ppValue)	\
    (This)->lpVtbl -> GetLocalVariable(This,dwIndex,ppValue)

#define ICorDebugILFrame_EnumerateArguments(This,ppValueEnum)	\
    (This)->lpVtbl -> EnumerateArguments(This,ppValueEnum)

#define ICorDebugILFrame_GetArgument(This,dwIndex,ppValue)	\
    (This)->lpVtbl -> GetArgument(This,dwIndex,ppValue)

#define ICorDebugILFrame_GetStackDepth(This,pDepth)	\
    (This)->lpVtbl -> GetStackDepth(This,pDepth)

#define ICorDebugILFrame_GetStackValue(This,dwIndex,ppValue)	\
    (This)->lpVtbl -> GetStackValue(This,dwIndex,ppValue)

#define ICorDebugILFrame_CanSetIP(This,nOffset)	\
    (This)->lpVtbl -> CanSetIP(This,nOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetIP_Proxy( 
    ICorDebugILFrame * This,
    /* [out] */ ULONG32 *pnOffset,
    /* [out] */ CorDebugMappingResult *pMappingResult);


void __RPC_STUB ICorDebugILFrame_GetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_SetIP_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ ULONG32 nOffset);


void __RPC_STUB ICorDebugILFrame_SetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_EnumerateLocalVariables_Proxy( 
    ICorDebugILFrame * This,
    /* [out] */ ICorDebugValueEnum **ppValueEnum);


void __RPC_STUB ICorDebugILFrame_EnumerateLocalVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetLocalVariable_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugILFrame_GetLocalVariable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_EnumerateArguments_Proxy( 
    ICorDebugILFrame * This,
    /* [out] */ ICorDebugValueEnum **ppValueEnum);


void __RPC_STUB ICorDebugILFrame_EnumerateArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetArgument_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugILFrame_GetArgument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetStackDepth_Proxy( 
    ICorDebugILFrame * This,
    /* [out] */ ULONG32 *pDepth);


void __RPC_STUB ICorDebugILFrame_GetStackDepth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_GetStackValue_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ DWORD dwIndex,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugILFrame_GetStackValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame_CanSetIP_Proxy( 
    ICorDebugILFrame * This,
    /* [in] */ ULONG32 nOffset);


void __RPC_STUB ICorDebugILFrame_CanSetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugILFrame_INTERFACE_DEFINED__ */


#ifndef __ICorDebugILFrame2_INTERFACE_DEFINED__
#define __ICorDebugILFrame2_INTERFACE_DEFINED__

/* interface ICorDebugILFrame2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugILFrame2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5D88A994-6C30-479b-890F-BCEF88B129A5")
    ICorDebugILFrame2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RemapFunction( 
            /* [in] */ ULONG32 newILOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateTypeParameters( 
            /* [out] */ ICorDebugTypeEnum **ppTyParEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugILFrame2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugILFrame2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugILFrame2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugILFrame2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemapFunction )( 
            ICorDebugILFrame2 * This,
            /* [in] */ ULONG32 newILOffset);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateTypeParameters )( 
            ICorDebugILFrame2 * This,
            /* [out] */ ICorDebugTypeEnum **ppTyParEnum);
        
        END_INTERFACE
    } ICorDebugILFrame2Vtbl;

    interface ICorDebugILFrame2
    {
        CONST_VTBL struct ICorDebugILFrame2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugILFrame2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugILFrame2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugILFrame2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugILFrame2_RemapFunction(This,newILOffset)	\
    (This)->lpVtbl -> RemapFunction(This,newILOffset)

#define ICorDebugILFrame2_EnumerateTypeParameters(This,ppTyParEnum)	\
    (This)->lpVtbl -> EnumerateTypeParameters(This,ppTyParEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugILFrame2_RemapFunction_Proxy( 
    ICorDebugILFrame2 * This,
    /* [in] */ ULONG32 newILOffset);


void __RPC_STUB ICorDebugILFrame2_RemapFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugILFrame2_EnumerateTypeParameters_Proxy( 
    ICorDebugILFrame2 * This,
    /* [out] */ ICorDebugTypeEnum **ppTyParEnum);


void __RPC_STUB ICorDebugILFrame2_EnumerateTypeParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugILFrame2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugNativeFrame_INTERFACE_DEFINED__
#define __ICorDebugNativeFrame_INTERFACE_DEFINED__

/* interface ICorDebugNativeFrame */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugNativeFrame;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("03E26314-4F76-11d3-88C6-006097945418")
    ICorDebugNativeFrame : public ICorDebugFrame
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetIP( 
            /* [out] */ ULONG32 *pnOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetIP( 
            /* [in] */ ULONG32 nOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterSet( 
            /* [out] */ ICorDebugRegisterSet **ppRegisters) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalRegisterValue( 
            /* [in] */ CorDebugRegister reg,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalDoubleRegisterValue( 
            /* [in] */ CorDebugRegister highWordReg,
            /* [in] */ CorDebugRegister lowWordReg,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalMemoryValue( 
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalRegisterMemoryValue( 
            /* [in] */ CorDebugRegister highWordReg,
            /* [in] */ CORDB_ADDRESS lowWordAddress,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalMemoryRegisterValue( 
            /* [in] */ CORDB_ADDRESS highWordAddress,
            /* [in] */ CorDebugRegister lowWordRegister,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSetIP( 
            /* [in] */ ULONG32 nOffset) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugNativeFrameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugNativeFrame * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugNativeFrame * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugNativeFrame * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetChain )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugChain **ppChain);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionToken )( 
            ICorDebugNativeFrame * This,
            /* [out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackRange )( 
            ICorDebugNativeFrame * This,
            /* [out] */ CORDB_ADDRESS *pStart,
            /* [out] */ CORDB_ADDRESS *pEnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetCaller )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *GetCallee )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugFrame **ppFrame);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStepper )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugStepper **ppStepper);
        
        HRESULT ( STDMETHODCALLTYPE *GetIP )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ULONG32 *pnOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetIP )( 
            ICorDebugNativeFrame * This,
            /* [in] */ ULONG32 nOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterSet )( 
            ICorDebugNativeFrame * This,
            /* [out] */ ICorDebugRegisterSet **ppRegisters);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalRegisterValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CorDebugRegister reg,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalDoubleRegisterValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CorDebugRegister highWordReg,
            /* [in] */ CorDebugRegister lowWordReg,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalMemoryValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CORDB_ADDRESS address,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalRegisterMemoryValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CorDebugRegister highWordReg,
            /* [in] */ CORDB_ADDRESS lowWordAddress,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalMemoryRegisterValue )( 
            ICorDebugNativeFrame * This,
            /* [in] */ CORDB_ADDRESS highWordAddress,
            /* [in] */ CorDebugRegister lowWordRegister,
            /* [in] */ ULONG cbSigBlob,
            /* [in] */ PCCOR_SIGNATURE pvSigBlob,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *CanSetIP )( 
            ICorDebugNativeFrame * This,
            /* [in] */ ULONG32 nOffset);
        
        END_INTERFACE
    } ICorDebugNativeFrameVtbl;

    interface ICorDebugNativeFrame
    {
        CONST_VTBL struct ICorDebugNativeFrameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugNativeFrame_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugNativeFrame_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugNativeFrame_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugNativeFrame_GetChain(This,ppChain)	\
    (This)->lpVtbl -> GetChain(This,ppChain)

#define ICorDebugNativeFrame_GetCode(This,ppCode)	\
    (This)->lpVtbl -> GetCode(This,ppCode)

#define ICorDebugNativeFrame_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugNativeFrame_GetFunctionToken(This,pToken)	\
    (This)->lpVtbl -> GetFunctionToken(This,pToken)

#define ICorDebugNativeFrame_GetStackRange(This,pStart,pEnd)	\
    (This)->lpVtbl -> GetStackRange(This,pStart,pEnd)

#define ICorDebugNativeFrame_GetCaller(This,ppFrame)	\
    (This)->lpVtbl -> GetCaller(This,ppFrame)

#define ICorDebugNativeFrame_GetCallee(This,ppFrame)	\
    (This)->lpVtbl -> GetCallee(This,ppFrame)

#define ICorDebugNativeFrame_CreateStepper(This,ppStepper)	\
    (This)->lpVtbl -> CreateStepper(This,ppStepper)


#define ICorDebugNativeFrame_GetIP(This,pnOffset)	\
    (This)->lpVtbl -> GetIP(This,pnOffset)

#define ICorDebugNativeFrame_SetIP(This,nOffset)	\
    (This)->lpVtbl -> SetIP(This,nOffset)

#define ICorDebugNativeFrame_GetRegisterSet(This,ppRegisters)	\
    (This)->lpVtbl -> GetRegisterSet(This,ppRegisters)

#define ICorDebugNativeFrame_GetLocalRegisterValue(This,reg,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalRegisterValue(This,reg,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_GetLocalDoubleRegisterValue(This,highWordReg,lowWordReg,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalDoubleRegisterValue(This,highWordReg,lowWordReg,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_GetLocalMemoryValue(This,address,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalMemoryValue(This,address,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_GetLocalRegisterMemoryValue(This,highWordReg,lowWordAddress,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalRegisterMemoryValue(This,highWordReg,lowWordAddress,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_GetLocalMemoryRegisterValue(This,highWordAddress,lowWordRegister,cbSigBlob,pvSigBlob,ppValue)	\
    (This)->lpVtbl -> GetLocalMemoryRegisterValue(This,highWordAddress,lowWordRegister,cbSigBlob,pvSigBlob,ppValue)

#define ICorDebugNativeFrame_CanSetIP(This,nOffset)	\
    (This)->lpVtbl -> CanSetIP(This,nOffset)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetIP_Proxy( 
    ICorDebugNativeFrame * This,
    /* [out] */ ULONG32 *pnOffset);


void __RPC_STUB ICorDebugNativeFrame_GetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_SetIP_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ ULONG32 nOffset);


void __RPC_STUB ICorDebugNativeFrame_SetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetRegisterSet_Proxy( 
    ICorDebugNativeFrame * This,
    /* [out] */ ICorDebugRegisterSet **ppRegisters);


void __RPC_STUB ICorDebugNativeFrame_GetRegisterSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalRegisterValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CorDebugRegister reg,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalRegisterValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalDoubleRegisterValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CorDebugRegister highWordReg,
    /* [in] */ CorDebugRegister lowWordReg,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalDoubleRegisterValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalMemoryValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CORDB_ADDRESS address,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalMemoryValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalRegisterMemoryValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CorDebugRegister highWordReg,
    /* [in] */ CORDB_ADDRESS lowWordAddress,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalRegisterMemoryValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_GetLocalMemoryRegisterValue_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ CORDB_ADDRESS highWordAddress,
    /* [in] */ CorDebugRegister lowWordRegister,
    /* [in] */ ULONG cbSigBlob,
    /* [in] */ PCCOR_SIGNATURE pvSigBlob,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugNativeFrame_GetLocalMemoryRegisterValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugNativeFrame_CanSetIP_Proxy( 
    ICorDebugNativeFrame * This,
    /* [in] */ ULONG32 nOffset);


void __RPC_STUB ICorDebugNativeFrame_CanSetIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugNativeFrame_INTERFACE_DEFINED__ */


#ifndef __ICorDebugModule_INTERFACE_DEFINED__
#define __ICorDebugModule_INTERFACE_DEFINED__

/* interface ICorDebugModule */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugModule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("dba2d8c1-e5c5-4069-8c13-10a7c6abf43d")
    ICorDebugModule : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [out] */ ICorDebugProcess **ppProcess) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaseAddress( 
            /* [out] */ CORDB_ADDRESS *pAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssembly( 
            /* [out] */ ICorDebugAssembly **ppAssembly) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableJITDebugging( 
            /* [in] */ BOOL bTrackJITInfo,
            /* [in] */ BOOL bAllowJitOpts) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnableClassLoadCallbacks( 
            /* [in] */ BOOL bClassLoadCallbacks) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromToken( 
            /* [in] */ mdMethodDef methodDef,
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromRVA( 
            /* [in] */ CORDB_ADDRESS rva,
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassFromToken( 
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ICorDebugClass **ppClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBreakpoint( 
            /* [out] */ ICorDebugModuleBreakpoint **ppBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEditAndContinueSnapshot( 
            /* [out] */ ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMetaDataInterface( 
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ mdModule *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDynamic( 
            /* [out] */ BOOL *pDynamic) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlobalVariableValue( 
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG32 *pcBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsInMemory( 
            /* [out] */ BOOL *pInMemory) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugModuleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugModule * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugModule * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugModule * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorDebugModule * This,
            /* [out] */ ICorDebugProcess **ppProcess);
        
        HRESULT ( STDMETHODCALLTYPE *GetBaseAddress )( 
            ICorDebugModule * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssembly )( 
            ICorDebugModule * This,
            /* [out] */ ICorDebugAssembly **ppAssembly);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorDebugModule * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *EnableJITDebugging )( 
            ICorDebugModule * This,
            /* [in] */ BOOL bTrackJITInfo,
            /* [in] */ BOOL bAllowJitOpts);
        
        HRESULT ( STDMETHODCALLTYPE *EnableClassLoadCallbacks )( 
            ICorDebugModule * This,
            /* [in] */ BOOL bClassLoadCallbacks);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromToken )( 
            ICorDebugModule * This,
            /* [in] */ mdMethodDef methodDef,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromRVA )( 
            ICorDebugModule * This,
            /* [in] */ CORDB_ADDRESS rva,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromToken )( 
            ICorDebugModule * This,
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugModule * This,
            /* [out] */ ICorDebugModuleBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetEditAndContinueSnapshot )( 
            ICorDebugModule * This,
            /* [out] */ ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetaDataInterface )( 
            ICorDebugModule * This,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppObj);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ICorDebugModule * This,
            /* [out] */ mdModule *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *IsDynamic )( 
            ICorDebugModule * This,
            /* [out] */ BOOL *pDynamic);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalVariableValue )( 
            ICorDebugModule * This,
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugModule * This,
            /* [out] */ ULONG32 *pcBytes);
        
        HRESULT ( STDMETHODCALLTYPE *IsInMemory )( 
            ICorDebugModule * This,
            /* [out] */ BOOL *pInMemory);
        
        END_INTERFACE
    } ICorDebugModuleVtbl;

    interface ICorDebugModule
    {
        CONST_VTBL struct ICorDebugModuleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugModule_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugModule_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugModule_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugModule_GetProcess(This,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,ppProcess)

#define ICorDebugModule_GetBaseAddress(This,pAddress)	\
    (This)->lpVtbl -> GetBaseAddress(This,pAddress)

#define ICorDebugModule_GetAssembly(This,ppAssembly)	\
    (This)->lpVtbl -> GetAssembly(This,ppAssembly)

#define ICorDebugModule_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ICorDebugModule_EnableJITDebugging(This,bTrackJITInfo,bAllowJitOpts)	\
    (This)->lpVtbl -> EnableJITDebugging(This,bTrackJITInfo,bAllowJitOpts)

#define ICorDebugModule_EnableClassLoadCallbacks(This,bClassLoadCallbacks)	\
    (This)->lpVtbl -> EnableClassLoadCallbacks(This,bClassLoadCallbacks)

#define ICorDebugModule_GetFunctionFromToken(This,methodDef,ppFunction)	\
    (This)->lpVtbl -> GetFunctionFromToken(This,methodDef,ppFunction)

#define ICorDebugModule_GetFunctionFromRVA(This,rva,ppFunction)	\
    (This)->lpVtbl -> GetFunctionFromRVA(This,rva,ppFunction)

#define ICorDebugModule_GetClassFromToken(This,typeDef,ppClass)	\
    (This)->lpVtbl -> GetClassFromToken(This,typeDef,ppClass)

#define ICorDebugModule_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)

#define ICorDebugModule_GetEditAndContinueSnapshot(This,ppEditAndContinueSnapshot)	\
    (This)->lpVtbl -> GetEditAndContinueSnapshot(This,ppEditAndContinueSnapshot)

#define ICorDebugModule_GetMetaDataInterface(This,riid,ppObj)	\
    (This)->lpVtbl -> GetMetaDataInterface(This,riid,ppObj)

#define ICorDebugModule_GetToken(This,pToken)	\
    (This)->lpVtbl -> GetToken(This,pToken)

#define ICorDebugModule_IsDynamic(This,pDynamic)	\
    (This)->lpVtbl -> IsDynamic(This,pDynamic)

#define ICorDebugModule_GetGlobalVariableValue(This,fieldDef,ppValue)	\
    (This)->lpVtbl -> GetGlobalVariableValue(This,fieldDef,ppValue)

#define ICorDebugModule_GetSize(This,pcBytes)	\
    (This)->lpVtbl -> GetSize(This,pcBytes)

#define ICorDebugModule_IsInMemory(This,pInMemory)	\
    (This)->lpVtbl -> IsInMemory(This,pInMemory)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugModule_GetProcess_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ICorDebugProcess **ppProcess);


void __RPC_STUB ICorDebugModule_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetBaseAddress_Proxy( 
    ICorDebugModule * This,
    /* [out] */ CORDB_ADDRESS *pAddress);


void __RPC_STUB ICorDebugModule_GetBaseAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetAssembly_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ICorDebugAssembly **ppAssembly);


void __RPC_STUB ICorDebugModule_GetAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetName_Proxy( 
    ICorDebugModule * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugModule_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_EnableJITDebugging_Proxy( 
    ICorDebugModule * This,
    /* [in] */ BOOL bTrackJITInfo,
    /* [in] */ BOOL bAllowJitOpts);


void __RPC_STUB ICorDebugModule_EnableJITDebugging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_EnableClassLoadCallbacks_Proxy( 
    ICorDebugModule * This,
    /* [in] */ BOOL bClassLoadCallbacks);


void __RPC_STUB ICorDebugModule_EnableClassLoadCallbacks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetFunctionFromToken_Proxy( 
    ICorDebugModule * This,
    /* [in] */ mdMethodDef methodDef,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugModule_GetFunctionFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetFunctionFromRVA_Proxy( 
    ICorDebugModule * This,
    /* [in] */ CORDB_ADDRESS rva,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugModule_GetFunctionFromRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetClassFromToken_Proxy( 
    ICorDebugModule * This,
    /* [in] */ mdTypeDef typeDef,
    /* [out] */ ICorDebugClass **ppClass);


void __RPC_STUB ICorDebugModule_GetClassFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_CreateBreakpoint_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ICorDebugModuleBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugModule_CreateBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetEditAndContinueSnapshot_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ICorDebugEditAndContinueSnapshot **ppEditAndContinueSnapshot);


void __RPC_STUB ICorDebugModule_GetEditAndContinueSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetMetaDataInterface_Proxy( 
    ICorDebugModule * This,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppObj);


void __RPC_STUB ICorDebugModule_GetMetaDataInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetToken_Proxy( 
    ICorDebugModule * This,
    /* [out] */ mdModule *pToken);


void __RPC_STUB ICorDebugModule_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_IsDynamic_Proxy( 
    ICorDebugModule * This,
    /* [out] */ BOOL *pDynamic);


void __RPC_STUB ICorDebugModule_IsDynamic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetGlobalVariableValue_Proxy( 
    ICorDebugModule * This,
    /* [in] */ mdFieldDef fieldDef,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugModule_GetGlobalVariableValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_GetSize_Proxy( 
    ICorDebugModule * This,
    /* [out] */ ULONG32 *pcBytes);


void __RPC_STUB ICorDebugModule_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule_IsInMemory_Proxy( 
    ICorDebugModule * This,
    /* [out] */ BOOL *pInMemory);


void __RPC_STUB ICorDebugModule_IsInMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugModule_INTERFACE_DEFINED__ */


#ifndef __ICorDebugModule2_INTERFACE_DEFINED__
#define __ICorDebugModule2_INTERFACE_DEFINED__

/* interface ICorDebugModule2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugModule2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7FCC5FB5-49C0-41de-9938-3B88B5B9ADD7")
    ICorDebugModule2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetJMCStatus( 
            /* [in] */ BOOL bIsJustMyCode,
            /* [in] */ ULONG32 cTokens,
            /* [size_is][in] */ mdToken pTokens[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ApplyChanges( 
            /* [in] */ ULONG cbMetadata,
            /* [size_is][in] */ BYTE pbMetadata[  ],
            /* [in] */ ULONG cbIL,
            /* [size_is][in] */ BYTE pbIL[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetJITCompilerFlags( 
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJITCompilerFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResolveAssembly( 
            /* [in] */ mdToken tkAssemblyRef,
            /* [out] */ ICorDebugAssembly **ppAssembly) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugModule2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugModule2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugModule2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugModule2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetJMCStatus )( 
            ICorDebugModule2 * This,
            /* [in] */ BOOL bIsJustMyCode,
            /* [in] */ ULONG32 cTokens,
            /* [size_is][in] */ mdToken pTokens[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ApplyChanges )( 
            ICorDebugModule2 * This,
            /* [in] */ ULONG cbMetadata,
            /* [size_is][in] */ BYTE pbMetadata[  ],
            /* [in] */ ULONG cbIL,
            /* [size_is][in] */ BYTE pbIL[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetJITCompilerFlags )( 
            ICorDebugModule2 * This,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetJITCompilerFlags )( 
            ICorDebugModule2 * This,
            /* [out] */ DWORD *pdwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *ResolveAssembly )( 
            ICorDebugModule2 * This,
            /* [in] */ mdToken tkAssemblyRef,
            /* [out] */ ICorDebugAssembly **ppAssembly);
        
        END_INTERFACE
    } ICorDebugModule2Vtbl;

    interface ICorDebugModule2
    {
        CONST_VTBL struct ICorDebugModule2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugModule2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugModule2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugModule2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugModule2_SetJMCStatus(This,bIsJustMyCode,cTokens,pTokens)	\
    (This)->lpVtbl -> SetJMCStatus(This,bIsJustMyCode,cTokens,pTokens)

#define ICorDebugModule2_ApplyChanges(This,cbMetadata,pbMetadata,cbIL,pbIL)	\
    (This)->lpVtbl -> ApplyChanges(This,cbMetadata,pbMetadata,cbIL,pbIL)

#define ICorDebugModule2_SetJITCompilerFlags(This,dwFlags)	\
    (This)->lpVtbl -> SetJITCompilerFlags(This,dwFlags)

#define ICorDebugModule2_GetJITCompilerFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetJITCompilerFlags(This,pdwFlags)

#define ICorDebugModule2_ResolveAssembly(This,tkAssemblyRef,ppAssembly)	\
    (This)->lpVtbl -> ResolveAssembly(This,tkAssemblyRef,ppAssembly)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugModule2_SetJMCStatus_Proxy( 
    ICorDebugModule2 * This,
    /* [in] */ BOOL bIsJustMyCode,
    /* [in] */ ULONG32 cTokens,
    /* [size_is][in] */ mdToken pTokens[  ]);


void __RPC_STUB ICorDebugModule2_SetJMCStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule2_ApplyChanges_Proxy( 
    ICorDebugModule2 * This,
    /* [in] */ ULONG cbMetadata,
    /* [size_is][in] */ BYTE pbMetadata[  ],
    /* [in] */ ULONG cbIL,
    /* [size_is][in] */ BYTE pbIL[  ]);


void __RPC_STUB ICorDebugModule2_ApplyChanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule2_SetJITCompilerFlags_Proxy( 
    ICorDebugModule2 * This,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB ICorDebugModule2_SetJITCompilerFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule2_GetJITCompilerFlags_Proxy( 
    ICorDebugModule2 * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB ICorDebugModule2_GetJITCompilerFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugModule2_ResolveAssembly_Proxy( 
    ICorDebugModule2 * This,
    /* [in] */ mdToken tkAssemblyRef,
    /* [out] */ ICorDebugAssembly **ppAssembly);


void __RPC_STUB ICorDebugModule2_ResolveAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugModule2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFunction_INTERFACE_DEFINED__
#define __ICorDebugFunction_INTERFACE_DEFINED__

/* interface ICorDebugFunction */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFunction;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF3-8A68-11d2-983C-0000F808342D")
    ICorDebugFunction : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ ICorDebugModule **ppModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClass( 
            /* [out] */ ICorDebugClass **ppClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ mdMethodDef *pMethodDef) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILCode( 
            /* [out] */ ICorDebugCode **ppCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNativeCode( 
            /* [out] */ ICorDebugCode **ppCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBreakpoint( 
            /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalVarSigToken( 
            /* [out] */ mdSignature *pmdSig) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentVersionNumber( 
            /* [out] */ ULONG32 *pnCurrentVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFunctionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFunction * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFunction * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFunction * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugModule **ppModule);
        
        HRESULT ( STDMETHODCALLTYPE *GetClass )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ICorDebugFunction * This,
            /* [out] */ mdMethodDef *pMethodDef);
        
        HRESULT ( STDMETHODCALLTYPE *GetILCode )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetNativeCode )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugCode **ppCode);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugFunction * This,
            /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalVarSigToken )( 
            ICorDebugFunction * This,
            /* [out] */ mdSignature *pmdSig);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentVersionNumber )( 
            ICorDebugFunction * This,
            /* [out] */ ULONG32 *pnCurrentVersion);
        
        END_INTERFACE
    } ICorDebugFunctionVtbl;

    interface ICorDebugFunction
    {
        CONST_VTBL struct ICorDebugFunctionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFunction_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFunction_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFunction_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFunction_GetModule(This,ppModule)	\
    (This)->lpVtbl -> GetModule(This,ppModule)

#define ICorDebugFunction_GetClass(This,ppClass)	\
    (This)->lpVtbl -> GetClass(This,ppClass)

#define ICorDebugFunction_GetToken(This,pMethodDef)	\
    (This)->lpVtbl -> GetToken(This,pMethodDef)

#define ICorDebugFunction_GetILCode(This,ppCode)	\
    (This)->lpVtbl -> GetILCode(This,ppCode)

#define ICorDebugFunction_GetNativeCode(This,ppCode)	\
    (This)->lpVtbl -> GetNativeCode(This,ppCode)

#define ICorDebugFunction_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)

#define ICorDebugFunction_GetLocalVarSigToken(This,pmdSig)	\
    (This)->lpVtbl -> GetLocalVarSigToken(This,pmdSig)

#define ICorDebugFunction_GetCurrentVersionNumber(This,pnCurrentVersion)	\
    (This)->lpVtbl -> GetCurrentVersionNumber(This,pnCurrentVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetModule_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugModule **ppModule);


void __RPC_STUB ICorDebugFunction_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetClass_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugClass **ppClass);


void __RPC_STUB ICorDebugFunction_GetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetToken_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ mdMethodDef *pMethodDef);


void __RPC_STUB ICorDebugFunction_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetILCode_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugCode **ppCode);


void __RPC_STUB ICorDebugFunction_GetILCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetNativeCode_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugCode **ppCode);


void __RPC_STUB ICorDebugFunction_GetNativeCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_CreateBreakpoint_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugFunction_CreateBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetLocalVarSigToken_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ mdSignature *pmdSig);


void __RPC_STUB ICorDebugFunction_GetLocalVarSigToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction_GetCurrentVersionNumber_Proxy( 
    ICorDebugFunction * This,
    /* [out] */ ULONG32 *pnCurrentVersion);


void __RPC_STUB ICorDebugFunction_GetCurrentVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFunction_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFunction2_INTERFACE_DEFINED__
#define __ICorDebugFunction2_INTERFACE_DEFINED__

/* interface ICorDebugFunction2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFunction2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EF0C490B-94C3-4e4d-B629-DDC134C532D8")
    ICorDebugFunction2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetJMCStatus( 
            /* [in] */ BOOL bIsJustMyCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetJMCStatus( 
            /* [out] */ BOOL *pbIsJustMyCode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateNativeCode( 
            /* [out] */ ICorDebugCodeEnum **ppCodeEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ ULONG32 *pnVersion) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFunction2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFunction2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFunction2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFunction2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetJMCStatus )( 
            ICorDebugFunction2 * This,
            /* [in] */ BOOL bIsJustMyCode);
        
        HRESULT ( STDMETHODCALLTYPE *GetJMCStatus )( 
            ICorDebugFunction2 * This,
            /* [out] */ BOOL *pbIsJustMyCode);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateNativeCode )( 
            ICorDebugFunction2 * This,
            /* [out] */ ICorDebugCodeEnum **ppCodeEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            ICorDebugFunction2 * This,
            /* [out] */ ULONG32 *pnVersion);
        
        END_INTERFACE
    } ICorDebugFunction2Vtbl;

    interface ICorDebugFunction2
    {
        CONST_VTBL struct ICorDebugFunction2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFunction2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFunction2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFunction2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFunction2_SetJMCStatus(This,bIsJustMyCode)	\
    (This)->lpVtbl -> SetJMCStatus(This,bIsJustMyCode)

#define ICorDebugFunction2_GetJMCStatus(This,pbIsJustMyCode)	\
    (This)->lpVtbl -> GetJMCStatus(This,pbIsJustMyCode)

#define ICorDebugFunction2_EnumerateNativeCode(This,ppCodeEnum)	\
    (This)->lpVtbl -> EnumerateNativeCode(This,ppCodeEnum)

#define ICorDebugFunction2_GetVersionNumber(This,pnVersion)	\
    (This)->lpVtbl -> GetVersionNumber(This,pnVersion)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFunction2_SetJMCStatus_Proxy( 
    ICorDebugFunction2 * This,
    /* [in] */ BOOL bIsJustMyCode);


void __RPC_STUB ICorDebugFunction2_SetJMCStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction2_GetJMCStatus_Proxy( 
    ICorDebugFunction2 * This,
    /* [out] */ BOOL *pbIsJustMyCode);


void __RPC_STUB ICorDebugFunction2_GetJMCStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction2_EnumerateNativeCode_Proxy( 
    ICorDebugFunction2 * This,
    /* [out] */ ICorDebugCodeEnum **ppCodeEnum);


void __RPC_STUB ICorDebugFunction2_EnumerateNativeCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugFunction2_GetVersionNumber_Proxy( 
    ICorDebugFunction2 * This,
    /* [out] */ ULONG32 *pnVersion);


void __RPC_STUB ICorDebugFunction2_GetVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFunction2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugCode_INTERFACE_DEFINED__
#define __ICorDebugCode_INTERFACE_DEFINED__

/* interface ICorDebugCode */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugCode;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF4-8A68-11d2-983C-0000F808342D")
    ICorDebugCode : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsIL( 
            /* [out] */ BOOL *pbIL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunction( 
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddress( 
            /* [out] */ CORDB_ADDRESS *pStart) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG32 *pcBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBreakpoint( 
            /* [in] */ ULONG32 offset,
            /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCode( 
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset,
            /* [in] */ ULONG32 cBufferAlloc,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ ULONG32 *pcBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersionNumber( 
            /* [out] */ ULONG32 *nVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILToNativeMapping( 
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEnCRemapSequencePoints( 
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ ULONG32 offsets[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugCodeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugCode * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugCode * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugCode * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsIL )( 
            ICorDebugCode * This,
            /* [out] */ BOOL *pbIL);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunction )( 
            ICorDebugCode * This,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugCode * This,
            /* [out] */ CORDB_ADDRESS *pStart);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugCode * This,
            /* [out] */ ULONG32 *pcBytes);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugCode * This,
            /* [in] */ ULONG32 offset,
            /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetCode )( 
            ICorDebugCode * This,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset,
            /* [in] */ ULONG32 cBufferAlloc,
            /* [length_is][size_is][out] */ BYTE buffer[  ],
            /* [out] */ ULONG32 *pcBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersionNumber )( 
            ICorDebugCode * This,
            /* [out] */ ULONG32 *nVersion);
        
        HRESULT ( STDMETHODCALLTYPE *GetILToNativeMapping )( 
            ICorDebugCode * This,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetEnCRemapSequencePoints )( 
            ICorDebugCode * This,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ ULONG32 offsets[  ]);
        
        END_INTERFACE
    } ICorDebugCodeVtbl;

    interface ICorDebugCode
    {
        CONST_VTBL struct ICorDebugCodeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugCode_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugCode_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugCode_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugCode_IsIL(This,pbIL)	\
    (This)->lpVtbl -> IsIL(This,pbIL)

#define ICorDebugCode_GetFunction(This,ppFunction)	\
    (This)->lpVtbl -> GetFunction(This,ppFunction)

#define ICorDebugCode_GetAddress(This,pStart)	\
    (This)->lpVtbl -> GetAddress(This,pStart)

#define ICorDebugCode_GetSize(This,pcBytes)	\
    (This)->lpVtbl -> GetSize(This,pcBytes)

#define ICorDebugCode_CreateBreakpoint(This,offset,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,offset,ppBreakpoint)

#define ICorDebugCode_GetCode(This,startOffset,endOffset,cBufferAlloc,buffer,pcBufferSize)	\
    (This)->lpVtbl -> GetCode(This,startOffset,endOffset,cBufferAlloc,buffer,pcBufferSize)

#define ICorDebugCode_GetVersionNumber(This,nVersion)	\
    (This)->lpVtbl -> GetVersionNumber(This,nVersion)

#define ICorDebugCode_GetILToNativeMapping(This,cMap,pcMap,map)	\
    (This)->lpVtbl -> GetILToNativeMapping(This,cMap,pcMap,map)

#define ICorDebugCode_GetEnCRemapSequencePoints(This,cMap,pcMap,offsets)	\
    (This)->lpVtbl -> GetEnCRemapSequencePoints(This,cMap,pcMap,offsets)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugCode_IsIL_Proxy( 
    ICorDebugCode * This,
    /* [out] */ BOOL *pbIL);


void __RPC_STUB ICorDebugCode_IsIL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetFunction_Proxy( 
    ICorDebugCode * This,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugCode_GetFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetAddress_Proxy( 
    ICorDebugCode * This,
    /* [out] */ CORDB_ADDRESS *pStart);


void __RPC_STUB ICorDebugCode_GetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetSize_Proxy( 
    ICorDebugCode * This,
    /* [out] */ ULONG32 *pcBytes);


void __RPC_STUB ICorDebugCode_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_CreateBreakpoint_Proxy( 
    ICorDebugCode * This,
    /* [in] */ ULONG32 offset,
    /* [out] */ ICorDebugFunctionBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugCode_CreateBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetCode_Proxy( 
    ICorDebugCode * This,
    /* [in] */ ULONG32 startOffset,
    /* [in] */ ULONG32 endOffset,
    /* [in] */ ULONG32 cBufferAlloc,
    /* [length_is][size_is][out] */ BYTE buffer[  ],
    /* [out] */ ULONG32 *pcBufferSize);


void __RPC_STUB ICorDebugCode_GetCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetVersionNumber_Proxy( 
    ICorDebugCode * This,
    /* [out] */ ULONG32 *nVersion);


void __RPC_STUB ICorDebugCode_GetVersionNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetILToNativeMapping_Proxy( 
    ICorDebugCode * This,
    /* [in] */ ULONG32 cMap,
    /* [out] */ ULONG32 *pcMap,
    /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);


void __RPC_STUB ICorDebugCode_GetILToNativeMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode_GetEnCRemapSequencePoints_Proxy( 
    ICorDebugCode * This,
    /* [in] */ ULONG32 cMap,
    /* [out] */ ULONG32 *pcMap,
    /* [length_is][size_is][out] */ ULONG32 offsets[  ]);


void __RPC_STUB ICorDebugCode_GetEnCRemapSequencePoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugCode_INTERFACE_DEFINED__ */


#ifndef __ICorDebugCode2_INTERFACE_DEFINED__
#define __ICorDebugCode2_INTERFACE_DEFINED__

/* interface ICorDebugCode2 */
/* [unique][uuid][object] */ 

typedef struct _CodeChunkInfo
    {
    CORDB_ADDRESS startAddr;
    ULONG32 length;
    } 	CodeChunkInfo;


EXTERN_C const IID IID_ICorDebugCode2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5F696509-452F-4436-A3FE-4D11FE7E2347")
    ICorDebugCode2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCodeChunks( 
            /* [in] */ ULONG32 cbufSize,
            /* [out] */ ULONG32 *pcnumChunks,
            /* [length_is][size_is][out] */ CodeChunkInfo chunks[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompilerFlags( 
            /* [out] */ DWORD *pdwFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugCode2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugCode2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugCode2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugCode2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeChunks )( 
            ICorDebugCode2 * This,
            /* [in] */ ULONG32 cbufSize,
            /* [out] */ ULONG32 *pcnumChunks,
            /* [length_is][size_is][out] */ CodeChunkInfo chunks[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompilerFlags )( 
            ICorDebugCode2 * This,
            /* [out] */ DWORD *pdwFlags);
        
        END_INTERFACE
    } ICorDebugCode2Vtbl;

    interface ICorDebugCode2
    {
        CONST_VTBL struct ICorDebugCode2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugCode2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugCode2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugCode2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugCode2_GetCodeChunks(This,cbufSize,pcnumChunks,chunks)	\
    (This)->lpVtbl -> GetCodeChunks(This,cbufSize,pcnumChunks,chunks)

#define ICorDebugCode2_GetCompilerFlags(This,pdwFlags)	\
    (This)->lpVtbl -> GetCompilerFlags(This,pdwFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugCode2_GetCodeChunks_Proxy( 
    ICorDebugCode2 * This,
    /* [in] */ ULONG32 cbufSize,
    /* [out] */ ULONG32 *pcnumChunks,
    /* [length_is][size_is][out] */ CodeChunkInfo chunks[  ]);


void __RPC_STUB ICorDebugCode2_GetCodeChunks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugCode2_GetCompilerFlags_Proxy( 
    ICorDebugCode2 * This,
    /* [out] */ DWORD *pdwFlags);


void __RPC_STUB ICorDebugCode2_GetCompilerFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugCode2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugClass_INTERFACE_DEFINED__
#define __ICorDebugClass_INTERFACE_DEFINED__

/* interface ICorDebugClass */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugClass;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF5-8A68-11d2-983C-0000F808342D")
    ICorDebugClass : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ ICorDebugModule **pModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ mdTypeDef *pTypeDef) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStaticFieldValue( 
            /* [in] */ mdFieldDef fieldDef,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugClassVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugClass * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugClass * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugClass * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            ICorDebugClass * This,
            /* [out] */ ICorDebugModule **pModule);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ICorDebugClass * This,
            /* [out] */ mdTypeDef *pTypeDef);
        
        HRESULT ( STDMETHODCALLTYPE *GetStaticFieldValue )( 
            ICorDebugClass * This,
            /* [in] */ mdFieldDef fieldDef,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugClassVtbl;

    interface ICorDebugClass
    {
        CONST_VTBL struct ICorDebugClassVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugClass_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugClass_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugClass_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugClass_GetModule(This,pModule)	\
    (This)->lpVtbl -> GetModule(This,pModule)

#define ICorDebugClass_GetToken(This,pTypeDef)	\
    (This)->lpVtbl -> GetToken(This,pTypeDef)

#define ICorDebugClass_GetStaticFieldValue(This,fieldDef,pFrame,ppValue)	\
    (This)->lpVtbl -> GetStaticFieldValue(This,fieldDef,pFrame,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugClass_GetModule_Proxy( 
    ICorDebugClass * This,
    /* [out] */ ICorDebugModule **pModule);


void __RPC_STUB ICorDebugClass_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugClass_GetToken_Proxy( 
    ICorDebugClass * This,
    /* [out] */ mdTypeDef *pTypeDef);


void __RPC_STUB ICorDebugClass_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugClass_GetStaticFieldValue_Proxy( 
    ICorDebugClass * This,
    /* [in] */ mdFieldDef fieldDef,
    /* [in] */ ICorDebugFrame *pFrame,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugClass_GetStaticFieldValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugClass_INTERFACE_DEFINED__ */


#ifndef __ICorDebugClass2_INTERFACE_DEFINED__
#define __ICorDebugClass2_INTERFACE_DEFINED__

/* interface ICorDebugClass2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugClass2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B008EA8D-7AB1-43f7-BB20-FBB5A04038AE")
    ICorDebugClass2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetParameterizedType( 
            /* [in] */ CorElementType elementType,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [out] */ ICorDebugType **ppType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetJMCStatus( 
            /* [in] */ BOOL bIsJustMyCode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugClass2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugClass2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugClass2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugClass2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameterizedType )( 
            ICorDebugClass2 * This,
            /* [in] */ CorElementType elementType,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [out] */ ICorDebugType **ppType);
        
        HRESULT ( STDMETHODCALLTYPE *SetJMCStatus )( 
            ICorDebugClass2 * This,
            /* [in] */ BOOL bIsJustMyCode);
        
        END_INTERFACE
    } ICorDebugClass2Vtbl;

    interface ICorDebugClass2
    {
        CONST_VTBL struct ICorDebugClass2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugClass2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugClass2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugClass2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugClass2_GetParameterizedType(This,elementType,nTypeArgs,ppTypeArgs,ppType)	\
    (This)->lpVtbl -> GetParameterizedType(This,elementType,nTypeArgs,ppTypeArgs,ppType)

#define ICorDebugClass2_SetJMCStatus(This,bIsJustMyCode)	\
    (This)->lpVtbl -> SetJMCStatus(This,bIsJustMyCode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugClass2_GetParameterizedType_Proxy( 
    ICorDebugClass2 * This,
    /* [in] */ CorElementType elementType,
    /* [in] */ ULONG32 nTypeArgs,
    /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
    /* [out] */ ICorDebugType **ppType);


void __RPC_STUB ICorDebugClass2_GetParameterizedType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugClass2_SetJMCStatus_Proxy( 
    ICorDebugClass2 * This,
    /* [in] */ BOOL bIsJustMyCode);


void __RPC_STUB ICorDebugClass2_SetJMCStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugClass2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEval_INTERFACE_DEFINED__
#define __ICorDebugEval_INTERFACE_DEFINED__

/* interface ICorDebugEval */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEval;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF6-8A68-11d2-983C-0000F808342D")
    ICorDebugEval : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallFunction( 
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewObject( 
            /* [in] */ ICorDebugFunction *pConstructor,
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewObjectNoConstructor( 
            /* [in] */ ICorDebugClass *pClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewString( 
            /* [in] */ LPCWSTR string) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewArray( 
            /* [in] */ CorElementType elementType,
            /* [in] */ ICorDebugClass *pElementClass,
            /* [in] */ ULONG32 rank,
            /* [size_is][in] */ ULONG32 dims[  ],
            /* [size_is][in] */ ULONG32 lowBounds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsActive( 
            /* [out] */ BOOL *pbActive) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetResult( 
            /* [out] */ ICorDebugValue **ppResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThread( 
            /* [out] */ ICorDebugThread **ppThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateValue( 
            /* [in] */ CorElementType elementType,
            /* [in] */ ICorDebugClass *pElementClass,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEvalVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEval * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEval * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEval * This);
        
        HRESULT ( STDMETHODCALLTYPE *CallFunction )( 
            ICorDebugEval * This,
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NewObject )( 
            ICorDebugEval * This,
            /* [in] */ ICorDebugFunction *pConstructor,
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NewObjectNoConstructor )( 
            ICorDebugEval * This,
            /* [in] */ ICorDebugClass *pClass);
        
        HRESULT ( STDMETHODCALLTYPE *NewString )( 
            ICorDebugEval * This,
            /* [in] */ LPCWSTR string);
        
        HRESULT ( STDMETHODCALLTYPE *NewArray )( 
            ICorDebugEval * This,
            /* [in] */ CorElementType elementType,
            /* [in] */ ICorDebugClass *pElementClass,
            /* [in] */ ULONG32 rank,
            /* [size_is][in] */ ULONG32 dims[  ],
            /* [size_is][in] */ ULONG32 lowBounds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *IsActive )( 
            ICorDebugEval * This,
            /* [out] */ BOOL *pbActive);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ICorDebugEval * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetResult )( 
            ICorDebugEval * This,
            /* [out] */ ICorDebugValue **ppResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetThread )( 
            ICorDebugEval * This,
            /* [out] */ ICorDebugThread **ppThread);
        
        HRESULT ( STDMETHODCALLTYPE *CreateValue )( 
            ICorDebugEval * This,
            /* [in] */ CorElementType elementType,
            /* [in] */ ICorDebugClass *pElementClass,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugEvalVtbl;

    interface ICorDebugEval
    {
        CONST_VTBL struct ICorDebugEvalVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEval_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEval_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEval_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEval_CallFunction(This,pFunction,nArgs,ppArgs)	\
    (This)->lpVtbl -> CallFunction(This,pFunction,nArgs,ppArgs)

#define ICorDebugEval_NewObject(This,pConstructor,nArgs,ppArgs)	\
    (This)->lpVtbl -> NewObject(This,pConstructor,nArgs,ppArgs)

#define ICorDebugEval_NewObjectNoConstructor(This,pClass)	\
    (This)->lpVtbl -> NewObjectNoConstructor(This,pClass)

#define ICorDebugEval_NewString(This,string)	\
    (This)->lpVtbl -> NewString(This,string)

#define ICorDebugEval_NewArray(This,elementType,pElementClass,rank,dims,lowBounds)	\
    (This)->lpVtbl -> NewArray(This,elementType,pElementClass,rank,dims,lowBounds)

#define ICorDebugEval_IsActive(This,pbActive)	\
    (This)->lpVtbl -> IsActive(This,pbActive)

#define ICorDebugEval_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define ICorDebugEval_GetResult(This,ppResult)	\
    (This)->lpVtbl -> GetResult(This,ppResult)

#define ICorDebugEval_GetThread(This,ppThread)	\
    (This)->lpVtbl -> GetThread(This,ppThread)

#define ICorDebugEval_CreateValue(This,elementType,pElementClass,ppValue)	\
    (This)->lpVtbl -> CreateValue(This,elementType,pElementClass,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEval_CallFunction_Proxy( 
    ICorDebugEval * This,
    /* [in] */ ICorDebugFunction *pFunction,
    /* [in] */ ULONG32 nArgs,
    /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);


void __RPC_STUB ICorDebugEval_CallFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_NewObject_Proxy( 
    ICorDebugEval * This,
    /* [in] */ ICorDebugFunction *pConstructor,
    /* [in] */ ULONG32 nArgs,
    /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);


void __RPC_STUB ICorDebugEval_NewObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_NewObjectNoConstructor_Proxy( 
    ICorDebugEval * This,
    /* [in] */ ICorDebugClass *pClass);


void __RPC_STUB ICorDebugEval_NewObjectNoConstructor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_NewString_Proxy( 
    ICorDebugEval * This,
    /* [in] */ LPCWSTR string);


void __RPC_STUB ICorDebugEval_NewString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_NewArray_Proxy( 
    ICorDebugEval * This,
    /* [in] */ CorElementType elementType,
    /* [in] */ ICorDebugClass *pElementClass,
    /* [in] */ ULONG32 rank,
    /* [size_is][in] */ ULONG32 dims[  ],
    /* [size_is][in] */ ULONG32 lowBounds[  ]);


void __RPC_STUB ICorDebugEval_NewArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_IsActive_Proxy( 
    ICorDebugEval * This,
    /* [out] */ BOOL *pbActive);


void __RPC_STUB ICorDebugEval_IsActive_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_Abort_Proxy( 
    ICorDebugEval * This);


void __RPC_STUB ICorDebugEval_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_GetResult_Proxy( 
    ICorDebugEval * This,
    /* [out] */ ICorDebugValue **ppResult);


void __RPC_STUB ICorDebugEval_GetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_GetThread_Proxy( 
    ICorDebugEval * This,
    /* [out] */ ICorDebugThread **ppThread);


void __RPC_STUB ICorDebugEval_GetThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval_CreateValue_Proxy( 
    ICorDebugEval * This,
    /* [in] */ CorElementType elementType,
    /* [in] */ ICorDebugClass *pElementClass,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugEval_CreateValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEval_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEval2_INTERFACE_DEFINED__
#define __ICorDebugEval2_INTERFACE_DEFINED__

/* interface ICorDebugEval2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEval2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FB0D9CE7-BE66-4683-9D32-A42A04E2FD91")
    ICorDebugEval2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CallParameterizedFunction( 
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateValueForType( 
            /* [in] */ ICorDebugType *pType,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewParameterizedObject( 
            /* [in] */ ICorDebugFunction *pConstructor,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewParameterizedObjectNoConstructor( 
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewParameterizedArray( 
            /* [in] */ ICorDebugType *pElementType,
            /* [in] */ ULONG32 rank,
            /* [size_is][in] */ ULONG32 dims[  ],
            /* [size_is][in] */ ULONG32 lowBounds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NewStringWithLength( 
            /* [in] */ LPCWSTR string,
            /* [in] */ UINT uiLength) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RudeAbort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEval2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEval2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEval2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEval2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CallParameterizedFunction )( 
            ICorDebugEval2 * This,
            /* [in] */ ICorDebugFunction *pFunction,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *CreateValueForType )( 
            ICorDebugEval2 * This,
            /* [in] */ ICorDebugType *pType,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *NewParameterizedObject )( 
            ICorDebugEval2 * This,
            /* [in] */ ICorDebugFunction *pConstructor,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
            /* [in] */ ULONG32 nArgs,
            /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NewParameterizedObjectNoConstructor )( 
            ICorDebugEval2 * This,
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ ULONG32 nTypeArgs,
            /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NewParameterizedArray )( 
            ICorDebugEval2 * This,
            /* [in] */ ICorDebugType *pElementType,
            /* [in] */ ULONG32 rank,
            /* [size_is][in] */ ULONG32 dims[  ],
            /* [size_is][in] */ ULONG32 lowBounds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *NewStringWithLength )( 
            ICorDebugEval2 * This,
            /* [in] */ LPCWSTR string,
            /* [in] */ UINT uiLength);
        
        HRESULT ( STDMETHODCALLTYPE *RudeAbort )( 
            ICorDebugEval2 * This);
        
        END_INTERFACE
    } ICorDebugEval2Vtbl;

    interface ICorDebugEval2
    {
        CONST_VTBL struct ICorDebugEval2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEval2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEval2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEval2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEval2_CallParameterizedFunction(This,pFunction,nTypeArgs,ppTypeArgs,nArgs,ppArgs)	\
    (This)->lpVtbl -> CallParameterizedFunction(This,pFunction,nTypeArgs,ppTypeArgs,nArgs,ppArgs)

#define ICorDebugEval2_CreateValueForType(This,pType,ppValue)	\
    (This)->lpVtbl -> CreateValueForType(This,pType,ppValue)

#define ICorDebugEval2_NewParameterizedObject(This,pConstructor,nTypeArgs,ppTypeArgs,nArgs,ppArgs)	\
    (This)->lpVtbl -> NewParameterizedObject(This,pConstructor,nTypeArgs,ppTypeArgs,nArgs,ppArgs)

#define ICorDebugEval2_NewParameterizedObjectNoConstructor(This,pClass,nTypeArgs,ppTypeArgs)	\
    (This)->lpVtbl -> NewParameterizedObjectNoConstructor(This,pClass,nTypeArgs,ppTypeArgs)

#define ICorDebugEval2_NewParameterizedArray(This,pElementType,rank,dims,lowBounds)	\
    (This)->lpVtbl -> NewParameterizedArray(This,pElementType,rank,dims,lowBounds)

#define ICorDebugEval2_NewStringWithLength(This,string,uiLength)	\
    (This)->lpVtbl -> NewStringWithLength(This,string,uiLength)

#define ICorDebugEval2_RudeAbort(This)	\
    (This)->lpVtbl -> RudeAbort(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEval2_CallParameterizedFunction_Proxy( 
    ICorDebugEval2 * This,
    /* [in] */ ICorDebugFunction *pFunction,
    /* [in] */ ULONG32 nTypeArgs,
    /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
    /* [in] */ ULONG32 nArgs,
    /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);


void __RPC_STUB ICorDebugEval2_CallParameterizedFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval2_CreateValueForType_Proxy( 
    ICorDebugEval2 * This,
    /* [in] */ ICorDebugType *pType,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugEval2_CreateValueForType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval2_NewParameterizedObject_Proxy( 
    ICorDebugEval2 * This,
    /* [in] */ ICorDebugFunction *pConstructor,
    /* [in] */ ULONG32 nTypeArgs,
    /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ],
    /* [in] */ ULONG32 nArgs,
    /* [size_is][in] */ ICorDebugValue *ppArgs[  ]);


void __RPC_STUB ICorDebugEval2_NewParameterizedObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval2_NewParameterizedObjectNoConstructor_Proxy( 
    ICorDebugEval2 * This,
    /* [in] */ ICorDebugClass *pClass,
    /* [in] */ ULONG32 nTypeArgs,
    /* [size_is][in] */ ICorDebugType *ppTypeArgs[  ]);


void __RPC_STUB ICorDebugEval2_NewParameterizedObjectNoConstructor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval2_NewParameterizedArray_Proxy( 
    ICorDebugEval2 * This,
    /* [in] */ ICorDebugType *pElementType,
    /* [in] */ ULONG32 rank,
    /* [size_is][in] */ ULONG32 dims[  ],
    /* [size_is][in] */ ULONG32 lowBounds[  ]);


void __RPC_STUB ICorDebugEval2_NewParameterizedArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval2_NewStringWithLength_Proxy( 
    ICorDebugEval2 * This,
    /* [in] */ LPCWSTR string,
    /* [in] */ UINT uiLength);


void __RPC_STUB ICorDebugEval2_NewStringWithLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEval2_RudeAbort_Proxy( 
    ICorDebugEval2 * This);


void __RPC_STUB ICorDebugEval2_RudeAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEval2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugValue_INTERFACE_DEFINED__
#define __ICorDebugValue_INTERFACE_DEFINED__

/* interface ICorDebugValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF7-8A68-11d2-983C-0000F808342D")
    ICorDebugValue : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ CorElementType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSize( 
            /* [out] */ ULONG32 *pSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddress( 
            /* [out] */ CORDB_ADDRESS *pAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateBreakpoint( 
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        END_INTERFACE
    } ICorDebugValueVtbl;

    interface ICorDebugValue
    {
        CONST_VTBL struct ICorDebugValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugValue_GetType_Proxy( 
    ICorDebugValue * This,
    /* [out] */ CorElementType *pType);


void __RPC_STUB ICorDebugValue_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugValue_GetSize_Proxy( 
    ICorDebugValue * This,
    /* [out] */ ULONG32 *pSize);


void __RPC_STUB ICorDebugValue_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugValue_GetAddress_Proxy( 
    ICorDebugValue * This,
    /* [out] */ CORDB_ADDRESS *pAddress);


void __RPC_STUB ICorDebugValue_GetAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugValue_CreateBreakpoint_Proxy( 
    ICorDebugValue * This,
    /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugValue_CreateBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugValue2_INTERFACE_DEFINED__
#define __ICorDebugValue2_INTERFACE_DEFINED__

/* interface ICorDebugValue2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugValue2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5E0B54E7-D88A-4626-9420-A691E0A78B49")
    ICorDebugValue2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExactType( 
            /* [out] */ ICorDebugType **ppType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugValue2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugValue2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugValue2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugValue2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetExactType )( 
            ICorDebugValue2 * This,
            /* [out] */ ICorDebugType **ppType);
        
        END_INTERFACE
    } ICorDebugValue2Vtbl;

    interface ICorDebugValue2
    {
        CONST_VTBL struct ICorDebugValue2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugValue2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugValue2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugValue2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugValue2_GetExactType(This,ppType)	\
    (This)->lpVtbl -> GetExactType(This,ppType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugValue2_GetExactType_Proxy( 
    ICorDebugValue2 * This,
    /* [out] */ ICorDebugType **ppType);


void __RPC_STUB ICorDebugValue2_GetExactType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugValue2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugGenericValue_INTERFACE_DEFINED__
#define __ICorDebugGenericValue_INTERFACE_DEFINED__

/* interface ICorDebugGenericValue */
/* [unique][uuid][local][object] */ 


EXTERN_C const IID IID_ICorDebugGenericValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF8-8A68-11d2-983C-0000F808342D")
    ICorDebugGenericValue : public ICorDebugValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ void *pTo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ void *pFrom) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugGenericValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugGenericValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugGenericValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugGenericValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugGenericValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugGenericValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugGenericValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugGenericValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICorDebugGenericValue * This,
            /* [out] */ void *pTo);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ICorDebugGenericValue * This,
            /* [in] */ void *pFrom);
        
        END_INTERFACE
    } ICorDebugGenericValueVtbl;

    interface ICorDebugGenericValue
    {
        CONST_VTBL struct ICorDebugGenericValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugGenericValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugGenericValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugGenericValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugGenericValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugGenericValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugGenericValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugGenericValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugGenericValue_GetValue(This,pTo)	\
    (This)->lpVtbl -> GetValue(This,pTo)

#define ICorDebugGenericValue_SetValue(This,pFrom)	\
    (This)->lpVtbl -> SetValue(This,pFrom)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugGenericValue_GetValue_Proxy( 
    ICorDebugGenericValue * This,
    /* [out] */ void *pTo);


void __RPC_STUB ICorDebugGenericValue_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugGenericValue_SetValue_Proxy( 
    ICorDebugGenericValue * This,
    /* [in] */ void *pFrom);


void __RPC_STUB ICorDebugGenericValue_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugGenericValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugReferenceValue_INTERFACE_DEFINED__
#define __ICorDebugReferenceValue_INTERFACE_DEFINED__

/* interface ICorDebugReferenceValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugReferenceValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAF9-8A68-11d2-983C-0000F808342D")
    ICorDebugReferenceValue : public ICorDebugValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsNull( 
            /* [out] */ BOOL *pbNull) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [out] */ CORDB_ADDRESS *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [in] */ CORDB_ADDRESS value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Dereference( 
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DereferenceStrong( 
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugReferenceValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugReferenceValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugReferenceValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugReferenceValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugReferenceValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugReferenceValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugReferenceValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugReferenceValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsNull )( 
            ICorDebugReferenceValue * This,
            /* [out] */ BOOL *pbNull);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICorDebugReferenceValue * This,
            /* [out] */ CORDB_ADDRESS *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ICorDebugReferenceValue * This,
            /* [in] */ CORDB_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *Dereference )( 
            ICorDebugReferenceValue * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *DereferenceStrong )( 
            ICorDebugReferenceValue * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugReferenceValueVtbl;

    interface ICorDebugReferenceValue
    {
        CONST_VTBL struct ICorDebugReferenceValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugReferenceValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugReferenceValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugReferenceValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugReferenceValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugReferenceValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugReferenceValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugReferenceValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugReferenceValue_IsNull(This,pbNull)	\
    (This)->lpVtbl -> IsNull(This,pbNull)

#define ICorDebugReferenceValue_GetValue(This,pValue)	\
    (This)->lpVtbl -> GetValue(This,pValue)

#define ICorDebugReferenceValue_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#define ICorDebugReferenceValue_Dereference(This,ppValue)	\
    (This)->lpVtbl -> Dereference(This,ppValue)

#define ICorDebugReferenceValue_DereferenceStrong(This,ppValue)	\
    (This)->lpVtbl -> DereferenceStrong(This,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_IsNull_Proxy( 
    ICorDebugReferenceValue * This,
    /* [out] */ BOOL *pbNull);


void __RPC_STUB ICorDebugReferenceValue_IsNull_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_GetValue_Proxy( 
    ICorDebugReferenceValue * This,
    /* [out] */ CORDB_ADDRESS *pValue);


void __RPC_STUB ICorDebugReferenceValue_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_SetValue_Proxy( 
    ICorDebugReferenceValue * This,
    /* [in] */ CORDB_ADDRESS value);


void __RPC_STUB ICorDebugReferenceValue_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_Dereference_Proxy( 
    ICorDebugReferenceValue * This,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugReferenceValue_Dereference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugReferenceValue_DereferenceStrong_Proxy( 
    ICorDebugReferenceValue * This,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugReferenceValue_DereferenceStrong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugReferenceValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugHeapValue_INTERFACE_DEFINED__
#define __ICorDebugHeapValue_INTERFACE_DEFINED__

/* interface ICorDebugHeapValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugHeapValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAFA-8A68-11d2-983C-0000F808342D")
    ICorDebugHeapValue : public ICorDebugValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsValid( 
            /* [out] */ BOOL *pbValid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRelocBreakpoint( 
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugHeapValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugHeapValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugHeapValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugHeapValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugHeapValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugHeapValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugHeapValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugHeapValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICorDebugHeapValue * This,
            /* [out] */ BOOL *pbValid);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRelocBreakpoint )( 
            ICorDebugHeapValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        END_INTERFACE
    } ICorDebugHeapValueVtbl;

    interface ICorDebugHeapValue
    {
        CONST_VTBL struct ICorDebugHeapValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugHeapValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugHeapValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugHeapValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugHeapValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugHeapValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugHeapValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugHeapValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugHeapValue_IsValid(This,pbValid)	\
    (This)->lpVtbl -> IsValid(This,pbValid)

#define ICorDebugHeapValue_CreateRelocBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateRelocBreakpoint(This,ppBreakpoint)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugHeapValue_IsValid_Proxy( 
    ICorDebugHeapValue * This,
    /* [out] */ BOOL *pbValid);


void __RPC_STUB ICorDebugHeapValue_IsValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugHeapValue_CreateRelocBreakpoint_Proxy( 
    ICorDebugHeapValue * This,
    /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);


void __RPC_STUB ICorDebugHeapValue_CreateRelocBreakpoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugHeapValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugHeapValue2_INTERFACE_DEFINED__
#define __ICorDebugHeapValue2_INTERFACE_DEFINED__

/* interface ICorDebugHeapValue2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugHeapValue2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E3AC4D6C-9CB7-43e6-96CC-B21540E5083C")
    ICorDebugHeapValue2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateHandle( 
            /* [in] */ CorDebugHandleType type,
            /* [out] */ ICorDebugHandleValue **ppHandle) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugHeapValue2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugHeapValue2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugHeapValue2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugHeapValue2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateHandle )( 
            ICorDebugHeapValue2 * This,
            /* [in] */ CorDebugHandleType type,
            /* [out] */ ICorDebugHandleValue **ppHandle);
        
        END_INTERFACE
    } ICorDebugHeapValue2Vtbl;

    interface ICorDebugHeapValue2
    {
        CONST_VTBL struct ICorDebugHeapValue2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugHeapValue2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugHeapValue2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugHeapValue2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugHeapValue2_CreateHandle(This,type,ppHandle)	\
    (This)->lpVtbl -> CreateHandle(This,type,ppHandle)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugHeapValue2_CreateHandle_Proxy( 
    ICorDebugHeapValue2 * This,
    /* [in] */ CorDebugHandleType type,
    /* [out] */ ICorDebugHandleValue **ppHandle);


void __RPC_STUB ICorDebugHeapValue2_CreateHandle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugHeapValue2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugObjectValue_INTERFACE_DEFINED__
#define __ICorDebugObjectValue_INTERFACE_DEFINED__

/* interface ICorDebugObjectValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugObjectValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18AD3D6E-B7D2-11d2-BD04-0000F80849BD")
    ICorDebugObjectValue : public ICorDebugValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClass( 
            /* [out] */ ICorDebugClass **ppClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFieldValue( 
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualMethod( 
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [out] */ ICorDebugContext **ppContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsValueClass( 
            /* [out] */ BOOL *pbIsValueClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetManagedCopy( 
            /* [out] */ IUnknown **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFromManagedCopy( 
            /* [in] */ IUnknown *pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugObjectValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugObjectValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugObjectValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugObjectValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugObjectValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugObjectValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugObjectValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugObjectValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetClass )( 
            ICorDebugObjectValue * This,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetFieldValue )( 
            ICorDebugObjectValue * This,
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualMethod )( 
            ICorDebugObjectValue * This,
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ICorDebugObjectValue * This,
            /* [out] */ ICorDebugContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueClass )( 
            ICorDebugObjectValue * This,
            /* [out] */ BOOL *pbIsValueClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetManagedCopy )( 
            ICorDebugObjectValue * This,
            /* [out] */ IUnknown **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetFromManagedCopy )( 
            ICorDebugObjectValue * This,
            /* [in] */ IUnknown *pObject);
        
        END_INTERFACE
    } ICorDebugObjectValueVtbl;

    interface ICorDebugObjectValue
    {
        CONST_VTBL struct ICorDebugObjectValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugObjectValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugObjectValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugObjectValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugObjectValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugObjectValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugObjectValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugObjectValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugObjectValue_GetClass(This,ppClass)	\
    (This)->lpVtbl -> GetClass(This,ppClass)

#define ICorDebugObjectValue_GetFieldValue(This,pClass,fieldDef,ppValue)	\
    (This)->lpVtbl -> GetFieldValue(This,pClass,fieldDef,ppValue)

#define ICorDebugObjectValue_GetVirtualMethod(This,memberRef,ppFunction)	\
    (This)->lpVtbl -> GetVirtualMethod(This,memberRef,ppFunction)

#define ICorDebugObjectValue_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#define ICorDebugObjectValue_IsValueClass(This,pbIsValueClass)	\
    (This)->lpVtbl -> IsValueClass(This,pbIsValueClass)

#define ICorDebugObjectValue_GetManagedCopy(This,ppObject)	\
    (This)->lpVtbl -> GetManagedCopy(This,ppObject)

#define ICorDebugObjectValue_SetFromManagedCopy(This,pObject)	\
    (This)->lpVtbl -> SetFromManagedCopy(This,pObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetClass_Proxy( 
    ICorDebugObjectValue * This,
    /* [out] */ ICorDebugClass **ppClass);


void __RPC_STUB ICorDebugObjectValue_GetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetFieldValue_Proxy( 
    ICorDebugObjectValue * This,
    /* [in] */ ICorDebugClass *pClass,
    /* [in] */ mdFieldDef fieldDef,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugObjectValue_GetFieldValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetVirtualMethod_Proxy( 
    ICorDebugObjectValue * This,
    /* [in] */ mdMemberRef memberRef,
    /* [out] */ ICorDebugFunction **ppFunction);


void __RPC_STUB ICorDebugObjectValue_GetVirtualMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetContext_Proxy( 
    ICorDebugObjectValue * This,
    /* [out] */ ICorDebugContext **ppContext);


void __RPC_STUB ICorDebugObjectValue_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_IsValueClass_Proxy( 
    ICorDebugObjectValue * This,
    /* [out] */ BOOL *pbIsValueClass);


void __RPC_STUB ICorDebugObjectValue_IsValueClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_GetManagedCopy_Proxy( 
    ICorDebugObjectValue * This,
    /* [out] */ IUnknown **ppObject);


void __RPC_STUB ICorDebugObjectValue_GetManagedCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugObjectValue_SetFromManagedCopy_Proxy( 
    ICorDebugObjectValue * This,
    /* [in] */ IUnknown *pObject);


void __RPC_STUB ICorDebugObjectValue_SetFromManagedCopy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugObjectValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugObjectValue2_INTERFACE_DEFINED__
#define __ICorDebugObjectValue2_INTERFACE_DEFINED__

/* interface ICorDebugObjectValue2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugObjectValue2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("49E4A320-4A9B-4eca-B105-229FB7D5009F")
    ICorDebugObjectValue2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVirtualMethodAndType( 
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction,
            /* [out] */ ICorDebugType **ppType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugObjectValue2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugObjectValue2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugObjectValue2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugObjectValue2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualMethodAndType )( 
            ICorDebugObjectValue2 * This,
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction,
            /* [out] */ ICorDebugType **ppType);
        
        END_INTERFACE
    } ICorDebugObjectValue2Vtbl;

    interface ICorDebugObjectValue2
    {
        CONST_VTBL struct ICorDebugObjectValue2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugObjectValue2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugObjectValue2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugObjectValue2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugObjectValue2_GetVirtualMethodAndType(This,memberRef,ppFunction,ppType)	\
    (This)->lpVtbl -> GetVirtualMethodAndType(This,memberRef,ppFunction,ppType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugObjectValue2_GetVirtualMethodAndType_Proxy( 
    ICorDebugObjectValue2 * This,
    /* [in] */ mdMemberRef memberRef,
    /* [out] */ ICorDebugFunction **ppFunction,
    /* [out] */ ICorDebugType **ppType);


void __RPC_STUB ICorDebugObjectValue2_GetVirtualMethodAndType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugObjectValue2_INTERFACE_DEFINED__ */


#ifndef __ICorDebugBoxValue_INTERFACE_DEFINED__
#define __ICorDebugBoxValue_INTERFACE_DEFINED__

/* interface ICorDebugBoxValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugBoxValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAFC-8A68-11d2-983C-0000F808342D")
    ICorDebugBoxValue : public ICorDebugHeapValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [out] */ ICorDebugObjectValue **ppObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugBoxValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugBoxValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugBoxValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugBoxValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugBoxValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugBoxValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugBoxValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugBoxValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICorDebugBoxValue * This,
            /* [out] */ BOOL *pbValid);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRelocBreakpoint )( 
            ICorDebugBoxValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetObject )( 
            ICorDebugBoxValue * This,
            /* [out] */ ICorDebugObjectValue **ppObject);
        
        END_INTERFACE
    } ICorDebugBoxValueVtbl;

    interface ICorDebugBoxValue
    {
        CONST_VTBL struct ICorDebugBoxValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugBoxValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugBoxValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugBoxValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugBoxValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugBoxValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugBoxValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugBoxValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugBoxValue_IsValid(This,pbValid)	\
    (This)->lpVtbl -> IsValid(This,pbValid)

#define ICorDebugBoxValue_CreateRelocBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateRelocBreakpoint(This,ppBreakpoint)


#define ICorDebugBoxValue_GetObject(This,ppObject)	\
    (This)->lpVtbl -> GetObject(This,ppObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugBoxValue_GetObject_Proxy( 
    ICorDebugBoxValue * This,
    /* [out] */ ICorDebugObjectValue **ppObject);


void __RPC_STUB ICorDebugBoxValue_GetObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugBoxValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugStringValue_INTERFACE_DEFINED__
#define __ICorDebugStringValue_INTERFACE_DEFINED__

/* interface ICorDebugStringValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugStringValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCAFD-8A68-11d2-983C-0000F808342D")
    ICorDebugStringValue : public ICorDebugHeapValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLength( 
            /* [out] */ ULONG32 *pcchString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ ULONG32 cchString,
            /* [out] */ ULONG32 *pcchString,
            /* [length_is][size_is][out] */ WCHAR szString[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugStringValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugStringValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugStringValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugStringValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugStringValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugStringValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugStringValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugStringValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICorDebugStringValue * This,
            /* [out] */ BOOL *pbValid);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRelocBreakpoint )( 
            ICorDebugStringValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetLength )( 
            ICorDebugStringValue * This,
            /* [out] */ ULONG32 *pcchString);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            ICorDebugStringValue * This,
            /* [in] */ ULONG32 cchString,
            /* [out] */ ULONG32 *pcchString,
            /* [length_is][size_is][out] */ WCHAR szString[  ]);
        
        END_INTERFACE
    } ICorDebugStringValueVtbl;

    interface ICorDebugStringValue
    {
        CONST_VTBL struct ICorDebugStringValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugStringValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugStringValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugStringValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugStringValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugStringValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugStringValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugStringValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugStringValue_IsValid(This,pbValid)	\
    (This)->lpVtbl -> IsValid(This,pbValid)

#define ICorDebugStringValue_CreateRelocBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateRelocBreakpoint(This,ppBreakpoint)


#define ICorDebugStringValue_GetLength(This,pcchString)	\
    (This)->lpVtbl -> GetLength(This,pcchString)

#define ICorDebugStringValue_GetString(This,cchString,pcchString,szString)	\
    (This)->lpVtbl -> GetString(This,cchString,pcchString,szString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugStringValue_GetLength_Proxy( 
    ICorDebugStringValue * This,
    /* [out] */ ULONG32 *pcchString);


void __RPC_STUB ICorDebugStringValue_GetLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugStringValue_GetString_Proxy( 
    ICorDebugStringValue * This,
    /* [in] */ ULONG32 cchString,
    /* [out] */ ULONG32 *pcchString,
    /* [length_is][size_is][out] */ WCHAR szString[  ]);


void __RPC_STUB ICorDebugStringValue_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugStringValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugArrayValue_INTERFACE_DEFINED__
#define __ICorDebugArrayValue_INTERFACE_DEFINED__

/* interface ICorDebugArrayValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugArrayValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0405B0DF-A660-11d2-BD02-0000F80849BD")
    ICorDebugArrayValue : public ICorDebugHeapValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetElementType( 
            /* [out] */ CorElementType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRank( 
            /* [out] */ ULONG32 *pnRank) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG32 *pnCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDimensions( 
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][out] */ ULONG32 dims[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasBaseIndicies( 
            /* [out] */ BOOL *pbHasBaseIndicies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBaseIndicies( 
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][out] */ ULONG32 indicies[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElement( 
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][in] */ ULONG32 indices[  ],
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetElementAtPosition( 
            /* [in] */ ULONG32 nPosition,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugArrayValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugArrayValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugArrayValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugArrayValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugArrayValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugArrayValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugArrayValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugArrayValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsValid )( 
            ICorDebugArrayValue * This,
            /* [out] */ BOOL *pbValid);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRelocBreakpoint )( 
            ICorDebugArrayValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetElementType )( 
            ICorDebugArrayValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetRank )( 
            ICorDebugArrayValue * This,
            /* [out] */ ULONG32 *pnRank);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugArrayValue * This,
            /* [out] */ ULONG32 *pnCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetDimensions )( 
            ICorDebugArrayValue * This,
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][out] */ ULONG32 dims[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *HasBaseIndicies )( 
            ICorDebugArrayValue * This,
            /* [out] */ BOOL *pbHasBaseIndicies);
        
        HRESULT ( STDMETHODCALLTYPE *GetBaseIndicies )( 
            ICorDebugArrayValue * This,
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][out] */ ULONG32 indicies[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetElement )( 
            ICorDebugArrayValue * This,
            /* [in] */ ULONG32 cdim,
            /* [length_is][size_is][in] */ ULONG32 indices[  ],
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetElementAtPosition )( 
            ICorDebugArrayValue * This,
            /* [in] */ ULONG32 nPosition,
            /* [out] */ ICorDebugValue **ppValue);
        
        END_INTERFACE
    } ICorDebugArrayValueVtbl;

    interface ICorDebugArrayValue
    {
        CONST_VTBL struct ICorDebugArrayValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugArrayValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugArrayValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugArrayValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugArrayValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugArrayValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugArrayValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugArrayValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugArrayValue_IsValid(This,pbValid)	\
    (This)->lpVtbl -> IsValid(This,pbValid)

#define ICorDebugArrayValue_CreateRelocBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateRelocBreakpoint(This,ppBreakpoint)


#define ICorDebugArrayValue_GetElementType(This,pType)	\
    (This)->lpVtbl -> GetElementType(This,pType)

#define ICorDebugArrayValue_GetRank(This,pnRank)	\
    (This)->lpVtbl -> GetRank(This,pnRank)

#define ICorDebugArrayValue_GetCount(This,pnCount)	\
    (This)->lpVtbl -> GetCount(This,pnCount)

#define ICorDebugArrayValue_GetDimensions(This,cdim,dims)	\
    (This)->lpVtbl -> GetDimensions(This,cdim,dims)

#define ICorDebugArrayValue_HasBaseIndicies(This,pbHasBaseIndicies)	\
    (This)->lpVtbl -> HasBaseIndicies(This,pbHasBaseIndicies)

#define ICorDebugArrayValue_GetBaseIndicies(This,cdim,indicies)	\
    (This)->lpVtbl -> GetBaseIndicies(This,cdim,indicies)

#define ICorDebugArrayValue_GetElement(This,cdim,indices,ppValue)	\
    (This)->lpVtbl -> GetElement(This,cdim,indices,ppValue)

#define ICorDebugArrayValue_GetElementAtPosition(This,nPosition,ppValue)	\
    (This)->lpVtbl -> GetElementAtPosition(This,nPosition,ppValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetElementType_Proxy( 
    ICorDebugArrayValue * This,
    /* [out] */ CorElementType *pType);


void __RPC_STUB ICorDebugArrayValue_GetElementType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetRank_Proxy( 
    ICorDebugArrayValue * This,
    /* [out] */ ULONG32 *pnRank);


void __RPC_STUB ICorDebugArrayValue_GetRank_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetCount_Proxy( 
    ICorDebugArrayValue * This,
    /* [out] */ ULONG32 *pnCount);


void __RPC_STUB ICorDebugArrayValue_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetDimensions_Proxy( 
    ICorDebugArrayValue * This,
    /* [in] */ ULONG32 cdim,
    /* [length_is][size_is][out] */ ULONG32 dims[  ]);


void __RPC_STUB ICorDebugArrayValue_GetDimensions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_HasBaseIndicies_Proxy( 
    ICorDebugArrayValue * This,
    /* [out] */ BOOL *pbHasBaseIndicies);


void __RPC_STUB ICorDebugArrayValue_HasBaseIndicies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetBaseIndicies_Proxy( 
    ICorDebugArrayValue * This,
    /* [in] */ ULONG32 cdim,
    /* [length_is][size_is][out] */ ULONG32 indicies[  ]);


void __RPC_STUB ICorDebugArrayValue_GetBaseIndicies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetElement_Proxy( 
    ICorDebugArrayValue * This,
    /* [in] */ ULONG32 cdim,
    /* [length_is][size_is][in] */ ULONG32 indices[  ],
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugArrayValue_GetElement_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugArrayValue_GetElementAtPosition_Proxy( 
    ICorDebugArrayValue * This,
    /* [in] */ ULONG32 nPosition,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugArrayValue_GetElementAtPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugArrayValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugHandleValue_INTERFACE_DEFINED__
#define __ICorDebugHandleValue_INTERFACE_DEFINED__

/* interface ICorDebugHandleValue */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugHandleValue;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("029596E8-276B-46a1-9821-732E96BBB00B")
    ICorDebugHandleValue : public ICorDebugReferenceValue
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHandleType( 
            /* [out] */ CorDebugHandleType *pType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Dispose( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugHandleValueVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugHandleValue * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugHandleValue * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugHandleValue * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugHandleValue * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugHandleValue * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugHandleValue * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugHandleValue * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *IsNull )( 
            ICorDebugHandleValue * This,
            /* [out] */ BOOL *pbNull);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ICorDebugHandleValue * This,
            /* [out] */ CORDB_ADDRESS *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ICorDebugHandleValue * This,
            /* [in] */ CORDB_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *Dereference )( 
            ICorDebugHandleValue * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *DereferenceStrong )( 
            ICorDebugHandleValue * This,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandleType )( 
            ICorDebugHandleValue * This,
            /* [out] */ CorDebugHandleType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *Dispose )( 
            ICorDebugHandleValue * This);
        
        END_INTERFACE
    } ICorDebugHandleValueVtbl;

    interface ICorDebugHandleValue
    {
        CONST_VTBL struct ICorDebugHandleValueVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugHandleValue_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugHandleValue_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugHandleValue_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugHandleValue_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugHandleValue_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugHandleValue_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugHandleValue_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugHandleValue_IsNull(This,pbNull)	\
    (This)->lpVtbl -> IsNull(This,pbNull)

#define ICorDebugHandleValue_GetValue(This,pValue)	\
    (This)->lpVtbl -> GetValue(This,pValue)

#define ICorDebugHandleValue_SetValue(This,value)	\
    (This)->lpVtbl -> SetValue(This,value)

#define ICorDebugHandleValue_Dereference(This,ppValue)	\
    (This)->lpVtbl -> Dereference(This,ppValue)

#define ICorDebugHandleValue_DereferenceStrong(This,ppValue)	\
    (This)->lpVtbl -> DereferenceStrong(This,ppValue)


#define ICorDebugHandleValue_GetHandleType(This,pType)	\
    (This)->lpVtbl -> GetHandleType(This,pType)

#define ICorDebugHandleValue_Dispose(This)	\
    (This)->lpVtbl -> Dispose(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugHandleValue_GetHandleType_Proxy( 
    ICorDebugHandleValue * This,
    /* [out] */ CorDebugHandleType *pType);


void __RPC_STUB ICorDebugHandleValue_GetHandleType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugHandleValue_Dispose_Proxy( 
    ICorDebugHandleValue * This);


void __RPC_STUB ICorDebugHandleValue_Dispose_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugHandleValue_INTERFACE_DEFINED__ */


#ifndef __ICorDebugContext_INTERFACE_DEFINED__
#define __ICorDebugContext_INTERFACE_DEFINED__

/* interface ICorDebugContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB00-8A68-11d2-983C-0000F808342D")
    ICorDebugContext : public ICorDebugObjectValue
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugContext * This,
            /* [out] */ CorElementType *pType);
        
        HRESULT ( STDMETHODCALLTYPE *GetSize )( 
            ICorDebugContext * This,
            /* [out] */ ULONG32 *pSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddress )( 
            ICorDebugContext * This,
            /* [out] */ CORDB_ADDRESS *pAddress);
        
        HRESULT ( STDMETHODCALLTYPE *CreateBreakpoint )( 
            ICorDebugContext * This,
            /* [out] */ ICorDebugValueBreakpoint **ppBreakpoint);
        
        HRESULT ( STDMETHODCALLTYPE *GetClass )( 
            ICorDebugContext * This,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetFieldValue )( 
            ICorDebugContext * This,
            /* [in] */ ICorDebugClass *pClass,
            /* [in] */ mdFieldDef fieldDef,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualMethod )( 
            ICorDebugContext * This,
            /* [in] */ mdMemberRef memberRef,
            /* [out] */ ICorDebugFunction **ppFunction);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            ICorDebugContext * This,
            /* [out] */ ICorDebugContext **ppContext);
        
        HRESULT ( STDMETHODCALLTYPE *IsValueClass )( 
            ICorDebugContext * This,
            /* [out] */ BOOL *pbIsValueClass);
        
        HRESULT ( STDMETHODCALLTYPE *GetManagedCopy )( 
            ICorDebugContext * This,
            /* [out] */ IUnknown **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetFromManagedCopy )( 
            ICorDebugContext * This,
            /* [in] */ IUnknown *pObject);
        
        END_INTERFACE
    } ICorDebugContextVtbl;

    interface ICorDebugContext
    {
        CONST_VTBL struct ICorDebugContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugContext_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ICorDebugContext_GetSize(This,pSize)	\
    (This)->lpVtbl -> GetSize(This,pSize)

#define ICorDebugContext_GetAddress(This,pAddress)	\
    (This)->lpVtbl -> GetAddress(This,pAddress)

#define ICorDebugContext_CreateBreakpoint(This,ppBreakpoint)	\
    (This)->lpVtbl -> CreateBreakpoint(This,ppBreakpoint)


#define ICorDebugContext_GetClass(This,ppClass)	\
    (This)->lpVtbl -> GetClass(This,ppClass)

#define ICorDebugContext_GetFieldValue(This,pClass,fieldDef,ppValue)	\
    (This)->lpVtbl -> GetFieldValue(This,pClass,fieldDef,ppValue)

#define ICorDebugContext_GetVirtualMethod(This,memberRef,ppFunction)	\
    (This)->lpVtbl -> GetVirtualMethod(This,memberRef,ppFunction)

#define ICorDebugContext_GetContext(This,ppContext)	\
    (This)->lpVtbl -> GetContext(This,ppContext)

#define ICorDebugContext_IsValueClass(This,pbIsValueClass)	\
    (This)->lpVtbl -> IsValueClass(This,pbIsValueClass)

#define ICorDebugContext_GetManagedCopy(This,ppObject)	\
    (This)->lpVtbl -> GetManagedCopy(This,ppObject)

#define ICorDebugContext_SetFromManagedCopy(This,pObject)	\
    (This)->lpVtbl -> SetFromManagedCopy(This,pObject)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __ICorDebugContext_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEnum_INTERFACE_DEFINED__
#define __ICorDebugEnum_INTERFACE_DEFINED__

/* interface ICorDebugEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB01-8A68-11d2-983C-0000F808342D")
    ICorDebugEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ ICorDebugEnum **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugEnum * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } ICorDebugEnumVtbl;

    interface ICorDebugEnum
    {
        CONST_VTBL struct ICorDebugEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEnum_Skip_Proxy( 
    ICorDebugEnum * This,
    /* [in] */ ULONG celt);


void __RPC_STUB ICorDebugEnum_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEnum_Reset_Proxy( 
    ICorDebugEnum * This);


void __RPC_STUB ICorDebugEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEnum_Clone_Proxy( 
    ICorDebugEnum * This,
    /* [out] */ ICorDebugEnum **ppEnum);


void __RPC_STUB ICorDebugEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEnum_GetCount_Proxy( 
    ICorDebugEnum * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB ICorDebugEnum_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugObjectEnum_INTERFACE_DEFINED__
#define __ICorDebugObjectEnum_INTERFACE_DEFINED__

/* interface ICorDebugObjectEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugObjectEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB02-8A68-11d2-983C-0000F808342D")
    ICorDebugObjectEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CORDB_ADDRESS objects[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugObjectEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugObjectEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugObjectEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugObjectEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugObjectEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugObjectEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugObjectEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugObjectEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugObjectEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CORDB_ADDRESS objects[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugObjectEnumVtbl;

    interface ICorDebugObjectEnum
    {
        CONST_VTBL struct ICorDebugObjectEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugObjectEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugObjectEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugObjectEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugObjectEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugObjectEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugObjectEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugObjectEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugObjectEnum_Next(This,celt,objects,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,objects,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugObjectEnum_Next_Proxy( 
    ICorDebugObjectEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ CORDB_ADDRESS objects[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugObjectEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugObjectEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugBreakpointEnum_INTERFACE_DEFINED__
#define __ICorDebugBreakpointEnum_INTERFACE_DEFINED__

/* interface ICorDebugBreakpointEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugBreakpointEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB03-8A68-11d2-983C-0000F808342D")
    ICorDebugBreakpointEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugBreakpoint *breakpoints[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugBreakpointEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugBreakpointEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugBreakpointEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugBreakpointEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugBreakpointEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugBreakpointEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugBreakpointEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugBreakpointEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugBreakpointEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugBreakpoint *breakpoints[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugBreakpointEnumVtbl;

    interface ICorDebugBreakpointEnum
    {
        CONST_VTBL struct ICorDebugBreakpointEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugBreakpointEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugBreakpointEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugBreakpointEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugBreakpointEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugBreakpointEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugBreakpointEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugBreakpointEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugBreakpointEnum_Next(This,celt,breakpoints,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,breakpoints,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugBreakpointEnum_Next_Proxy( 
    ICorDebugBreakpointEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugBreakpoint *breakpoints[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugBreakpointEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugBreakpointEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugStepperEnum_INTERFACE_DEFINED__
#define __ICorDebugStepperEnum_INTERFACE_DEFINED__

/* interface ICorDebugStepperEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugStepperEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB04-8A68-11d2-983C-0000F808342D")
    ICorDebugStepperEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugStepper *steppers[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugStepperEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugStepperEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugStepperEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugStepperEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugStepperEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugStepperEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugStepperEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugStepperEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugStepperEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugStepper *steppers[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugStepperEnumVtbl;

    interface ICorDebugStepperEnum
    {
        CONST_VTBL struct ICorDebugStepperEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugStepperEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugStepperEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugStepperEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugStepperEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugStepperEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugStepperEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugStepperEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugStepperEnum_Next(This,celt,steppers,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,steppers,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugStepperEnum_Next_Proxy( 
    ICorDebugStepperEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugStepper *steppers[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugStepperEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugStepperEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugProcessEnum_INTERFACE_DEFINED__
#define __ICorDebugProcessEnum_INTERFACE_DEFINED__

/* interface ICorDebugProcessEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugProcessEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB05-8A68-11d2-983C-0000F808342D")
    ICorDebugProcessEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugProcess *processes[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugProcessEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugProcessEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugProcessEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugProcessEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugProcessEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugProcessEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugProcessEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugProcessEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugProcessEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugProcess *processes[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugProcessEnumVtbl;

    interface ICorDebugProcessEnum
    {
        CONST_VTBL struct ICorDebugProcessEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugProcessEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugProcessEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugProcessEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugProcessEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugProcessEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugProcessEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugProcessEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugProcessEnum_Next(This,celt,processes,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,processes,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugProcessEnum_Next_Proxy( 
    ICorDebugProcessEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugProcess *processes[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugProcessEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugProcessEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugThreadEnum_INTERFACE_DEFINED__
#define __ICorDebugThreadEnum_INTERFACE_DEFINED__

/* interface ICorDebugThreadEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugThreadEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB06-8A68-11d2-983C-0000F808342D")
    ICorDebugThreadEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugThread *threads[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugThreadEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugThreadEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugThreadEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugThreadEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugThreadEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugThreadEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugThreadEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugThreadEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugThreadEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugThread *threads[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugThreadEnumVtbl;

    interface ICorDebugThreadEnum
    {
        CONST_VTBL struct ICorDebugThreadEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugThreadEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugThreadEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugThreadEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugThreadEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugThreadEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugThreadEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugThreadEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugThreadEnum_Next(This,celt,threads,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,threads,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugThreadEnum_Next_Proxy( 
    ICorDebugThreadEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugThread *threads[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugThreadEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugThreadEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugFrameEnum_INTERFACE_DEFINED__
#define __ICorDebugFrameEnum_INTERFACE_DEFINED__

/* interface ICorDebugFrameEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugFrameEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB07-8A68-11d2-983C-0000F808342D")
    ICorDebugFrameEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugFrame *frames[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugFrameEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugFrameEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugFrameEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugFrameEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugFrameEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugFrameEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugFrameEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugFrameEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugFrameEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugFrame *frames[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugFrameEnumVtbl;

    interface ICorDebugFrameEnum
    {
        CONST_VTBL struct ICorDebugFrameEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugFrameEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugFrameEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugFrameEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugFrameEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugFrameEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugFrameEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugFrameEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugFrameEnum_Next(This,celt,frames,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,frames,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugFrameEnum_Next_Proxy( 
    ICorDebugFrameEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugFrame *frames[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugFrameEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugFrameEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugChainEnum_INTERFACE_DEFINED__
#define __ICorDebugChainEnum_INTERFACE_DEFINED__

/* interface ICorDebugChainEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugChainEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB08-8A68-11d2-983C-0000F808342D")
    ICorDebugChainEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugChain *chains[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugChainEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugChainEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugChainEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugChainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugChainEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugChainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugChainEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugChainEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugChainEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugChain *chains[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugChainEnumVtbl;

    interface ICorDebugChainEnum
    {
        CONST_VTBL struct ICorDebugChainEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugChainEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugChainEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugChainEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugChainEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugChainEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugChainEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugChainEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugChainEnum_Next(This,celt,chains,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,chains,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugChainEnum_Next_Proxy( 
    ICorDebugChainEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugChain *chains[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugChainEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugChainEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugModuleEnum_INTERFACE_DEFINED__
#define __ICorDebugModuleEnum_INTERFACE_DEFINED__

/* interface ICorDebugModuleEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugModuleEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB09-8A68-11d2-983C-0000F808342D")
    ICorDebugModuleEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugModule *modules[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugModuleEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugModuleEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugModuleEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugModuleEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugModuleEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugModuleEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugModuleEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugModuleEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugModuleEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugModule *modules[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugModuleEnumVtbl;

    interface ICorDebugModuleEnum
    {
        CONST_VTBL struct ICorDebugModuleEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugModuleEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugModuleEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugModuleEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugModuleEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugModuleEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugModuleEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugModuleEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugModuleEnum_Next(This,celt,modules,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,modules,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugModuleEnum_Next_Proxy( 
    ICorDebugModuleEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugModule *modules[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugModuleEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugModuleEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugValueEnum_INTERFACE_DEFINED__
#define __ICorDebugValueEnum_INTERFACE_DEFINED__

/* interface ICorDebugValueEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugValueEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC7BCB0A-8A68-11d2-983C-0000F808342D")
    ICorDebugValueEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugValue *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugValueEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugValueEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugValueEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugValueEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugValueEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugValueEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugValueEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugValueEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugValueEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugValue *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugValueEnumVtbl;

    interface ICorDebugValueEnum
    {
        CONST_VTBL struct ICorDebugValueEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugValueEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugValueEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugValueEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugValueEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugValueEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugValueEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugValueEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugValueEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugValueEnum_Next_Proxy( 
    ICorDebugValueEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugValue *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugValueEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugValueEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugCodeEnum_INTERFACE_DEFINED__
#define __ICorDebugCodeEnum_INTERFACE_DEFINED__

/* interface ICorDebugCodeEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugCodeEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55E96461-9645-45e4-A2FF-0367877ABCDE")
    ICorDebugCodeEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugCode *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugCodeEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugCodeEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugCodeEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugCodeEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugCodeEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugCodeEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugCodeEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugCodeEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugCodeEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugCode *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugCodeEnumVtbl;

    interface ICorDebugCodeEnum
    {
        CONST_VTBL struct ICorDebugCodeEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugCodeEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugCodeEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugCodeEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugCodeEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugCodeEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugCodeEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugCodeEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugCodeEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugCodeEnum_Next_Proxy( 
    ICorDebugCodeEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugCode *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugCodeEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugCodeEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugTypeEnum_INTERFACE_DEFINED__
#define __ICorDebugTypeEnum_INTERFACE_DEFINED__

/* interface ICorDebugTypeEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugTypeEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("10F27499-9DF2-43ce-8333-A321D7C99CB4")
    ICorDebugTypeEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugType *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugTypeEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugTypeEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugTypeEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugTypeEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugTypeEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugTypeEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugTypeEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugTypeEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugTypeEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugType *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugTypeEnumVtbl;

    interface ICorDebugTypeEnum
    {
        CONST_VTBL struct ICorDebugTypeEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugTypeEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugTypeEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugTypeEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugTypeEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugTypeEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugTypeEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugTypeEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugTypeEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugTypeEnum_Next_Proxy( 
    ICorDebugTypeEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugType *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugTypeEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugTypeEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugType_INTERFACE_DEFINED__
#define __ICorDebugType_INTERFACE_DEFINED__

/* interface ICorDebugType */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugType;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D613F0BB-ACE1-4c19-BD72-E4C08D5DA7F5")
    ICorDebugType : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetType( 
            /* [out] */ CorElementType *ty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClass( 
            /* [out] */ ICorDebugClass **ppClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumerateTypeParameters( 
            /* [out] */ ICorDebugTypeEnum **ppTyParEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFirstTypeParameter( 
            /* [out] */ ICorDebugType **value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBase( 
            /* [out] */ ICorDebugType **pBase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStaticFieldValue( 
            /* [in] */ mdFieldDef fieldDef,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [out] */ ICorDebugValue **ppValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRank( 
            /* [out] */ ULONG32 *pnRank) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugTypeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugType * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugType * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugType * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetType )( 
            ICorDebugType * This,
            /* [out] */ CorElementType *ty);
        
        HRESULT ( STDMETHODCALLTYPE *GetClass )( 
            ICorDebugType * This,
            /* [out] */ ICorDebugClass **ppClass);
        
        HRESULT ( STDMETHODCALLTYPE *EnumerateTypeParameters )( 
            ICorDebugType * This,
            /* [out] */ ICorDebugTypeEnum **ppTyParEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetFirstTypeParameter )( 
            ICorDebugType * This,
            /* [out] */ ICorDebugType **value);
        
        HRESULT ( STDMETHODCALLTYPE *GetBase )( 
            ICorDebugType * This,
            /* [out] */ ICorDebugType **pBase);
        
        HRESULT ( STDMETHODCALLTYPE *GetStaticFieldValue )( 
            ICorDebugType * This,
            /* [in] */ mdFieldDef fieldDef,
            /* [in] */ ICorDebugFrame *pFrame,
            /* [out] */ ICorDebugValue **ppValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetRank )( 
            ICorDebugType * This,
            /* [out] */ ULONG32 *pnRank);
        
        END_INTERFACE
    } ICorDebugTypeVtbl;

    interface ICorDebugType
    {
        CONST_VTBL struct ICorDebugTypeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugType_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugType_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugType_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugType_GetType(This,ty)	\
    (This)->lpVtbl -> GetType(This,ty)

#define ICorDebugType_GetClass(This,ppClass)	\
    (This)->lpVtbl -> GetClass(This,ppClass)

#define ICorDebugType_EnumerateTypeParameters(This,ppTyParEnum)	\
    (This)->lpVtbl -> EnumerateTypeParameters(This,ppTyParEnum)

#define ICorDebugType_GetFirstTypeParameter(This,value)	\
    (This)->lpVtbl -> GetFirstTypeParameter(This,value)

#define ICorDebugType_GetBase(This,pBase)	\
    (This)->lpVtbl -> GetBase(This,pBase)

#define ICorDebugType_GetStaticFieldValue(This,fieldDef,pFrame,ppValue)	\
    (This)->lpVtbl -> GetStaticFieldValue(This,fieldDef,pFrame,ppValue)

#define ICorDebugType_GetRank(This,pnRank)	\
    (This)->lpVtbl -> GetRank(This,pnRank)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugType_GetType_Proxy( 
    ICorDebugType * This,
    /* [out] */ CorElementType *ty);


void __RPC_STUB ICorDebugType_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugType_GetClass_Proxy( 
    ICorDebugType * This,
    /* [out] */ ICorDebugClass **ppClass);


void __RPC_STUB ICorDebugType_GetClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugType_EnumerateTypeParameters_Proxy( 
    ICorDebugType * This,
    /* [out] */ ICorDebugTypeEnum **ppTyParEnum);


void __RPC_STUB ICorDebugType_EnumerateTypeParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugType_GetFirstTypeParameter_Proxy( 
    ICorDebugType * This,
    /* [out] */ ICorDebugType **value);


void __RPC_STUB ICorDebugType_GetFirstTypeParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugType_GetBase_Proxy( 
    ICorDebugType * This,
    /* [out] */ ICorDebugType **pBase);


void __RPC_STUB ICorDebugType_GetBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugType_GetStaticFieldValue_Proxy( 
    ICorDebugType * This,
    /* [in] */ mdFieldDef fieldDef,
    /* [in] */ ICorDebugFrame *pFrame,
    /* [out] */ ICorDebugValue **ppValue);


void __RPC_STUB ICorDebugType_GetStaticFieldValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugType_GetRank_Proxy( 
    ICorDebugType * This,
    /* [out] */ ULONG32 *pnRank);


void __RPC_STUB ICorDebugType_GetRank_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugType_INTERFACE_DEFINED__ */


#ifndef __ICorDebugErrorInfoEnum_INTERFACE_DEFINED__
#define __ICorDebugErrorInfoEnum_INTERFACE_DEFINED__

/* interface ICorDebugErrorInfoEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugErrorInfoEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0E18809-72B5-11d2-976F-00A0C9B4D50C")
    ICorDebugErrorInfoEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugEditAndContinueErrorInfo *errors[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugErrorInfoEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugErrorInfoEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugErrorInfoEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugErrorInfoEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugErrorInfoEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugErrorInfoEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugErrorInfoEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugErrorInfoEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugErrorInfoEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugEditAndContinueErrorInfo *errors[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugErrorInfoEnumVtbl;

    interface ICorDebugErrorInfoEnum
    {
        CONST_VTBL struct ICorDebugErrorInfoEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugErrorInfoEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugErrorInfoEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugErrorInfoEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugErrorInfoEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugErrorInfoEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugErrorInfoEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugErrorInfoEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugErrorInfoEnum_Next(This,celt,errors,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,errors,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugErrorInfoEnum_Next_Proxy( 
    ICorDebugErrorInfoEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugEditAndContinueErrorInfo *errors[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugErrorInfoEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugErrorInfoEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAppDomainEnum_INTERFACE_DEFINED__
#define __ICorDebugAppDomainEnum_INTERFACE_DEFINED__

/* interface ICorDebugAppDomainEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAppDomainEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63ca1b24-4359-4883-bd57-13f815f58744")
    ICorDebugAppDomainEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugAppDomain *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAppDomainEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAppDomainEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAppDomainEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAppDomainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugAppDomainEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugAppDomainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugAppDomainEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugAppDomainEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugAppDomainEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugAppDomain *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugAppDomainEnumVtbl;

    interface ICorDebugAppDomainEnum
    {
        CONST_VTBL struct ICorDebugAppDomainEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAppDomainEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAppDomainEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAppDomainEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAppDomainEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugAppDomainEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugAppDomainEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugAppDomainEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugAppDomainEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAppDomainEnum_Next_Proxy( 
    ICorDebugAppDomainEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugAppDomain *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugAppDomainEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAppDomainEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugAssemblyEnum_INTERFACE_DEFINED__
#define __ICorDebugAssemblyEnum_INTERFACE_DEFINED__

/* interface ICorDebugAssemblyEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugAssemblyEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a2a1ec9-85ec-4bfb-9f15-a89fdfe0fe83")
    ICorDebugAssemblyEnum : public ICorDebugEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugAssembly *values[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugAssemblyEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugAssemblyEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugAssemblyEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorDebugAssemblyEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorDebugAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorDebugAssemblyEnum * This,
            /* [out] */ ICorDebugEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorDebugAssemblyEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorDebugAssemblyEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorDebugAssembly *values[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorDebugAssemblyEnumVtbl;

    interface ICorDebugAssemblyEnum
    {
        CONST_VTBL struct ICorDebugAssemblyEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugAssemblyEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugAssemblyEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugAssemblyEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugAssemblyEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorDebugAssemblyEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorDebugAssemblyEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorDebugAssemblyEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorDebugAssemblyEnum_Next(This,celt,values,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,values,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugAssemblyEnum_Next_Proxy( 
    ICorDebugAssemblyEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorDebugAssembly *values[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorDebugAssemblyEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugAssemblyEnum_INTERFACE_DEFINED__ */


#ifndef __ICorDebugMDA_INTERFACE_DEFINED__
#define __ICorDebugMDA_INTERFACE_DEFINED__

/* interface ICorDebugMDA */
/* [unique][uuid][object] */ 

typedef 
enum CorDebugMDAFlags
    {	MDA_FLAG_SLIP	= 0x2
    } 	CorDebugMDAFlags;


EXTERN_C const IID IID_ICorDebugMDA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC726F2F-1DB7-459b-B0EC-05F01D841B42")
    ICorDebugMDA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescription( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetXML( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFlags( 
            /* [in] */ CorDebugMDAFlags *pFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOSThreadId( 
            /* [out] */ DWORD *pOsTid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugMDAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugMDA * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugMDA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugMDA * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorDebugMDA * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescription )( 
            ICorDebugMDA * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetXML )( 
            ICorDebugMDA * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetFlags )( 
            ICorDebugMDA * This,
            /* [in] */ CorDebugMDAFlags *pFlags);
        
        HRESULT ( STDMETHODCALLTYPE *GetOSThreadId )( 
            ICorDebugMDA * This,
            /* [out] */ DWORD *pOsTid);
        
        END_INTERFACE
    } ICorDebugMDAVtbl;

    interface ICorDebugMDA
    {
        CONST_VTBL struct ICorDebugMDAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugMDA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugMDA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugMDA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugMDA_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ICorDebugMDA_GetDescription(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetDescription(This,cchName,pcchName,szName)

#define ICorDebugMDA_GetXML(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetXML(This,cchName,pcchName,szName)

#define ICorDebugMDA_GetFlags(This,pFlags)	\
    (This)->lpVtbl -> GetFlags(This,pFlags)

#define ICorDebugMDA_GetOSThreadId(This,pOsTid)	\
    (This)->lpVtbl -> GetOSThreadId(This,pOsTid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugMDA_GetName_Proxy( 
    ICorDebugMDA * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugMDA_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugMDA_GetDescription_Proxy( 
    ICorDebugMDA * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugMDA_GetDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugMDA_GetXML_Proxy( 
    ICorDebugMDA * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ICorDebugMDA_GetXML_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugMDA_GetFlags_Proxy( 
    ICorDebugMDA * This,
    /* [in] */ CorDebugMDAFlags *pFlags);


void __RPC_STUB ICorDebugMDA_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugMDA_GetOSThreadId_Proxy( 
    ICorDebugMDA * This,
    /* [out] */ DWORD *pOsTid);


void __RPC_STUB ICorDebugMDA_GetOSThreadId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugMDA_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEditAndContinueErrorInfo_INTERFACE_DEFINED__
#define __ICorDebugEditAndContinueErrorInfo_INTERFACE_DEFINED__

/* interface ICorDebugEditAndContinueErrorInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEditAndContinueErrorInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8D600D41-F4F6-4cb3-B7EC-7BD164944036")
    ICorDebugEditAndContinueErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetModule( 
            /* [out] */ ICorDebugModule **ppModule) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [out] */ mdToken *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorCode( 
            /* [out] */ HRESULT *pHr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetString( 
            /* [in] */ ULONG32 cchString,
            /* [out] */ ULONG32 *pcchString,
            /* [length_is][size_is][out] */ WCHAR szString[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEditAndContinueErrorInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEditAndContinueErrorInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEditAndContinueErrorInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetModule )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [out] */ ICorDebugModule **ppModule);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [out] */ mdToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorCode )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [out] */ HRESULT *pHr);
        
        HRESULT ( STDMETHODCALLTYPE *GetString )( 
            ICorDebugEditAndContinueErrorInfo * This,
            /* [in] */ ULONG32 cchString,
            /* [out] */ ULONG32 *pcchString,
            /* [length_is][size_is][out] */ WCHAR szString[  ]);
        
        END_INTERFACE
    } ICorDebugEditAndContinueErrorInfoVtbl;

    interface ICorDebugEditAndContinueErrorInfo
    {
        CONST_VTBL struct ICorDebugEditAndContinueErrorInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEditAndContinueErrorInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEditAndContinueErrorInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEditAndContinueErrorInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEditAndContinueErrorInfo_GetModule(This,ppModule)	\
    (This)->lpVtbl -> GetModule(This,ppModule)

#define ICorDebugEditAndContinueErrorInfo_GetToken(This,pToken)	\
    (This)->lpVtbl -> GetToken(This,pToken)

#define ICorDebugEditAndContinueErrorInfo_GetErrorCode(This,pHr)	\
    (This)->lpVtbl -> GetErrorCode(This,pHr)

#define ICorDebugEditAndContinueErrorInfo_GetString(This,cchString,pcchString,szString)	\
    (This)->lpVtbl -> GetString(This,cchString,pcchString,szString)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueErrorInfo_GetModule_Proxy( 
    ICorDebugEditAndContinueErrorInfo * This,
    /* [out] */ ICorDebugModule **ppModule);


void __RPC_STUB ICorDebugEditAndContinueErrorInfo_GetModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueErrorInfo_GetToken_Proxy( 
    ICorDebugEditAndContinueErrorInfo * This,
    /* [out] */ mdToken *pToken);


void __RPC_STUB ICorDebugEditAndContinueErrorInfo_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueErrorInfo_GetErrorCode_Proxy( 
    ICorDebugEditAndContinueErrorInfo * This,
    /* [out] */ HRESULT *pHr);


void __RPC_STUB ICorDebugEditAndContinueErrorInfo_GetErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueErrorInfo_GetString_Proxy( 
    ICorDebugEditAndContinueErrorInfo * This,
    /* [in] */ ULONG32 cchString,
    /* [out] */ ULONG32 *pcchString,
    /* [length_is][size_is][out] */ WCHAR szString[  ]);


void __RPC_STUB ICorDebugEditAndContinueErrorInfo_GetString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEditAndContinueErrorInfo_INTERFACE_DEFINED__ */


#ifndef __ICorDebugEditAndContinueSnapshot_INTERFACE_DEFINED__
#define __ICorDebugEditAndContinueSnapshot_INTERFACE_DEFINED__

/* interface ICorDebugEditAndContinueSnapshot */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorDebugEditAndContinueSnapshot;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DC3FA01-D7CB-11d2-8A95-0080C792E5D8")
    ICorDebugEditAndContinueSnapshot : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CopyMetaData( 
            /* [in] */ IStream *pIStream,
            /* [out] */ GUID *pMvid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMvid( 
            /* [out] */ GUID *pMvid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoDataRVA( 
            /* [out] */ ULONG32 *pRoDataRVA) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRwDataRVA( 
            /* [out] */ ULONG32 *pRwDataRVA) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPEBytes( 
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetILMap( 
            /* [in] */ mdToken mdFunction,
            /* [in] */ ULONG cMapSize,
            /* [size_is][in] */ COR_IL_MAP map[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPESymbolBytes( 
            /* [in] */ IStream *pIStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorDebugEditAndContinueSnapshotVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorDebugEditAndContinueSnapshot * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorDebugEditAndContinueSnapshot * This);
        
        HRESULT ( STDMETHODCALLTYPE *CopyMetaData )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ IStream *pIStream,
            /* [out] */ GUID *pMvid);
        
        HRESULT ( STDMETHODCALLTYPE *GetMvid )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [out] */ GUID *pMvid);
        
        HRESULT ( STDMETHODCALLTYPE *GetRoDataRVA )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [out] */ ULONG32 *pRoDataRVA);
        
        HRESULT ( STDMETHODCALLTYPE *GetRwDataRVA )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [out] */ ULONG32 *pRwDataRVA);
        
        HRESULT ( STDMETHODCALLTYPE *SetPEBytes )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *SetILMap )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ mdToken mdFunction,
            /* [in] */ ULONG cMapSize,
            /* [size_is][in] */ COR_IL_MAP map[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetPESymbolBytes )( 
            ICorDebugEditAndContinueSnapshot * This,
            /* [in] */ IStream *pIStream);
        
        END_INTERFACE
    } ICorDebugEditAndContinueSnapshotVtbl;

    interface ICorDebugEditAndContinueSnapshot
    {
        CONST_VTBL struct ICorDebugEditAndContinueSnapshotVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorDebugEditAndContinueSnapshot_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorDebugEditAndContinueSnapshot_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorDebugEditAndContinueSnapshot_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorDebugEditAndContinueSnapshot_CopyMetaData(This,pIStream,pMvid)	\
    (This)->lpVtbl -> CopyMetaData(This,pIStream,pMvid)

#define ICorDebugEditAndContinueSnapshot_GetMvid(This,pMvid)	\
    (This)->lpVtbl -> GetMvid(This,pMvid)

#define ICorDebugEditAndContinueSnapshot_GetRoDataRVA(This,pRoDataRVA)	\
    (This)->lpVtbl -> GetRoDataRVA(This,pRoDataRVA)

#define ICorDebugEditAndContinueSnapshot_GetRwDataRVA(This,pRwDataRVA)	\
    (This)->lpVtbl -> GetRwDataRVA(This,pRwDataRVA)

#define ICorDebugEditAndContinueSnapshot_SetPEBytes(This,pIStream)	\
    (This)->lpVtbl -> SetPEBytes(This,pIStream)

#define ICorDebugEditAndContinueSnapshot_SetILMap(This,mdFunction,cMapSize,map)	\
    (This)->lpVtbl -> SetILMap(This,mdFunction,cMapSize,map)

#define ICorDebugEditAndContinueSnapshot_SetPESymbolBytes(This,pIStream)	\
    (This)->lpVtbl -> SetPESymbolBytes(This,pIStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_CopyMetaData_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [in] */ IStream *pIStream,
    /* [out] */ GUID *pMvid);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_CopyMetaData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_GetMvid_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [out] */ GUID *pMvid);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_GetMvid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_GetRoDataRVA_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [out] */ ULONG32 *pRoDataRVA);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_GetRoDataRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_GetRwDataRVA_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [out] */ ULONG32 *pRwDataRVA);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_GetRwDataRVA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_SetPEBytes_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [in] */ IStream *pIStream);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_SetPEBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_SetILMap_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [in] */ mdToken mdFunction,
    /* [in] */ ULONG cMapSize,
    /* [size_is][in] */ COR_IL_MAP map[  ]);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_SetILMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorDebugEditAndContinueSnapshot_SetPESymbolBytes_Proxy( 
    ICorDebugEditAndContinueSnapshot * This,
    /* [in] */ IStream *pIStream);


void __RPC_STUB ICorDebugEditAndContinueSnapshot_SetPESymbolBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorDebugEditAndContinueSnapshot_INTERFACE_DEFINED__ */



#ifndef __CORDBLib_LIBRARY_DEFINED__
#define __CORDBLib_LIBRARY_DEFINED__

/* library CORDBLib */
/* [helpstring][version][uuid] */ 

























EXTERN_C const IID LIBID_CORDBLib;

EXTERN_C const CLSID CLSID_CorDebug;

#ifdef __cplusplus

class DECLSPEC_UUID("6fef44d0-39e7-4c77-be8e-c9f8cf988630")
CorDebug;
#endif

EXTERN_C const CLSID CLSID_EmbeddedCLRCorDebug;

#ifdef __cplusplus

class DECLSPEC_UUID("211f1254-bc7e-4af5-b9aa-067308d83dd1")
EmbeddedCLRCorDebug;
#endif
#endif /* __CORDBLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  HPROCESS_UserSize(     unsigned long *, unsigned long            , HPROCESS * ); 
unsigned char * __RPC_USER  HPROCESS_UserMarshal(  unsigned long *, unsigned char *, HPROCESS * ); 
unsigned char * __RPC_USER  HPROCESS_UserUnmarshal(unsigned long *, unsigned char *, HPROCESS * ); 
void                      __RPC_USER  HPROCESS_UserFree(     unsigned long *, HPROCESS * ); 

unsigned long             __RPC_USER  HTHREAD_UserSize(     unsigned long *, unsigned long            , HTHREAD * ); 
unsigned char * __RPC_USER  HTHREAD_UserMarshal(  unsigned long *, unsigned char *, HTHREAD * ); 
unsigned char * __RPC_USER  HTHREAD_UserUnmarshal(unsigned long *, unsigned char *, HTHREAD * ); 
void                      __RPC_USER  HTHREAD_UserFree(     unsigned long *, HTHREAD * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\CorError.h ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
/*********************************************************************
 **                                                                 **
 ** CorError.h - lists the HResults used by the .NET Framework's    **
 **              Common Language Runtime.                           **
 ** Created: September 3, 1999.                                     **
 **                                                                 **
 *********************************************************************/


#ifndef __COMMON_LANGUAGE_RUNTIME_HRESULTS__
#define __COMMON_LANGUAGE_RUNTIME_HRESULTS__

/*********************************************************************

These HRESULTs are used for mapping managed exceptions to COM error codes
and vice versa through COM Interop.  For background on COM error codes see
http://msdn.microsoft.com/library/default.asp?url=/library/en-us/com/error_9td2.asp.

FACILITY_URT is defined as 0x13 (0x8013xxxx). The facility range is reserved
for the .NET Framework SDK teams.

Within that range, the following subranges have been allocated for different
feature areas:

0x10yy for Execution Engine
0x11yy for Metadata, TypeLib Export, and CLDB
0x12yy for MetaData Validator
0x13yy for Debugger and Profiler errors
0x14yy for Security
0x15yy for BCL
0x1600 - 0x161F for Reflection
0x1620 - 0x163F for System.IO
0x1640 - 0x165F for Security
0x1660 - 0x16FF for BCL
0x17yy for shim
0x18yy for IL Verifier
0x19yy for .NET Framework
0x1Ayy for .NET Framework
0x1Byy for MetaData Validator
0x1Cyy for more debugger errors
0x1Dyy for PE Format Validation
0x1Eyy for CLR Optimization Service errors
0x1Fyy for NGEN errors
0x30yy for VSA errors

Base class library HRESULTs are copied from this file into many different
files named __HResults.cs under the BCL directory.  Frameworks HRESULTs are
defined in src/main/HResults.cs. If you make any modifications to
the range allocations described above, please make sure the corerror.h file
gets updated.

*********************************************************************/

#include <winerror.h>

#ifndef FACILITY_URT
#define FACILITY_URT            0x13
#endif

#ifndef EMAKEHR
#define SMAKEHR(val)            MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_URT, val)
#define EMAKEHR(val)            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_URT, val)
#endif


// ******************
// FACILITY_UTF
// ******************


// ******************
// Metadata errors
// ******************

//**** ICeeFileGen errors.
#define CEE_E_ENTRYPOINT                EMAKEHR(0x1000)     // The entry point info is invalid.
#define CEE_E_CVTRES_NOT_FOUND          EMAKEHR(0x1001)     // cannot find cvtres.exe

//**** EE errors
#define MSEE_E_LOADLIBFAILED            EMAKEHR(0x1010)     // Failed to delay load library %s (Win32 error: %d).
#define MSEE_E_GETPROCFAILED            EMAKEHR(0x1011)     // Failed to get entry point %s (Win32 error: %d).
#define MSEE_E_MULTCOPIESLOADED         EMAKEHR(0x1012)     // Multiple copies of MSCOREE.dll have been loaded by the same process.
// the following two are COR to match the name used in the library
#define COR_E_APPDOMAINUNLOADED         EMAKEHR(0x1014)     // access unloaded appdomain
#define COR_E_CANNOTUNLOADAPPDOMAIN     EMAKEHR(0x1015)     // Error while unloading an appdomain
#define MSEE_E_ASSEMBLYLOADINPROGRESS   EMAKEHR(0x1016)     // Assembly is being currently being loaded
#define MSEE_E_CANNOTCREATEAPPDOMAIN    EMAKEHR(0x1017)     // Attempt to create appdomain failed
#define COR_E_FIXUPSINEXE                   EMAKEHR(0x1019)     // Attempt to load an unverifiable exe with fixups (IAT with more than 2 sections or a TLS section)
#define COR_E_NO_LOADLIBRARY_ALLOWED    EMAKEHR(0x101A)     // Attempt to LoadLibrary a managed image in an improper way (only assemblies with EAT's area allowed.)
#define COR_E_NEWER_RUNTIME             EMAKEHR(0x101B)     // The assembly is built by a runtime newer than the currently loaded runtime, and cannot be loaded.
#define COR_E_CANNOT_SET_POLICY         EMAKEHR(0x101C)     // Unable to set app domain security policy after non-GAC domain neutral assemblies are loaded
#define COR_E_CANNOT_SPECIFY_EVIDENCE   EMAKEHR(0x101D)     // Unable to use assembly evidence after non-GAC domain neutral assemblies are loaded

// The CLR hosting support reserves 0x1020-0x102F.
#define HOST_E_DEADLOCK        EMAKEHR(0x1020)             // Host detects deadlock on a blocking operation
#define HOST_E_INTERRUPTED     EMAKEHR(0x1021)             // Host interrupts a wait, similar to APC
#define HOST_E_INVALIDOPERATION     EMAKEHR(0x1022)        // The operation is invalid
#define HOST_E_CLRNOTAVAILABLE     EMAKEHR(0x1023)         // CLR has been disabled due to unrecoverable error
#define HOST_E_TIMEOUT     EMAKEHR(0x1024)                 // A wait times out
#define HOST_E_NOT_OWNER     EMAKEHR(0x1025)               //
#define HOST_E_ABANDONED     EMAKEHR(0x1026)               // An event is abandoned
#define HOST_E_EXITPROCESS_THREADABORT     EMAKEHR(0x1027) // ExitProcess due to ThreadAbort escalation
#define HOST_E_EXITPROCESS_ADUNLOAD     EMAKEHR(0x1028)    // ExitProcess due to AD Unload escalation
#define HOST_E_EXITPROCESS_TIMEOUT     EMAKEHR(0x1029)     // ExitProcess due to Timeout escalation
#define HOST_E_EXITPROCESS_OUTOFMEMORY     EMAKEHR(0x102a) // ExitProcess due to OutOfMemory escalation
#define HOST_E_EXITPROCESS_STACKOVERFLOW   EMAKEHR(0x102b) // ExitProcess due to StackOverflow escalation

//**** Assembly Cache errors
#define COR_E_MODULE_HASH_CHECK_FAILED EMAKEHR(0x1039)      // The check of the module's hash failed.
#define FUSION_E_REF_DEF_MISMATCH       EMAKEHR(0x1040)     // The located assembly's manifest definition does not match the assembly reference.
#define FUSION_E_INVALID_PRIVATE_ASM_LOCATION EMAKEHR(0x1041) // The private assembly was located outside the appbase directory.
#define FUSION_E_ASM_MODULE_MISSING     EMAKEHR(0x1042)     // A module specified in the manifest was not found.
#define FUSION_E_UNEXPECTED_MODULE_FOUND EMAKEHR(0x1043)    // Modules which are not in the manifest were streamed in.
#define FUSION_E_PRIVATE_ASM_DISALLOWED EMAKEHR(0x1044)     // A strongly-named assembly is required.
#define FUSION_E_SIGNATURE_CHECK_FAILED EMAKEHR(0x1045)     // The check of the signature failed.
#define FUSION_E_DATABASE_ERROR         EMAKEHR(0x1046)     // An unexpected error was encountered in the Assembly Cache database.
#define FUSION_E_INVALID_NAME           EMAKEHR(0x1047)     // The given assembly name or codebase was invalid.
#define FUSION_E_CODE_DOWNLOAD_DISABLED EMAKEHR(0x1048)     // HTTP download of assemblies has been disabled for this appdomain.
#define FUSION_E_UNINSTALL_DISALLOWED   EMAKEHR(0x1049)     // Uninstall of given assembly is not allowed.
#define FUSION_E_HOST_GAC_ASM_MISMATCH  EMAKEHR(0x1050)     // Assembly in host store has a different signature than assembly in GAC
#define FUSION_E_LOADFROM_BLOCKED       EMAKEHR(0x1051)     // Hosted environment doesn't permit loading by location
#define FUSION_E_CACHEFILE_FAILED       EMAKEHR(0x1052)     // Failed to add file to AppDomain cache


//=============================================================================
// THE VALIDATOR IS CURRENTLY USING ERROR CODES STARTING WITH 0x1050 ONWARDS.
// LOOK AT ERROR CODES STARTING FROM VLDTR_E_AS_NAMENULL.  JUST A NOTE IN CASE
// THE EE EVER COMES TO THE POINT OF NEEDING THOSE!!!
//=============================================================================

//**** Generic errors.
#define CLDB_E_FILE_BADREAD             EMAKEHR(0x1100)     // Error occured during a read.
#define CLDB_E_FILE_BADWRITE            EMAKEHR(0x1101)     // Error occured during a write.
#define CLDB_E_FILE_READONLY            EMAKEHR(0x1103)     // File is read only.
#define CLDB_E_NAME_ERROR               EMAKEHR(0x1105)     // An ill-formed name was given.
#define CLDB_S_TRUNCATION               SMAKEHR(0x1106)     // STATUS: Data value was truncated.
#define CLDB_E_TRUNCATION               EMAKEHR(0x1106)     // ERROR:  Data value was truncated.
#define CLDB_E_FILE_OLDVER              EMAKEHR(0x1107)     // Old version error.
#define CLDB_E_RELOCATED                EMAKEHR(0x1108)     // A shared mem open failed to open at the originally
                                                    //  assigned memory address.
#define CLDB_S_NULL                     SMAKEHR(0x1109)     // NULL data value.
#define CLDB_E_SMDUPLICATE              EMAKEHR(0x110A)     // Create of shared memory failed.  A memory mapping of the same name already exists.
#define CLDB_E_NO_DATA                  EMAKEHR(0x110B)     // There isn't .CLB data in the memory or stream.
#define CLDB_E_READONLY                 EMAKEHR(0x110C)     // Database is read only.
#define CLDB_E_INCOMPATIBLE             EMAKEHR(0x110D)     // The importing scope is not comptabile with the emitting scope

//**** Schema errors.
#define CLDB_E_FILE_CORRUPT             EMAKEHR(0x110E)     // File is corrupt.
#define CLDB_E_SCHEMA_VERNOTFOUND       EMAKEHR(0x110F)   // Version %d of schema '%s' not found.
#define CLDB_E_BADUPDATEMODE            EMAKEHR(0x1110)     // cannot open a incrementally build scope for full update

//**** Index errors.
#define CLDB_E_INDEX_NONULLKEYS         EMAKEHR(0x1121)     // Null value not allowed in unique index or primary key.
#define CLDB_E_INDEX_DUPLICATE          EMAKEHR(0x1122)     // Unique index %s has been violated.
#define CLDB_E_INDEX_BADTYPE            EMAKEHR(0x1123)     // The columns data type is not allowed in an index.
#define CLDB_E_INDEX_NOTFOUND           EMAKEHR(0x1124)     // Index %s not found.
#define CLDB_S_INDEX_TABLESCANREQUIRED  SMAKEHR(0x1125) // Table scan required to run query.

//**** Record errors.
#define CLDB_E_RECORD_NOTFOUND          EMAKEHR(0x1130)     // Record wasn't found on lookup.
#define CLDB_E_RECORD_OVERFLOW          EMAKEHR(0x1131)     // Too many records were returned for criteria.
#define CLDB_E_RECORD_DUPLICATE         EMAKEHR(0x1132)     // Record is a duplicate.
#define CLDB_E_RECORD_PKREQUIRED        EMAKEHR(0x1133)    // Primary key value is required.
#define CLDB_E_RECORD_DELETED           EMAKEHR(0x1134)     // Record is valid but deleted.
#define CLDB_E_RECORD_OUTOFORDER        EMAKEHR(0x1135)    // Record is emitted out of order.

//**** Column errors.
#define CLDB_E_COLUMN_OVERFLOW          EMAKEHR(0x1140)     // Data too large.
#define CLDB_E_COLUMN_READONLY          EMAKEHR(0x1141)     // Column cannot be changed.
#define CLDB_E_COLUMN_SPECIALCOL        EMAKEHR(0x1142)    // Too many RID or primary key columns, 1 is max.
#define CLDB_E_COLUMN_PKNONULLS         EMAKEHR(0x1143)     // Primary key column %s may not allow the null value.

//**** Table errors.
#define CLDB_E_TABLE_CANTDROP           EMAKEHR(0x1150)     // Can't auto-drop table while open.

//**** Object errors.
#define CLDB_E_OBJECT_NOTFOUND          EMAKEHR(0x1151)     // Object was not found in the database.
#define CLDB_E_OBJECT_COLNOTFOUND       EMAKEHR(0x1152)   // The column was not found.

//**** Vector errors.
#define CLDB_E_VECTOR_BADINDEX          EMAKEHR(0x1153)     // The index given was invalid.

//**** Heap errors;
#define CLDB_E_TOO_BIG                  EMAKEHR(0x1154)     // A blob or string was too big.

//**** IMeta* errors.
#define META_E_INVALID_TOKEN_TYPE       EMAKEHR(0x115f) // A token of the wrong type passed to a metadata function.

#define TLBX_E_INVALID_TYPEINFO         EMAKEHR(0x1160) // Typelib import: invalid type, not converted.
#define TLBX_E_INVALID_TYPEINFO_UNNAMED EMAKEHR(0x1161) // Typelib import: invalid type, not converted -- name unknown.
#define TLBX_E_CTX_NESTED               EMAKEHR(0x1162) // Typelib export: Format string for nested contexts.
#define TLBX_E_ERROR_MESSAGE            EMAKEHR(0x1163) // Typelib export: Error message wrapper.
#define TLBX_E_CANT_SAVE                EMAKEHR(0x1164) // Typelib export: cant "SaveAllChanges()"
#define TLBX_W_LIBNOTREGISTERED         EMAKEHR(0x1165) // Typelib export: type library is not registered.
#define TLBX_E_CANTLOADLIBRARY          EMAKEHR(0x1166) // Typelib export: type library cannot be loaded.
#define TLBX_E_BAD_VT_TYPE              EMAKEHR(0x1167) // Typelib import: invalid VT_*, not converted.
#define TLBX_E_NO_MSCOREE_TLB           EMAKEHR(0x1168) // Typelib export: can't load mscoree.tlb
#define TLBX_E_BAD_MSCOREE_TLB          EMAKEHR(0x1169) // Typelib export: can't get a required typeinfo from mscoree.tlb.
#define TLBX_E_TLB_EXCEPTION            EMAKEHR(0x116a) // Typelib import: fault reading a typelib.
#define TLBX_E_MULTIPLE_LCIDS           EMAKEHR(0x116b) // Typelib import: Multiple LCID's parameters on a method.
#define TLBX_I_TYPEINFO_IMPORTED        SMAKEHR(0x116c) // Typelib import: progress report.
#define TLBX_E_AMBIGUOUS_RETURN         EMAKEHR(0x116d) // Typelib import: duplicate or ambiguous return types.
#define TLBX_E_DUPLICATE_TYPE_NAME      EMAKEHR(0x116e) // Typelib import: duplicate name (due to user-defined name).
#define TLBX_I_USEIUNKNOWN              SMAKEHR(0x116f) // Typelib export: substituted IUnknown for type.

#define TLBX_I_UNCONVERTABLE_ARGS       SMAKEHR(0x1170) // Typelib import: signature can't be converted (eg, struct**)
#define TLBX_I_UNCONVERTABLE_FIELD      SMAKEHR(0x1171) // Typelib import: signature can't be converted (eg, struct**)
#define TLBX_I_NONSEQUENTIALSTRUCT      EMAKEHR(0x1172) // Typelib export: Can't convert non-sequential structs.
#define TLBX_W_WARNING_MESSAGE          SMAKEHR(0x1173) // Typelib export: Warning message wrapper.
#define TLBX_I_RESOLVEREFFAILED         EMAKEHR(0x1174) // Typelib import: The resolve ref call failed.
#define TLBX_E_ASANY                    EMAKEHR(0x1175) // Typelib export: Encounterd "AsAny" -- ignored.
#define TLBX_E_INVALIDLCIDPARAM         EMAKEHR(0x1176) // Typelib export: Encounterd an LCID attribute set to an invalid param.
#define TLBX_E_LCIDONDISPONLYITF        EMAKEHR(0x1177) // Typelib export: Encounterd an LCID attribute on a disp only interface.
#define TLBX_E_NONPUBLIC_FIELD          EMAKEHR(0x1178) // Typelib export: Non-public field in public struct.
#define TLBX_I_TYPE_EXPORTED            SMAKEHR(0x1179) // Typelib export: type exported
#define TLBX_I_DUPLICATE_DISPID         SMAKEHR(0x117A) // Typelib export: duplicate dispid -- auto corrected.
#define TLBX_E_BAD_NAMES                EMAKEHR(0x117B) // Typelib export: bad names list.
#define TLBX_I_REF_TYPE_AS_STRUCT       SMAKEHR(0x117C) // Typelib export: referenct tyep had layout, exported as struct.
#define TLBX_E_GENERICINST_SIGNATURE    EMAKEHR(0x117D) // TypeLib export: generic type instance in signature.
#define TLBX_E_GENERICPAR_SIGNATURE     EMAKEHR(0x117E) // TypeLib export: generic type parameter in signature.
#define TLBX_I_GENERIC_TYPE             SMAKEHR(0x117F) // TypeLib export: generic type definition

#define META_E_DUPLICATE                EMAKEHR(0x1180)     // Attempt to define an object that already exists.
#define META_E_GUID_REQUIRED            EMAKEHR(0x1181)     // A guid was not provided where one was required.
#define META_E_TYPEDEF_MISMATCH         EMAKEHR(0x1182)     // Merge: an import typedef matched ns.name, but not version and guid.
#define META_E_MERGE_COLLISION          EMAKEHR(0x1183)     // Merge: conflict between import and emit
#define TLBX_W_NON_INTEGRAL_CA_TYPE     SMAKEHR(0x1184) // TypeLib import: Ignoring IDL custom attribute -- does not have an integral value.
#define TLBX_W_IENUM_CA_ON_IUNK         SMAKEHR(0x1185) // TypeLib import: Ignoring IDL custom attribute -- using IEnum CA on an IUnknown derived interface.
#define TLBX_E_NO_SAFEHANDLE_ARRAYS     EMAKEHR(0x1186) // TypeLib export: detected array of SafeHandles
#define META_E_METHD_NOT_FOUND          EMAKEHR(0x1187) // Merge: Class already in emit scope, but member not found
#define META_E_FIELD_NOT_FOUND          EMAKEHR(0x1188) // Merge: Class already in emit scope, but member not found
#define META_S_PARAM_MISMATCH           SMAKEHR(0x1189) // Merge: Parameter information mismatched.
#define META_E_PARAM_MISMATCH           EMAKEHR(0x1189) // Merge: Parameter information mismatched.
#define META_E_BADMETADATA              EMAKEHR(0x118A) // Merge: Inconsistency in meta data import scope
#define META_E_INTFCEIMPL_NOT_FOUND     EMAKEHR(0x118B) // Merge: Class already in emit scope, but interfaceimpl not found
#define TLBX_E_NO_CRITICALHANDLE_ARRAYS EMAKEHR(0x118C) // TypeLib export: detected array of CriticalHandles
#define META_E_CLASS_LAYOUT_INCONSISTENT EMAKEHR(0x118D) // Merge: Class is duplicated but class layout information is not consistent
#define META_E_FIELD_MARSHAL_NOT_FOUND  EMAKEHR(0x118E) // Merge: Field is duplicated but we cannot find the matching FieldMarshal information
#define META_E_METHODSEM_NOT_FOUND      EMAKEHR(0x118F) // Merge:

#define META_E_EVENT_NOT_FOUND          EMAKEHR(0x1190) // Merge: Method is duplicated but we cannot find the matching event info.
#define META_E_PROP_NOT_FOUND           EMAKEHR(0x1191) // Merge: Method is duplicated but we cannot find the maching property info.
#define META_E_BAD_SIGNATURE            EMAKEHR(0x1192) // Bad binary signature
#define META_E_BAD_INPUT_PARAMETER      EMAKEHR(0x1193) // Bad input parameters
#define META_E_METHDIMPL_INCONSISTENT   EMAKEHR(0x1194) // Merge: duplicated methods have inconsistent ImplFlags
#define META_E_MD_INCONSISTENCY         EMAKEHR(0x1195) // Merge: Inconsistency in meta data
#define META_E_CANNOTRESOLVETYPEREF     EMAKEHR(0x1196) // Cannot resolve typeref
#define META_S_DUPLICATE                SMAKEHR(0x1197) // Attempt to define an object that already exists in valid scenerios.
#define META_E_STRINGSPACE_FULL         EMAKEHR(0x1198) // No logical space left to create more user strings.
#define META_E_UNEXPECTED_REMAP         EMAKEHR(0x1199) // A TokenRemap occurred which we weren't prepared to handle.
#define META_E_HAS_UNMARKALL            EMAKEHR(0x119A) // Unmark all has been called already
#define META_E_MUST_CALL_UNMARKALL      EMAKEHR(0x119B) // Must call UnmarkAll first before marking.
#define META_E_GENERICPARAM_INCONSISTENT EMAKEHR(0x119C) // Merge: duplicated types/methods have inconsistent GenericParams
#define META_E_EVENT_COUNTS             EMAKEHR(0x119D) // Merge: different event counts in import and emit scopes.
#define META_E_PROPERTY_COUNTS          EMAKEHR(0x119E) // Merge: different property counts in import and emit scopes.
#define META_E_TYPEDEF_MISSING          EMAKEHR(0x119F) // Merge: An input scope has a TypeRef which should but doesn't have a matching TypeDef.

#define TLBX_E_CANT_LOAD_MODULE         EMAKEHR(0x11A0) // TypeLib export: can't open the module to export.
#define TLBX_E_CANT_LOAD_CLASS          EMAKEHR(0x11A1) // TypeLib export: can't load a class.
#define TLBX_E_NULL_MODULE              EMAKEHR(0x11A2) // TypeLib export: the hMod of a loaded class is 0; can't export it.
#define TLBX_E_NO_CLSID_KEY             EMAKEHR(0x11A3) // TypeLib export: no CLSID or Interface subkey to HKCR.
#define TLBX_E_CIRCULAR_EXPORT          EMAKEHR(0x11A4) // TypeLib export: attempt to export a CLB imported from a TLB.
#define TLBX_E_CIRCULAR_EXPORT2          EMAKEHR(0x1B52) // TypeLib export: attempt to export a CLB imported from a TLB.
#define TLBX_E_CIRCULAR_IMPORT          EMAKEHR(0x11A5) // TypeLib import: attempt to import a TLB exported from a CLB.
#define TLBX_E_BAD_NATIVETYPE           EMAKEHR(0x11A6) // TypeLib export: bad Native type in method signature.
#define TLBX_E_BAD_VTABLE               EMAKEHR(0x11A7) // TypeLib import: non-increasing vtable (duplicate slots).
#define TLBX_E_CRM_NON_STATIC           EMAKEHR(0x11A8) // TypeLib export: the COM register method is non static.
#define TLBX_E_CRM_INVALID_SIG          EMAKEHR(0x11A9) // TypeLib export: the specified COM register method does not have the correct signature.
#define TLBX_E_CLASS_LOAD_EXCEPTION     EMAKEHR(0x11AA) // TypeLib export: can't load, have the class load exception.
#define TLBX_E_UNKNOWN_SIGNATURE        EMAKEHR(0x11AB) // TypeLib export: unknown element in signature.
#define TLBX_E_REFERENCED_TYPELIB       EMAKEHR(0x11AC) // TypeLib import: reference to an external typelib.
#define TLBX_S_REFERENCED_TYPELIB       SMAKEHR(0x11AC) // TypeLib import: reference to an external typelib.
#define TLBX_E_INVALID_NAMESPACE        EMAKEHR(0x11AD) // TypeLib import: an imported typelib has an invalid namespace name.
#define TLBX_E_LAYOUT_ERROR             EMAKEHR(0x11AE) // Typelib export: an error on Layout()
#define TLBX_E_NOTIUNKNOWN              EMAKEHR(0x11AF) // Typelib import: Interface not derived from IUnknown.

#define TLBX_E_NONVISIBLEVALUECLASS     EMAKEHR(0x11B0) // Typelib export: Non COM visible value type in method signature.
#define TLBX_E_LPTSTR_NOT_ALLOWED       EMAKEHR(0x11B1) // Typelib export: Types which contain the native type NATIVE_TYPE_LPTSTR are not allowed to be exported to COM.
#define TLBX_E_AUTO_CS_NOT_ALLOWED      EMAKEHR(0x11B2) // Typelib export: Types with a char set of auto are not allowed to be exported to COM.
#define TLBX_S_NOSTDINTERFACE           SMAKEHR(0x11B3) // Typelib export: Found an interface marked as IID_IDispatch or IID_IUnknown.
#define TLBX_S_DUPLICATE_DISPID         SMAKEHR(0x11B4) // Typelib export: duplicate dispid found; ignored.
#define TLBX_E_ENUM_VALUE_INVALID       EMAKEHR(0x11B5) // Typelib export: The enum value is not legal for a typelib.
#define TLBX_E_DUPLICATE_IID            EMAKEHR(0x11B6) // Typelib export: Duplicate IID
#define TLBX_E_NO_NESTED_ARRAYS         EMAKEHR(0x11B7) // Tyeplib export: detected nested arrays.
#define TLBX_E_PARAM_ERROR_NAMED        EMAKEHR(0x11B8) // Typelib import: param type couldn't be converted.
#define TLBX_E_PARAM_ERROR_UNNAMED      EMAKEHR(0x11B9) // Typelib import: param type couldn't be converted -- param name unknown.
#define TLBX_E_AGNOST_SIGNATURE         EMAKEHR(0x11BA) // TypeLib export: size agnostic element in signature.
#define TLBX_E_CONVERT_FAIL             EMAKEHR(0x11BB) // TypeLib export: exporter failed.
#define TLBX_W_DUAL_NOT_DISPATCH        EMAKEHR(0x11BC) // Typelib import: [dual] interface not derived from IDispatch.
#define TLBX_E_BAD_SIGNATURE            EMAKEHR(0x11BD) // Typelib export: unconvertable signature (use specific error for reporting!)
#define TLBX_E_ARRAY_NEEDS_NT_FIXED     EMAKEHR(0x11BE) // Typelib export: non-fixed/non-safearray array in struct
#define TLBX_E_CLASS_NEEDS_NT_INTF      EMAKEHR(0x11BF) // Typelib export: non-interface class in struct

#define META_E_CA_INVALID_TARGET        EMAKEHR(0x11C0) // Known custom attribute on invalid target.
#define META_E_CA_INVALID_VALUE         EMAKEHR(0x11C1) // Known custom attribute had invalid value.
#define META_E_CA_INVALID_BLOB          EMAKEHR(0x11C2) // Known custom attribute blob is bad format.
#define META_E_CA_REPEATED_ARG          EMAKEHR(0x11C3) // Known custom attribute blob has repeated named argument.
#define META_E_CA_UNKNOWN_ARGUMENT      EMAKEHR(0x11C4) // Known custom attrubte named arg not recognized.
#define META_E_CA_VARIANT_NYI           EMAKEHR(0x11C5) // Known attribute named argument doesn't support variant.
#define META_E_CA_ARRAY_NYI             EMAKEHR(0x11C6) // Known attribute named argument doesn't support array.
#define META_E_CA_UNEXPECTED_TYPE       EMAKEHR(0x11C7) // Known attribute parser found unexpected type.
#define META_E_CA_INVALID_ARGTYPE       EMAKEHR(0x11C8) // Known attribute parser only handles fields -- no properties.
#define META_E_CA_INVALID_ARG_FOR_TYPE  EMAKEHR(0x11C9) // Known attribute parser found an argument that is invalid for the object it is applied to.
#define META_E_CA_INVALID_UUID          EMAKEHR(0x11CA) // The format of the UUID was invalid.
#define META_E_CA_INVALID_MARSHALAS_FIELDS EMAKEHR(0x11CB) // The MarshalAs attribute has fields set that are not valid for the specified unmanaged type.
#define META_E_CA_NT_FIELDONLY          EMAKEHR(0x11CC) // The specified unmanaged type is only valid on fields.
#define META_E_CA_NEGATIVE_PARAMINDEX   EMAKEHR(0x11CD) // The parameter index cannot be negative.
#define META_E_CA_NEGATIVE_MULTIPLIER   EMAKEHR(0x11CE) // The multiplier cannot be negative.
#define META_E_CA_NEGATIVE_CONSTSIZE    EMAKEHR(0x11CF) // The constant size cannot be negative.

#define META_E_CA_FIXEDSTR_SIZE_REQUIRED EMAKEHR(0x11D0) // A fixed string requires a size.
#define META_E_CA_CUSTMARSH_TYPE_REQUIRED EMAKEHR(0x11D1) // A custom marshaler requires the custom marshaler type.
#define META_E_CA_FILENAME_REQUIRED     EMAKEHR(0x11D2) // A DllImport attribute requires a filename.
#define TLBX_W_NO_PROPS_IN_EVENTS       EMAKEHR(0x11D3) // TypeLib import: Detected properties in a source dispinterface.
#define META_E_NOT_IN_ENC_MODE          EMAKEHR(0x11D4) // SaveDelta was called without being in EnC mode
#define TLBX_W_ENUM_VALUE_TOOBIG        SMAKEHR(0x11D5) // Typelib export: The enum value is not legal for a typelib.
#define META_E_METHOD_COUNTS            EMAKEHR(0x11D6) // Merge: different method counts in import and emit scopes.
#define META_E_FIELD_COUNTS             EMAKEHR(0x11D7) // Merge: different field counts in import and emit scopes.
#define META_E_PARAM_COUNTS             EMAKEHR(0x11D8) // Merge: different param counts in import and emit scopes.
#define TLBX_W_EXPORTING_AUTO_LAYOUT    SMAKEHR(0x11D9) // TypeLib export: Exporting an auto-layout type.
#define TLBX_E_TYPED_REF                EMAKEHR(0x11DA) // TypeLib export: Exporting a TypedReference.
#define TLBX_W_DEFAULT_INTF_NOT_VISIBLE SMAKEHR(0x11DB) // TypeLib export: ComDefaultInterface is not COMVisible.
#define TLBX_W_BAD_SAFEARRAYFIELD_NO_ELEMENTVT SMAKEHR(0x11DE) // TypeLib export: System.Array SAFEARRAY field without a SafeArraySubType.
#define TLBX_W_LAYOUTCLASS_AS_INTERFACE SMAKEHR(0x11DF) // TypeLib export: Class with layout parameter of field marked with UnmanagedType.Interface
#define TLBX_I_GENERIC_BASE_TYPE        SMAKEHR(0x11E0) // TypeLib export: type deriving from a generic type.
#define TLBX_E_BITNESS_MISMATCH         EMAKEHR(0x11E1) // TypeLib export: bitness of assembly doesn't match bitness of output type library
#define TLBX_E_EVENT_WITH_NEWENUM       EMAKEHR(0x11E2) // TypeLib import: source interface with NewEnum member.
#define TLBX_E_PROPGET_WITHOUT_RETURN   EMAKEHR(0x11E3) // TypeLib import: propget without return type
#define META_E_MISMATCHED_VISIBLITY     EMAKEHR(0x11E4) // Merge - Match found for type/method/etc but differs in visiblity 
#define META_E_CA_BAD_FRIENDS_ARGS      EMAKEHR(0x11E5) // InternalsVisibileTo can't have a version, culture, or processor architecture 
#define META_E_CA_FRIENDS_SN_REQUIRED   EMAKEHR(0x11E6) // Strong-name signed assemblies can only grant friend access to strong name-signed assemblies


// Return values from validator functions.
#define VLDTR_S_WRN                     SMAKEHR(0x1200) // Warnings found in the validator.
#define VLDTR_S_ERR                     SMAKEHR(0x1201) // Errors found in the validator.
#define VLDTR_S_WRNERR                  SMAKEHR(0x1202) // Warnings and errors found in the validator.

// Validator structural errors.
#define VLDTR_E_RID_OUTOFRANGE          EMAKEHR(0x1203) // Rid is out of range.
#define VLDTR_E_CDTKN_OUTOFRANGE        EMAKEHR(0x1204) // Coded token type is out of range.
#define VLDTR_E_CDRID_OUTOFRANGE        EMAKEHR(0x1205) // Coded rid is out of range.
#define VLDTR_E_STRING_INVALID          EMAKEHR(0x1206) // String offset is invalid.
#define VLDTR_E_GUID_INVALID            EMAKEHR(0x1207) // GUID offset is invalid.
#define VLDTR_E_BLOB_INVALID            EMAKEHR(0x1208) // Blob offset if invalid.

// Validator semantic errors.
#define VLDTR_E_MOD_MULTI               EMAKEHR(0x1209) // Multiple module records found.
#define VLDTR_E_MOD_NULLMVID            EMAKEHR(0x120A) // Module has null MVID.
#define VLDTR_E_TR_NAMENULL             EMAKEHR(0x120B) // TypeRef name is NULL.
#define VLDTR_E_TR_DUP                  EMAKEHR(0x120C) // TypeRef has a dup.
#define VLDTR_E_TD_NAMENULL             EMAKEHR(0x120D) // TypeDef name is NULL.
#define VLDTR_E_TD_DUPNAME              EMAKEHR(0x120E) // TypeDef has a dup based on name+namespace.
#define VLDTR_E_TD_DUPGUID              EMAKEHR(0x120F) // TypeDef has a dup based on GUID.
#define VLDTR_E_TD_NOTIFACEOBJEXTNULL   EMAKEHR(0x1210) // TypeDef that's not an Interface and not System.Object extends nil parent.
#define VLDTR_E_TD_OBJEXTENDSNONNULL    EMAKEHR(0x1211) // System.Object extends a non-nil parent.
#define VLDTR_E_TD_EXTENDSSEALED        EMAKEHR(0x1212) // TypeDef extends sealed class.
#define VLDTR_E_TD_DLTNORTSPCL          EMAKEHR(0x1213) // TypeDef is Deleted but not marked with RTSpecialName.
#define VLDTR_E_TD_RTSPCLNOTDLT         EMAKEHR(0x1214) // TypeDef is marked RTSpecialName, but is not a Deleted record.
#define VLDTR_E_MI_DECLPRIV             EMAKEHR(0x1215) // MethodImpl's Decl is private
#define VLDTR_E_AS_BADNAME              EMAKEHR(0x1216) // Assembly [Ref] name has path and/or extension.
#define VLDTR_E_FILE_SYSNAME            EMAKEHR(0x1217) // File has a system name (con, com, aux, etc.).
#define VLDTR_E_MI_BODYSTATIC           EMAKEHR(0x1218) // MethodImpl's body is static.
#define VLDTR_E_TD_IFACENOTABS          EMAKEHR(0x1219) // TypeDef is marked Interface but not Abstract.
#define VLDTR_E_TD_IFACEPARNOTNIL       EMAKEHR(0x121A) // TypeDef is marked Interface but parent is not Nil.
#define VLDTR_E_TD_IFACEGUIDNULL        EMAKEHR(0x121B) // TypeDef is marked Interface but GUID is NULL.
#define VLDTR_E_MI_DECLFINAL            EMAKEHR(0x121C) // TMethodImpl's Decl is final.
#define VLDTR_E_TD_VTNOTSEAL            EMAKEHR(0x121D) // TypeDef is marked ValueType but not marked Sealed.
#define VLDTR_E_PD_BADFLAGS             EMAKEHR(0x121E) // Param has extra bits in flags.
#define VLDTR_E_IFACE_DUP               EMAKEHR(0x121F) // InterfaceImpl has a dup.
#define VLDTR_E_MR_NAMENULL             EMAKEHR(0x1220) // MemberRef name is NULL.
#define VLDTR_E_MR_VTBLNAME             EMAKEHR(0x1221) // MemberRef has an invalid name, _VtblGap*.
#define VLDTR_E_MR_DELNAME              EMAKEHR(0x1222) // MemberRef has an invalid name, _Deleted*.
#define VLDTR_E_MR_PARNIL               EMAKEHR(0x1223) // MemberRef parent Nil in a PE file.
#define VLDTR_E_MR_BADCALLINGCONV       EMAKEHR(0x1224) // MemberRef has invalid calling convention.
#define VLDTR_E_MR_NOTVARARG            EMAKEHR(0x1225) // MemberRef has Method parent but calling convention is not VARARG.
#define VLDTR_E_MR_NAMEDIFF             EMAKEHR(0x1226) // MemberRef name different from parent MethodDef.
#define VLDTR_E_MR_SIGDIFF              EMAKEHR(0x1227) // MemberRef signature different from parent MethodDef.
#define VLDTR_E_MR_DUP                  EMAKEHR(0x1228) // MemberRef has a dup.
#define VLDTR_E_CL_TDAUTO               EMAKEHR(0x1229) // ClassLayout parent TypeDef is marked AutoLayout.
#define VLDTR_E_CL_BADPCKSZ             EMAKEHR(0x122A) // ClassLayout has bad PackingSize.
#define VLDTR_E_CL_DUP                  EMAKEHR(0x122B) // ClassLayout has dup.
#define VLDTR_E_FL_BADOFFSET            EMAKEHR(0x122C) // FieldLayout2 has bad offset.
#define VLDTR_E_FL_TDNIL                EMAKEHR(0x122D) // FieldLayout2 has field with nil parent.
#define VLDTR_E_FL_NOCL                 EMAKEHR(0x122E) // FieldLayout2 has no ClassLayout record.
#define VLDTR_E_FL_TDNOTEXPLCT          EMAKEHR(0x122F) // FieldLayout2 parent TypeDef is not marked with ExplicitLayout.
#define VLDTR_E_FL_FLDSTATIC            EMAKEHR(0x1230) // FieldLayout2 has field marked Static.
#define VLDTR_E_FL_DUP                  EMAKEHR(0x1231) // FieldLayout2 has a dup.
#define VLDTR_E_MODREF_NAMENULL         EMAKEHR(0x1232) // ModuleRef name is NULL.
#define VLDTR_E_MODREF_DUP              EMAKEHR(0x1233) // ModuleRef has a dup.
#define VLDTR_E_TR_BADSCOPE             EMAKEHR(0x1234) // TypeRef has a bad resolution scope.
#define VLDTR_E_TD_NESTEDNOENCL         EMAKEHR(0x1235) // TypeDef marked nested has no encloser.
#define VLDTR_E_TD_EXTTRRES             EMAKEHR(0x1236) // TypeDef extends a TypeRef which resolves to a TypeDef in the same module.
#define VLDTR_E_SIGNULL                 EMAKEHR(0x1237) // Signature specified is zero-sized.
#define VLDTR_E_SIGNODATA               EMAKEHR(0x1238) // Signature does not have enough data at specified byte.
#define VLDTR_E_MD_BADCALLINGCONV       EMAKEHR(0x1239) // Method signature has invalid calling convention.
#define VLDTR_E_MD_THISSTATIC           EMAKEHR(0x123A) // Method is marked static but has HASTHIS/EXPLICITTHIS set on the calling convention.
#define VLDTR_E_MD_NOTTHISNOTSTATIC     EMAKEHR(0x123B) // Method is not marked static but is not HASTHIS/EXPLICITTHIS.
#define VLDTR_E_MD_NOARGCNT             EMAKEHR(0x123C) // Method signature is missing the argument count.
#define VLDTR_E_SIG_MISSELTYPE          EMAKEHR(0x123D) // Signature missing element type.
#define VLDTR_E_SIG_MISSTKN             EMAKEHR(0x123E) // Signature missing token.
#define VLDTR_E_SIG_TKNBAD              EMAKEHR(0x123F) // Signature has bad token.
#define VLDTR_E_SIG_MISSFPTR            EMAKEHR(0x1240) // Signature is missing function pointer.
#define VLDTR_E_SIG_MISSFPTRARGCNT      EMAKEHR(0x1241) // Signature has function pointer missing argument count.
#define VLDTR_E_SIG_MISSRANK            EMAKEHR(0x1242) // Signature is missing rank specification.
#define VLDTR_E_SIG_MISSNSIZE           EMAKEHR(0x1243) // Signature is missing count of sized dimensions.
#define VLDTR_E_SIG_MISSSIZE            EMAKEHR(0x1244) // Signature is missing size of dimension.
#define VLDTR_E_SIG_MISSNLBND           EMAKEHR(0x1245) // Signature is missing count of lower bounds.
#define VLDTR_E_SIG_MISSLBND            EMAKEHR(0x1246) // Signature is missing a lower bound.
#define VLDTR_E_SIG_BADELTYPE           EMAKEHR(0x1247) // Signature has bad element type.
#define VLDTR_E_SIG_MISSVASIZE          EMAKEHR(0x1248) // Signature has value array missing size.
#define VLDTR_E_FD_BADCALLINGCONV       EMAKEHR(0x1249) // Field signature has invalid calling convention.
#define VLDTR_E_MD_NAMENULL             EMAKEHR(0x124A) // Method name is NULL.
#define VLDTR_E_MD_PARNIL               EMAKEHR(0x124B) // Method has parent NIL.
#define VLDTR_E_MD_DUP                  EMAKEHR(0x124C) // Method has dup.
#define VLDTR_E_FD_NAMENULL             EMAKEHR(0x124D) // Field name is NULL.
#define VLDTR_E_FD_PARNIL               EMAKEHR(0x124E) // Field parent is Nil.
#define VLDTR_E_FD_DUP                  EMAKEHR(0x124F) // Field has dup.
#define VLDTR_E_AS_MULTI                EMAKEHR(0x1250) // Multiple Assembly records found.
#define VLDTR_E_AS_NAMENULL             EMAKEHR(0x1251) // Assembly name is NULL.
#define VLDTR_E_SIG_TOKTYPEMISMATCH     EMAKEHR(0x1252) // E_T_VALUETYPE<class token> or E_T_CLASS<vtype token>.
#define VLDTR_E_CL_TDINTF               EMAKEHR(0x1253) // Class layout on an Interface.
#define VLDTR_E_ASOS_OSPLTFRMIDINVAL    EMAKEHR(0x1254) // AssemblyOS platform ID invalid.
#define VLDTR_E_AR_NAMENULL             EMAKEHR(0x1255) // AssemblyRef name is NULL.
#define VLDTR_E_TD_ENCLNOTNESTED        EMAKEHR(0x1256) // TypeDef not nested has encloser.
#define VLDTR_E_AROS_OSPLTFRMIDINVAL    EMAKEHR(0x1257) // AssemblyRefOS has invalid platform ID.
#define VLDTR_E_FILE_NAMENULL           EMAKEHR(0x1258) // File name is NULL.
#define VLDTR_E_CT_NAMENULL             EMAKEHR(0x1259) // ExportedType name is NULL.
#define VLDTR_E_TD_EXTENDSCHILD         EMAKEHR(0x125A) // TypeDef extends its own child.
#define VLDTR_E_MAR_NAMENULL            EMAKEHR(0x125B) // ManifestResource name is NULL.
#define VLDTR_E_FILE_DUP                EMAKEHR(0x125C) // File has dup.
#define VLDTR_E_FILE_NAMEFULLQLFD       EMAKEHR(0x125D) // File name is fully qualified.
#define VLDTR_E_CT_DUP                  EMAKEHR(0x125E) // ExportedType has dup.
#define VLDTR_E_MAR_DUP                 EMAKEHR(0x125F) // ManifestResource has dup.
#define VLDTR_E_MAR_NOTPUBPRIV          EMAKEHR(0x1260) // ManifestResource is neither Public not Private.
#define VLDTR_E_TD_ENUMNOVALUE          EMAKEHR(0x1261) // Enum has no "value__" field.
#define VLDTR_E_TD_ENUMVALSTATIC        EMAKEHR(0x1262) // Enum's "value__" field is static.
#define VLDTR_E_TD_ENUMVALNOTSN         EMAKEHR(0x1263) // Enum's "value__" field is not SpecialName.
#define VLDTR_E_TD_ENUMFLDNOTST         EMAKEHR(0x1264) // Enum's field is not static.
#define VLDTR_E_TD_ENUMFLDNOTLIT        EMAKEHR(0x1265) // Enum's field is not literal.
#define VLDTR_E_TD_ENUMNOLITFLDS        EMAKEHR(0x1266) // Enum has no literal fields.
#define VLDTR_E_TD_ENUMFLDSIGMISMATCH   EMAKEHR(0x1267) // Enum's field sig does not match value__ sig.
#define VLDTR_E_TD_ENUMVALNOT1ST        EMAKEHR(0x1268) // Enum's "value__" field is not first.
#define VLDTR_E_FD_NOTVALUERTSN         EMAKEHR(0x1269) // Field is RTSpecialName but name is not "value__".
#define VLDTR_E_FD_VALUEPARNOTENUM      EMAKEHR(0x126A) // Field "value__" in not Enum class.
#define VLDTR_E_FD_INSTINIFACE          EMAKEHR(0x126B) // Instance field in interface.
#define VLDTR_E_FD_NOTPUBINIFACE        EMAKEHR(0x126C) // Non-public field in interface.
#define VLDTR_E_FMD_GLOBALNOTPUBPRIVSC  EMAKEHR(0x126D) // Global field/method neither Public nor PrivateScope.
#define VLDTR_E_FMD_GLOBALNOTSTATIC     EMAKEHR(0x126E) // Global field/method not static.
#define VLDTR_E_FD_GLOBALNORVA          EMAKEHR(0x126F) // Global field has no RVA.
#define VLDTR_E_MD_CTORZERORVA          EMAKEHR(0x1270) // .ctor,.cctor has zero RVA.
#define VLDTR_E_FD_MARKEDNOMARSHAL      EMAKEHR(0x1271) // Field is marked marshaled but has no marshaling rec.
#define VLDTR_E_FD_MARSHALNOTMARKED     EMAKEHR(0x1272) // Field has marshaling rec but is not marked marshaled.
#define VLDTR_E_FD_MARKEDNODEFLT        EMAKEHR(0x1273) // Field is marked HasDefault but has no const value.
#define VLDTR_E_FD_DEFLTNOTMARKED       EMAKEHR(0x1274) // Field has const value rec but is not marked HasDefault.
#define VLDTR_E_FMD_MARKEDNOSECUR       EMAKEHR(0x1275) // Field/method is marked HasSecurity but has no security rec.
#define VLDTR_E_FMD_SECURNOTMARKED      EMAKEHR(0x1276) // Field/method has security rec but is not marked HasSecurity.
#define VLDTR_E_FMD_PINVOKENOTSTATIC    EMAKEHR(0x1277) // Field/method is PInvoke but is not marked Static.
#define VLDTR_E_FMD_MARKEDNOPINVOKE     EMAKEHR(0x1278) // Field/method is marked PInvoke but has no ImplMap.
#define VLDTR_E_FMD_PINVOKENOTMARKED    EMAKEHR(0x1279) // Field/method has ImplMap but is not marked PInvoke.
#define VLDTR_E_FMD_BADIMPLMAP          EMAKEHR(0x127A) // Field/method has invalid ImplMap
#define VLDTR_E_IMAP_BADMODREF          EMAKEHR(0x127B) // ImplMap has invalid ModuleRef
#define VLDTR_E_IMAP_BADMEMBER          EMAKEHR(0x127C) // ImplMap has invalid MemberForwarded
#define VLDTR_E_IMAP_BADIMPORTNAME      EMAKEHR(0x127D) // ImplMap has invalid ImportName
#define VLDTR_E_IMAP_BADCALLCONV        EMAKEHR(0x127E) // ImplMap has invalid call conv
#define VLDTR_E_FMD_BADACCESSFLAG       EMAKEHR(0x127F) // Field/method has invalid access flag
#define VLDTR_E_FD_INITONLYANDLITERAL   EMAKEHR(0x1280) // Field is InitOnly and Literal
#define VLDTR_E_FD_LITERALNOTSTATIC     EMAKEHR(0x1281) // Field is Literal but not Static
#define VLDTR_E_FMD_RTSNNOTSN           EMAKEHR(0x1282) // Field/method is RTSpec.Name but not Spec.Name
#define VLDTR_E_MD_ABSTPARNOTABST       EMAKEHR(0x1283) // Method is abstract, parent is not
#define VLDTR_E_MD_NOTSTATABSTININTF    EMAKEHR(0x1284) // Method not static or abstract in interface
#define VLDTR_E_MD_NOTPUBININTF         EMAKEHR(0x1285) // Method not public in interface
#define VLDTR_E_MD_CTORININTF           EMAKEHR(0x1286) // ctor in interface
#define VLDTR_E_MD_GLOBALCTORCCTOR      EMAKEHR(0x1287) // global ctor or cctor
#define VLDTR_E_MD_CTORSTATIC           EMAKEHR(0x1288) // static ctor
#define VLDTR_E_MD_CTORNOTSNRTSN        EMAKEHR(0x1289) // ctor,cctor not marked SpecialName,RTSpecialName
#define VLDTR_E_MD_CTORVIRT             EMAKEHR(0x128A) // virtual ctor,cctor
#define VLDTR_E_MD_CTORABST             EMAKEHR(0x128B) // abstract ctor,cctor
#define VLDTR_E_MD_CCTORNOTSTATIC       EMAKEHR(0x128C) // instance cctor
#define VLDTR_E_MD_ZERORVA              EMAKEHR(0x128D) // RVA=0, method not abstract or pinvoke or runtime, or reverse
#define VLDTR_E_MD_FINNOTVIRT           EMAKEHR(0x128E) // Method is final and not virtual
#define VLDTR_E_MD_STATANDFINORVIRT     EMAKEHR(0x128F) // Method is static and final or virtual
#define VLDTR_E_MD_ABSTANDFINAL         EMAKEHR(0x1290) // Method is abstract and final
#define VLDTR_E_MD_ABSTANDIMPL          EMAKEHR(0x1291) // Method is abstract and implemented
#define VLDTR_E_MD_ABSTANDPINVOKE       EMAKEHR(0x1292) // Method is abstract and pinvoke
#define VLDTR_E_MD_ABSTNOTVIRT          EMAKEHR(0x1293) // Method is abstract and not virtual
#define VLDTR_E_MD_NOTABSTNOTIMPL       EMAKEHR(0x1294) // Method is not abstract and not implemented
#define VLDTR_E_MD_NOTABSTBADFLAGSRVA   EMAKEHR(0x1295) // Method is not abstract and not (RVA!=0 or pinvoke or runtime)
#define VLDTR_E_MD_PRIVSCOPENORVA       EMAKEHR(0x1296) // Method is PrivateScope and has RVA==0
#define VLDTR_E_MD_GLOBALABSTORVIRT     EMAKEHR(0x1297) // Global method is abstract or virtual
#define VLDTR_E_SIG_LONGFORM            EMAKEHR(0x1298) // Signature uses long form
#define VLDTR_E_MD_MULTIPLESEMANTICS    EMAKEHR(0x1299) // Method has multiple semantics (warning)
#define VLDTR_E_MD_INVALIDSEMANTICS     EMAKEHR(0x129A) // Method has invalid semantics (not event or prop)
#define VLDTR_E_MD_SEMANTICSNOTEXIST    EMAKEHR(0x129B) // Method has semantics assoc that does not exist
#define VLDTR_E_MI_DECLNOTVIRT          EMAKEHR(0x129C) // MethodImpl's Decl is not virtual
#define VLDTR_E_FMD_GLOBALITEM          EMAKEHR(0x129D) // Global field/method (warning,CLS)
#define VLDTR_E_MD_MULTSEMANTICFLAGS    EMAKEHR(0x129E) // Method has multiple semantic flags set
#define VLDTR_E_MD_NOSEMANTICFLAGS      EMAKEHR(0x129F) // Method has no semantic flags set
#define VLDTR_E_FD_FLDINIFACE           EMAKEHR(0x12A0) // Field in Interface (warning, CLS)
#define VLDTR_E_AS_HASHALGID            EMAKEHR(0x12A1) // Unrecognized Hash Alg ID (warning)
#define VLDTR_E_AS_PROCID               EMAKEHR(0x12A2) // Unrecognized Processor ID in Assembly(warning)
#define VLDTR_E_AR_PROCID               EMAKEHR(0x12A3) // Unrecognized Processor ID in AssemblyRef(warning)
#define VLDTR_E_CN_PARENTRANGE          EMAKEHR(0x12A4) // Constant: parent token out of range
#define VLDTR_E_AS_BADFLAGS             EMAKEHR(0x12A5) // Invalid flags in Assembly
#define VLDTR_E_TR_HASTYPEDEF           EMAKEHR(0x12A6) // There is TypeDef with same name as TypeRef (warning)
#define VLDTR_E_IFACE_BADIMPL           EMAKEHR(0x12A7) // In InterfaceImpl, the implementing token is not TypeDef
#define VLDTR_E_IFACE_BADIFACE          EMAKEHR(0x12A8) // In InterfaceImpl, the implemented token is not TypeDef or TypeRef
#define VLDTR_E_TD_SECURNOTMARKED       EMAKEHR(0x12A9) // TypeDef has security rec but not marked HasSecurity
#define VLDTR_E_TD_MARKEDNOSECUR        EMAKEHR(0x12AA) // TypeDef marked HasSecurity but has no security rec
#define VLDTR_E_MD_CCTORHASARGS         EMAKEHR(0x12AB) // .cctor has arguments
#define VLDTR_E_CT_BADIMPL              EMAKEHR(0x12AC) // ExportedType has invalid Implementation
#define VLDTR_E_MI_ALIENBODY            EMAKEHR(0x12AD) // MethodImpl has body from other class
#define VLDTR_E_MD_CCTORCALLCONV        EMAKEHR(0x12AE) // .cctor has invalid calling convention
#define VLDTR_E_MI_BADCLASS             EMAKEHR(0x12AF) // MethodImpl has invalid Class token
#define VLDTR_E_MI_CLASSISINTF          EMAKEHR(0x12B0) // MethodImpl declared in Interface
#define VLDTR_E_MI_BADDECL              EMAKEHR(0x12B1) // MethodImpl has invalid MethodDeclaration token
#define VLDTR_E_MI_BADBODY              EMAKEHR(0x12B2) // MethodImpl has invalid MethodBody token
#define VLDTR_E_MI_DUP                  EMAKEHR(0x12B3) // MethodImpl has duplicate
#define VLDTR_E_FD_BADPARENT            EMAKEHR(0x12B4) // Bad field parent
#define VLDTR_E_MD_PARAMOUTOFSEQ        EMAKEHR(0x12B5) // Param out of sequence (warning)
#define VLDTR_E_MD_PARASEQTOOBIG        EMAKEHR(0x12B6) // Param's sequence num exceeds num of args
#define VLDTR_E_MD_PARMMARKEDNOMARSHAL  EMAKEHR(0x12B7) // Param marked HasMarshal, has no marshaling info
#define VLDTR_E_MD_PARMMARSHALNOTMARKED EMAKEHR(0x12B8) // Param has marshaling info, not marked HasMarshal
#define VLDTR_E_MD_PARMMARKEDNODEFLT    EMAKEHR(0x12BA) // Param marked HasDefault, has no const value
#define VLDTR_E_MD_PARMDEFLTNOTMARKED   EMAKEHR(0x12BB) // Param has const value, not marked HasDefault
#define VLDTR_E_PR_BADSCOPE             EMAKEHR(0x12BC) // Prop has invalid scope
#define VLDTR_E_PR_NONAME               EMAKEHR(0x12BD) // Prop has no name
#define VLDTR_E_PR_NOSIG                EMAKEHR(0x12BE) // Prop has no signature
#define VLDTR_E_PR_DUP                  EMAKEHR(0x12BF) // Prop has a duplicate
#define VLDTR_E_PR_BADCALLINGCONV       EMAKEHR(0x12C0) // Prop has bad calling convention
#define VLDTR_E_PR_MARKEDNODEFLT        EMAKEHR(0x12C1) // Prop marked HasDefault, has no const value
#define VLDTR_E_PR_DEFLTNOTMARKED       EMAKEHR(0x12C2) // Prop has const value, not marked HasDefault
#define VLDTR_E_PR_BADSEMANTICS         EMAKEHR(0x12C3) // Prop has method not (Setter,Getter, or Other)
#define VLDTR_E_PR_BADMETHOD            EMAKEHR(0x12C4) // Prop has method with invalid token
#define VLDTR_E_PR_ALIENMETHOD          EMAKEHR(0x12C5) // Prop has method from another class
#define VLDTR_E_CN_BLOBNOTNULL          EMAKEHR(0x12C6) // Const has non-null blob when it should not
#define VLDTR_E_CN_BLOBNULL             EMAKEHR(0x12C7) // Const has null value blob
#define VLDTR_E_EV_BADSCOPE             EMAKEHR(0x12C8) // Event has invalid scope
#define VLDTR_E_EV_NONAME               EMAKEHR(0x12CA) // Event has no name
#define VLDTR_E_EV_DUP                  EMAKEHR(0x12CB) // Event has a duplicate
#define VLDTR_E_EV_BADEVTYPE            EMAKEHR(0x12CC) // Event has invalid EventType
#define VLDTR_E_EV_EVTYPENOTCLASS       EMAKEHR(0x12CD) // Event's EventType is not a class
#define VLDTR_E_EV_BADSEMANTICS         EMAKEHR(0x12CE) // Event has method not (AddOn,RemoveOn,Fire,Other)
#define VLDTR_E_EV_BADMETHOD            EMAKEHR(0x12CF) // Event has method with invalid token
#define VLDTR_E_EV_ALIENMETHOD          EMAKEHR(0x12D0) // Event has method from another class
#define VLDTR_E_EV_NOADDON              EMAKEHR(0x12D1) // Event has no AddOn method
#define VLDTR_E_EV_NOREMOVEON           EMAKEHR(0x12D2) // Event has no RemoveOn method
#define VLDTR_E_CT_DUPTDNAME            EMAKEHR(0x12D3) // ExportedType has same name as TypeDef
#define VLDTR_E_MAR_BADOFFSET           EMAKEHR(0x12D4) // MRes refers to non-PE file with offset !=0
#define VLDTR_E_DS_BADOWNER             EMAKEHR(0x12D5) // Decl.security has invalid owner token
#define VLDTR_E_DS_BADFLAGS             EMAKEHR(0x12D6) // Decl.security has invalid action flags
#define VLDTR_E_DS_NOBLOB               EMAKEHR(0x12D7) // Decl.security has no permission blob
#define VLDTR_E_MAR_BADIMPL             EMAKEHR(0x12D8) // Manifest resource has invalid Implementation
#define VLDTR_E_MR_VARARGCALLINGCONV    EMAKEHR(0x12DA) // MemberRef has VARARG calling conv. (CLS warning)
#define VLDTR_E_MD_CTORNOTVOID          EMAKEHR(0x12DB) // .ctor,.cctor returning not void
#define VLDTR_E_EV_FIRENOTVOID          EMAKEHR(0x12DC) // Fire method returning not void
#define VLDTR_E_AS_BADLOCALE            EMAKEHR(0x12DD) // Invalid locale
#define VLDTR_E_CN_PARENTTYPE           EMAKEHR(0x12DE) // Constant has parent of invalid type
#define VLDTR_E_SIG_SENTINMETHODDEF     EMAKEHR(0x12DF) // E_T_SENTINEL in MethodDef signature
#define VLDTR_E_SIG_SENTMUSTVARARG      EMAKEHR(0x12E0) // E_T_SENTINEL <=> VARARG
#define VLDTR_E_SIG_MULTSENTINELS       EMAKEHR(0x12E1) // Multiple E_T_SENTINELs
#define VLDTR_E_SIG_LASTSENTINEL        EMAKEHR(0x12E2) // E_T_SENTINEL not followed by type
#define VLDTR_E_SIG_MISSARG             EMAKEHR(0x12E3) // Signature missing argument
#define VLDTR_E_SIG_BYREFINFIELD        EMAKEHR(0x12E4) // Field of ByRef type
#define VLDTR_E_MD_SYNCMETHODINVTYPE    EMAKEHR(0x12E5) // Synchronized method in value class
#define VLDTR_E_TD_NAMETOOLONG          EMAKEHR(0x12E6) // TypeDef name too long
#define VLDTR_E_AS_PROCDUP              EMAKEHR(0x12E7) // Duplicate Assembly Processor
#define VLDTR_E_ASOS_DUP                EMAKEHR(0x12E8) // Duplicate Assembly OS (ID+ver.major+ver.minor)
#define VLDTR_E_MAR_BADFLAGS            EMAKEHR(0x12E9) // Manifest Resource has bad flags
#define VLDTR_E_CT_NOTYPEDEFID          EMAKEHR(0x12EA) // ExportedType has nil TypeDefId
#define VLDTR_E_FILE_BADFLAGS           EMAKEHR(0x12EB) // File has bad flags
#define VLDTR_E_FILE_NULLHASH           EMAKEHR(0x12EC) // File has no hash blob
#define VLDTR_E_MOD_NONAME              EMAKEHR(0x12ED) // Module has no name
#define VLDTR_E_MOD_NAMEFULLQLFD        EMAKEHR(0x12EE) // Module has fully-qualified name
#define VLDTR_E_TD_RTSPCLNOTSPCL        EMAKEHR(0x12EF) // TypeDef is tdRTSpecialName but not tdSpecialName
#define VLDTR_E_TD_EXTENDSIFACE         EMAKEHR(0x12F0) // TypeDef extends interface
#define VLDTR_E_MD_CTORPINVOKE          EMAKEHR(0x12F1) // .ctor,.cctor is PInvokeImpl
#define VLDTR_E_TD_SYSENUMNOTCLASS      EMAKEHR(0x12F2) // System.Enum is not a class
#define VLDTR_E_TD_SYSENUMNOTEXTVTYPE   EMAKEHR(0x12F3) // System.Enum extends not System.ValueType
#define VLDTR_E_MI_SIGMISMATCH          EMAKEHR(0x12F4) // MethodImpl's Decl and Body signatures mismatch
#define VLDTR_E_TD_ENUMHASMETHODS       EMAKEHR(0x12F5) // TypeDef extends System.Enum but has methods
#define VLDTR_E_TD_ENUMIMPLIFACE        EMAKEHR(0x12F6) // TypeDef extends System.Enum but impls interface(s)
#define VLDTR_E_TD_ENUMHASPROP          EMAKEHR(0x12F7) // TypeDef extends System.Enum but has prop(s)
#define VLDTR_E_TD_ENUMHASEVENT         EMAKEHR(0x12F8) // TypeDef extends System.Enum but has event(s)
#define VLDTR_E_TD_BADMETHODLST         EMAKEHR(0x12F9) // TypeDef has MethodList > Nmethods+1
#define VLDTR_E_TD_BADFIELDLST          EMAKEHR(0x12FA) // TypeDef has FieldList > Nfields+1
#define VLDTR_E_CN_BADTYPE              EMAKEHR(0x12FB) // Constant has wrong type
#define VLDTR_E_TD_ENUMNOINSTFLD        EMAKEHR(0x12FC) // Enum has no instance fields
#define VLDTR_E_TD_ENUMMULINSTFLD       EMAKEHR(0x12FD) // Enum has multiple instance fields


#define VLDTR_E_INTERRUPTED             EMAKEHR(0x12FE) // Validator has been interrupted by the VEHandler.
#define VLDTR_E_NOTINIT                 EMAKEHR(0x12FF) // Validator failed to initialize correctly.

#define VLDTR_E_IFACE_NOTIFACE          EMAKEHR(0x1B00) // Interface in InterfaceImpl is not marked tdInterface
#define VLDTR_E_FD_RVAHASNORVA          EMAKEHR(0x1B01) // Field marked fdHasFieldRVA but has no RVA rec
#define VLDTR_E_FD_RVAHASZERORVA        EMAKEHR(0x1B02) // Field marked fdHasFieldRVA has RVA =0
#define VLDTR_E_MD_RVAANDIMPLMAP        EMAKEHR(0x1B03) // Method has both RVA !=0 and ImplMap
#define VLDTR_E_TD_EXTRAFLAGS           EMAKEHR(0x1B04) // TypeDef has extraneous bits in flags
#define VLDTR_E_TD_EXTENDSITSELF        EMAKEHR(0x1B05) // TypeDef extends itself
#define VLDTR_E_TD_SYSVTNOTEXTOBJ       EMAKEHR(0x1B06) // System.ValueType does not extend System.Object
#define VLDTR_E_TD_EXTTYPESPEC          EMAKEHR(0x1B07) // Class extends TypeSpec (warning)
#define VLDTR_E_TD_VTNOSIZE             EMAKEHR(0x1B09) // Value Class has zero size
#define VLDTR_E_TD_IFACESEALED          EMAKEHR(0x1B0A) // Interface is sealed
#define VLDTR_E_NC_BADNESTED            EMAKEHR(0x1B0B) // Bad "nested" token in NestedClass
#define VLDTR_E_NC_BADENCLOSER          EMAKEHR(0x1B0C) // Bad "enclosing" token in NestedClass
#define VLDTR_E_NC_DUP                  EMAKEHR(0x1B0D) // Duplicate NestedClass record
#define VLDTR_E_NC_DUPENCLOSER          EMAKEHR(0x1B0E) // Duplicate NestedClass with different encloser
#define VLDTR_E_FRVA_ZERORVA            EMAKEHR(0x1B0F) // RVA=0 in FieldRVA record
#define VLDTR_E_FRVA_BADFIELD           EMAKEHR(0x1B10) // Invalid field token in FieldRVA record
#define VLDTR_E_FRVA_DUPRVA             EMAKEHR(0x1B11) // Duplicate RVA in FieldRVA record
#define VLDTR_E_FRVA_DUPFIELD           EMAKEHR(0x1B12) // Duplicate field in FieldRVA record
#define VLDTR_E_EP_BADTOKEN             EMAKEHR(0x1B13) // Bad token as entry point in CLR header
#define VLDTR_E_EP_INSTANCE             EMAKEHR(0x1B14) // Entry point in CLR header is a token of instance method
#define VLDTR_E_TD_ENUMFLDBADTYPE       EMAKEHR(0x1B15) // Enum has non-integral underlying type
#define VLDTR_E_MD_BADRVA               EMAKEHR(0x1B16) // Method has bogus RVA
#define VLDTR_E_FD_LITERALNODEFAULT     EMAKEHR(0x1B17) // Literal field has no const value
#define VLDTR_E_IFACE_METHNOTIMPL       EMAKEHR(0x1B18) // Class implementing an interface doesn't impl.one of methods
#define VLDTR_E_CA_BADPARENT            EMAKEHR(0x1B19) // CA has invalid owner
#define VLDTR_E_CA_BADTYPE              EMAKEHR(0x1B1A) // CA has invalid type
#define VLDTR_E_CA_NOTCTOR              EMAKEHR(0x1B1B) // CA type is not .ctor
#define VLDTR_E_CA_BADSIG               EMAKEHR(0x1B1C) // CA type has bad signature
#define VLDTR_E_CA_NOSIG                EMAKEHR(0x1B1D) // CA type has no signature
#define VLDTR_E_CA_BADPROLOG            EMAKEHR(0x1B1E) // CA blob has bad prolog (not 0x01 0x00)
#define VLDTR_E_MD_BADLOCALSIGTOK       EMAKEHR(0x1B1F) // Method has invalid LocalSig token
#define VLDTR_E_MD_BADHEADER            EMAKEHR(0x1B20) // Method has invalid header
#define VLDTR_E_EP_TOOMANYARGS          EMAKEHR(0x1B21) // Entry point has more than one arg
#define VLDTR_E_EP_BADRET               EMAKEHR(0x1B22) // Entry point has bad return type
#define VLDTR_E_EP_BADARG               EMAKEHR(0x1B23) // Entry point has bad argument
#define VLDTR_E_SIG_BADVOID             EMAKEHR(0x1B24) // Illegal "void" in signature
#define VLDTR_E_IFACE_METHMULTIMPL      EMAKEHR(0x1B25) // Multiple implementation of method
//@GENERICS
#define VLDTR_E_GP_NAMENULL             EMAKEHR(0x1B26) // GenericParam name is NULL
#define VLDTR_E_GP_OWNERNIL             EMAKEHR(0x1B27) // GenericParam has nil owner.
#define VLDTR_E_GP_DUPNAME              EMAKEHR(0x1B28) // GenericParam has duplicate by owner and name.
#define VLDTR_E_GP_DUPNUMBER            EMAKEHR(0x1B29) // GenericParam has duplicate by owner and number.
#define VLDTR_E_GP_NONSEQ_BY_OWNER      EMAKEHR(0x1B2A) // GenericParam is non sequential by owner
#define VLDTR_E_GP_NONSEQ_BY_NUMBER     EMAKEHR(0x1B2B) // GenericParam is non sequential by number
#define VLDTR_E_GP_UNEXPECTED_OWNER_FOR_VARIANT_VAR EMAKEHR(0x1B2C) // GenericParam has variance but its owner is not an interface or delegate
#define VLDTR_E_GP_ILLEGAL_VARIANT_MVAR  EMAKEHR(0x1B2D) // GenericParam is a method type parameter and must be non-variant
#define VLDTR_E_GP_ILLEGAL_VARIANCE_FLAGS  EMAKEHR(0x1B2E) // GenericParam has illegal value for variance flags
#define VLDTR_E_GP_REFANDVALUETYPE      EMAKEHR(0x1B2F) // GenericParam has incompatible special constraints reference type and valuetype
#define VLDTR_E_GPC_OWNERNIL            EMAKEHR(0x1B30) // GenericParamConstraint has nil owner
#define VLDTR_E_GPC_DUP                 EMAKEHR(0x1B31) // GenericParamConstraint has duplicate by owner and constraint
#define VLDTR_E_GPC_NONCONTIGUOUS       EMAKEHR(0x1B32) // GenericParamConstraint is non-contiguous with preceeding constraints for same owner
#define VLDTR_E_MS_METHODNIL            EMAKEHR(0x1B33)  // MethodSpec has nil method
#define VLDTR_E_MS_DUP                  EMAKEHR(0x1B34)  // MethodSpec has duplicate based own method and instantiation
#define VLDTR_E_MS_BADCALLINGCONV       EMAKEHR(0x1B35)  // MethodSpec signature has invalid calling convention
#define VLDTR_E_MS_MISSARITY            EMAKEHR(0x1B36)    // MethodSpec signature is missing arity specification
#define VLDTR_E_MS_MISSARG              EMAKEHR(0x1B37)    // MethodSpec signature is missing type argument
#define VLDTR_E_MS_ARITYMISMATCH        EMAKEHR(0x1B38)    // MethodSpec arity of generic method and instantiation do not match
#define VLDTR_E_MS_METHODNOTGENERIC     EMAKEHR(0x1B39)    // MethodSpec method is not generic
#define VLDTR_E_SIG_MISSARITY           EMAKEHR(0x1B3A)    // Signature missing arity of instantiated generic type
#define VLDTR_E_SIG_ARITYMISMATCH       EMAKEHR(0x1B3B)    // Signature has generic type of arity instantiated at different arity
#define VLDTR_E_MD_GENERIC_CCTOR        EMAKEHR(0x1B3C)    // Method cannot be both generic and a class constructor
#define VLDTR_E_MD_GENERIC_CTOR         EMAKEHR(0x1B3D)    // Method cannot be both generic and an instance constructor
#define VLDTR_E_MD_GENERIC_IMPORT       EMAKEHR(0x1B3E)    // Method cannot be both generic and defined on an imported type
#define VLDTR_E_MD_GENERIC_BADCALLCONV  EMAKEHR(0x1B3F)    // Method cannot be both generic and have non-default calling convention
#define VLDTR_E_EP_GENERIC_METHOD       EMAKEHR(0x1B40)    // Entry point in CLR header is the token for a generic method
#define VLDTR_E_MD_MISSARITY            EMAKEHR(0x1B41)    // Method signature is generic but is missing its arity
#define VLDTR_E_MD_ARITYZERO            EMAKEHR(0x1B42)    // Method signature is generic but its arity is zero
#define VLDTR_E_SIG_ARITYZERO           EMAKEHR(0x1B43)    // Signature has generic type instantiated at arity 0
#define VLDTR_E_MS_ARITYZERO            EMAKEHR(0x1B44)    // MethodSpec signature has arity 0
#define VLDTR_E_MD_GPMISMATCH           EMAKEHR(0x1B45)    // MethodDef signature has arity n but owns m GenericParams
#define VLDTR_E_EP_GENERIC_TYPE         EMAKEHR(0x1B46)    // Entry point in CLR header is the token for a method in a generic type
#define VLDTR_E_MI_DECLNOTGENERIC       EMAKEHR(0x1B47)    // MethodImpl overrides non-generic method with generic method
#define VLDTR_E_MI_IMPLNOTGENERIC       EMAKEHR(0x1B48)    // MethodImpl overrides non-generic method with generic method
#define VLDTR_E_MI_ARITYMISMATCH        EMAKEHR(0x1B49)    // MethodImpl overrides generic method of arity n with generic method of arity m
#define VLDTR_E_TD_EXTBADTYPESPEC       EMAKEHR(0x1B4A)    // TypeDef extends a TypeSpec that is not an instantiated type
#define VLDTR_E_SIG_BYREFINST           EMAKEHR(0x1B4B)    // Signature has type instantiated at byref at offset i
#define VLDTR_E_MS_BYREFINST            EMAKEHR(0x1B4C)    // Signature has type instantiated at byref at offset i
#define VLDTR_E_TS_EMPTY                EMAKEHR(0x1B4D)    // TypeSpec has empty signature
#define VLDTR_E_TS_HASSENTINALS         EMAKEHR(0x1B4E)    // TypeSpec has signature containing one or more sentinals
#define VLDTR_E_TD_GENERICHASEXPLAYOUT  EMAKEHR(0x1B4F)    // TypeDef is generic but has explicit layout
#define VLDTR_E_SIG_BADTOKTYPE          EMAKEHR(0x1B50)    // Signature has token following ELEMENT_TYPE_CLASS (_VALUETYPE) that is not a TypeDef or TypeRef
#define VLDTR_E_IFACE_METHNOTIMPLTHISMOD EMAKEHR(0x1B51)   // Warn:Class doesn't implement interface method in this module

//**** Common Language Runtime Debugging Services errors
#define CORDBG_E_UNRECOVERABLE_ERROR                    EMAKEHR(0x1300) // Unrecoverable API error.
#define CORDBG_E_PROCESS_TERMINATED                     EMAKEHR(0x1301) // Process was terminated.
#define CORDBG_E_PROCESS_NOT_SYNCHRONIZED               EMAKEHR(0x1302) // Process not synchronized.
#define CORDBG_E_CLASS_NOT_LOADED                       EMAKEHR(0x1303) // A class is not loaded.
#define CORDBG_E_IL_VAR_NOT_AVAILABLE                   EMAKEHR(0x1304) // An IL variable is not available at the
                                                                        // current native IP.
#define CORDBG_E_BAD_REFERENCE_VALUE                    EMAKEHR(0x1305) // A reference value was found to be bad
                                                                        // during dereferencing.
#define CORDBG_E_FIELD_NOT_AVAILABLE                    EMAKEHR(0x1306) // A field in a class is not available,
                                                                        // because the runtime optimized it away.
#define CORDBG_E_NON_NATIVE_FRAME                       EMAKEHR(0x1307) // "Native frame only" operation on
                                                                        // non-native frame
#define CORDBG_E_NONCONTINUABLE_EXCEPTION               EMAKEHR(0x1308) // Continue on non-continuable exception
#define CORDBG_E_CODE_NOT_AVAILABLE                     EMAKEHR(0x1309) // The code is currently unavailable
#define CORDBG_E_FUNCTION_NOT_IL                        EMAKEHR(0x130A) // Attempt to get a ICorDebugFunction for
                                                                        // a function that is not IL.
#define CORDBG_S_BAD_START_SEQUENCE_POINT               SMAKEHR(0x130B) // Attempt to SetIP not at a sequence point
#define CORDBG_S_BAD_END_SEQUENCE_POINT                 SMAKEHR(0x130C) // Attempt to SetIP when not going to a
                                                                        // sequence point.  If both this and
                                                                        // CORDBG_E_BAD_START_SEQUENCE_POINT are
                                                                        // true, only CORDBG_E_BAD_START_SEQUENCE_POINT
                                                                        // will be reported.
#define CORDBG_S_INSUFFICIENT_INFO_FOR_SET_IP           SMAKEHR(0x130D) // SetIP is possible, but the debugger doesn't
                                                                        // have enough info to fix variable locations,
                                                                        // GC refs, or anything else. Use at your own
                                                                        // risk.
#define CORDBG_E_CANT_SET_IP_INTO_FINALLY               EMAKEHR(0x130E) // SetIP isn't possible, because SetIP would
                                                                        // move EIP from outside of an exception
                                                                        // handling finally clause to a point inside
                                                                        // of one.
#define CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY             EMAKEHR(0x130F) // SetIP isn't possible because it would move
                                                                        // EIP from within an exception handling finally
                                                                        // clause to a point outside of one.
#define CORDBG_E_CANT_SET_IP_INTO_CATCH                 EMAKEHR(0x1310) // SetIP isn't possible, because SetIP would
                                                                        // move EIP from outside of an exception
                                                                        // handling catch clause to a point inside of
                                                                        // one.
#define CORDBG_E_SET_IP_NOT_ALLOWED_ON_NONLEAF_FRAME    EMAKEHR(0x1311) // Setip cannot be done on any frame except
                                                                        // the leaf frame.
#define CORDBG_E_SET_IP_IMPOSSIBLE                      EMAKEHR(0x1312) // SetIP isn't allowed. For example, there is
                                                                        // insufficient memory to perform SetIP.
#define CORDBG_E_FUNC_EVAL_BAD_START_POINT              EMAKEHR(0x1313) // Func eval can't work if we're, for example,
                                                                        // not stopped at a GC safe point.
#define CORDBG_E_INVALID_OBJECT                         EMAKEHR(0x1314) // This object value is no longer valid.
#define CORDBG_E_FUNC_EVAL_NOT_COMPLETE                 EMAKEHR(0x1315) // If you call CordbEval::GetResult before the
                                                                        // func eval has finished, you'll get this
                                                                        // result.
#define CORDBG_S_FUNC_EVAL_HAS_NO_RESULT                SMAKEHR(0x1316) // Some Func evals will lack a return value,
                                                                        // such as those whose return type is void.
#define CORDBG_S_VALUE_POINTS_TO_VOID                   SMAKEHR(0x1317) // The Debugging API doesn't support
                                                                        // dereferencing pointers of type void.
#define CORDBG_E_INPROC_NOT_IMPL                        EMAKEHR(0x1318) // The inproc version of the debugging API
                                                                        // doesn't implement this function,
#define CORDBG_S_FUNC_EVAL_ABORTED                      SMAKEHR(0x1319) // The func eval completed, but was aborted.
#define CORDBG_E_STATIC_VAR_NOT_AVAILABLE               EMAKEHR(0x131A) // A static variable isn't available because
                                                                        // it hasn't been initialized yet.
#define CORDBG_E_OBJECT_IS_NOT_COPYABLE_VALUE_CLASS     EMAKEHR(0x131B) // Can't copy a VC with object refs in it.
#define CORDBG_E_CANT_SETIP_INTO_OR_OUT_OF_FILTER       EMAKEHR(0x131C) // SetIP can't leave or enter a filter
#define CORDBG_E_CANT_CHANGE_JIT_SETTING_FOR_ZAP_MODULE EMAKEHR(0x131D) // You can't change JIT settings for ZAP
                                                                        // modules.
#define CORDBG_E_CANT_SET_IP_OUT_OF_FINALLY_ON_WIN64    EMAKEHR(0x131E) // SetIP isn't possible because it would move
                                                                        // EIP from within a finally clause to a point
                                                                        // outside of one on WIN64 platforms.
#define CORDBG_E_CANT_SET_IP_OUT_OF_CATCH_ON_WIN64      EMAKEHR(0x131F) // SetIP isn't possible because it would move
                                                                        // EIP from within a catch clause to a point
                                                                        // outside of one on WIN64 platforms.

#define CORDBG_E_REMOTE_CONNECTION_CONN_RESET           EMAKEHR(0x1320) // The remote device closed the connection.
#define CORDBG_E_REMOTE_CONNECTION_KEEP_ALIVE           EMAKEHR(0x1321) // The connection was closed due to akeep alive failure.
#define CORDBG_E_REMOTE_CONNECTION_FATAL_ERROR          EMAKEHR(0x1322) // Generic error that the device connection has been broken with no chance for recovery.

#define CORDBG_E_CANT_SET_TO_JMC                        EMAKEHR(0x1323) // Can't use JMC on this code (likely wrong jit settings).

#define CORDBG_E_BAD_THREAD_STATE                       EMAKEHR(0x132d) // The state of the thread is invalid.
#define CORDBG_E_DEBUGGER_ALREADY_ATTACHED              EMAKEHR(0x132e) // This process has already been attached to
#define CORDBG_E_SUPERFLOUS_CONTINUE                    EMAKEHR(0x132f) // Returned from a call to Continue that was
                                                                        // Not matched with a stopping event.
#define CORDBG_E_SET_VALUE_NOT_ALLOWED_ON_NONLEAF_FRAME EMAKEHR(0x1330) // Can't perfrom SetValue on non-leaf frames.
#define CORDBG_E_ENC_EH_MAX_NESTING_LEVEL_CANT_INCREASE EMAKEHR(0x1331) // When doing EnC, some JITters don't let you
                                                                        // increase the maximum level to which
                                                                        // exception handling can be nested.
#define CORDBG_E_ENC_MODULE_NOT_ENC_ENABLED             EMAKEHR(0x1332) // Tried to do EnC on a module that wasn't
                                                                        // started in EnC mode.
#define CORDBG_E_SET_IP_NOT_ALLOWED_ON_EXCEPTION        EMAKEHR(0x1333) // Setip cannot be done on any exception
#define CORDBG_E_VARIABLE_IS_ACTUALLY_LITERAL           EMAKEHR(0x1334) // The 'variable' doesn't exist because it is a
                                                                        // literal optimized away by the compiler - ask
                                                                        // Metadata for it's default value, instead.
#define CORDBG_E_PROCESS_DETACHED                       EMAKEHR(0x1335) // Process has been detached from
#define CORDBG_E_ENC_METHOD_SIG_CHANGED                 EMAKEHR(0x1336) // Not allowed to change the signature of an
                                                                        // existing method - compiler should make new method
                                                                        // instead.
#define CORDBG_E_ENC_METHOD_NO_LOCAL_SIG                EMAKEHR(0x1337) // Can't get the local signature for the method
                                                                        // we're trying to EnC.
#define CORDBG_E_ENC_CANT_ADD_FIELD_TO_VALUE_OR_LAYOUT_CLASS EMAKEHR(0x1338) // Adding a field to a value or layout class is prohibitted,
                                                                        // since we can't guarantee the new field is contiguous to
                                                                        // VC's on the stack, embedded in other objects, etc.
#define CORDBG_E_ENC_CANT_CHANGE_FIELD                  EMAKEHR(0x1339) // Once you've got a field, you're not allowed to change
                                                                        // it, since that would change the size of the type it belongs to.
#define CORDBG_E_ENC_CANT_ADD_NON_PRIVATE_MEMBER        EMAKEHR(0x133A) // Only support addition of private members.
#define CORDBG_E_FIELD_NOT_STATIC                       EMAKEHR(0x133B) // Returned if someone tries to call GetStaticFieldValue
                                                                        // on a non-static field
#define CORDBG_E_FIELD_NOT_INSTANCE                     EMAKEHR(0x133C) // Returned if someone tries to call GetStaticFieldValue
                                                                        // on a non-instance field
#define CORDBG_E_ENC_ZAPPED_WITHOUT_ENC                 EMAKEHR(0x133D) // If a zap file was created without the EnC flag set, then
                                                                        // we can't do EnC on it, no matter what.
#define CORDBG_E_ENC_BAD_METHOD_INFO                    EMAKEHR(0x133E) // Lacking information about method.
#define CORDBG_E_ENC_JIT_CANT_UPDATE                    EMAKEHR(0x133F) // The JIT is unable to update the method.
#define CORDBG_E_ENC_MISSING_CLASS                      EMAKEHR(0x1340) // An internal structure about the class is missing
#define CORDBG_E_ENC_INTERNAL_ERROR                     EMAKEHR(0x1341) // Generic message for "Something user doesn't control went wrong" message.
#define CORDBG_E_ENC_HANGING_FIELD                      EMAKEHR(0x1342) // The field was added via enc after the class was loaded, and so instead of
                                                                        // the field being contiguous with the other fields, it's 'hanging' off the
                                                                        // instance, so the right side will have to go & get (instance-specific
                                                                        // info based on the particular object.
#define CORDBG_E_MODULE_NOT_LOADED                      EMAKEHR(0x1343) // If the module isn't loaded, including if it's been unloaded.

#define CORDBG_E_ENC_CANT_CHANGE_SUPERCLASS             EMAKEHR(0x1344) // Not allowed to change which class something inherits from
#define CORDBG_E_UNABLE_TO_SET_BREAKPOINT               EMAKEHR(0x1345) // Can't set a breakpoint here.
#define CORDBG_E_DEBUGGING_NOT_POSSIBLE                 EMAKEHR(0x1346) // Debugging isn't possible due to an incompatability within the CLR implementation.
#define CORDBG_E_KERNEL_DEBUGGER_ENABLED                EMAKEHR(0x1347) // Debugging isn't possible because a kernel debugger is enabled on the system.
#define CORDBG_E_KERNEL_DEBUGGER_PRESENT                EMAKEHR(0x1348) // Debugging isn't possible because a kernel debugger is present on the system.
#define CORDBG_E_HELPER_THREAD_DEAD                     EMAKEHR(0x1349) // The debugger's internal helper thread is dead.
#define CORDBG_E_INTERFACE_INHERITANCE_CANT_CHANGE      EMAKEHR(0x134A) // Not allowed to change interface inheritance.
#define CORDBG_E_INCOMPATIBLE_PROTOCOL                  EMAKEHR(0x134B) // The debugger's protocol is incompatible with the debuggee.
#define CORDBG_E_TOO_MANY_PROCESSES                     EMAKEHR(0x134C) // The debugger can only handle a finite number of debuggees.
#define CORDBG_E_INTEROP_NOT_SUPPORTED                  EMAKEHR(0x134D) // Interop is not allowed on a win9x platform
#define CORDBG_E_NO_REMAP_BREAKPIONT                    EMAKEHR(0x134E) // Cannot call RemapFunction until have received RemapBreakpoint
#define CORDBG_E_OBJECT_NEUTERED                        EMAKEHR(0x134F) // Object has been neutered (it's in a zombie state).
// NOTE!  YOU CANNOT PUT MORE ERRORS HERE!  They run into the range for profiling errors.  All new
// new error need to be added below (search for cordbg_e_ in your editor).

//**** Common Language Runtime Profiling Services errors
#define CORPROF_E_FUNCTION_NOT_COMPILED EMAKEHR(0x1350)     // Function not yet compiled.
#define CORPROF_E_DATAINCOMPLETE        EMAKEHR(0x1351)     // The ID is not fully loaded/defined yet.
#define CORPROF_E_NOT_REJITABLE_METHODS EMAKEHR(0x1352)     // The Module is not configured for updateable methods.
#define CORPROF_E_CANNOT_UPDATE_METHOD  EMAKEHR(0x1353)     // The Method could not be updated for re-jit.
#define CORPROF_E_FUNCTION_NOT_IL       EMAKEHR(0x1354)     // The Method has no associated IL
#define CORPROF_E_NOT_MANAGED_THREAD    EMAKEHR(0x1355)     // The thread has never run managed code before
#define CORPROF_E_CALL_ONLY_FROM_INIT   EMAKEHR(0x1356)     // The function may only be called during profiler init
#define CORPROF_E_INPROC_NOT_ENABLED    EMAKEHR(0x1357)     // Inprocess debugging must be enabled during init
                                                            // Also returned when BeginInprocDebugging not called
                                                            // before using the inprocess debugging services
#define CORPROF_E_JITMAPS_NOT_ENABLED   EMAKEHR(0x1358)     // Can't get a JIT map becuase they are not enabled
#define CORPROF_E_INPROC_ALREADY_BEGUN  EMAKEHR(0x1359)     // If a profiler tries to call BeginInprocDebugging more than
                                                            // once, it will get this error.
#define CORPROF_E_INPROC_NOT_AVAILABLE  EMAKEHR(0x135A)     // States that inprocess debugging not allowed at this point
                                                            // (for example during GC callbacks or RuntimeSuspention callbacks
#define CORPROF_E_NOT_YET_AVAILABLE     EMAKEHR(0x135B)     // This is a general error used to indicated that the information
                                                            // requested is not yet available
#define CORPROF_E_TYPE_IS_PARAMETERIZED EMAKEHR(0x135C)     // The given type is a generic and cannot be used with this method.
#define CORPROF_E_FUNCTION_IS_PARAMETERIZED EMAKEHR(0x135D) // The given function is a generic and cannot be used with this method.
#define CORPROF_E_STACKSNAPSHOT_INVALID_TGT_THREAD EMAKEHR(0x135E) // A profiler tried to walk the stack of an invalid thread
#define CORPROF_E_STACKSNAPSHOT_UNMANAGED_CTX        EMAKEHR(0x135F) // A profiler can not walk a thread that is currently executing unmanaged code
#define CORPROF_E_STACKSNAPSHOT_UNSAFE  EMAKEHR(0x1360)     // A stackwalk at this point may cause dead locks or data corruption
#define CORPROF_E_STACKSNAPSHOT_ABORTED EMAKEHR(0x1361)     // Stackwalking callback requested the walk to abort
#define CORPROF_E_LITERALS_HAVE_NO_ADDRESS EMAKEHR(0x1362)  // Returned when asked for the address of a static that is a literal.
#define CORPROF_E_UNSUPPORTED_CALL_SEQUENCE EMAKEHR(0x1363) // A call was made at an unsupported time (e.g., API illegally called asynchronously)
#define CORPROF_E_ASYNCHRONOUS_UNSAFE           EMAKEHR(0x1364) // A legal asynchronous call was made at an unsafe time (e.g., CLR locks are held) 
#define CORPROF_E_CLASSID_IS_ARRAY                      EMAKEHR(0x1365) // The specified ClassID cannot be inspected by this function because it is an array
#define CORPROF_E_CLASSID_IS_COMPOSITE              EMAKEHR(0x1366) // The specified ClassID is a non-array composite type (e.g., ref) and cannot be inspected


//**** Security errors
#define SECURITY_E_XML_TO_ASN_ENCODING  EMAKEHR(0x1400)     // Failed to convert XML to ASN
#define SECURITY_E_INCOMPATIBLE_SHARE   EMAKEHR(0x1401)     // Loading this assembly would produce a different grant set from other instances
#define SECURITY_E_UNVERIFIABLE         EMAKEHR(0x1402)     // Unverifable code failed policy check
#define SECURITY_E_INCOMPATIBLE_EVIDENCE EMAKEHR(0x1403)     // Assembly already loaded without additional security evidence.

//**** Reserved.
#define CLDB_E_INTERNALERROR            EMAKEHR(0x1fff)

// ******************
// Debugger & Profiler errors
// ******************


// ******************
// Security errors
// ******************

#define CORSEC_E_DECODE_SET             EMAKEHR(0x1410)         // Failure decoding permission set
#define CORSEC_E_ENCODE_SET             EMAKEHR(0x1411)         // Failure encoding permission set
#define CORSEC_E_UNSUPPORTED_FORMAT     EMAKEHR(0x1412)         // Unrecognized encoding format
#define SN_CRYPTOAPI_CALL_FAILED        EMAKEHR(0x1413)         // StrongName APIs not supported on system
#define CORSEC_E_CRYPTOAPI_CALL_FAILED  EMAKEHR(0x1413)         // StrongName APIs not supported on system
#define SN_NO_SUITABLE_CSP              EMAKEHR(0x1414)         // StrongName APIs couldn't locate a matching CSP
#define CORSEC_E_NO_SUITABLE_CSP        EMAKEHR(0x1414)         // StrongName APIs couldn't locate a matching CSP
#define CORSEC_E_INVALID_ATTR           EMAKEHR(0x1415)         // Invalid security custom attribute
#define CORSEC_E_POLICY_EXCEPTION       EMAKEHR(0x1416)         // PolicyException thrown
#define CORSEC_E_MIN_GRANT_FAIL         EMAKEHR(0x1417)         // Failed to grant minimum permission requests
#define CORSEC_E_NO_EXEC_PERM           EMAKEHR(0x1418)         // Failed to grant permission to execute
#define CORSEC_E_XMLSYNTAX              EMAKEHR(0x1419)         // XML Syntax error
#define CORSEC_E_INVALID_STRONGNAME     EMAKEHR(0x141a)         // Strong name validation failed
#define CORSEC_E_MISSING_STRONGNAME     EMAKEHR(0x141b)         // Assembly is not strong named
#define CORSEC_E_CONTAINER_NOT_FOUND    EMAKEHR(0x141c)         // Strong name key container not found
#define CORSEC_E_INVALID_IMAGE_FORMAT   EMAKEHR(0x141d)         // Invalid assembly file format
#define CORSEC_E_INVALID_PUBLICKEY      EMAKEHR(0x141e)         // Invalid assembly public key
#define CORSEC_E_SIGNATURE_MISMATCH     EMAKEHR(0x1420)         // Signature size mismatch

//**** crypto errors 1430 -- 1439
#define CORSEC_E_CRYPTO                 EMAKEHR(0x1430)         // generic CryptographicException
#define CORSEC_E_CRYPTO_UNEX_OPER       EMAKEHR(0x1431)         // generic CryptographicUnexpectedOperationException

//**** security custom attribute errors 143a -- 144f
#define CORSECATTR_E_BAD_ATTRIBUTE              EMAKEHR(0x143a) // Generic problem with a custom attribute
#define CORSECATTR_E_MISSING_CONSTRUCTOR        EMAKEHR(0x143b) // Missing a required constructor
#define CORSECATTR_E_FAILED_TO_CREATE_PERM      EMAKEHR(0x143c) // Unable to create a permission for this attribute
#define CORSECATTR_E_BAD_ACTION_ASM             EMAKEHR(0x143d) // SecurityAction type invalid on assembly
#define CORSECATTR_E_BAD_ACTION_OTHER           EMAKEHR(0x143e) // SecurityAction type invalid on types and methods
#define CORSECATTR_E_BAD_PARENT                 EMAKEHR(0x143f) // Security custom attribute attached to invalid parent
#define CORSECATTR_E_TRUNCATED                  EMAKEHR(0x1440) // Bad custom attribute serialized blob
#define CORSECATTR_E_BAD_VERSION                EMAKEHR(0x1441) // Bad custom attribute serialized blob version
#define CORSECATTR_E_BAD_ACTION                 EMAKEHR(0x1442) // Invalid security action code
#define CORSECATTR_E_NO_SELF_REF                EMAKEHR(0x1443) // CA ref to CA def'd in same assembly
#define CORSECATTR_E_BAD_NONCAS                 EMAKEHR(0x1444) // Use of non-CAS perm with invalid action
#define CORSECATTR_E_ASSEMBLY_LOAD_FAILED       EMAKEHR(0x1445) // Failed to load assembly containing CA (or req'd CA type)
#define CORSECATTR_E_ASSEMBLY_LOAD_FAILED_EX    EMAKEHR(0x1446) // Failed to load assembly containing CA (or req'd CA type)
#define CORSECATTR_E_TYPE_LOAD_FAILED           EMAKEHR(0x1447) // Failed to load CA type (or reqd CA type)
#define CORSECATTR_E_TYPE_LOAD_FAILED_EX        EMAKEHR(0x1448) // Failed to load CA type (or reqd CA type)
#define CORSECATTR_E_ABSTRACT                   EMAKEHR(0x1449) // CA type is abstract
#define CORSECATTR_E_UNSUPPORTED_TYPE           EMAKEHR(0x144a) // Unsupported type for field/property setter
#define CORSECATTR_E_UNSUPPORTED_ENUM_TYPE      EMAKEHR(0x144b) // Unsupported base type for enum field/property
#define CORSECATTR_E_NO_FIELD                   EMAKEHR(0x144c) // Couldn't find a CA field
#define CORSECATTR_E_NO_PROPERTY                EMAKEHR(0x144d) // Couldn't find a CA property
#define CORSECATTR_E_EXCEPTION                  EMAKEHR(0x144e) // Unexpected exception
#define CORSECATTR_E_EXCEPTION_HR               EMAKEHR(0x144f) // Unexpected exception


//**** Isolated Storage Errors 1450 - 14FF
#define ISS_E_ISOSTORE                   EMAKEHR(0x1450L)

#define ISS_E_OPEN_STORE_FILE            EMAKEHR(0x1460L)
#define ISS_E_OPEN_FILE_MAPPING          EMAKEHR(0x1461L)
#define ISS_E_MAP_VIEW_OF_FILE           EMAKEHR(0x1462L)
#define ISS_E_GET_FILE_SIZE              EMAKEHR(0x1463L)
#define ISS_E_CREATE_MUTEX               EMAKEHR(0x1464L)
#define ISS_E_LOCK_FAILED                EMAKEHR(0x1465L)
#define ISS_E_FILE_WRITE                 EMAKEHR(0x1466L)
#define ISS_E_SET_FILE_POINTER           EMAKEHR(0x1467L)
#define ISS_E_CREATE_DIR                 EMAKEHR(0x1468L)
#define ISS_E_STORE_NOT_OPEN             EMAKEHR(0x1469L)

#define ISS_E_CORRUPTED_STORE_FILE       EMAKEHR(0x1480L)
#define ISS_E_STORE_VERSION              EMAKEHR(0x1481L)
#define ISS_E_FILE_NOT_MAPPED            EMAKEHR(0x1482L)
#define ISS_E_BLOCK_SIZE_TOO_SMALL       EMAKEHR(0x1483L)
#define ISS_E_ALLOC_TOO_LARGE            EMAKEHR(0x1484L)
#define ISS_E_USAGE_WILL_EXCEED_QUOTA    EMAKEHR(0x1485L)
#define ISS_E_TABLE_ROW_NOT_FOUND        EMAKEHR(0x1486L)

#define ISS_E_DEPRECATE                  EMAKEHR(0x14A0L)
#define ISS_E_CALLER                     EMAKEHR(0x14A1L)
#define ISS_E_PATH_LENGTH                EMAKEHR(0x14A2L)
#define ISS_E_MACHINE                    EMAKEHR(0x14A3L)
#define ISS_E_MACHINE_DACL               EMAKEHR(0x14A4L)

#define ISS_E_ISOSTORE_START             EMAKEHR(0x1450L)
#define ISS_E_ISOSTORE_END               EMAKEHR(0x14FFL)

// ******************
// Classlib errors
// ******************


//
// MessageId: COR_E_APPLICATION
//
// MessageText:
//
// The base class for all "less serious" exceptions.
//
#define COR_E_APPLICATION  EMAKEHR(0x1600L)


//
// MessageId: COR_E_ARGUMENT
//
// MessageText:
//
// An argument does not meet the contract of the method.
//
#define COR_E_ARGUMENT  E_INVALIDARG        // 0x80070057


//
// MessageId: COR_E_ARGUMENTOUTOFRANGE
//
// MessageText:
//
// An argument was out of its legal range.
//
#define COR_E_ARGUMENTOUTOFRANGE  EMAKEHR(0x1502L)


//
// MessageId: COR_E_ARITHMETIC
//
// MessageText:
//
// Overflow or underflow in mathematical operations.
//
#define COR_E_ARITHMETIC  HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW)     // 0x80070216


//
// MessageId: COR_E_ARRAYTYPEMISMATCH
//
// MessageText:
//
// Attempted to store an object of the wrong type in an array
//
#define COR_E_ARRAYTYPEMISMATCH  EMAKEHR(0x1503L)


//
// MessageId: COR_E_CONTEXTMARSHAL
//
// MessageText:
//
//
//
#define COR_E_CONTEXTMARSHAL  EMAKEHR(0x1504L)


//
// MessageId: COR_E_TIMEOUT
//
// MessageText:
//
//
//
#define COR_E_TIMEOUT  EMAKEHR(0x1505L)


//
// MessageId: COR_E_KEYNOTFOUND
//
// MessageText:
//
//
//
#define COR_E_KEYNOTFOUND  EMAKEHR(0x1577L)



//
// MessageId: COR_E_DEVICESNOTSUPPORTED
//
// MessageText:
//
//
//
#define COR_E_DEVICESNOTSUPPORTED  EMAKEHR(0x1540L)

//
// MessageId: COR_E_DIVIDEBYZERO
//
// MessageText:
//
// Attempted to divide a number by zero.
//
#define COR_E_DIVIDEBYZERO  _HRESULT_TYPEDEF_(0x80020012L) // DISP_E_DIVBYZERO


//
// MessageId: COR_E_EXCEPTION
//
// MessageText:
//
// Base class for all exceptions in the runtime
//
#define COR_E_EXCEPTION  EMAKEHR(0x1500L)


//
// MessageId: COR_E_EXECUTIONENGINE
//
// MessageText:
//
// An internal error happened in the Common Language Runtime's Execution Engine
//
#define COR_E_EXECUTIONENGINE  EMAKEHR(0x1506L)


//
// MessageId: COR_E_FIELDACCESS
//
// MessageText:
//
// Access to this field is denied.
//
#define COR_E_FIELDACCESS  EMAKEHR(0x1507L)


//
// MessageId: COR_E_FORMAT
//
// MessageText:
//
// The format of one arguments does not meet the contract of the method.
//
#define COR_E_FORMAT  EMAKEHR(0x1537L)


//
// MessageId: COR_E_BADIMAGEFORMAT
//
// MessageText:
//
// The format of DLL or executable being loaded is invalid.
//
#define COR_E_BADIMAGEFORMAT  _HRESULT_TYPEDEF_(0x8007000BL)


//
// MessageId: COR_E_ASSEMBLYEXPECTED
//
// MessageText:
//
// The module was expected to contain an assembly manifest.
//
#define COR_E_ASSEMBLYEXPECTED  EMAKEHR(0x1018L)

//
// MessageId: COR_E_TYPEUNLOADED
//
// MessageText:
//
// The type had been unloaded.
//
#define COR_E_TYPEUNLOADED   EMAKEHR(0x1013L)

//
// MessageId: COR_E_INDEXOUTOFRANGE
//
// MessageText:
//
// Attempted to access an element within an array by using an index that is
// not within the bound of that array.
//
#define COR_E_INDEXOUTOFRANGE  EMAKEHR(0x1508L)


//
// MessageId: COR_E_INSUFFICIENTMEMORY
//
// MessageText:
//
// Not enough memory was available for an operation.
// This may not be potentially fatal (vs. an OutOfMemoryException).
//
#define COR_E_INSUFFICIENTMEMORY  EMAKEHR(0x153DL)


//
// MessageId: COR_E_RUNTIMEWRAPPED
//
// MessageText:
//
// An object that does not derive from System.Exception has been wrapped in a RuntimeWrappedException.
//
#define COR_E_RUNTIMEWRAPPED  EMAKEHR(0x153EL)


//
// MessageId: COR_E_INVALIDCAST
//
// MessageText:
//
// Indicates a bad cast condition
//
#define COR_E_INVALIDCAST  E_NOINTERFACE        // 0x80004002


//
// MessageId: COR_E_INVALIDOPERATION
//
// MessageText:
//
// An operation is not legal in the current state.
//
#define COR_E_INVALIDOPERATION  EMAKEHR(0x1509L)


//
// MessageId: COR_E_INVALIDPROGRAM
//
// MessageText:
//
// A program contained invalid IL or bad metadata.  Usually this is a compiler bug.
//
#define COR_E_INVALIDPROGRAM  EMAKEHR(0x153AL)


//
// MessageId: COR_E_MEMBERACCESS
//
// MessageText:
//
// Access to this member is denied.
//
#define COR_E_MEMBERACCESS  EMAKEHR(0x151AL)


//
// MessageId: COR_E_METHODACCESS
//
// MessageText:
//
// Access to this method is denied.
//
#define COR_E_METHODACCESS  EMAKEHR(0x1510L)


//
// MessageId: COR_E_MISSINGFIELD
//
// MessageText:
//
// An attempt was made to dynamically access a field that does not exist.
//
#define COR_E_MISSINGFIELD  EMAKEHR(0x1511L)


//
// MessageId: COR_E_MISSINGMANIFESTRESOURCE
//
// MessageText:
//
// An expected resource in the assembly manifest was missing.
//
#define COR_E_MISSINGMANIFESTRESOURCE  EMAKEHR(0x1532L)


//
// MessageId: COR_E_MISSINGMEMBER
//
// MessageText:
//
// An attempt was made to dynamically invoke or access a field or method
// that does not exist.
//
#define COR_E_MISSINGMEMBER  EMAKEHR(0x1512L)


//
// MessageId: COR_E_MISSINGMETHOD
//
// MessageText:
//
// An attempt was made to dynamically invoke a method that does not exist
//
#define COR_E_MISSINGMETHOD  EMAKEHR(0x1513L)


//
// MessageId: COR_E_MISSINGSATELLITEASSEMBLY
//
// MessageText:
//
// An expected satellite assembly containing the ultimate fallback resources
// for a given culture was not found or couldn't be loaded.  Setup problem?
//
#define COR_E_MISSINGSATELLITEASSEMBLY  EMAKEHR(0x1536L)


//
// MessageId: COR_E_MULTICASTNOTSUPPORTED
//
// MessageText:
//
// Attempted to combine delegates that are not multicast
//
#define COR_E_MULTICASTNOTSUPPORTED  EMAKEHR(0x1514L)


//
// MessageId: COR_E_NOTFINITENUMBER
//
// MessageText:
//
//  Thrown if value (a floating point number) is either the not a number value (NaN) or +- infinity value
//  VB needs this stuff
#define COR_E_NOTFINITENUMBER     EMAKEHR(0x1528L)


//
// MessageId: COR_E_DUPLICATEWAITOBJECT
//
// MessageText:
//
// An object appears more than once in the wait objects array.
//
#define COR_E_DUPLICATEWAITOBJECT   EMAKEHR(0x1529L)


//
// MessageId: COR_E_PLATFORMNOTSUPPORTED
//
// MessageText:
//
// The method is not supported on this platform
//
#define COR_E_PLATFORMNOTSUPPORTED  EMAKEHR(0x1539L)

//
// MessageId: COR_E_NOTSUPPORTED
//
// MessageText:
//
// The operation is not supported
//
#define COR_E_NOTSUPPORTED  EMAKEHR(0x1515L)

//
// MessageId: COR_E_NULLREFERENCE
//
// MessageText:
//
// Dereferencing a null reference. In general class libraries should not throw this
//
#define COR_E_NULLREFERENCE  E_POINTER      // 0x80004003


//
// MessageId: COR_E_OUTOFMEMORY
//
// MessageText:
//
// The EE thows this exception when no more memory is avaible to continue execution
//
#define COR_E_OUTOFMEMORY  E_OUTOFMEMORY        // 0x8007000E


//
// MessageId: COR_E_OVERFLOW
//
// MessageText:
//
// An arithmetic, casting, or conversion operation overflowed or underflowed.
//
#define COR_E_OVERFLOW  EMAKEHR(0x1516L)


//
// MessageId: COR_E_RANK
//
// MessageText:
//
// An array has the wrong number of dimensions for a particular operation.
//
#define COR_E_RANK  EMAKEHR(0x1517L)


//
// MessageId: COR_E_REMOTING
//
// MessageText:
//
// An error relating to remoting occurred.
//
#define COR_E_REMOTING  EMAKEHR(0x150BL)
#define COR_E_SERVER  EMAKEHR(0x150EL)

//
// MessageId: COR_E_SERVICEDCOMPONENT
//
// MessageText:
//
// An error relating to ServicedComponent occurred.
//
#define COR_E_SERVICEDCOMPONENT  EMAKEHR(0x150FL)


//
// MessageId: COR_E_SECURITY
//
// MessageText:
//
// An error relating to security occured.
//
#define COR_E_SECURITY  EMAKEHR(0x150AL)


//
// MessageID: COR_E_SERIALIZATION
//
// MessageText:
//
// An error relating to serialization has occurred.
//
#define COR_E_SERIALIZATION EMAKEHR(0x150CL)


//
// MessageId: COR_E_STACKOVERFLOW
//
// MessageText:
//
// Is raised by the EE when the execution stack overflows as it is attempting to ex
//
#define COR_E_STACKOVERFLOW  HRESULT_FROM_WIN32(ERROR_STACK_OVERFLOW)       // 0x800703E9


//
// MessageId: COR_E_SYNCHRONIZATIONLOCK
//
// MessageText:
//
// Wait(), Notify() or NotifyAll() was called from an unsynchronized ** block of c
//
#define COR_E_SYNCHRONIZATIONLOCK  EMAKEHR(0x1518L)


//
// MessageId: COR_E_SYSTEM
//
// MessageText:
//
// The base class for the runtime's "less serious" exceptions
//
#define COR_E_SYSTEM  EMAKEHR(0x1501L)


//
// MessageId: COR_E_THREADABORTED
//
// MessageText:
//
// Thrown into a thread to cause it to abort. Not catchable.
//
#define COR_E_THREADABORTED  EMAKEHR(0x1530L)


//
// MessageId: COR_E_OPERATIONCANCELED
//
// MessageText:
//
// The operation was cancelled.
//
#define COR_E_OPERATIONCANCELED EMAKEHR(0x153BL)


//
// MessageId: COR_E_THREADINTERRUPTED
//
// MessageText:
//
// Indicates that the thread was interrupted from a waiting state
//
#define COR_E_THREADINTERRUPTED  EMAKEHR(0x1519L)


//
// MessageId: COR_E_THREADSTATE
//
// MessageText:
//
// Indicate that the Thread class is in an invalid state for the method call
//
#define COR_E_THREADSTATE  EMAKEHR(0x1520L)


//
// MessageId: COR_E_THREADSTOP
//
// MessageText:
//
// Thrown into a thread to cause it to stop. This exception is typically not caught
//
#define COR_E_THREADSTOP  EMAKEHR(0x1521L)


//
// MessageId: COR_E_THREADSTART
//
// MessageText:
//
// Indicate that a user thread fails to start.
//
#define COR_E_THREADSTART  EMAKEHR(0x1525L)


//
// MessageId: COR_E_TYPEINITIALIZATION
//
// MessageText:
//
// An exception was thrown by a type's initializer (.cctor).
//
#define COR_E_TYPEINITIALIZATION  EMAKEHR(0x1534L)


//
// MessageId: COR_E_TYPELOAD
//
// MessageText:
//
// Could not find or load a specific type (class, enum, etc).
//
#define COR_E_TYPELOAD  EMAKEHR(0x1522L)


//
// MessageId: COR_E_ENTRYPOINTNOTFOUND
//
// MessageText:
//
// Could not find the specified DllImport entry point
//
#define COR_E_ENTRYPOINTNOTFOUND  EMAKEHR(0x1523L)


//
// MessageId: COR_E_DLLNOTFOUND
//
// MessageText:
//
// Could not find the specified DllImport DLL.
//
#define COR_E_DLLNOTFOUND  EMAKEHR(0x1524L)


//
// MessageId: COR_E_UNAUTHORIZEDACCESS
//
// MessageText:
//
// Access is denied.
//
#define COR_E_UNAUTHORIZEDACCESS  E_ACCESSDENIED    // 0x80070005


//
// MessageId: COR_E_VERIFICATION
//
// MessageText:
//
// A verification failure occurred
//
#define COR_E_VERIFICATION  EMAKEHR(0x150DL)


//
// MessageId: COR_E_INVALIDCOMOBJECT
//
// MessageText:
//
// An invalid __ComObject has been used.
//
#define COR_E_INVALIDCOMOBJECT     EMAKEHR(0x1527L)


//
// MessageId: COR_E_SEMAPHOREFULL
//
// MessageText:
//
// Adding the given count to the semaphore would cause it to exceed its maximum count.
//
#define COR_E_SEMAPHOREFULL     EMAKEHR(0x152BL)


//
// MessageId: COR_E_WAITHANDLECANNOTBEOPENED
//
// MessageText:
//
// No Semaphore of the given name exists.
//
#define COR_E_WAITHANDLECANNOTBEOPENED     EMAKEHR(0x152CL)

//
// MessageId: COR_E_ABANDONEDMUTEX
//
// MessageText:
//
// The wait completed due to an abandoned mutex.
//
#define COR_E_ABANDONEDMUTEX EMAKEHR(0x152DL)

//
// MessageId: COR_E_MARSHALDIRECTIVE
//
// MessageText:
//
// The marshaling directives are invalid.
//
#define COR_E_MARSHALDIRECTIVE     EMAKEHR(0x1535L)


//
// MessageId: COR_E_INVALIDOLEVARIANTTYPE
//
// MessageText:
//
// The type of an OLE variant that was passed into the runtime is invalid.
//
#define COR_E_INVALIDOLEVARIANTTYPE    EMAKEHR(0x1531L)


//
// MessageId: COR_E_SAFEARRAYTYPEMISMATCH
//
// MessageText:
//
// A mismatch has occured between the runtime type of the array and the
// sub type recorded in the metadata.
//
#define COR_E_SAFEARRAYTYPEMISMATCH    EMAKEHR(0x1533L)


//
// MessageId: COR_E_SAFEARRAYRANKMISMATCH
//
// MessageText:
//
// A mismatch has occured between the runtime rank of the array and the
// rank recorded in the metadata.
//
#define COR_E_SAFEARRAYRANKMISMATCH    EMAKEHR(0x1538L)

//
// MessageId: COR_E_DATAMISALIGNED
//
// MessageText:
//
// A datatype misalignment was detected in a load or store instruction.
//
#define COR_E_DATAMISALIGNED    EMAKEHR(0x1541L)


//
// MessageId: COR_E_TARGETPARAMCOUNT
//
// MessageText:
//
// There was a mismatch between number of arguments provided and the number expected
//
#define COR_E_TARGETPARAMCOUNT     _HRESULT_TYPEDEF_(0x8002000EL) // DISP_E_BADPARAMCOUNT


//
// MessageId: COR_E_AMBIGUOUSMATCH
//
// MessageText:
//
// While late binding to a method via reflection, could not resolve between
// multiple overloads of a method.
//
#define COR_E_AMBIGUOUSMATCH  _HRESULT_TYPEDEF_(0x8000211DL)


//
// MessageId: COR_E_INVALIDFILTERCRITERIA
//
// MessageText:
//
// The given filter criteria does not match the filter contract.
//
#define COR_E_INVALIDFILTERCRITERIA  EMAKEHR(0x1601L)


//
// MessageId: COR_E_REFLECTIONTYPELOAD
//
// MessageText:
//
// Could not find or load a specific class that was requested through Reflection
//
#define COR_E_REFLECTIONTYPELOAD  EMAKEHR(0x1602L)


//
// MessageId: COR_E_TARGET
//
// MessageText:
//
// - If you attempt to invoke a non-static method with a null Object - If you atte
//
#define COR_E_TARGET  EMAKEHR(0x1603L)


//
// MessageId: COR_E_TARGETINVOCATION
//
// MessageText:
//
// If the method called throws an exception
//
#define COR_E_TARGETINVOCATION  EMAKEHR(0x1604L)


//
// MessageId: COR_E_CUSTOMATTRIBUTEFORMAT
//
// MessageText:
//
// If the binary format of a custom attribute is invalid.
//
#define COR_E_CUSTOMATTRIBUTEFORMAT  EMAKEHR(0x1605L)


//
// MessageId: COR_E_ENDOFSTREAM
//
// MessageText:
//
// Thrown when the End of file is reached
//
#define COR_E_ENDOFSTREAM  HRESULT_FROM_WIN32(ERROR_HANDLE_EOF)


//
// MessageId: COR_E_FILELOAD
//
// MessageText:
//
//
//
#define COR_E_FILELOAD  EMAKEHR(0x1621L)


//
// MessageId: COR_E_FILENOTFOUND
//
// MessageText:
//
//
//
#define COR_E_FILENOTFOUND  HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND)

//
// MessageId: ERROR_BAD_PATHNAME
//
// MessageText:
//
//  The specified path is invalid.
//
#define COR_E_BAD_PATHNAME  HRESULT_FROM_WIN32(ERROR_BAD_PATHNAME)

//
// MessageId: COR_E_IO
//
// MessageText:
//
// Some sort of I/O error.
//
#define COR_E_IO  EMAKEHR(0x1620L)


//
// MessageId: COR_E_DIRECTORYNOTFOUND
//
// MessageText:
//
// The specified path couldn't be found.
//
#define COR_E_DIRECTORYNOTFOUND  HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND)


//
// MessageId: COR_E_PATHTOOLONG
//
// MessageText:
//
// The specified path was too long.
//
#define COR_E_PATHTOOLONG  HRESULT_FROM_WIN32(ERROR_FILENAME_EXCED_RANGE)


//
// MessageId: COR_E_OBJECTDISPOSED
//
// MessageText:
//
// The object has already been disposed.
//
#define COR_E_OBJECTDISPOSED EMAKEHR(0x1622L)


//
// MessageId: COR_E_FAILFAST
//
// MessageText:
//
// Runtime operation halted by call to System.Environment.FailFast().
//
#define COR_E_FAILFAST  EMAKEHR(0x1623L)


//
// MessageId: COR_E_HOSTPROTECTION
//
// MessageText:
//
// Attempted to perform an operation that was forbidden by the host.
//
#define COR_E_HOSTPROTECTION  EMAKEHR(0x1640L)


//
// MessageId: COR_E_ILLEGAL_REENTRANCY
//
// MessageText:
//
// Attempted to call into managed code when executing inside a low level extensibility point.
//
#define COR_E_ILLEGAL_REENTRANCY  EMAKEHR(0x1641L)


//**** Shim errors 1700 - 1750
//
#define CLR_E_SHIM_RUNTIMELOAD            EMAKEHR(0x1700)     // Failed to load the runtime
#define CLR_E_SHIM_RUNTIMEEXPORT          EMAKEHR(0x1701)     // Failed to find a required export in the runtime
#define CLR_E_SHIM_INSTALLROOT            EMAKEHR(0x1702)     // Install root is not defined
#define CLR_E_SHIM_INSTALLCOMP            EMAKEHR(0x1703)     // Expected component of the runtime is not available

//**** Verifier Errors 1800 - 18FF
// See src/dlls/mscorrc/mscorrc.rc for a description of each error

#define VER_E_HRESULT           EMAKEHR(0x1801)
#define VER_E_OFFSET            EMAKEHR(0x1802)
#define VER_E_OPCODE            EMAKEHR(0x1803)
#define VER_E_OPERAND           EMAKEHR(0x1804)
#define VER_E_TOKEN             EMAKEHR(0x1805)
#define VER_E_EXCEPT            EMAKEHR(0x1806)
#define VER_E_STACK_SLOT        EMAKEHR(0x1807)
#define VER_E_LOC               EMAKEHR(0x1808)
#define VER_E_ARG               EMAKEHR(0x1809)
#define VER_E_FOUND             EMAKEHR(0x180A)
#define VER_E_EXPECTED          EMAKEHR(0x180B)
#define VER_E_LOC_BYNAME        EMAKEHR(0x180C)

#define VER_E_UNKNOWN_OPCODE    EMAKEHR(0x1810)
#define VER_E_SIG_CALLCONV      EMAKEHR(0x1811)
#define VER_E_SIG_ELEMTYPE      EMAKEHR(0x1812)

#define VER_E_RET_SIG           EMAKEHR(0x1814)
#define VER_E_FIELD_SIG         EMAKEHR(0x1815)

#define VER_E_INTERNAL          EMAKEHR(0x1818)
#define VER_E_STACK_TOO_LARGE   EMAKEHR(0x1819)
#define VER_E_ARRAY_NAME_LONG   EMAKEHR(0x181A)

#define VER_E_FALLTHRU          EMAKEHR(0x1820)
#define VER_E_TRY_GTEQ_END      EMAKEHR(0x1821)
#define VER_E_TRYEND_GT_CS      EMAKEHR(0x1822)
#define VER_E_HND_GTEQ_END      EMAKEHR(0x1823)
#define VER_E_HNDEND_GT_CS      EMAKEHR(0x1824)
#define VER_E_FLT_GTEQ_CS       EMAKEHR(0x1825)
#define VER_E_TRY_START         EMAKEHR(0x1826)
#define VER_E_HND_START         EMAKEHR(0x1827)
#define VER_E_FLT_START         EMAKEHR(0x1828)
#define VER_E_TRY_OVERLAP       EMAKEHR(0x1829)
#define VER_E_TRY_EQ_HND_FIL    EMAKEHR(0x182A)
#define VER_E_TRY_SHARE_FIN_FAL EMAKEHR(0x182B)
#define VER_E_HND_OVERLAP       EMAKEHR(0x182C)
#define VER_E_HND_EQ            EMAKEHR(0x182D)
#define VER_E_FIL_OVERLAP       EMAKEHR(0x182E)
#define VER_E_FIL_EQ            EMAKEHR(0x182F)
#define VER_E_FIL_CONT_TRY      EMAKEHR(0x1830)
#define VER_E_FIL_CONT_HND      EMAKEHR(0x1831)
#define VER_E_FIL_CONT_FIL      EMAKEHR(0x1832)
#define VER_E_FIL_GTEQ_CS       EMAKEHR(0x1833)
#define VER_E_FIL_START         EMAKEHR(0x1834)
#define VER_E_FALLTHRU_EXCEP    EMAKEHR(0x1835)
#define VER_E_FALLTHRU_INTO_HND EMAKEHR(0x1836)
#define VER_E_FALLTHRU_INTO_FIL EMAKEHR(0x1837)
#define VER_E_LEAVE             EMAKEHR(0x1838)
#define VER_E_RETHROW           EMAKEHR(0x1839)
#define VER_E_ENDFINALLY        EMAKEHR(0x183A)
#define VER_E_ENDFILTER         EMAKEHR(0x183B)
#define VER_E_ENDFILTER_MISSING EMAKEHR(0x183C)
#define VER_E_BR_INTO_TRY       EMAKEHR(0x183D)
#define VER_E_BR_INTO_HND       EMAKEHR(0x183E)
#define VER_E_BR_INTO_FIL       EMAKEHR(0x183F)
#define VER_E_BR_OUTOF_TRY      EMAKEHR(0x1840)
#define VER_E_BR_OUTOF_HND      EMAKEHR(0x1841)
#define VER_E_BR_OUTOF_FIL      EMAKEHR(0x1842)
#define VER_E_BR_OUTOF_FIN      EMAKEHR(0x1843)
#define VER_E_RET_FROM_TRY      EMAKEHR(0x1844)
#define VER_E_RET_FROM_HND      EMAKEHR(0x1845)
#define VER_E_RET_FROM_FIL      EMAKEHR(0x1846)
#define VER_E_BAD_JMP_TARGET    EMAKEHR(0x1847)
#define VER_E_PATH_LOC          EMAKEHR(0x1848)
#define VER_E_PATH_THIS         EMAKEHR(0x1849)
#define VER_E_PATH_STACK        EMAKEHR(0x184A)
#define VER_E_PATH_STACK_DEPTH  EMAKEHR(0x184B)
#define VER_E_THIS              EMAKEHR(0x184C)
#define VER_E_THIS_UNINIT_EXCEP EMAKEHR(0x184D)
#define VER_E_THIS_UNINIT_STORE EMAKEHR(0x184E)
#define VER_E_THIS_UNINIT_RET   EMAKEHR(0x184F)
#define VER_E_THIS_UNINIT_V_RET EMAKEHR(0x1850)
#define VER_E_THIS_UNINIT_BR    EMAKEHR(0x1851)
#define VER_E_LDFTN_CTOR        EMAKEHR(0x1852)
#define VER_E_STACK_NOT_EQ      EMAKEHR(0x1853)
#define VER_E_STACK_UNEXPECTED  EMAKEHR(0x1854)
#define VER_E_STACK_EXCEPTION   EMAKEHR(0x1855)
#define VER_E_STACK_OVERFLOW    EMAKEHR(0x1856)
#define VER_E_STACK_UNDERFLOW   EMAKEHR(0x1857)
#define VER_E_STACK_EMPTY       EMAKEHR(0x1858)
#define VER_E_STACK_UNINIT      EMAKEHR(0x1859)
#define VER_E_STACK_I_I4_I8     EMAKEHR(0x185A)
#define VER_E_STACK_R_R4_R8     EMAKEHR(0x185B)
#define VER_E_STACK_NO_R_I8     EMAKEHR(0x185C)
#define VER_E_STACK_NUMERIC     EMAKEHR(0x185D)
#define VER_E_STACK_OBJREF      EMAKEHR(0x185E)
#define VER_E_STACK_P_OBJREF    EMAKEHR(0x185F)
#define VER_E_STACK_BYREF       EMAKEHR(0x1860)
#define VER_E_STACK_METHOD      EMAKEHR(0x1861)
#define VER_E_STACK_ARRAY_SD    EMAKEHR(0x1862)
#define VER_E_STACK_VALCLASS    EMAKEHR(0x1863)
#define VER_E_STACK_P_VALCLASS  EMAKEHR(0x1864)
#define VER_E_STACK_NO_VALCLASS EMAKEHR(0x1865)
#define VER_E_LOC_DEAD          EMAKEHR(0x1866)
#define VER_E_LOC_NUM           EMAKEHR(0x1867)
#define VER_E_ARG_NUM           EMAKEHR(0x1868)
#define VER_E_TOKEN_RESOLVE     EMAKEHR(0x1869)
#define VER_E_TOKEN_TYPE        EMAKEHR(0x186A)
#define VER_E_TOKEN_TYPE_MEMBER EMAKEHR(0x186B)
#define VER_E_TOKEN_TYPE_FIELD  EMAKEHR(0x186C)
#define VER_E_TOKEN_TYPE_SIG    EMAKEHR(0x186D)
#define VER_E_UNVERIFIABLE      EMAKEHR(0x186E)
#define VER_E_LDSTR_OPERAND     EMAKEHR(0x186F)
#define VER_E_RET_PTR_TO_STACK  EMAKEHR(0x1870)
#define VER_E_RET_VOID          EMAKEHR(0x1871)
#define VER_E_RET_MISSING       EMAKEHR(0x1872)
#define VER_E_RET_EMPTY         EMAKEHR(0x1873)
#define VER_E_RET_UNINIT        EMAKEHR(0x1874)
#define VER_E_ARRAY_ACCESS      EMAKEHR(0x1875)
#define VER_E_ARRAY_V_STORE     EMAKEHR(0x1876)
#define VER_E_ARRAY_SD          EMAKEHR(0x1877)
#define VER_E_ARRAY_SD_PTR      EMAKEHR(0x1878)
#define VER_E_ARRAY_FIELD       EMAKEHR(0x1879)
#define VER_E_ARGLIST           EMAKEHR(0x187A)
#define VER_E_VALCLASS          EMAKEHR(0x187B)
#define VER_E_METHOD_ACCESS     EMAKEHR(0x187C)
#define VER_E_FIELD_ACCESS      EMAKEHR(0x187D)
#define VER_E_DEAD              EMAKEHR(0x187E)
#define VER_E_FIELD_STATIC      EMAKEHR(0x187F)
#define VER_E_FIELD_NO_STATIC   EMAKEHR(0x1880)
#define VER_E_ADDR              EMAKEHR(0x1881)
#define VER_E_ADDR_BYREF        EMAKEHR(0x1882)
#define VER_E_ADDR_LITERAL      EMAKEHR(0x1883)
#define VER_E_INITONLY          EMAKEHR(0x1884)
#define VER_E_THROW             EMAKEHR(0x1885)
#define VER_E_CALLVIRT_VALCLASS EMAKEHR(0x1886)
#define VER_E_CALL_SIG          EMAKEHR(0x1887)
#define VER_E_CALL_STATIC       EMAKEHR(0x1888)
#define VER_E_CTOR              EMAKEHR(0x1889)
#define VER_E_CTOR_VIRT         EMAKEHR(0x188A)
#define VER_E_CTOR_OR_SUPER     EMAKEHR(0x188B)
#define VER_E_CTOR_MUL_INIT     EMAKEHR(0x188C)
#define VER_E_SIG               EMAKEHR(0x188D)
#define VER_E_SIG_ARRAY         EMAKEHR(0x188E)
#define VER_E_SIG_ARRAY_PTR     EMAKEHR(0x188F)
#define VER_E_SIG_ARRAY_BYREF   EMAKEHR(0x1890)
#define VER_E_SIG_ELEM_PTR      EMAKEHR(0x1891)
#define VER_E_SIG_VARARG        EMAKEHR(0x1892)
#define VER_E_SIG_VOID          EMAKEHR(0x1893)
#define VER_E_SIG_BYREF_BYREF   EMAKEHR(0x1894)
#define VER_E_CODE_SIZE_ZERO    EMAKEHR(0x1896)
#define VER_E_BAD_VARARG        EMAKEHR(0x1897)
#define VER_E_TAIL_CALL         EMAKEHR(0x1898)
#define VER_E_TAIL_BYREF        EMAKEHR(0x1899)
#define VER_E_TAIL_RET          EMAKEHR(0x189A)
#define VER_E_TAIL_RET_VOID     EMAKEHR(0x189B)
#define VER_E_TAIL_RET_TYPE     EMAKEHR(0x189C)
#define VER_E_TAIL_STACK_EMPTY  EMAKEHR(0x189D)
#define VER_E_METHOD_END        EMAKEHR(0x189E)
#define VER_E_BAD_BRANCH        EMAKEHR(0x189F)
#define VER_E_FIN_OVERLAP       EMAKEHR(0x18A0)
#define VER_E_LEXICAL_NESTING   EMAKEHR(0x18A1)
#define VER_E_VOLATILE          EMAKEHR(0x18A2)
#define VER_E_UNALIGNED         EMAKEHR(0x18A3)
#define VER_E_INNERMOST_FIRST   EMAKEHR(0x18A4)
#define VER_E_CALLI_VIRTUAL     EMAKEHR(0x18A5)
#define VER_E_CALL_ABSTRACT     EMAKEHR(0x18A6)
#define VER_E_STACK_UNEXP_ARRAY EMAKEHR(0x18A7)
#define VER_E_NOT_IN_GC_HEAP    EMAKEHR(0x18A8)
#define VER_E_TRY_N_EMPTY_STACK EMAKEHR(0x18A9)
#define VER_E_DLGT_CTOR         EMAKEHR(0x18AA)
#define VER_E_DLGT_BB           EMAKEHR(0x18AB)
#define VER_E_DLGT_PATTERN      EMAKEHR(0x18AC)
#define VER_E_DLGT_LDFTN        EMAKEHR(0x18AD)
#define VER_E_FTN_ABSTRACT      EMAKEHR(0x18AE)
#define VER_E_SIG_C_VC          EMAKEHR(0x18AF)
#define VER_E_SIG_VC_C          EMAKEHR(0x18B0)
#define VER_E_BOX_PTR_TO_STACK  EMAKEHR(0x18B1)
#define VER_E_SIG_BYREF_TB_AH   EMAKEHR(0x18B2)
#define VER_E_SIG_ARRAY_TB_AH   EMAKEHR(0x18B3)
#define VER_E_ENDFILTER_STACK   EMAKEHR(0x18B4)
#define VER_E_DLGT_SIG_I        EMAKEHR(0x18B5)
#define VER_E_DLGT_SIG_O        EMAKEHR(0x18B6)
#define VER_E_RA_PTR_TO_STACK   EMAKEHR(0x18B7)
#define VER_E_CATCH_VALUE_TYPE  EMAKEHR(0x18B8)
#define VER_E_CATCH_BYREF       EMAKEHR(0x18B9)
#define VER_E_FIL_PRECEED_HND   EMAKEHR(0x18BA)
#define VER_E_LDVIRTFTN_STATIC  EMAKEHR(0x18BB)
#define VER_E_CALLVIRT_STATIC   EMAKEHR(0x18BC)
#define VER_E_INITLOCALS        EMAKEHR(0x18BD)
#define VER_E_BR_TO_EXCEPTION   EMAKEHR(0x18BE)
#define VER_E_CALL_CTOR         EMAKEHR(0x18BF)

//@GENERICSVER: new generics related error messages
#define VER_E_VALCLASS_OBJREF_VAR          EMAKEHR(0x18C0)
#define VER_E_STACK_P_VALCLASS_OBJREF_VAR  EMAKEHR(0x18C1)
#define VER_E_SIG_VAR_PARAM     EMAKEHR(0x18C2)
#define VER_E_SIG_MVAR_PARAM    EMAKEHR(0x18C3)
#define VER_E_SIG_VAR_ARG       EMAKEHR(0x18C4)
#define VER_E_SIG_MVAR_ARG      EMAKEHR(0x18C5)
#define VER_E_SIG_GENERICINST   EMAKEHR(0x18C6)
#define VER_E_SIG_METHOD_INST   EMAKEHR(0x18C7)
#define VER_E_SIG_METHOD_PARENT_INST    EMAKEHR(0x18C8)
#define VER_E_SIG_FIELD_PARENT_INST     EMAKEHR(0x18C9)
#define VER_E_CALLCONV_NOT_GENERICINST  EMAKEHR(0x18CA)
#define VER_E_TOKEN_BAD_METHOD_SPEC     EMAKEHR(0x18CB)
#define VER_E_BAD_READONLY_PREFIX       EMAKEHR(0x18CC)
#define VER_E_BAD_CONSTRAINED_PREFIX    EMAKEHR(0x18CD)
//these two are actually raised by the EE - should they appear elsewhere?
#define VER_E_CIRCULAR_VAR_CONSTRAINTS  EMAKEHR(0x18CE)
#define VER_E_CIRCULAR_MVAR_CONSTRAINTS EMAKEHR(0x18CF)
//these are used by the new peverify
#define VER_E_UNSATISFIED_METHOD_INST           EMAKEHR(0x18D0)
#define VER_E_UNSATISFIED_METHOD_PARENT_INST    EMAKEHR(0x18D1)
#define VER_E_UNSATISFIED_FIELD_PARENT_INST     EMAKEHR(0x18D2)
#define VER_E_UNSATISFIED_BOX_OPERAND           EMAKEHR(0x18D3)
#define VER_E_CONSTRAINED_CALL_WITH_NON_BYREF_THIS  EMAKEHR(0x18D4)
#define VER_E_CONSTRAINED_OF_NON_VARIABLE_TYPE EMAKEHR(0x18D5)
#define VER_E_READONLY_UNEXPECTED_CALLEE       EMAKEHR(0x18D6)
#define VER_E_READONLY_ILLEGAL_WRITE           EMAKEHR(0x18D7)
#define VER_E_READONLY_IN_MKREFANY             EMAKEHR(0x18D8)
#define VER_E_UNALIGNED_ALIGNMENT              EMAKEHR(0x18D9)
#define VER_E_TAILCALL_INSIDE_EH               EMAKEHR(0x18DA)
#define VER_E_BACKWARD_BRANCH                  EMAKEHR(0x18DB)
#define VER_E_CALL_TO_VTYPE_BASE               EMAKEHR(0x18DC)
#define VER_E_NEWOBJ_OF_ABSTRACT_CLASS         EMAKEHR(0x18DD)
#define VER_E_UNMANAGED_POINTER                EMAKEHR(0x18DE)
#define VER_E_LDFTN_NON_FINAL_VIRTUAL          EMAKEHR(0x18DF)
#define VER_E_FIELD_OVERLAP                    EMAKEHR(0x18E0)
#define VER_E_THIS_MISMATCH                    EMAKEHR(0x18E1)
#define VER_E_STACK_I_I4                       EMAKEHR(0x18E2)

#define VER_E_BAD_PE            EMAKEHR(0x18F0)
#define VER_E_BAD_MD            EMAKEHR(0x18F1)
#define VER_E_BAD_APPDOMAIN     EMAKEHR(0x18F2)
#define VER_E_TYPELOAD          EMAKEHR(0x18F3)
#define VER_E_PE_LOAD           EMAKEHR(0x18F4)
#define VER_E_WRITE_RVA_STATIC  EMAKEHR(0x18F5)


//
// ATTENTION: Range 0x1900 - 0x1AFF is reserved for Framework errors
//            Range 0x1B00 - 0x1BFF is reserved for MD Validator errors (see above VLDTR_E_...)
//

// System.Xml
#define COR_E_Xml                        EMAKEHR(0x1940)
#define COR_E_XmlSchema                  EMAKEHR(0x1941)
#define COR_E_XmlXslt                    EMAKEHR(0x1942)
#define COR_E_XmlXPath                   EMAKEHR(0x1943)
#define COR_E_XmlQuery                   EMAKEHR(0x1944)

// System.Data DataSet
#define COR_E_Data                       EMAKEHR(0x1920)
#define COR_E_DataDeletedRowInaccessible EMAKEHR(0x1921)
#define COR_E_DataDuplicateName          EMAKEHR(0x1922)
#define COR_E_DataInRowChangingEvent     EMAKEHR(0x1923)
#define COR_E_DataInvalidConstraint      EMAKEHR(0x1924)
#define COR_E_DataMissingPrimaryKey      EMAKEHR(0x1925)
#define COR_E_DataNoNullAllowed          EMAKEHR(0x1926)
#define COR_E_DataReadOnly               EMAKEHR(0x1927)
#define COR_E_DataRowNotInTable          EMAKEHR(0x1928)
#define COR_E_DataVersionNotFound        EMAKEHR(0x1929)
#define COR_E_DataConstraint             EMAKEHR(0x192A)
#define COR_E_StrongTyping               EMAKEHR(0x192B)

// System.Data Managed Providers
#define COR_E_SqlType                    EMAKEHR(0x1930)
#define COR_E_SqlNullValue               EMAKEHR(0x1931)
#define COR_E_SqlTruncate                EMAKEHR(0x1932)
#define COR_E_AdapterMapping             EMAKEHR(0x1933)
#define COR_E_DataAdapter                EMAKEHR(0x1934)
#define COR_E_DBConcurrency              EMAKEHR(0x1935)
#define COR_E_OperationAborted           EMAKEHR(0x1936)
#define COR_E_InvalidUdt                 EMAKEHR(0x1937)

#define COR_E_SqlException               EMAKEHR(0x1904)  // System.Data.SqlClient.SqlClientException
#define COR_E_OdbcException              EMAKEHR(0x1937)  // System.Data.Odbc.OdbcException
#define COR_E_OracleException            EMAKEHR(0x1938)  // System.Data.OracleClient.OracleException


//**** More debugger error 1C00 - 1CFF
//
#define CORDBG_E_THREAD_NOT_SCHEDULED                   EMAKEHR(0x1C00) // Thread is not scheduled. Thus we may not have OSThreadId, handle, or context
#define CORDBG_E_HANDLE_HAS_BEEN_DISPOSED               EMAKEHR(0x1C01) // Handle has been disposed.
#define CORDBG_E_NONINTERCEPTABLE_EXCEPTION             EMAKEHR(0x1C02) // Cant intercept this exception.
#define CORDBG_E_CANT_UNWIND_ABOVE_CALLBACK             EMAKEHR(0x1C03) // When intercepting an exception, cannot intercept above the current frame.
#define CORDBG_E_INTERCEPT_FRAME_ALREADY_SET            EMAKEHR(0x1C04) // The intercept frame for this exception has already been set.
#define CORDBG_E_NO_NATIVE_PATCH_AT_ADDR                EMAKEHR(0x1C05) // there's no native patch at the given address.
#define CORDBG_E_MUST_BE_INTEROP_DEBUGGING              EMAKEHR(0x1C06) // This API is only allowed when interop debugging.
#define CORDBG_E_NATIVE_PATCH_ALREADY_AT_ADDR           EMAKEHR(0x1C07) // There's already a native patch at the address
#define CORDBG_E_TIMEOUT                                EMAKEHR(0x1C08) // a wait timed out .. likely an indication of deadlock.
#define CORDBG_E_CANT_CALL_ON_THIS_THREAD               EMAKEHR(0x1C09) // Can't use the API on this thread.
#define CORDBG_E_ENC_INFOLESS_METHOD                    EMAKEHR(0x1C0A) // Method was not JITed in EnC mode
#define CORDBG_E_ENC_NESTED_HANLDERS                    EMAKEHR(0x1C0B) // Frame cant be updated due to change in max nesting of handlers
#define CORDBG_E_ENC_IN_FUNCLET                         EMAKEHR(0x1C0C) // Method is in a callable handler/filter. Cant grow stack
#define CORDBG_E_ENC_LOCALLOC                           EMAKEHR(0x1C0D) // Frame cant be updated due to localloc
#define CORDBG_E_ENC_EDIT_NOT_SUPPORTED                 EMAKEHR(0x1C0E) // Attempt to perform unsupported edit
#define CORDBG_E_FEABORT_DELAYED_UNTIL_THREAD_RESUMED   EMAKEHR(0x1C0F) // Attempt to func eval abort on a suspended thread.
#define CORDBG_E_NOTREADY                               EMAKEHR(0x1C10) // The LS is not in a good spot to perform the requested operation.
#define CORDBG_E_CANNOT_RESOLVE_ASSEMBLY                EMAKEHR(0x1c11) // We failed to resolve assembly given an AssemblyRef token. Assembly may be not loaded yet or not a valid token.
#define CORDBG_E_MUST_BE_IN_LOAD_MODULE                 EMAKEHR(0x1C12) // Must be in context of LoadModule callback to perform requested operation
#define CORDBG_E_CANNOT_BE_ON_ATTACH                    EMAKEHR(0x1C13) // Requested operation cannot be performed during an attach operation
#define CORDBG_S_NOT_ALL_BITS_SET                            SMAKEHR(0x1C13) // Not all bits specified were successfully applied
#define CORDBG_E_NGEN_NOT_SUPPORTED                     EMAKEHR(0x1C14) // NGEN must be supported to perform the requested operation
#define CORDBG_E_ILLEGAL_SHUTDOWN_ORDER                 EMAKEHR(0x1C15) // Trying to shutdown out of order.
#define CORDBG_E_CANNOT_DEBUG_FIBER_PROCESS             EMAKEHR(0x1C16) // For Whidbey, we don't support debugging fiber mode managed process
#define CORDBG_E_MUST_BE_IN_CREATE_PROCESS              EMAKEHR(0x1C17) // Must be in context of CreateProcess callback to perform requested operation
#define CORDBG_E_DETACH_FAILED_OUTSTANDING_EVALS        EMAKEHR(0x1C18) // All outstanding func-evals have not completed, detaching is not allowed at this time.
#define CORDBG_E_DETACH_FAILED_OUTSTANDING_STEPPERS     EMAKEHR(0x1C19) // All outstanding steppers have not been closed, detaching is not allowed at this time.
#define CORDBG_E_CANT_INTEROP_STEP_OUT                  EMAKEHR(0x1C20) // Can't have an ICorDebugStepper do a native step-out.
#define CORDBG_E_DETACH_FAILED_OUTSTANDING_BREAKPOINTS  EMAKEHR(0x1C21) // All outstanding breakpoints have not been closed, detaching is not allowed at this time.
#define CORDBG_E_ILLEGAL_IN_STACK_OVERFLOW              EMAKEHR(0x1c22) // the operation is illegal because of a stackoverflow.
#define CORDBG_E_ILLEGAL_AT_GC_UNSAFE_POINT             EMAKEHR(0x1c23) // The operation failed because it's a GC unsafe point.
#define CORDBG_E_ILLEGAL_IN_PROLOG                      EMAKEHR(0x1c24) // The operation failed because the thread is in the prolog
#define CORDBG_E_ILLEGAL_IN_NATIVE_CODE                 EMAKEHR(0x1c25) // The operation failed because the thread is in native code
#define CORDBG_E_ILLEGAL_IN_OPTIMIZED_CODE              EMAKEHR(0x1c26) // The operation failed because the thread is in optimized code.
#define CORDBG_E_MINIDUMP_UNSUPPORTED                   EMAKEHR(0x1c27) //
#define CORDBG_E_APPDOMAIN_MISMATCH                     EMAKEHR(0x1c28) // A supplied object or type belongs to the wrong AppDomain
#define CORDBG_E_CONTEXT_UNVAILABLE                     EMAKEHR(0x1c29) // The thread's context is not available.
#define CORDBG_E_UNCOMPATIBLE_PLATFORMS                 EMAKEHR(0x1c30) // The operation failed because debuggee and debugger are on incompatible platform
#define CORDBG_E_DEBUGGING_DISABLED                     EMAKEHR(0x1c31) // The operation failed because the debugging has been disabled
#define CORDBG_E_DETACH_FAILED_ON_ENC                   EMAKEHR(0x1c32) // Detach is illegal after a module has been EnCed.
#define CORDBG_E_CURRENT_EXCEPTION_IS_OUTSIDE_CURRENT_EXECUTION_SCOPE EMAKEHR(0x1c33) // Interception of the current exception is not legal
#define CORDBG_E_HELPER_MAY_DEADLOCK                    EMAKEHR(0x1c34) // Helper thread can not safely run code. The opereration may work at a later time.



//**** PE Format validation errors 1D00 - 1DFF
//
#define PEFMT_E_NO_CONTENTS                             EMAKEHR(0x1D00) // File is empty
#define PEFMT_E_NO_NTHEADERS                            EMAKEHR(0x1D01) // File has no NT headers
#define PEFMT_E_64BIT                                   EMAKEHR(0x1D02) // File is PE32+
#define PEFMT_E_NO_CORHEADER                            EMAKEHR(0x1D03) // File has no COR header
#define PEFMT_E_NOT_ILONLY                              EMAKEHR(0x1D04) // Flag IL_ONLY not set
#define PEFMT_E_IMPORT_DLLS                             EMAKEHR(0x1D05) // Bad import DLLs
#define PEFMT_E_EXE_NOENTRYPOINT                        EMAKEHR(0x1D06) // EXE file has no mgd entry point
#define PEFMT_E_BASE_RELOCS                             EMAKEHR(0x1D07) // Bad base relocations
#define PEFMT_E_ENTRYPOINT                              EMAKEHR(0x1D08) // Bad managed entry point
#define PEFMT_E_ZERO_SIZEOFCODE                         EMAKEHR(0x1D09) // OptHeader.SizeOfCode==0
#define PEFMT_E_BAD_CORHEADER                           EMAKEHR(0x1D0A) // File has invalid COR header

//**** CLR Optimization service 1E00 - 1EFF
//
#define CLR_OPTSVC_E_CONTROLLER_INTERRUPT               EMAKEHR(0x1E00) // Service controller interrupted work


//**** CLR Optimization service 1F00 - 1FFF
//
#define NGEN_FAILED_GET_DEPENDENCIES                    EMAKEHR(0x1F00)  // Service manager failed to get ICorSvcDependencies interface
#define NGEN_FAILED_NATIVE_IMAGE_DELETE                 EMAKEHR(0x1F01)  // Failed to delete native image





#endif // __COMMON_LANGUAGE_RUNTIME_HRESULTS__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\CorHdr.h ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
/*****************************************************************************
 **                                                                         **
 ** CorHdr.h - contains definitions for the Runtime structures,             **
 **            needed to work with metadata.                                **
 **                                                                         **
 *****************************************************************************/


#ifndef __CORHDR_H__
#define __CORHDR_H__

#define FRAMEWORK_REGISTRY_KEY          "Software\\Microsoft\\.NETFramework"
#define FRAMEWORK_REGISTRY_KEY_W        L"Software\\Microsoft\\.NETFramework"

#ifdef _MSC_VER
#pragma warning(disable:4200) // nonstandard extension used : zero-sized array in struct/union.
#endif
typedef LPVOID  mdScope;                // Obsolete; not used in the runtime.
typedef ULONG32 mdToken;                // Generic token


// Token  definitions


typedef mdToken mdModule;               // Module token (roughly, a scope)
typedef mdToken mdTypeRef;              // TypeRef reference (this or other scope)
typedef mdToken mdTypeDef;              // TypeDef in this scope
typedef mdToken mdFieldDef;             // Field in this scope
typedef mdToken mdMethodDef;            // Method in this scope
typedef mdToken mdParamDef;             // param token
typedef mdToken mdInterfaceImpl;        // interface implementation token

typedef mdToken mdMemberRef;            // MemberRef (this or other scope)
typedef mdToken mdCustomAttribute;      // attribute token
typedef mdToken mdPermission;           // DeclSecurity

typedef mdToken mdSignature;            // Signature object
typedef mdToken mdEvent;                // event token
typedef mdToken mdProperty;             // property token

typedef mdToken mdModuleRef;            // Module reference (for the imported modules)

// Assembly tokens.
typedef mdToken mdAssembly;             // Assembly token.
typedef mdToken mdAssemblyRef;          // AssemblyRef token.
typedef mdToken mdFile;                 // File token.
typedef mdToken mdExportedType;         // ExportedType token.
typedef mdToken mdManifestResource;     // ManifestResource token.

typedef mdToken mdTypeSpec;             // TypeSpec object

typedef mdToken mdGenericParam;         // formal parameter to generic type or method
typedef mdToken mdMethodSpec;           // instantiation of a generic method
typedef mdToken mdGenericParamConstraint; // constraint on a formal generic parameter

// Application string.
typedef mdToken mdString;               // User literal string token.

typedef mdToken mdCPToken;              // constantpool token

#ifndef MACROS_NOT_SUPPORTED
typedef ULONG RID;
#else
typedef unsigned RID;
#endif // MACROS_NOT_SUPPORTED

typedef enum ReplacesGeneralNumericDefines
{
// Directory entry macro for CLR data.
#ifndef IMAGE_DIRECTORY_ENTRY_COMHEADER
    IMAGE_DIRECTORY_ENTRY_COMHEADER     =14,
#endif // IMAGE_DIRECTORY_ENTRY_COMHEADER

    _NEW_FLAGS_IMPLEMENTED              =1,
    __NEW_FLAGS_IMPLEMENTED             =1,
} ReplacesGeneralNumericDefines;


#ifndef __IMAGE_COR20_HEADER_DEFINED__
#define __IMAGE_COR20_HEADER_DEFINED__

typedef enum ReplacesCorHdrNumericDefines
{
// COM+ Header entry point flags.
    COMIMAGE_FLAGS_ILONLY               =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED        =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY           =0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED     =0x00000008,
// DDBLD - Added Next Line - Still verifying general usage
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT    =0x00000010,
// DDBLD - End of Add
    COMIMAGE_FLAGS_TRACKDEBUGDATA       =0x00010000,

// Version flags for image.
    COR_VERSION_MAJOR_V2                =2,
    COR_VERSION_MAJOR                   =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR                   =5,
    COR_DELETED_NAME_LENGTH             =8,
    COR_VTABLEGAP_NAME_LENGTH           =8,

// Maximum size of a NativeType descriptor.
    NATIVE_TYPE_MAX_CB                  =1,   
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,

// #defines for the MIH FLAGS
    IMAGE_COR_MIH_METHODRVA             =0x01,
    IMAGE_COR_MIH_EHRVA                 =0x02,    
    IMAGE_COR_MIH_BASICBLOCK            =0x08,

// V-table constants
    COR_VTABLE_32BIT                    =0x01,          // V-table slots are 32-bits in size.   
    COR_VTABLE_64BIT                    =0x02,          // V-table slots are 64-bits in size.   
    COR_VTABLE_FROM_UNMANAGED           =0x04,          // If set, transition from unmanaged.
    COR_VTABLE_CALL_MOST_DERIVED        =0x10,          // Call most derived method described by

// EATJ constants
    IMAGE_COR_EATJ_THUNK_SIZE           =32,            // Size of a jump thunk reserved range.

// Max name lengths    
    //@todo: Change to unlimited name lengths.
    MAX_CLASS_NAME                      =1024,
    MAX_PACKAGE_NAME                    =1024,
} ReplacesCorHdrNumericDefines;

// COM+ 2.0 header structure.
typedef struct IMAGE_COR20_HEADER
{
    // Header versioning
    DWORD                   cb;              
    WORD                    MajorRuntimeVersion;
    WORD                    MinorRuntimeVersion;
    
    // Symbol table and startup information
    IMAGE_DATA_DIRECTORY    MetaData;        
    DWORD                   Flags;           
// DDBLD - Added next section to replace following lin
// DDBLD - Still verifying, since not in NT SDK
//    DWORD                   EntryPointToken;
  
    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is not set, EntryPointToken represents a managed entrypoint.
    // If COMIMAGE_FLAGS_NATIVE_ENTRYPOINT is set, EntryPointRVA represents an RVA to a native entrypoint.
    union {
        DWORD               EntryPointToken;
        DWORD               EntryPointRVA;
    };
// DDBLD - End of Added Area
    
    // Binding information
    IMAGE_DATA_DIRECTORY    Resources;
    IMAGE_DATA_DIRECTORY    StrongNameSignature;

    // Regular fixup and binding information
    IMAGE_DATA_DIRECTORY    CodeManagerTable;
    IMAGE_DATA_DIRECTORY    VTableFixups;
    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps;

    // Precompiled image info (internal use only - set to zero)
    IMAGE_DATA_DIRECTORY    ManagedNativeHeader;
    
} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;

#else // !__IMAGE_COR20_HEADER_DEFINED__

// <TODO>@TODO: This hack is required because we pull in the COM+ 2.0 PE header
// definition from winnt.h, and the constant below hasn't propogated yet.</TODO>
#define COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN 0x08

#endif // __IMAGE_COR20_HEADER_DEFINED__

// The most recent version.

#define COR_CTOR_METHOD_NAME        ".ctor"
#define COR_CTOR_METHOD_NAME_W      L".ctor"
#define COR_CCTOR_METHOD_NAME       ".cctor"
#define COR_CCTOR_METHOD_NAME_W     L".cctor"

#define COR_ENUM_FIELD_NAME         "value__"
#define COR_ENUM_FIELD_NAME_W       L"value__"

// The predefined name for deleting a typeDef,MethodDef, FieldDef, Property and Event
#define COR_DELETED_NAME_A          "_Deleted"
#define COR_DELETED_NAME_W          L"_Deleted"
#define COR_VTABLEGAP_NAME_A        "_VtblGap"
#define COR_VTABLEGAP_NAME_W        L"_VtblGap"

// We intentionally use strncmp so that we will ignore any suffix
#define IsDeletedName(strName)      (strncmp(strName, COR_DELETED_NAME_A, COR_DELETED_NAME_LENGTH) == 0)
#define IsVtblGapName(strName)      (strncmp(strName, COR_VTABLEGAP_NAME_A, COR_VTABLEGAP_NAME_LENGTH) == 0)

// TypeDef/ExportedType attr bits, used by DefineTypeDef.
typedef enum CorTypeAttr
{
    // Use this mask to retrieve the type visibility information.
    tdVisibilityMask        =   0x00000007,
    tdNotPublic             =   0x00000000,     // Class is not public scope.
    tdPublic                =   0x00000001,     // Class is public scope.
    tdNestedPublic          =   0x00000002,     // Class is nested with public visibility.
    tdNestedPrivate         =   0x00000003,     // Class is nested with private visibility.
    tdNestedFamily          =   0x00000004,     // Class is nested with family visibility.
    tdNestedAssembly        =   0x00000005,     // Class is nested with assembly visibility.
    tdNestedFamANDAssem     =   0x00000006,     // Class is nested with family and assembly visibility.
    tdNestedFamORAssem      =   0x00000007,     // Class is nested with family or assembly visibility.

    // Use this mask to retrieve class layout information
    tdLayoutMask            =   0x00000018,
    tdAutoLayout            =   0x00000000,     // Class fields are auto-laid out
    tdSequentialLayout      =   0x00000008,     // Class fields are laid out sequentially
    tdExplicitLayout        =   0x00000010,     // Layout is supplied explicitly
    // end layout mask

    // Use this mask to retrieve class semantics information.
    tdClassSemanticsMask    =   0x00000060,
    tdClass                 =   0x00000000,     // Type is a class.
    tdInterface             =   0x00000020,     // Type is an interface.
    // end semantics mask

    // Special semantics in addition to class semantics.
    tdAbstract              =   0x00000080,     // Class is abstract
    tdSealed                =   0x00000100,     // Class is concrete and may not be extended
    tdSpecialName           =   0x00000400,     // Class name is special.  Name describes how.

    // Implementation attributes.
    tdImport                =   0x00001000,     // Class / interface is imported
    tdSerializable          =   0x00002000,     // The class is Serializable.

    // Use tdStringFormatMask to retrieve string information for native interop
    tdStringFormatMask      =   0x00030000,
    tdAnsiClass             =   0x00000000,     // LPTSTR is interpreted as ANSI in this class
    tdUnicodeClass          =   0x00010000,     // LPTSTR is interpreted as UNICODE
    tdAutoClass             =   0x00020000,     // LPTSTR is interpreted automatically
    tdCustomFormatClass     =   0x00030000,     // A non-standard encoding specified by CustomFormatMask
    tdCustomFormatMask      =   0x00C00000,     // Use this mask to retrieve non-standard encoding information for native interop. The meaning of the values of these 2 bits is unspecified.

    // end string format mask

    tdBeforeFieldInit       =   0x00100000,     // Initialize the class any time before first static field access.
    tdForwarder             =   0x00200000,     // This ExportedType is a type forwarder.

    // Flags reserved for runtime use.
    tdReservedMask          =   0x00040800,
    tdRTSpecialName         =   0x00000800,     // Runtime should check name encoding.
    tdHasSecurity           =   0x00040000,     // Class has security associate with it.
} CorTypeAttr;


// Macros for accessing the members of the CorTypeAttr.
#define IsTdNotPublic(x)                    (((x) & tdVisibilityMask) == tdNotPublic)
#define IsTdPublic(x)                       (((x) & tdVisibilityMask) == tdPublic)
#define IsTdNestedPublic(x)                 (((x) & tdVisibilityMask) == tdNestedPublic)
#define IsTdNestedPrivate(x)                (((x) & tdVisibilityMask) == tdNestedPrivate)
#define IsTdNestedFamily(x)                 (((x) & tdVisibilityMask) == tdNestedFamily)
#define IsTdNestedAssembly(x)               (((x) & tdVisibilityMask) == tdNestedAssembly)
#define IsTdNestedFamANDAssem(x)            (((x) & tdVisibilityMask) == tdNestedFamANDAssem)
#define IsTdNestedFamORAssem(x)             (((x) & tdVisibilityMask) == tdNestedFamORAssem)
#define IsTdNested(x)                       (((x) & tdVisibilityMask) >= tdNestedPublic)

#define IsTdAutoLayout(x)                   (((x) & tdLayoutMask) == tdAutoLayout)
#define IsTdSequentialLayout(x)             (((x) & tdLayoutMask) == tdSequentialLayout)
#define IsTdExplicitLayout(x)               (((x) & tdLayoutMask) == tdExplicitLayout)

#define IsTdClass(x)                        (((x) & tdClassSemanticsMask) == tdClass)
#define IsTdInterface(x)                    (((x) & tdClassSemanticsMask) == tdInterface)

#define IsTdAbstract(x)                     ((x) & tdAbstract)
#define IsTdSealed(x)                       ((x) & tdSealed)
#define IsTdSpecialName(x)                  ((x) & tdSpecialName)

#define IsTdImport(x)                       ((x) & tdImport)
#define IsTdSerializable(x)                 ((x) & tdSerializable)

#define IsTdAnsiClass(x)                    (((x) & tdStringFormatMask) == tdAnsiClass)
#define IsTdUnicodeClass(x)                 (((x) & tdStringFormatMask) == tdUnicodeClass)
#define IsTdAutoClass(x)                    (((x) & tdStringFormatMask) == tdAutoClass)
#define IsTdCustomFormatClass(x)            (((x) & tdStringFormatMask) == tdCustomFormatClass)
#define IsTdBeforeFieldInit(x)              ((x) & tdBeforeFieldInit)
#define IsTdForwarder(x)                    ((x) & tdForwarder)

#define IsTdRTSpecialName(x)                ((x) & tdRTSpecialName)
#define IsTdHasSecurity(x)                  ((x) & tdHasSecurity)

// MethodDef attr bits, Used by DefineMethod.
typedef enum CorMethodAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    mdMemberAccessMask          =   0x0007,
    mdPrivateScope              =   0x0000,     // Member not referenceable.
    mdPrivate                   =   0x0001,     // Accessible only by the parent type.
    mdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    mdAssem                     =   0x0003,     // Accessibly by anyone in the Assembly.
    mdFamily                    =   0x0004,     // Accessible only by type and sub-types.
    mdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    mdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.
    // end member access mask

    // method contract attributes.
    mdStatic                    =   0x0010,     // Defined on type, else per instance.
    mdFinal                     =   0x0020,     // Method may not be overridden.
    mdVirtual                   =   0x0040,     // Method virtual.
    mdHideBySig                 =   0x0080,     // Method hides by name+sig, else just by name.

    // vtable layout mask - Use this mask to retrieve vtable attributes.
    mdVtableLayoutMask          =   0x0100,
    mdReuseSlot                 =   0x0000,     // The default.
    mdNewSlot                   =   0x0100,     // Method always gets a new slot in the vtable.
    // end vtable layout mask

    // method implementation attributes.
    mdCheckAccessOnOverride     =   0x0200,     // Overridability is the same as the visibility.
    mdAbstract                  =   0x0400,     // Method does not provide an implementation.
    mdSpecialName               =   0x0800,     // Method is special.  Name describes how.

    // interop attributes
    mdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.
    mdUnmanagedExport           =   0x0008,     // Managed method exported via thunk to unmanaged code.

    // Reserved flags for runtime use only.
    mdReservedMask              =   0xd000,
    mdRTSpecialName             =   0x1000,     // Runtime should check name encoding.
    mdHasSecurity               =   0x4000,     // Method has security associate with it.
    mdRequireSecObject          =   0x8000,     // Method calls another method containing security code.

} CorMethodAttr;

// Macros for accessing the members of CorMethodAttr.
#define IsMdPrivateScope(x)                 (((x) & mdMemberAccessMask) == mdPrivateScope)
#define IsMdPrivate(x)                      (((x) & mdMemberAccessMask) == mdPrivate)
#define IsMdFamANDAssem(x)                  (((x) & mdMemberAccessMask) == mdFamANDAssem)
#define IsMdAssem(x)                        (((x) & mdMemberAccessMask) == mdAssem)
#define IsMdFamily(x)                       (((x) & mdMemberAccessMask) == mdFamily)
#define IsMdFamORAssem(x)                   (((x) & mdMemberAccessMask) == mdFamORAssem)
#define IsMdPublic(x)                       (((x) & mdMemberAccessMask) == mdPublic)

#define IsMdStatic(x)                       ((x) & mdStatic)
#define IsMdFinal(x)                        ((x) & mdFinal)
#define IsMdVirtual(x)                      ((x) & mdVirtual)
#define IsMdHideBySig(x)                    ((x) & mdHideBySig)

#define IsMdReuseSlot(x)                    (((x) & mdVtableLayoutMask) == mdReuseSlot)
#define IsMdNewSlot(x)                      (((x) & mdVtableLayoutMask) == mdNewSlot)

#define IsMdCheckAccessOnOverride(x)        ((x) & mdCheckAccessOnOverride)
#define IsMdAbstract(x)                     ((x) & mdAbstract)
#define IsMdSpecialName(x)                  ((x) & mdSpecialName)

#define IsMdPinvokeImpl(x)                  ((x) & mdPinvokeImpl)
#define IsMdUnmanagedExport(x)              ((x) & mdUnmanagedExport)

#define IsMdRTSpecialName(x)                ((x) & mdRTSpecialName)
#define IsMdInstanceInitializer(x, str)     (((x) & mdRTSpecialName) && !strcmp((str), COR_CTOR_METHOD_NAME))
#define IsMdInstanceInitializerW(x, str)    (((x) & mdRTSpecialName) && !wcscmp((str), COR_CTOR_METHOD_NAME_W))
#define IsMdClassConstructor(x, str)        (((x) & mdRTSpecialName) && !strcmp((str), COR_CCTOR_METHOD_NAME))
#define IsMdClassConstructorW(x, str)       (((x) & mdRTSpecialName) && !wcscmp((str), COR_CCTOR_METHOD_NAME_W))
#define IsMdHasSecurity(x)                  ((x) & mdHasSecurity)
#define IsMdRequireSecObject(x)             ((x) & mdRequireSecObject)

// FieldDef attr bits, used by DefineField.
typedef enum CorFieldAttr
{
    // member access mask - Use this mask to retrieve accessibility information.
    fdFieldAccessMask           =   0x0007,
    fdPrivateScope              =   0x0000,     // Member not referenceable.
    fdPrivate                   =   0x0001,     // Accessible only by the parent type.
    fdFamANDAssem               =   0x0002,     // Accessible by sub-types only in this Assembly.
    fdAssembly                  =   0x0003,     // Accessibly by anyone in the Assembly.
    fdFamily                    =   0x0004,     // Accessible only by type and sub-types.
    fdFamORAssem                =   0x0005,     // Accessibly by sub-types anywhere, plus anyone in assembly.
    fdPublic                    =   0x0006,     // Accessibly by anyone who has visibility to this scope.
    // end member access mask

    // field contract attributes.
    fdStatic                    =   0x0010,     // Defined on type, else per instance.
    fdInitOnly                  =   0x0020,     // Field may only be initialized, not written to after init.
    fdLiteral                   =   0x0040,     // Value is compile time constant.
    fdNotSerialized             =   0x0080,     // Field does not have to be serialized when type is remoted.

    fdSpecialName               =   0x0200,     // field is special.  Name describes how.

    // interop attributes
    fdPinvokeImpl               =   0x2000,     // Implementation is forwarded through pinvoke.

    // Reserved flags for runtime use only.
    fdReservedMask              =   0x9500,
    fdRTSpecialName             =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    fdHasFieldMarshal           =   0x1000,     // Field has marshalling information.
    fdHasDefault                =   0x8000,     // Field has default.
    fdHasFieldRVA               =   0x0100,     // Field has RVA.
} CorFieldAttr;

// Macros for accessing the members of CorFieldAttr.
#define IsFdPrivateScope(x)                 (((x) & fdFieldAccessMask) == fdPrivateScope)
#define IsFdPrivate(x)                      (((x) & fdFieldAccessMask) == fdPrivate)
#define IsFdFamANDAssem(x)                  (((x) & fdFieldAccessMask) == fdFamANDAssem)
#define IsFdAssembly(x)                     (((x) & fdFieldAccessMask) == fdAssembly)
#define IsFdFamily(x)                       (((x) & fdFieldAccessMask) == fdFamily)
#define IsFdFamORAssem(x)                   (((x) & fdFieldAccessMask) == fdFamORAssem)
#define IsFdPublic(x)                       (((x) & fdFieldAccessMask) == fdPublic)

#define IsFdStatic(x)                       ((x) & fdStatic)
#define IsFdInitOnly(x)                     ((x) & fdInitOnly)
#define IsFdLiteral(x)                      ((x) & fdLiteral)
#define IsFdNotSerialized(x)                ((x) & fdNotSerialized)

#define IsFdPinvokeImpl(x)                  ((x) & fdPinvokeImpl)
#define IsFdSpecialName(x)                  ((x) & fdSpecialName)
#define IsFdHasFieldRVA(x)                  ((x) & fdHasFieldRVA)

#define IsFdRTSpecialName(x)                ((x) & fdRTSpecialName)
#define IsFdHasFieldMarshal(x)              ((x) & fdHasFieldMarshal)
#define IsFdHasDefault(x)                   ((x) & fdHasDefault)

// Param attr bits, used by DefineParam.
typedef enum CorParamAttr
{
    pdIn                        =   0x0001,     // Param is [In]
    pdOut                       =   0x0002,     // Param is [out]
    pdOptional                  =   0x0010,     // Param is optional

    // Reserved flags for Runtime use only.
    pdReservedMask              =   0xf000,
    pdHasDefault                =   0x1000,     // Param has default value.
    pdHasFieldMarshal           =   0x2000,     // Param has FieldMarshal.

    pdUnused                    =   0xcfe0,
} CorParamAttr;

// Macros for accessing the members of CorParamAttr.
#define IsPdIn(x)                           ((x) & pdIn)
#define IsPdOut(x)                          ((x) & pdOut)
#define IsPdOptional(x)                     ((x) & pdOptional)

#define IsPdHasDefault(x)                   ((x) & pdHasDefault)
#define IsPdHasFieldMarshal(x)              ((x) & pdHasFieldMarshal)


// Property attr bits, used by DefineProperty.
typedef enum CorPropertyAttr
{
    prSpecialName           =   0x0200,     // property is special.  Name describes how.

    // Reserved flags for Runtime use only.
    prReservedMask          =   0xf400,
    prRTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
    prHasDefault            =   0x1000,     // Property has default

    prUnused                =   0xe9ff,
} CorPropertyAttr;

// Macros for accessing the members of CorPropertyAttr.
#define IsPrSpecialName(x)                  ((x) & prSpecialName)

#define IsPrRTSpecialName(x)                ((x) & prRTSpecialName)
#define IsPrHasDefault(x)                   ((x) & prHasDefault)

// Event attr bits, used by DefineEvent.
typedef enum CorEventAttr
{
    evSpecialName           =   0x0200,     // event is special.  Name describes how.

    // Reserved flags for Runtime use only.
    evReservedMask          =   0x0400,
    evRTSpecialName         =   0x0400,     // Runtime(metadata internal APIs) should check name encoding.
} CorEventAttr;

// Macros for accessing the members of CorEventAttr.
#define IsEvSpecialName(x)                  ((x) & evSpecialName)

#define IsEvRTSpecialName(x)                ((x) & evRTSpecialName)


// MethodSemantic attr bits, used by DefineProperty, DefineEvent.
typedef enum CorMethodSemanticsAttr
{
    msSetter    =   0x0001,     // Setter for property
    msGetter    =   0x0002,     // Getter for property
    msOther     =   0x0004,     // other method for property or event
    msAddOn     =   0x0008,     // AddOn method for event
    msRemoveOn  =   0x0010,     // RemoveOn method for event
    msFire      =   0x0020,     // Fire method for event
} CorMethodSemanticsAttr;

// Macros for accessing the members of CorMethodSemanticsAttr.
#define IsMsSetter(x)                       ((x) & msSetter)
#define IsMsGetter(x)                       ((x) & msGetter)
#define IsMsOther(x)                        ((x) & msOther)
#define IsMsAddOn(x)                        ((x) & msAddOn)
#define IsMsRemoveOn(x)                     ((x) & msRemoveOn)
#define IsMsFire(x)                         ((x) & msFire)


// DeclSecurity attr bits, used by DefinePermissionSet.
typedef enum CorDeclSecurity
{
    dclActionMask               =   0x001f,     // Mask allows growth of enum.
    dclActionNil                =   0x0000,     //
    dclRequest                  =   0x0001,     //
    dclDemand                   =   0x0002,     //
    dclAssert                   =   0x0003,     //
    dclDeny                     =   0x0004,     //
    dclPermitOnly               =   0x0005,     //
    dclLinktimeCheck            =   0x0006,     //
    dclInheritanceCheck         =   0x0007,     //
    dclRequestMinimum           =   0x0008,     //
    dclRequestOptional          =   0x0009,     //
    dclRequestRefuse            =   0x000a,     //
    dclPrejitGrant              =   0x000b,     // Persisted grant set at prejit time
    dclPrejitDenied             =   0x000c,     // Persisted denied set at prejit time
    dclNonCasDemand             =   0x000d,     //
    dclNonCasLinkDemand         =   0x000e,     //
    dclNonCasInheritance        =   0x000f,     //
    dclMaximumValue             =   0x000f,     // Maximum legal value
} CorDeclSecurity;

// Macros for accessing the members of CorDeclSecurity.
#define IsDclActionNil(x)                   (((x) & dclActionMask) == dclActionNil)
// Is this a demand that can trigger a stackwalk?
#define IsDclActionAnyStackModifier(x)              ((((x) & dclActionMask) == dclAssert) || \
                                                    (((x) & dclActionMask) == dclDeny)  || \
                                                    (((x) & dclActionMask) == dclPermitOnly))

// MethodImpl attr bits, used by DefineMethodImpl.
typedef enum CorMethodImpl
{
    // code impl mask
    miCodeTypeMask      =   0x0003,   // Flags about code type.
    miIL                =   0x0000,   // Method impl is IL.
    miNative            =   0x0001,   // Method impl is native.
    miOPTIL             =   0x0002,   // Method impl is OPTIL
    miRuntime           =   0x0003,   // Method impl is provided by the runtime.
    // end code impl mask

    // managed mask
    miManagedMask       =   0x0004,   // Flags specifying whether the code is managed or unmanaged.
    miUnmanaged         =   0x0004,   // Method impl is unmanaged, otherwise managed.
    miManaged           =   0x0000,   // Method impl is managed.
    // end managed mask

    // implementation info and interop
    miForwardRef        =   0x0010,   // Indicates method is defined; used primarily in merge scenarios.
    miPreserveSig       =   0x0080,   // Indicates method sig is not to be mangled to do HRESULT conversion.

    miInternalCall      =   0x1000,   // Reserved for internal use.

    miSynchronized      =   0x0020,   // Method is single threaded through the body.
    miNoInlining        =   0x0008,   // Method may not be inlined.
    miMaxMethodImplVal  =   0xffff,   // Range check value
} CorMethodImpl;

// Macros for accesing the members of CorMethodImpl.
#define IsMiIL(x)                           (((x) & miCodeTypeMask) == miIL)
#define IsMiNative(x)                       (((x) & miCodeTypeMask) == miNative)
#define IsMiOPTIL(x)                        (((x) & miCodeTypeMask) == miOPTIL)
#define IsMiRuntime(x)                      (((x) & miCodeTypeMask) == miRuntime)

#define IsMiUnmanaged(x)                    (((x) & miManagedMask) == miUnmanaged)
#define IsMiManaged(x)                      (((x) & miManagedMask) == miManaged)

#define IsMiForwardRef(x)                   ((x) & miForwardRef)
#define IsMiPreserveSig(x)                  ((x) & miPreserveSig)

#define IsMiInternalCall(x)                 ((x) & miInternalCall)

#define IsMiSynchronized(x)                 ((x) & miSynchronized)
#define IsMiNoInlining(x)                   ((x) & miNoInlining)


// PinvokeMap attr bits, used by DefinePinvokeMap.
typedef enum  CorPinvokeMap
{
    pmNoMangle          = 0x0001,   // Pinvoke is to use the member name as specified.

    // Use this mask to retrieve the CharSet information.
    pmCharSetMask       = 0x0006,
    pmCharSetNotSpec    = 0x0000,
    pmCharSetAnsi       = 0x0002,
    pmCharSetUnicode    = 0x0004,
    pmCharSetAuto       = 0x0006,


    pmBestFitUseAssem   = 0x0000,
    pmBestFitEnabled    = 0x0010,
    pmBestFitDisabled   = 0x0020,
    pmBestFitMask       = 0x0030,

    pmThrowOnUnmappableCharUseAssem   = 0x0000,
    pmThrowOnUnmappableCharEnabled    = 0x1000,
    pmThrowOnUnmappableCharDisabled   = 0x2000,
    pmThrowOnUnmappableCharMask       = 0x3000,

    pmSupportsLastError = 0x0040,   // Information about target function. Not relevant for fields.

    // None of the calling convention flags is relevant for fields.
    pmCallConvMask      = 0x0700,
    pmCallConvWinapi    = 0x0100,   // Pinvoke will use native callconv appropriate to target windows platform.
    pmCallConvCdecl     = 0x0200,
    pmCallConvStdcall   = 0x0300,
    pmCallConvThiscall  = 0x0400,   // In M9, pinvoke will raise exception.
    pmCallConvFastcall  = 0x0500,

    pmMaxValue          = 0xFFFF,
} CorPinvokeMap;

// Macros for accessing the members of CorPinvokeMap
#define IsPmNoMangle(x)                     ((x) & pmNoMangle)

#define IsPmCharSetNotSpec(x)               (((x) & pmCharSetMask) == pmCharSetNotSpec)
#define IsPmCharSetAnsi(x)                  (((x) & pmCharSetMask) == pmCharSetAnsi)
#define IsPmCharSetUnicode(x)               (((x) & pmCharSetMask) == pmCharSetUnicode)
#define IsPmCharSetAuto(x)                  (((x) & pmCharSetMask) == pmCharSetAuto)

#define IsPmSupportsLastError(x)            ((x) & pmSupportsLastError)

#define IsPmCallConvWinapi(x)               (((x) & pmCallConvMask) == pmCallConvWinapi)
#define IsPmCallConvCdecl(x)                (((x) & pmCallConvMask) == pmCallConvCdecl)
#define IsPmCallConvStdcall(x)              (((x) & pmCallConvMask) == pmCallConvStdcall)
#define IsPmCallConvThiscall(x)             (((x) & pmCallConvMask) == pmCallConvThiscall)
#define IsPmCallConvFastcall(x)             (((x) & pmCallConvMask) == pmCallConvFastcall)

#define IsPmBestFitEnabled(x)                 (((x) & pmBestFitMask) == pmBestFitEnabled)
#define IsPmBestFitDisabled(x)                (((x) & pmBestFitMask) == pmBestFitDisabled)
#define IsPmBestFitUseAssem(x)                (((x) & pmBestFitMask) == pmBestFitUseAssem)

#define IsPmThrowOnUnmappableCharEnabled(x)   (((x) & pmThrowOnUnmappableCharMask) == pmThrowOnUnmappableCharEnabled)
#define IsPmThrowOnUnmappableCharDisabled(x)  (((x) & pmThrowOnUnmappableCharMask) == pmThrowOnUnmappableCharDisabled)
#define IsPmThrowOnUnmappableCharUseAssem(x)  (((x) & pmThrowOnUnmappableCharMask) == pmThrowOnUnmappableCharUseAssem)

// Assembly attr bits, used by DefineAssembly.
typedef enum CorAssemblyFlags
{
    afPublicKey             =   0x0001,     // The assembly ref holds the full (unhashed) public key.
    
    afPA_None               =   0x0000,     // Processor Architecture unspecified
    afPA_MSIL               =   0x0010,     // Processor Architecture: neutral (PE32)
    afPA_x86                =   0x0020,     // Processor Architecture: x86 (PE32)
    afPA_IA64               =   0x0030,     // Processor Architecture: Itanium (PE32+)
    afPA_AMD64              =   0x0040,     // Processor Architecture: AMD X64 (PE32+)
    afPA_Specified          =   0x0080,     // Propagate PA flags to AssemblyRef record
    afPA_Mask               =   0x0070,     // Bits describing the processor architecture
    afPA_FullMask           =   0x00F0,     // Bits describing the PA incl. Specified
    afPA_Shift              =   0x0004,     // NOT A FLAG, shift count in PA flags <--> index conversion

    afEnableJITcompileTracking  =   0x8000, // From "DebuggableAttribute".
    afDisableJITcompileOptimizer=   0x4000, // From "DebuggableAttribute".

    afRetargetable          =   0x0100,     // The assembly can be retargeted (at runtime) to an
                                            //  assembly from a different publisher.
} CorAssemblyFlags;

// Macros for accessing the members of CorAssemblyFlags.
#define IsAfRetargetable(x)                 ((x) & afRetargetable)

// Macros for accessing the Processor Architecture flags of CorAssemblyFlags.
#define IsAfPA_MSIL(x) (((x) & afPA_Mask) == afPA_MSIL)
#define IsAfPA_x86(x) (((x) & afPA_Mask) == afPA_x86)
#define IsAfPA_IA64(x) (((x) & afPA_Mask) == afPA_IA64)
#define IsAfPA_AMD64(x) (((x) & afPA_Mask) == afPA_AMD64)
#define IsAfPA_Specified(x) ((x) & afPA_Specified)
#define PAIndex(x) (((x) & afPA_Mask) >> afPA_Shift)
#define PAFlag(x)  (((x) << afPA_Shift) & afPA_Mask)
#define PrepareForSaving(x) ((x) & (((x) & afPA_Specified) ? ~afPA_Specified : ~afPA_FullMask))

#define IsAfEnableJITcompileTracking(x)     ((x) & afEnableJITcompileTracking)
#define IsAfDisableJITcompileOptimizer(x)   ((x) & afDisableJITcompileOptimizer)

// Macros for accessing the public key flags of CorAssemblyFlags.
#define IsAfPublicKey(x)                    ((x) & afPublicKey)
#define IsAfPublicKeyToken(x)               (((x) & afPublicKey) == 0)


// ManifestResource attr bits, used by DefineManifestResource.
typedef enum CorManifestResourceFlags
{
    mrVisibilityMask        =   0x0007,
    mrPublic                =   0x0001,     // The Resource is exported from the Assembly.
    mrPrivate               =   0x0002,     // The Resource is private to the Assembly.
} CorManifestResourceFlags;

// Macros for accessing the members of CorManifestResourceFlags.
#define IsMrPublic(x)                       (((x) & mrVisibilityMask) == mrPublic)
#define IsMrPrivate(x)                      (((x) & mrVisibilityMask) == mrPrivate)


// File attr bits, used by DefineFile.
typedef enum CorFileFlags
{
    ffContainsMetaData      =   0x0000,     // This is not a resource file
    ffContainsNoMetaData    =   0x0001,     // This is a resource file or other non-metadata-containing file
} CorFileFlags;

// Macros for accessing the members of CorFileFlags.
#define IsFfContainsMetaData(x)             (!((x) & ffContainsNoMetaData))
#define IsFfContainsNoMetaData(x)           ((x) & ffContainsNoMetaData)

// PE file kind bits, returned by IMetaDataImport2::GetPEKind()
typedef enum CorPEKind
{
    peNot       = 0x00000000,   // not a PE file
    peILonly    = 0x00000001,   // flag IL_ONLY is set in COR header
    pe32BitRequired=0x00000002,  // flag 32BIT_REQUIRED is set in COR header
    pe32Plus    = 0x00000004,   // PE32+ file (64 bit)
    pe32Unmanaged=0x00000008    // PE32 without COR header
} CorPEKind;


// GenericParam bits, used by DefineGenericParam.
typedef enum CorGenericParamAttr
{
    // Variance of type parameters, only applicable to generic parameters 
    // for generic interfaces and delegates
    gpVarianceMask          =   0x0003,
    gpNonVariant            =   0x0000, 
    gpCovariant             =   0x0001,
    gpContravariant         =   0x0002,

    // Special constraints, applicable to any type parameters
    gpSpecialConstraintMask =  0x001C,
    gpNoSpecialConstraint   =   0x0000,      
    gpReferenceTypeConstraint = 0x0004,      // type argument must be a reference type
    gpNotNullableValueTypeConstraint   =   0x0008,      // type argument must be a value type but not Nullable
    gpDefaultConstructorConstraint = 0x0010, // type argument must have a public default constructor
} CorGenericParamAttr;

// structures and enums moved from COR.H
typedef unsigned __int8 COR_SIGNATURE;

typedef COR_SIGNATURE* PCOR_SIGNATURE;      // pointer to a cor sig.  Not void* so that
                                            // the bytes can be incremented easily
typedef const COR_SIGNATURE* PCCOR_SIGNATURE;


typedef const char * MDUTF8CSTR;
typedef char * MDUTF8STR;

//*****************************************************************************
//
// Element type for Cor signature
//
//*****************************************************************************

typedef enum CorElementType
{
    ELEMENT_TYPE_END            = 0x0,
    ELEMENT_TYPE_VOID           = 0x1,
    ELEMENT_TYPE_BOOLEAN        = 0x2,
    ELEMENT_TYPE_CHAR           = 0x3,
    ELEMENT_TYPE_I1             = 0x4,
    ELEMENT_TYPE_U1             = 0x5,
    ELEMENT_TYPE_I2             = 0x6,
    ELEMENT_TYPE_U2             = 0x7,
    ELEMENT_TYPE_I4             = 0x8,
    ELEMENT_TYPE_U4             = 0x9,
    ELEMENT_TYPE_I8             = 0xa,
    ELEMENT_TYPE_U8             = 0xb,
    ELEMENT_TYPE_R4             = 0xc,
    ELEMENT_TYPE_R8             = 0xd,
    ELEMENT_TYPE_STRING         = 0xe,

    // every type above PTR will be simple type
    ELEMENT_TYPE_PTR            = 0xf,      // PTR <type>
    ELEMENT_TYPE_BYREF          = 0x10,     // BYREF <type>

    // Please use ELEMENT_TYPE_VALUETYPE. ELEMENT_TYPE_VALUECLASS is deprecated.
    ELEMENT_TYPE_VALUETYPE      = 0x11,     // VALUETYPE <class Token>
    ELEMENT_TYPE_CLASS          = 0x12,     // CLASS <class Token>
    ELEMENT_TYPE_VAR            = 0x13,     // a class type variable VAR <U1>
    ELEMENT_TYPE_ARRAY          = 0x14,     // MDARRAY <type> <rank> <bcount> <bound1> ... <lbcount> <lb1> ...
    ELEMENT_TYPE_GENERICINST    = 0x15,     // GENERICINST <generic type> <argCnt> <arg1> ... <argn>
    ELEMENT_TYPE_TYPEDBYREF     = 0x16,     // TYPEDREF  (it takes no args) a typed referece to some other type

    ELEMENT_TYPE_I              = 0x18,     // native integer size
    ELEMENT_TYPE_U              = 0x19,     // native unsigned integer size
    ELEMENT_TYPE_FNPTR          = 0x1B,     // FNPTR <complete sig for the function including calling convention>
    ELEMENT_TYPE_OBJECT         = 0x1C,     // Shortcut for System.Object
    ELEMENT_TYPE_SZARRAY        = 0x1D,     // Shortcut for single dimension zero lower bound array
                                            // SZARRAY <type>
    ELEMENT_TYPE_MVAR           = 0x1e,     // a method type variable MVAR <U1>

    // This is only for binding
    ELEMENT_TYPE_CMOD_REQD      = 0x1F,     // required C modifier : E_T_CMOD_REQD <mdTypeRef/mdTypeDef>
    ELEMENT_TYPE_CMOD_OPT       = 0x20,     // optional C modifier : E_T_CMOD_OPT <mdTypeRef/mdTypeDef>

    // This is for signatures generated internally (which will not be persisted in any way).
    ELEMENT_TYPE_INTERNAL       = 0x21,     // INTERNAL <typehandle>

    // Note that this is the max of base type excluding modifiers
    ELEMENT_TYPE_MAX            = 0x22,     // first invalid element type


    ELEMENT_TYPE_MODIFIER       = 0x40,
    ELEMENT_TYPE_SENTINEL       = 0x01 | ELEMENT_TYPE_MODIFIER, // sentinel for varargs
    ELEMENT_TYPE_PINNED         = 0x05 | ELEMENT_TYPE_MODIFIER,
    ELEMENT_TYPE_R4_HFA         = 0x06 | ELEMENT_TYPE_MODIFIER, // used only internally for R4 HFA types
    ELEMENT_TYPE_R8_HFA         = 0x07 | ELEMENT_TYPE_MODIFIER, // used only internally for R8 HFA types

} CorElementType;


//*****************************************************************************
//
// Serialization types for Custom attribute support
//
//*****************************************************************************

typedef enum CorSerializationType
{
    SERIALIZATION_TYPE_UNDEFINED    = 0,
    SERIALIZATION_TYPE_BOOLEAN      = ELEMENT_TYPE_BOOLEAN,
    SERIALIZATION_TYPE_CHAR         = ELEMENT_TYPE_CHAR,
    SERIALIZATION_TYPE_I1           = ELEMENT_TYPE_I1,
    SERIALIZATION_TYPE_U1           = ELEMENT_TYPE_U1,
    SERIALIZATION_TYPE_I2           = ELEMENT_TYPE_I2,
    SERIALIZATION_TYPE_U2           = ELEMENT_TYPE_U2,
    SERIALIZATION_TYPE_I4           = ELEMENT_TYPE_I4,
    SERIALIZATION_TYPE_U4           = ELEMENT_TYPE_U4,
    SERIALIZATION_TYPE_I8           = ELEMENT_TYPE_I8,
    SERIALIZATION_TYPE_U8           = ELEMENT_TYPE_U8,
    SERIALIZATION_TYPE_R4           = ELEMENT_TYPE_R4,
    SERIALIZATION_TYPE_R8           = ELEMENT_TYPE_R8,
    SERIALIZATION_TYPE_STRING       = ELEMENT_TYPE_STRING,
    SERIALIZATION_TYPE_SZARRAY      = ELEMENT_TYPE_SZARRAY, // Shortcut for single dimension zero lower bound array
    SERIALIZATION_TYPE_TYPE         = 0x50,
    SERIALIZATION_TYPE_TAGGED_OBJECT= 0x51,
    SERIALIZATION_TYPE_FIELD        = 0x53,
    SERIALIZATION_TYPE_PROPERTY     = 0x54,
    SERIALIZATION_TYPE_ENUM         = 0x55
} CorSerializationType;

//
// Calling convention flags.
//


typedef enum CorCallingConvention
{
    IMAGE_CEE_CS_CALLCONV_DEFAULT       = 0x0,

    IMAGE_CEE_CS_CALLCONV_VARARG        = 0x5,
    IMAGE_CEE_CS_CALLCONV_FIELD         = 0x6,
    IMAGE_CEE_CS_CALLCONV_LOCAL_SIG     = 0x7,
    IMAGE_CEE_CS_CALLCONV_PROPERTY      = 0x8,
    IMAGE_CEE_CS_CALLCONV_UNMGD         = 0x9,
    IMAGE_CEE_CS_CALLCONV_GENERICINST   = 0xa,  // generic method instantiation
    IMAGE_CEE_CS_CALLCONV_NATIVEVARARG  = 0xb,  // used ONLY for 64bit vararg PInvoke calls
    IMAGE_CEE_CS_CALLCONV_MAX           = 0xc,  // first invalid calling convention


        // The high bits of the calling convention convey additional info
    IMAGE_CEE_CS_CALLCONV_MASK      = 0x0f,  // Calling convention is bottom 4 bits
    IMAGE_CEE_CS_CALLCONV_HASTHIS   = 0x20,  // Top bit indicates a 'this' parameter
    IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS = 0x40,  // This parameter is explicitly in the signature
    IMAGE_CEE_CS_CALLCONV_GENERIC   = 0x10,  // Generic method sig with explicit number of type arguments (precedes ordinary parameter count)
} CorCallingConvention;

#define IMAGE_CEE_CS_CALLCONV_INSTANTIATION IMAGE_CEE_CS_CALLCONV_GENERICINST

typedef enum CorUnmanagedCallingConvention
{
    IMAGE_CEE_UNMANAGED_CALLCONV_C         = 0x1,
    IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL   = 0x2,
    IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL  = 0x3,
    IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL  = 0x4,

    IMAGE_CEE_CS_CALLCONV_C         = IMAGE_CEE_UNMANAGED_CALLCONV_C,
    IMAGE_CEE_CS_CALLCONV_STDCALL   = IMAGE_CEE_UNMANAGED_CALLCONV_STDCALL,
    IMAGE_CEE_CS_CALLCONV_THISCALL  = IMAGE_CEE_UNMANAGED_CALLCONV_THISCALL,
    IMAGE_CEE_CS_CALLCONV_FASTCALL  = IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL,

} CorUnmanagedCallingConvention;


typedef enum CorArgType
{
    IMAGE_CEE_CS_END        = 0x0,
    IMAGE_CEE_CS_VOID       = 0x1,
    IMAGE_CEE_CS_I4         = 0x2,
    IMAGE_CEE_CS_I8         = 0x3,
    IMAGE_CEE_CS_R4         = 0x4,
    IMAGE_CEE_CS_R8         = 0x5,
    IMAGE_CEE_CS_PTR        = 0x6,
    IMAGE_CEE_CS_OBJECT     = 0x7,
    IMAGE_CEE_CS_STRUCT4    = 0x8,
    IMAGE_CEE_CS_STRUCT32   = 0x9,
    IMAGE_CEE_CS_BYVALUE    = 0xA,
} CorArgType;


//*****************************************************************************
//
// Native type for N-Direct
//
//*****************************************************************************

typedef enum CorNativeType
{
    NATIVE_TYPE_END         = 0x0,    //DEPRECATED
    NATIVE_TYPE_VOID        = 0x1,    //DEPRECATED
    NATIVE_TYPE_BOOLEAN     = 0x2,    // (4 byte boolean value: TRUE = non-zero, FALSE = 0)
    NATIVE_TYPE_I1          = 0x3,
    NATIVE_TYPE_U1          = 0x4,
    NATIVE_TYPE_I2          = 0x5,
    NATIVE_TYPE_U2          = 0x6,
    NATIVE_TYPE_I4          = 0x7,
    NATIVE_TYPE_U4          = 0x8,
    NATIVE_TYPE_I8          = 0x9,
    NATIVE_TYPE_U8          = 0xa,
    NATIVE_TYPE_R4          = 0xb,
    NATIVE_TYPE_R8          = 0xc,
    NATIVE_TYPE_SYSCHAR     = 0xd,    //DEPRECATED
    NATIVE_TYPE_VARIANT     = 0xe,    //DEPRECATED
    NATIVE_TYPE_CURRENCY    = 0xf,
    NATIVE_TYPE_PTR         = 0x10,   //DEPRECATED

    NATIVE_TYPE_DECIMAL     = 0x11,   //DEPRECATED
    NATIVE_TYPE_DATE        = 0x12,   //DEPRECATED
    NATIVE_TYPE_BSTR        = 0x13,   //COMINTEROP
    NATIVE_TYPE_LPSTR       = 0x14,
    NATIVE_TYPE_LPWSTR      = 0x15,
    NATIVE_TYPE_LPTSTR      = 0x16,
    NATIVE_TYPE_FIXEDSYSSTRING  = 0x17,
    NATIVE_TYPE_OBJECTREF   = 0x18,   //DEPRECATED
    NATIVE_TYPE_IUNKNOWN    = 0x19,   //COMINTEROP
    NATIVE_TYPE_IDISPATCH   = 0x1a,   //COMINTEROP
    NATIVE_TYPE_STRUCT      = 0x1b,
    NATIVE_TYPE_INTF        = 0x1c,   //COMINTEROP
    NATIVE_TYPE_SAFEARRAY   = 0x1d,   //COMINTEROP
    NATIVE_TYPE_FIXEDARRAY  = 0x1e,
    NATIVE_TYPE_INT         = 0x1f,
    NATIVE_TYPE_UINT        = 0x20,

    NATIVE_TYPE_NESTEDSTRUCT  = 0x21, //DEPRECATED (use NATIVE_TYPE_STRUCT)

    NATIVE_TYPE_BYVALSTR    = 0x22,   //COMINTEROP

    NATIVE_TYPE_ANSIBSTR    = 0x23,   //COMINTEROP

    NATIVE_TYPE_TBSTR       = 0x24, // select BSTR or ANSIBSTR depending on platform
                                      //COMINTEROP

    NATIVE_TYPE_VARIANTBOOL = 0x25, // (2-byte boolean value: TRUE = -1, FALSE = 0)
                                      //COMINTEROP
    NATIVE_TYPE_FUNC        = 0x26,

    NATIVE_TYPE_ASANY       = 0x28,

    NATIVE_TYPE_ARRAY       = 0x2a,
    NATIVE_TYPE_LPSTRUCT    = 0x2b,

    NATIVE_TYPE_CUSTOMMARSHALER = 0x2c,  // Custom marshaler native type. This must be followed
                                         // by a string of the following format:
                                         // "Native type name/0Custom marshaler type name/0Optional cookie/0"
                                         // Or
                                         // "{Native type GUID}/0Custom marshaler type name/0Optional cookie/0"

    NATIVE_TYPE_ERROR       = 0x2d, // This native type coupled with ELEMENT_TYPE_I4 will map to VT_HRESULT
                                    //COMINTEROP

    NATIVE_TYPE_MAX         = 0x50, // first invalid element type
} CorNativeType;


enum
{
    DESCR_GROUP_METHODDEF = 0,          // DESCR group for MethodDefs
    DESCR_GROUP_METHODIMPL,             // DESCR group for MethodImpls
};

/***********************************************************************************/
// a COR_ILMETHOD_SECT is a generic container for attributes that are private
// to a particular method.  The COR_ILMETHOD structure points to one of these
// (see GetSect()).  COR_ILMETHOD_SECT can decode the Kind of attribute (but not
// its internal data layout, and can skip past the current attibute to find the
// Next one.   The overhead for COR_ILMETHOD_SECT is a minimum of 2 bytes.

typedef enum CorILMethodSect                             // codes that identify attributes
{
    CorILMethod_Sect_Reserved    = 0,
    CorILMethod_Sect_EHTable     = 1,
    CorILMethod_Sect_OptILTable  = 2,

    CorILMethod_Sect_KindMask    = 0x3F,        // The mask for decoding the type code
    CorILMethod_Sect_FatFormat   = 0x40,        // fat format
    CorILMethod_Sect_MoreSects   = 0x80,        // there is another attribute after this one
} CorILMethodSect;

/************************************/
/* NOTE this structure must be DWORD aligned!! */

typedef struct IMAGE_COR_ILMETHOD_SECT_SMALL
{
    BYTE Kind;
    BYTE DataSize;

} IMAGE_COR_ILMETHOD_SECT_SMALL;



/************************************/
/* NOTE this structure must be DWORD aligned!! */
typedef struct IMAGE_COR_ILMETHOD_SECT_FAT
{
    unsigned Kind : 8;
    unsigned DataSize : 24;

} IMAGE_COR_ILMETHOD_SECT_FAT;



/***********************************************************************************/
/* If COR_ILMETHOD_SECT_HEADER::Kind() = CorILMethod_Sect_EHTable then the attribute
   is a list of exception handling clauses.  There are two formats, fat or small
*/
typedef enum CorExceptionFlag                       // defintitions for the Flags field below (for both big and small)
{
    COR_ILEXCEPTION_CLAUSE_NONE,                    // This is a typed handler
    COR_ILEXCEPTION_CLAUSE_OFFSETLEN = 0x0000,      // Deprecated
    COR_ILEXCEPTION_CLAUSE_DEPRECATED = 0x0000,     // Deprecated
    COR_ILEXCEPTION_CLAUSE_FILTER  = 0x0001,        // If this bit is on, then this EH entry is for a filter
    COR_ILEXCEPTION_CLAUSE_FINALLY = 0x0002,        // This clause is a finally clause
    COR_ILEXCEPTION_CLAUSE_FAULT = 0x0004,          // Fault clause (finally that is called on exception only)
    COR_ILEXCEPTION_CLAUSE_DUPLICATED = 0x0008,     // duplicated clase..  this clause was duplicated down to a funclet which was pulled out of line
} CorExceptionFlag;

/***********************************/
// NOTE !!! NOTE
// This structure should line up with EE_ILEXCEPTION_CLAUSE,
// otherwise you'll have to adjust code in Excep.cpp, re: EHRangeTree
// NOTE !!! NOTE

typedef struct IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT
{
    CorExceptionFlag    Flags;
    DWORD               TryOffset;
    DWORD               TryLength;      // relative to start of try block
    DWORD               HandlerOffset;
    DWORD               HandlerLength;  // relative to start of handler
    union {
        DWORD           ClassToken;     // use for type-based exception handlers
        DWORD           FilterOffset;   // use for filter-based exception handlers (COR_ILEXCEPTION_FILTER is set)
    };
} IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT;

typedef struct IMAGE_COR_ILMETHOD_SECT_EH_FAT
{
    IMAGE_COR_ILMETHOD_SECT_FAT   SectFat;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT Clauses[1];     // actually variable size
} IMAGE_COR_ILMETHOD_SECT_EH_FAT;

/***********************************/
typedef struct IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL
{
#ifdef _WIN64
    unsigned            Flags         : 16;
#else // !_WIN64
    CorExceptionFlag    Flags         : 16;
#endif
    unsigned            TryOffset     : 16;
    unsigned            TryLength     : 8;  // relative to start of try block
    unsigned            HandlerOffset : 16;
    unsigned            HandlerLength : 8;  // relative to start of handler
    union {
        DWORD       ClassToken;
        DWORD       FilterOffset;
    };
} IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL;

/***********************************/
typedef struct IMAGE_COR_ILMETHOD_SECT_EH_SMALL
{
    IMAGE_COR_ILMETHOD_SECT_SMALL SectSmall;
    WORD Reserved;
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL Clauses[1];   // actually variable size
} IMAGE_COR_ILMETHOD_SECT_EH_SMALL;



typedef union IMAGE_COR_ILMETHOD_SECT_EH
{
    IMAGE_COR_ILMETHOD_SECT_EH_SMALL Small;
    IMAGE_COR_ILMETHOD_SECT_EH_FAT Fat;
} IMAGE_COR_ILMETHOD_SECT_EH;


/***********************************************************************************/
typedef enum CorILMethodFlags
{
    CorILMethod_InitLocals      = 0x0010,           // call default constructor on all local vars
    CorILMethod_MoreSects       = 0x0008,           // there is another attribute after this one

    CorILMethod_CompressedIL    = 0x0040,           // FIX Remove this and do it on a per Module basis

        // Indicates the format for the COR_ILMETHOD header
    CorILMethod_FormatShift     = 3,
    CorILMethod_FormatMask      = ((1 << CorILMethod_FormatShift) - 1),
    CorILMethod_TinyFormat      = 0x0002,         // use this code if the code size is even
    CorILMethod_SmallFormat     = 0x0000,
    CorILMethod_FatFormat       = 0x0003,
    CorILMethod_TinyFormat1     = 0x0006,         // use this code if the code size is odd
} CorILMethodFlags;

/***************************************************************************/
/* Used when the method is tiny (< 64 bytes), and there are no local vars */
typedef struct IMAGE_COR_ILMETHOD_TINY
{
    BYTE Flags_CodeSize;
} IMAGE_COR_ILMETHOD_TINY;

/************************************/
// This strucuture is the 'fat' layout, where no compression is attempted.
// Note that this structure can be added on at the end, thus making it extensible
typedef struct IMAGE_COR_ILMETHOD_FAT
{
    unsigned Flags    : 12;     // Flags
    unsigned Size     :  4;     // size in DWords of this structure (currently 3)
    unsigned MaxStack : 16;     // maximum number of items (I4, I, I8, obj ...), on the operand stack
    DWORD   CodeSize;           // size of the code
    mdSignature   LocalVarSigTok;     // token that indicates the signature of the local vars (0 means none)

} IMAGE_COR_ILMETHOD_FAT;

typedef union IMAGE_COR_ILMETHOD
{
    IMAGE_COR_ILMETHOD_TINY       Tiny;
    IMAGE_COR_ILMETHOD_FAT        Fat;
} IMAGE_COR_ILMETHOD;

//
// Native method descriptor.
//

typedef struct IMAGE_COR_NATIVE_DESCRIPTOR
{
    DWORD       GCInfo;
    DWORD       EHInfo;
} IMAGE_COR_NATIVE_DESCRIPTOR;


typedef struct IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY
{
    ULONG       BeginAddress;           // RVA of start of function
    ULONG       EndAddress;             // RVA of end of function
    ULONG       MIH;                    // Associated MIH
} IMAGE_COR_X86_RUNTIME_FUNCTION_ENTRY;

typedef struct IMAGE_COR_MIH_ENTRY
{
    ULONG   EHRVA;
    ULONG   MethodRVA;
    mdToken Token;
    BYTE    Flags;
    BYTE    CodeManager;
    BYTE    MIHData[0];
} IMAGE_COR_MIH_ENTRY;

//*****************************************************************************
// Non VOS v-table entries.  Define an array of these pointed to by
// IMAGE_COR20_HEADER.VTableFixups.  Each entry describes a contiguous array of
// v-table slots.  The slots start out initialized to the meta data token value
// for the method they need to call.  At image load time, the CLR Loader will
// turn each entry into a pointer to machine code for the CPU and can be
// called directly.
//*****************************************************************************

typedef struct IMAGE_COR_VTABLEFIXUP
{
    ULONG       RVA;                    // Offset of v-table array in image.
    USHORT      Count;                  // How many entries at location.
    USHORT      Type;                   // COR_VTABLE_xxx type of entries.
} IMAGE_COR_VTABLEFIXUP;





//*****************************************************************************
//*****************************************************************************
//
// M E T A - D A T A    D E C L A R A T I O N S
//
//*****************************************************************************
//*****************************************************************************

//*****************************************************************************
//
// Enums for SetOption API.
//
//*****************************************************************************

// flags for MetaDataCheckDuplicatesFor
typedef enum CorCheckDuplicatesFor
{
    MDDupAll                    = 0xffffffff,
    MDDupENC                    = MDDupAll,
    MDNoDupChecks               = 0x00000000,
    MDDupTypeDef                = 0x00000001,
    MDDupInterfaceImpl          = 0x00000002,
    MDDupMethodDef              = 0x00000004,
    MDDupTypeRef                = 0x00000008,
    MDDupMemberRef              = 0x00000010,
    MDDupCustomAttribute        = 0x00000020,
    MDDupParamDef               = 0x00000040,
    MDDupPermission             = 0x00000080,
    MDDupProperty               = 0x00000100,
    MDDupEvent                  = 0x00000200,
    MDDupFieldDef               = 0x00000400,
    MDDupSignature              = 0x00000800,
    MDDupModuleRef              = 0x00001000,
    MDDupTypeSpec               = 0x00002000,
    MDDupImplMap                = 0x00004000,
    MDDupAssemblyRef            = 0x00008000,
    MDDupFile                   = 0x00010000,
    MDDupExportedType           = 0x00020000,
    MDDupManifestResource       = 0x00040000,
    MDDupGenericParam           = 0x00080000,
    MDDupMethodSpec             = 0x00100000,
    MDDupGenericParamConstraint = 0x00200000,
    // gap for debug junk
    MDDupAssembly               = 0x10000000,

    // This is the default behavior on metadata. It will check duplicates for TypeRef, MemberRef, Signature, TypeSpec and MethodSpec.
    MDDupDefault = MDNoDupChecks | MDDupTypeRef | MDDupMemberRef | MDDupSignature | MDDupTypeSpec | MDDupMethodSpec,
} CorCheckDuplicatesFor;

// flags for MetaDataRefToDefCheck
typedef enum CorRefToDefCheck
{
    // default behavior is to always perform TypeRef to TypeDef and MemberRef to MethodDef/FieldDef optimization
    MDRefToDefDefault           = 0x00000003,
    MDRefToDefAll               = 0xffffffff,
    MDRefToDefNone              = 0x00000000,
    MDTypeRefToDef              = 0x00000001,
    MDMemberRefToDef            = 0x00000002
} CorRefToDefCheck;


// MetaDataNotificationForTokenMovement
typedef enum CorNotificationForTokenMovement
{
    // default behavior is to notify TypeRef, MethodDef, MemberRef, and FieldDef token remaps
    MDNotifyDefault             = 0x0000000f,
    MDNotifyAll                 = 0xffffffff,
    MDNotifyNone                = 0x00000000,
    MDNotifyMethodDef           = 0x00000001,
    MDNotifyMemberRef           = 0x00000002,
    MDNotifyFieldDef            = 0x00000004,
    MDNotifyTypeRef             = 0x00000008,

    MDNotifyTypeDef             = 0x00000010,
    MDNotifyParamDef            = 0x00000020,
    MDNotifyInterfaceImpl       = 0x00000040,
    MDNotifyProperty            = 0x00000080,
    MDNotifyEvent               = 0x00000100,
    MDNotifySignature           = 0x00000200,
    MDNotifyTypeSpec            = 0x00000400,
    MDNotifyCustomAttribute     = 0x00000800,
    MDNotifySecurityValue       = 0x00001000,
    MDNotifyPermission          = 0x00002000,
    MDNotifyModuleRef           = 0x00004000,

    MDNotifyNameSpace           = 0x00008000,

    MDNotifyAssemblyRef         = 0x01000000,
    MDNotifyFile                = 0x02000000,
    MDNotifyExportedType        = 0x04000000,
    MDNotifyResource            = 0x08000000,
} CorNotificationForTokenMovement;


typedef enum CorSetENC
{
    MDSetENCOn                  = 0x00000001,   // Deprecated name.
    MDSetENCOff                 = 0x00000002,   // Deprecated name.

    MDUpdateENC                 = 0x00000001,   // ENC mode.  Tokens don't move; can be updated.
    MDUpdateFull                = 0x00000002,   // "Normal" update mode.
    MDUpdateExtension           = 0x00000003,   // Extension mode.  Tokens don't move, adds only.
    MDUpdateIncremental         = 0x00000004,   // Incremental compilation
    MDUpdateDelta               = 0x00000005,   // If ENC on, save only deltas.
    MDUpdateMask                = 0x00000007,


} CorSetENC;

#define IsENCDelta(x)                       (((x) & MDUpdateMask) == MDUpdateDelta)

// flags used in SetOption when pair with MetaDataErrorIfEmitOutOfOrder guid
typedef enum CorErrorIfEmitOutOfOrder
{
    MDErrorOutOfOrderDefault    = 0x00000000,   // default not to generate any error
    MDErrorOutOfOrderNone       = 0x00000000,   // do not generate error for out of order emit
    MDErrorOutOfOrderAll        = 0xffffffff,   // generate out of order emit for method, field, param, property, and event
    MDMethodOutOfOrder          = 0x00000001,   // generate error when methods are emitted out of order
    MDFieldOutOfOrder           = 0x00000002,   // generate error when fields are emitted out of order
    MDParamOutOfOrder           = 0x00000004,   // generate error when params are emitted out of order
    MDPropertyOutOfOrder        = 0x00000008,   // generate error when properties are emitted out of order
    MDEventOutOfOrder           = 0x00000010,   // generate error when events are emitted out of order
} CorErrorIfEmitOutOfOrder;


// flags used in SetOption when pair with MetaDataImportOption guid
typedef enum CorImportOptions
{
    MDImportOptionDefault       = 0x00000000,   // default to skip over deleted records
    MDImportOptionAll           = 0xFFFFFFFF,   // Enumerate everything
    MDImportOptionAllTypeDefs   = 0x00000001,   // all of the typedefs including the deleted typedef
    MDImportOptionAllMethodDefs = 0x00000002,   // all of the methoddefs including the deleted ones
    MDImportOptionAllFieldDefs  = 0x00000004,   // all of the fielddefs including the deleted ones
    MDImportOptionAllProperties = 0x00000008,   // all of the properties including the deleted ones
    MDImportOptionAllEvents     = 0x00000010,   // all of the events including the deleted ones
    MDImportOptionAllCustomAttributes = 0x00000020, // all of the custom attributes including the deleted ones
    MDImportOptionAllExportedTypes  = 0x00000040,   // all of the ExportedTypes including the deleted ones

} CorImportOptions;


// flags for MetaDataThreadSafetyOptions
typedef enum CorThreadSafetyOptions
{
    // default behavior is to have thread safety turn off. This means that MetaData APIs will not take reader/writer
    // lock. Clients is responsible to make sure the properly thread synchornization when using MetaData APIs.
    MDThreadSafetyDefault       = 0x00000000,
    MDThreadSafetyOff           = 0x00000000,
    MDThreadSafetyOn            = 0x00000001,
} CorThreadSafetyOptions;


// flags for MetaDataLinkerOptions
typedef enum CorLinkerOptions
{
    // default behavior is not to keep private types
    MDAssembly          = 0x00000000,
    MDNetModule         = 0x00000001,
} CorLinkerOptions;

// flags for MetaDataMergeOptions
typedef enum MergeFlags
{
    MergeFlagsNone      =   0,
    MergeManifest       =   0x00000001,     
    DropMemberRefCAs    =   0x00000002,
    NoDupCheck          =   0x00000004,
    MergeExportedTypes  =   0x00000008
} MergeFlags;


//
// struct used to retrieve field offset
// used by GetClassLayout and SetClassLayout
//

#ifndef _COR_FIELD_OFFSET_
#define _COR_FIELD_OFFSET_

typedef struct COR_FIELD_OFFSET
{
    mdFieldDef  ridOfField;
    ULONG       ulOffset;
} COR_FIELD_OFFSET;

#endif

typedef struct IMAGE_COR_FIXUPENTRY
{
    ULONG ulRVA;
    ULONG Count;
} IMAGE_COR_FIXUPENTRY;


//
// Token tags.
//
typedef enum CorTokenType
{
    mdtModule               = 0x00000000,       //
    mdtTypeRef              = 0x01000000,       //
    mdtTypeDef              = 0x02000000,       //
    mdtFieldDef             = 0x04000000,       //
    mdtMethodDef            = 0x06000000,       //
    mdtParamDef             = 0x08000000,       //
    mdtInterfaceImpl        = 0x09000000,       //
    mdtMemberRef            = 0x0a000000,       //
    mdtCustomAttribute      = 0x0c000000,       //
    mdtPermission           = 0x0e000000,       //
    mdtSignature            = 0x11000000,       //
    mdtEvent                = 0x14000000,       //
    mdtProperty             = 0x17000000,       //
    mdtModuleRef            = 0x1a000000,       //
    mdtTypeSpec             = 0x1b000000,       //
    mdtAssembly             = 0x20000000,       //
    mdtAssemblyRef          = 0x23000000,       //
    mdtFile                 = 0x26000000,       //
    mdtExportedType         = 0x27000000,       //
    mdtManifestResource     = 0x28000000,       //
    mdtGenericParam         = 0x2a000000,       //
    mdtMethodSpec           = 0x2b000000,       //
    mdtGenericParamConstraint = 0x2c000000,

    mdtString               = 0x70000000,       //
    mdtName                 = 0x71000000,       //
    mdtBaseType             = 0x72000000,       // Leave this on the high end value. This does not correspond to metadata table
} CorTokenType;

//
// Build / decompose tokens.
//
#define RidToToken(rid,tktype) ((rid) |= (tktype))
#define TokenFromRid(rid,tktype) ((rid) | (tktype))
#define RidFromToken(tk) ((RID) ((tk) & 0x00ffffff))
#define TypeFromToken(tk) ((ULONG32)((tk) & 0xff000000))
#define IsNilToken(tk) ((RidFromToken(tk)) == 0)

//
// Nil tokens
//
#define mdTokenNil                  ((mdToken)0)
#define mdModuleNil                 ((mdModule)mdtModule)
#define mdTypeRefNil                ((mdTypeRef)mdtTypeRef)
#define mdTypeDefNil                ((mdTypeDef)mdtTypeDef)
#define mdFieldDefNil               ((mdFieldDef)mdtFieldDef)
#define mdMethodDefNil              ((mdMethodDef)mdtMethodDef)
#define mdParamDefNil               ((mdParamDef)mdtParamDef)
#define mdInterfaceImplNil          ((mdInterfaceImpl)mdtInterfaceImpl)
#define mdMemberRefNil              ((mdMemberRef)mdtMemberRef)
#define mdCustomAttributeNil        ((mdCustomAttribute)mdtCustomAttribute)
#define mdPermissionNil             ((mdPermission)mdtPermission)
#define mdSignatureNil              ((mdSignature)mdtSignature)
#define mdEventNil                  ((mdEvent)mdtEvent)
#define mdPropertyNil               ((mdProperty)mdtProperty)
#define mdModuleRefNil              ((mdModuleRef)mdtModuleRef)
#define mdTypeSpecNil               ((mdTypeSpec)mdtTypeSpec)
#define mdAssemblyNil               ((mdAssembly)mdtAssembly)
#define mdAssemblyRefNil            ((mdAssemblyRef)mdtAssemblyRef)
#define mdFileNil                   ((mdFile)mdtFile)
#define mdExportedTypeNil           ((mdExportedType)mdtExportedType)
#define mdManifestResourceNil       ((mdManifestResource)mdtManifestResource)

#define mdGenericParamNil           ((mdGenericParam)mdtGenericParam)
#define mdGenericParamConstraintNil ((mdGenericParamConstraint)mdtGenericParamConstraint)
#define mdMethodSpecNil             ((mdMethodSpec)mdtMethodSpec)

#define mdStringNil                 ((mdString)mdtString)

//
// Open bits.
//
typedef enum CorOpenFlags
{
    ofRead              =   0x00000000,     // Open scope for read
    ofWrite             =   0x00000001,     // Open scope for write.
    ofReadWriteMask     =   0x00000001,     // Mask for read/write bit.

    ofCopyMemory        =   0x00000002,     // Open scope with memory. Ask metadata to maintain its own copy of memory.

    ofManifestMetadata  =   0x00000008,     // Open scope on ngen image, return the manifest metadata instead of the IL metadata
    ofReadOnly          =   0x00000010,     // Open scope for read. Will be unable to QI for a IMetadataEmit* interface
    ofTakeOwnership     =   0x00000020,     // The memory was allocated with CoTaskMemAlloc and will be freed by the metadata

    // These are obsolete and are ignored.
    ofCacheImage        =   0x00000004,     // EE maps but does not do relocations or verify image
    ofNoTypeLib         =   0x00000080,     // Don't OpenScope on a typelib.

    // Internal bits
    ofReserved1         =   0x00000100,     // Reserved for internal use.
    ofReserved2         =   0x00000200,     // Reserved for internal use.
    ofReserved          =   0xffffff40      // All the reserved bits.

} CorOpenFlags;

#define IsOfRead(x)                         (((x) & ofReadWriteMask) == ofRead)
#define IsOfReadWrite(x)                    (((x) & ofReadWriteMask) == ofWrite)

#define IsOfCopyMemory(x)                   ((x) & ofCopyMemory)
#define IsOfManifestMetadata(x)             ((x) & ofManifestMetadata)

#define IsOfReadOnly(x)                     ((x) & ofReadOnly)
#define IsOfTakeOwnership(x)                ((x) & ofTakeOwnership)

#define IsOfReserved(x)                     (((x) & ofReserved) != 0)

typedef CorTypeAttr CorRegTypeAttr;

//
// Opaque type for an enumeration handle.
//
typedef void *HCORENUM;


// Note that this must be kept in sync with System.AttributeTargets.
typedef enum CorAttributeTargets
{
    catAssembly      = 0x0001,
    catModule        = 0x0002,
    catClass         = 0x0004,
    catStruct        = 0x0008,
    catEnum          = 0x0010,
    catConstructor   = 0x0020,
    catMethod        = 0x0040,
    catProperty      = 0x0080,
    catField         = 0x0100,
    catEvent         = 0x0200,
    catInterface     = 0x0400,
    catParameter     = 0x0800,
    catDelegate      = 0x1000,
    catGenericParameter = 0x4000,

    catAll           = catAssembly | catModule | catClass | catStruct | catEnum | catConstructor |
                    catMethod | catProperty | catField | catEvent | catInterface | catParameter | catDelegate | catGenericParameter,
    catClassMembers  = catClass | catStruct | catEnum | catConstructor | catMethod | catProperty | catField | catEvent | catDelegate | catInterface,

} CorAttributeTargets;

#ifndef MACROS_NOT_SUPPORTED
//
// Some well-known custom attributes
//
#ifndef IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS
  #define IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS (IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS)
#endif

#define INTEROP_DISPID_TYPE_W                   L"System.Runtime.InteropServices.DispIdAttribute"
#define INTEROP_DISPID_TYPE                     "System.Runtime.InteropServices.DispIdAttribute"
#define INTEROP_DISPID_SIG                      {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_INTERFACETYPE_TYPE_W            L"System.Runtime.InteropServices.InterfaceTypeAttribute"
#define INTEROP_INTERFACETYPE_TYPE              "System.Runtime.InteropServices.InterfaceTypeAttribute"
#define INTEROP_INTERFACETYPE_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_CLASSINTERFACE_TYPE_W           L"System.Runtime.InteropServices.ClassInterfaceAttribute"
#define INTEROP_CLASSINTERFACE_TYPE             "System.Runtime.InteropServices.ClassInterfaceAttribute"
#define INTEROP_CLASSINTERFACE_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMVISIBLE_TYPE_W               L"System.Runtime.InteropServices.ComVisibleAttribute"
#define INTEROP_COMVISIBLE_TYPE                 "System.Runtime.InteropServices.ComVisibleAttribute"
#define INTEROP_COMVISIBLE_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_COMREGISTERFUNCTION_TYPE_W      L"System.Runtime.InteropServices.ComRegisterFunctionAttribute"
#define INTEROP_COMREGISTERFUNCTION_TYPE        "System.Runtime.InteropServices.ComRegisterFunctionAttribute"
#define INTEROP_COMREGISTERFUNCTION_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMUNREGISTERFUNCTION_TYPE_W    L"System.Runtime.InteropServices.ComUnregisterFunctionAttribute"
#define INTEROP_COMUNREGISTERFUNCTION_TYPE      "System.Runtime.InteropServices.ComUnregisterFunctionAttribute"
#define INTEROP_COMUNREGISTERFUNCTION_SIG       {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_IMPORTEDFROMTYPELIB_TYPE_W      L"System.Runtime.InteropServices.ImportedFromTypeLibAttribute"
#define INTEROP_IMPORTEDFROMTYPELIB_TYPE        "System.Runtime.InteropServices.ImportedFromTypeLibAttribute"
#define INTEROP_IMPORTEDFROMTYPELIB_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_IDISPATCHIMPL_TYPE_W            L"System.Runtime.InteropServices.IDispatchImplAttribute"
#define INTEROP_IDISPATCHIMPL_TYPE              "System.Runtime.InteropServices.IDispatchImplAttribute"
#define INTEROP_IDISPATCHIMPL_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMSOURCEINTERFACES_TYPE_W      L"System.Runtime.InteropServices.ComSourceInterfacesAttribute"
#define INTEROP_COMSOURCEINTERFACES_TYPE        "System.Runtime.InteropServices.ComSourceInterfacesAttribute"
#define INTEROP_COMSOURCEINTERFACES_SIG         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_COMDEFAULTINTERFACE_TYPE_W      L"System.Runtime.InteropServices.ComDefaultInterfaceAttribute"
#define INTEROP_COMDEFAULTINTERFACE_TYPE        "System.Runtime.InteropServices.ComDefaultInterfaceAttribute"

#define INTEROP_COMCONVERSIONLOSS_TYPE_W        L"System.Runtime.InteropServices.ComConversionLossAttribute"
#define INTEROP_COMCONVERSIONLOSS_TYPE          "System.Runtime.InteropServices.ComConversionLossAttribute"
#define INTEROP_COMCONVERSIONLOSS_SIG           {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_BESTFITMAPPING_TYPE_W           L"System.Runtime.InteropServices.BestFitMappingAttribute"
#define INTEROP_BESTFITMAPPING_TYPE             "System.Runtime.InteropServices.BestFitMappingAttribute"
#define INTEROP_BESTFITMAPPING_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 2, ELEMENT_TYPE_VOID, ELEMENT_TYPE_BOOLEAN, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_TYPELIBTYPE_TYPE_W              L"System.Runtime.InteropServices.TypeLibTypeAttribute"
#define INTEROP_TYPELIBTYPE_TYPE                "System.Runtime.InteropServices.TypeLibTypeAttribute"
#define INTEROP_TYPELIBTYPE_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_TYPELIBFUNC_TYPE_W              L"System.Runtime.InteropServices.TypeLibFuncAttribute"
#define INTEROP_TYPELIBFUNC_TYPE                "System.Runtime.InteropServices.TypeLibFuncAttribute"
#define INTEROP_TYPELIBFUNC_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_TYPELIBVAR_TYPE_W               L"System.Runtime.InteropServices.TypeLibVarAttribute"
#define INTEROP_TYPELIBVAR_TYPE                 "System.Runtime.InteropServices.TypeLibVarAttribute"
#define INTEROP_TYPELIBVAR_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_MARSHALAS_TYPE_W                L"System.Runtime.InteropServices.MarshalAsAttribute"
#define INTEROP_MARSHALAS_TYPE                  "System.Runtime.InteropServices.MarshalAsAttribute"
#define INTEROP_MARSHALAS_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2}

#define INTEROP_COMIMPORT_TYPE_W                L"System.Runtime.InteropServices.ComImportAttribute"
#define INTEROP_COMIMPORT_TYPE                  "System.Runtime.InteropServices.ComImportAttribute"
#define INTEROP_COMIMPORT_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_GUID_TYPE_W                     L"System.Runtime.InteropServices.GuidAttribute"
#define INTEROP_GUID_TYPE                       "System.Runtime.InteropServices.GuidAttribute"
#define INTEROP_GUID_SIG                        {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_DEFAULTMEMBER_TYPE_W            L"System.Reflection.DefaultMemberAttribute"
#define INTEROP_DEFAULTMEMBER_TYPE              "System.Reflection.DefaultMemberAttribute"
#define INTEROP_DEFAULTMEMBER_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_COMEMULATE_TYPE_W               L"System.Runtime.InteropServices.ComEmulateAttribute"
#define INTEROP_COMEMULATE_TYPE                 "System.Runtime.InteropServices.ComEmulateAttribute"
#define INTEROP_COMEMULATE_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_PRESERVESIG_TYPE_W              L"System.Runtime.InteropServices.PreserveSigAttribure"
#define INTEROP_PRESERVESIG_TYPE                "System.Runtime.InteropServices.PreserveSigAttribure"
#define INTEROP_PRESERVESIG_SIG                 {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_IN_TYPE_W                       L"System.Runtime.InteropServices.InAttribute"
#define INTEROP_IN_TYPE                         "System.Runtime.InteropServices.InAttribute"
#define INTEROP_IN_SIG                          {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_OUT_TYPE_W                      L"System.Runtime.InteropServices.OutAttribute"
#define INTEROP_OUT_TYPE                        "System.Runtime.InteropServices.OutAttribute"
#define INTEROP_OUT_SIG                         {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_COMALIASNAME_TYPE_W             L"System.Runtime.InteropServices.ComAliasNameAttribute"
#define INTEROP_COMALIASNAME_TYPE               "System.Runtime.InteropServices.ComAliasNameAttribute"
#define INTEROP_COMALIASNAME_SIG                {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define INTEROP_PARAMARRAY_TYPE_W               L"System.ParamArrayAttribute"
#define INTEROP_PARAMARRAY_TYPE                 "System.ParamArrayAttribute"
#define INTEROP_PARAMARRAY_SIG                  {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_LCIDCONVERSION_TYPE_W           L"System.Runtime.InteropServices.LCIDConversionAttribute"
#define INTEROP_LCIDCONVERSION_TYPE             "System.Runtime.InteropServices.LCIDConversionAttribute"
#define INTEROP_LCIDCONVERSION_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I4}

#define INTEROP_COMSUBSTITUTABLEINTERFACE_TYPE_W    L"System.Runtime.InteropServices.ComSubstitutableInterfaceAttribute"
#define INTEROP_COMSUBSTITUTABLEINTERFACE_TYPE      "System.Runtime.InteropServices.ComSubstitutableInterfaceAttribute"
#define INTEROP_COMSUBSTITUTABLEINTERFACE_SIG       {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_DECIMALVALUE_TYPE_W             L"System.Runtime.CompilerServices.DecimalConstantAttribute"
#define INTEROP_DECIMALVALUE_TYPE               "System.Runtime.CompilerServices.DecimalConstantAttribute"
#define INTEROP_DECIMALVALUE_SIG                {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 5, ELEMENT_TYPE_VOID, ELEMENT_TYPE_U1, ELEMENT_TYPE_U1, ELEMENT_TYPE_U4, ELEMENT_TYPE_U4, ELEMENT_TYPE_U4}

#define INTEROP_DATETIMEVALUE_TYPE_W            L"System.Runtime.CompilerServices.DateTimeConstantAttribute"
#define INTEROP_DATETIMEVALUE_TYPE              "System.Runtime.CompilerServices.DateTimeConstantAttribute"
#define INTEROP_DATETIMEVALUE_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I8}

#define INTEROP_IUNKNOWNVALUE_TYPE_W            L"System.Runtime.CompilerServices.IUnknownConstantAttribute"
#define INTEROP_IUNKNOWNVALUE_TYPE               "System.Runtime.CompilerServices.IUnknownConstantAttribute"
#define INTEROP_IUNKNOWNVALUE_SIG               {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_IDISPATCHVALUE_TYPE_W           L"System.Runtime.CompilerServices.IDispatchConstantAttribute"
#define INTEROP_IDISPATCHVALUE_TYPE              "System.Runtime.CompilerServices.IDispatchConstantAttribute"
#define INTEROP_IDISPATCHVALUE_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_AUTOPROXY_TYPE_W                L"System.Runtime.InteropServices.AutomationProxyAttribute"
#define INTEROP_AUTOPROXY_TYPE                  "System.Runtime.InteropServices.AutomationProxyAttribute"
#define INTEROP_AUTOPROXY_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_BOOLEAN}

#define INTEROP_TYPELIBIMPORTCLASS_TYPE_W       L"System.Runtime.InteropServices.TypeLibImportClassAttribute"
#define INTEROP_TYPELIBIMPORTCLASS_TYPE         "System.Runtime.InteropServices.TypeLibImportClassAttribute"


#define INTEROP_TYPELIBVERSION_TYPE_W           L"System.Runtime.InteropServices.TypeLibVersionAttribute"
#define INTEROP_TYPELIBVERSION_TYPE             "System.Runtime.InteropServices.TypeLibVersionAttribute"
#define INTEROP_TYPELIBVERSION_SIG              {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 2, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2, ELEMENT_TYPE_I2}

#define INTEROP_COMCOMPATIBLEVERSION_TYPE_W     L"System.Runtime.InteropServices.ComCompatibleVersionAttribute"
#define INTEROP_COMCOMPATIBLEVERSION_TYPE       "System.Runtime.InteropServices.ComCompatibleVersionAttribute"
#define INTEROP_COMCOMPATIBLEVERSION_SIG        {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 4, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I2, ELEMENT_TYPE_I2, ELEMENT_TYPE_I2, ELEMENT_TYPE_I2}

#define INTEROP_COMEVENTINTERFACE_TYPE_W        L"System.Runtime.InteropServices.ComEventInterfaceAttribute"
#define INTEROP_COMEVENTINTERFACE_TYPE          "System.Runtime.InteropServices.ComEventInterfaceAttribute"

#define INTEROP_COCLASS_TYPE_W                  L"System.Runtime.InteropServices.CoClassAttribute"
#define INTEROP_COCLASS_TYPE                    "System.Runtime.InteropServices.CoClassAttribute"

#define INTEROP_SERIALIZABLE_TYPE_W             L"System.SerializableAttribute"
#define INTEROP_SERIALIZABLE_TYPE               "System.SerializableAttribute"
#define INTEROP_SERIALIZABLE_SIG                {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define INTEROP_SETWIN32CONTEXTINIDISPATCHATTRIBUTE_TYPE_W  L"System.Runtime.InteropServices.SetWin32ContextInIDispatchAttribute"
#define INTEROP_SETWIN32CONTEXTINIDISPATCHATTRIBUTE_TYPE     "System.Runtime.InteropServices.SetWin32ContextInIDispatchAttribute"
#define INTEROP_SETWIN32CONTEXTINIDISPATCHATTRIBUTE_SIG     {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define FRIEND_ASSEMBLY_TYPE_W                  L"System.Runtime.CompilerServices.InternalsVisibleToAttribute"
#define FRIEND_ASSEMBLY_TYPE                     "System.Runtime.CompilerServices.InternalsVisibleToAttribute"
#define FRIEND_ASSEMBLY_SIG                     {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_STRING}

#define DEFAULTDOMAIN_STA_TYPE_W                L"System.STAThreadAttribute"
#define DEFAULTDOMAIN_STA_TYPE                   "System.STAThreadAttribute"
#define DEFAULTDOMAIN_STA_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_MTA_TYPE_W                L"System.MTAThreadAttribute"
#define DEFAULTDOMAIN_MTA_TYPE                   "System.MTAThreadAttribute"
#define DEFAULTDOMAIN_MTA_SIG                   {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID}

#define DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE_W L"System.LoaderOptimizationAttribute"
#define DEFAULTDOMAIN_LOADEROPTIMIZATION_TYPE    "System.LoaderOptimizationAttribute"
#define DEFAULTDOMAIN_LOADEROPTIMIZATION_SIG    {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 1, ELEMENT_TYPE_VOID, ELEMENT_TYPE_I1}


// Keep in sync with CompilationRelaxations.cs
typedef enum CompilationRelaxationsEnum
{
    CompilationRelaxations_NoStringInterning       = 0x0008,
        
} CompilationRelaxationEnum;

#define COMPILATIONRELAXATIONS_TYPE_W           L"System.Runtime.CompilerServices.CompilationRelaxationsAttribute"
#define COMPILATIONRELAXATIONS_TYPE             "System.Runtime.CompilerServices.CompilationRelaxationsAttribute"


// Keep in sync with RuntimeCompatibilityAttribute.cs
#define RUNTIMECOMPATIBILITY_TYPE_W             L"System.Runtime.CompilerServices.RuntimeCompatibilityAttribute"
#define RUNTIMECOMPATIBILITY_TYPE               "System.Runtime.CompilerServices.RuntimeCompatibilityAttribute"


// Keep in sync with AssemblySettingAttributes.cs

typedef enum NGenHintEnum
{    
    NGenDefault             = 0x0000, // No preference specified

    NGenEager               = 0x0001, // NGen at install time
    NGenLazy                = 0x0002, // NGen after install time
    NGenNever               = 0x0003  // Assembly should not be ngened      
};

typedef enum LoadHintEnum
{
    LoadDefault             = 0x0000, // No preference specified

    LoadAlways              = 0x0001, // Dependency is always loaded
    LoadSometimes           = 0x0002, // Dependency is sometimes loaded
    LoadNever               = 0x0003  // Dependency is never loaded
};

#define NGEN_TYPE_W                             L"System.Runtime.CompilerServices.NGenAttribute"
#define NGEN_TYPE                               "System.Runtime.CompilerServices.NGenAttribute"

#define DEFAULTDEPENDENCY_TYPE_W                L"System.Runtime.CompilerServices.DefaultDependencyAttribute"
#define DEFAULTDEPENDENCY_TYPE                  "System.Runtime.CompilerServices.DefaultDependencyAttribute"

#define DEPENDENCY_TYPE_W                       L"System.Runtime.CompilerServices.DependencyAttribute"
#define DEPENDENCY_TYPE                         "System.Runtime.CompilerServices.DependencyAttribute"


#define CMOD_CALLCONV_NAMESPACE_OLD             "System.Runtime.InteropServices"
#define CMOD_CALLCONV_NAMESPACE                 "System.Runtime.CompilerServices"
#define CMOD_CALLCONV_NAME_CDECL                "CallConvCdecl"
#define CMOD_CALLCONV_NAME_STDCALL              "CallConvStdcall"
#define CMOD_CALLCONV_NAME_THISCALL             "CallConvThiscall"
#define CMOD_CALLCONV_NAME_FASTCALL             "CallConvFastcall"

#endif // MACROS_NOT_SUPPORTED

//
// GetSaveSize accuracy
//
#ifndef _CORSAVESIZE_DEFINED_
#define _CORSAVESIZE_DEFINED_
typedef enum CorSaveSize
{
    cssAccurate             = 0x0000,               // Find exact save size, accurate but slower.
    cssQuick                = 0x0001,               // Estimate save size, may pad estimate, but faster.
    cssDiscardTransientCAs  = 0x0002,               // remove all of the CAs of discardable types
} CorSaveSize;
#endif

#define COR_IS_METHOD_MANAGED_IL(flags)         ((flags & 0xf) == (miIL | miManaged))
#define COR_IS_METHOD_MANAGED_OPTIL(flags)      ((flags & 0xf) == (miOPTIL | miManaged))
#define COR_IS_METHOD_MANAGED_NATIVE(flags)     ((flags & 0xf) == (miNative | miManaged))
#define COR_IS_METHOD_UNMANAGED_NATIVE(flags)   ((flags & 0xf) == (miNative | miUnmanaged))

//
// Enum used with NATIVE_TYPE_ARRAY.
//
typedef enum NativeTypeArrayFlags
{
    ntaSizeParamIndexSpecified = 0x0001,
    ntaReserved                = 0xfffe      // All the reserved bits.
};

//
// Opaque types for security properties and values.
//
typedef void  *  PSECURITY_PROPS ;
typedef void  *  PSECURITY_VALUE ;
typedef void ** PPSECURITY_PROPS ;
typedef void ** PPSECURITY_VALUE ;

//-------------------------------------
//--- Security data structures
//-------------------------------------

// Descriptor for a single security custom attribute.
typedef struct COR_SECATTR {
    mdMemberRef     tkCtor;         // Ref to constructor of security attribute.
    const void      *pCustomAttribute;  // Blob describing ctor args and field/property values.
    ULONG           cbCustomAttribute;  // Length of the above blob.
} COR_SECATTR;

#endif // __CORHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\corhlpr.cpp ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
/****************************************************************************
 **                                                                        **
 ** Corhlpr.h - signature helpers.                                         **
 **                                                                        **
 ****************************************************************************/
#ifndef SOS_INCLUDE

#ifdef _BLD_CLR
#include "utilcode.h"
#endif
#include "corhlpr.h"
#include <stdlib.h>

/*************************************************************************************
*
* implementation of CQuickMemoryBase
*
*************************************************************************************/

template <DWORD SIZE, DWORD INCREMENT>
HRESULT CQuickMemoryBase <SIZE, INCREMENT>::ReSizeNoThrow(SIZE_T iItems)
{
#ifdef _BLD_CLR
#ifdef _DEBUG
    // Exercise heap for OOM-fault injection purposes
    // But we can't do this if current thread suspends EE
    if (!IsSuspendEEThread ())
    {
        BYTE *pTmp = NEW_NOTHROW(iItems);
        if (!pTmp)
        {
            return E_OUTOFMEMORY;
        }
        delete [] pTmp;
    }
#endif
#endif
    BYTE *pbBuffNew;
    if (iItems <= cbTotal)
    {
        iSize = iItems;
        return NOERROR;
    }
    
#ifdef _BLD_CLR
    // not allowed to do allocation if current thread suspends EE
    if (IsSuspendEEThread ())
        return E_OUTOFMEMORY;
#endif
    pbBuffNew = NEW_NOTHROW(iItems + INCREMENT);
    if (!pbBuffNew)
        return E_OUTOFMEMORY;
    if (pbBuff)
    {
        memcpy(pbBuffNew, pbBuff, cbTotal);
        delete [] pbBuff;
    }
    else
    {
        _ASSERTE(cbTotal == SIZE);
        memcpy(pbBuffNew, rgData, cbTotal);
    }
    cbTotal = iItems + INCREMENT;
    iSize = iItems;
    pbBuff = pbBuffNew;
    return NOERROR;
}


/*************************************************************************************
*
* get number of bytes consumed by one argument/return type
*
*************************************************************************************/
#define CHECK_REMAINDER  if(cbTotal >= cbTotalMax){hr=E_FAIL; goto ErrExit;}
HRESULT _CountBytesOfOneArg(
    PCCOR_SIGNATURE pbSig,
    ULONG       *pcbTotal)  // Initially, *pcbTotal contains the remaining size of the sig blob
{
    ULONG       cb;
    ULONG       cbTotal=0;
    ULONG       cbTotalMax;
    CorElementType ulElementType;
    ULONG       ulData;
    ULONG       ulTemp;
    int         iData;
    mdToken     tk;
    ULONG       cArg;
    ULONG       callingconv;
    ULONG       cArgsIndex;
    HRESULT     hr = NOERROR;

    if(pcbTotal==NULL) return E_FAIL;
    cbTotalMax = *pcbTotal;

    CHECK_REMAINDER;
    cbTotal = CorSigUncompressElementType(pbSig, &ulElementType);
    while (CorIsModifierElementType((CorElementType) ulElementType))
    {
        CHECK_REMAINDER;
        cbTotal += CorSigUncompressElementType(&pbSig[cbTotal], &ulElementType);
    }
    switch (ulElementType)
    {
        case ELEMENT_TYPE_SZARRAY:
        case 0x1e /* obsolete */:
            // skip over base type
            CHECK_REMAINDER;
            cb = cbTotalMax - cbTotal;
            IfFailGo( _CountBytesOfOneArg(&pbSig[cbTotal], &cb) );
            cbTotal += cb;
            break;

        case ELEMENT_TYPE_FNPTR:
            CHECK_REMAINDER;
            cbTotal += CorSigUncompressData (&pbSig[cbTotal], &callingconv);

            // remember number of bytes to represent the arg counts
            CHECK_REMAINDER;
            cbTotal += CorSigUncompressData (&pbSig[cbTotal], &cArg);

            // how many bytes to represent the return type
            CHECK_REMAINDER;
            cb = cbTotalMax - cbTotal;
            IfFailGo( _CountBytesOfOneArg( &pbSig[cbTotal], &cb) );
            cbTotal += cb;

            // loop through argument
            for (cArgsIndex = 0; cArgsIndex < cArg; cArgsIndex++)
            {
                CHECK_REMAINDER;
                cb = cbTotalMax - cbTotal;
                IfFailGo( _CountBytesOfOneArg( &pbSig[cbTotal], &cb) );
                cbTotal += cb;
            }

            break;

        case ELEMENT_TYPE_ARRAY:
            // syntax : ARRAY BaseType <rank> [i size_1... size_i] [j lowerbound_1 ... lowerbound_j]

            // skip over base type
            CHECK_REMAINDER;
            cb = cbTotalMax - cbTotal;
            IfFailGo( _CountBytesOfOneArg(&pbSig[cbTotal], &cb) );
            cbTotal += cb;

            // Parse for the rank
            CHECK_REMAINDER;
            cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulData);

            // if rank == 0, we are done
            if (ulData == 0)
                break;

            // any size of dimension specified?
            CHECK_REMAINDER;
            cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulData);
            while (ulData--)
            {
                CHECK_REMAINDER;
                cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulTemp);
            }

            // any lower bound specified?
            CHECK_REMAINDER;
            cbTotal += CorSigUncompressData(&pbSig[cbTotal], &ulData);

            while (ulData--)
            {
                CHECK_REMAINDER;
                cbTotal += CorSigUncompressSignedInt(&pbSig[cbTotal], &iData);
            }

            break;
        case ELEMENT_TYPE_VALUETYPE:
        case ELEMENT_TYPE_CLASS:
        case ELEMENT_TYPE_CMOD_REQD:
        case ELEMENT_TYPE_CMOD_OPT:
            // count the bytes for the token compression
            CHECK_REMAINDER;
            cbTotal += CorSigUncompressToken(&pbSig[cbTotal], &tk);
            if ( ulElementType == ELEMENT_TYPE_CMOD_REQD ||
                 ulElementType == ELEMENT_TYPE_CMOD_OPT)
            {
                // skip over base type
                CHECK_REMAINDER;
                cb = cbTotalMax - cbTotal;
                IfFailGo( _CountBytesOfOneArg(&pbSig[cbTotal], &cb) );
                cbTotal += cb;
            }
            break;
        default:
            break;
    }

    *pcbTotal = cbTotal;
ErrExit:
    return hr;
}
#undef CHECK_REMAINDER

//*****************************************************************************
// copy fixed part of VarArg signature to a buffer
//*****************************************************************************
HRESULT _GetFixedSigOfVarArg(           // S_OK or error.
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob of COM+ method signature
    ULONG   cbSigBlob,                  // [IN] size of signature
    CQuickBytes *pqbSig,                // [OUT] output buffer for fixed part of VarArg Signature
    ULONG   *pcbSigBlob)                // [OUT] number of bytes written to the above output buffer
{
    HRESULT     hr = NOERROR;
    ULONG       cbCalling;
    ULONG       cbTyArgsNumber = 0;     // number of bytes to store the type arg count (generics only)
    ULONG       cbArgsNumber;           // number of bytes to store the original arg count
    ULONG       cbArgsNumberTemp;       // number of bytes to store the fixed arg count
    ULONG       cbTotal = 0;            // total of number bytes for return type + all fixed arguments
    ULONG       cbCur = 0;              // index through the pvSigBlob
    ULONG       cb;
    ULONG       cArg;
    ULONG       cTyArg;
    ULONG       callingconv;
    ULONG       cArgsIndex;
    CorElementType ulElementType;
    BYTE        *pbSig;

    _ASSERTE (pvSigBlob && pcbSigBlob);

    // remember the number of bytes to represent the calling convention
    cbCalling = CorSigUncompressData (pvSigBlob, &callingconv);
    if (cbCalling == ((ULONG)(-1)))
    {
        return E_INVALIDARG;
    }
    _ASSERTE (isCallConv(callingconv, IMAGE_CEE_CS_CALLCONV_VARARG));
    cbCur += cbCalling;

    if (callingconv & IMAGE_CEE_CS_CALLCONV_GENERIC)
    {
        cbTyArgsNumber = CorSigUncompressData(&pvSigBlob[cbCur], &cTyArg);
        if (cbTyArgsNumber == ((ULONG)(-1)))
        {
            return E_INVALIDARG;
        }
        cbCur += cbTyArgsNumber;
    }

    // remember number of bytes to represent the arg counts
    cbArgsNumber= CorSigUncompressData (&pvSigBlob[cbCur], &cArg);
    if (cbArgsNumber == ((ULONG)(-1)))
    {
        return E_INVALIDARG;
    }
    
    cbCur += cbArgsNumber;

    // how many bytes to represent the return type
    cb = cbSigBlob-cbCur;
    IfFailGo( _CountBytesOfOneArg( &pvSigBlob[cbCur], &cb) );
    cbCur += cb;
    cbTotal += cb;

    // loop through argument until we found ELEMENT_TYPE_SENTINEL or run
    // out of arguments
    for (cArgsIndex = 0; cArgsIndex < cArg; cArgsIndex++)
    {
        _ASSERTE(cbCur < cbSigBlob);

        // peak the outter most ELEMENT_TYPE_*
        CorSigUncompressElementType (&pvSigBlob[cbCur], &ulElementType);
        if (ulElementType == ELEMENT_TYPE_SENTINEL)
            break;
        cb = cbSigBlob-cbCur;
        IfFailGo( _CountBytesOfOneArg( &pvSigBlob[cbCur], &cb) );
        cbTotal += cb;
        cbCur += cb;
    }

    cbArgsNumberTemp = CorSigCompressData(cArgsIndex, &cArg);

    // now cbCalling : the number of bytes needed to store the calling convention
    // cbArgNumberTemp : number of bytes to store the fixed arg count
    // cbTotal : the number of bytes to store the ret and fixed arguments

    *pcbSigBlob = cbCalling + cbArgsNumberTemp + cbTotal;

    // resize the buffer
    IfFailGo( pqbSig->ReSizeNoThrow(*pcbSigBlob) );
    pbSig = (BYTE *)pqbSig->Ptr();

    // copy over the calling convention
    cb = CorSigCompressData(callingconv, pbSig);

    // copy over the fixed arg count
    cbArgsNumberTemp = CorSigCompressData(cArgsIndex, &pbSig[cb]);

    // copy over the fixed args + ret type
    memcpy(&pbSig[cb + cbArgsNumberTemp], &pvSigBlob[cbCalling + cbArgsNumber], cbTotal);

ErrExit:
    return hr;
}


#endif // !SOS_INCLUDE


//*****************************************************************************
//
//***** File format helper classes
//
//*****************************************************************************

extern "C" {

/***************************************************************************/
/* Note that this construtor does not set the LocalSig, but has the
   advantage that it does not have any dependancy on EE structures.
   inside the EE use the FunctionDesc constructor */

void __stdcall DecoderInit(void * pThis, COR_ILMETHOD* header)
{
    COR_ILMETHOD_DECODER* decoder = (COR_ILMETHOD_DECODER*)pThis;

    memset(decoder, 0, sizeof(COR_ILMETHOD_DECODER));
    if (header->Tiny.IsTiny()) {
        decoder->SetMaxStack(header->Tiny.GetMaxStack());
        decoder->Code = header->Tiny.GetCode();
        decoder->SetCodeSize(header->Tiny.GetCodeSize());
        decoder->SetFlags(CorILMethod_TinyFormat);
        return;
    }
    if (header->Fat.IsFat()) {
#ifdef _WIN64
        if((((size_t) header) & 3) == 0)        // header is aligned
#else
        _ASSERTE((((size_t) header) & 3) == 0);        // header is aligned
#endif
        {
            *((COR_ILMETHOD_FAT*) decoder) = header->Fat;
            decoder->Code = header->Fat.GetCode();
            if(header->Fat.GetSize() >= 3)        // Size if valid
            {
                decoder->Sect = header->Fat.GetSect();
                if (decoder->Sect != 0 && decoder->Sect->Kind() == CorILMethod_Sect_EHTable) {
                    decoder->EH = (COR_ILMETHOD_SECT_EH*) decoder->Sect;
                    decoder->Sect = decoder->Sect->Next();
                }
            }
        }
        return;
    }
    // so we don't asert on trash  _ASSERTE(!"Unknown format");
}

// Calculate the total method size. First get address of end of code. If there are no sections, then
// the end of code addr marks end of COR_ILMETHOD. Otherwise find addr of end of last section and use it
// to mark end of COR_ILMETHD. Assumes that the code is directly followed
// by each section in the on-disk format
int __stdcall DecoderGetOnDiskSize(void * pThis, COR_ILMETHOD* header)
{
    COR_ILMETHOD_DECODER* decoder = (COR_ILMETHOD_DECODER*)pThis;

    if (!decoder->Code)
        return 0;
    
    BYTE *lastAddr = (BYTE*)decoder->Code + decoder->GetCodeSize();    // addr of end of code
    const COR_ILMETHOD_SECT *sect = decoder->EH;
    if (sect != 0 && sect->Next() == 0)
        lastAddr = (BYTE *)(&sect->Data()[sect->DataSize()]);
    else
    {
        const COR_ILMETHOD_SECT *nextSect;
        for (sect = decoder->Sect; sect; sect = nextSect) {
            nextSect = sect->Next();
            if (nextSect == 0) {
                // sect points to the last section, so set lastAddr
                lastAddr = (BYTE *)(&sect->Data()[sect->DataSize()]);
                break;
            }
        }
    }
    return (int)(lastAddr - (BYTE*)header);
}

/*********************************************************************/
/* APIs for emitting sections etc */

unsigned __stdcall IlmethodSize(COR_ILMETHOD_FAT* header, BOOL moreSections)
{
    if (header->GetMaxStack() <= 8 && (header->GetFlags() & ~CorILMethod_FormatMask) == 0
        && header->GetLocalVarSigTok() == 0 && header->GetCodeSize() < 64 && !moreSections)
        return(sizeof(COR_ILMETHOD_TINY));

    return(sizeof(COR_ILMETHOD_FAT));
}

/*********************************************************************/
        // emit the header (bestFormat) return amount emitted
unsigned __stdcall IlmethodEmit(unsigned size, COR_ILMETHOD_FAT* header,
                  BOOL moreSections, BYTE* outBuff)
{
#ifndef SOS_INCLUDE    
#ifdef _DEBUG
    BYTE* origBuff = outBuff;
#endif
#endif // !SOS_INCLUDE
    if (size == 1) {
            // Tiny format
        *outBuff++ = (BYTE) (CorILMethod_TinyFormat | (header->GetCodeSize() << 2));
    }
    else {
            // Fat format
        _ASSERTE((((size_t) outBuff) & 3) == 0);               // header is dword aligned
        COR_ILMETHOD_FAT* fatHeader = (COR_ILMETHOD_FAT*) outBuff;
        outBuff += sizeof(COR_ILMETHOD_FAT);
        *fatHeader = *header;
        fatHeader->SetFlags(fatHeader->GetFlags() | CorILMethod_FatFormat);
        _ASSERTE((fatHeader->GetFlags() & CorILMethod_FormatMask) == CorILMethod_FatFormat);
        if (moreSections)
            fatHeader->SetFlags(fatHeader->GetFlags() | CorILMethod_MoreSects);
        fatHeader->SetSize(sizeof(COR_ILMETHOD_FAT) / 4);
    }
#ifndef SOS_INCLUDE        
    _ASSERTE(&origBuff[size] == outBuff);
#endif // !SOS_INCLUDE
    return(size);
}

/*********************************************************************/
/* static */
IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* __stdcall SectEH_EHClause(void *pSectEH, unsigned idx, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* buff)
{
    if (((COR_ILMETHOD_SECT_EH *)pSectEH)->IsFat())
        return(&(((COR_ILMETHOD_SECT_EH *)pSectEH)->Fat.Clauses[idx]));

    COR_ILMETHOD_SECT_EH_CLAUSE_FAT* fatClause = (COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)buff;
    COR_ILMETHOD_SECT_EH_CLAUSE_SMALL* smallClause = (COR_ILMETHOD_SECT_EH_CLAUSE_SMALL*)&((COR_ILMETHOD_SECT_EH *)pSectEH)->Small.Clauses[idx];

    // mask to remove sign extension - cast just wouldn't work
    fatClause->SetFlags((CorExceptionFlag)(smallClause->GetFlags()&0x0000ffff));
    fatClause->SetClassToken(smallClause->GetClassToken());
    fatClause->SetTryOffset(smallClause->GetTryOffset());
    fatClause->SetTryLength(smallClause->GetTryLength());
    fatClause->SetHandlerLength(smallClause->GetHandlerLength());
    fatClause->SetHandlerOffset(smallClause->GetHandlerOffset());
    return(buff);
}
/*********************************************************************/
        // compute the size of the section (best format)
        // codeSize is the size of the method
    // deprecated
unsigned __stdcall SectEH_SizeWithCode(unsigned ehCount, unsigned codeSize)
{
    return((ehCount)? SectEH_SizeWorst(ehCount) : 0);
}

    // will return worse-case size and then Emit will return actual size
unsigned __stdcall SectEH_SizeWorst(unsigned ehCount)
{
    return((ehCount)? (COR_ILMETHOD_SECT_EH_FAT::Size(ehCount)) : 0);
}

    // will return exact size which will match the size returned by Emit
unsigned __stdcall SectEH_SizeExact(unsigned ehCount, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses)
{
    if (ehCount == 0)
        return(0);

    unsigned smallSize = COR_ILMETHOD_SECT_EH_SMALL::Size(ehCount);
    if (smallSize > COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE)
            return(COR_ILMETHOD_SECT_EH_FAT::Size(ehCount));
    for (unsigned i = 0; i < ehCount; i++) {
        COR_ILMETHOD_SECT_EH_CLAUSE_FAT* fatClause = (COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)&clauses[i];
        if (fatClause->GetTryOffset() > 0xFFFF ||
                fatClause->GetTryLength() > 0xFF ||
                fatClause->GetHandlerOffset() > 0xFFFF ||
                fatClause->GetHandlerLength() > 0xFF) {
            return(COR_ILMETHOD_SECT_EH_FAT::Size(ehCount));
        }
    }
    return smallSize;
}

/*********************************************************************/

        // emit the section (best format);
unsigned __stdcall SectEH_Emit(unsigned size, unsigned ehCount,
                  IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses,
                  BOOL moreSections, BYTE* outBuff,
                  ULONG* ehTypeOffsets)
{
    if (size == 0)
       return(0);

    _ASSERTE((((size_t) outBuff) & 3) == 0);               // header is dword aligned
    BYTE* origBuff = outBuff;
    if (ehCount <= 0)
        return 0;

    // Initialize the ehTypeOffsets array.
    if (ehTypeOffsets)
    {
        for (unsigned int i = 0; i < ehCount; i++)
            ehTypeOffsets[i] = (ULONG) -1;
    }

    if (COR_ILMETHOD_SECT_EH_SMALL::Size(ehCount) < COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE) {
        COR_ILMETHOD_SECT_EH_SMALL* EHSect = (COR_ILMETHOD_SECT_EH_SMALL*) outBuff;
        unsigned i;
        for (i = 0; i < ehCount; i++) {
            COR_ILMETHOD_SECT_EH_CLAUSE_FAT* fatClause = (COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)&clauses[i];
            if (fatClause->GetTryOffset() > 0xFFFF ||
                    fatClause->GetTryLength() > 0xFF ||
                    fatClause->GetHandlerOffset() > 0xFFFF ||
                    fatClause->GetHandlerLength() > 0xFF) {
                break;  // fall through and generate as FAT
            }
            _ASSERTE((fatClause->GetFlags() & ~0xFFFF) == 0);
            _ASSERTE((fatClause->GetTryOffset() & ~0xFFFF) == 0);
            _ASSERTE((fatClause->GetTryLength() & ~0xFF) == 0);
            _ASSERTE((fatClause->GetHandlerOffset() & ~0xFFFF) == 0);
            _ASSERTE((fatClause->GetHandlerLength() & ~0xFF) == 0);

            COR_ILMETHOD_SECT_EH_CLAUSE_SMALL* smallClause = (COR_ILMETHOD_SECT_EH_CLAUSE_SMALL*)&EHSect->Clauses[i];
            smallClause->SetFlags((CorExceptionFlag) fatClause->GetFlags());
            smallClause->SetTryOffset(fatClause->GetTryOffset());
            smallClause->SetTryLength(fatClause->GetTryLength());
            smallClause->SetHandlerOffset(fatClause->GetHandlerOffset());
            smallClause->SetHandlerLength(fatClause->GetHandlerLength());
            smallClause->SetClassToken(fatClause->GetClassToken());
        }
        if (i >= ehCount) {
            // if actually got through all the clauses and they are small enough
            EHSect->Kind = CorILMethod_Sect_EHTable;
            if (moreSections)
                EHSect->Kind |= CorILMethod_Sect_MoreSects;
#ifndef SOS_INCLUDE            
            EHSect->DataSize = EHSect->Size(ehCount);
#else
            EHSect->DataSize = (BYTE) EHSect->Size(ehCount);
#endif // !SOS_INCLUDE
            EHSect->Reserved = 0;
            _ASSERTE(EHSect->DataSize == EHSect->Size(ehCount)); // make sure didn't overflow
            outBuff = (BYTE*) &EHSect->Clauses[ehCount];
            // Set the offsets for the exception type tokens.
            if (ehTypeOffsets)
            {
                for (i = 0; i < ehCount; i++) {
                    COR_ILMETHOD_SECT_EH_CLAUSE_SMALL* smallClause = (COR_ILMETHOD_SECT_EH_CLAUSE_SMALL*)&EHSect->Clauses[i];
                    if (smallClause->GetFlags() == COR_ILEXCEPTION_CLAUSE_NONE)
                    {
                        _ASSERTE(! IsNilToken(smallClause->GetClassToken()));
                        ehTypeOffsets[i] = (ULONG)((BYTE *)&smallClause->ClassToken - origBuff);
                    }
                }
            }
            return(size);
        }
    }
    // either total size too big or one of constituent elements too big (eg. offset or length)
    COR_ILMETHOD_SECT_EH_FAT* EHSect = (COR_ILMETHOD_SECT_EH_FAT*) outBuff;
    EHSect->SetKind(CorILMethod_Sect_EHTable | CorILMethod_Sect_FatFormat);
    if (moreSections)
        EHSect->SetKind(EHSect->GetKind() | CorILMethod_Sect_MoreSects);

    EHSect->SetDataSize(EHSect->Size(ehCount));
    memcpy(EHSect->Clauses, clauses, ehCount * sizeof(COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
    outBuff = (BYTE*) &EHSect->Clauses[ehCount];
    _ASSERTE(&origBuff[size] == outBuff);
    // Set the offsets for the exception type tokens.
    if (ehTypeOffsets)
    {
        for (unsigned int i = 0; i < ehCount; i++) {
            COR_ILMETHOD_SECT_EH_CLAUSE_FAT* fatClause = (COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)&EHSect->Clauses[i];
            if (fatClause->GetFlags() == COR_ILEXCEPTION_CLAUSE_NONE)
            {
                _ASSERTE(! IsNilToken(fatClause->GetClassToken()));
                ehTypeOffsets[i] = (ULONG)((BYTE *)&fatClause->ClassToken - origBuff);
            }
        }
    }
    return(size);
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\corpub.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for corpub.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __corpub_h__
#define __corpub_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __CorpubPublish_FWD_DEFINED__
#define __CorpubPublish_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorpubPublish CorpubPublish;
#else
typedef struct CorpubPublish CorpubPublish;
#endif /* __cplusplus */

#endif 	/* __CorpubPublish_FWD_DEFINED__ */


#ifndef __ICorPublish_FWD_DEFINED__
#define __ICorPublish_FWD_DEFINED__
typedef interface ICorPublish ICorPublish;
#endif 	/* __ICorPublish_FWD_DEFINED__ */


#ifndef __ICorPublishEnum_FWD_DEFINED__
#define __ICorPublishEnum_FWD_DEFINED__
typedef interface ICorPublishEnum ICorPublishEnum;
#endif 	/* __ICorPublishEnum_FWD_DEFINED__ */


#ifndef __ICorPublishProcess_FWD_DEFINED__
#define __ICorPublishProcess_FWD_DEFINED__
typedef interface ICorPublishProcess ICorPublishProcess;
#endif 	/* __ICorPublishProcess_FWD_DEFINED__ */


#ifndef __ICorPublishAppDomain_FWD_DEFINED__
#define __ICorPublishAppDomain_FWD_DEFINED__
typedef interface ICorPublishAppDomain ICorPublishAppDomain;
#endif 	/* __ICorPublishAppDomain_FWD_DEFINED__ */


#ifndef __ICorPublishProcessEnum_FWD_DEFINED__
#define __ICorPublishProcessEnum_FWD_DEFINED__
typedef interface ICorPublishProcessEnum ICorPublishProcessEnum;
#endif 	/* __ICorPublishProcessEnum_FWD_DEFINED__ */


#ifndef __ICorPublishAppDomainEnum_FWD_DEFINED__
#define __ICorPublishAppDomainEnum_FWD_DEFINED__
typedef interface ICorPublishAppDomainEnum ICorPublishAppDomainEnum;
#endif 	/* __ICorPublishAppDomainEnum_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_corpub_0000 */
/* [local] */ 

#if 0
#endif
typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corpub_0000_0001
    {	COR_PUB_MANAGEDONLY	= 0x1
    } 	COR_PUB_ENUMPROCESS;








extern RPC_IF_HANDLE __MIDL_itf_corpub_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corpub_0000_v0_0_s_ifspec;


#ifndef __CorpubProcessLib_LIBRARY_DEFINED__
#define __CorpubProcessLib_LIBRARY_DEFINED__

/* library CorpubProcessLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CorpubProcessLib;

EXTERN_C const CLSID CLSID_CorpubPublish;

#ifdef __cplusplus

class DECLSPEC_UUID("047a9a40-657e-11d3-8d5b-00104b35e7ef")
CorpubPublish;
#endif
#endif /* __CorpubProcessLib_LIBRARY_DEFINED__ */

#ifndef __ICorPublish_INTERFACE_DEFINED__
#define __ICorPublish_INTERFACE_DEFINED__

/* interface ICorPublish */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorPublish;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9613A0E7-5A68-11d3-8F84-00A0C9B4D50C")
    ICorPublish : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumProcesses( 
            /* [in] */ COR_PUB_ENUMPROCESS Type,
            /* [out] */ ICorPublishProcessEnum **ppIEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcess( 
            /* [in] */ unsigned int pid,
            /* [out] */ ICorPublishProcess **ppProcess) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorPublishVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorPublish * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorPublish * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorPublish * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumProcesses )( 
            ICorPublish * This,
            /* [in] */ COR_PUB_ENUMPROCESS Type,
            /* [out] */ ICorPublishProcessEnum **ppIEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcess )( 
            ICorPublish * This,
            /* [in] */ unsigned int pid,
            /* [out] */ ICorPublishProcess **ppProcess);
        
        END_INTERFACE
    } ICorPublishVtbl;

    interface ICorPublish
    {
        CONST_VTBL struct ICorPublishVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorPublish_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorPublish_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorPublish_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorPublish_EnumProcesses(This,Type,ppIEnum)	\
    (This)->lpVtbl -> EnumProcesses(This,Type,ppIEnum)

#define ICorPublish_GetProcess(This,pid,ppProcess)	\
    (This)->lpVtbl -> GetProcess(This,pid,ppProcess)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorPublish_EnumProcesses_Proxy( 
    ICorPublish * This,
    /* [in] */ COR_PUB_ENUMPROCESS Type,
    /* [out] */ ICorPublishProcessEnum **ppIEnum);


void __RPC_STUB ICorPublish_EnumProcesses_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublish_GetProcess_Proxy( 
    ICorPublish * This,
    /* [in] */ unsigned int pid,
    /* [out] */ ICorPublishProcess **ppProcess);


void __RPC_STUB ICorPublish_GetProcess_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorPublish_INTERFACE_DEFINED__ */


#ifndef __ICorPublishEnum_INTERFACE_DEFINED__
#define __ICorPublishEnum_INTERFACE_DEFINED__

/* interface ICorPublishEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorPublishEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C0B22967-5A69-11d3-8F84-00A0C9B4D50C")
    ICorPublishEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ ICorPublishEnum **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorPublishEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorPublishEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorPublishEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorPublishEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorPublishEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorPublishEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorPublishEnum * This,
            /* [out] */ ICorPublishEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorPublishEnum * This,
            /* [out] */ ULONG *pcelt);
        
        END_INTERFACE
    } ICorPublishEnumVtbl;

    interface ICorPublishEnum
    {
        CONST_VTBL struct ICorPublishEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorPublishEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorPublishEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorPublishEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorPublishEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorPublishEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorPublishEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorPublishEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorPublishEnum_Skip_Proxy( 
    ICorPublishEnum * This,
    /* [in] */ ULONG celt);


void __RPC_STUB ICorPublishEnum_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishEnum_Reset_Proxy( 
    ICorPublishEnum * This);


void __RPC_STUB ICorPublishEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishEnum_Clone_Proxy( 
    ICorPublishEnum * This,
    /* [out] */ ICorPublishEnum **ppEnum);


void __RPC_STUB ICorPublishEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishEnum_GetCount_Proxy( 
    ICorPublishEnum * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB ICorPublishEnum_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorPublishEnum_INTERFACE_DEFINED__ */


#ifndef __ICorPublishProcess_INTERFACE_DEFINED__
#define __ICorPublishProcess_INTERFACE_DEFINED__

/* interface ICorPublishProcess */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorPublishProcess;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("18D87AF1-5A6A-11d3-8F84-00A0C9B4D50C")
    ICorPublishProcess : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsManaged( 
            /* [out] */ BOOL *pbManaged) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAppDomains( 
            /* [out] */ ICorPublishAppDomainEnum **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProcessID( 
            /* [out] */ unsigned int *pid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR *szName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorPublishProcessVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorPublishProcess * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorPublishProcess * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorPublishProcess * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsManaged )( 
            ICorPublishProcess * This,
            /* [out] */ BOOL *pbManaged);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAppDomains )( 
            ICorPublishProcess * This,
            /* [out] */ ICorPublishAppDomainEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetProcessID )( 
            ICorPublishProcess * This,
            /* [out] */ unsigned int *pid);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            ICorPublishProcess * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR *szName);
        
        END_INTERFACE
    } ICorPublishProcessVtbl;

    interface ICorPublishProcess
    {
        CONST_VTBL struct ICorPublishProcessVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorPublishProcess_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorPublishProcess_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorPublishProcess_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorPublishProcess_IsManaged(This,pbManaged)	\
    (This)->lpVtbl -> IsManaged(This,pbManaged)

#define ICorPublishProcess_EnumAppDomains(This,ppEnum)	\
    (This)->lpVtbl -> EnumAppDomains(This,ppEnum)

#define ICorPublishProcess_GetProcessID(This,pid)	\
    (This)->lpVtbl -> GetProcessID(This,pid)

#define ICorPublishProcess_GetDisplayName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetDisplayName(This,cchName,pcchName,szName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorPublishProcess_IsManaged_Proxy( 
    ICorPublishProcess * This,
    /* [out] */ BOOL *pbManaged);


void __RPC_STUB ICorPublishProcess_IsManaged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishProcess_EnumAppDomains_Proxy( 
    ICorPublishProcess * This,
    /* [out] */ ICorPublishAppDomainEnum **ppEnum);


void __RPC_STUB ICorPublishProcess_EnumAppDomains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishProcess_GetProcessID_Proxy( 
    ICorPublishProcess * This,
    /* [out] */ unsigned int *pid);


void __RPC_STUB ICorPublishProcess_GetProcessID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishProcess_GetDisplayName_Proxy( 
    ICorPublishProcess * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR *szName);


void __RPC_STUB ICorPublishProcess_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorPublishProcess_INTERFACE_DEFINED__ */


#ifndef __ICorPublishAppDomain_INTERFACE_DEFINED__
#define __ICorPublishAppDomain_INTERFACE_DEFINED__

/* interface ICorPublishAppDomain */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorPublishAppDomain;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D6315C8F-5A6A-11d3-8F84-00A0C9B4D50C")
    ICorPublishAppDomain : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetID( 
            /* [out] */ ULONG32 *puId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR *szName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorPublishAppDomainVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorPublishAppDomain * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorPublishAppDomain * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorPublishAppDomain * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetID )( 
            ICorPublishAppDomain * This,
            /* [out] */ ULONG32 *puId);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ICorPublishAppDomain * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR *szName);
        
        END_INTERFACE
    } ICorPublishAppDomainVtbl;

    interface ICorPublishAppDomain
    {
        CONST_VTBL struct ICorPublishAppDomainVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorPublishAppDomain_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorPublishAppDomain_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorPublishAppDomain_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorPublishAppDomain_GetID(This,puId)	\
    (This)->lpVtbl -> GetID(This,puId)

#define ICorPublishAppDomain_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorPublishAppDomain_GetID_Proxy( 
    ICorPublishAppDomain * This,
    /* [out] */ ULONG32 *puId);


void __RPC_STUB ICorPublishAppDomain_GetID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorPublishAppDomain_GetName_Proxy( 
    ICorPublishAppDomain * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR *szName);


void __RPC_STUB ICorPublishAppDomain_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorPublishAppDomain_INTERFACE_DEFINED__ */


#ifndef __ICorPublishProcessEnum_INTERFACE_DEFINED__
#define __ICorPublishProcessEnum_INTERFACE_DEFINED__

/* interface ICorPublishProcessEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorPublishProcessEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A37FBD41-5A69-11d3-8F84-00A0C9B4D50C")
    ICorPublishProcessEnum : public ICorPublishEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorPublishProcess **objects,
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorPublishProcessEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorPublishProcessEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorPublishProcessEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorPublishProcessEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorPublishProcessEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorPublishProcessEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorPublishProcessEnum * This,
            /* [out] */ ICorPublishEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorPublishProcessEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorPublishProcessEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorPublishProcess **objects,
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorPublishProcessEnumVtbl;

    interface ICorPublishProcessEnum
    {
        CONST_VTBL struct ICorPublishProcessEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorPublishProcessEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorPublishProcessEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorPublishProcessEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorPublishProcessEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorPublishProcessEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorPublishProcessEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorPublishProcessEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorPublishProcessEnum_Next(This,celt,objects,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,objects,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorPublishProcessEnum_Next_Proxy( 
    ICorPublishProcessEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorPublishProcess **objects,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorPublishProcessEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorPublishProcessEnum_INTERFACE_DEFINED__ */


#ifndef __ICorPublishAppDomainEnum_INTERFACE_DEFINED__
#define __ICorPublishAppDomainEnum_INTERFACE_DEFINED__

/* interface ICorPublishAppDomainEnum */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICorPublishAppDomainEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F0C98F5-5A6A-11d3-8F84-00A0C9B4D50C")
    ICorPublishAppDomainEnum : public ICorPublishEnum
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorPublishAppDomain **objects,
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorPublishAppDomainEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorPublishAppDomainEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorPublishAppDomainEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorPublishAppDomainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorPublishAppDomainEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorPublishAppDomainEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorPublishAppDomainEnum * This,
            /* [out] */ ICorPublishEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorPublishAppDomainEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorPublishAppDomainEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ICorPublishAppDomain **objects,
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorPublishAppDomainEnumVtbl;

    interface ICorPublishAppDomainEnum
    {
        CONST_VTBL struct ICorPublishAppDomainEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorPublishAppDomainEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorPublishAppDomainEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorPublishAppDomainEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorPublishAppDomainEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorPublishAppDomainEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorPublishAppDomainEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorPublishAppDomainEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)


#define ICorPublishAppDomainEnum_Next(This,celt,objects,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,objects,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorPublishAppDomainEnum_Next_Proxy( 
    ICorPublishAppDomainEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ICorPublishAppDomain **objects,
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorPublishAppDomainEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorPublishAppDomainEnum_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\corsym.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for corsym.idl:
    Oicf, W0, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __corsym_h__
#define __corsym_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __CorSymWriter_deprecated_FWD_DEFINED__
#define __CorSymWriter_deprecated_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorSymWriter_deprecated CorSymWriter_deprecated;
#else
typedef struct CorSymWriter_deprecated CorSymWriter_deprecated;
#endif /* __cplusplus */

#endif 	/* __CorSymWriter_deprecated_FWD_DEFINED__ */


#ifndef __CorSymReader_deprecated_FWD_DEFINED__
#define __CorSymReader_deprecated_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorSymReader_deprecated CorSymReader_deprecated;
#else
typedef struct CorSymReader_deprecated CorSymReader_deprecated;
#endif /* __cplusplus */

#endif 	/* __CorSymReader_deprecated_FWD_DEFINED__ */


#ifndef __CorSymBinder_deprecated_FWD_DEFINED__
#define __CorSymBinder_deprecated_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorSymBinder_deprecated CorSymBinder_deprecated;
#else
typedef struct CorSymBinder_deprecated CorSymBinder_deprecated;
#endif /* __cplusplus */

#endif 	/* __CorSymBinder_deprecated_FWD_DEFINED__ */


#ifndef __CorSymWriter_SxS_FWD_DEFINED__
#define __CorSymWriter_SxS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorSymWriter_SxS CorSymWriter_SxS;
#else
typedef struct CorSymWriter_SxS CorSymWriter_SxS;
#endif /* __cplusplus */

#endif 	/* __CorSymWriter_SxS_FWD_DEFINED__ */


#ifndef __CorSymReader_SxS_FWD_DEFINED__
#define __CorSymReader_SxS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorSymReader_SxS CorSymReader_SxS;
#else
typedef struct CorSymReader_SxS CorSymReader_SxS;
#endif /* __cplusplus */

#endif 	/* __CorSymReader_SxS_FWD_DEFINED__ */


#ifndef __CorSymBinder_SxS_FWD_DEFINED__
#define __CorSymBinder_SxS_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorSymBinder_SxS CorSymBinder_SxS;
#else
typedef struct CorSymBinder_SxS CorSymBinder_SxS;
#endif /* __cplusplus */

#endif 	/* __CorSymBinder_SxS_FWD_DEFINED__ */


#ifndef __ISymUnmanagedBinder_FWD_DEFINED__
#define __ISymUnmanagedBinder_FWD_DEFINED__
typedef interface ISymUnmanagedBinder ISymUnmanagedBinder;
#endif 	/* __ISymUnmanagedBinder_FWD_DEFINED__ */


#ifndef __ISymUnmanagedBinder2_FWD_DEFINED__
#define __ISymUnmanagedBinder2_FWD_DEFINED__
typedef interface ISymUnmanagedBinder2 ISymUnmanagedBinder2;
#endif 	/* __ISymUnmanagedBinder2_FWD_DEFINED__ */


#ifndef __ISymUnmanagedBinder3_FWD_DEFINED__
#define __ISymUnmanagedBinder3_FWD_DEFINED__
typedef interface ISymUnmanagedBinder3 ISymUnmanagedBinder3;
#endif 	/* __ISymUnmanagedBinder3_FWD_DEFINED__ */


#ifndef __ISymUnmanagedDispose_FWD_DEFINED__
#define __ISymUnmanagedDispose_FWD_DEFINED__
typedef interface ISymUnmanagedDispose ISymUnmanagedDispose;
#endif 	/* __ISymUnmanagedDispose_FWD_DEFINED__ */


#ifndef __ISymUnmanagedDocument_FWD_DEFINED__
#define __ISymUnmanagedDocument_FWD_DEFINED__
typedef interface ISymUnmanagedDocument ISymUnmanagedDocument;
#endif 	/* __ISymUnmanagedDocument_FWD_DEFINED__ */


#ifndef __ISymUnmanagedDocumentWriter_FWD_DEFINED__
#define __ISymUnmanagedDocumentWriter_FWD_DEFINED__
typedef interface ISymUnmanagedDocumentWriter ISymUnmanagedDocumentWriter;
#endif 	/* __ISymUnmanagedDocumentWriter_FWD_DEFINED__ */


#ifndef __ISymUnmanagedMethod_FWD_DEFINED__
#define __ISymUnmanagedMethod_FWD_DEFINED__
typedef interface ISymUnmanagedMethod ISymUnmanagedMethod;
#endif 	/* __ISymUnmanagedMethod_FWD_DEFINED__ */


#ifndef __ISymENCUnmanagedMethod_FWD_DEFINED__
#define __ISymENCUnmanagedMethod_FWD_DEFINED__
typedef interface ISymENCUnmanagedMethod ISymENCUnmanagedMethod;
#endif 	/* __ISymENCUnmanagedMethod_FWD_DEFINED__ */


#ifndef __ISymUnmanagedNamespace_FWD_DEFINED__
#define __ISymUnmanagedNamespace_FWD_DEFINED__
typedef interface ISymUnmanagedNamespace ISymUnmanagedNamespace;
#endif 	/* __ISymUnmanagedNamespace_FWD_DEFINED__ */


#ifndef __ISymUnmanagedReader_FWD_DEFINED__
#define __ISymUnmanagedReader_FWD_DEFINED__
typedef interface ISymUnmanagedReader ISymUnmanagedReader;
#endif 	/* __ISymUnmanagedReader_FWD_DEFINED__ */


#ifndef __ISymUnmanagedSourceServerModule_FWD_DEFINED__
#define __ISymUnmanagedSourceServerModule_FWD_DEFINED__
typedef interface ISymUnmanagedSourceServerModule ISymUnmanagedSourceServerModule;
#endif 	/* __ISymUnmanagedSourceServerModule_FWD_DEFINED__ */


#ifndef __ISymUnmanagedENCUpdate_FWD_DEFINED__
#define __ISymUnmanagedENCUpdate_FWD_DEFINED__
typedef interface ISymUnmanagedENCUpdate ISymUnmanagedENCUpdate;
#endif 	/* __ISymUnmanagedENCUpdate_FWD_DEFINED__ */


#ifndef __ISymUnmanagedReaderSymbolSearchInfo_FWD_DEFINED__
#define __ISymUnmanagedReaderSymbolSearchInfo_FWD_DEFINED__
typedef interface ISymUnmanagedReaderSymbolSearchInfo ISymUnmanagedReaderSymbolSearchInfo;
#endif 	/* __ISymUnmanagedReaderSymbolSearchInfo_FWD_DEFINED__ */


#ifndef __ISymUnmanagedScope_FWD_DEFINED__
#define __ISymUnmanagedScope_FWD_DEFINED__
typedef interface ISymUnmanagedScope ISymUnmanagedScope;
#endif 	/* __ISymUnmanagedScope_FWD_DEFINED__ */


#ifndef __ISymUnmanagedConstant_FWD_DEFINED__
#define __ISymUnmanagedConstant_FWD_DEFINED__
typedef interface ISymUnmanagedConstant ISymUnmanagedConstant;
#endif 	/* __ISymUnmanagedConstant_FWD_DEFINED__ */


#ifndef __ISymUnmanagedScope2_FWD_DEFINED__
#define __ISymUnmanagedScope2_FWD_DEFINED__
typedef interface ISymUnmanagedScope2 ISymUnmanagedScope2;
#endif 	/* __ISymUnmanagedScope2_FWD_DEFINED__ */


#ifndef __ISymUnmanagedVariable_FWD_DEFINED__
#define __ISymUnmanagedVariable_FWD_DEFINED__
typedef interface ISymUnmanagedVariable ISymUnmanagedVariable;
#endif 	/* __ISymUnmanagedVariable_FWD_DEFINED__ */


#ifndef __ISymUnmanagedSymbolSearchInfo_FWD_DEFINED__
#define __ISymUnmanagedSymbolSearchInfo_FWD_DEFINED__
typedef interface ISymUnmanagedSymbolSearchInfo ISymUnmanagedSymbolSearchInfo;
#endif 	/* __ISymUnmanagedSymbolSearchInfo_FWD_DEFINED__ */


#ifndef __ISymUnmanagedWriter_FWD_DEFINED__
#define __ISymUnmanagedWriter_FWD_DEFINED__
typedef interface ISymUnmanagedWriter ISymUnmanagedWriter;
#endif 	/* __ISymUnmanagedWriter_FWD_DEFINED__ */


#ifndef __ISymUnmanagedWriter2_FWD_DEFINED__
#define __ISymUnmanagedWriter2_FWD_DEFINED__
typedef interface ISymUnmanagedWriter2 ISymUnmanagedWriter2;
#endif 	/* __ISymUnmanagedWriter2_FWD_DEFINED__ */


#ifndef __ISymUnmanagedWriter3_FWD_DEFINED__
#define __ISymUnmanagedWriter3_FWD_DEFINED__
typedef interface ISymUnmanagedWriter3 ISymUnmanagedWriter3;
#endif 	/* __ISymUnmanagedWriter3_FWD_DEFINED__ */


#ifndef __ISymUnmanagedReader2_FWD_DEFINED__
#define __ISymUnmanagedReader2_FWD_DEFINED__
typedef interface ISymUnmanagedReader2 ISymUnmanagedReader2;
#endif 	/* __ISymUnmanagedReader2_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_corsym_0000 */
/* [local] */ 

#if 0
typedef typedef unsigned int UINT32;
;

typedef mdToken mdTypeDef;

typedef mdToken mdMethodDef;

typedef typedef ULONG_PTR SIZE_T;
;

#endif
#ifndef __CORHDR_H__
typedef mdToken mdSignature;

#endif
EXTERN_GUID(CorSym_LanguageType_C, 0x63a08714, 0xfc37, 0x11d2, 0x90, 0x4c, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1);
EXTERN_GUID(CorSym_LanguageType_CPlusPlus, 0x3a12d0b7, 0xc26c, 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);
EXTERN_GUID(CorSym_LanguageType_CSharp, 0x3f5162f8, 0x07c6, 0x11d3, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1);
EXTERN_GUID(CorSym_LanguageType_Basic, 0x3a12d0b8, 0xc26c, 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);
EXTERN_GUID(CorSym_LanguageType_Java, 0x3a12d0b4, 0xc26c, 0x11d0, 0xb4, 0x42, 0x0, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);
EXTERN_GUID(CorSym_LanguageType_Cobol, 0xaf046cd1, 0xd0e1, 0x11d2, 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);
EXTERN_GUID(CorSym_LanguageType_Pascal, 0xaf046cd2, 0xd0e1, 0x11d2, 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);
EXTERN_GUID(CorSym_LanguageType_ILAssembly, 0xaf046cd3, 0xd0e1, 0x11d2, 0x97, 0x7c, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc);
EXTERN_GUID(CorSym_LanguageType_JScript, 0x3a12d0b6, 0xc26c, 0x11d0, 0xb4, 0x42, 0x00, 0xa0, 0x24, 0x4a, 0x1d, 0xd2);
EXTERN_GUID(CorSym_LanguageType_SMC, 0xd9b9f7b, 0x6611, 0x11d3, 0xbd, 0x2a, 0x0, 0x0, 0xf8, 0x8, 0x49, 0xbd);
EXTERN_GUID(CorSym_LanguageType_MCPlusPlus, 0x4b35fde8, 0x07c6, 0x11d3, 0x90, 0x53, 0x0, 0xc0, 0x4f, 0xa3, 0x02, 0xa1);
EXTERN_GUID(CorSym_LanguageVendor_Microsoft, 0x994b45c4, 0xe6e9, 0x11d2, 0x90, 0x3f, 0x00, 0xc0, 0x4f, 0xa3, 0x02, 0xa1);
EXTERN_GUID(CorSym_DocumentType_Text, 0x5a869d0b, 0x6611, 0x11d3, 0xbd, 0x2a, 0x0, 0x0, 0xf8, 0x8, 0x49, 0xbd);
EXTERN_GUID(CorSym_DocumentType_MC, 0xeb40cb65, 0x3c1f, 0x4352, 0x9d, 0x7b, 0xba, 0xf, 0xc4, 0x7a, 0x9d, 0x77);
EXTERN_GUID(CorSym_SourceHash_MD5,  0x406ea660, 0x64cf, 0x4c82, 0xb6, 0xf0, 0x42, 0xd4, 0x81, 0x72, 0xa7, 0x99);
EXTERN_GUID(CorSym_SourceHash_SHA1, 0xff1816ec, 0xaa5e, 0x4d10, 0x87, 0xf7, 0x6f, 0x49, 0x63, 0x83, 0x34, 0x60);












typedef 
enum CorSymAddrKind
    {	ADDR_IL_OFFSET	= 1,
	ADDR_NATIVE_RVA	= 2,
	ADDR_NATIVE_REGISTER	= 3,
	ADDR_NATIVE_REGREL	= 4,
	ADDR_NATIVE_OFFSET	= 5,
	ADDR_NATIVE_REGREG	= 6,
	ADDR_NATIVE_REGSTK	= 7,
	ADDR_NATIVE_STKREG	= 8,
	ADDR_BITFIELD	= 9,
	ADDR_NATIVE_ISECTOFFSET	= 10
    } 	CorSymAddrKind;

typedef 
enum CorSymVarFlag
    {	VAR_IS_COMP_GEN	= 1
    } 	CorSymVarFlag;



extern RPC_IF_HANDLE __MIDL_itf_corsym_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corsym_0000_v0_0_s_ifspec;


#ifndef __CorSymLib_LIBRARY_DEFINED__
#define __CorSymLib_LIBRARY_DEFINED__

/* library CorSymLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CorSymLib;

EXTERN_C const CLSID CLSID_CorSymWriter_deprecated;

#ifdef __cplusplus

class DECLSPEC_UUID("108296C1-281E-11d3-BD22-0000F80849BD")
CorSymWriter_deprecated;
#endif

EXTERN_C const CLSID CLSID_CorSymReader_deprecated;

#ifdef __cplusplus

class DECLSPEC_UUID("108296C2-281E-11d3-BD22-0000F80849BD")
CorSymReader_deprecated;
#endif

EXTERN_C const CLSID CLSID_CorSymBinder_deprecated;

#ifdef __cplusplus

class DECLSPEC_UUID("AA544D41-28CB-11d3-BD22-0000F80849BD")
CorSymBinder_deprecated;
#endif

EXTERN_C const CLSID CLSID_CorSymWriter_SxS;

#ifdef __cplusplus

class DECLSPEC_UUID("0AE2DEB0-F901-478b-BB9F-881EE8066788")
CorSymWriter_SxS;
#endif

EXTERN_C const CLSID CLSID_CorSymReader_SxS;

#ifdef __cplusplus

class DECLSPEC_UUID("0A3976C5-4529-4ef8-B0B0-42EED37082CD")
CorSymReader_SxS;
#endif

EXTERN_C const CLSID CLSID_CorSymBinder_SxS;

#ifdef __cplusplus

class DECLSPEC_UUID("0A29FF9E-7F9C-4437-8B11-F424491E3931")
CorSymBinder_SxS;
#endif
#endif /* __CorSymLib_LIBRARY_DEFINED__ */

#ifndef __ISymUnmanagedBinder_INTERFACE_DEFINED__
#define __ISymUnmanagedBinder_INTERFACE_DEFINED__

/* interface ISymUnmanagedBinder */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedBinder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AA544D42-28CB-11d3-BD22-0000F80849BD")
    ISymUnmanagedBinder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReaderForFile( 
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReaderFromStream( 
            /* [in] */ IUnknown *importer,
            /* [in] */ IStream *pstream,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedBinderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedBinder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedBinder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedBinder * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderForFile )( 
            ISymUnmanagedBinder * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderFromStream )( 
            ISymUnmanagedBinder * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ IStream *pstream,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        END_INTERFACE
    } ISymUnmanagedBinderVtbl;

    interface ISymUnmanagedBinder
    {
        CONST_VTBL struct ISymUnmanagedBinderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedBinder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedBinder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedBinder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedBinder_GetReaderForFile(This,importer,fileName,searchPath,pRetVal)	\
    (This)->lpVtbl -> GetReaderForFile(This,importer,fileName,searchPath,pRetVal)

#define ISymUnmanagedBinder_GetReaderFromStream(This,importer,pstream,pRetVal)	\
    (This)->lpVtbl -> GetReaderFromStream(This,importer,pstream,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedBinder_GetReaderForFile_Proxy( 
    ISymUnmanagedBinder * This,
    /* [in] */ IUnknown *importer,
    /* [in] */ const WCHAR *fileName,
    /* [in] */ const WCHAR *searchPath,
    /* [retval][out] */ ISymUnmanagedReader **pRetVal);


void __RPC_STUB ISymUnmanagedBinder_GetReaderForFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedBinder_GetReaderFromStream_Proxy( 
    ISymUnmanagedBinder * This,
    /* [in] */ IUnknown *importer,
    /* [in] */ IStream *pstream,
    /* [retval][out] */ ISymUnmanagedReader **pRetVal);


void __RPC_STUB ISymUnmanagedBinder_GetReaderFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedBinder_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_corsym_0115 */
/* [local] */ 

typedef 
enum CorSymSearchPolicyAttributes
    {	AllowRegistryAccess	= 0x1,
	AllowSymbolServerAccess	= 0x2,
	AllowOriginalPathAccess	= 0x4,
	AllowReferencePathAccess	= 0x8
    } 	CorSymSearchPolicyAttributes;



extern RPC_IF_HANDLE __MIDL_itf_corsym_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corsym_0115_v0_0_s_ifspec;

#ifndef __ISymUnmanagedBinder2_INTERFACE_DEFINED__
#define __ISymUnmanagedBinder2_INTERFACE_DEFINED__

/* interface ISymUnmanagedBinder2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedBinder2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ACCEE350-89AF-4ccb-8B40-1C2C4C6F9434")
    ISymUnmanagedBinder2 : public ISymUnmanagedBinder
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReaderForFile2( 
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [in] */ ULONG32 searchPolicy,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedBinder2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedBinder2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedBinder2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedBinder2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderForFile )( 
            ISymUnmanagedBinder2 * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderFromStream )( 
            ISymUnmanagedBinder2 * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ IStream *pstream,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderForFile2 )( 
            ISymUnmanagedBinder2 * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [in] */ ULONG32 searchPolicy,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        END_INTERFACE
    } ISymUnmanagedBinder2Vtbl;

    interface ISymUnmanagedBinder2
    {
        CONST_VTBL struct ISymUnmanagedBinder2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedBinder2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedBinder2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedBinder2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedBinder2_GetReaderForFile(This,importer,fileName,searchPath,pRetVal)	\
    (This)->lpVtbl -> GetReaderForFile(This,importer,fileName,searchPath,pRetVal)

#define ISymUnmanagedBinder2_GetReaderFromStream(This,importer,pstream,pRetVal)	\
    (This)->lpVtbl -> GetReaderFromStream(This,importer,pstream,pRetVal)


#define ISymUnmanagedBinder2_GetReaderForFile2(This,importer,fileName,searchPath,searchPolicy,pRetVal)	\
    (This)->lpVtbl -> GetReaderForFile2(This,importer,fileName,searchPath,searchPolicy,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedBinder2_GetReaderForFile2_Proxy( 
    ISymUnmanagedBinder2 * This,
    /* [in] */ IUnknown *importer,
    /* [in] */ const WCHAR *fileName,
    /* [in] */ const WCHAR *searchPath,
    /* [in] */ ULONG32 searchPolicy,
    /* [retval][out] */ ISymUnmanagedReader **pRetVal);


void __RPC_STUB ISymUnmanagedBinder2_GetReaderForFile2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedBinder2_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedBinder3_INTERFACE_DEFINED__
#define __ISymUnmanagedBinder3_INTERFACE_DEFINED__

/* interface ISymUnmanagedBinder3 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedBinder3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28AD3D43-B601-4d26-8A1B-25F9165AF9D7")
    ISymUnmanagedBinder3 : public ISymUnmanagedBinder2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReaderFromCallback( 
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [in] */ ULONG32 searchPolicy,
            /* [in] */ IUnknown *callback,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedBinder3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedBinder3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedBinder3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedBinder3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderForFile )( 
            ISymUnmanagedBinder3 * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderFromStream )( 
            ISymUnmanagedBinder3 * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ IStream *pstream,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderForFile2 )( 
            ISymUnmanagedBinder3 * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [in] */ ULONG32 searchPolicy,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetReaderFromCallback )( 
            ISymUnmanagedBinder3 * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *fileName,
            /* [in] */ const WCHAR *searchPath,
            /* [in] */ ULONG32 searchPolicy,
            /* [in] */ IUnknown *callback,
            /* [retval][out] */ ISymUnmanagedReader **pRetVal);
        
        END_INTERFACE
    } ISymUnmanagedBinder3Vtbl;

    interface ISymUnmanagedBinder3
    {
        CONST_VTBL struct ISymUnmanagedBinder3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedBinder3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedBinder3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedBinder3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedBinder3_GetReaderForFile(This,importer,fileName,searchPath,pRetVal)	\
    (This)->lpVtbl -> GetReaderForFile(This,importer,fileName,searchPath,pRetVal)

#define ISymUnmanagedBinder3_GetReaderFromStream(This,importer,pstream,pRetVal)	\
    (This)->lpVtbl -> GetReaderFromStream(This,importer,pstream,pRetVal)


#define ISymUnmanagedBinder3_GetReaderForFile2(This,importer,fileName,searchPath,searchPolicy,pRetVal)	\
    (This)->lpVtbl -> GetReaderForFile2(This,importer,fileName,searchPath,searchPolicy,pRetVal)


#define ISymUnmanagedBinder3_GetReaderFromCallback(This,importer,fileName,searchPath,searchPolicy,callback,pRetVal)	\
    (This)->lpVtbl -> GetReaderFromCallback(This,importer,fileName,searchPath,searchPolicy,callback,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedBinder3_GetReaderFromCallback_Proxy( 
    ISymUnmanagedBinder3 * This,
    /* [in] */ IUnknown *importer,
    /* [in] */ const WCHAR *fileName,
    /* [in] */ const WCHAR *searchPath,
    /* [in] */ ULONG32 searchPolicy,
    /* [in] */ IUnknown *callback,
    /* [retval][out] */ ISymUnmanagedReader **pRetVal);


void __RPC_STUB ISymUnmanagedBinder3_GetReaderFromCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedBinder3_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_corsym_0117 */
/* [local] */ 

static const int E_SYM_DESTROYED = MAKE_HRESULT(1, FACILITY_ITF, 0xdead);


extern RPC_IF_HANDLE __MIDL_itf_corsym_0117_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corsym_0117_v0_0_s_ifspec;

#ifndef __ISymUnmanagedDispose_INTERFACE_DEFINED__
#define __ISymUnmanagedDispose_INTERFACE_DEFINED__

/* interface ISymUnmanagedDispose */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedDispose;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("969708D2-05E5-4861-A3B0-96E473CDF63F")
    ISymUnmanagedDispose : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Destroy( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedDisposeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedDispose * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedDispose * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedDispose * This);
        
        HRESULT ( STDMETHODCALLTYPE *Destroy )( 
            ISymUnmanagedDispose * This);
        
        END_INTERFACE
    } ISymUnmanagedDisposeVtbl;

    interface ISymUnmanagedDispose
    {
        CONST_VTBL struct ISymUnmanagedDisposeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedDispose_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedDispose_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedDispose_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedDispose_Destroy(This)	\
    (This)->lpVtbl -> Destroy(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedDispose_Destroy_Proxy( 
    ISymUnmanagedDispose * This);


void __RPC_STUB ISymUnmanagedDispose_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedDispose_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedDocument_INTERFACE_DEFINED__
#define __ISymUnmanagedDocument_INTERFACE_DEFINED__

/* interface ISymUnmanagedDocument */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("40DE4037-7C81-3E1E-B022-AE1ABFF2CA08")
    ISymUnmanagedDocument : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [in] */ ULONG32 cchUrl,
            /* [out] */ ULONG32 *pcchUrl,
            /* [length_is][size_is][out] */ WCHAR szUrl[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentType( 
            /* [retval][out] */ GUID *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguage( 
            /* [retval][out] */ GUID *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLanguageVendor( 
            /* [retval][out] */ GUID *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCheckSumAlgorithmId( 
            /* [retval][out] */ GUID *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCheckSum( 
            /* [in] */ ULONG32 cData,
            /* [out] */ ULONG32 *pcData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FindClosestLine( 
            /* [in] */ ULONG32 line,
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HasEmbeddedSource( 
            /* [retval][out] */ BOOL *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceLength( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceRange( 
            /* [in] */ ULONG32 startLine,
            /* [in] */ ULONG32 startColumn,
            /* [in] */ ULONG32 endLine,
            /* [in] */ ULONG32 endColumn,
            /* [in] */ ULONG32 cSourceBytes,
            /* [out] */ ULONG32 *pcSourceBytes,
            /* [length_is][size_is][out] */ BYTE source[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedDocumentVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedDocument * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedDocument * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedDocument * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetURL )( 
            ISymUnmanagedDocument * This,
            /* [in] */ ULONG32 cchUrl,
            /* [out] */ ULONG32 *pcchUrl,
            /* [length_is][size_is][out] */ WCHAR szUrl[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentType )( 
            ISymUnmanagedDocument * This,
            /* [retval][out] */ GUID *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguage )( 
            ISymUnmanagedDocument * This,
            /* [retval][out] */ GUID *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLanguageVendor )( 
            ISymUnmanagedDocument * This,
            /* [retval][out] */ GUID *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCheckSumAlgorithmId )( 
            ISymUnmanagedDocument * This,
            /* [retval][out] */ GUID *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetCheckSum )( 
            ISymUnmanagedDocument * This,
            /* [in] */ ULONG32 cData,
            /* [out] */ ULONG32 *pcData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *FindClosestLine )( 
            ISymUnmanagedDocument * This,
            /* [in] */ ULONG32 line,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *HasEmbeddedSource )( 
            ISymUnmanagedDocument * This,
            /* [retval][out] */ BOOL *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceLength )( 
            ISymUnmanagedDocument * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceRange )( 
            ISymUnmanagedDocument * This,
            /* [in] */ ULONG32 startLine,
            /* [in] */ ULONG32 startColumn,
            /* [in] */ ULONG32 endLine,
            /* [in] */ ULONG32 endColumn,
            /* [in] */ ULONG32 cSourceBytes,
            /* [out] */ ULONG32 *pcSourceBytes,
            /* [length_is][size_is][out] */ BYTE source[  ]);
        
        END_INTERFACE
    } ISymUnmanagedDocumentVtbl;

    interface ISymUnmanagedDocument
    {
        CONST_VTBL struct ISymUnmanagedDocumentVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedDocument_GetURL(This,cchUrl,pcchUrl,szUrl)	\
    (This)->lpVtbl -> GetURL(This,cchUrl,pcchUrl,szUrl)

#define ISymUnmanagedDocument_GetDocumentType(This,pRetVal)	\
    (This)->lpVtbl -> GetDocumentType(This,pRetVal)

#define ISymUnmanagedDocument_GetLanguage(This,pRetVal)	\
    (This)->lpVtbl -> GetLanguage(This,pRetVal)

#define ISymUnmanagedDocument_GetLanguageVendor(This,pRetVal)	\
    (This)->lpVtbl -> GetLanguageVendor(This,pRetVal)

#define ISymUnmanagedDocument_GetCheckSumAlgorithmId(This,pRetVal)	\
    (This)->lpVtbl -> GetCheckSumAlgorithmId(This,pRetVal)

#define ISymUnmanagedDocument_GetCheckSum(This,cData,pcData,data)	\
    (This)->lpVtbl -> GetCheckSum(This,cData,pcData,data)

#define ISymUnmanagedDocument_FindClosestLine(This,line,pRetVal)	\
    (This)->lpVtbl -> FindClosestLine(This,line,pRetVal)

#define ISymUnmanagedDocument_HasEmbeddedSource(This,pRetVal)	\
    (This)->lpVtbl -> HasEmbeddedSource(This,pRetVal)

#define ISymUnmanagedDocument_GetSourceLength(This,pRetVal)	\
    (This)->lpVtbl -> GetSourceLength(This,pRetVal)

#define ISymUnmanagedDocument_GetSourceRange(This,startLine,startColumn,endLine,endColumn,cSourceBytes,pcSourceBytes,source)	\
    (This)->lpVtbl -> GetSourceRange(This,startLine,startColumn,endLine,endColumn,cSourceBytes,pcSourceBytes,source)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetURL_Proxy( 
    ISymUnmanagedDocument * This,
    /* [in] */ ULONG32 cchUrl,
    /* [out] */ ULONG32 *pcchUrl,
    /* [length_is][size_is][out] */ WCHAR szUrl[  ]);


void __RPC_STUB ISymUnmanagedDocument_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetDocumentType_Proxy( 
    ISymUnmanagedDocument * This,
    /* [retval][out] */ GUID *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_GetDocumentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetLanguage_Proxy( 
    ISymUnmanagedDocument * This,
    /* [retval][out] */ GUID *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_GetLanguage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetLanguageVendor_Proxy( 
    ISymUnmanagedDocument * This,
    /* [retval][out] */ GUID *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_GetLanguageVendor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetCheckSumAlgorithmId_Proxy( 
    ISymUnmanagedDocument * This,
    /* [retval][out] */ GUID *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_GetCheckSumAlgorithmId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetCheckSum_Proxy( 
    ISymUnmanagedDocument * This,
    /* [in] */ ULONG32 cData,
    /* [out] */ ULONG32 *pcData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB ISymUnmanagedDocument_GetCheckSum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_FindClosestLine_Proxy( 
    ISymUnmanagedDocument * This,
    /* [in] */ ULONG32 line,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_FindClosestLine_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_HasEmbeddedSource_Proxy( 
    ISymUnmanagedDocument * This,
    /* [retval][out] */ BOOL *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_HasEmbeddedSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetSourceLength_Proxy( 
    ISymUnmanagedDocument * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedDocument_GetSourceLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocument_GetSourceRange_Proxy( 
    ISymUnmanagedDocument * This,
    /* [in] */ ULONG32 startLine,
    /* [in] */ ULONG32 startColumn,
    /* [in] */ ULONG32 endLine,
    /* [in] */ ULONG32 endColumn,
    /* [in] */ ULONG32 cSourceBytes,
    /* [out] */ ULONG32 *pcSourceBytes,
    /* [length_is][size_is][out] */ BYTE source[  ]);


void __RPC_STUB ISymUnmanagedDocument_GetSourceRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedDocument_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedDocumentWriter_INTERFACE_DEFINED__
#define __ISymUnmanagedDocumentWriter_INTERFACE_DEFINED__

/* interface ISymUnmanagedDocumentWriter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedDocumentWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006")
    ISymUnmanagedDocumentWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetSource( 
            /* [in] */ ULONG32 sourceSize,
            /* [size_is][in] */ BYTE source[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCheckSum( 
            /* [in] */ GUID algorithmId,
            /* [in] */ ULONG32 checkSumSize,
            /* [size_is][in] */ BYTE checkSum[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedDocumentWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedDocumentWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedDocumentWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedDocumentWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSource )( 
            ISymUnmanagedDocumentWriter * This,
            /* [in] */ ULONG32 sourceSize,
            /* [size_is][in] */ BYTE source[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *SetCheckSum )( 
            ISymUnmanagedDocumentWriter * This,
            /* [in] */ GUID algorithmId,
            /* [in] */ ULONG32 checkSumSize,
            /* [size_is][in] */ BYTE checkSum[  ]);
        
        END_INTERFACE
    } ISymUnmanagedDocumentWriterVtbl;

    interface ISymUnmanagedDocumentWriter
    {
        CONST_VTBL struct ISymUnmanagedDocumentWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedDocumentWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedDocumentWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedDocumentWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedDocumentWriter_SetSource(This,sourceSize,source)	\
    (This)->lpVtbl -> SetSource(This,sourceSize,source)

#define ISymUnmanagedDocumentWriter_SetCheckSum(This,algorithmId,checkSumSize,checkSum)	\
    (This)->lpVtbl -> SetCheckSum(This,algorithmId,checkSumSize,checkSum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedDocumentWriter_SetSource_Proxy( 
    ISymUnmanagedDocumentWriter * This,
    /* [in] */ ULONG32 sourceSize,
    /* [size_is][in] */ BYTE source[  ]);


void __RPC_STUB ISymUnmanagedDocumentWriter_SetSource_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedDocumentWriter_SetCheckSum_Proxy( 
    ISymUnmanagedDocumentWriter * This,
    /* [in] */ GUID algorithmId,
    /* [in] */ ULONG32 checkSumSize,
    /* [size_is][in] */ BYTE checkSum[  ]);


void __RPC_STUB ISymUnmanagedDocumentWriter_SetCheckSum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedDocumentWriter_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedMethod_INTERFACE_DEFINED__
#define __ISymUnmanagedMethod_INTERFACE_DEFINED__

/* interface ISymUnmanagedMethod */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedMethod;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B62B923C-B500-3158-A543-24F307A8B7E1")
    ISymUnmanagedMethod : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetToken( 
            /* [retval][out] */ mdMethodDef *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSequencePointCount( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootScope( 
            /* [retval][out] */ ISymUnmanagedScope **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetScopeFromOffset( 
            /* [in] */ ULONG32 offset,
            /* [retval][out] */ ISymUnmanagedScope **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOffset( 
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRanges( 
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [in] */ ULONG32 cRanges,
            /* [out] */ ULONG32 *pcRanges,
            /* [length_is][size_is][out] */ ULONG32 ranges[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParameters( 
            /* [in] */ ULONG32 cParams,
            /* [out] */ ULONG32 *pcParams,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *params[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespace( 
            /* [out] */ ISymUnmanagedNamespace **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceStartEnd( 
            /* [in] */ ISymUnmanagedDocument *docs[ 2 ],
            /* [in] */ ULONG32 lines[ 2 ],
            /* [in] */ ULONG32 columns[ 2 ],
            /* [out] */ BOOL *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSequencePoints( 
            /* [in] */ ULONG32 cPoints,
            /* [out] */ ULONG32 *pcPoints,
            /* [size_is][in] */ ULONG32 offsets[  ],
            /* [size_is][in] */ ISymUnmanagedDocument *documents[  ],
            /* [size_is][in] */ ULONG32 lines[  ],
            /* [size_is][in] */ ULONG32 columns[  ],
            /* [size_is][in] */ ULONG32 endLines[  ],
            /* [size_is][in] */ ULONG32 endColumns[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedMethodVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedMethod * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedMethod * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedMethod * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetToken )( 
            ISymUnmanagedMethod * This,
            /* [retval][out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetSequencePointCount )( 
            ISymUnmanagedMethod * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRootScope )( 
            ISymUnmanagedMethod * This,
            /* [retval][out] */ ISymUnmanagedScope **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetScopeFromOffset )( 
            ISymUnmanagedMethod * This,
            /* [in] */ ULONG32 offset,
            /* [retval][out] */ ISymUnmanagedScope **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetOffset )( 
            ISymUnmanagedMethod * This,
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetRanges )( 
            ISymUnmanagedMethod * This,
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [in] */ ULONG32 cRanges,
            /* [out] */ ULONG32 *pcRanges,
            /* [length_is][size_is][out] */ ULONG32 ranges[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetParameters )( 
            ISymUnmanagedMethod * This,
            /* [in] */ ULONG32 cParams,
            /* [out] */ ULONG32 *pcParams,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *params[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespace )( 
            ISymUnmanagedMethod * This,
            /* [out] */ ISymUnmanagedNamespace **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceStartEnd )( 
            ISymUnmanagedMethod * This,
            /* [in] */ ISymUnmanagedDocument *docs[ 2 ],
            /* [in] */ ULONG32 lines[ 2 ],
            /* [in] */ ULONG32 columns[ 2 ],
            /* [out] */ BOOL *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSequencePoints )( 
            ISymUnmanagedMethod * This,
            /* [in] */ ULONG32 cPoints,
            /* [out] */ ULONG32 *pcPoints,
            /* [size_is][in] */ ULONG32 offsets[  ],
            /* [size_is][in] */ ISymUnmanagedDocument *documents[  ],
            /* [size_is][in] */ ULONG32 lines[  ],
            /* [size_is][in] */ ULONG32 columns[  ],
            /* [size_is][in] */ ULONG32 endLines[  ],
            /* [size_is][in] */ ULONG32 endColumns[  ]);
        
        END_INTERFACE
    } ISymUnmanagedMethodVtbl;

    interface ISymUnmanagedMethod
    {
        CONST_VTBL struct ISymUnmanagedMethodVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedMethod_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedMethod_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedMethod_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedMethod_GetToken(This,pToken)	\
    (This)->lpVtbl -> GetToken(This,pToken)

#define ISymUnmanagedMethod_GetSequencePointCount(This,pRetVal)	\
    (This)->lpVtbl -> GetSequencePointCount(This,pRetVal)

#define ISymUnmanagedMethod_GetRootScope(This,pRetVal)	\
    (This)->lpVtbl -> GetRootScope(This,pRetVal)

#define ISymUnmanagedMethod_GetScopeFromOffset(This,offset,pRetVal)	\
    (This)->lpVtbl -> GetScopeFromOffset(This,offset,pRetVal)

#define ISymUnmanagedMethod_GetOffset(This,document,line,column,pRetVal)	\
    (This)->lpVtbl -> GetOffset(This,document,line,column,pRetVal)

#define ISymUnmanagedMethod_GetRanges(This,document,line,column,cRanges,pcRanges,ranges)	\
    (This)->lpVtbl -> GetRanges(This,document,line,column,cRanges,pcRanges,ranges)

#define ISymUnmanagedMethod_GetParameters(This,cParams,pcParams,params)	\
    (This)->lpVtbl -> GetParameters(This,cParams,pcParams,params)

#define ISymUnmanagedMethod_GetNamespace(This,pRetVal)	\
    (This)->lpVtbl -> GetNamespace(This,pRetVal)

#define ISymUnmanagedMethod_GetSourceStartEnd(This,docs,lines,columns,pRetVal)	\
    (This)->lpVtbl -> GetSourceStartEnd(This,docs,lines,columns,pRetVal)

#define ISymUnmanagedMethod_GetSequencePoints(This,cPoints,pcPoints,offsets,documents,lines,columns,endLines,endColumns)	\
    (This)->lpVtbl -> GetSequencePoints(This,cPoints,pcPoints,offsets,documents,lines,columns,endLines,endColumns)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetToken_Proxy( 
    ISymUnmanagedMethod * This,
    /* [retval][out] */ mdMethodDef *pToken);


void __RPC_STUB ISymUnmanagedMethod_GetToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetSequencePointCount_Proxy( 
    ISymUnmanagedMethod * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedMethod_GetSequencePointCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetRootScope_Proxy( 
    ISymUnmanagedMethod * This,
    /* [retval][out] */ ISymUnmanagedScope **pRetVal);


void __RPC_STUB ISymUnmanagedMethod_GetRootScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetScopeFromOffset_Proxy( 
    ISymUnmanagedMethod * This,
    /* [in] */ ULONG32 offset,
    /* [retval][out] */ ISymUnmanagedScope **pRetVal);


void __RPC_STUB ISymUnmanagedMethod_GetScopeFromOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetOffset_Proxy( 
    ISymUnmanagedMethod * This,
    /* [in] */ ISymUnmanagedDocument *document,
    /* [in] */ ULONG32 line,
    /* [in] */ ULONG32 column,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedMethod_GetOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetRanges_Proxy( 
    ISymUnmanagedMethod * This,
    /* [in] */ ISymUnmanagedDocument *document,
    /* [in] */ ULONG32 line,
    /* [in] */ ULONG32 column,
    /* [in] */ ULONG32 cRanges,
    /* [out] */ ULONG32 *pcRanges,
    /* [length_is][size_is][out] */ ULONG32 ranges[  ]);


void __RPC_STUB ISymUnmanagedMethod_GetRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetParameters_Proxy( 
    ISymUnmanagedMethod * This,
    /* [in] */ ULONG32 cParams,
    /* [out] */ ULONG32 *pcParams,
    /* [length_is][size_is][out] */ ISymUnmanagedVariable *params[  ]);


void __RPC_STUB ISymUnmanagedMethod_GetParameters_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetNamespace_Proxy( 
    ISymUnmanagedMethod * This,
    /* [out] */ ISymUnmanagedNamespace **pRetVal);


void __RPC_STUB ISymUnmanagedMethod_GetNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetSourceStartEnd_Proxy( 
    ISymUnmanagedMethod * This,
    /* [in] */ ISymUnmanagedDocument *docs[ 2 ],
    /* [in] */ ULONG32 lines[ 2 ],
    /* [in] */ ULONG32 columns[ 2 ],
    /* [out] */ BOOL *pRetVal);


void __RPC_STUB ISymUnmanagedMethod_GetSourceStartEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedMethod_GetSequencePoints_Proxy( 
    ISymUnmanagedMethod * This,
    /* [in] */ ULONG32 cPoints,
    /* [out] */ ULONG32 *pcPoints,
    /* [size_is][in] */ ULONG32 offsets[  ],
    /* [size_is][in] */ ISymUnmanagedDocument *documents[  ],
    /* [size_is][in] */ ULONG32 lines[  ],
    /* [size_is][in] */ ULONG32 columns[  ],
    /* [size_is][in] */ ULONG32 endLines[  ],
    /* [size_is][in] */ ULONG32 endColumns[  ]);


void __RPC_STUB ISymUnmanagedMethod_GetSequencePoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedMethod_INTERFACE_DEFINED__ */


#ifndef __ISymENCUnmanagedMethod_INTERFACE_DEFINED__
#define __ISymENCUnmanagedMethod_INTERFACE_DEFINED__

/* interface ISymENCUnmanagedMethod */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymENCUnmanagedMethod;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("85E891DA-A631-4c76-ACA2-A44A39C46B8C")
    ISymENCUnmanagedMethod : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetFileNameFromOffset( 
            /* [in] */ ULONG32 dwOffset,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineFromOffset( 
            /* [in] */ ULONG32 dwOffset,
            /* [out] */ ULONG32 *pline,
            /* [out] */ ULONG32 *pcolumn,
            /* [out] */ ULONG32 *pendLine,
            /* [out] */ ULONG32 *pendColumn,
            /* [out] */ ULONG32 *pdwStartOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentsForMethodCount( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentsForMethod( 
            /* [in] */ ULONG32 cDocs,
            /* [out] */ ULONG32 *pcDocs,
            /* [size_is][in] */ ISymUnmanagedDocument *documents[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSourceExtentInDocument( 
            /* [in] */ ISymUnmanagedDocument *document,
            /* [out] */ ULONG32 *pstartLine,
            /* [out] */ ULONG32 *pendLine) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymENCUnmanagedMethodVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymENCUnmanagedMethod * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymENCUnmanagedMethod * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymENCUnmanagedMethod * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileNameFromOffset )( 
            ISymENCUnmanagedMethod * This,
            /* [in] */ ULONG32 dwOffset,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetLineFromOffset )( 
            ISymENCUnmanagedMethod * This,
            /* [in] */ ULONG32 dwOffset,
            /* [out] */ ULONG32 *pline,
            /* [out] */ ULONG32 *pcolumn,
            /* [out] */ ULONG32 *pendLine,
            /* [out] */ ULONG32 *pendColumn,
            /* [out] */ ULONG32 *pdwStartOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentsForMethodCount )( 
            ISymENCUnmanagedMethod * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentsForMethod )( 
            ISymENCUnmanagedMethod * This,
            /* [in] */ ULONG32 cDocs,
            /* [out] */ ULONG32 *pcDocs,
            /* [size_is][in] */ ISymUnmanagedDocument *documents[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceExtentInDocument )( 
            ISymENCUnmanagedMethod * This,
            /* [in] */ ISymUnmanagedDocument *document,
            /* [out] */ ULONG32 *pstartLine,
            /* [out] */ ULONG32 *pendLine);
        
        END_INTERFACE
    } ISymENCUnmanagedMethodVtbl;

    interface ISymENCUnmanagedMethod
    {
        CONST_VTBL struct ISymENCUnmanagedMethodVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymENCUnmanagedMethod_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymENCUnmanagedMethod_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymENCUnmanagedMethod_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymENCUnmanagedMethod_GetFileNameFromOffset(This,dwOffset,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetFileNameFromOffset(This,dwOffset,cchName,pcchName,szName)

#define ISymENCUnmanagedMethod_GetLineFromOffset(This,dwOffset,pline,pcolumn,pendLine,pendColumn,pdwStartOffset)	\
    (This)->lpVtbl -> GetLineFromOffset(This,dwOffset,pline,pcolumn,pendLine,pendColumn,pdwStartOffset)

#define ISymENCUnmanagedMethod_GetDocumentsForMethodCount(This,pRetVal)	\
    (This)->lpVtbl -> GetDocumentsForMethodCount(This,pRetVal)

#define ISymENCUnmanagedMethod_GetDocumentsForMethod(This,cDocs,pcDocs,documents)	\
    (This)->lpVtbl -> GetDocumentsForMethod(This,cDocs,pcDocs,documents)

#define ISymENCUnmanagedMethod_GetSourceExtentInDocument(This,document,pstartLine,pendLine)	\
    (This)->lpVtbl -> GetSourceExtentInDocument(This,document,pstartLine,pendLine)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymENCUnmanagedMethod_GetFileNameFromOffset_Proxy( 
    ISymENCUnmanagedMethod * This,
    /* [in] */ ULONG32 dwOffset,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ISymENCUnmanagedMethod_GetFileNameFromOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymENCUnmanagedMethod_GetLineFromOffset_Proxy( 
    ISymENCUnmanagedMethod * This,
    /* [in] */ ULONG32 dwOffset,
    /* [out] */ ULONG32 *pline,
    /* [out] */ ULONG32 *pcolumn,
    /* [out] */ ULONG32 *pendLine,
    /* [out] */ ULONG32 *pendColumn,
    /* [out] */ ULONG32 *pdwStartOffset);


void __RPC_STUB ISymENCUnmanagedMethod_GetLineFromOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymENCUnmanagedMethod_GetDocumentsForMethodCount_Proxy( 
    ISymENCUnmanagedMethod * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymENCUnmanagedMethod_GetDocumentsForMethodCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymENCUnmanagedMethod_GetDocumentsForMethod_Proxy( 
    ISymENCUnmanagedMethod * This,
    /* [in] */ ULONG32 cDocs,
    /* [out] */ ULONG32 *pcDocs,
    /* [size_is][in] */ ISymUnmanagedDocument *documents[  ]);


void __RPC_STUB ISymENCUnmanagedMethod_GetDocumentsForMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymENCUnmanagedMethod_GetSourceExtentInDocument_Proxy( 
    ISymENCUnmanagedMethod * This,
    /* [in] */ ISymUnmanagedDocument *document,
    /* [out] */ ULONG32 *pstartLine,
    /* [out] */ ULONG32 *pendLine);


void __RPC_STUB ISymENCUnmanagedMethod_GetSourceExtentInDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymENCUnmanagedMethod_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedNamespace_INTERFACE_DEFINED__
#define __ISymUnmanagedNamespace_INTERFACE_DEFINED__

/* interface ISymUnmanagedNamespace */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedNamespace;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0DFF7289-54F8-11d3-BD28-0000F80849BD")
    ISymUnmanagedNamespace : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaces( 
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVariables( 
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedNamespaceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedNamespace * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedNamespace * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedNamespace * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ISymUnmanagedNamespace * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespaces )( 
            ISymUnmanagedNamespace * This,
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetVariables )( 
            ISymUnmanagedNamespace * This,
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);
        
        END_INTERFACE
    } ISymUnmanagedNamespaceVtbl;

    interface ISymUnmanagedNamespace
    {
        CONST_VTBL struct ISymUnmanagedNamespaceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedNamespace_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedNamespace_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedNamespace_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedNamespace_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ISymUnmanagedNamespace_GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)	\
    (This)->lpVtbl -> GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)

#define ISymUnmanagedNamespace_GetVariables(This,cVars,pcVars,pVars)	\
    (This)->lpVtbl -> GetVariables(This,cVars,pcVars,pVars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedNamespace_GetName_Proxy( 
    ISymUnmanagedNamespace * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ISymUnmanagedNamespace_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedNamespace_GetNamespaces_Proxy( 
    ISymUnmanagedNamespace * This,
    /* [in] */ ULONG32 cNameSpaces,
    /* [out] */ ULONG32 *pcNameSpaces,
    /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);


void __RPC_STUB ISymUnmanagedNamespace_GetNamespaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedNamespace_GetVariables_Proxy( 
    ISymUnmanagedNamespace * This,
    /* [in] */ ULONG32 cVars,
    /* [out] */ ULONG32 *pcVars,
    /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);


void __RPC_STUB ISymUnmanagedNamespace_GetVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedNamespace_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedReader_INTERFACE_DEFINED__
#define __ISymUnmanagedReader_INTERFACE_DEFINED__

/* interface ISymUnmanagedReader */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedReader;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B4CE6286-2A6B-3712-A3B7-1EE1DAD467B5")
    ISymUnmanagedReader : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDocument( 
            /* [in] */ WCHAR *url,
            /* [in] */ GUID language,
            /* [in] */ GUID languageVendor,
            /* [in] */ GUID documentType,
            /* [retval][out] */ ISymUnmanagedDocument **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocuments( 
            /* [in] */ ULONG32 cDocs,
            /* [out] */ ULONG32 *pcDocs,
            /* [length_is][size_is][out] */ ISymUnmanagedDocument *pDocs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUserEntryPoint( 
            /* [retval][out] */ mdMethodDef *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethod( 
            /* [in] */ mdMethodDef token,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodByVersion( 
            /* [in] */ mdMethodDef token,
            /* [in] */ int version,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVariables( 
            /* [in] */ mdToken parent,
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGlobalVariables( 
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodFromDocumentPosition( 
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymAttribute( 
            /* [in] */ mdToken parent,
            /* [in] */ WCHAR *name,
            /* [in] */ ULONG32 cBuffer,
            /* [out] */ ULONG32 *pcBuffer,
            /* [length_is][size_is][out] */ BYTE buffer[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaces( 
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *filename,
            /* [in] */ const WCHAR *searchPath,
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateSymbolStore( 
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReplaceSymbolStore( 
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymbolStoreFileName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodsFromDocumentPosition( 
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [in] */ ULONG32 cMethod,
            /* [out] */ ULONG32 *pcMethod,
            /* [length_is][size_is][out] */ ISymUnmanagedMethod *pRetVal[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDocumentVersion( 
            /* [in] */ ISymUnmanagedDocument *pDoc,
            /* [out] */ int *version,
            /* [out] */ BOOL *pbCurrent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodVersion( 
            /* [in] */ ISymUnmanagedMethod *pMethod,
            /* [out] */ int *version) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedReaderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedReader * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedReader * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedReader * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            ISymUnmanagedReader * This,
            /* [in] */ WCHAR *url,
            /* [in] */ GUID language,
            /* [in] */ GUID languageVendor,
            /* [in] */ GUID documentType,
            /* [retval][out] */ ISymUnmanagedDocument **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocuments )( 
            ISymUnmanagedReader * This,
            /* [in] */ ULONG32 cDocs,
            /* [out] */ ULONG32 *pcDocs,
            /* [length_is][size_is][out] */ ISymUnmanagedDocument *pDocs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserEntryPoint )( 
            ISymUnmanagedReader * This,
            /* [retval][out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            ISymUnmanagedReader * This,
            /* [in] */ mdMethodDef token,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodByVersion )( 
            ISymUnmanagedReader * This,
            /* [in] */ mdMethodDef token,
            /* [in] */ int version,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetVariables )( 
            ISymUnmanagedReader * This,
            /* [in] */ mdToken parent,
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalVariables )( 
            ISymUnmanagedReader * This,
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodFromDocumentPosition )( 
            ISymUnmanagedReader * This,
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymAttribute )( 
            ISymUnmanagedReader * This,
            /* [in] */ mdToken parent,
            /* [in] */ WCHAR *name,
            /* [in] */ ULONG32 cBuffer,
            /* [out] */ ULONG32 *pcBuffer,
            /* [length_is][size_is][out] */ BYTE buffer[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespaces )( 
            ISymUnmanagedReader * This,
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISymUnmanagedReader * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *filename,
            /* [in] */ const WCHAR *searchPath,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateSymbolStore )( 
            ISymUnmanagedReader * This,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *ReplaceSymbolStore )( 
            ISymUnmanagedReader * This,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymbolStoreFileName )( 
            ISymUnmanagedReader * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodsFromDocumentPosition )( 
            ISymUnmanagedReader * This,
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [in] */ ULONG32 cMethod,
            /* [out] */ ULONG32 *pcMethod,
            /* [length_is][size_is][out] */ ISymUnmanagedMethod *pRetVal[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentVersion )( 
            ISymUnmanagedReader * This,
            /* [in] */ ISymUnmanagedDocument *pDoc,
            /* [out] */ int *version,
            /* [out] */ BOOL *pbCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodVersion )( 
            ISymUnmanagedReader * This,
            /* [in] */ ISymUnmanagedMethod *pMethod,
            /* [out] */ int *version);
        
        END_INTERFACE
    } ISymUnmanagedReaderVtbl;

    interface ISymUnmanagedReader
    {
        CONST_VTBL struct ISymUnmanagedReaderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedReader_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedReader_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedReader_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedReader_GetDocument(This,url,language,languageVendor,documentType,pRetVal)	\
    (This)->lpVtbl -> GetDocument(This,url,language,languageVendor,documentType,pRetVal)

#define ISymUnmanagedReader_GetDocuments(This,cDocs,pcDocs,pDocs)	\
    (This)->lpVtbl -> GetDocuments(This,cDocs,pcDocs,pDocs)

#define ISymUnmanagedReader_GetUserEntryPoint(This,pToken)	\
    (This)->lpVtbl -> GetUserEntryPoint(This,pToken)

#define ISymUnmanagedReader_GetMethod(This,token,pRetVal)	\
    (This)->lpVtbl -> GetMethod(This,token,pRetVal)

#define ISymUnmanagedReader_GetMethodByVersion(This,token,version,pRetVal)	\
    (This)->lpVtbl -> GetMethodByVersion(This,token,version,pRetVal)

#define ISymUnmanagedReader_GetVariables(This,parent,cVars,pcVars,pVars)	\
    (This)->lpVtbl -> GetVariables(This,parent,cVars,pcVars,pVars)

#define ISymUnmanagedReader_GetGlobalVariables(This,cVars,pcVars,pVars)	\
    (This)->lpVtbl -> GetGlobalVariables(This,cVars,pcVars,pVars)

#define ISymUnmanagedReader_GetMethodFromDocumentPosition(This,document,line,column,pRetVal)	\
    (This)->lpVtbl -> GetMethodFromDocumentPosition(This,document,line,column,pRetVal)

#define ISymUnmanagedReader_GetSymAttribute(This,parent,name,cBuffer,pcBuffer,buffer)	\
    (This)->lpVtbl -> GetSymAttribute(This,parent,name,cBuffer,pcBuffer,buffer)

#define ISymUnmanagedReader_GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)	\
    (This)->lpVtbl -> GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)

#define ISymUnmanagedReader_Initialize(This,importer,filename,searchPath,pIStream)	\
    (This)->lpVtbl -> Initialize(This,importer,filename,searchPath,pIStream)

#define ISymUnmanagedReader_UpdateSymbolStore(This,filename,pIStream)	\
    (This)->lpVtbl -> UpdateSymbolStore(This,filename,pIStream)

#define ISymUnmanagedReader_ReplaceSymbolStore(This,filename,pIStream)	\
    (This)->lpVtbl -> ReplaceSymbolStore(This,filename,pIStream)

#define ISymUnmanagedReader_GetSymbolStoreFileName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetSymbolStoreFileName(This,cchName,pcchName,szName)

#define ISymUnmanagedReader_GetMethodsFromDocumentPosition(This,document,line,column,cMethod,pcMethod,pRetVal)	\
    (This)->lpVtbl -> GetMethodsFromDocumentPosition(This,document,line,column,cMethod,pcMethod,pRetVal)

#define ISymUnmanagedReader_GetDocumentVersion(This,pDoc,version,pbCurrent)	\
    (This)->lpVtbl -> GetDocumentVersion(This,pDoc,version,pbCurrent)

#define ISymUnmanagedReader_GetMethodVersion(This,pMethod,version)	\
    (This)->lpVtbl -> GetMethodVersion(This,pMethod,version)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetDocument_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ WCHAR *url,
    /* [in] */ GUID language,
    /* [in] */ GUID languageVendor,
    /* [in] */ GUID documentType,
    /* [retval][out] */ ISymUnmanagedDocument **pRetVal);


void __RPC_STUB ISymUnmanagedReader_GetDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetDocuments_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ULONG32 cDocs,
    /* [out] */ ULONG32 *pcDocs,
    /* [length_is][size_is][out] */ ISymUnmanagedDocument *pDocs[  ]);


void __RPC_STUB ISymUnmanagedReader_GetDocuments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetUserEntryPoint_Proxy( 
    ISymUnmanagedReader * This,
    /* [retval][out] */ mdMethodDef *pToken);


void __RPC_STUB ISymUnmanagedReader_GetUserEntryPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetMethod_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ mdMethodDef token,
    /* [retval][out] */ ISymUnmanagedMethod **pRetVal);


void __RPC_STUB ISymUnmanagedReader_GetMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetMethodByVersion_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ mdMethodDef token,
    /* [in] */ int version,
    /* [retval][out] */ ISymUnmanagedMethod **pRetVal);


void __RPC_STUB ISymUnmanagedReader_GetMethodByVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetVariables_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ mdToken parent,
    /* [in] */ ULONG32 cVars,
    /* [out] */ ULONG32 *pcVars,
    /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);


void __RPC_STUB ISymUnmanagedReader_GetVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetGlobalVariables_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ULONG32 cVars,
    /* [out] */ ULONG32 *pcVars,
    /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);


void __RPC_STUB ISymUnmanagedReader_GetGlobalVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetMethodFromDocumentPosition_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ISymUnmanagedDocument *document,
    /* [in] */ ULONG32 line,
    /* [in] */ ULONG32 column,
    /* [retval][out] */ ISymUnmanagedMethod **pRetVal);


void __RPC_STUB ISymUnmanagedReader_GetMethodFromDocumentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetSymAttribute_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ mdToken parent,
    /* [in] */ WCHAR *name,
    /* [in] */ ULONG32 cBuffer,
    /* [out] */ ULONG32 *pcBuffer,
    /* [length_is][size_is][out] */ BYTE buffer[  ]);


void __RPC_STUB ISymUnmanagedReader_GetSymAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetNamespaces_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ULONG32 cNameSpaces,
    /* [out] */ ULONG32 *pcNameSpaces,
    /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);


void __RPC_STUB ISymUnmanagedReader_GetNamespaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_Initialize_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ IUnknown *importer,
    /* [in] */ const WCHAR *filename,
    /* [in] */ const WCHAR *searchPath,
    /* [in] */ IStream *pIStream);


void __RPC_STUB ISymUnmanagedReader_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_UpdateSymbolStore_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ const WCHAR *filename,
    /* [in] */ IStream *pIStream);


void __RPC_STUB ISymUnmanagedReader_UpdateSymbolStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_ReplaceSymbolStore_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ const WCHAR *filename,
    /* [in] */ IStream *pIStream);


void __RPC_STUB ISymUnmanagedReader_ReplaceSymbolStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetSymbolStoreFileName_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ISymUnmanagedReader_GetSymbolStoreFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetMethodsFromDocumentPosition_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ISymUnmanagedDocument *document,
    /* [in] */ ULONG32 line,
    /* [in] */ ULONG32 column,
    /* [in] */ ULONG32 cMethod,
    /* [out] */ ULONG32 *pcMethod,
    /* [length_is][size_is][out] */ ISymUnmanagedMethod *pRetVal[  ]);


void __RPC_STUB ISymUnmanagedReader_GetMethodsFromDocumentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetDocumentVersion_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ISymUnmanagedDocument *pDoc,
    /* [out] */ int *version,
    /* [out] */ BOOL *pbCurrent);


void __RPC_STUB ISymUnmanagedReader_GetDocumentVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader_GetMethodVersion_Proxy( 
    ISymUnmanagedReader * This,
    /* [in] */ ISymUnmanagedMethod *pMethod,
    /* [out] */ int *version);


void __RPC_STUB ISymUnmanagedReader_GetMethodVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedReader_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedSourceServerModule_INTERFACE_DEFINED__
#define __ISymUnmanagedSourceServerModule_INTERFACE_DEFINED__

/* interface ISymUnmanagedSourceServerModule */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedSourceServerModule;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("997DD0CC-A76F-4c82-8D79-EA87559D27AD")
    ISymUnmanagedSourceServerModule : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSourceServerData( 
            /* [out] */ ULONG *pDataByteCount,
            /* [size_is][size_is][out] */ BYTE **ppData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedSourceServerModuleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedSourceServerModule * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedSourceServerModule * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedSourceServerModule * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSourceServerData )( 
            ISymUnmanagedSourceServerModule * This,
            /* [out] */ ULONG *pDataByteCount,
            /* [size_is][size_is][out] */ BYTE **ppData);
        
        END_INTERFACE
    } ISymUnmanagedSourceServerModuleVtbl;

    interface ISymUnmanagedSourceServerModule
    {
        CONST_VTBL struct ISymUnmanagedSourceServerModuleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedSourceServerModule_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedSourceServerModule_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedSourceServerModule_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedSourceServerModule_GetSourceServerData(This,pDataByteCount,ppData)	\
    (This)->lpVtbl -> GetSourceServerData(This,pDataByteCount,ppData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedSourceServerModule_GetSourceServerData_Proxy( 
    ISymUnmanagedSourceServerModule * This,
    /* [out] */ ULONG *pDataByteCount,
    /* [size_is][size_is][out] */ BYTE **ppData);


void __RPC_STUB ISymUnmanagedSourceServerModule_GetSourceServerData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedSourceServerModule_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedENCUpdate_INTERFACE_DEFINED__
#define __ISymUnmanagedENCUpdate_INTERFACE_DEFINED__

/* interface ISymUnmanagedENCUpdate */
/* [unique][uuid][object] */ 

typedef struct _SYMLINEDELTA
    {
    mdMethodDef mdMethod;
    INT32 delta;
    } 	SYMLINEDELTA;


EXTERN_C const IID IID_ISymUnmanagedENCUpdate;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("E502D2DD-8671-4338-8F2A-FC08229628C4")
    ISymUnmanagedENCUpdate : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UpdateSymbolStore2( 
            /* [in] */ IStream *pIStream,
            /* [in] */ SYMLINEDELTA *pDeltaLines,
            /* [in] */ ULONG cDeltaLines) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalVariableCount( 
            /* [in] */ mdMethodDef mdMethodToken,
            /* [out] */ ULONG *pcLocals) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalVariables( 
            /* [in] */ mdMethodDef mdMethodToken,
            /* [in] */ ULONG cLocals,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *rgLocals[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeForEnc( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateMethodLines( 
            /* [in] */ mdMethodDef mdMethodToken,
            /* [size_is][in] */ INT32 *pDeltas,
            /* [in] */ ULONG cDeltas) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedENCUpdateVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedENCUpdate * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedENCUpdate * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedENCUpdate * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateSymbolStore2 )( 
            ISymUnmanagedENCUpdate * This,
            /* [in] */ IStream *pIStream,
            /* [in] */ SYMLINEDELTA *pDeltaLines,
            /* [in] */ ULONG cDeltaLines);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalVariableCount )( 
            ISymUnmanagedENCUpdate * This,
            /* [in] */ mdMethodDef mdMethodToken,
            /* [out] */ ULONG *pcLocals);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalVariables )( 
            ISymUnmanagedENCUpdate * This,
            /* [in] */ mdMethodDef mdMethodToken,
            /* [in] */ ULONG cLocals,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *rgLocals[  ],
            /* [out] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeForEnc )( 
            ISymUnmanagedENCUpdate * This);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateMethodLines )( 
            ISymUnmanagedENCUpdate * This,
            /* [in] */ mdMethodDef mdMethodToken,
            /* [size_is][in] */ INT32 *pDeltas,
            /* [in] */ ULONG cDeltas);
        
        END_INTERFACE
    } ISymUnmanagedENCUpdateVtbl;

    interface ISymUnmanagedENCUpdate
    {
        CONST_VTBL struct ISymUnmanagedENCUpdateVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedENCUpdate_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedENCUpdate_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedENCUpdate_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedENCUpdate_UpdateSymbolStore2(This,pIStream,pDeltaLines,cDeltaLines)	\
    (This)->lpVtbl -> UpdateSymbolStore2(This,pIStream,pDeltaLines,cDeltaLines)

#define ISymUnmanagedENCUpdate_GetLocalVariableCount(This,mdMethodToken,pcLocals)	\
    (This)->lpVtbl -> GetLocalVariableCount(This,mdMethodToken,pcLocals)

#define ISymUnmanagedENCUpdate_GetLocalVariables(This,mdMethodToken,cLocals,rgLocals,pceltFetched)	\
    (This)->lpVtbl -> GetLocalVariables(This,mdMethodToken,cLocals,rgLocals,pceltFetched)

#define ISymUnmanagedENCUpdate_InitializeForEnc(This)	\
    (This)->lpVtbl -> InitializeForEnc(This)

#define ISymUnmanagedENCUpdate_UpdateMethodLines(This,mdMethodToken,pDeltas,cDeltas)	\
    (This)->lpVtbl -> UpdateMethodLines(This,mdMethodToken,pDeltas,cDeltas)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedENCUpdate_UpdateSymbolStore2_Proxy( 
    ISymUnmanagedENCUpdate * This,
    /* [in] */ IStream *pIStream,
    /* [in] */ SYMLINEDELTA *pDeltaLines,
    /* [in] */ ULONG cDeltaLines);


void __RPC_STUB ISymUnmanagedENCUpdate_UpdateSymbolStore2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedENCUpdate_GetLocalVariableCount_Proxy( 
    ISymUnmanagedENCUpdate * This,
    /* [in] */ mdMethodDef mdMethodToken,
    /* [out] */ ULONG *pcLocals);


void __RPC_STUB ISymUnmanagedENCUpdate_GetLocalVariableCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedENCUpdate_GetLocalVariables_Proxy( 
    ISymUnmanagedENCUpdate * This,
    /* [in] */ mdMethodDef mdMethodToken,
    /* [in] */ ULONG cLocals,
    /* [length_is][size_is][out] */ ISymUnmanagedVariable *rgLocals[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ISymUnmanagedENCUpdate_GetLocalVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedENCUpdate_InitializeForEnc_Proxy( 
    ISymUnmanagedENCUpdate * This);


void __RPC_STUB ISymUnmanagedENCUpdate_InitializeForEnc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedENCUpdate_UpdateMethodLines_Proxy( 
    ISymUnmanagedENCUpdate * This,
    /* [in] */ mdMethodDef mdMethodToken,
    /* [size_is][in] */ INT32 *pDeltas,
    /* [in] */ ULONG cDeltas);


void __RPC_STUB ISymUnmanagedENCUpdate_UpdateMethodLines_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedENCUpdate_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedReaderSymbolSearchInfo_INTERFACE_DEFINED__
#define __ISymUnmanagedReaderSymbolSearchInfo_INTERFACE_DEFINED__

/* interface ISymUnmanagedReaderSymbolSearchInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedReaderSymbolSearchInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("20D9645D-03CD-4e34-9C11-9848A5B084F1")
    ISymUnmanagedReaderSymbolSearchInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSymbolSearchInfoCount( 
            /* [out] */ ULONG32 *pcSearchInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymbolSearchInfo( 
            /* [in] */ ULONG32 cSearchInfo,
            /* [out] */ ULONG32 *pcSearchInfo,
            /* [length_is][size_is][out] */ ISymUnmanagedSymbolSearchInfo **rgpSearchInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedReaderSymbolSearchInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedReaderSymbolSearchInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedReaderSymbolSearchInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedReaderSymbolSearchInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymbolSearchInfoCount )( 
            ISymUnmanagedReaderSymbolSearchInfo * This,
            /* [out] */ ULONG32 *pcSearchInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymbolSearchInfo )( 
            ISymUnmanagedReaderSymbolSearchInfo * This,
            /* [in] */ ULONG32 cSearchInfo,
            /* [out] */ ULONG32 *pcSearchInfo,
            /* [length_is][size_is][out] */ ISymUnmanagedSymbolSearchInfo **rgpSearchInfo);
        
        END_INTERFACE
    } ISymUnmanagedReaderSymbolSearchInfoVtbl;

    interface ISymUnmanagedReaderSymbolSearchInfo
    {
        CONST_VTBL struct ISymUnmanagedReaderSymbolSearchInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedReaderSymbolSearchInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedReaderSymbolSearchInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedReaderSymbolSearchInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedReaderSymbolSearchInfo_GetSymbolSearchInfoCount(This,pcSearchInfo)	\
    (This)->lpVtbl -> GetSymbolSearchInfoCount(This,pcSearchInfo)

#define ISymUnmanagedReaderSymbolSearchInfo_GetSymbolSearchInfo(This,cSearchInfo,pcSearchInfo,rgpSearchInfo)	\
    (This)->lpVtbl -> GetSymbolSearchInfo(This,cSearchInfo,pcSearchInfo,rgpSearchInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedReaderSymbolSearchInfo_GetSymbolSearchInfoCount_Proxy( 
    ISymUnmanagedReaderSymbolSearchInfo * This,
    /* [out] */ ULONG32 *pcSearchInfo);


void __RPC_STUB ISymUnmanagedReaderSymbolSearchInfo_GetSymbolSearchInfoCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReaderSymbolSearchInfo_GetSymbolSearchInfo_Proxy( 
    ISymUnmanagedReaderSymbolSearchInfo * This,
    /* [in] */ ULONG32 cSearchInfo,
    /* [out] */ ULONG32 *pcSearchInfo,
    /* [length_is][size_is][out] */ ISymUnmanagedSymbolSearchInfo **rgpSearchInfo);


void __RPC_STUB ISymUnmanagedReaderSymbolSearchInfo_GetSymbolSearchInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedReaderSymbolSearchInfo_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedScope_INTERFACE_DEFINED__
#define __ISymUnmanagedScope_INTERFACE_DEFINED__

/* interface ISymUnmanagedScope */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedScope;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("68005D0F-B8E0-3B01-84D5-A11A94154942")
    ISymUnmanagedScope : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMethod( 
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [retval][out] */ ISymUnmanagedScope **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetChildren( 
            /* [in] */ ULONG32 cChildren,
            /* [out] */ ULONG32 *pcChildren,
            /* [length_is][size_is][out] */ ISymUnmanagedScope *children[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStartOffset( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndOffset( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocalCount( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocals( 
            /* [in] */ ULONG32 cLocals,
            /* [out] */ ULONG32 *pcLocals,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *locals[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNamespaces( 
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedScopeVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedScope * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedScope * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedScope * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            ISymUnmanagedScope * This,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            ISymUnmanagedScope * This,
            /* [retval][out] */ ISymUnmanagedScope **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetChildren )( 
            ISymUnmanagedScope * This,
            /* [in] */ ULONG32 cChildren,
            /* [out] */ ULONG32 *pcChildren,
            /* [length_is][size_is][out] */ ISymUnmanagedScope *children[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartOffset )( 
            ISymUnmanagedScope * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndOffset )( 
            ISymUnmanagedScope * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalCount )( 
            ISymUnmanagedScope * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocals )( 
            ISymUnmanagedScope * This,
            /* [in] */ ULONG32 cLocals,
            /* [out] */ ULONG32 *pcLocals,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *locals[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespaces )( 
            ISymUnmanagedScope * This,
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);
        
        END_INTERFACE
    } ISymUnmanagedScopeVtbl;

    interface ISymUnmanagedScope
    {
        CONST_VTBL struct ISymUnmanagedScopeVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedScope_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedScope_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedScope_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedScope_GetMethod(This,pRetVal)	\
    (This)->lpVtbl -> GetMethod(This,pRetVal)

#define ISymUnmanagedScope_GetParent(This,pRetVal)	\
    (This)->lpVtbl -> GetParent(This,pRetVal)

#define ISymUnmanagedScope_GetChildren(This,cChildren,pcChildren,children)	\
    (This)->lpVtbl -> GetChildren(This,cChildren,pcChildren,children)

#define ISymUnmanagedScope_GetStartOffset(This,pRetVal)	\
    (This)->lpVtbl -> GetStartOffset(This,pRetVal)

#define ISymUnmanagedScope_GetEndOffset(This,pRetVal)	\
    (This)->lpVtbl -> GetEndOffset(This,pRetVal)

#define ISymUnmanagedScope_GetLocalCount(This,pRetVal)	\
    (This)->lpVtbl -> GetLocalCount(This,pRetVal)

#define ISymUnmanagedScope_GetLocals(This,cLocals,pcLocals,locals)	\
    (This)->lpVtbl -> GetLocals(This,cLocals,pcLocals,locals)

#define ISymUnmanagedScope_GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)	\
    (This)->lpVtbl -> GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetMethod_Proxy( 
    ISymUnmanagedScope * This,
    /* [retval][out] */ ISymUnmanagedMethod **pRetVal);


void __RPC_STUB ISymUnmanagedScope_GetMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetParent_Proxy( 
    ISymUnmanagedScope * This,
    /* [retval][out] */ ISymUnmanagedScope **pRetVal);


void __RPC_STUB ISymUnmanagedScope_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetChildren_Proxy( 
    ISymUnmanagedScope * This,
    /* [in] */ ULONG32 cChildren,
    /* [out] */ ULONG32 *pcChildren,
    /* [length_is][size_is][out] */ ISymUnmanagedScope *children[  ]);


void __RPC_STUB ISymUnmanagedScope_GetChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetStartOffset_Proxy( 
    ISymUnmanagedScope * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedScope_GetStartOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetEndOffset_Proxy( 
    ISymUnmanagedScope * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedScope_GetEndOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetLocalCount_Proxy( 
    ISymUnmanagedScope * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedScope_GetLocalCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetLocals_Proxy( 
    ISymUnmanagedScope * This,
    /* [in] */ ULONG32 cLocals,
    /* [out] */ ULONG32 *pcLocals,
    /* [length_is][size_is][out] */ ISymUnmanagedVariable *locals[  ]);


void __RPC_STUB ISymUnmanagedScope_GetLocals_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope_GetNamespaces_Proxy( 
    ISymUnmanagedScope * This,
    /* [in] */ ULONG32 cNameSpaces,
    /* [out] */ ULONG32 *pcNameSpaces,
    /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);


void __RPC_STUB ISymUnmanagedScope_GetNamespaces_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedScope_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedConstant_INTERFACE_DEFINED__
#define __ISymUnmanagedConstant_INTERFACE_DEFINED__

/* interface ISymUnmanagedConstant */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedConstant;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("48B25ED8-5BAD-41bc-9CEE-CD62FABC74E9")
    ISymUnmanagedConstant : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            VARIANT *pValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignature( 
            /* [in] */ ULONG32 cSig,
            /* [out] */ ULONG32 *pcSig,
            /* [length_is][size_is][out] */ BYTE sig[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedConstantVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedConstant * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedConstant * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedConstant * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ISymUnmanagedConstant * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ISymUnmanagedConstant * This,
            VARIANT *pValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignature )( 
            ISymUnmanagedConstant * This,
            /* [in] */ ULONG32 cSig,
            /* [out] */ ULONG32 *pcSig,
            /* [length_is][size_is][out] */ BYTE sig[  ]);
        
        END_INTERFACE
    } ISymUnmanagedConstantVtbl;

    interface ISymUnmanagedConstant
    {
        CONST_VTBL struct ISymUnmanagedConstantVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedConstant_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedConstant_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedConstant_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedConstant_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ISymUnmanagedConstant_GetValue(This,pValue)	\
    (This)->lpVtbl -> GetValue(This,pValue)

#define ISymUnmanagedConstant_GetSignature(This,cSig,pcSig,sig)	\
    (This)->lpVtbl -> GetSignature(This,cSig,pcSig,sig)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedConstant_GetName_Proxy( 
    ISymUnmanagedConstant * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ISymUnmanagedConstant_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedConstant_GetValue_Proxy( 
    ISymUnmanagedConstant * This,
    VARIANT *pValue);


void __RPC_STUB ISymUnmanagedConstant_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedConstant_GetSignature_Proxy( 
    ISymUnmanagedConstant * This,
    /* [in] */ ULONG32 cSig,
    /* [out] */ ULONG32 *pcSig,
    /* [length_is][size_is][out] */ BYTE sig[  ]);


void __RPC_STUB ISymUnmanagedConstant_GetSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedConstant_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedScope2_INTERFACE_DEFINED__
#define __ISymUnmanagedScope2_INTERFACE_DEFINED__

/* interface ISymUnmanagedScope2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedScope2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AE932FBA-3FD8-4dba-8232-30A2309B02DB")
    ISymUnmanagedScope2 : public ISymUnmanagedScope
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConstantCount( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConstants( 
            /* [in] */ ULONG32 cConstants,
            /* [out] */ ULONG32 *pcConstants,
            /* [length_is][size_is][out] */ ISymUnmanagedConstant *constants[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedScope2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedScope2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedScope2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedScope2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            ISymUnmanagedScope2 * This,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetParent )( 
            ISymUnmanagedScope2 * This,
            /* [retval][out] */ ISymUnmanagedScope **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetChildren )( 
            ISymUnmanagedScope2 * This,
            /* [in] */ ULONG32 cChildren,
            /* [out] */ ULONG32 *pcChildren,
            /* [length_is][size_is][out] */ ISymUnmanagedScope *children[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartOffset )( 
            ISymUnmanagedScope2 * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndOffset )( 
            ISymUnmanagedScope2 * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocalCount )( 
            ISymUnmanagedScope2 * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetLocals )( 
            ISymUnmanagedScope2 * This,
            /* [in] */ ULONG32 cLocals,
            /* [out] */ ULONG32 *pcLocals,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *locals[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespaces )( 
            ISymUnmanagedScope2 * This,
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetConstantCount )( 
            ISymUnmanagedScope2 * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetConstants )( 
            ISymUnmanagedScope2 * This,
            /* [in] */ ULONG32 cConstants,
            /* [out] */ ULONG32 *pcConstants,
            /* [length_is][size_is][out] */ ISymUnmanagedConstant *constants[  ]);
        
        END_INTERFACE
    } ISymUnmanagedScope2Vtbl;

    interface ISymUnmanagedScope2
    {
        CONST_VTBL struct ISymUnmanagedScope2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedScope2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedScope2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedScope2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedScope2_GetMethod(This,pRetVal)	\
    (This)->lpVtbl -> GetMethod(This,pRetVal)

#define ISymUnmanagedScope2_GetParent(This,pRetVal)	\
    (This)->lpVtbl -> GetParent(This,pRetVal)

#define ISymUnmanagedScope2_GetChildren(This,cChildren,pcChildren,children)	\
    (This)->lpVtbl -> GetChildren(This,cChildren,pcChildren,children)

#define ISymUnmanagedScope2_GetStartOffset(This,pRetVal)	\
    (This)->lpVtbl -> GetStartOffset(This,pRetVal)

#define ISymUnmanagedScope2_GetEndOffset(This,pRetVal)	\
    (This)->lpVtbl -> GetEndOffset(This,pRetVal)

#define ISymUnmanagedScope2_GetLocalCount(This,pRetVal)	\
    (This)->lpVtbl -> GetLocalCount(This,pRetVal)

#define ISymUnmanagedScope2_GetLocals(This,cLocals,pcLocals,locals)	\
    (This)->lpVtbl -> GetLocals(This,cLocals,pcLocals,locals)

#define ISymUnmanagedScope2_GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)	\
    (This)->lpVtbl -> GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)


#define ISymUnmanagedScope2_GetConstantCount(This,pRetVal)	\
    (This)->lpVtbl -> GetConstantCount(This,pRetVal)

#define ISymUnmanagedScope2_GetConstants(This,cConstants,pcConstants,constants)	\
    (This)->lpVtbl -> GetConstants(This,cConstants,pcConstants,constants)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedScope2_GetConstantCount_Proxy( 
    ISymUnmanagedScope2 * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedScope2_GetConstantCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedScope2_GetConstants_Proxy( 
    ISymUnmanagedScope2 * This,
    /* [in] */ ULONG32 cConstants,
    /* [out] */ ULONG32 *pcConstants,
    /* [length_is][size_is][out] */ ISymUnmanagedConstant *constants[  ]);


void __RPC_STUB ISymUnmanagedScope2_GetConstants_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedScope2_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedVariable_INTERFACE_DEFINED__
#define __ISymUnmanagedVariable_INTERFACE_DEFINED__

/* interface ISymUnmanagedVariable */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedVariable;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9F60EEBE-2D9A-3F7C-BF58-80BC991C60BB")
    ISymUnmanagedVariable : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAttributes( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSignature( 
            /* [in] */ ULONG32 cSig,
            /* [out] */ ULONG32 *pcSig,
            /* [length_is][size_is][out] */ BYTE sig[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressKind( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressField1( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressField2( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAddressField3( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStartOffset( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEndOffset( 
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedVariableVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedVariable * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedVariable * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedVariable * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ISymUnmanagedVariable * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttributes )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSignature )( 
            ISymUnmanagedVariable * This,
            /* [in] */ ULONG32 cSig,
            /* [out] */ ULONG32 *pcSig,
            /* [length_is][size_is][out] */ BYTE sig[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressKind )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressField1 )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressField2 )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetAddressField3 )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetStartOffset )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetEndOffset )( 
            ISymUnmanagedVariable * This,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        END_INTERFACE
    } ISymUnmanagedVariableVtbl;

    interface ISymUnmanagedVariable
    {
        CONST_VTBL struct ISymUnmanagedVariableVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedVariable_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedVariable_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedVariable_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedVariable_GetName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetName(This,cchName,pcchName,szName)

#define ISymUnmanagedVariable_GetAttributes(This,pRetVal)	\
    (This)->lpVtbl -> GetAttributes(This,pRetVal)

#define ISymUnmanagedVariable_GetSignature(This,cSig,pcSig,sig)	\
    (This)->lpVtbl -> GetSignature(This,cSig,pcSig,sig)

#define ISymUnmanagedVariable_GetAddressKind(This,pRetVal)	\
    (This)->lpVtbl -> GetAddressKind(This,pRetVal)

#define ISymUnmanagedVariable_GetAddressField1(This,pRetVal)	\
    (This)->lpVtbl -> GetAddressField1(This,pRetVal)

#define ISymUnmanagedVariable_GetAddressField2(This,pRetVal)	\
    (This)->lpVtbl -> GetAddressField2(This,pRetVal)

#define ISymUnmanagedVariable_GetAddressField3(This,pRetVal)	\
    (This)->lpVtbl -> GetAddressField3(This,pRetVal)

#define ISymUnmanagedVariable_GetStartOffset(This,pRetVal)	\
    (This)->lpVtbl -> GetStartOffset(This,pRetVal)

#define ISymUnmanagedVariable_GetEndOffset(This,pRetVal)	\
    (This)->lpVtbl -> GetEndOffset(This,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetName_Proxy( 
    ISymUnmanagedVariable * This,
    /* [in] */ ULONG32 cchName,
    /* [out] */ ULONG32 *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ]);


void __RPC_STUB ISymUnmanagedVariable_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetAttributes_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetSignature_Proxy( 
    ISymUnmanagedVariable * This,
    /* [in] */ ULONG32 cSig,
    /* [out] */ ULONG32 *pcSig,
    /* [length_is][size_is][out] */ BYTE sig[  ]);


void __RPC_STUB ISymUnmanagedVariable_GetSignature_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetAddressKind_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetAddressKind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetAddressField1_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetAddressField1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetAddressField2_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetAddressField2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetAddressField3_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetAddressField3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetStartOffset_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetStartOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedVariable_GetEndOffset_Proxy( 
    ISymUnmanagedVariable * This,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedVariable_GetEndOffset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedVariable_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedSymbolSearchInfo_INTERFACE_DEFINED__
#define __ISymUnmanagedSymbolSearchInfo_INTERFACE_DEFINED__

/* interface ISymUnmanagedSymbolSearchInfo */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedSymbolSearchInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F8B3534A-A46B-4980-B520-BEC4ACEABA8F")
    ISymUnmanagedSymbolSearchInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSearchPathLength( 
            /* [out] */ ULONG32 *pcchPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSearchPath( 
            /* [in] */ ULONG32 cchPath,
            /* [out] */ ULONG32 *pcchPath,
            /* [length_is][size_is][out] */ WCHAR szPath[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHRESULT( 
            /* [out] */ HRESULT *phr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedSymbolSearchInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedSymbolSearchInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedSymbolSearchInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedSymbolSearchInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSearchPathLength )( 
            ISymUnmanagedSymbolSearchInfo * This,
            /* [out] */ ULONG32 *pcchPath);
        
        HRESULT ( STDMETHODCALLTYPE *GetSearchPath )( 
            ISymUnmanagedSymbolSearchInfo * This,
            /* [in] */ ULONG32 cchPath,
            /* [out] */ ULONG32 *pcchPath,
            /* [length_is][size_is][out] */ WCHAR szPath[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetHRESULT )( 
            ISymUnmanagedSymbolSearchInfo * This,
            /* [out] */ HRESULT *phr);
        
        END_INTERFACE
    } ISymUnmanagedSymbolSearchInfoVtbl;

    interface ISymUnmanagedSymbolSearchInfo
    {
        CONST_VTBL struct ISymUnmanagedSymbolSearchInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedSymbolSearchInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedSymbolSearchInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedSymbolSearchInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedSymbolSearchInfo_GetSearchPathLength(This,pcchPath)	\
    (This)->lpVtbl -> GetSearchPathLength(This,pcchPath)

#define ISymUnmanagedSymbolSearchInfo_GetSearchPath(This,cchPath,pcchPath,szPath)	\
    (This)->lpVtbl -> GetSearchPath(This,cchPath,pcchPath,szPath)

#define ISymUnmanagedSymbolSearchInfo_GetHRESULT(This,phr)	\
    (This)->lpVtbl -> GetHRESULT(This,phr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedSymbolSearchInfo_GetSearchPathLength_Proxy( 
    ISymUnmanagedSymbolSearchInfo * This,
    /* [out] */ ULONG32 *pcchPath);


void __RPC_STUB ISymUnmanagedSymbolSearchInfo_GetSearchPathLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedSymbolSearchInfo_GetSearchPath_Proxy( 
    ISymUnmanagedSymbolSearchInfo * This,
    /* [in] */ ULONG32 cchPath,
    /* [out] */ ULONG32 *pcchPath,
    /* [length_is][size_is][out] */ WCHAR szPath[  ]);


void __RPC_STUB ISymUnmanagedSymbolSearchInfo_GetSearchPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedSymbolSearchInfo_GetHRESULT_Proxy( 
    ISymUnmanagedSymbolSearchInfo * This,
    /* [out] */ HRESULT *phr);


void __RPC_STUB ISymUnmanagedSymbolSearchInfo_GetHRESULT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedSymbolSearchInfo_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedWriter_INTERFACE_DEFINED__
#define __ISymUnmanagedWriter_INTERFACE_DEFINED__

/* interface ISymUnmanagedWriter */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedWriter;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("ED14AA72-78E2-4884-84E2-334293AE5214")
    ISymUnmanagedWriter : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DefineDocument( 
            /* [in] */ const WCHAR *url,
            /* [in] */ const GUID *language,
            /* [in] */ const GUID *languageVendor,
            /* [in] */ const GUID *documentType,
            /* [retval][out] */ ISymUnmanagedDocumentWriter **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUserEntryPoint( 
            /* [in] */ mdMethodDef entryMethod) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenMethod( 
            /* [in] */ mdMethodDef method) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseMethod( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenScope( 
            /* [in] */ ULONG32 startOffset,
            /* [retval][out] */ ULONG32 *pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseScope( 
            /* [in] */ ULONG32 endOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetScopeRange( 
            /* [in] */ ULONG32 scopeID,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineLocalVariable( 
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineParameter( 
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 sequence,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineField( 
            /* [in] */ mdTypeDef parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineGlobalVariable( 
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSymAttribute( 
            /* [in] */ mdToken parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 cData,
            /* [size_is][in] */ unsigned char data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const WCHAR *name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseNamespace( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UsingNamespace( 
            /* [in] */ const WCHAR *fullName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMethodSourceRange( 
            /* [in] */ ISymUnmanagedDocumentWriter *startDoc,
            /* [in] */ ULONG32 startLine,
            /* [in] */ ULONG32 startColumn,
            /* [in] */ ISymUnmanagedDocumentWriter *endDoc,
            /* [in] */ ULONG32 endLine,
            /* [in] */ ULONG32 endColumn) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDebugInfo( 
            /* [out][in] */ IMAGE_DEBUG_DIRECTORY *pIDD,
            /* [in] */ DWORD cData,
            /* [out] */ DWORD *pcData,
            /* [length_is][size_is][out] */ BYTE data[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineSequencePoints( 
            /* [in] */ ISymUnmanagedDocumentWriter *document,
            /* [in] */ ULONG32 spCount,
            /* [size_is][in] */ ULONG32 offsets[  ],
            /* [size_is][in] */ ULONG32 lines[  ],
            /* [size_is][in] */ ULONG32 columns[  ],
            /* [size_is][in] */ ULONG32 endLines[  ],
            /* [size_is][in] */ ULONG32 endColumns[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemapToken( 
            /* [in] */ mdToken oldToken,
            /* [in] */ mdToken newToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Initialize2( 
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *tempfilename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild,
            /* [in] */ const WCHAR *finalfilename) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineConstant( 
            /* [in] */ const WCHAR *name,
            /* [in] */ VARIANT value,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedWriterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedWriter * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedWriter * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *DefineDocument )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *url,
            /* [in] */ const GUID *language,
            /* [in] */ const GUID *languageVendor,
            /* [in] */ const GUID *documentType,
            /* [retval][out] */ ISymUnmanagedDocumentWriter **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserEntryPoint )( 
            ISymUnmanagedWriter * This,
            /* [in] */ mdMethodDef entryMethod);
        
        HRESULT ( STDMETHODCALLTYPE *OpenMethod )( 
            ISymUnmanagedWriter * This,
            /* [in] */ mdMethodDef method);
        
        HRESULT ( STDMETHODCALLTYPE *CloseMethod )( 
            ISymUnmanagedWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenScope )( 
            ISymUnmanagedWriter * This,
            /* [in] */ ULONG32 startOffset,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *CloseScope )( 
            ISymUnmanagedWriter * This,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetScopeRange )( 
            ISymUnmanagedWriter * This,
            /* [in] */ ULONG32 scopeID,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineLocalVariable )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineParameter )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 sequence,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineField )( 
            ISymUnmanagedWriter * This,
            /* [in] */ mdTypeDef parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineGlobalVariable )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            ISymUnmanagedWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSymAttribute )( 
            ISymUnmanagedWriter * This,
            /* [in] */ mdToken parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 cData,
            /* [size_is][in] */ unsigned char data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *OpenNamespace )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *name);
        
        HRESULT ( STDMETHODCALLTYPE *CloseNamespace )( 
            ISymUnmanagedWriter * This);
        
        HRESULT ( STDMETHODCALLTYPE *UsingNamespace )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *fullName);
        
        HRESULT ( STDMETHODCALLTYPE *SetMethodSourceRange )( 
            ISymUnmanagedWriter * This,
            /* [in] */ ISymUnmanagedDocumentWriter *startDoc,
            /* [in] */ ULONG32 startLine,
            /* [in] */ ULONG32 startColumn,
            /* [in] */ ISymUnmanagedDocumentWriter *endDoc,
            /* [in] */ ULONG32 endLine,
            /* [in] */ ULONG32 endColumn);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISymUnmanagedWriter * This,
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugInfo )( 
            ISymUnmanagedWriter * This,
            /* [out][in] */ IMAGE_DEBUG_DIRECTORY *pIDD,
            /* [in] */ DWORD cData,
            /* [out] */ DWORD *pcData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DefineSequencePoints )( 
            ISymUnmanagedWriter * This,
            /* [in] */ ISymUnmanagedDocumentWriter *document,
            /* [in] */ ULONG32 spCount,
            /* [size_is][in] */ ULONG32 offsets[  ],
            /* [size_is][in] */ ULONG32 lines[  ],
            /* [size_is][in] */ ULONG32 columns[  ],
            /* [size_is][in] */ ULONG32 endLines[  ],
            /* [size_is][in] */ ULONG32 endColumns[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RemapToken )( 
            ISymUnmanagedWriter * This,
            /* [in] */ mdToken oldToken,
            /* [in] */ mdToken newToken);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize2 )( 
            ISymUnmanagedWriter * This,
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *tempfilename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild,
            /* [in] */ const WCHAR *finalfilename);
        
        HRESULT ( STDMETHODCALLTYPE *DefineConstant )( 
            ISymUnmanagedWriter * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ VARIANT value,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ISymUnmanagedWriter * This);
        
        END_INTERFACE
    } ISymUnmanagedWriterVtbl;

    interface ISymUnmanagedWriter
    {
        CONST_VTBL struct ISymUnmanagedWriterVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedWriter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedWriter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedWriter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedWriter_DefineDocument(This,url,language,languageVendor,documentType,pRetVal)	\
    (This)->lpVtbl -> DefineDocument(This,url,language,languageVendor,documentType,pRetVal)

#define ISymUnmanagedWriter_SetUserEntryPoint(This,entryMethod)	\
    (This)->lpVtbl -> SetUserEntryPoint(This,entryMethod)

#define ISymUnmanagedWriter_OpenMethod(This,method)	\
    (This)->lpVtbl -> OpenMethod(This,method)

#define ISymUnmanagedWriter_CloseMethod(This)	\
    (This)->lpVtbl -> CloseMethod(This)

#define ISymUnmanagedWriter_OpenScope(This,startOffset,pRetVal)	\
    (This)->lpVtbl -> OpenScope(This,startOffset,pRetVal)

#define ISymUnmanagedWriter_CloseScope(This,endOffset)	\
    (This)->lpVtbl -> CloseScope(This,endOffset)

#define ISymUnmanagedWriter_SetScopeRange(This,scopeID,startOffset,endOffset)	\
    (This)->lpVtbl -> SetScopeRange(This,scopeID,startOffset,endOffset)

#define ISymUnmanagedWriter_DefineLocalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3,startOffset,endOffset)	\
    (This)->lpVtbl -> DefineLocalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3,startOffset,endOffset)

#define ISymUnmanagedWriter_DefineParameter(This,name,attributes,sequence,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineParameter(This,name,attributes,sequence,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter_DefineField(This,parent,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineField(This,parent,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter_DefineGlobalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineGlobalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define ISymUnmanagedWriter_SetSymAttribute(This,parent,name,cData,data)	\
    (This)->lpVtbl -> SetSymAttribute(This,parent,name,cData,data)

#define ISymUnmanagedWriter_OpenNamespace(This,name)	\
    (This)->lpVtbl -> OpenNamespace(This,name)

#define ISymUnmanagedWriter_CloseNamespace(This)	\
    (This)->lpVtbl -> CloseNamespace(This)

#define ISymUnmanagedWriter_UsingNamespace(This,fullName)	\
    (This)->lpVtbl -> UsingNamespace(This,fullName)

#define ISymUnmanagedWriter_SetMethodSourceRange(This,startDoc,startLine,startColumn,endDoc,endLine,endColumn)	\
    (This)->lpVtbl -> SetMethodSourceRange(This,startDoc,startLine,startColumn,endDoc,endLine,endColumn)

#define ISymUnmanagedWriter_Initialize(This,emitter,filename,pIStream,fFullBuild)	\
    (This)->lpVtbl -> Initialize(This,emitter,filename,pIStream,fFullBuild)

#define ISymUnmanagedWriter_GetDebugInfo(This,pIDD,cData,pcData,data)	\
    (This)->lpVtbl -> GetDebugInfo(This,pIDD,cData,pcData,data)

#define ISymUnmanagedWriter_DefineSequencePoints(This,document,spCount,offsets,lines,columns,endLines,endColumns)	\
    (This)->lpVtbl -> DefineSequencePoints(This,document,spCount,offsets,lines,columns,endLines,endColumns)

#define ISymUnmanagedWriter_RemapToken(This,oldToken,newToken)	\
    (This)->lpVtbl -> RemapToken(This,oldToken,newToken)

#define ISymUnmanagedWriter_Initialize2(This,emitter,tempfilename,pIStream,fFullBuild,finalfilename)	\
    (This)->lpVtbl -> Initialize2(This,emitter,tempfilename,pIStream,fFullBuild,finalfilename)

#define ISymUnmanagedWriter_DefineConstant(This,name,value,cSig,signature)	\
    (This)->lpVtbl -> DefineConstant(This,name,value,cSig,signature)

#define ISymUnmanagedWriter_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineDocument_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *url,
    /* [in] */ const GUID *language,
    /* [in] */ const GUID *languageVendor,
    /* [in] */ const GUID *documentType,
    /* [retval][out] */ ISymUnmanagedDocumentWriter **pRetVal);


void __RPC_STUB ISymUnmanagedWriter_DefineDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_SetUserEntryPoint_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ mdMethodDef entryMethod);


void __RPC_STUB ISymUnmanagedWriter_SetUserEntryPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_OpenMethod_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ mdMethodDef method);


void __RPC_STUB ISymUnmanagedWriter_OpenMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_CloseMethod_Proxy( 
    ISymUnmanagedWriter * This);


void __RPC_STUB ISymUnmanagedWriter_CloseMethod_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_OpenScope_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ ULONG32 startOffset,
    /* [retval][out] */ ULONG32 *pRetVal);


void __RPC_STUB ISymUnmanagedWriter_OpenScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_CloseScope_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ ULONG32 endOffset);


void __RPC_STUB ISymUnmanagedWriter_CloseScope_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_SetScopeRange_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ ULONG32 scopeID,
    /* [in] */ ULONG32 startOffset,
    /* [in] */ ULONG32 endOffset);


void __RPC_STUB ISymUnmanagedWriter_SetScopeRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineLocalVariable_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 attributes,
    /* [in] */ ULONG32 cSig,
    /* [size_is][in] */ unsigned char signature[  ],
    /* [in] */ ULONG32 addrKind,
    /* [in] */ ULONG32 addr1,
    /* [in] */ ULONG32 addr2,
    /* [in] */ ULONG32 addr3,
    /* [in] */ ULONG32 startOffset,
    /* [in] */ ULONG32 endOffset);


void __RPC_STUB ISymUnmanagedWriter_DefineLocalVariable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineParameter_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 attributes,
    /* [in] */ ULONG32 sequence,
    /* [in] */ ULONG32 addrKind,
    /* [in] */ ULONG32 addr1,
    /* [in] */ ULONG32 addr2,
    /* [in] */ ULONG32 addr3);


void __RPC_STUB ISymUnmanagedWriter_DefineParameter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineField_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ mdTypeDef parent,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 attributes,
    /* [in] */ ULONG32 cSig,
    /* [size_is][in] */ unsigned char signature[  ],
    /* [in] */ ULONG32 addrKind,
    /* [in] */ ULONG32 addr1,
    /* [in] */ ULONG32 addr2,
    /* [in] */ ULONG32 addr3);


void __RPC_STUB ISymUnmanagedWriter_DefineField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineGlobalVariable_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 attributes,
    /* [in] */ ULONG32 cSig,
    /* [size_is][in] */ unsigned char signature[  ],
    /* [in] */ ULONG32 addrKind,
    /* [in] */ ULONG32 addr1,
    /* [in] */ ULONG32 addr2,
    /* [in] */ ULONG32 addr3);


void __RPC_STUB ISymUnmanagedWriter_DefineGlobalVariable_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_Close_Proxy( 
    ISymUnmanagedWriter * This);


void __RPC_STUB ISymUnmanagedWriter_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_SetSymAttribute_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ mdToken parent,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 cData,
    /* [size_is][in] */ unsigned char data[  ]);


void __RPC_STUB ISymUnmanagedWriter_SetSymAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_OpenNamespace_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *name);


void __RPC_STUB ISymUnmanagedWriter_OpenNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_CloseNamespace_Proxy( 
    ISymUnmanagedWriter * This);


void __RPC_STUB ISymUnmanagedWriter_CloseNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_UsingNamespace_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *fullName);


void __RPC_STUB ISymUnmanagedWriter_UsingNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_SetMethodSourceRange_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ ISymUnmanagedDocumentWriter *startDoc,
    /* [in] */ ULONG32 startLine,
    /* [in] */ ULONG32 startColumn,
    /* [in] */ ISymUnmanagedDocumentWriter *endDoc,
    /* [in] */ ULONG32 endLine,
    /* [in] */ ULONG32 endColumn);


void __RPC_STUB ISymUnmanagedWriter_SetMethodSourceRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_Initialize_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ IUnknown *emitter,
    /* [in] */ const WCHAR *filename,
    /* [in] */ IStream *pIStream,
    /* [in] */ BOOL fFullBuild);


void __RPC_STUB ISymUnmanagedWriter_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_GetDebugInfo_Proxy( 
    ISymUnmanagedWriter * This,
    /* [out][in] */ IMAGE_DEBUG_DIRECTORY *pIDD,
    /* [in] */ DWORD cData,
    /* [out] */ DWORD *pcData,
    /* [length_is][size_is][out] */ BYTE data[  ]);


void __RPC_STUB ISymUnmanagedWriter_GetDebugInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineSequencePoints_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ ISymUnmanagedDocumentWriter *document,
    /* [in] */ ULONG32 spCount,
    /* [size_is][in] */ ULONG32 offsets[  ],
    /* [size_is][in] */ ULONG32 lines[  ],
    /* [size_is][in] */ ULONG32 columns[  ],
    /* [size_is][in] */ ULONG32 endLines[  ],
    /* [size_is][in] */ ULONG32 endColumns[  ]);


void __RPC_STUB ISymUnmanagedWriter_DefineSequencePoints_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_RemapToken_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ mdToken oldToken,
    /* [in] */ mdToken newToken);


void __RPC_STUB ISymUnmanagedWriter_RemapToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_Initialize2_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ IUnknown *emitter,
    /* [in] */ const WCHAR *tempfilename,
    /* [in] */ IStream *pIStream,
    /* [in] */ BOOL fFullBuild,
    /* [in] */ const WCHAR *finalfilename);


void __RPC_STUB ISymUnmanagedWriter_Initialize2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_DefineConstant_Proxy( 
    ISymUnmanagedWriter * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ VARIANT value,
    /* [in] */ ULONG32 cSig,
    /* [size_is][in] */ unsigned char signature[  ]);


void __RPC_STUB ISymUnmanagedWriter_DefineConstant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter_Abort_Proxy( 
    ISymUnmanagedWriter * This);


void __RPC_STUB ISymUnmanagedWriter_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedWriter_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedWriter2_INTERFACE_DEFINED__
#define __ISymUnmanagedWriter2_INTERFACE_DEFINED__

/* interface ISymUnmanagedWriter2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedWriter2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0B97726E-9E6D-4f05-9A26-424022093CAA")
    ISymUnmanagedWriter2 : public ISymUnmanagedWriter
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DefineLocalVariable2( 
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ mdSignature sigToken,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineGlobalVariable2( 
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ mdSignature sigToken,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineConstant2( 
            /* [in] */ const WCHAR *name,
            /* [in] */ VARIANT value,
            /* [in] */ mdSignature sigToken) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedWriter2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedWriter2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedWriter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DefineDocument )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *url,
            /* [in] */ const GUID *language,
            /* [in] */ const GUID *languageVendor,
            /* [in] */ const GUID *documentType,
            /* [retval][out] */ ISymUnmanagedDocumentWriter **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserEntryPoint )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ mdMethodDef entryMethod);
        
        HRESULT ( STDMETHODCALLTYPE *OpenMethod )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ mdMethodDef method);
        
        HRESULT ( STDMETHODCALLTYPE *CloseMethod )( 
            ISymUnmanagedWriter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenScope )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ ULONG32 startOffset,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *CloseScope )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetScopeRange )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ ULONG32 scopeID,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineLocalVariable )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineParameter )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 sequence,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineField )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ mdTypeDef parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineGlobalVariable )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            ISymUnmanagedWriter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSymAttribute )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ mdToken parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 cData,
            /* [size_is][in] */ unsigned char data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *OpenNamespace )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name);
        
        HRESULT ( STDMETHODCALLTYPE *CloseNamespace )( 
            ISymUnmanagedWriter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *UsingNamespace )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *fullName);
        
        HRESULT ( STDMETHODCALLTYPE *SetMethodSourceRange )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ ISymUnmanagedDocumentWriter *startDoc,
            /* [in] */ ULONG32 startLine,
            /* [in] */ ULONG32 startColumn,
            /* [in] */ ISymUnmanagedDocumentWriter *endDoc,
            /* [in] */ ULONG32 endLine,
            /* [in] */ ULONG32 endColumn);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugInfo )( 
            ISymUnmanagedWriter2 * This,
            /* [out][in] */ IMAGE_DEBUG_DIRECTORY *pIDD,
            /* [in] */ DWORD cData,
            /* [out] */ DWORD *pcData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DefineSequencePoints )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ ISymUnmanagedDocumentWriter *document,
            /* [in] */ ULONG32 spCount,
            /* [size_is][in] */ ULONG32 offsets[  ],
            /* [size_is][in] */ ULONG32 lines[  ],
            /* [size_is][in] */ ULONG32 columns[  ],
            /* [size_is][in] */ ULONG32 endLines[  ],
            /* [size_is][in] */ ULONG32 endColumns[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RemapToken )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ mdToken oldToken,
            /* [in] */ mdToken newToken);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize2 )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *tempfilename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild,
            /* [in] */ const WCHAR *finalfilename);
        
        HRESULT ( STDMETHODCALLTYPE *DefineConstant )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ VARIANT value,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ISymUnmanagedWriter2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DefineLocalVariable2 )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ mdSignature sigToken,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineGlobalVariable2 )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ mdSignature sigToken,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineConstant2 )( 
            ISymUnmanagedWriter2 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ VARIANT value,
            /* [in] */ mdSignature sigToken);
        
        END_INTERFACE
    } ISymUnmanagedWriter2Vtbl;

    interface ISymUnmanagedWriter2
    {
        CONST_VTBL struct ISymUnmanagedWriter2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedWriter2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedWriter2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedWriter2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedWriter2_DefineDocument(This,url,language,languageVendor,documentType,pRetVal)	\
    (This)->lpVtbl -> DefineDocument(This,url,language,languageVendor,documentType,pRetVal)

#define ISymUnmanagedWriter2_SetUserEntryPoint(This,entryMethod)	\
    (This)->lpVtbl -> SetUserEntryPoint(This,entryMethod)

#define ISymUnmanagedWriter2_OpenMethod(This,method)	\
    (This)->lpVtbl -> OpenMethod(This,method)

#define ISymUnmanagedWriter2_CloseMethod(This)	\
    (This)->lpVtbl -> CloseMethod(This)

#define ISymUnmanagedWriter2_OpenScope(This,startOffset,pRetVal)	\
    (This)->lpVtbl -> OpenScope(This,startOffset,pRetVal)

#define ISymUnmanagedWriter2_CloseScope(This,endOffset)	\
    (This)->lpVtbl -> CloseScope(This,endOffset)

#define ISymUnmanagedWriter2_SetScopeRange(This,scopeID,startOffset,endOffset)	\
    (This)->lpVtbl -> SetScopeRange(This,scopeID,startOffset,endOffset)

#define ISymUnmanagedWriter2_DefineLocalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3,startOffset,endOffset)	\
    (This)->lpVtbl -> DefineLocalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3,startOffset,endOffset)

#define ISymUnmanagedWriter2_DefineParameter(This,name,attributes,sequence,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineParameter(This,name,attributes,sequence,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter2_DefineField(This,parent,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineField(This,parent,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter2_DefineGlobalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineGlobalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter2_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define ISymUnmanagedWriter2_SetSymAttribute(This,parent,name,cData,data)	\
    (This)->lpVtbl -> SetSymAttribute(This,parent,name,cData,data)

#define ISymUnmanagedWriter2_OpenNamespace(This,name)	\
    (This)->lpVtbl -> OpenNamespace(This,name)

#define ISymUnmanagedWriter2_CloseNamespace(This)	\
    (This)->lpVtbl -> CloseNamespace(This)

#define ISymUnmanagedWriter2_UsingNamespace(This,fullName)	\
    (This)->lpVtbl -> UsingNamespace(This,fullName)

#define ISymUnmanagedWriter2_SetMethodSourceRange(This,startDoc,startLine,startColumn,endDoc,endLine,endColumn)	\
    (This)->lpVtbl -> SetMethodSourceRange(This,startDoc,startLine,startColumn,endDoc,endLine,endColumn)

#define ISymUnmanagedWriter2_Initialize(This,emitter,filename,pIStream,fFullBuild)	\
    (This)->lpVtbl -> Initialize(This,emitter,filename,pIStream,fFullBuild)

#define ISymUnmanagedWriter2_GetDebugInfo(This,pIDD,cData,pcData,data)	\
    (This)->lpVtbl -> GetDebugInfo(This,pIDD,cData,pcData,data)

#define ISymUnmanagedWriter2_DefineSequencePoints(This,document,spCount,offsets,lines,columns,endLines,endColumns)	\
    (This)->lpVtbl -> DefineSequencePoints(This,document,spCount,offsets,lines,columns,endLines,endColumns)

#define ISymUnmanagedWriter2_RemapToken(This,oldToken,newToken)	\
    (This)->lpVtbl -> RemapToken(This,oldToken,newToken)

#define ISymUnmanagedWriter2_Initialize2(This,emitter,tempfilename,pIStream,fFullBuild,finalfilename)	\
    (This)->lpVtbl -> Initialize2(This,emitter,tempfilename,pIStream,fFullBuild,finalfilename)

#define ISymUnmanagedWriter2_DefineConstant(This,name,value,cSig,signature)	\
    (This)->lpVtbl -> DefineConstant(This,name,value,cSig,signature)

#define ISymUnmanagedWriter2_Abort(This)	\
    (This)->lpVtbl -> Abort(This)


#define ISymUnmanagedWriter2_DefineLocalVariable2(This,name,attributes,sigToken,addrKind,addr1,addr2,addr3,startOffset,endOffset)	\
    (This)->lpVtbl -> DefineLocalVariable2(This,name,attributes,sigToken,addrKind,addr1,addr2,addr3,startOffset,endOffset)

#define ISymUnmanagedWriter2_DefineGlobalVariable2(This,name,attributes,sigToken,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineGlobalVariable2(This,name,attributes,sigToken,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter2_DefineConstant2(This,name,value,sigToken)	\
    (This)->lpVtbl -> DefineConstant2(This,name,value,sigToken)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter2_DefineLocalVariable2_Proxy( 
    ISymUnmanagedWriter2 * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 attributes,
    /* [in] */ mdSignature sigToken,
    /* [in] */ ULONG32 addrKind,
    /* [in] */ ULONG32 addr1,
    /* [in] */ ULONG32 addr2,
    /* [in] */ ULONG32 addr3,
    /* [in] */ ULONG32 startOffset,
    /* [in] */ ULONG32 endOffset);


void __RPC_STUB ISymUnmanagedWriter2_DefineLocalVariable2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter2_DefineGlobalVariable2_Proxy( 
    ISymUnmanagedWriter2 * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ ULONG32 attributes,
    /* [in] */ mdSignature sigToken,
    /* [in] */ ULONG32 addrKind,
    /* [in] */ ULONG32 addr1,
    /* [in] */ ULONG32 addr2,
    /* [in] */ ULONG32 addr3);


void __RPC_STUB ISymUnmanagedWriter2_DefineGlobalVariable2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter2_DefineConstant2_Proxy( 
    ISymUnmanagedWriter2 * This,
    /* [in] */ const WCHAR *name,
    /* [in] */ VARIANT value,
    /* [in] */ mdSignature sigToken);


void __RPC_STUB ISymUnmanagedWriter2_DefineConstant2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedWriter2_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedWriter3_INTERFACE_DEFINED__
#define __ISymUnmanagedWriter3_INTERFACE_DEFINED__

/* interface ISymUnmanagedWriter3 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedWriter3;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12F1E02C-1E05-4B0E-9468-EBC9D1BB040F")
    ISymUnmanagedWriter3 : public ISymUnmanagedWriter2
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenMethod2( 
            /* [in] */ mdMethodDef method,
            /* [in] */ ULONG32 isect,
            /* [in] */ ULONG32 offset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedWriter3Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedWriter3 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedWriter3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DefineDocument )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ const WCHAR *url,
            /* [in] */ const GUID *language,
            /* [in] */ const GUID *languageVendor,
            /* [in] */ const GUID *documentType,
            /* [retval][out] */ ISymUnmanagedDocumentWriter **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *SetUserEntryPoint )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ mdMethodDef entryMethod);
        
        HRESULT ( STDMETHODCALLTYPE *OpenMethod )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ mdMethodDef method);
        
        HRESULT ( STDMETHODCALLTYPE *CloseMethod )( 
            ISymUnmanagedWriter3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenScope )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ ULONG32 startOffset,
            /* [retval][out] */ ULONG32 *pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *CloseScope )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *SetScopeRange )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ ULONG32 scopeID,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineLocalVariable )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineParameter )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 sequence,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineField )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ mdTypeDef parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineGlobalVariable )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ],
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *Close )( 
            ISymUnmanagedWriter3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetSymAttribute )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ mdToken parent,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 cData,
            /* [size_is][in] */ unsigned char data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *OpenNamespace )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ const WCHAR *name);
        
        HRESULT ( STDMETHODCALLTYPE *CloseNamespace )( 
            ISymUnmanagedWriter3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *UsingNamespace )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ const WCHAR *fullName);
        
        HRESULT ( STDMETHODCALLTYPE *SetMethodSourceRange )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ ISymUnmanagedDocumentWriter *startDoc,
            /* [in] */ ULONG32 startLine,
            /* [in] */ ULONG32 startColumn,
            /* [in] */ ISymUnmanagedDocumentWriter *endDoc,
            /* [in] */ ULONG32 endLine,
            /* [in] */ ULONG32 endColumn);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild);
        
        HRESULT ( STDMETHODCALLTYPE *GetDebugInfo )( 
            ISymUnmanagedWriter3 * This,
            /* [out][in] */ IMAGE_DEBUG_DIRECTORY *pIDD,
            /* [in] */ DWORD cData,
            /* [out] */ DWORD *pcData,
            /* [length_is][size_is][out] */ BYTE data[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DefineSequencePoints )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ ISymUnmanagedDocumentWriter *document,
            /* [in] */ ULONG32 spCount,
            /* [size_is][in] */ ULONG32 offsets[  ],
            /* [size_is][in] */ ULONG32 lines[  ],
            /* [size_is][in] */ ULONG32 columns[  ],
            /* [size_is][in] */ ULONG32 endLines[  ],
            /* [size_is][in] */ ULONG32 endColumns[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RemapToken )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ mdToken oldToken,
            /* [in] */ mdToken newToken);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize2 )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ IUnknown *emitter,
            /* [in] */ const WCHAR *tempfilename,
            /* [in] */ IStream *pIStream,
            /* [in] */ BOOL fFullBuild,
            /* [in] */ const WCHAR *finalfilename);
        
        HRESULT ( STDMETHODCALLTYPE *DefineConstant )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ VARIANT value,
            /* [in] */ ULONG32 cSig,
            /* [size_is][in] */ unsigned char signature[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ISymUnmanagedWriter3 * This);
        
        HRESULT ( STDMETHODCALLTYPE *DefineLocalVariable2 )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ mdSignature sigToken,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3,
            /* [in] */ ULONG32 startOffset,
            /* [in] */ ULONG32 endOffset);
        
        HRESULT ( STDMETHODCALLTYPE *DefineGlobalVariable2 )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ ULONG32 attributes,
            /* [in] */ mdSignature sigToken,
            /* [in] */ ULONG32 addrKind,
            /* [in] */ ULONG32 addr1,
            /* [in] */ ULONG32 addr2,
            /* [in] */ ULONG32 addr3);
        
        HRESULT ( STDMETHODCALLTYPE *DefineConstant2 )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ const WCHAR *name,
            /* [in] */ VARIANT value,
            /* [in] */ mdSignature sigToken);
        
        HRESULT ( STDMETHODCALLTYPE *OpenMethod2 )( 
            ISymUnmanagedWriter3 * This,
            /* [in] */ mdMethodDef method,
            /* [in] */ ULONG32 isect,
            /* [in] */ ULONG32 offset);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            ISymUnmanagedWriter3 * This);
        
        END_INTERFACE
    } ISymUnmanagedWriter3Vtbl;

    interface ISymUnmanagedWriter3
    {
        CONST_VTBL struct ISymUnmanagedWriter3Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedWriter3_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedWriter3_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedWriter3_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedWriter3_DefineDocument(This,url,language,languageVendor,documentType,pRetVal)	\
    (This)->lpVtbl -> DefineDocument(This,url,language,languageVendor,documentType,pRetVal)

#define ISymUnmanagedWriter3_SetUserEntryPoint(This,entryMethod)	\
    (This)->lpVtbl -> SetUserEntryPoint(This,entryMethod)

#define ISymUnmanagedWriter3_OpenMethod(This,method)	\
    (This)->lpVtbl -> OpenMethod(This,method)

#define ISymUnmanagedWriter3_CloseMethod(This)	\
    (This)->lpVtbl -> CloseMethod(This)

#define ISymUnmanagedWriter3_OpenScope(This,startOffset,pRetVal)	\
    (This)->lpVtbl -> OpenScope(This,startOffset,pRetVal)

#define ISymUnmanagedWriter3_CloseScope(This,endOffset)	\
    (This)->lpVtbl -> CloseScope(This,endOffset)

#define ISymUnmanagedWriter3_SetScopeRange(This,scopeID,startOffset,endOffset)	\
    (This)->lpVtbl -> SetScopeRange(This,scopeID,startOffset,endOffset)

#define ISymUnmanagedWriter3_DefineLocalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3,startOffset,endOffset)	\
    (This)->lpVtbl -> DefineLocalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3,startOffset,endOffset)

#define ISymUnmanagedWriter3_DefineParameter(This,name,attributes,sequence,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineParameter(This,name,attributes,sequence,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter3_DefineField(This,parent,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineField(This,parent,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter3_DefineGlobalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineGlobalVariable(This,name,attributes,cSig,signature,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter3_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define ISymUnmanagedWriter3_SetSymAttribute(This,parent,name,cData,data)	\
    (This)->lpVtbl -> SetSymAttribute(This,parent,name,cData,data)

#define ISymUnmanagedWriter3_OpenNamespace(This,name)	\
    (This)->lpVtbl -> OpenNamespace(This,name)

#define ISymUnmanagedWriter3_CloseNamespace(This)	\
    (This)->lpVtbl -> CloseNamespace(This)

#define ISymUnmanagedWriter3_UsingNamespace(This,fullName)	\
    (This)->lpVtbl -> UsingNamespace(This,fullName)

#define ISymUnmanagedWriter3_SetMethodSourceRange(This,startDoc,startLine,startColumn,endDoc,endLine,endColumn)	\
    (This)->lpVtbl -> SetMethodSourceRange(This,startDoc,startLine,startColumn,endDoc,endLine,endColumn)

#define ISymUnmanagedWriter3_Initialize(This,emitter,filename,pIStream,fFullBuild)	\
    (This)->lpVtbl -> Initialize(This,emitter,filename,pIStream,fFullBuild)

#define ISymUnmanagedWriter3_GetDebugInfo(This,pIDD,cData,pcData,data)	\
    (This)->lpVtbl -> GetDebugInfo(This,pIDD,cData,pcData,data)

#define ISymUnmanagedWriter3_DefineSequencePoints(This,document,spCount,offsets,lines,columns,endLines,endColumns)	\
    (This)->lpVtbl -> DefineSequencePoints(This,document,spCount,offsets,lines,columns,endLines,endColumns)

#define ISymUnmanagedWriter3_RemapToken(This,oldToken,newToken)	\
    (This)->lpVtbl -> RemapToken(This,oldToken,newToken)

#define ISymUnmanagedWriter3_Initialize2(This,emitter,tempfilename,pIStream,fFullBuild,finalfilename)	\
    (This)->lpVtbl -> Initialize2(This,emitter,tempfilename,pIStream,fFullBuild,finalfilename)

#define ISymUnmanagedWriter3_DefineConstant(This,name,value,cSig,signature)	\
    (This)->lpVtbl -> DefineConstant(This,name,value,cSig,signature)

#define ISymUnmanagedWriter3_Abort(This)	\
    (This)->lpVtbl -> Abort(This)


#define ISymUnmanagedWriter3_DefineLocalVariable2(This,name,attributes,sigToken,addrKind,addr1,addr2,addr3,startOffset,endOffset)	\
    (This)->lpVtbl -> DefineLocalVariable2(This,name,attributes,sigToken,addrKind,addr1,addr2,addr3,startOffset,endOffset)

#define ISymUnmanagedWriter3_DefineGlobalVariable2(This,name,attributes,sigToken,addrKind,addr1,addr2,addr3)	\
    (This)->lpVtbl -> DefineGlobalVariable2(This,name,attributes,sigToken,addrKind,addr1,addr2,addr3)

#define ISymUnmanagedWriter3_DefineConstant2(This,name,value,sigToken)	\
    (This)->lpVtbl -> DefineConstant2(This,name,value,sigToken)


#define ISymUnmanagedWriter3_OpenMethod2(This,method,isect,offset)	\
    (This)->lpVtbl -> OpenMethod2(This,method,isect,offset)

#define ISymUnmanagedWriter3_Commit(This)	\
    (This)->lpVtbl -> Commit(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter3_OpenMethod2_Proxy( 
    ISymUnmanagedWriter3 * This,
    /* [in] */ mdMethodDef method,
    /* [in] */ ULONG32 isect,
    /* [in] */ ULONG32 offset);


void __RPC_STUB ISymUnmanagedWriter3_OpenMethod2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedWriter3_Commit_Proxy( 
    ISymUnmanagedWriter3 * This);


void __RPC_STUB ISymUnmanagedWriter3_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedWriter3_INTERFACE_DEFINED__ */


#ifndef __ISymUnmanagedReader2_INTERFACE_DEFINED__
#define __ISymUnmanagedReader2_INTERFACE_DEFINED__

/* interface ISymUnmanagedReader2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ISymUnmanagedReader2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A09E53B2-2A57-4cca-8F63-B84F7C35D4AA")
    ISymUnmanagedReader2 : public ISymUnmanagedReader
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMethodByVersionPreRemap( 
            /* [in] */ mdMethodDef token,
            /* [in] */ int version,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSymAttributePreRemap( 
            /* [in] */ mdToken parent,
            /* [in] */ WCHAR *name,
            /* [in] */ ULONG32 cBuffer,
            /* [out] */ ULONG32 *pcBuffer,
            /* [length_is][size_is][out] */ BYTE buffer[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMethodsInDocument( 
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 cMethod,
            /* [out] */ ULONG32 *pcMethod,
            /* [length_is][size_is][out] */ ISymUnmanagedMethod *pRetVal[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISymUnmanagedReader2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISymUnmanagedReader2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISymUnmanagedReader2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocument )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ WCHAR *url,
            /* [in] */ GUID language,
            /* [in] */ GUID languageVendor,
            /* [in] */ GUID documentType,
            /* [retval][out] */ ISymUnmanagedDocument **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocuments )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ ULONG32 cDocs,
            /* [out] */ ULONG32 *pcDocs,
            /* [length_is][size_is][out] */ ISymUnmanagedDocument *pDocs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetUserEntryPoint )( 
            ISymUnmanagedReader2 * This,
            /* [retval][out] */ mdMethodDef *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethod )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ mdMethodDef token,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodByVersion )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ mdMethodDef token,
            /* [in] */ int version,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetVariables )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ mdToken parent,
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetGlobalVariables )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ ULONG32 cVars,
            /* [out] */ ULONG32 *pcVars,
            /* [length_is][size_is][out] */ ISymUnmanagedVariable *pVars[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodFromDocumentPosition )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymAttribute )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ mdToken parent,
            /* [in] */ WCHAR *name,
            /* [in] */ ULONG32 cBuffer,
            /* [out] */ ULONG32 *pcBuffer,
            /* [length_is][size_is][out] */ BYTE buffer[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetNamespaces )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ ULONG32 cNameSpaces,
            /* [out] */ ULONG32 *pcNameSpaces,
            /* [length_is][size_is][out] */ ISymUnmanagedNamespace *namespaces[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ IUnknown *importer,
            /* [in] */ const WCHAR *filename,
            /* [in] */ const WCHAR *searchPath,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *UpdateSymbolStore )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *ReplaceSymbolStore )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ const WCHAR *filename,
            /* [in] */ IStream *pIStream);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymbolStoreFileName )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ ULONG32 cchName,
            /* [out] */ ULONG32 *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodsFromDocumentPosition )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 line,
            /* [in] */ ULONG32 column,
            /* [in] */ ULONG32 cMethod,
            /* [out] */ ULONG32 *pcMethod,
            /* [length_is][size_is][out] */ ISymUnmanagedMethod *pRetVal[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetDocumentVersion )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ ISymUnmanagedDocument *pDoc,
            /* [out] */ int *version,
            /* [out] */ BOOL *pbCurrent);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodVersion )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ ISymUnmanagedMethod *pMethod,
            /* [out] */ int *version);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodByVersionPreRemap )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ mdMethodDef token,
            /* [in] */ int version,
            /* [retval][out] */ ISymUnmanagedMethod **pRetVal);
        
        HRESULT ( STDMETHODCALLTYPE *GetSymAttributePreRemap )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ mdToken parent,
            /* [in] */ WCHAR *name,
            /* [in] */ ULONG32 cBuffer,
            /* [out] */ ULONG32 *pcBuffer,
            /* [length_is][size_is][out] */ BYTE buffer[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetMethodsInDocument )( 
            ISymUnmanagedReader2 * This,
            /* [in] */ ISymUnmanagedDocument *document,
            /* [in] */ ULONG32 cMethod,
            /* [out] */ ULONG32 *pcMethod,
            /* [length_is][size_is][out] */ ISymUnmanagedMethod *pRetVal[  ]);
        
        END_INTERFACE
    } ISymUnmanagedReader2Vtbl;

    interface ISymUnmanagedReader2
    {
        CONST_VTBL struct ISymUnmanagedReader2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISymUnmanagedReader2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISymUnmanagedReader2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISymUnmanagedReader2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISymUnmanagedReader2_GetDocument(This,url,language,languageVendor,documentType,pRetVal)	\
    (This)->lpVtbl -> GetDocument(This,url,language,languageVendor,documentType,pRetVal)

#define ISymUnmanagedReader2_GetDocuments(This,cDocs,pcDocs,pDocs)	\
    (This)->lpVtbl -> GetDocuments(This,cDocs,pcDocs,pDocs)

#define ISymUnmanagedReader2_GetUserEntryPoint(This,pToken)	\
    (This)->lpVtbl -> GetUserEntryPoint(This,pToken)

#define ISymUnmanagedReader2_GetMethod(This,token,pRetVal)	\
    (This)->lpVtbl -> GetMethod(This,token,pRetVal)

#define ISymUnmanagedReader2_GetMethodByVersion(This,token,version,pRetVal)	\
    (This)->lpVtbl -> GetMethodByVersion(This,token,version,pRetVal)

#define ISymUnmanagedReader2_GetVariables(This,parent,cVars,pcVars,pVars)	\
    (This)->lpVtbl -> GetVariables(This,parent,cVars,pcVars,pVars)

#define ISymUnmanagedReader2_GetGlobalVariables(This,cVars,pcVars,pVars)	\
    (This)->lpVtbl -> GetGlobalVariables(This,cVars,pcVars,pVars)

#define ISymUnmanagedReader2_GetMethodFromDocumentPosition(This,document,line,column,pRetVal)	\
    (This)->lpVtbl -> GetMethodFromDocumentPosition(This,document,line,column,pRetVal)

#define ISymUnmanagedReader2_GetSymAttribute(This,parent,name,cBuffer,pcBuffer,buffer)	\
    (This)->lpVtbl -> GetSymAttribute(This,parent,name,cBuffer,pcBuffer,buffer)

#define ISymUnmanagedReader2_GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)	\
    (This)->lpVtbl -> GetNamespaces(This,cNameSpaces,pcNameSpaces,namespaces)

#define ISymUnmanagedReader2_Initialize(This,importer,filename,searchPath,pIStream)	\
    (This)->lpVtbl -> Initialize(This,importer,filename,searchPath,pIStream)

#define ISymUnmanagedReader2_UpdateSymbolStore(This,filename,pIStream)	\
    (This)->lpVtbl -> UpdateSymbolStore(This,filename,pIStream)

#define ISymUnmanagedReader2_ReplaceSymbolStore(This,filename,pIStream)	\
    (This)->lpVtbl -> ReplaceSymbolStore(This,filename,pIStream)

#define ISymUnmanagedReader2_GetSymbolStoreFileName(This,cchName,pcchName,szName)	\
    (This)->lpVtbl -> GetSymbolStoreFileName(This,cchName,pcchName,szName)

#define ISymUnmanagedReader2_GetMethodsFromDocumentPosition(This,document,line,column,cMethod,pcMethod,pRetVal)	\
    (This)->lpVtbl -> GetMethodsFromDocumentPosition(This,document,line,column,cMethod,pcMethod,pRetVal)

#define ISymUnmanagedReader2_GetDocumentVersion(This,pDoc,version,pbCurrent)	\
    (This)->lpVtbl -> GetDocumentVersion(This,pDoc,version,pbCurrent)

#define ISymUnmanagedReader2_GetMethodVersion(This,pMethod,version)	\
    (This)->lpVtbl -> GetMethodVersion(This,pMethod,version)


#define ISymUnmanagedReader2_GetMethodByVersionPreRemap(This,token,version,pRetVal)	\
    (This)->lpVtbl -> GetMethodByVersionPreRemap(This,token,version,pRetVal)

#define ISymUnmanagedReader2_GetSymAttributePreRemap(This,parent,name,cBuffer,pcBuffer,buffer)	\
    (This)->lpVtbl -> GetSymAttributePreRemap(This,parent,name,cBuffer,pcBuffer,buffer)

#define ISymUnmanagedReader2_GetMethodsInDocument(This,document,cMethod,pcMethod,pRetVal)	\
    (This)->lpVtbl -> GetMethodsInDocument(This,document,cMethod,pcMethod,pRetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISymUnmanagedReader2_GetMethodByVersionPreRemap_Proxy( 
    ISymUnmanagedReader2 * This,
    /* [in] */ mdMethodDef token,
    /* [in] */ int version,
    /* [retval][out] */ ISymUnmanagedMethod **pRetVal);


void __RPC_STUB ISymUnmanagedReader2_GetMethodByVersionPreRemap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader2_GetSymAttributePreRemap_Proxy( 
    ISymUnmanagedReader2 * This,
    /* [in] */ mdToken parent,
    /* [in] */ WCHAR *name,
    /* [in] */ ULONG32 cBuffer,
    /* [out] */ ULONG32 *pcBuffer,
    /* [length_is][size_is][out] */ BYTE buffer[  ]);


void __RPC_STUB ISymUnmanagedReader2_GetSymAttributePreRemap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISymUnmanagedReader2_GetMethodsInDocument_Proxy( 
    ISymUnmanagedReader2 * This,
    /* [in] */ ISymUnmanagedDocument *document,
    /* [in] */ ULONG32 cMethod,
    /* [out] */ ULONG32 *pcMethod,
    /* [length_is][size_is][out] */ ISymUnmanagedMethod *pRetVal[  ]);


void __RPC_STUB ISymUnmanagedReader2_GetMethodsInDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISymUnmanagedReader2_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\corprof.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for corprof.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __corprof_h__
#define __corprof_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICorProfilerCallback_FWD_DEFINED__
#define __ICorProfilerCallback_FWD_DEFINED__
typedef interface ICorProfilerCallback ICorProfilerCallback;
#endif 	/* __ICorProfilerCallback_FWD_DEFINED__ */


#ifndef __ICorProfilerCallback2_FWD_DEFINED__
#define __ICorProfilerCallback2_FWD_DEFINED__
typedef interface ICorProfilerCallback2 ICorProfilerCallback2;
#endif 	/* __ICorProfilerCallback2_FWD_DEFINED__ */


#ifndef __ICorProfilerInfo_FWD_DEFINED__
#define __ICorProfilerInfo_FWD_DEFINED__
typedef interface ICorProfilerInfo ICorProfilerInfo;
#endif 	/* __ICorProfilerInfo_FWD_DEFINED__ */


#ifndef __ICorProfilerInfo2_FWD_DEFINED__
#define __ICorProfilerInfo2_FWD_DEFINED__
typedef interface ICorProfilerInfo2 ICorProfilerInfo2;
#endif 	/* __ICorProfilerInfo2_FWD_DEFINED__ */


#ifndef __ICorProfilerObjectEnum_FWD_DEFINED__
#define __ICorProfilerObjectEnum_FWD_DEFINED__
typedef interface ICorProfilerObjectEnum ICorProfilerObjectEnum;
#endif 	/* __ICorProfilerObjectEnum_FWD_DEFINED__ */


#ifndef __IMethodMalloc_FWD_DEFINED__
#define __IMethodMalloc_FWD_DEFINED__
typedef interface IMethodMalloc IMethodMalloc;
#endif 	/* __IMethodMalloc_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_corprof_0000 */
/* [local] */ 

#define PROFILER_REGKEY_ROOT            L"software\\microsoft\\.NETFramework\\Profilers"
#define PROFILER_REGVALUE_HELPSTRING    L"HelpString"
#define PROFILER_REGVALUE_PROFID        L"ProfilerID"
#define CorDB_CONTROL_Profiling         "Cor_Enable_Profiling"
#define CorDB_CONTROL_ProfilingL       L"Cor_Enable_Profiling"
#if 0
typedef LONG32 mdToken;

typedef mdToken mdModule;

typedef mdToken mdTypeDef;

typedef mdToken mdMethodDef;

typedef mdToken mdFieldDef;

typedef ULONG CorElementType;


#endif
typedef const BYTE *LPCBYTE;

typedef BYTE *LPBYTE;

#ifndef _COR_IL_MAP
#define _COR_IL_MAP
typedef struct _COR_IL_MAP
    {
    ULONG32 oldOffset;
    ULONG32 newOffset;
    BOOL fAccurate;
    } 	COR_IL_MAP;

#endif //_COR_IL_MAP
#ifndef _COR_DEBUG_IL_TO_NATIVE_MAP_
#define _COR_DEBUG_IL_TO_NATIVE_MAP_
typedef 
enum CorDebugIlToNativeMappingTypes
    {	NO_MAPPING	= -1,
	PROLOG	= -2,
	EPILOG	= -3
    } 	CorDebugIlToNativeMappingTypes;

typedef struct COR_DEBUG_IL_TO_NATIVE_MAP
    {
    ULONG32 ilOffset;
    ULONG32 nativeStartOffset;
    ULONG32 nativeEndOffset;
    } 	COR_DEBUG_IL_TO_NATIVE_MAP;

#endif // _COR_DEBUG_IL_TO_NATIVE_MAP_
#ifndef _COR_FIELD_OFFSET_
#define _COR_FIELD_OFFSET_
typedef struct _COR_FIELD_OFFSET
    {
    mdFieldDef ridOfField;
    ULONG ulOffset;
    } 	COR_FIELD_OFFSET;

#endif // _COR_FIELD_OFFSET_
typedef UINT_PTR ProcessID;

typedef UINT_PTR AssemblyID;

typedef UINT_PTR AppDomainID;

typedef UINT_PTR ModuleID;

typedef UINT_PTR ClassID;

typedef UINT_PTR ThreadID;

typedef UINT_PTR ContextID;

typedef UINT_PTR FunctionID;

typedef UINT_PTR ObjectID;

typedef UINT_PTR GCHandleID;

typedef UINT_PTR __stdcall __stdcall FunctionIDMapper( 
    FunctionID funcId,
    BOOL *pbHookFunction);

typedef 
enum _COR_PRF_SNAPSHOT_INFO
    {	COR_PRF_SNAPSHOT_DEFAULT	= 0,
	COR_PRF_SNAPSHOT_REGISTER_CONTEXT	= 0x1
    } 	COR_PRF_SNAPSHOT_INFO;

typedef UINT_PTR COR_PRF_FRAME_INFO;

typedef struct _COR_PRF_FUNCTION_ARGUMENT_RANGE
    {
    UINT_PTR startAddress;
    ULONG length;
    } 	COR_PRF_FUNCTION_ARGUMENT_RANGE;

typedef struct _COR_PRF_FUNCTION_ARGUMENT_INFO
    {
    ULONG numRanges;
    ULONG totalArgumentSize;
    COR_PRF_FUNCTION_ARGUMENT_RANGE ranges[ 1 ];
    } 	COR_PRF_FUNCTION_ARGUMENT_INFO;

typedef struct _COR_PRF_CODE_INFO
    {
    UINT_PTR startAddress;
    SIZE_T size;
    } 	COR_PRF_CODE_INFO;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0001
    {	COR_PRF_FIELD_NOT_A_STATIC	= 0,
	COR_PRF_FIELD_APP_DOMAIN_STATIC	= 0x1,
	COR_PRF_FIELD_THREAD_STATIC	= 0x2,
	COR_PRF_FIELD_CONTEXT_STATIC	= 0x4,
	COR_PRF_FIELD_RVA_STATIC	= 0x8
    } 	COR_PRF_STATIC_TYPE;

typedef void FunctionEnter( 
    FunctionID funcID);

typedef void FunctionLeave( 
    FunctionID funcID);

typedef void FunctionTailcall( 
    FunctionID funcID);

typedef void FunctionEnter2( 
    FunctionID funcId,
    UINT_PTR clientData,
    COR_PRF_FRAME_INFO func,
    COR_PRF_FUNCTION_ARGUMENT_INFO *argumentInfo);

typedef void FunctionLeave2( 
    FunctionID funcId,
    UINT_PTR clientData,
    COR_PRF_FRAME_INFO func,
    COR_PRF_FUNCTION_ARGUMENT_RANGE *retvalRange);

typedef void FunctionTailcall2( 
    FunctionID funcId,
    UINT_PTR clientData,
    COR_PRF_FRAME_INFO func);

typedef HRESULT __stdcall __stdcall StackSnapshotCallback( 
    FunctionID funcId,
    UINT_PTR ip,
    COR_PRF_FRAME_INFO frameInfo,
    ULONG32 contextSize,
    BYTE context[  ],
    void *clientData);

typedef /* [public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0002
    {	COR_PRF_MONITOR_NONE	= 0,
	COR_PRF_MONITOR_FUNCTION_UNLOADS	= 0x1,
	COR_PRF_MONITOR_CLASS_LOADS	= 0x2,
	COR_PRF_MONITOR_MODULE_LOADS	= 0x4,
	COR_PRF_MONITOR_ASSEMBLY_LOADS	= 0x8,
	COR_PRF_MONITOR_APPDOMAIN_LOADS	= 0x10,
	COR_PRF_MONITOR_JIT_COMPILATION	= 0x20,
	COR_PRF_MONITOR_EXCEPTIONS	= 0x40,
	COR_PRF_MONITOR_GC	= 0x80,
	COR_PRF_MONITOR_OBJECT_ALLOCATED	= 0x100,
	COR_PRF_MONITOR_THREADS	= 0x200,
	COR_PRF_MONITOR_REMOTING	= 0x400,
	COR_PRF_MONITOR_CODE_TRANSITIONS	= 0x800,
	COR_PRF_MONITOR_ENTERLEAVE	= 0x1000,
	COR_PRF_MONITOR_CCW	= 0x2000,
	COR_PRF_MONITOR_REMOTING_COOKIE	= 0x4000 | COR_PRF_MONITOR_REMOTING,
	COR_PRF_MONITOR_REMOTING_ASYNC	= 0x8000 | COR_PRF_MONITOR_REMOTING,
	COR_PRF_MONITOR_SUSPENDS	= 0x10000,
	COR_PRF_MONITOR_CACHE_SEARCHES	= 0x20000,
	COR_PRF_MONITOR_CLR_EXCEPTIONS	= 0x1000000,
	COR_PRF_MONITOR_ALL	= 0x107ffff,
	COR_PRF_ENABLE_REJIT	= 0x40000,
	COR_PRF_ENABLE_INPROC_DEBUGGING	= 0x80000,
	COR_PRF_ENABLE_JIT_MAPS	= 0x100000,
	COR_PRF_DISABLE_INLINING	= 0x200000,
	COR_PRF_DISABLE_OPTIMIZATIONS	= 0x400000,
	COR_PRF_ENABLE_OBJECT_ALLOCATED	= 0x800000,
	COR_PRF_ENABLE_FUNCTION_ARGS	= 0x2000000,
	COR_PRF_ENABLE_FUNCTION_RETVAL	= 0x4000000,
	COR_PRF_ENABLE_FRAME_INFO	= 0x8000000,
	COR_PRF_ENABLE_STACK_SNAPSHOT	= 0x10000000,
	COR_PRF_USE_PROFILE_IMAGES	= 0x20000000,
	COR_PRF_ALL	= 0x3fffffff,
	COR_PRF_MONITOR_IMMUTABLE	= COR_PRF_MONITOR_CODE_TRANSITIONS | COR_PRF_MONITOR_REMOTING | COR_PRF_MONITOR_REMOTING_COOKIE | COR_PRF_MONITOR_REMOTING_ASYNC | COR_PRF_MONITOR_GC | COR_PRF_ENABLE_REJIT | COR_PRF_ENABLE_INPROC_DEBUGGING | COR_PRF_ENABLE_JIT_MAPS | COR_PRF_DISABLE_OPTIMIZATIONS | COR_PRF_DISABLE_INLINING | COR_PRF_ENABLE_OBJECT_ALLOCATED | COR_PRF_ENABLE_FUNCTION_ARGS | COR_PRF_ENABLE_FUNCTION_RETVAL | COR_PRF_ENABLE_FRAME_INFO | COR_PRF_ENABLE_STACK_SNAPSHOT | COR_PRF_USE_PROFILE_IMAGES
    } 	COR_PRF_MONITOR;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0003
    {	PROFILER_PARENT_UNKNOWN	= 0xfffffffd,
	PROFILER_GLOBAL_CLASS	= 0xfffffffe,
	PROFILER_GLOBAL_MODULE	= 0xffffffff
    } 	COR_PRF_MISC;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0004
    {	COR_PRF_CACHED_FUNCTION_FOUND	= 0,
	COR_PRF_CACHED_FUNCTION_NOT_FOUND	= COR_PRF_CACHED_FUNCTION_FOUND + 1
    } 	COR_PRF_JIT_CACHE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0005
    {	COR_PRF_TRANSITION_CALL	= 0,
	COR_PRF_TRANSITION_RETURN	= COR_PRF_TRANSITION_CALL + 1
    } 	COR_PRF_TRANSITION_REASON;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0000_0006
    {	COR_PRF_SUSPEND_OTHER	= 0,
	COR_PRF_SUSPEND_FOR_GC	= 1,
	COR_PRF_SUSPEND_FOR_APPDOMAIN_SHUTDOWN	= 2,
	COR_PRF_SUSPEND_FOR_CODE_PITCHING	= 3,
	COR_PRF_SUSPEND_FOR_SHUTDOWN	= 4,
	COR_PRF_SUSPEND_FOR_INPROC_DEBUGGER	= 6,
	COR_PRF_SUSPEND_FOR_GC_PREP	= 7
    } 	COR_PRF_SUSPEND_REASON;









extern RPC_IF_HANDLE __MIDL_itf_corprof_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corprof_0000_v0_0_s_ifspec;

#ifndef __ICorProfilerCallback_INTERFACE_DEFINED__
#define __ICorProfilerCallback_INTERFACE_DEFINED__

/* interface ICorProfilerCallback */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorProfilerCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("176FBED1-A55C-4796-98CA-A9DA0EF883E7")
    ICorProfilerCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ IUnknown *pICorProfilerInfoUnk) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppDomainCreationStarted( 
            /* [in] */ AppDomainID appDomainId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppDomainCreationFinished( 
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppDomainShutdownStarted( 
            /* [in] */ AppDomainID appDomainId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AppDomainShutdownFinished( 
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssemblyLoadStarted( 
            /* [in] */ AssemblyID assemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssemblyLoadFinished( 
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssemblyUnloadStarted( 
            /* [in] */ AssemblyID assemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssemblyUnloadFinished( 
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleLoadStarted( 
            /* [in] */ ModuleID moduleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleLoadFinished( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleUnloadStarted( 
            /* [in] */ ModuleID moduleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleUnloadFinished( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ModuleAttachedToAssembly( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ AssemblyID AssemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassLoadStarted( 
            /* [in] */ ClassID classId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassLoadFinished( 
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassUnloadStarted( 
            /* [in] */ ClassID classId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClassUnloadFinished( 
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FunctionUnloadStarted( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITCompilationStarted( 
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fIsSafeToBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITCompilationFinished( 
            /* [in] */ FunctionID functionId,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ BOOL fIsSafeToBlock) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITCachedFunctionSearchStarted( 
            /* [in] */ FunctionID functionId,
            /* [out] */ BOOL *pbUseCachedFunction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITCachedFunctionSearchFinished( 
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_JIT_CACHE result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITFunctionPitched( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE JITInlining( 
            /* [in] */ FunctionID callerId,
            /* [in] */ FunctionID calleeId,
            /* [out] */ BOOL *pfShouldInline) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadCreated( 
            /* [in] */ ThreadID threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadDestroyed( 
            /* [in] */ ThreadID threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ThreadAssignedToOSThread( 
            /* [in] */ ThreadID managedThreadId,
            /* [in] */ DWORD osThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingClientInvocationStarted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingClientSendingMessage( 
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingClientReceivingReply( 
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingClientInvocationFinished( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingServerReceivingMessage( 
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingServerInvocationStarted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingServerInvocationReturned( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemotingServerSendingReply( 
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmanagedToManagedTransition( 
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ManagedToUnmanagedTransition( 
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeSuspendStarted( 
            /* [in] */ COR_PRF_SUSPEND_REASON suspendReason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeSuspendFinished( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeSuspendAborted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeResumeStarted( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeResumeFinished( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeThreadSuspended( 
            /* [in] */ ThreadID threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RuntimeThreadResumed( 
            /* [in] */ ThreadID threadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MovedReferences( 
            /* [in] */ ULONG cMovedObjectIDRanges,
            /* [size_is][in] */ ObjectID oldObjectIDRangeStart[  ],
            /* [size_is][in] */ ObjectID newObjectIDRangeStart[  ],
            /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjectAllocated( 
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjectsAllocatedByClass( 
            /* [in] */ ULONG cClassCount,
            /* [size_is][in] */ ClassID classIds[  ],
            /* [size_is][in] */ ULONG cObjects[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ObjectReferences( 
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId,
            /* [in] */ ULONG cObjectRefs,
            /* [size_is][in] */ ObjectID objectRefIds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RootReferences( 
            /* [in] */ ULONG cRootRefs,
            /* [size_is][in] */ ObjectID rootRefIds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionThrown( 
            /* [in] */ ObjectID thrownObjectId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchFunctionEnter( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchFunctionLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchFilterEnter( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchFilterLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionSearchCatcherFound( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionOSHandlerEnter( 
            /* [in] */ UINT_PTR __unused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionOSHandlerLeave( 
            /* [in] */ UINT_PTR __unused) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwindFunctionEnter( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwindFunctionLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwindFinallyEnter( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionUnwindFinallyLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionCatcherEnter( 
            /* [in] */ FunctionID functionId,
            /* [in] */ ObjectID objectId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionCatcherLeave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE COMClassicVTableCreated( 
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable,
            /* [in] */ ULONG cSlots) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE COMClassicVTableDestroyed( 
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionCLRCatcherFound( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExceptionCLRCatcherExecute( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorProfilerCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorProfilerCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorProfilerCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICorProfilerCallback * This,
            /* [in] */ IUnknown *pICorProfilerInfoUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainCreationStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ AppDomainID appDomainId);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainCreationFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainShutdownStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ AppDomainID appDomainId);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainShutdownFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyLoadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ AssemblyID assemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyLoadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyUnloadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ AssemblyID assemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyUnloadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleLoadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleLoadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleUnloadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleUnloadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleAttachedToAssembly )( 
            ICorProfilerCallback * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ AssemblyID AssemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassLoadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassLoadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ClassUnloadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassUnloadFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *FunctionUnloadStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *JITCompilationStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fIsSafeToBlock);
        
        HRESULT ( STDMETHODCALLTYPE *JITCompilationFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ BOOL fIsSafeToBlock);
        
        HRESULT ( STDMETHODCALLTYPE *JITCachedFunctionSearchStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ BOOL *pbUseCachedFunction);
        
        HRESULT ( STDMETHODCALLTYPE *JITCachedFunctionSearchFinished )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_JIT_CACHE result);
        
        HRESULT ( STDMETHODCALLTYPE *JITFunctionPitched )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *JITInlining )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID callerId,
            /* [in] */ FunctionID calleeId,
            /* [out] */ BOOL *pfShouldInline);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadCreated )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadDestroyed )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadAssignedToOSThread )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID managedThreadId,
            /* [in] */ DWORD osThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientInvocationStarted )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientSendingMessage )( 
            ICorProfilerCallback * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientReceivingReply )( 
            ICorProfilerCallback * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientInvocationFinished )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerReceivingMessage )( 
            ICorProfilerCallback * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerInvocationStarted )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerInvocationReturned )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerSendingReply )( 
            ICorProfilerCallback * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *UnmanagedToManagedTransition )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason);
        
        HRESULT ( STDMETHODCALLTYPE *ManagedToUnmanagedTransition )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendStarted )( 
            ICorProfilerCallback * This,
            /* [in] */ COR_PRF_SUSPEND_REASON suspendReason);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendFinished )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendAborted )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeResumeStarted )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeResumeFinished )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeThreadSuspended )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeThreadResumed )( 
            ICorProfilerCallback * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *MovedReferences )( 
            ICorProfilerCallback * This,
            /* [in] */ ULONG cMovedObjectIDRanges,
            /* [size_is][in] */ ObjectID oldObjectIDRangeStart[  ],
            /* [size_is][in] */ ObjectID newObjectIDRangeStart[  ],
            /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectAllocated )( 
            ICorProfilerCallback * This,
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectsAllocatedByClass )( 
            ICorProfilerCallback * This,
            /* [in] */ ULONG cClassCount,
            /* [size_is][in] */ ClassID classIds[  ],
            /* [size_is][in] */ ULONG cObjects[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectReferences )( 
            ICorProfilerCallback * This,
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId,
            /* [in] */ ULONG cObjectRefs,
            /* [size_is][in] */ ObjectID objectRefIds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RootReferences )( 
            ICorProfilerCallback * This,
            /* [in] */ ULONG cRootRefs,
            /* [size_is][in] */ ObjectID rootRefIds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionThrown )( 
            ICorProfilerCallback * This,
            /* [in] */ ObjectID thrownObjectId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFunctionEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFunctionLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFilterEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFilterLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchCatcherFound )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionOSHandlerEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ UINT_PTR __unused);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionOSHandlerLeave )( 
            ICorProfilerCallback * This,
            /* [in] */ UINT_PTR __unused);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFunctionEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFunctionLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFinallyEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFinallyLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCatcherEnter )( 
            ICorProfilerCallback * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ ObjectID objectId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCatcherLeave )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *COMClassicVTableCreated )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable,
            /* [in] */ ULONG cSlots);
        
        HRESULT ( STDMETHODCALLTYPE *COMClassicVTableDestroyed )( 
            ICorProfilerCallback * This,
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCLRCatcherFound )( 
            ICorProfilerCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCLRCatcherExecute )( 
            ICorProfilerCallback * This);
        
        END_INTERFACE
    } ICorProfilerCallbackVtbl;

    interface ICorProfilerCallback
    {
        CONST_VTBL struct ICorProfilerCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorProfilerCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorProfilerCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorProfilerCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorProfilerCallback_Initialize(This,pICorProfilerInfoUnk)	\
    (This)->lpVtbl -> Initialize(This,pICorProfilerInfoUnk)

#define ICorProfilerCallback_Shutdown(This)	\
    (This)->lpVtbl -> Shutdown(This)

#define ICorProfilerCallback_AppDomainCreationStarted(This,appDomainId)	\
    (This)->lpVtbl -> AppDomainCreationStarted(This,appDomainId)

#define ICorProfilerCallback_AppDomainCreationFinished(This,appDomainId,hrStatus)	\
    (This)->lpVtbl -> AppDomainCreationFinished(This,appDomainId,hrStatus)

#define ICorProfilerCallback_AppDomainShutdownStarted(This,appDomainId)	\
    (This)->lpVtbl -> AppDomainShutdownStarted(This,appDomainId)

#define ICorProfilerCallback_AppDomainShutdownFinished(This,appDomainId,hrStatus)	\
    (This)->lpVtbl -> AppDomainShutdownFinished(This,appDomainId,hrStatus)

#define ICorProfilerCallback_AssemblyLoadStarted(This,assemblyId)	\
    (This)->lpVtbl -> AssemblyLoadStarted(This,assemblyId)

#define ICorProfilerCallback_AssemblyLoadFinished(This,assemblyId,hrStatus)	\
    (This)->lpVtbl -> AssemblyLoadFinished(This,assemblyId,hrStatus)

#define ICorProfilerCallback_AssemblyUnloadStarted(This,assemblyId)	\
    (This)->lpVtbl -> AssemblyUnloadStarted(This,assemblyId)

#define ICorProfilerCallback_AssemblyUnloadFinished(This,assemblyId,hrStatus)	\
    (This)->lpVtbl -> AssemblyUnloadFinished(This,assemblyId,hrStatus)

#define ICorProfilerCallback_ModuleLoadStarted(This,moduleId)	\
    (This)->lpVtbl -> ModuleLoadStarted(This,moduleId)

#define ICorProfilerCallback_ModuleLoadFinished(This,moduleId,hrStatus)	\
    (This)->lpVtbl -> ModuleLoadFinished(This,moduleId,hrStatus)

#define ICorProfilerCallback_ModuleUnloadStarted(This,moduleId)	\
    (This)->lpVtbl -> ModuleUnloadStarted(This,moduleId)

#define ICorProfilerCallback_ModuleUnloadFinished(This,moduleId,hrStatus)	\
    (This)->lpVtbl -> ModuleUnloadFinished(This,moduleId,hrStatus)

#define ICorProfilerCallback_ModuleAttachedToAssembly(This,moduleId,AssemblyId)	\
    (This)->lpVtbl -> ModuleAttachedToAssembly(This,moduleId,AssemblyId)

#define ICorProfilerCallback_ClassLoadStarted(This,classId)	\
    (This)->lpVtbl -> ClassLoadStarted(This,classId)

#define ICorProfilerCallback_ClassLoadFinished(This,classId,hrStatus)	\
    (This)->lpVtbl -> ClassLoadFinished(This,classId,hrStatus)

#define ICorProfilerCallback_ClassUnloadStarted(This,classId)	\
    (This)->lpVtbl -> ClassUnloadStarted(This,classId)

#define ICorProfilerCallback_ClassUnloadFinished(This,classId,hrStatus)	\
    (This)->lpVtbl -> ClassUnloadFinished(This,classId,hrStatus)

#define ICorProfilerCallback_FunctionUnloadStarted(This,functionId)	\
    (This)->lpVtbl -> FunctionUnloadStarted(This,functionId)

#define ICorProfilerCallback_JITCompilationStarted(This,functionId,fIsSafeToBlock)	\
    (This)->lpVtbl -> JITCompilationStarted(This,functionId,fIsSafeToBlock)

#define ICorProfilerCallback_JITCompilationFinished(This,functionId,hrStatus,fIsSafeToBlock)	\
    (This)->lpVtbl -> JITCompilationFinished(This,functionId,hrStatus,fIsSafeToBlock)

#define ICorProfilerCallback_JITCachedFunctionSearchStarted(This,functionId,pbUseCachedFunction)	\
    (This)->lpVtbl -> JITCachedFunctionSearchStarted(This,functionId,pbUseCachedFunction)

#define ICorProfilerCallback_JITCachedFunctionSearchFinished(This,functionId,result)	\
    (This)->lpVtbl -> JITCachedFunctionSearchFinished(This,functionId,result)

#define ICorProfilerCallback_JITFunctionPitched(This,functionId)	\
    (This)->lpVtbl -> JITFunctionPitched(This,functionId)

#define ICorProfilerCallback_JITInlining(This,callerId,calleeId,pfShouldInline)	\
    (This)->lpVtbl -> JITInlining(This,callerId,calleeId,pfShouldInline)

#define ICorProfilerCallback_ThreadCreated(This,threadId)	\
    (This)->lpVtbl -> ThreadCreated(This,threadId)

#define ICorProfilerCallback_ThreadDestroyed(This,threadId)	\
    (This)->lpVtbl -> ThreadDestroyed(This,threadId)

#define ICorProfilerCallback_ThreadAssignedToOSThread(This,managedThreadId,osThreadId)	\
    (This)->lpVtbl -> ThreadAssignedToOSThread(This,managedThreadId,osThreadId)

#define ICorProfilerCallback_RemotingClientInvocationStarted(This)	\
    (This)->lpVtbl -> RemotingClientInvocationStarted(This)

#define ICorProfilerCallback_RemotingClientSendingMessage(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingClientSendingMessage(This,pCookie,fIsAsync)

#define ICorProfilerCallback_RemotingClientReceivingReply(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingClientReceivingReply(This,pCookie,fIsAsync)

#define ICorProfilerCallback_RemotingClientInvocationFinished(This)	\
    (This)->lpVtbl -> RemotingClientInvocationFinished(This)

#define ICorProfilerCallback_RemotingServerReceivingMessage(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingServerReceivingMessage(This,pCookie,fIsAsync)

#define ICorProfilerCallback_RemotingServerInvocationStarted(This)	\
    (This)->lpVtbl -> RemotingServerInvocationStarted(This)

#define ICorProfilerCallback_RemotingServerInvocationReturned(This)	\
    (This)->lpVtbl -> RemotingServerInvocationReturned(This)

#define ICorProfilerCallback_RemotingServerSendingReply(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingServerSendingReply(This,pCookie,fIsAsync)

#define ICorProfilerCallback_UnmanagedToManagedTransition(This,functionId,reason)	\
    (This)->lpVtbl -> UnmanagedToManagedTransition(This,functionId,reason)

#define ICorProfilerCallback_ManagedToUnmanagedTransition(This,functionId,reason)	\
    (This)->lpVtbl -> ManagedToUnmanagedTransition(This,functionId,reason)

#define ICorProfilerCallback_RuntimeSuspendStarted(This,suspendReason)	\
    (This)->lpVtbl -> RuntimeSuspendStarted(This,suspendReason)

#define ICorProfilerCallback_RuntimeSuspendFinished(This)	\
    (This)->lpVtbl -> RuntimeSuspendFinished(This)

#define ICorProfilerCallback_RuntimeSuspendAborted(This)	\
    (This)->lpVtbl -> RuntimeSuspendAborted(This)

#define ICorProfilerCallback_RuntimeResumeStarted(This)	\
    (This)->lpVtbl -> RuntimeResumeStarted(This)

#define ICorProfilerCallback_RuntimeResumeFinished(This)	\
    (This)->lpVtbl -> RuntimeResumeFinished(This)

#define ICorProfilerCallback_RuntimeThreadSuspended(This,threadId)	\
    (This)->lpVtbl -> RuntimeThreadSuspended(This,threadId)

#define ICorProfilerCallback_RuntimeThreadResumed(This,threadId)	\
    (This)->lpVtbl -> RuntimeThreadResumed(This,threadId)

#define ICorProfilerCallback_MovedReferences(This,cMovedObjectIDRanges,oldObjectIDRangeStart,newObjectIDRangeStart,cObjectIDRangeLength)	\
    (This)->lpVtbl -> MovedReferences(This,cMovedObjectIDRanges,oldObjectIDRangeStart,newObjectIDRangeStart,cObjectIDRangeLength)

#define ICorProfilerCallback_ObjectAllocated(This,objectId,classId)	\
    (This)->lpVtbl -> ObjectAllocated(This,objectId,classId)

#define ICorProfilerCallback_ObjectsAllocatedByClass(This,cClassCount,classIds,cObjects)	\
    (This)->lpVtbl -> ObjectsAllocatedByClass(This,cClassCount,classIds,cObjects)

#define ICorProfilerCallback_ObjectReferences(This,objectId,classId,cObjectRefs,objectRefIds)	\
    (This)->lpVtbl -> ObjectReferences(This,objectId,classId,cObjectRefs,objectRefIds)

#define ICorProfilerCallback_RootReferences(This,cRootRefs,rootRefIds)	\
    (This)->lpVtbl -> RootReferences(This,cRootRefs,rootRefIds)

#define ICorProfilerCallback_ExceptionThrown(This,thrownObjectId)	\
    (This)->lpVtbl -> ExceptionThrown(This,thrownObjectId)

#define ICorProfilerCallback_ExceptionSearchFunctionEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchFunctionEnter(This,functionId)

#define ICorProfilerCallback_ExceptionSearchFunctionLeave(This)	\
    (This)->lpVtbl -> ExceptionSearchFunctionLeave(This)

#define ICorProfilerCallback_ExceptionSearchFilterEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchFilterEnter(This,functionId)

#define ICorProfilerCallback_ExceptionSearchFilterLeave(This)	\
    (This)->lpVtbl -> ExceptionSearchFilterLeave(This)

#define ICorProfilerCallback_ExceptionSearchCatcherFound(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchCatcherFound(This,functionId)

#define ICorProfilerCallback_ExceptionOSHandlerEnter(This,__unused)	\
    (This)->lpVtbl -> ExceptionOSHandlerEnter(This,__unused)

#define ICorProfilerCallback_ExceptionOSHandlerLeave(This,__unused)	\
    (This)->lpVtbl -> ExceptionOSHandlerLeave(This,__unused)

#define ICorProfilerCallback_ExceptionUnwindFunctionEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionUnwindFunctionEnter(This,functionId)

#define ICorProfilerCallback_ExceptionUnwindFunctionLeave(This)	\
    (This)->lpVtbl -> ExceptionUnwindFunctionLeave(This)

#define ICorProfilerCallback_ExceptionUnwindFinallyEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionUnwindFinallyEnter(This,functionId)

#define ICorProfilerCallback_ExceptionUnwindFinallyLeave(This)	\
    (This)->lpVtbl -> ExceptionUnwindFinallyLeave(This)

#define ICorProfilerCallback_ExceptionCatcherEnter(This,functionId,objectId)	\
    (This)->lpVtbl -> ExceptionCatcherEnter(This,functionId,objectId)

#define ICorProfilerCallback_ExceptionCatcherLeave(This)	\
    (This)->lpVtbl -> ExceptionCatcherLeave(This)

#define ICorProfilerCallback_COMClassicVTableCreated(This,wrappedClassId,implementedIID,pVTable,cSlots)	\
    (This)->lpVtbl -> COMClassicVTableCreated(This,wrappedClassId,implementedIID,pVTable,cSlots)

#define ICorProfilerCallback_COMClassicVTableDestroyed(This,wrappedClassId,implementedIID,pVTable)	\
    (This)->lpVtbl -> COMClassicVTableDestroyed(This,wrappedClassId,implementedIID,pVTable)

#define ICorProfilerCallback_ExceptionCLRCatcherFound(This)	\
    (This)->lpVtbl -> ExceptionCLRCatcherFound(This)

#define ICorProfilerCallback_ExceptionCLRCatcherExecute(This)	\
    (This)->lpVtbl -> ExceptionCLRCatcherExecute(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorProfilerCallback_Initialize_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ IUnknown *pICorProfilerInfoUnk);


void __RPC_STUB ICorProfilerCallback_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_Shutdown_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_Shutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AppDomainCreationStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AppDomainID appDomainId);


void __RPC_STUB ICorProfilerCallback_AppDomainCreationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AppDomainCreationFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AppDomainID appDomainId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_AppDomainCreationFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AppDomainShutdownStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AppDomainID appDomainId);


void __RPC_STUB ICorProfilerCallback_AppDomainShutdownStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AppDomainShutdownFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AppDomainID appDomainId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_AppDomainShutdownFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AssemblyLoadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AssemblyID assemblyId);


void __RPC_STUB ICorProfilerCallback_AssemblyLoadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AssemblyLoadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AssemblyID assemblyId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_AssemblyLoadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AssemblyUnloadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AssemblyID assemblyId);


void __RPC_STUB ICorProfilerCallback_AssemblyUnloadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_AssemblyUnloadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ AssemblyID assemblyId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_AssemblyUnloadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleLoadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId);


void __RPC_STUB ICorProfilerCallback_ModuleLoadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleLoadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_ModuleLoadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleUnloadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId);


void __RPC_STUB ICorProfilerCallback_ModuleUnloadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleUnloadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_ModuleUnloadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ModuleAttachedToAssembly_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ AssemblyID AssemblyId);


void __RPC_STUB ICorProfilerCallback_ModuleAttachedToAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ClassLoadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID classId);


void __RPC_STUB ICorProfilerCallback_ClassLoadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ClassLoadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID classId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_ClassLoadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ClassUnloadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID classId);


void __RPC_STUB ICorProfilerCallback_ClassUnloadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ClassUnloadFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID classId,
    /* [in] */ HRESULT hrStatus);


void __RPC_STUB ICorProfilerCallback_ClassUnloadFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_FunctionUnloadStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_FunctionUnloadStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITCompilationStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ BOOL fIsSafeToBlock);


void __RPC_STUB ICorProfilerCallback_JITCompilationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITCompilationFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ HRESULT hrStatus,
    /* [in] */ BOOL fIsSafeToBlock);


void __RPC_STUB ICorProfilerCallback_JITCompilationFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITCachedFunctionSearchStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [out] */ BOOL *pbUseCachedFunction);


void __RPC_STUB ICorProfilerCallback_JITCachedFunctionSearchStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITCachedFunctionSearchFinished_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ COR_PRF_JIT_CACHE result);


void __RPC_STUB ICorProfilerCallback_JITCachedFunctionSearchFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITFunctionPitched_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_JITFunctionPitched_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_JITInlining_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID callerId,
    /* [in] */ FunctionID calleeId,
    /* [out] */ BOOL *pfShouldInline);


void __RPC_STUB ICorProfilerCallback_JITInlining_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ThreadCreated_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID threadId);


void __RPC_STUB ICorProfilerCallback_ThreadCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ThreadDestroyed_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID threadId);


void __RPC_STUB ICorProfilerCallback_ThreadDestroyed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ThreadAssignedToOSThread_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID managedThreadId,
    /* [in] */ DWORD osThreadId);


void __RPC_STUB ICorProfilerCallback_ThreadAssignedToOSThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingClientInvocationStarted_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RemotingClientInvocationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingClientSendingMessage_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ GUID *pCookie,
    /* [in] */ BOOL fIsAsync);


void __RPC_STUB ICorProfilerCallback_RemotingClientSendingMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingClientReceivingReply_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ GUID *pCookie,
    /* [in] */ BOOL fIsAsync);


void __RPC_STUB ICorProfilerCallback_RemotingClientReceivingReply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingClientInvocationFinished_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RemotingClientInvocationFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingServerReceivingMessage_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ GUID *pCookie,
    /* [in] */ BOOL fIsAsync);


void __RPC_STUB ICorProfilerCallback_RemotingServerReceivingMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingServerInvocationStarted_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RemotingServerInvocationStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingServerInvocationReturned_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RemotingServerInvocationReturned_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RemotingServerSendingReply_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ GUID *pCookie,
    /* [in] */ BOOL fIsAsync);


void __RPC_STUB ICorProfilerCallback_RemotingServerSendingReply_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_UnmanagedToManagedTransition_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ COR_PRF_TRANSITION_REASON reason);


void __RPC_STUB ICorProfilerCallback_UnmanagedToManagedTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ManagedToUnmanagedTransition_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ COR_PRF_TRANSITION_REASON reason);


void __RPC_STUB ICorProfilerCallback_ManagedToUnmanagedTransition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeSuspendStarted_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ COR_PRF_SUSPEND_REASON suspendReason);


void __RPC_STUB ICorProfilerCallback_RuntimeSuspendStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeSuspendFinished_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RuntimeSuspendFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeSuspendAborted_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RuntimeSuspendAborted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeResumeStarted_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RuntimeResumeStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeResumeFinished_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_RuntimeResumeFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeThreadSuspended_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID threadId);


void __RPC_STUB ICorProfilerCallback_RuntimeThreadSuspended_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RuntimeThreadResumed_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ThreadID threadId);


void __RPC_STUB ICorProfilerCallback_RuntimeThreadResumed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_MovedReferences_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ULONG cMovedObjectIDRanges,
    /* [size_is][in] */ ObjectID oldObjectIDRangeStart[  ],
    /* [size_is][in] */ ObjectID newObjectIDRangeStart[  ],
    /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]);


void __RPC_STUB ICorProfilerCallback_MovedReferences_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ObjectAllocated_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ObjectID objectId,
    /* [in] */ ClassID classId);


void __RPC_STUB ICorProfilerCallback_ObjectAllocated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ObjectsAllocatedByClass_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ULONG cClassCount,
    /* [size_is][in] */ ClassID classIds[  ],
    /* [size_is][in] */ ULONG cObjects[  ]);


void __RPC_STUB ICorProfilerCallback_ObjectsAllocatedByClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ObjectReferences_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ObjectID objectId,
    /* [in] */ ClassID classId,
    /* [in] */ ULONG cObjectRefs,
    /* [size_is][in] */ ObjectID objectRefIds[  ]);


void __RPC_STUB ICorProfilerCallback_ObjectReferences_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_RootReferences_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ULONG cRootRefs,
    /* [size_is][in] */ ObjectID rootRefIds[  ]);


void __RPC_STUB ICorProfilerCallback_RootReferences_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionThrown_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ObjectID thrownObjectId);


void __RPC_STUB ICorProfilerCallback_ExceptionThrown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchFunctionEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchFunctionEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchFunctionLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchFunctionLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchFilterEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchFilterEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchFilterLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchFilterLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionSearchCatcherFound_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionSearchCatcherFound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionOSHandlerEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ UINT_PTR __unused);


void __RPC_STUB ICorProfilerCallback_ExceptionOSHandlerEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionOSHandlerLeave_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ UINT_PTR __unused);


void __RPC_STUB ICorProfilerCallback_ExceptionOSHandlerLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionUnwindFunctionEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionUnwindFunctionEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionUnwindFunctionLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionUnwindFunctionLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionUnwindFinallyEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerCallback_ExceptionUnwindFinallyEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionUnwindFinallyLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionUnwindFinallyLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionCatcherEnter_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ ObjectID objectId);


void __RPC_STUB ICorProfilerCallback_ExceptionCatcherEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionCatcherLeave_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionCatcherLeave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_COMClassicVTableCreated_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID wrappedClassId,
    /* [in] */ REFGUID implementedIID,
    /* [in] */ void *pVTable,
    /* [in] */ ULONG cSlots);


void __RPC_STUB ICorProfilerCallback_COMClassicVTableCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_COMClassicVTableDestroyed_Proxy( 
    ICorProfilerCallback * This,
    /* [in] */ ClassID wrappedClassId,
    /* [in] */ REFGUID implementedIID,
    /* [in] */ void *pVTable);


void __RPC_STUB ICorProfilerCallback_COMClassicVTableDestroyed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionCLRCatcherFound_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionCLRCatcherFound_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback_ExceptionCLRCatcherExecute_Proxy( 
    ICorProfilerCallback * This);


void __RPC_STUB ICorProfilerCallback_ExceptionCLRCatcherExecute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorProfilerCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_corprof_0011 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0011_0001
    {	COR_PRF_GC_ROOT_STACK	= 1,
	COR_PRF_GC_ROOT_FINALIZER	= 2,
	COR_PRF_GC_ROOT_HANDLE	= 3,
	COR_PRF_GC_ROOT_OTHER	= 0
    } 	COR_PRF_GC_ROOT_KIND;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0011_0002
    {	COR_PRF_GC_ROOT_PINNING	= 0x1,
	COR_PRF_GC_ROOT_WEAKREF	= 0x2,
	COR_PRF_GC_ROOT_INTERIOR	= 0x4,
	COR_PRF_GC_ROOT_REFCOUNTED	= 0x8
    } 	COR_PRF_GC_ROOT_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_corprof_0011_0003
    {	COR_PRF_FINALIZER_CRITICAL	= 0x1
    } 	COR_PRF_FINALIZER_FLAGS;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_corprof_0011_0004
    {	COR_PRF_GC_GEN_0	= 0,
	COR_PRF_GC_GEN_1	= 1,
	COR_PRF_GC_GEN_2	= 2,
	COR_PRF_GC_LARGE_OBJECT_HEAP	= 3
    } 	COR_PRF_GC_GENERATION;

typedef struct COR_PRF_GC_GENERATION_RANGE
    {
    COR_PRF_GC_GENERATION generation;
    ObjectID rangeStart;
    UINT_PTR rangeLength;
    UINT_PTR rangeLengthReserved;
    } 	COR_PRF_GC_GENERATION_RANGE;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_corprof_0011_0005
    {	COR_PRF_CLAUSE_NONE	= 0,
	COR_PRF_CLAUSE_FILTER	= 1,
	COR_PRF_CLAUSE_CATCH	= 2,
	COR_PRF_CLAUSE_FINALLY	= 3
    } 	COR_PRF_CLAUSE_TYPE;

typedef struct COR_PRF_EX_CLAUSE_INFO
    {
    COR_PRF_CLAUSE_TYPE clauseType;
    UINT_PTR programCounter;
    UINT_PTR framePointer;
    UINT_PTR shadowStackPointer;
    } 	COR_PRF_EX_CLAUSE_INFO;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_corprof_0011_0006
    {	COR_PRF_GC_INDUCED	= 1,
	COR_PRF_GC_OTHER	= 0
    } 	COR_PRF_GC_REASON;



extern RPC_IF_HANDLE __MIDL_itf_corprof_0011_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_corprof_0011_v0_0_s_ifspec;

#ifndef __ICorProfilerCallback2_INTERFACE_DEFINED__
#define __ICorProfilerCallback2_INTERFACE_DEFINED__

/* interface ICorProfilerCallback2 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorProfilerCallback2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8A8CC829-CCF2-49fe-BBAE-0F022228071A")
    ICorProfilerCallback2 : public ICorProfilerCallback
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ThreadNameChanged( 
            /* [in] */ ThreadID threadId,
            /* [in] */ ULONG cchName,
            /* [in] */ WCHAR name[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GarbageCollectionStarted( 
            /* [in] */ int cGenerations,
            /* [length_is][size_is][in] */ BOOL generationCollected[  ],
            /* [in] */ COR_PRF_GC_REASON reason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SurvivingReferences( 
            /* [in] */ ULONG cSurvivingObjectIDRanges,
            /* [size_is][in] */ ObjectID objectIDRangeStart[  ],
            /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GarbageCollectionFinished( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FinalizeableObjectQueued( 
            /* [in] */ DWORD finalizerFlags,
            /* [in] */ ObjectID objectID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RootReferences2( 
            /* [in] */ ULONG cRootRefs,
            /* [size_is][in] */ ObjectID rootRefIds[  ],
            /* [size_is][in] */ COR_PRF_GC_ROOT_KIND rootKinds[  ],
            /* [size_is][in] */ COR_PRF_GC_ROOT_FLAGS rootFlags[  ],
            /* [size_is][in] */ UINT_PTR rootIds[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleCreated( 
            /* [in] */ GCHandleID handleId,
            /* [in] */ ObjectID initialObjectId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HandleDestroyed( 
            /* [in] */ GCHandleID handleId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorProfilerCallback2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorProfilerCallback2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorProfilerCallback2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            ICorProfilerCallback2 * This,
            /* [in] */ IUnknown *pICorProfilerInfoUnk);
        
        HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainCreationStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AppDomainID appDomainId);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainCreationFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainShutdownStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AppDomainID appDomainId);
        
        HRESULT ( STDMETHODCALLTYPE *AppDomainShutdownFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyLoadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AssemblyID assemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyLoadFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyUnloadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AssemblyID assemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *AssemblyUnloadFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleLoadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ModuleID moduleId);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleLoadFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleUnloadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ModuleID moduleId);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleUnloadFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ModuleAttachedToAssembly )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ AssemblyID AssemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassLoadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassLoadFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *ClassUnloadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ClassUnloadFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ClassID classId,
            /* [in] */ HRESULT hrStatus);
        
        HRESULT ( STDMETHODCALLTYPE *FunctionUnloadStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *JITCompilationStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fIsSafeToBlock);
        
        HRESULT ( STDMETHODCALLTYPE *JITCompilationFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ HRESULT hrStatus,
            /* [in] */ BOOL fIsSafeToBlock);
        
        HRESULT ( STDMETHODCALLTYPE *JITCachedFunctionSearchStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ BOOL *pbUseCachedFunction);
        
        HRESULT ( STDMETHODCALLTYPE *JITCachedFunctionSearchFinished )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_JIT_CACHE result);
        
        HRESULT ( STDMETHODCALLTYPE *JITFunctionPitched )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *JITInlining )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID callerId,
            /* [in] */ FunctionID calleeId,
            /* [out] */ BOOL *pfShouldInline);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadCreated )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadDestroyed )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadAssignedToOSThread )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ThreadID managedThreadId,
            /* [in] */ DWORD osThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientInvocationStarted )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientSendingMessage )( 
            ICorProfilerCallback2 * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientReceivingReply )( 
            ICorProfilerCallback2 * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingClientInvocationFinished )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerReceivingMessage )( 
            ICorProfilerCallback2 * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerInvocationStarted )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerInvocationReturned )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RemotingServerSendingReply )( 
            ICorProfilerCallback2 * This,
            /* [in] */ GUID *pCookie,
            /* [in] */ BOOL fIsAsync);
        
        HRESULT ( STDMETHODCALLTYPE *UnmanagedToManagedTransition )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason);
        
        HRESULT ( STDMETHODCALLTYPE *ManagedToUnmanagedTransition )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ COR_PRF_TRANSITION_REASON reason);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ COR_PRF_SUSPEND_REASON suspendReason);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendFinished )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeSuspendAborted )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeResumeStarted )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeResumeFinished )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeThreadSuspended )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *RuntimeThreadResumed )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ThreadID threadId);
        
        HRESULT ( STDMETHODCALLTYPE *MovedReferences )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ULONG cMovedObjectIDRanges,
            /* [size_is][in] */ ObjectID oldObjectIDRangeStart[  ],
            /* [size_is][in] */ ObjectID newObjectIDRangeStart[  ],
            /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectAllocated )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectsAllocatedByClass )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ULONG cClassCount,
            /* [size_is][in] */ ClassID classIds[  ],
            /* [size_is][in] */ ULONG cObjects[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ObjectReferences )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ObjectID objectId,
            /* [in] */ ClassID classId,
            /* [in] */ ULONG cObjectRefs,
            /* [size_is][in] */ ObjectID objectRefIds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *RootReferences )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ULONG cRootRefs,
            /* [size_is][in] */ ObjectID rootRefIds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionThrown )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ObjectID thrownObjectId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFunctionEnter )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFunctionLeave )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFilterEnter )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchFilterLeave )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionSearchCatcherFound )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionOSHandlerEnter )( 
            ICorProfilerCallback2 * This,
            /* [in] */ UINT_PTR __unused);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionOSHandlerLeave )( 
            ICorProfilerCallback2 * This,
            /* [in] */ UINT_PTR __unused);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFunctionEnter )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFunctionLeave )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFinallyEnter )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionUnwindFinallyLeave )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCatcherEnter )( 
            ICorProfilerCallback2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ ObjectID objectId);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCatcherLeave )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *COMClassicVTableCreated )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable,
            /* [in] */ ULONG cSlots);
        
        HRESULT ( STDMETHODCALLTYPE *COMClassicVTableDestroyed )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ClassID wrappedClassId,
            /* [in] */ REFGUID implementedIID,
            /* [in] */ void *pVTable);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCLRCatcherFound )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ExceptionCLRCatcherExecute )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadNameChanged )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ThreadID threadId,
            /* [in] */ ULONG cchName,
            /* [in] */ WCHAR name[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GarbageCollectionStarted )( 
            ICorProfilerCallback2 * This,
            /* [in] */ int cGenerations,
            /* [length_is][size_is][in] */ BOOL generationCollected[  ],
            /* [in] */ COR_PRF_GC_REASON reason);
        
        HRESULT ( STDMETHODCALLTYPE *SurvivingReferences )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ULONG cSurvivingObjectIDRanges,
            /* [size_is][in] */ ObjectID objectIDRangeStart[  ],
            /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GarbageCollectionFinished )( 
            ICorProfilerCallback2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *FinalizeableObjectQueued )( 
            ICorProfilerCallback2 * This,
            /* [in] */ DWORD finalizerFlags,
            /* [in] */ ObjectID objectID);
        
        HRESULT ( STDMETHODCALLTYPE *RootReferences2 )( 
            ICorProfilerCallback2 * This,
            /* [in] */ ULONG cRootRefs,
            /* [size_is][in] */ ObjectID rootRefIds[  ],
            /* [size_is][in] */ COR_PRF_GC_ROOT_KIND rootKinds[  ],
            /* [size_is][in] */ COR_PRF_GC_ROOT_FLAGS rootFlags[  ],
            /* [size_is][in] */ UINT_PTR rootIds[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *HandleCreated )( 
            ICorProfilerCallback2 * This,
            /* [in] */ GCHandleID handleId,
            /* [in] */ ObjectID initialObjectId);
        
        HRESULT ( STDMETHODCALLTYPE *HandleDestroyed )( 
            ICorProfilerCallback2 * This,
            /* [in] */ GCHandleID handleId);
        
        END_INTERFACE
    } ICorProfilerCallback2Vtbl;

    interface ICorProfilerCallback2
    {
        CONST_VTBL struct ICorProfilerCallback2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorProfilerCallback2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorProfilerCallback2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorProfilerCallback2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorProfilerCallback2_Initialize(This,pICorProfilerInfoUnk)	\
    (This)->lpVtbl -> Initialize(This,pICorProfilerInfoUnk)

#define ICorProfilerCallback2_Shutdown(This)	\
    (This)->lpVtbl -> Shutdown(This)

#define ICorProfilerCallback2_AppDomainCreationStarted(This,appDomainId)	\
    (This)->lpVtbl -> AppDomainCreationStarted(This,appDomainId)

#define ICorProfilerCallback2_AppDomainCreationFinished(This,appDomainId,hrStatus)	\
    (This)->lpVtbl -> AppDomainCreationFinished(This,appDomainId,hrStatus)

#define ICorProfilerCallback2_AppDomainShutdownStarted(This,appDomainId)	\
    (This)->lpVtbl -> AppDomainShutdownStarted(This,appDomainId)

#define ICorProfilerCallback2_AppDomainShutdownFinished(This,appDomainId,hrStatus)	\
    (This)->lpVtbl -> AppDomainShutdownFinished(This,appDomainId,hrStatus)

#define ICorProfilerCallback2_AssemblyLoadStarted(This,assemblyId)	\
    (This)->lpVtbl -> AssemblyLoadStarted(This,assemblyId)

#define ICorProfilerCallback2_AssemblyLoadFinished(This,assemblyId,hrStatus)	\
    (This)->lpVtbl -> AssemblyLoadFinished(This,assemblyId,hrStatus)

#define ICorProfilerCallback2_AssemblyUnloadStarted(This,assemblyId)	\
    (This)->lpVtbl -> AssemblyUnloadStarted(This,assemblyId)

#define ICorProfilerCallback2_AssemblyUnloadFinished(This,assemblyId,hrStatus)	\
    (This)->lpVtbl -> AssemblyUnloadFinished(This,assemblyId,hrStatus)

#define ICorProfilerCallback2_ModuleLoadStarted(This,moduleId)	\
    (This)->lpVtbl -> ModuleLoadStarted(This,moduleId)

#define ICorProfilerCallback2_ModuleLoadFinished(This,moduleId,hrStatus)	\
    (This)->lpVtbl -> ModuleLoadFinished(This,moduleId,hrStatus)

#define ICorProfilerCallback2_ModuleUnloadStarted(This,moduleId)	\
    (This)->lpVtbl -> ModuleUnloadStarted(This,moduleId)

#define ICorProfilerCallback2_ModuleUnloadFinished(This,moduleId,hrStatus)	\
    (This)->lpVtbl -> ModuleUnloadFinished(This,moduleId,hrStatus)

#define ICorProfilerCallback2_ModuleAttachedToAssembly(This,moduleId,AssemblyId)	\
    (This)->lpVtbl -> ModuleAttachedToAssembly(This,moduleId,AssemblyId)

#define ICorProfilerCallback2_ClassLoadStarted(This,classId)	\
    (This)->lpVtbl -> ClassLoadStarted(This,classId)

#define ICorProfilerCallback2_ClassLoadFinished(This,classId,hrStatus)	\
    (This)->lpVtbl -> ClassLoadFinished(This,classId,hrStatus)

#define ICorProfilerCallback2_ClassUnloadStarted(This,classId)	\
    (This)->lpVtbl -> ClassUnloadStarted(This,classId)

#define ICorProfilerCallback2_ClassUnloadFinished(This,classId,hrStatus)	\
    (This)->lpVtbl -> ClassUnloadFinished(This,classId,hrStatus)

#define ICorProfilerCallback2_FunctionUnloadStarted(This,functionId)	\
    (This)->lpVtbl -> FunctionUnloadStarted(This,functionId)

#define ICorProfilerCallback2_JITCompilationStarted(This,functionId,fIsSafeToBlock)	\
    (This)->lpVtbl -> JITCompilationStarted(This,functionId,fIsSafeToBlock)

#define ICorProfilerCallback2_JITCompilationFinished(This,functionId,hrStatus,fIsSafeToBlock)	\
    (This)->lpVtbl -> JITCompilationFinished(This,functionId,hrStatus,fIsSafeToBlock)

#define ICorProfilerCallback2_JITCachedFunctionSearchStarted(This,functionId,pbUseCachedFunction)	\
    (This)->lpVtbl -> JITCachedFunctionSearchStarted(This,functionId,pbUseCachedFunction)

#define ICorProfilerCallback2_JITCachedFunctionSearchFinished(This,functionId,result)	\
    (This)->lpVtbl -> JITCachedFunctionSearchFinished(This,functionId,result)

#define ICorProfilerCallback2_JITFunctionPitched(This,functionId)	\
    (This)->lpVtbl -> JITFunctionPitched(This,functionId)

#define ICorProfilerCallback2_JITInlining(This,callerId,calleeId,pfShouldInline)	\
    (This)->lpVtbl -> JITInlining(This,callerId,calleeId,pfShouldInline)

#define ICorProfilerCallback2_ThreadCreated(This,threadId)	\
    (This)->lpVtbl -> ThreadCreated(This,threadId)

#define ICorProfilerCallback2_ThreadDestroyed(This,threadId)	\
    (This)->lpVtbl -> ThreadDestroyed(This,threadId)

#define ICorProfilerCallback2_ThreadAssignedToOSThread(This,managedThreadId,osThreadId)	\
    (This)->lpVtbl -> ThreadAssignedToOSThread(This,managedThreadId,osThreadId)

#define ICorProfilerCallback2_RemotingClientInvocationStarted(This)	\
    (This)->lpVtbl -> RemotingClientInvocationStarted(This)

#define ICorProfilerCallback2_RemotingClientSendingMessage(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingClientSendingMessage(This,pCookie,fIsAsync)

#define ICorProfilerCallback2_RemotingClientReceivingReply(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingClientReceivingReply(This,pCookie,fIsAsync)

#define ICorProfilerCallback2_RemotingClientInvocationFinished(This)	\
    (This)->lpVtbl -> RemotingClientInvocationFinished(This)

#define ICorProfilerCallback2_RemotingServerReceivingMessage(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingServerReceivingMessage(This,pCookie,fIsAsync)

#define ICorProfilerCallback2_RemotingServerInvocationStarted(This)	\
    (This)->lpVtbl -> RemotingServerInvocationStarted(This)

#define ICorProfilerCallback2_RemotingServerInvocationReturned(This)	\
    (This)->lpVtbl -> RemotingServerInvocationReturned(This)

#define ICorProfilerCallback2_RemotingServerSendingReply(This,pCookie,fIsAsync)	\
    (This)->lpVtbl -> RemotingServerSendingReply(This,pCookie,fIsAsync)

#define ICorProfilerCallback2_UnmanagedToManagedTransition(This,functionId,reason)	\
    (This)->lpVtbl -> UnmanagedToManagedTransition(This,functionId,reason)

#define ICorProfilerCallback2_ManagedToUnmanagedTransition(This,functionId,reason)	\
    (This)->lpVtbl -> ManagedToUnmanagedTransition(This,functionId,reason)

#define ICorProfilerCallback2_RuntimeSuspendStarted(This,suspendReason)	\
    (This)->lpVtbl -> RuntimeSuspendStarted(This,suspendReason)

#define ICorProfilerCallback2_RuntimeSuspendFinished(This)	\
    (This)->lpVtbl -> RuntimeSuspendFinished(This)

#define ICorProfilerCallback2_RuntimeSuspendAborted(This)	\
    (This)->lpVtbl -> RuntimeSuspendAborted(This)

#define ICorProfilerCallback2_RuntimeResumeStarted(This)	\
    (This)->lpVtbl -> RuntimeResumeStarted(This)

#define ICorProfilerCallback2_RuntimeResumeFinished(This)	\
    (This)->lpVtbl -> RuntimeResumeFinished(This)

#define ICorProfilerCallback2_RuntimeThreadSuspended(This,threadId)	\
    (This)->lpVtbl -> RuntimeThreadSuspended(This,threadId)

#define ICorProfilerCallback2_RuntimeThreadResumed(This,threadId)	\
    (This)->lpVtbl -> RuntimeThreadResumed(This,threadId)

#define ICorProfilerCallback2_MovedReferences(This,cMovedObjectIDRanges,oldObjectIDRangeStart,newObjectIDRangeStart,cObjectIDRangeLength)	\
    (This)->lpVtbl -> MovedReferences(This,cMovedObjectIDRanges,oldObjectIDRangeStart,newObjectIDRangeStart,cObjectIDRangeLength)

#define ICorProfilerCallback2_ObjectAllocated(This,objectId,classId)	\
    (This)->lpVtbl -> ObjectAllocated(This,objectId,classId)

#define ICorProfilerCallback2_ObjectsAllocatedByClass(This,cClassCount,classIds,cObjects)	\
    (This)->lpVtbl -> ObjectsAllocatedByClass(This,cClassCount,classIds,cObjects)

#define ICorProfilerCallback2_ObjectReferences(This,objectId,classId,cObjectRefs,objectRefIds)	\
    (This)->lpVtbl -> ObjectReferences(This,objectId,classId,cObjectRefs,objectRefIds)

#define ICorProfilerCallback2_RootReferences(This,cRootRefs,rootRefIds)	\
    (This)->lpVtbl -> RootReferences(This,cRootRefs,rootRefIds)

#define ICorProfilerCallback2_ExceptionThrown(This,thrownObjectId)	\
    (This)->lpVtbl -> ExceptionThrown(This,thrownObjectId)

#define ICorProfilerCallback2_ExceptionSearchFunctionEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchFunctionEnter(This,functionId)

#define ICorProfilerCallback2_ExceptionSearchFunctionLeave(This)	\
    (This)->lpVtbl -> ExceptionSearchFunctionLeave(This)

#define ICorProfilerCallback2_ExceptionSearchFilterEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchFilterEnter(This,functionId)

#define ICorProfilerCallback2_ExceptionSearchFilterLeave(This)	\
    (This)->lpVtbl -> ExceptionSearchFilterLeave(This)

#define ICorProfilerCallback2_ExceptionSearchCatcherFound(This,functionId)	\
    (This)->lpVtbl -> ExceptionSearchCatcherFound(This,functionId)

#define ICorProfilerCallback2_ExceptionOSHandlerEnter(This,__unused)	\
    (This)->lpVtbl -> ExceptionOSHandlerEnter(This,__unused)

#define ICorProfilerCallback2_ExceptionOSHandlerLeave(This,__unused)	\
    (This)->lpVtbl -> ExceptionOSHandlerLeave(This,__unused)

#define ICorProfilerCallback2_ExceptionUnwindFunctionEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionUnwindFunctionEnter(This,functionId)

#define ICorProfilerCallback2_ExceptionUnwindFunctionLeave(This)	\
    (This)->lpVtbl -> ExceptionUnwindFunctionLeave(This)

#define ICorProfilerCallback2_ExceptionUnwindFinallyEnter(This,functionId)	\
    (This)->lpVtbl -> ExceptionUnwindFinallyEnter(This,functionId)

#define ICorProfilerCallback2_ExceptionUnwindFinallyLeave(This)	\
    (This)->lpVtbl -> ExceptionUnwindFinallyLeave(This)

#define ICorProfilerCallback2_ExceptionCatcherEnter(This,functionId,objectId)	\
    (This)->lpVtbl -> ExceptionCatcherEnter(This,functionId,objectId)

#define ICorProfilerCallback2_ExceptionCatcherLeave(This)	\
    (This)->lpVtbl -> ExceptionCatcherLeave(This)

#define ICorProfilerCallback2_COMClassicVTableCreated(This,wrappedClassId,implementedIID,pVTable,cSlots)	\
    (This)->lpVtbl -> COMClassicVTableCreated(This,wrappedClassId,implementedIID,pVTable,cSlots)

#define ICorProfilerCallback2_COMClassicVTableDestroyed(This,wrappedClassId,implementedIID,pVTable)	\
    (This)->lpVtbl -> COMClassicVTableDestroyed(This,wrappedClassId,implementedIID,pVTable)

#define ICorProfilerCallback2_ExceptionCLRCatcherFound(This)	\
    (This)->lpVtbl -> ExceptionCLRCatcherFound(This)

#define ICorProfilerCallback2_ExceptionCLRCatcherExecute(This)	\
    (This)->lpVtbl -> ExceptionCLRCatcherExecute(This)


#define ICorProfilerCallback2_ThreadNameChanged(This,threadId,cchName,name)	\
    (This)->lpVtbl -> ThreadNameChanged(This,threadId,cchName,name)

#define ICorProfilerCallback2_GarbageCollectionStarted(This,cGenerations,generationCollected,reason)	\
    (This)->lpVtbl -> GarbageCollectionStarted(This,cGenerations,generationCollected,reason)

#define ICorProfilerCallback2_SurvivingReferences(This,cSurvivingObjectIDRanges,objectIDRangeStart,cObjectIDRangeLength)	\
    (This)->lpVtbl -> SurvivingReferences(This,cSurvivingObjectIDRanges,objectIDRangeStart,cObjectIDRangeLength)

#define ICorProfilerCallback2_GarbageCollectionFinished(This)	\
    (This)->lpVtbl -> GarbageCollectionFinished(This)

#define ICorProfilerCallback2_FinalizeableObjectQueued(This,finalizerFlags,objectID)	\
    (This)->lpVtbl -> FinalizeableObjectQueued(This,finalizerFlags,objectID)

#define ICorProfilerCallback2_RootReferences2(This,cRootRefs,rootRefIds,rootKinds,rootFlags,rootIds)	\
    (This)->lpVtbl -> RootReferences2(This,cRootRefs,rootRefIds,rootKinds,rootFlags,rootIds)

#define ICorProfilerCallback2_HandleCreated(This,handleId,initialObjectId)	\
    (This)->lpVtbl -> HandleCreated(This,handleId,initialObjectId)

#define ICorProfilerCallback2_HandleDestroyed(This,handleId)	\
    (This)->lpVtbl -> HandleDestroyed(This,handleId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_ThreadNameChanged_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ ThreadID threadId,
    /* [in] */ ULONG cchName,
    /* [in] */ WCHAR name[  ]);


void __RPC_STUB ICorProfilerCallback2_ThreadNameChanged_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_GarbageCollectionStarted_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ int cGenerations,
    /* [length_is][size_is][in] */ BOOL generationCollected[  ],
    /* [in] */ COR_PRF_GC_REASON reason);


void __RPC_STUB ICorProfilerCallback2_GarbageCollectionStarted_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_SurvivingReferences_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ ULONG cSurvivingObjectIDRanges,
    /* [size_is][in] */ ObjectID objectIDRangeStart[  ],
    /* [size_is][in] */ ULONG cObjectIDRangeLength[  ]);


void __RPC_STUB ICorProfilerCallback2_SurvivingReferences_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_GarbageCollectionFinished_Proxy( 
    ICorProfilerCallback2 * This);


void __RPC_STUB ICorProfilerCallback2_GarbageCollectionFinished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_FinalizeableObjectQueued_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ DWORD finalizerFlags,
    /* [in] */ ObjectID objectID);


void __RPC_STUB ICorProfilerCallback2_FinalizeableObjectQueued_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_RootReferences2_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ ULONG cRootRefs,
    /* [size_is][in] */ ObjectID rootRefIds[  ],
    /* [size_is][in] */ COR_PRF_GC_ROOT_KIND rootKinds[  ],
    /* [size_is][in] */ COR_PRF_GC_ROOT_FLAGS rootFlags[  ],
    /* [size_is][in] */ UINT_PTR rootIds[  ]);


void __RPC_STUB ICorProfilerCallback2_RootReferences2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_HandleCreated_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ GCHandleID handleId,
    /* [in] */ ObjectID initialObjectId);


void __RPC_STUB ICorProfilerCallback2_HandleCreated_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerCallback2_HandleDestroyed_Proxy( 
    ICorProfilerCallback2 * This,
    /* [in] */ GCHandleID handleId);


void __RPC_STUB ICorProfilerCallback2_HandleDestroyed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorProfilerCallback2_INTERFACE_DEFINED__ */


#ifndef __ICorProfilerInfo_INTERFACE_DEFINED__
#define __ICorProfilerInfo_INTERFACE_DEFINED__

/* interface ICorProfilerInfo */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorProfilerInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28B5557D-3F3F-48b4-90B2-5F9EEA2F6C48")
    ICorProfilerInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetClassFromObject( 
            /* [in] */ ObjectID objectId,
            /* [out] */ ClassID *pClassId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassFromToken( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ClassID *pClassId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeInfo( 
            /* [in] */ FunctionID functionId,
            /* [out] */ LPCBYTE *pStart,
            /* [out] */ ULONG *pcSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetEventMask( 
            /* [out] */ DWORD *pdwEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromIP( 
            /* [in] */ LPCBYTE ip,
            /* [out] */ FunctionID *pFunctionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromToken( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdToken token,
            /* [out] */ FunctionID *pFunctionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandleFromThread( 
            /* [in] */ ThreadID threadId,
            /* [out] */ HANDLE *phThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectSize( 
            /* [in] */ ObjectID objectId,
            /* [out] */ ULONG *pcSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsArrayClass( 
            /* [in] */ ClassID classId,
            /* [out] */ CorElementType *pBaseElemType,
            /* [out] */ ClassID *pBaseClassId,
            /* [out] */ ULONG *pcRank) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadInfo( 
            /* [in] */ ThreadID threadId,
            /* [out] */ DWORD *pdwWin32ThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadID( 
            /* [out] */ ThreadID *pThreadId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassIDInfo( 
            /* [in] */ ClassID classId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdTypeDef *pTypeDefToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionInfo( 
            /* [in] */ FunctionID functionId,
            /* [out] */ ClassID *pClassId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdToken *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEventMask( 
            /* [in] */ DWORD dwEvents) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnterLeaveFunctionHooks( 
            /* [in] */ FunctionEnter *pFuncEnter,
            /* [in] */ FunctionLeave *pFuncLeave,
            /* [in] */ FunctionTailcall *pFuncTailcall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFunctionIDMapper( 
            /* [in] */ FunctionIDMapper *pFunc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTokenAndMetaDataFromFunction( 
            /* [in] */ FunctionID functionId,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppImport,
            /* [out] */ mdToken *pToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleInfo( 
            /* [in] */ ModuleID moduleId,
            /* [out] */ LPCBYTE *ppBaseLoadAddress,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AssemblyID *pAssemblyId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModuleMetaData( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ DWORD dwOpenFlags,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILFunctionBody( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodId,
            /* [out] */ LPCBYTE *ppMethodHeader,
            /* [out] */ ULONG *pcbMethodSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILFunctionBodyAllocator( 
            /* [in] */ ModuleID moduleId,
            /* [out] */ IMethodMalloc **ppMalloc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetILFunctionBody( 
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodid,
            /* [in] */ LPCBYTE pbNewILMethodHeader) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppDomainInfo( 
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ ProcessID *pProcessId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyInfo( 
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AppDomainID *pAppDomainId,
            /* [out] */ ModuleID *pModuleId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFunctionReJIT( 
            /* [in] */ FunctionID functionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ForceGC( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetILInstrumentedCodeMap( 
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fStartJit,
            /* [in] */ ULONG cILMapEntries,
            /* [size_is][in] */ COR_IL_MAP rgILMapEntries[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInprocInspectionInterface( 
            /* [out] */ IUnknown **ppicd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInprocInspectionIThisThread( 
            /* [out] */ IUnknown **ppicd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ ThreadID threadId,
            /* [out] */ ContextID *pContextId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginInprocDebugging( 
            /* [in] */ BOOL fThisThreadOnly,
            /* [out] */ DWORD *pdwProfilerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndInprocDebugging( 
            /* [in] */ DWORD dwProfilerContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetILToNativeMapping( 
            /* [in] */ FunctionID functionId,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorProfilerInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorProfilerInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorProfilerInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorProfilerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromObject )( 
            ICorProfilerInfo * This,
            /* [in] */ ObjectID objectId,
            /* [out] */ ClassID *pClassId);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromToken )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ClassID *pClassId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ LPCBYTE *pStart,
            /* [out] */ ULONG *pcSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventMask )( 
            ICorProfilerInfo * This,
            /* [out] */ DWORD *pdwEvents);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromIP )( 
            ICorProfilerInfo * This,
            /* [in] */ LPCBYTE ip,
            /* [out] */ FunctionID *pFunctionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromToken )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdToken token,
            /* [out] */ FunctionID *pFunctionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandleFromThread )( 
            ICorProfilerInfo * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ HANDLE *phThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectSize )( 
            ICorProfilerInfo * This,
            /* [in] */ ObjectID objectId,
            /* [out] */ ULONG *pcSize);
        
        HRESULT ( STDMETHODCALLTYPE *IsArrayClass )( 
            ICorProfilerInfo * This,
            /* [in] */ ClassID classId,
            /* [out] */ CorElementType *pBaseElemType,
            /* [out] */ ClassID *pBaseClassId,
            /* [out] */ ULONG *pcRank);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ DWORD *pdwWin32ThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadID )( 
            ICorProfilerInfo * This,
            /* [out] */ ThreadID *pThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassIDInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ ClassID classId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdTypeDef *pTypeDefToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ ClassID *pClassId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *SetEventMask )( 
            ICorProfilerInfo * This,
            /* [in] */ DWORD dwEvents);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnterLeaveFunctionHooks )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionEnter *pFuncEnter,
            /* [in] */ FunctionLeave *pFuncLeave,
            /* [in] */ FunctionTailcall *pFuncTailcall);
        
        HRESULT ( STDMETHODCALLTYPE *SetFunctionIDMapper )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionIDMapper *pFunc);
        
        HRESULT ( STDMETHODCALLTYPE *GetTokenAndMetaDataFromFunction )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppImport,
            /* [out] */ mdToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [out] */ LPCBYTE *ppBaseLoadAddress,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AssemblyID *pAssemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleMetaData )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ DWORD dwOpenFlags,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetILFunctionBody )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodId,
            /* [out] */ LPCBYTE *ppMethodHeader,
            /* [out] */ ULONG *pcbMethodSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetILFunctionBodyAllocator )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [out] */ IMethodMalloc **ppMalloc);
        
        HRESULT ( STDMETHODCALLTYPE *SetILFunctionBody )( 
            ICorProfilerInfo * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodid,
            /* [in] */ LPCBYTE pbNewILMethodHeader);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppDomainInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ ProcessID *pProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyInfo )( 
            ICorProfilerInfo * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AppDomainID *pAppDomainId,
            /* [out] */ ModuleID *pModuleId);
        
        HRESULT ( STDMETHODCALLTYPE *SetFunctionReJIT )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ForceGC )( 
            ICorProfilerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetILInstrumentedCodeMap )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fStartJit,
            /* [in] */ ULONG cILMapEntries,
            /* [size_is][in] */ COR_IL_MAP rgILMapEntries[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetInprocInspectionInterface )( 
            ICorProfilerInfo * This,
            /* [out] */ IUnknown **ppicd);
        
        HRESULT ( STDMETHODCALLTYPE *GetInprocInspectionIThisThread )( 
            ICorProfilerInfo * This,
            /* [out] */ IUnknown **ppicd);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICorProfilerInfo * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ ContextID *pContextId);
        
        HRESULT ( STDMETHODCALLTYPE *BeginInprocDebugging )( 
            ICorProfilerInfo * This,
            /* [in] */ BOOL fThisThreadOnly,
            /* [out] */ DWORD *pdwProfilerContext);
        
        HRESULT ( STDMETHODCALLTYPE *EndInprocDebugging )( 
            ICorProfilerInfo * This,
            /* [in] */ DWORD dwProfilerContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetILToNativeMapping )( 
            ICorProfilerInfo * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);
        
        END_INTERFACE
    } ICorProfilerInfoVtbl;

    interface ICorProfilerInfo
    {
        CONST_VTBL struct ICorProfilerInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorProfilerInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorProfilerInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorProfilerInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorProfilerInfo_GetClassFromObject(This,objectId,pClassId)	\
    (This)->lpVtbl -> GetClassFromObject(This,objectId,pClassId)

#define ICorProfilerInfo_GetClassFromToken(This,moduleId,typeDef,pClassId)	\
    (This)->lpVtbl -> GetClassFromToken(This,moduleId,typeDef,pClassId)

#define ICorProfilerInfo_GetCodeInfo(This,functionId,pStart,pcSize)	\
    (This)->lpVtbl -> GetCodeInfo(This,functionId,pStart,pcSize)

#define ICorProfilerInfo_GetEventMask(This,pdwEvents)	\
    (This)->lpVtbl -> GetEventMask(This,pdwEvents)

#define ICorProfilerInfo_GetFunctionFromIP(This,ip,pFunctionId)	\
    (This)->lpVtbl -> GetFunctionFromIP(This,ip,pFunctionId)

#define ICorProfilerInfo_GetFunctionFromToken(This,moduleId,token,pFunctionId)	\
    (This)->lpVtbl -> GetFunctionFromToken(This,moduleId,token,pFunctionId)

#define ICorProfilerInfo_GetHandleFromThread(This,threadId,phThread)	\
    (This)->lpVtbl -> GetHandleFromThread(This,threadId,phThread)

#define ICorProfilerInfo_GetObjectSize(This,objectId,pcSize)	\
    (This)->lpVtbl -> GetObjectSize(This,objectId,pcSize)

#define ICorProfilerInfo_IsArrayClass(This,classId,pBaseElemType,pBaseClassId,pcRank)	\
    (This)->lpVtbl -> IsArrayClass(This,classId,pBaseElemType,pBaseClassId,pcRank)

#define ICorProfilerInfo_GetThreadInfo(This,threadId,pdwWin32ThreadId)	\
    (This)->lpVtbl -> GetThreadInfo(This,threadId,pdwWin32ThreadId)

#define ICorProfilerInfo_GetCurrentThreadID(This,pThreadId)	\
    (This)->lpVtbl -> GetCurrentThreadID(This,pThreadId)

#define ICorProfilerInfo_GetClassIDInfo(This,classId,pModuleId,pTypeDefToken)	\
    (This)->lpVtbl -> GetClassIDInfo(This,classId,pModuleId,pTypeDefToken)

#define ICorProfilerInfo_GetFunctionInfo(This,functionId,pClassId,pModuleId,pToken)	\
    (This)->lpVtbl -> GetFunctionInfo(This,functionId,pClassId,pModuleId,pToken)

#define ICorProfilerInfo_SetEventMask(This,dwEvents)	\
    (This)->lpVtbl -> SetEventMask(This,dwEvents)

#define ICorProfilerInfo_SetEnterLeaveFunctionHooks(This,pFuncEnter,pFuncLeave,pFuncTailcall)	\
    (This)->lpVtbl -> SetEnterLeaveFunctionHooks(This,pFuncEnter,pFuncLeave,pFuncTailcall)

#define ICorProfilerInfo_SetFunctionIDMapper(This,pFunc)	\
    (This)->lpVtbl -> SetFunctionIDMapper(This,pFunc)

#define ICorProfilerInfo_GetTokenAndMetaDataFromFunction(This,functionId,riid,ppImport,pToken)	\
    (This)->lpVtbl -> GetTokenAndMetaDataFromFunction(This,functionId,riid,ppImport,pToken)

#define ICorProfilerInfo_GetModuleInfo(This,moduleId,ppBaseLoadAddress,cchName,pcchName,szName,pAssemblyId)	\
    (This)->lpVtbl -> GetModuleInfo(This,moduleId,ppBaseLoadAddress,cchName,pcchName,szName,pAssemblyId)

#define ICorProfilerInfo_GetModuleMetaData(This,moduleId,dwOpenFlags,riid,ppOut)	\
    (This)->lpVtbl -> GetModuleMetaData(This,moduleId,dwOpenFlags,riid,ppOut)

#define ICorProfilerInfo_GetILFunctionBody(This,moduleId,methodId,ppMethodHeader,pcbMethodSize)	\
    (This)->lpVtbl -> GetILFunctionBody(This,moduleId,methodId,ppMethodHeader,pcbMethodSize)

#define ICorProfilerInfo_GetILFunctionBodyAllocator(This,moduleId,ppMalloc)	\
    (This)->lpVtbl -> GetILFunctionBodyAllocator(This,moduleId,ppMalloc)

#define ICorProfilerInfo_SetILFunctionBody(This,moduleId,methodid,pbNewILMethodHeader)	\
    (This)->lpVtbl -> SetILFunctionBody(This,moduleId,methodid,pbNewILMethodHeader)

#define ICorProfilerInfo_GetAppDomainInfo(This,appDomainId,cchName,pcchName,szName,pProcessId)	\
    (This)->lpVtbl -> GetAppDomainInfo(This,appDomainId,cchName,pcchName,szName,pProcessId)

#define ICorProfilerInfo_GetAssemblyInfo(This,assemblyId,cchName,pcchName,szName,pAppDomainId,pModuleId)	\
    (This)->lpVtbl -> GetAssemblyInfo(This,assemblyId,cchName,pcchName,szName,pAppDomainId,pModuleId)

#define ICorProfilerInfo_SetFunctionReJIT(This,functionId)	\
    (This)->lpVtbl -> SetFunctionReJIT(This,functionId)

#define ICorProfilerInfo_ForceGC(This)	\
    (This)->lpVtbl -> ForceGC(This)

#define ICorProfilerInfo_SetILInstrumentedCodeMap(This,functionId,fStartJit,cILMapEntries,rgILMapEntries)	\
    (This)->lpVtbl -> SetILInstrumentedCodeMap(This,functionId,fStartJit,cILMapEntries,rgILMapEntries)

#define ICorProfilerInfo_GetInprocInspectionInterface(This,ppicd)	\
    (This)->lpVtbl -> GetInprocInspectionInterface(This,ppicd)

#define ICorProfilerInfo_GetInprocInspectionIThisThread(This,ppicd)	\
    (This)->lpVtbl -> GetInprocInspectionIThisThread(This,ppicd)

#define ICorProfilerInfo_GetThreadContext(This,threadId,pContextId)	\
    (This)->lpVtbl -> GetThreadContext(This,threadId,pContextId)

#define ICorProfilerInfo_BeginInprocDebugging(This,fThisThreadOnly,pdwProfilerContext)	\
    (This)->lpVtbl -> BeginInprocDebugging(This,fThisThreadOnly,pdwProfilerContext)

#define ICorProfilerInfo_EndInprocDebugging(This,dwProfilerContext)	\
    (This)->lpVtbl -> EndInprocDebugging(This,dwProfilerContext)

#define ICorProfilerInfo_GetILToNativeMapping(This,functionId,cMap,pcMap,map)	\
    (This)->lpVtbl -> GetILToNativeMapping(This,functionId,cMap,pcMap,map)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetClassFromObject_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ObjectID objectId,
    /* [out] */ ClassID *pClassId);


void __RPC_STUB ICorProfilerInfo_GetClassFromObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetClassFromToken_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdTypeDef typeDef,
    /* [out] */ ClassID *pClassId);


void __RPC_STUB ICorProfilerInfo_GetClassFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetCodeInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [out] */ LPCBYTE *pStart,
    /* [out] */ ULONG *pcSize);


void __RPC_STUB ICorProfilerInfo_GetCodeInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetEventMask_Proxy( 
    ICorProfilerInfo * This,
    /* [out] */ DWORD *pdwEvents);


void __RPC_STUB ICorProfilerInfo_GetEventMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetFunctionFromIP_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ LPCBYTE ip,
    /* [out] */ FunctionID *pFunctionId);


void __RPC_STUB ICorProfilerInfo_GetFunctionFromIP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetFunctionFromToken_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdToken token,
    /* [out] */ FunctionID *pFunctionId);


void __RPC_STUB ICorProfilerInfo_GetFunctionFromToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetHandleFromThread_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ThreadID threadId,
    /* [out] */ HANDLE *phThread);


void __RPC_STUB ICorProfilerInfo_GetHandleFromThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetObjectSize_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ObjectID objectId,
    /* [out] */ ULONG *pcSize);


void __RPC_STUB ICorProfilerInfo_GetObjectSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_IsArrayClass_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ClassID classId,
    /* [out] */ CorElementType *pBaseElemType,
    /* [out] */ ClassID *pBaseClassId,
    /* [out] */ ULONG *pcRank);


void __RPC_STUB ICorProfilerInfo_IsArrayClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetThreadInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ThreadID threadId,
    /* [out] */ DWORD *pdwWin32ThreadId);


void __RPC_STUB ICorProfilerInfo_GetThreadInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetCurrentThreadID_Proxy( 
    ICorProfilerInfo * This,
    /* [out] */ ThreadID *pThreadId);


void __RPC_STUB ICorProfilerInfo_GetCurrentThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetClassIDInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ClassID classId,
    /* [out] */ ModuleID *pModuleId,
    /* [out] */ mdTypeDef *pTypeDefToken);


void __RPC_STUB ICorProfilerInfo_GetClassIDInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetFunctionInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [out] */ ClassID *pClassId,
    /* [out] */ ModuleID *pModuleId,
    /* [out] */ mdToken *pToken);


void __RPC_STUB ICorProfilerInfo_GetFunctionInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetEventMask_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ DWORD dwEvents);


void __RPC_STUB ICorProfilerInfo_SetEventMask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetEnterLeaveFunctionHooks_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionEnter *pFuncEnter,
    /* [in] */ FunctionLeave *pFuncLeave,
    /* [in] */ FunctionTailcall *pFuncTailcall);


void __RPC_STUB ICorProfilerInfo_SetEnterLeaveFunctionHooks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetFunctionIDMapper_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionIDMapper *pFunc);


void __RPC_STUB ICorProfilerInfo_SetFunctionIDMapper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetTokenAndMetaDataFromFunction_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppImport,
    /* [out] */ mdToken *pToken);


void __RPC_STUB ICorProfilerInfo_GetTokenAndMetaDataFromFunction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetModuleInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [out] */ LPCBYTE *ppBaseLoadAddress,
    /* [in] */ ULONG cchName,
    /* [out] */ ULONG *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ],
    /* [out] */ AssemblyID *pAssemblyId);


void __RPC_STUB ICorProfilerInfo_GetModuleInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetModuleMetaData_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ DWORD dwOpenFlags,
    /* [in] */ REFIID riid,
    /* [out] */ IUnknown **ppOut);


void __RPC_STUB ICorProfilerInfo_GetModuleMetaData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetILFunctionBody_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdMethodDef methodId,
    /* [out] */ LPCBYTE *ppMethodHeader,
    /* [out] */ ULONG *pcbMethodSize);


void __RPC_STUB ICorProfilerInfo_GetILFunctionBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetILFunctionBodyAllocator_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [out] */ IMethodMalloc **ppMalloc);


void __RPC_STUB ICorProfilerInfo_GetILFunctionBodyAllocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetILFunctionBody_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ModuleID moduleId,
    /* [in] */ mdMethodDef methodid,
    /* [in] */ LPCBYTE pbNewILMethodHeader);


void __RPC_STUB ICorProfilerInfo_SetILFunctionBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetAppDomainInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ AppDomainID appDomainId,
    /* [in] */ ULONG cchName,
    /* [out] */ ULONG *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ],
    /* [out] */ ProcessID *pProcessId);


void __RPC_STUB ICorProfilerInfo_GetAppDomainInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetAssemblyInfo_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ AssemblyID assemblyId,
    /* [in] */ ULONG cchName,
    /* [out] */ ULONG *pcchName,
    /* [length_is][size_is][out] */ WCHAR szName[  ],
    /* [out] */ AppDomainID *pAppDomainId,
    /* [out] */ ModuleID *pModuleId);


void __RPC_STUB ICorProfilerInfo_GetAssemblyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetFunctionReJIT_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId);


void __RPC_STUB ICorProfilerInfo_SetFunctionReJIT_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_ForceGC_Proxy( 
    ICorProfilerInfo * This);


void __RPC_STUB ICorProfilerInfo_ForceGC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_SetILInstrumentedCodeMap_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ BOOL fStartJit,
    /* [in] */ ULONG cILMapEntries,
    /* [size_is][in] */ COR_IL_MAP rgILMapEntries[  ]);


void __RPC_STUB ICorProfilerInfo_SetILInstrumentedCodeMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetInprocInspectionInterface_Proxy( 
    ICorProfilerInfo * This,
    /* [out] */ IUnknown **ppicd);


void __RPC_STUB ICorProfilerInfo_GetInprocInspectionInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetInprocInspectionIThisThread_Proxy( 
    ICorProfilerInfo * This,
    /* [out] */ IUnknown **ppicd);


void __RPC_STUB ICorProfilerInfo_GetInprocInspectionIThisThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetThreadContext_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ ThreadID threadId,
    /* [out] */ ContextID *pContextId);


void __RPC_STUB ICorProfilerInfo_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_BeginInprocDebugging_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ BOOL fThisThreadOnly,
    /* [out] */ DWORD *pdwProfilerContext);


void __RPC_STUB ICorProfilerInfo_BeginInprocDebugging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_EndInprocDebugging_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ DWORD dwProfilerContext);


void __RPC_STUB ICorProfilerInfo_EndInprocDebugging_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo_GetILToNativeMapping_Proxy( 
    ICorProfilerInfo * This,
    /* [in] */ FunctionID functionId,
    /* [in] */ ULONG32 cMap,
    /* [out] */ ULONG32 *pcMap,
    /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);


void __RPC_STUB ICorProfilerInfo_GetILToNativeMapping_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorProfilerInfo_INTERFACE_DEFINED__ */


#ifndef __ICorProfilerInfo2_INTERFACE_DEFINED__
#define __ICorProfilerInfo2_INTERFACE_DEFINED__

/* interface ICorProfilerInfo2 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorProfilerInfo2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CC0935CD-A518-487d-B0BB-A93214E65478")
    ICorProfilerInfo2 : public ICorProfilerInfo
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoStackSnapshot( 
            /* [in] */ ThreadID thread,
            /* [in] */ StackSnapshotCallback *callback,
            /* [in] */ ULONG32 infoFlags,
            /* [in] */ void *clientData,
            /* [length_is][size_is][in] */ BYTE context[  ],
            /* [in] */ ULONG32 contextSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEnterLeaveFunctionHooks2( 
            /* [in] */ FunctionEnter2 *pFuncEnter,
            /* [in] */ FunctionLeave2 *pFuncLeave,
            /* [in] */ FunctionTailcall2 *pFuncTailcall) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionInfo2( 
            /* [in] */ FunctionID funcId,
            /* [in] */ COR_PRF_FRAME_INFO frameInfo,
            /* [out] */ ClassID *pClassId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdToken *pToken,
            /* [in] */ ULONG32 cTypeArgs,
            /* [out] */ ULONG32 *pcTypeArgs,
            /* [out] */ ClassID typeArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStringLayout( 
            /* [out] */ ULONG *pBufferLengthOffset,
            /* [out] */ ULONG *pStringLengthOffset,
            /* [out] */ ULONG *pBufferOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassLayout( 
            /* [in] */ ClassID classID,
            /* [out][in] */ COR_FIELD_OFFSET rFieldOffset[  ],
            /* [in] */ ULONG cFieldOffset,
            /* [out] */ ULONG *pcFieldOffset,
            /* [out] */ ULONG *pulClassSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassIDInfo2( 
            /* [in] */ ClassID classId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdTypeDef *pTypeDefToken,
            /* [out] */ ClassID *pParentClassId,
            /* [in] */ ULONG32 cNumTypeArgs,
            /* [out] */ ULONG32 *pcNumTypeArgs,
            /* [out] */ ClassID typeArgs[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodeInfo2( 
            /* [in] */ FunctionID functionID,
            /* [in] */ ULONG32 cCodeInfos,
            /* [out] */ ULONG32 *pcCodeInfos,
            /* [length_is][size_is][out] */ COR_PRF_CODE_INFO codeInfos[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClassFromTokenAndTypeArgs( 
            /* [in] */ ModuleID moduleID,
            /* [in] */ mdTypeDef typeDef,
            /* [in] */ ULONG32 cTypeArgs,
            /* [size_is][in] */ ClassID typeArgs[  ],
            /* [out] */ ClassID *pClassID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFunctionFromTokenAndTypeArgs( 
            /* [in] */ ModuleID moduleID,
            /* [in] */ mdMethodDef funcDef,
            /* [in] */ ClassID classId,
            /* [in] */ ULONG32 cTypeArgs,
            /* [size_is][in] */ ClassID typeArgs[  ],
            /* [out] */ FunctionID *pFunctionID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumModuleFrozenObjects( 
            /* [in] */ ModuleID moduleID,
            /* [out] */ ICorProfilerObjectEnum **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetArrayObjectInfo( 
            /* [in] */ ObjectID objectId,
            /* [in] */ ULONG32 cDimensions,
            /* [length_is][size_is][out] */ ULONG32 pDimensionSizes[  ],
            /* [length_is][size_is][out] */ int pDimensionLowerBounds[  ],
            /* [out] */ BYTE **ppData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBoxClassLayout( 
            /* [in] */ ClassID classId,
            /* [out] */ ULONG32 *pBufferOffset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadAppDomain( 
            /* [in] */ ThreadID threadId,
            /* [out] */ AppDomainID *pAppDomainId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRVAStaticAddress( 
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [out] */ void **ppAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAppDomainStaticAddress( 
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [in] */ AppDomainID appDomainId,
            /* [out] */ void **ppAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadStaticAddress( 
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [in] */ ThreadID threadId,
            /* [out] */ void **ppAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContextStaticAddress( 
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [in] */ ContextID contextId,
            /* [out] */ void **ppAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStaticFieldInfo( 
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [out] */ COR_PRF_STATIC_TYPE *pFieldInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGenerationBounds( 
            /* [in] */ ULONG cObjectRanges,
            /* [out] */ ULONG *pcObjectRanges,
            /* [length_is][size_is][out] */ COR_PRF_GC_GENERATION_RANGE ranges[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectGeneration( 
            /* [in] */ ObjectID objectId,
            /* [out] */ COR_PRF_GC_GENERATION_RANGE *range) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNotifiedExceptionClauseInfo( 
            /* [out] */ COR_PRF_EX_CLAUSE_INFO *pinfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorProfilerInfo2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorProfilerInfo2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorProfilerInfo2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorProfilerInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromObject )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ObjectID objectId,
            /* [out] */ ClassID *pClassId);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromToken )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdTypeDef typeDef,
            /* [out] */ ClassID *pClassId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeInfo )( 
            ICorProfilerInfo2 * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ LPCBYTE *pStart,
            /* [out] */ ULONG *pcSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetEventMask )( 
            ICorProfilerInfo2 * This,
            /* [out] */ DWORD *pdwEvents);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromIP )( 
            ICorProfilerInfo2 * This,
            /* [in] */ LPCBYTE ip,
            /* [out] */ FunctionID *pFunctionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromToken )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdToken token,
            /* [out] */ FunctionID *pFunctionId);
        
        HRESULT ( STDMETHODCALLTYPE *GetHandleFromThread )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ HANDLE *phThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectSize )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ObjectID objectId,
            /* [out] */ ULONG *pcSize);
        
        HRESULT ( STDMETHODCALLTYPE *IsArrayClass )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ClassID classId,
            /* [out] */ CorElementType *pBaseElemType,
            /* [out] */ ClassID *pBaseClassId,
            /* [out] */ ULONG *pcRank);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadInfo )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ DWORD *pdwWin32ThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadID )( 
            ICorProfilerInfo2 * This,
            /* [out] */ ThreadID *pThreadId);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassIDInfo )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ClassID classId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdTypeDef *pTypeDefToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionInfo )( 
            ICorProfilerInfo2 * This,
            /* [in] */ FunctionID functionId,
            /* [out] */ ClassID *pClassId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *SetEventMask )( 
            ICorProfilerInfo2 * This,
            /* [in] */ DWORD dwEvents);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnterLeaveFunctionHooks )( 
            ICorProfilerInfo2 * This,
            /* [in] */ FunctionEnter *pFuncEnter,
            /* [in] */ FunctionLeave *pFuncLeave,
            /* [in] */ FunctionTailcall *pFuncTailcall);
        
        HRESULT ( STDMETHODCALLTYPE *SetFunctionIDMapper )( 
            ICorProfilerInfo2 * This,
            /* [in] */ FunctionIDMapper *pFunc);
        
        HRESULT ( STDMETHODCALLTYPE *GetTokenAndMetaDataFromFunction )( 
            ICorProfilerInfo2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppImport,
            /* [out] */ mdToken *pToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleInfo )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ModuleID moduleId,
            /* [out] */ LPCBYTE *ppBaseLoadAddress,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AssemblyID *pAssemblyId);
        
        HRESULT ( STDMETHODCALLTYPE *GetModuleMetaData )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ DWORD dwOpenFlags,
            /* [in] */ REFIID riid,
            /* [out] */ IUnknown **ppOut);
        
        HRESULT ( STDMETHODCALLTYPE *GetILFunctionBody )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodId,
            /* [out] */ LPCBYTE *ppMethodHeader,
            /* [out] */ ULONG *pcbMethodSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetILFunctionBodyAllocator )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ModuleID moduleId,
            /* [out] */ IMethodMalloc **ppMalloc);
        
        HRESULT ( STDMETHODCALLTYPE *SetILFunctionBody )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ModuleID moduleId,
            /* [in] */ mdMethodDef methodid,
            /* [in] */ LPCBYTE pbNewILMethodHeader);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppDomainInfo )( 
            ICorProfilerInfo2 * This,
            /* [in] */ AppDomainID appDomainId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ ProcessID *pProcessId);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyInfo )( 
            ICorProfilerInfo2 * This,
            /* [in] */ AssemblyID assemblyId,
            /* [in] */ ULONG cchName,
            /* [out] */ ULONG *pcchName,
            /* [length_is][size_is][out] */ WCHAR szName[  ],
            /* [out] */ AppDomainID *pAppDomainId,
            /* [out] */ ModuleID *pModuleId);
        
        HRESULT ( STDMETHODCALLTYPE *SetFunctionReJIT )( 
            ICorProfilerInfo2 * This,
            /* [in] */ FunctionID functionId);
        
        HRESULT ( STDMETHODCALLTYPE *ForceGC )( 
            ICorProfilerInfo2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetILInstrumentedCodeMap )( 
            ICorProfilerInfo2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ BOOL fStartJit,
            /* [in] */ ULONG cILMapEntries,
            /* [size_is][in] */ COR_IL_MAP rgILMapEntries[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetInprocInspectionInterface )( 
            ICorProfilerInfo2 * This,
            /* [out] */ IUnknown **ppicd);
        
        HRESULT ( STDMETHODCALLTYPE *GetInprocInspectionIThisThread )( 
            ICorProfilerInfo2 * This,
            /* [out] */ IUnknown **ppicd);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ ContextID *pContextId);
        
        HRESULT ( STDMETHODCALLTYPE *BeginInprocDebugging )( 
            ICorProfilerInfo2 * This,
            /* [in] */ BOOL fThisThreadOnly,
            /* [out] */ DWORD *pdwProfilerContext);
        
        HRESULT ( STDMETHODCALLTYPE *EndInprocDebugging )( 
            ICorProfilerInfo2 * This,
            /* [in] */ DWORD dwProfilerContext);
        
        HRESULT ( STDMETHODCALLTYPE *GetILToNativeMapping )( 
            ICorProfilerInfo2 * This,
            /* [in] */ FunctionID functionId,
            /* [in] */ ULONG32 cMap,
            /* [out] */ ULONG32 *pcMap,
            /* [length_is][size_is][out] */ COR_DEBUG_IL_TO_NATIVE_MAP map[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *DoStackSnapshot )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ThreadID thread,
            /* [in] */ StackSnapshotCallback *callback,
            /* [in] */ ULONG32 infoFlags,
            /* [in] */ void *clientData,
            /* [length_is][size_is][in] */ BYTE context[  ],
            /* [in] */ ULONG32 contextSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetEnterLeaveFunctionHooks2 )( 
            ICorProfilerInfo2 * This,
            /* [in] */ FunctionEnter2 *pFuncEnter,
            /* [in] */ FunctionLeave2 *pFuncLeave,
            /* [in] */ FunctionTailcall2 *pFuncTailcall);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionInfo2 )( 
            ICorProfilerInfo2 * This,
            /* [in] */ FunctionID funcId,
            /* [in] */ COR_PRF_FRAME_INFO frameInfo,
            /* [out] */ ClassID *pClassId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdToken *pToken,
            /* [in] */ ULONG32 cTypeArgs,
            /* [out] */ ULONG32 *pcTypeArgs,
            /* [out] */ ClassID typeArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetStringLayout )( 
            ICorProfilerInfo2 * This,
            /* [out] */ ULONG *pBufferLengthOffset,
            /* [out] */ ULONG *pStringLengthOffset,
            /* [out] */ ULONG *pBufferOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassLayout )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ClassID classID,
            /* [out][in] */ COR_FIELD_OFFSET rFieldOffset[  ],
            /* [in] */ ULONG cFieldOffset,
            /* [out] */ ULONG *pcFieldOffset,
            /* [out] */ ULONG *pulClassSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassIDInfo2 )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ClassID classId,
            /* [out] */ ModuleID *pModuleId,
            /* [out] */ mdTypeDef *pTypeDefToken,
            /* [out] */ ClassID *pParentClassId,
            /* [in] */ ULONG32 cNumTypeArgs,
            /* [out] */ ULONG32 *pcNumTypeArgs,
            /* [out] */ ClassID typeArgs[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodeInfo2 )( 
            ICorProfilerInfo2 * This,
            /* [in] */ FunctionID functionID,
            /* [in] */ ULONG32 cCodeInfos,
            /* [out] */ ULONG32 *pcCodeInfos,
            /* [length_is][size_is][out] */ COR_PRF_CODE_INFO codeInfos[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetClassFromTokenAndTypeArgs )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ModuleID moduleID,
            /* [in] */ mdTypeDef typeDef,
            /* [in] */ ULONG32 cTypeArgs,
            /* [size_is][in] */ ClassID typeArgs[  ],
            /* [out] */ ClassID *pClassID);
        
        HRESULT ( STDMETHODCALLTYPE *GetFunctionFromTokenAndTypeArgs )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ModuleID moduleID,
            /* [in] */ mdMethodDef funcDef,
            /* [in] */ ClassID classId,
            /* [in] */ ULONG32 cTypeArgs,
            /* [size_is][in] */ ClassID typeArgs[  ],
            /* [out] */ FunctionID *pFunctionID);
        
        HRESULT ( STDMETHODCALLTYPE *EnumModuleFrozenObjects )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ModuleID moduleID,
            /* [out] */ ICorProfilerObjectEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetArrayObjectInfo )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ObjectID objectId,
            /* [in] */ ULONG32 cDimensions,
            /* [length_is][size_is][out] */ ULONG32 pDimensionSizes[  ],
            /* [length_is][size_is][out] */ int pDimensionLowerBounds[  ],
            /* [out] */ BYTE **ppData);
        
        HRESULT ( STDMETHODCALLTYPE *GetBoxClassLayout )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ClassID classId,
            /* [out] */ ULONG32 *pBufferOffset);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadAppDomain )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ThreadID threadId,
            /* [out] */ AppDomainID *pAppDomainId);
        
        HRESULT ( STDMETHODCALLTYPE *GetRVAStaticAddress )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [out] */ void **ppAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetAppDomainStaticAddress )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [in] */ AppDomainID appDomainId,
            /* [out] */ void **ppAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadStaticAddress )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [in] */ ThreadID threadId,
            /* [out] */ void **ppAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetContextStaticAddress )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [in] */ ContextID contextId,
            /* [out] */ void **ppAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetStaticFieldInfo )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ClassID classId,
            /* [in] */ mdFieldDef fieldToken,
            /* [out] */ COR_PRF_STATIC_TYPE *pFieldInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetGenerationBounds )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ULONG cObjectRanges,
            /* [out] */ ULONG *pcObjectRanges,
            /* [length_is][size_is][out] */ COR_PRF_GC_GENERATION_RANGE ranges[  ]);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectGeneration )( 
            ICorProfilerInfo2 * This,
            /* [in] */ ObjectID objectId,
            /* [out] */ COR_PRF_GC_GENERATION_RANGE *range);
        
        HRESULT ( STDMETHODCALLTYPE *GetNotifiedExceptionClauseInfo )( 
            ICorProfilerInfo2 * This,
            /* [out] */ COR_PRF_EX_CLAUSE_INFO *pinfo);
        
        END_INTERFACE
    } ICorProfilerInfo2Vtbl;

    interface ICorProfilerInfo2
    {
        CONST_VTBL struct ICorProfilerInfo2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorProfilerInfo2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorProfilerInfo2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorProfilerInfo2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorProfilerInfo2_GetClassFromObject(This,objectId,pClassId)	\
    (This)->lpVtbl -> GetClassFromObject(This,objectId,pClassId)

#define ICorProfilerInfo2_GetClassFromToken(This,moduleId,typeDef,pClassId)	\
    (This)->lpVtbl -> GetClassFromToken(This,moduleId,typeDef,pClassId)

#define ICorProfilerInfo2_GetCodeInfo(This,functionId,pStart,pcSize)	\
    (This)->lpVtbl -> GetCodeInfo(This,functionId,pStart,pcSize)

#define ICorProfilerInfo2_GetEventMask(This,pdwEvents)	\
    (This)->lpVtbl -> GetEventMask(This,pdwEvents)

#define ICorProfilerInfo2_GetFunctionFromIP(This,ip,pFunctionId)	\
    (This)->lpVtbl -> GetFunctionFromIP(This,ip,pFunctionId)

#define ICorProfilerInfo2_GetFunctionFromToken(This,moduleId,token,pFunctionId)	\
    (This)->lpVtbl -> GetFunctionFromToken(This,moduleId,token,pFunctionId)

#define ICorProfilerInfo2_GetHandleFromThread(This,threadId,phThread)	\
    (This)->lpVtbl -> GetHandleFromThread(This,threadId,phThread)

#define ICorProfilerInfo2_GetObjectSize(This,objectId,pcSize)	\
    (This)->lpVtbl -> GetObjectSize(This,objectId,pcSize)

#define ICorProfilerInfo2_IsArrayClass(This,classId,pBaseElemType,pBaseClassId,pcRank)	\
    (This)->lpVtbl -> IsArrayClass(This,classId,pBaseElemType,pBaseClassId,pcRank)

#define ICorProfilerInfo2_GetThreadInfo(This,threadId,pdwWin32ThreadId)	\
    (This)->lpVtbl -> GetThreadInfo(This,threadId,pdwWin32ThreadId)

#define ICorProfilerInfo2_GetCurrentThreadID(This,pThreadId)	\
    (This)->lpVtbl -> GetCurrentThreadID(This,pThreadId)

#define ICorProfilerInfo2_GetClassIDInfo(This,classId,pModuleId,pTypeDefToken)	\
    (This)->lpVtbl -> GetClassIDInfo(This,classId,pModuleId,pTypeDefToken)

#define ICorProfilerInfo2_GetFunctionInfo(This,functionId,pClassId,pModuleId,pToken)	\
    (This)->lpVtbl -> GetFunctionInfo(This,functionId,pClassId,pModuleId,pToken)

#define ICorProfilerInfo2_SetEventMask(This,dwEvents)	\
    (This)->lpVtbl -> SetEventMask(This,dwEvents)

#define ICorProfilerInfo2_SetEnterLeaveFunctionHooks(This,pFuncEnter,pFuncLeave,pFuncTailcall)	\
    (This)->lpVtbl -> SetEnterLeaveFunctionHooks(This,pFuncEnter,pFuncLeave,pFuncTailcall)

#define ICorProfilerInfo2_SetFunctionIDMapper(This,pFunc)	\
    (This)->lpVtbl -> SetFunctionIDMapper(This,pFunc)

#define ICorProfilerInfo2_GetTokenAndMetaDataFromFunction(This,functionId,riid,ppImport,pToken)	\
    (This)->lpVtbl -> GetTokenAndMetaDataFromFunction(This,functionId,riid,ppImport,pToken)

#define ICorProfilerInfo2_GetModuleInfo(This,moduleId,ppBaseLoadAddress,cchName,pcchName,szName,pAssemblyId)	\
    (This)->lpVtbl -> GetModuleInfo(This,moduleId,ppBaseLoadAddress,cchName,pcchName,szName,pAssemblyId)

#define ICorProfilerInfo2_GetModuleMetaData(This,moduleId,dwOpenFlags,riid,ppOut)	\
    (This)->lpVtbl -> GetModuleMetaData(This,moduleId,dwOpenFlags,riid,ppOut)

#define ICorProfilerInfo2_GetILFunctionBody(This,moduleId,methodId,ppMethodHeader,pcbMethodSize)	\
    (This)->lpVtbl -> GetILFunctionBody(This,moduleId,methodId,ppMethodHeader,pcbMethodSize)

#define ICorProfilerInfo2_GetILFunctionBodyAllocator(This,moduleId,ppMalloc)	\
    (This)->lpVtbl -> GetILFunctionBodyAllocator(This,moduleId,ppMalloc)

#define ICorProfilerInfo2_SetILFunctionBody(This,moduleId,methodid,pbNewILMethodHeader)	\
    (This)->lpVtbl -> SetILFunctionBody(This,moduleId,methodid,pbNewILMethodHeader)

#define ICorProfilerInfo2_GetAppDomainInfo(This,appDomainId,cchName,pcchName,szName,pProcessId)	\
    (This)->lpVtbl -> GetAppDomainInfo(This,appDomainId,cchName,pcchName,szName,pProcessId)

#define ICorProfilerInfo2_GetAssemblyInfo(This,assemblyId,cchName,pcchName,szName,pAppDomainId,pModuleId)	\
    (This)->lpVtbl -> GetAssemblyInfo(This,assemblyId,cchName,pcchName,szName,pAppDomainId,pModuleId)

#define ICorProfilerInfo2_SetFunctionReJIT(This,functionId)	\
    (This)->lpVtbl -> SetFunctionReJIT(This,functionId)

#define ICorProfilerInfo2_ForceGC(This)	\
    (This)->lpVtbl -> ForceGC(This)

#define ICorProfilerInfo2_SetILInstrumentedCodeMap(This,functionId,fStartJit,cILMapEntries,rgILMapEntries)	\
    (This)->lpVtbl -> SetILInstrumentedCodeMap(This,functionId,fStartJit,cILMapEntries,rgILMapEntries)

#define ICorProfilerInfo2_GetInprocInspectionInterface(This,ppicd)	\
    (This)->lpVtbl -> GetInprocInspectionInterface(This,ppicd)

#define ICorProfilerInfo2_GetInprocInspectionIThisThread(This,ppicd)	\
    (This)->lpVtbl -> GetInprocInspectionIThisThread(This,ppicd)

#define ICorProfilerInfo2_GetThreadContext(This,threadId,pContextId)	\
    (This)->lpVtbl -> GetThreadContext(This,threadId,pContextId)

#define ICorProfilerInfo2_BeginInprocDebugging(This,fThisThreadOnly,pdwProfilerContext)	\
    (This)->lpVtbl -> BeginInprocDebugging(This,fThisThreadOnly,pdwProfilerContext)

#define ICorProfilerInfo2_EndInprocDebugging(This,dwProfilerContext)	\
    (This)->lpVtbl -> EndInprocDebugging(This,dwProfilerContext)

#define ICorProfilerInfo2_GetILToNativeMapping(This,functionId,cMap,pcMap,map)	\
    (This)->lpVtbl -> GetILToNativeMapping(This,functionId,cMap,pcMap,map)


#define ICorProfilerInfo2_DoStackSnapshot(This,thread,callback,infoFlags,clientData,context,contextSize)	\
    (This)->lpVtbl -> DoStackSnapshot(This,thread,callback,infoFlags,clientData,context,contextSize)

#define ICorProfilerInfo2_SetEnterLeaveFunctionHooks2(This,pFuncEnter,pFuncLeave,pFuncTailcall)	\
    (This)->lpVtbl -> SetEnterLeaveFunctionHooks2(This,pFuncEnter,pFuncLeave,pFuncTailcall)

#define ICorProfilerInfo2_GetFunctionInfo2(This,funcId,frameInfo,pClassId,pModuleId,pToken,cTypeArgs,pcTypeArgs,typeArgs)	\
    (This)->lpVtbl -> GetFunctionInfo2(This,funcId,frameInfo,pClassId,pModuleId,pToken,cTypeArgs,pcTypeArgs,typeArgs)

#define ICorProfilerInfo2_GetStringLayout(This,pBufferLengthOffset,pStringLengthOffset,pBufferOffset)	\
    (This)->lpVtbl -> GetStringLayout(This,pBufferLengthOffset,pStringLengthOffset,pBufferOffset)

#define ICorProfilerInfo2_GetClassLayout(This,classID,rFieldOffset,cFieldOffset,pcFieldOffset,pulClassSize)	\
    (This)->lpVtbl -> GetClassLayout(This,classID,rFieldOffset,cFieldOffset,pcFieldOffset,pulClassSize)

#define ICorProfilerInfo2_GetClassIDInfo2(This,classId,pModuleId,pTypeDefToken,pParentClassId,cNumTypeArgs,pcNumTypeArgs,typeArgs)	\
    (This)->lpVtbl -> GetClassIDInfo2(This,classId,pModuleId,pTypeDefToken,pParentClassId,cNumTypeArgs,pcNumTypeArgs,typeArgs)

#define ICorProfilerInfo2_GetCodeInfo2(This,functionID,cCodeInfos,pcCodeInfos,codeInfos)	\
    (This)->lpVtbl -> GetCodeInfo2(This,functionID,cCodeInfos,pcCodeInfos,codeInfos)

#define ICorProfilerInfo2_GetClassFromTokenAndTypeArgs(This,moduleID,typeDef,cTypeArgs,typeArgs,pClassID)	\
    (This)->lpVtbl -> GetClassFromTokenAndTypeArgs(This,moduleID,typeDef,cTypeArgs,typeArgs,pClassID)

#define ICorProfilerInfo2_GetFunctionFromTokenAndTypeArgs(This,moduleID,funcDef,classId,cTypeArgs,typeArgs,pFunctionID)	\
    (This)->lpVtbl -> GetFunctionFromTokenAndTypeArgs(This,moduleID,funcDef,classId,cTypeArgs,typeArgs,pFunctionID)

#define ICorProfilerInfo2_EnumModuleFrozenObjects(This,moduleID,ppEnum)	\
    (This)->lpVtbl -> EnumModuleFrozenObjects(This,moduleID,ppEnum)

#define ICorProfilerInfo2_GetArrayObjectInfo(This,objectId,cDimensions,pDimensionSizes,pDimensionLowerBounds,ppData)	\
    (This)->lpVtbl -> GetArrayObjectInfo(This,objectId,cDimensions,pDimensionSizes,pDimensionLowerBounds,ppData)

#define ICorProfilerInfo2_GetBoxClassLayout(This,classId,pBufferOffset)	\
    (This)->lpVtbl -> GetBoxClassLayout(This,classId,pBufferOffset)

#define ICorProfilerInfo2_GetThreadAppDomain(This,threadId,pAppDomainId)	\
    (This)->lpVtbl -> GetThreadAppDomain(This,threadId,pAppDomainId)

#define ICorProfilerInfo2_GetRVAStaticAddress(This,classId,fieldToken,ppAddress)	\
    (This)->lpVtbl -> GetRVAStaticAddress(This,classId,fieldToken,ppAddress)

#define ICorProfilerInfo2_GetAppDomainStaticAddress(This,classId,fieldToken,appDomainId,ppAddress)	\
    (This)->lpVtbl -> GetAppDomainStaticAddress(This,classId,fieldToken,appDomainId,ppAddress)

#define ICorProfilerInfo2_GetThreadStaticAddress(This,classId,fieldToken,threadId,ppAddress)	\
    (This)->lpVtbl -> GetThreadStaticAddress(This,classId,fieldToken,threadId,ppAddress)

#define ICorProfilerInfo2_GetContextStaticAddress(This,classId,fieldToken,contextId,ppAddress)	\
    (This)->lpVtbl -> GetContextStaticAddress(This,classId,fieldToken,contextId,ppAddress)

#define ICorProfilerInfo2_GetStaticFieldInfo(This,classId,fieldToken,pFieldInfo)	\
    (This)->lpVtbl -> GetStaticFieldInfo(This,classId,fieldToken,pFieldInfo)

#define ICorProfilerInfo2_GetGenerationBounds(This,cObjectRanges,pcObjectRanges,ranges)	\
    (This)->lpVtbl -> GetGenerationBounds(This,cObjectRanges,pcObjectRanges,ranges)

#define ICorProfilerInfo2_GetObjectGeneration(This,objectId,range)	\
    (This)->lpVtbl -> GetObjectGeneration(This,objectId,range)

#define ICorProfilerInfo2_GetNotifiedExceptionClauseInfo(This,pinfo)	\
    (This)->lpVtbl -> GetNotifiedExceptionClauseInfo(This,pinfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_DoStackSnapshot_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ThreadID thread,
    /* [in] */ StackSnapshotCallback *callback,
    /* [in] */ ULONG32 infoFlags,
    /* [in] */ void *clientData,
    /* [length_is][size_is][in] */ BYTE context[  ],
    /* [in] */ ULONG32 contextSize);


void __RPC_STUB ICorProfilerInfo2_DoStackSnapshot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_SetEnterLeaveFunctionHooks2_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ FunctionEnter2 *pFuncEnter,
    /* [in] */ FunctionLeave2 *pFuncLeave,
    /* [in] */ FunctionTailcall2 *pFuncTailcall);


void __RPC_STUB ICorProfilerInfo2_SetEnterLeaveFunctionHooks2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetFunctionInfo2_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ FunctionID funcId,
    /* [in] */ COR_PRF_FRAME_INFO frameInfo,
    /* [out] */ ClassID *pClassId,
    /* [out] */ ModuleID *pModuleId,
    /* [out] */ mdToken *pToken,
    /* [in] */ ULONG32 cTypeArgs,
    /* [out] */ ULONG32 *pcTypeArgs,
    /* [out] */ ClassID typeArgs[  ]);


void __RPC_STUB ICorProfilerInfo2_GetFunctionInfo2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetStringLayout_Proxy( 
    ICorProfilerInfo2 * This,
    /* [out] */ ULONG *pBufferLengthOffset,
    /* [out] */ ULONG *pStringLengthOffset,
    /* [out] */ ULONG *pBufferOffset);


void __RPC_STUB ICorProfilerInfo2_GetStringLayout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetClassLayout_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ClassID classID,
    /* [out][in] */ COR_FIELD_OFFSET rFieldOffset[  ],
    /* [in] */ ULONG cFieldOffset,
    /* [out] */ ULONG *pcFieldOffset,
    /* [out] */ ULONG *pulClassSize);


void __RPC_STUB ICorProfilerInfo2_GetClassLayout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetClassIDInfo2_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ClassID classId,
    /* [out] */ ModuleID *pModuleId,
    /* [out] */ mdTypeDef *pTypeDefToken,
    /* [out] */ ClassID *pParentClassId,
    /* [in] */ ULONG32 cNumTypeArgs,
    /* [out] */ ULONG32 *pcNumTypeArgs,
    /* [out] */ ClassID typeArgs[  ]);


void __RPC_STUB ICorProfilerInfo2_GetClassIDInfo2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetCodeInfo2_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ FunctionID functionID,
    /* [in] */ ULONG32 cCodeInfos,
    /* [out] */ ULONG32 *pcCodeInfos,
    /* [length_is][size_is][out] */ COR_PRF_CODE_INFO codeInfos[  ]);


void __RPC_STUB ICorProfilerInfo2_GetCodeInfo2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetClassFromTokenAndTypeArgs_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ModuleID moduleID,
    /* [in] */ mdTypeDef typeDef,
    /* [in] */ ULONG32 cTypeArgs,
    /* [size_is][in] */ ClassID typeArgs[  ],
    /* [out] */ ClassID *pClassID);


void __RPC_STUB ICorProfilerInfo2_GetClassFromTokenAndTypeArgs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetFunctionFromTokenAndTypeArgs_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ModuleID moduleID,
    /* [in] */ mdMethodDef funcDef,
    /* [in] */ ClassID classId,
    /* [in] */ ULONG32 cTypeArgs,
    /* [size_is][in] */ ClassID typeArgs[  ],
    /* [out] */ FunctionID *pFunctionID);


void __RPC_STUB ICorProfilerInfo2_GetFunctionFromTokenAndTypeArgs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_EnumModuleFrozenObjects_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ModuleID moduleID,
    /* [out] */ ICorProfilerObjectEnum **ppEnum);


void __RPC_STUB ICorProfilerInfo2_EnumModuleFrozenObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetArrayObjectInfo_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ObjectID objectId,
    /* [in] */ ULONG32 cDimensions,
    /* [length_is][size_is][out] */ ULONG32 pDimensionSizes[  ],
    /* [length_is][size_is][out] */ int pDimensionLowerBounds[  ],
    /* [out] */ BYTE **ppData);


void __RPC_STUB ICorProfilerInfo2_GetArrayObjectInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetBoxClassLayout_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ClassID classId,
    /* [out] */ ULONG32 *pBufferOffset);


void __RPC_STUB ICorProfilerInfo2_GetBoxClassLayout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetThreadAppDomain_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ThreadID threadId,
    /* [out] */ AppDomainID *pAppDomainId);


void __RPC_STUB ICorProfilerInfo2_GetThreadAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetRVAStaticAddress_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ClassID classId,
    /* [in] */ mdFieldDef fieldToken,
    /* [out] */ void **ppAddress);


void __RPC_STUB ICorProfilerInfo2_GetRVAStaticAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetAppDomainStaticAddress_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ClassID classId,
    /* [in] */ mdFieldDef fieldToken,
    /* [in] */ AppDomainID appDomainId,
    /* [out] */ void **ppAddress);


void __RPC_STUB ICorProfilerInfo2_GetAppDomainStaticAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetThreadStaticAddress_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ClassID classId,
    /* [in] */ mdFieldDef fieldToken,
    /* [in] */ ThreadID threadId,
    /* [out] */ void **ppAddress);


void __RPC_STUB ICorProfilerInfo2_GetThreadStaticAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetContextStaticAddress_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ClassID classId,
    /* [in] */ mdFieldDef fieldToken,
    /* [in] */ ContextID contextId,
    /* [out] */ void **ppAddress);


void __RPC_STUB ICorProfilerInfo2_GetContextStaticAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetStaticFieldInfo_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ClassID classId,
    /* [in] */ mdFieldDef fieldToken,
    /* [out] */ COR_PRF_STATIC_TYPE *pFieldInfo);


void __RPC_STUB ICorProfilerInfo2_GetStaticFieldInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetGenerationBounds_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ULONG cObjectRanges,
    /* [out] */ ULONG *pcObjectRanges,
    /* [length_is][size_is][out] */ COR_PRF_GC_GENERATION_RANGE ranges[  ]);


void __RPC_STUB ICorProfilerInfo2_GetGenerationBounds_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetObjectGeneration_Proxy( 
    ICorProfilerInfo2 * This,
    /* [in] */ ObjectID objectId,
    /* [out] */ COR_PRF_GC_GENERATION_RANGE *range);


void __RPC_STUB ICorProfilerInfo2_GetObjectGeneration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerInfo2_GetNotifiedExceptionClauseInfo_Proxy( 
    ICorProfilerInfo2 * This,
    /* [out] */ COR_PRF_EX_CLAUSE_INFO *pinfo);


void __RPC_STUB ICorProfilerInfo2_GetNotifiedExceptionClauseInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorProfilerInfo2_INTERFACE_DEFINED__ */


#ifndef __ICorProfilerObjectEnum_INTERFACE_DEFINED__
#define __ICorProfilerObjectEnum_INTERFACE_DEFINED__

/* interface ICorProfilerObjectEnum */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ICorProfilerObjectEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2C6269BD-2D13-4321-AE12-6686365FD6AF")
    ICorProfilerObjectEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ ICorProfilerObjectEnum **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG *pcelt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ObjectID objects[  ],
            /* [out] */ ULONG *pceltFetched) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorProfilerObjectEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorProfilerObjectEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorProfilerObjectEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorProfilerObjectEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            ICorProfilerObjectEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICorProfilerObjectEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ICorProfilerObjectEnum * This,
            /* [out] */ ICorProfilerObjectEnum **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetCount )( 
            ICorProfilerObjectEnum * This,
            /* [out] */ ULONG *pcelt);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            ICorProfilerObjectEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ObjectID objects[  ],
            /* [out] */ ULONG *pceltFetched);
        
        END_INTERFACE
    } ICorProfilerObjectEnumVtbl;

    interface ICorProfilerObjectEnum
    {
        CONST_VTBL struct ICorProfilerObjectEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorProfilerObjectEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorProfilerObjectEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorProfilerObjectEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorProfilerObjectEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define ICorProfilerObjectEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define ICorProfilerObjectEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define ICorProfilerObjectEnum_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#define ICorProfilerObjectEnum_Next(This,celt,objects,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,objects,pceltFetched)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorProfilerObjectEnum_Skip_Proxy( 
    ICorProfilerObjectEnum * This,
    /* [in] */ ULONG celt);


void __RPC_STUB ICorProfilerObjectEnum_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerObjectEnum_Reset_Proxy( 
    ICorProfilerObjectEnum * This);


void __RPC_STUB ICorProfilerObjectEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerObjectEnum_Clone_Proxy( 
    ICorProfilerObjectEnum * This,
    /* [out] */ ICorProfilerObjectEnum **ppEnum);


void __RPC_STUB ICorProfilerObjectEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerObjectEnum_GetCount_Proxy( 
    ICorProfilerObjectEnum * This,
    /* [out] */ ULONG *pcelt);


void __RPC_STUB ICorProfilerObjectEnum_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorProfilerObjectEnum_Next_Proxy( 
    ICorProfilerObjectEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ObjectID objects[  ],
    /* [out] */ ULONG *pceltFetched);


void __RPC_STUB ICorProfilerObjectEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorProfilerObjectEnum_INTERFACE_DEFINED__ */


#ifndef __IMethodMalloc_INTERFACE_DEFINED__
#define __IMethodMalloc_INTERFACE_DEFINED__

/* interface IMethodMalloc */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IMethodMalloc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A0EFB28B-6EE2-4d7b-B983-A75EF7BEEDB8")
    IMethodMalloc : public IUnknown
    {
    public:
        virtual PVOID STDMETHODCALLTYPE Alloc( 
            /* [in] */ ULONG cb) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMethodMallocVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IMethodMalloc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IMethodMalloc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IMethodMalloc * This);
        
        PVOID ( STDMETHODCALLTYPE *Alloc )( 
            IMethodMalloc * This,
            /* [in] */ ULONG cb);
        
        END_INTERFACE
    } IMethodMallocVtbl;

    interface IMethodMalloc
    {
        CONST_VTBL struct IMethodMallocVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMethodMalloc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMethodMalloc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMethodMalloc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMethodMalloc_Alloc(This,cb)	\
    (This)->lpVtbl -> Alloc(This,cb)

#endif /* COBJMACROS */


#endif 	/* C style interface */



PVOID STDMETHODCALLTYPE IMethodMalloc_Alloc_Proxy( 
    IMethodMalloc * This,
    /* [in] */ ULONG cb);


void __RPC_STUB IMethodMalloc_Alloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMethodMalloc_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\corhlpr.h ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
/*****************************************************************************
 **                                                                         **
 ** Corhlpr.h - <STRIP>this file contains a set of "as is" code that may be **
 **             used by developers writing compilers and tools against      **
 **             the Common Language Runtime. The code is not officially     **
 **             supported, but is code being used by the Runtime itself.    **
 ** </STRIP>                                                                **
 **                                                                         **
 *****************************************************************************/


#ifndef __CORHLPR_H__
#define __CORHLPR_H__

#include "cor.h"
#include "corhdr.h"
#include "corerror.h"

// This header is consumed both within the runtime and externally. In the former
// case we need to wrap memory allocations, in the latter there is no
// infrastructure to support this. Detect which way we're building and provide a
// very simple abstraction layer (handles allocating bytes only).
#ifdef _BLD_CLR
#include "new.hpp"
#define NEW_NOTHROW(_bytes) new (nothrow) BYTE[_bytes]
#define NEW_THROWS(_bytes) new BYTE[_bytes]
#else
#define NEW_NOTHROW(_bytes) new BYTE[_bytes]
#define NEW_THROWS(_bytes) __CorHlprNewThrows(_bytes)
static inline BYTE *__CorHlprNewThrows(size_t bytes)
{
    BYTE *pbMemory = new BYTE[bytes];
    if (pbMemory == NULL)
        RaiseException(STATUS_NO_MEMORY, 0, 0, NULL);
    return pbMemory;
}
#endif


//*****************************************************************************
// There are a set of macros commonly used in the helpers which you will want
// to override to get richer behavior.  The following defines what is needed
// if you chose not to do the extra work.
//*****************************************************************************
#ifndef IfFailGoto
#define IfFailGoto(EXPR, LABEL) \
do { hr = (EXPR); if(FAILED(hr)) { goto LABEL; } } while (0)
#endif

#ifndef IfFailGo
#define IfFailGo(EXPR) IfFailGoto(EXPR, ErrExit)
#endif

#ifndef IfFailRet
#define IfFailRet(EXPR) do { hr = (EXPR); if(FAILED(hr)) { return (hr); } } while (0)
#endif

#ifndef IfNullRet
#define IfNullRet(EXPR) do { if ((EXPR) == NULL){ return (E_OUTOFMEMORY); } } while (0)
#endif


#ifndef _ASSERTE
#define _ASSERTE(expr)
#endif

#ifndef COUNTOF
#define COUNTOF(a) (sizeof(a) / sizeof(*a))
#endif

#if !BIGENDIAN
#define VAL16(x) x
#define VAL32(x) x
#endif


//*****************************************************************************
//
//***** Macro to assist with cleaning up local static variables
//
//*****************************************************************************

#define CHECK_LOCAL_STATIC_VAR(x)   \
    x                                \

//*****************************************************************************
//
//***** Utility helpers
//
//*****************************************************************************


#define MAX_CLASSNAME_LENGTH 1024

#ifndef SOS_INCLUDE

//*****************************************************************************
//
// **** CQuickBytes
// This helper class is useful for cases where 90% of the time you allocate 512
// or less bytes for a data structure.  This class contains a 512 byte buffer.
// Alloc() will return a pointer to this buffer if your allocation is small
// enough, otherwise it asks the heap for a larger buffer which is freed for
// you.  No mutex locking is required for the small allocation case, making the
// code run faster, less heap fragmentation, etc...  Each instance will allocate
// 520 bytes, so use accordinly.
//
//*****************************************************************************
template <DWORD SIZE, DWORD INCREMENT>
class CQuickMemoryBase
{
public:
    void Init()
    {
        pbBuff = 0;
        iSize = 0;
        cbTotal = SIZE;
    }

    void Destroy()
    {
        if (pbBuff)
        {
            delete [] pbBuff;
            pbBuff = 0;
        }
    }

    void *AllocThrows(SIZE_T iItems)
    {
#ifdef _BLD_CLR
#ifdef _DEBUG
        delete [] NEW_THROWS(iItems);    // Exercise heap for OOM-fault injection purposes
#endif
#endif
        if (iItems <= SIZE)
        {
            iSize = iItems;
            cbTotal = SIZE;
            return (&rgData[0]);
        }
        else
        {
            BYTE *pTmp = NEW_THROWS(iItems);

            if (pbBuff) delete [] pbBuff;
            // We need the following line to make data structure consistant if
            // new throws.
            iSize = iItems;
            cbTotal = 0;
            pbBuff = pTmp;
            cbTotal = iItems;
            return (pbBuff);
        }
    }

    void *AllocNoThrow(SIZE_T iItems)
    {
#ifdef _BLD_CLR
#ifdef _DEBUG
        {
            // Exercise heap for OOM-fault injection purposes
            BYTE *pTmp = NEW_NOTHROW(iItems);
            if (!pTmp)
            {
                return NULL;
            }
            delete [] pTmp;
        }
#endif
#endif
        if (iItems <= SIZE)
        {
            cbTotal = SIZE;
            iSize = iItems;
            return (&rgData[0]);
        }
        else
        {
            if (pbBuff) delete [] pbBuff;
            pbBuff = NEW_NOTHROW(iItems);
            if (pbBuff)
            {
                cbTotal = iItems;
                iSize   = iItems;
            }
            else
            {
                cbTotal = 0;
                iSize   = 0;
            }
            return (pbBuff);
        }
    }

    void ReSizeThrows(SIZE_T iItems)
    {
#ifdef _BLD_CLR
#ifdef _DEBUG
        // Exercise heap for OOM-fault injection purposes
        delete [] NEW_THROWS(iItems);
#endif
#endif
        BYTE *pbBuffNew;
        if (iItems <= cbTotal)
        {
            iSize = iItems;
            return;
        }

        pbBuffNew = NEW_THROWS(iItems + INCREMENT);

        if (pbBuff)
        {
            memcpy(pbBuffNew, pbBuff, cbTotal);
            delete [] pbBuff;
        }
        else
        {
            _ASSERTE(cbTotal == SIZE);
            memcpy(pbBuffNew, rgData, cbTotal);
        }
        cbTotal = iItems + INCREMENT;
        iSize = iItems;
        pbBuff = pbBuffNew;
    }

    HRESULT ReSizeNoThrow(SIZE_T iItems);

    void Shrink(SIZE_T iItems)
    {
        _ASSERTE(iItems <= cbTotal);
        iSize = iItems;
    }

    operator PVOID()
    {
        return ((pbBuff) ? pbBuff : (PVOID)&rgData[0]);
    }

    void *Ptr()
    {
        return ((pbBuff) ? pbBuff : (PVOID)&rgData[0]);
    }

    const void *Ptr() const
    {
        return ((pbBuff) ? pbBuff : (PVOID)&rgData[0]);
    }

    SIZE_T Size() const
    {
        return (iSize);
    }

    SIZE_T MaxSize() const
    {
        return (cbTotal);
    }

    void Maximize()
    {
        iSize = cbTotal;
    }

    BYTE       *pbBuff;
    SIZE_T      iSize;              // number of bytes used
    SIZE_T      cbTotal;            // total bytes allocated in the buffer
    // use UINT64 to enforce the alignment of the memory
    UINT64 rgData[(SIZE+sizeof(UINT64)-1)/sizeof(UINT64)];
};

// These should be multiples of 8 so that data can be naturally aligned.
#define     CQUICKBYTES_BASE_SIZE           512
#define     CQUICKBYTES_INCREMENTAL_SIZE    128

class CQuickBytesBase : public CQuickMemoryBase<CQUICKBYTES_BASE_SIZE, CQUICKBYTES_INCREMENTAL_SIZE>
{
};

class CQuickBytes : public CQuickBytesBase
{
public:
    CQuickBytes()
    {
        Init();
    }

    ~CQuickBytes()
    {
        Destroy();
    }
};

/* to be used as static variable - no constructor/destructor, assumes zero
   initialized memory */
class CQuickBytesStatic : public CQuickBytesBase
{
};

template <DWORD CQUICKBYTES_BASE_SPECIFY_SIZE>
class CQuickBytesSpecifySizeBase : public CQuickMemoryBase<CQUICKBYTES_BASE_SPECIFY_SIZE, CQUICKBYTES_INCREMENTAL_SIZE>
{
};

template <DWORD CQUICKBYTES_BASE_SPECIFY_SIZE>
class CQuickBytesSpecifySize : public CQuickBytesSpecifySizeBase<CQUICKBYTES_BASE_SPECIFY_SIZE>
{
public:
    CQuickBytesSpecifySize()
    {
        Init();
    }

    ~CQuickBytesSpecifySize()
    {
        Destroy();
    }
};

/* to be used as static variable - no constructor/destructor, assumes zero
   initialized memory */
template <DWORD CQUICKBYTES_BASE_SPECIFY_SIZE>
class CQuickBytesSpecifySizeStatic : public CQuickBytesSpecifySizeBase<CQUICKBYTES_BASE_SPECIFY_SIZE>
{
};

template <class T> class CQuickArrayBase : public CQuickBytesBase
{
public:
    T* AllocThrows(int iItems)
    {   
        return (T*)CQuickBytesBase::AllocThrows(iItems * sizeof(T)); 
    }

    void ReSizeThrows(SIZE_T iItems)
    { 
        CQuickBytesBase::ReSizeThrows(iItems * sizeof(T));
    }

    T* AllocNoThrow(int iItems)
    { 
        return (T*)CQuickBytesBase::AllocNoThrow(iItems * sizeof(T)); 
    }

    HRESULT ReSizeNoThrow(SIZE_T iItems)
    { 
        return CQuickBytesBase::ReSizeNoThrow(iItems * sizeof(T)); 
    }
    
    void Shrink(SIZE_T iItems)    
    { 
        CQuickBytesBase::Shrink(iItems * sizeof(T)); 
    }

    T* Ptr()
    { 
        return (T*) CQuickBytesBase::Ptr(); 
    }

    const T* Ptr() const
    { 
        return (T*) CQuickBytesBase::Ptr(); 
    }

    SIZE_T Size() const
    { 
        return CQuickBytesBase::Size() / sizeof(T); 
    }

    SIZE_T MaxSize() const
    { 
        return CQuickBytesBase::cbTotal / sizeof(T); 
    }

    T& operator[] (SIZE_T ix)
    { 
        _ASSERTE(ix < Size());
        return *(Ptr() + ix);
    }

    const T& operator[] (SIZE_T ix) const
    { 
        _ASSERTE(ix < Size());
        return *(Ptr() + ix);
    }
};

template <class T> class CQuickArray : public CQuickArrayBase<T>
{
public:
    CQuickArray<T>()
    {
        Init();
    }

    ~CQuickArray<T>()
    {
        Destroy();
    }
};

/* to be used as static variable - no constructor/destructor, assumes zero
   initialized memory */
template <class T> class CQuickArrayStatic : public CQuickArrayBase<T>
{
};

typedef CQuickArrayBase<WCHAR> CQuickWSTRBase;
typedef CQuickArray<WCHAR> CQuickWSTR;
typedef CQuickArrayStatic<WCHAR> CQuickWSTRStatic;

typedef CQuickArrayBase<CHAR> CQuickSTRBase;
typedef CQuickArray<CHAR> CQuickSTR;
typedef CQuickArrayStatic<CHAR> CQuickSTRStatic;

class RidBitmap
{
public:
    HRESULT InsertToken(mdToken token)
    {
        mdToken rid   = RidFromToken(token);
        SIZE_T  index = rid / 8;
        BYTE    bit   = (1 << (rid % 8));

        if (index >= buffer.Size())
        {
            HRESULT hr;
            SIZE_T oldSize = buffer.Size();
            SIZE_T newSize = index+1+oldSize/8;
            IfFailRet(buffer.ReSizeNoThrow(newSize));
            memset(&buffer[oldSize], 0, newSize-oldSize);
        }

        buffer[index] |= bit;
        return S_OK;
    }

    bool IsTokenInBitmap(mdToken token)
    {
        mdToken rid   = RidFromToken(token);
        SIZE_T  index = rid / 8;
        BYTE    bit   = (1 << (rid % 8));

        return ((index < buffer.Size()) && (buffer[index] & bit));
    }

    void Reset()
    {
        if (buffer.Size()) 
        {
            memset(&buffer[0], 0, buffer.Size());
        }
    }

private:
    CQuickArray<BYTE> buffer;
};

#endif // SOS_INCLUDE
//*****************************************************************************
//
//***** Signature helpers
//
//*****************************************************************************

inline bool isCallConv(unsigned sigByte, CorCallingConvention conv)
{
    return ((sigByte & IMAGE_CEE_CS_CALLCONV_MASK) == (unsigned) conv);
}

HRESULT _CountBytesOfOneArg(
    PCCOR_SIGNATURE pbSig,
    ULONG       *pcbTotal);

HRESULT _GetFixedSigOfVarArg(           // S_OK or error.
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob of CLR signature
    ULONG   cbSigBlob,                  // [IN] size of signature
    CQuickBytes *pqbSig,                // [OUT] output buffer for fixed part of VarArg Signature
    ULONG   *pcbSigBlob);               // [OUT] number of bytes written to the above output buffer




//*****************************************************************************
//
//***** File format helper classes
//
//*****************************************************************************



//*****************************************************************************
typedef struct tagCOR_ILMETHOD_SECT_SMALL : IMAGE_COR_ILMETHOD_SECT_SMALL {
        //Data follows
    const BYTE* Data() const 
    { 
        return(((const BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_SECT_SMALL)); 
    }
} COR_ILMETHOD_SECT_SMALL;


/************************************/
/* NOTE this structure must be DWORD aligned!! */
typedef struct tagCOR_ILMETHOD_SECT_FAT : IMAGE_COR_ILMETHOD_SECT_FAT {
        //Data follows
    const BYTE* Data() const 
    { 
        return(((const BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_SECT_FAT)); 
    }

        //Endian-safe wrappers
    unsigned GetKind() const {
        /* return Kind; */
        return *(BYTE*)this;
    }
    void SetKind(unsigned kind) {
        /* Kind = kind; */
        *(BYTE*)this = (BYTE)kind;
    }

    unsigned GetDataSize() const {
        /* return DataSize; */
        BYTE* p = (BYTE*)this;
        return ((unsigned)*(p+1)) |
            (((unsigned)*(p+2)) << 8) |
            (((unsigned)*(p+3)) << 16);
    }
    void SetDataSize(unsigned datasize) {
        /* DataSize = dataSize; */
        BYTE* p = (BYTE*)this;
        *(p+1) = (BYTE)(datasize);
        *(p+2) = (BYTE)(datasize >> 8);
        *(p+3) = (BYTE)(datasize >> 16);
    }
} COR_ILMETHOD_SECT_FAT;

typedef struct tagCOR_ILMETHOD_SECT_EH_CLAUSE_FAT : public IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT {
    //Endian-safe wrappers
    CorExceptionFlag GetFlags() const {
        return (CorExceptionFlag)VAL32((unsigned)Flags);
    }
    void SetFlags(CorExceptionFlag flags) {
        Flags = (CorExceptionFlag)VAL32((unsigned)flags);
    }

    DWORD GetTryOffset() const {
        return VAL32(TryOffset);
    }
    void SetTryOffset(DWORD Offset) {
        TryOffset = VAL32(Offset);
    }

    DWORD GetTryLength() const {
        return VAL32(TryLength);
    }
    void SetTryLength(DWORD Length) {
        TryLength = VAL32(Length);
    }

    DWORD GetHandlerOffset() const {
        return VAL32(HandlerOffset);
    }
    void SetHandlerOffset(DWORD Offset) {
        HandlerOffset = VAL32(Offset);
    }

    DWORD GetHandlerLength() const {
        return VAL32(HandlerLength);
    }
    void SetHandlerLength(DWORD Length) {
        HandlerLength = VAL32(Length);
    }

    DWORD GetClassToken() const {
        return VAL32(ClassToken);
    }
    void SetClassToken(DWORD tok) {
        ClassToken = VAL32(tok);
    }

    DWORD GetFilterOffset() const {
        return VAL32(FilterOffset);
    }
    void SetFilterOffset(DWORD offset) {
        FilterOffset = VAL32(offset);
    }

} COR_ILMETHOD_SECT_EH_CLAUSE_FAT;

//*****************************************************************************
struct COR_ILMETHOD_SECT_EH_FAT : public COR_ILMETHOD_SECT_FAT {
    static unsigned Size(unsigned ehCount) {
        return (sizeof(COR_ILMETHOD_SECT_EH_FAT) +
                sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT) * (ehCount-1));
        }

    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT Clauses[1];     // actually variable size
};

typedef struct tagCOR_ILMETHOD_SECT_EH_CLAUSE_SMALL : public IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL {
    //Endian-safe wrappers
    CorExceptionFlag GetFlags() const {
        return (CorExceptionFlag)VAL16((SHORT)Flags);
    }
    void SetFlags(CorExceptionFlag flags) {
        Flags = (CorExceptionFlag)VAL16((SHORT)flags);
    }

    DWORD GetTryOffset() const {
        return VAL16(TryOffset);
    }
    void SetTryOffset(DWORD Offset) {
        TryOffset = VAL16(Offset);
    }

    DWORD GetTryLength() const {
        return TryLength;
    }
    void SetTryLength(DWORD Length) {
        TryLength = Length;
    }

    DWORD GetHandlerOffset() const {
        return VAL16(HandlerOffset);
    }
    void SetHandlerOffset(DWORD Offset) {
        HandlerOffset = VAL16(Offset);
    }

    DWORD GetHandlerLength() const {
        return HandlerLength;
    }
    void SetHandlerLength(DWORD Length) {
        HandlerLength = Length;
    }

    DWORD GetClassToken() const {
        return VAL32(ClassToken);
    }
    void SetClassToken(DWORD tok) {
        ClassToken = VAL32(tok);
    }

    DWORD GetFilterOffset() const {
        return VAL32(FilterOffset);
    }
    void SetFilterOffset(DWORD offset) {
        FilterOffset = VAL32(offset);
    }
} COR_ILMETHOD_SECT_EH_CLAUSE_SMALL;

//*****************************************************************************
struct COR_ILMETHOD_SECT_EH_SMALL : public COR_ILMETHOD_SECT_SMALL {
    static unsigned Size(unsigned ehCount) {
        return (sizeof(COR_ILMETHOD_SECT_EH_SMALL) +
                sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL) * (ehCount-1));
        }

    WORD Reserved;                                  // alignment padding
    IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL Clauses[1];   // actually variable size
};


/************************************/
/* NOTE this structure must be DWORD aligned!! */
struct COR_ILMETHOD_SECT
{
    bool More() const           
    { 
        return((AsSmall()->Kind & CorILMethod_Sect_MoreSects) != 0); 
    }

    CorILMethodSect Kind() const
    { 
        return((CorILMethodSect) (AsSmall()->Kind & CorILMethod_Sect_KindMask)); 
    }

    const COR_ILMETHOD_SECT* Next() const   
    {
        if (!More()) return(0);
        if (IsFat()) return(((COR_ILMETHOD_SECT*) &AsFat()->Data()[AsFat()->GetDataSize()])->Align());
        return(((COR_ILMETHOD_SECT*) &AsSmall()->Data()[AsSmall()->DataSize])->Align());
    }

    const COR_ILMETHOD_SECT* NextLoc() const   
    {
        if (IsFat()) return(((COR_ILMETHOD_SECT*) &AsFat()->Data()[AsFat()->GetDataSize()])->Align());
        return(((COR_ILMETHOD_SECT*) &AsSmall()->Data()[AsSmall()->DataSize])->Align());
    }

    const BYTE* Data() const 
    {
        if (IsFat()) return(AsFat()->Data());
        return(AsSmall()->Data());
    }

    unsigned EHSize() const
    {
        // Work around a bug where VB doesn't specify the size correctly for EH sections

        if (Kind() == CorILMethod_Sect_EHTable) 
        {
            if (IsFat())
                return Fat.Size(Fat.GetDataSize() / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT));
            else
                return Small.Size(Small.DataSize / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL));
        }

        return 0;
    }

    unsigned DataSizeHelper() const 
    {
        if (IsFat()) return(AsFat()->GetDataSize());
        return(AsSmall()->DataSize);
    }

    unsigned DataSize() const
    {
        // When VB fixes bug #26859 (where they don't specify DataSize correctly), we can
        // remove this code and just use the code in DataSizeHelper.
        unsigned ehSize = EHSize();
        unsigned dataSizeHelper = DataSizeHelper();
        return (dataSizeHelper > ehSize) ? dataSizeHelper : ehSize;
    }

    friend struct COR_ILMETHOD;
    friend struct tagCOR_ILMETHOD_FAT;
    friend struct tagCOR_ILMETHOD_TINY;
    bool IsFat() const                            
    { 
        return((AsSmall()->Kind & CorILMethod_Sect_FatFormat) != 0); 
    }

    const COR_ILMETHOD_SECT* Align() const        
    { 
        return((COR_ILMETHOD_SECT*) ((((UINT_PTR) this) + 3) & ~3));  
    }

protected:
    const COR_ILMETHOD_SECT_FAT*   AsFat() const  
    { 
        return((COR_ILMETHOD_SECT_FAT*) this); 
    }

    const COR_ILMETHOD_SECT_SMALL* AsSmall() const
    { 
        return((COR_ILMETHOD_SECT_SMALL*) this); 
    }

public:
    // The body is either a COR_ILMETHOD_SECT_SMALL or COR_ILMETHOD_SECT_FAT
    // (as indicated by the CorILMethod_Sect_FatFormat bit
    union {
        COR_ILMETHOD_SECT_EH_SMALL Small;
        COR_ILMETHOD_SECT_EH_FAT Fat;
        };
};


/***********************************/
// exported functions (implementation in Format\Format.cpp:
extern "C" {
IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* __stdcall SectEH_EHClause(void *pSectEH, unsigned idx, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* buff);
        // compute the size of the section (best format)
        // codeSize is the size of the method
    // deprecated
unsigned __stdcall SectEH_SizeWithCode(unsigned ehCount, unsigned codeSize);

    // will return worse-case size and then Emit will return actual size
unsigned __stdcall SectEH_SizeWorst(unsigned ehCount);

    // will return exact size which will match the size returned by Emit
unsigned __stdcall SectEH_SizeExact(unsigned ehCount, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses);

        // emit the section (best format);
unsigned __stdcall SectEH_Emit(unsigned size, unsigned ehCount,
                  IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses,
                  BOOL moreSections, BYTE* outBuff,
                  ULONG* ehTypeOffsets = 0);
} // extern "C"


struct COR_ILMETHOD_SECT_EH : public COR_ILMETHOD_SECT
{
    unsigned EHCount() const 
    {
        return (unsigned)(IsFat() ? (Fat.GetDataSize() / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT)) :
                        (Small.DataSize / sizeof(IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_SMALL)));
    }

        // return one clause in its fat form.  Use 'buff' if needed
    const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* EHClause(unsigned idx, IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* buff) const
    { 
        return SectEH_EHClause((void *)this, idx, buff); 
    };
        // compute the size of the section (best format)
        // codeSize is the size of the method
    // deprecated
    unsigned static Size(unsigned ehCount, unsigned codeSize)
    { 
        return SectEH_SizeWithCode(ehCount, codeSize); 
    };

    // will return worse-case size and then Emit will return actual size
    unsigned static Size(unsigned ehCount)
    { 
        return SectEH_SizeWorst(ehCount); 
    };

    // will return exact size which will match the size returned by Emit
    unsigned static Size(unsigned ehCount, const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses)
    { 
        return SectEH_SizeExact(ehCount, (IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)clauses);  
    };

        // emit the section (best format);
    unsigned static Emit(unsigned size, unsigned ehCount,
                  const IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT* clauses,
                  bool moreSections, BYTE* outBuff,
                  ULONG* ehTypeOffsets = 0)
    { 
        return SectEH_Emit(size, ehCount,
                           (IMAGE_COR_ILMETHOD_SECT_EH_CLAUSE_FAT*)clauses,
                           moreSections, outBuff, ehTypeOffsets); 
    };
};


/***************************************************************************/
/* Used when the method is tiny (< 64 bytes), and there are no local vars */
typedef struct tagCOR_ILMETHOD_TINY : IMAGE_COR_ILMETHOD_TINY
{
    bool     IsTiny() const         
    { 
        return((Flags_CodeSize & (CorILMethod_FormatMask >> 1)) == CorILMethod_TinyFormat); 
    }

    unsigned GetCodeSize() const    
    { 
        return(((unsigned) Flags_CodeSize) >> (CorILMethod_FormatShift-1)); 
    }

    unsigned GetMaxStack() const    
    { 
        return(8); 
    }

    BYTE*    GetCode() const        
    { 
        return(((BYTE*) this) + sizeof(struct tagCOR_ILMETHOD_TINY)); 
    }

    DWORD    GetLocalVarSigTok() const  
    { 
        return(0); 
    }

    COR_ILMETHOD_SECT* GetSect() const 
    { 
        return(0); 
    }
} COR_ILMETHOD_TINY;


/************************************/
// This strucuture is the 'fat' layout, where no compression is attempted.
// Note that this structure can be added on at the end, thus making it extensible
typedef struct tagCOR_ILMETHOD_FAT : IMAGE_COR_ILMETHOD_FAT
{
        //Endian-safe wrappers
    unsigned GetSize() const {
        /* return Size; */
        BYTE* p = (BYTE*)this;
        return *(p+1) >> 4;
    }
    void SetSize(unsigned size) {
        /* Size = size; */
        BYTE* p = (BYTE*)this;
        *(p+1) = (BYTE)((*(p+1) & 0x0F) | (size << 4));
    }

    unsigned GetFlags() const {
        /* return Flags; */
        BYTE* p = (BYTE*)this;
        return ((unsigned)*(p+0)) | (( ((unsigned)*(p+1)) << 8) & 0x0F);
    }
    void SetFlags(unsigned flags) {
        /* flags = Flags; */
        BYTE* p = (BYTE*)this;
        *p = (BYTE)flags;
        *(p+1) = (BYTE)((*(p+1) & 0xF0) | ((flags >> 8) & 0x0F));
    }

    bool IsFat() const {
        /* return((IMAGE_COR_ILMETHOD_FAT::GetFlags() & CorILMethod_FormatMask) == CorILMethod_FatFormat); */
        return (*(BYTE*)this & CorILMethod_FormatMask) == CorILMethod_FatFormat;
    }

    unsigned GetMaxStack() const {
        /* return MaxStack; */
        return VAL16(*(USHORT*)((BYTE*)this+2));
    }
    void SetMaxStack(unsigned maxStack) {
        /* MaxStack = maxStack; */
        *(USHORT*)((BYTE*)this+2) = VAL16((USHORT)maxStack);
    }

    unsigned GetCodeSize() const        
    { 
        return VAL32(CodeSize); 
    }

    void SetCodeSize(DWORD Size)        
    { 
        CodeSize = VAL32(Size); 
    }

    mdToken  GetLocalVarSigTok() const      
    { 
        return VAL32(LocalVarSigTok); 
    }

    void SetLocalVarSigTok(mdSignature tok) 
    { 
        LocalVarSigTok = VAL32(tok); 
    }

    BYTE* GetCode() const {
        return(((BYTE*) this) + 4*GetSize());
    }

    const COR_ILMETHOD_SECT* GetSect() const {
        /* if (!(GetFlags() & CorILMethod_MoreSects)) return(0); */
        if (!(*(BYTE*)this & CorILMethod_MoreSects)) return (0);
        return(((COR_ILMETHOD_SECT*) (GetCode() + GetCodeSize()))->Align());
    }
} COR_ILMETHOD_FAT;


extern "C" {
/************************************/
// exported functions (impl. Format\Format.cpp)
unsigned __stdcall IlmethodSize(COR_ILMETHOD_FAT* header, BOOL MoreSections);
        // emit the header (bestFormat) return amount emitted
unsigned __stdcall IlmethodEmit(unsigned size, COR_ILMETHOD_FAT* header,
                  BOOL moreSections, BYTE* outBuff);
}

struct COR_ILMETHOD
{
        // a COR_ILMETHOD header should not be decoded by hand.  Instead us
        // COR_ILMETHOD_DECODER to decode it.
    friend class COR_ILMETHOD_DECODER;

        // compute the size of the header (best format)
    unsigned static Size(const COR_ILMETHOD_FAT* header, bool MoreSections)
    { 
        return IlmethodSize((COR_ILMETHOD_FAT*)header,MoreSections); 
    };
        // emit the header (bestFormat) return amount emitted
    unsigned static Emit(unsigned size, const COR_ILMETHOD_FAT* header,
                  bool moreSections, BYTE* outBuff)
    { 
        return IlmethodEmit(size, (COR_ILMETHOD_FAT*)header, moreSections, outBuff); 
    };

//private:
    union
    {
        COR_ILMETHOD_TINY       Tiny;
        COR_ILMETHOD_FAT        Fat;
    };
        // Code follows the Header, then immedately after the code comes
        // any sections (COR_ILMETHOD_SECT).
};

extern "C" {
/***************************************************************************/
/* COR_ILMETHOD_DECODER is the only way functions internal to the EE should
   fetch data from a COR_ILMETHOD.  This way any dependancy on the file format
   (and the multiple ways of encoding the header) is centralized to the
   COR_ILMETHOD_DECODER constructor) */
    void __stdcall DecoderInit(void * pThis, COR_ILMETHOD* header);
    int  __stdcall DecoderGetOnDiskSize(void * pThis, COR_ILMETHOD* header);
} // extern "C"

class COR_ILMETHOD_DECODER : public COR_ILMETHOD_FAT
{
public:
    // Typically the ONLY way you should access COR_ILMETHOD is through
    // this constructor so format changes are easier.
    COR_ILMETHOD_DECODER(const COR_ILMETHOD* header) 
    { 
        DecoderInit(this,(COR_ILMETHOD*)header); 
    };

    // The above variant of the constructor can not do a 'complete' job, because
    // it can not look up the local variable signature meta-data token.
    // This method should be used when you have access to the Meta data API
    // If the construction fails, the 'Code' field is set to 0

    enum DecoderStatus {SUCCESS, FORMAT_ERROR, VERIFICATION_ERROR};

    // If we want the decoder to verify the that local signature is OK we
    // will pass a non-NULL value for wbStatus
    //
    // When using LazyInit we want ask that the local signature be verified
    // But if we fail verification we still need access to the 'Code' field
    // Because we may be able to demand SkipVerification and thus it was OK
    // to have had a verification error.

    COR_ILMETHOD_DECODER(COR_ILMETHOD* header, 
                         void *pInternalImport,
                         DecoderStatus* wbStatus);

    unsigned EHCount() const 
    {
        return (EH != 0) ? EH->EHCount() : 0;
    }

    unsigned GetHeaderSize() const
    {
        return GetCodeSize() + ((EH != 0) ? EH->DataSize() : 0);
    }

    // returns total size of method for use in copying
    int GetOnDiskSize(const COR_ILMETHOD* header) 
    { 
        return DecoderGetOnDiskSize(this,(COR_ILMETHOD*)header); 
    }

    // Flags        these are available because we inherit COR_ILMETHOD_FAT
    // MaxStack
    // CodeSize
    const BYTE* Code;
    PCCOR_SIGNATURE LocalVarSig;        // pointer to signature blob, or 0 if none
    const COR_ILMETHOD_SECT_EH* EH;     // eh table if any  0 if none
    const COR_ILMETHOD_SECT* Sect;      // additional sections  0 if none
};

#endif // __CORHLPR_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\dfshim.h ===
/*++ 

Copyright (c) Microsoft Corporation. All rights reserved.

Module Name:

    dfshim.h

Abstract:

    Include file for ClickOnce unmanaged public APIs.

--*/

//
// Clean (or uninstalls) all online applications from ClickOnce store.
//
HRESULT CleanOnlineAppCache();
//
// Parameters
//              None.
// 
// Return Values
//              If successful returns S_OK, otherwise failure HRESULT. 
//              If a managed exception happens during this operation it returns 0x80020009 (DISP_E_EXCEPTION). 
//
//  Remarks 
//              This will start ClickOnce service if not already running.
//






//
// Retrieves Deployment information from manifest and activation url.
//
HRESULT GetDeploymentDataFromManifest(
                LPCWSTR pcwzActivationUrl, 
                LPCWSTR pcwzPathToDeploymentManifest,
                __out_ecount(*pdwIdentityBufferLength) LPWSTR pwzApplicationIdentity, 
                LPDWORD pdwIdentityBufferLength,
                __out_ecount(*pdwArchitectureBufferLength) LPWSTR pwzProcessorArchitecture, 
                LPDWORD pdwArchitectureBufferLength,
                __out_ecount(*pdwCodebaseBufferLength) LPWSTR pwzApplicationManifestCodebase, 
                LPDWORD pdwCodebaseBufferLength,
                __out_ecount(*pdwProviderBufferLength) LPWSTR pwzDeploymentProvider, 
                LPDWORD pdwProviderBufferLength);

// Parameters   
//             pwzApplicationIdentity           - pointer to a buffer to receive a NULL-terminated 
//                                                string that specifies the full application identity returned.
//             pdwIdentityBufferLength          - pointer to a DWORD that is the length of the pwzApplicationIdentity buffer, in
//                                                WCHARs. This includes the space for the NULL termination character.
//             pwzProcessorArchitecture         - pointer to a buffer to receive a NULL-terminated string that specifies the
//                                                processor architecture of the application deployment, from the manifest.
//             pdwArchitectureBufferLength      - pointer to a DWORD that is the length of the pwzProcessorArchitecture
//                                                buffer, in WCHARs.
//             pwzApplicationManifestCodebase   - pointer to a buffer to receive a NULL-terminated string that specifies
//                                                codebase of the application manifest, from the manifest.
//             pdwCodebaseBufferLength          - pointer to a DWORD that is the length of the pwzApplicationManifestCodebase
//                                                buffer, in WCHARs.
//             pwzDeploymentProvider            - pointer to a buffer to receive a NULL-terminated string that specifies the
//                                                deployment provider from the manifest, if present. Otherwise, an empty string is
//                                                returned.
//             pdwProviderBufferLength          - pointer to a DWORD that is the length of the pwzProviderBufferLength
//
//             Pointers must not be NULL. pcwzActivationUrl and pcwzPathToDeploymentManifest must not be empty.
//
// Return Values
//              S_OK if function succeeds.
//              HRESULTFROMWIN32(ERROR_INSUFFICIENT_BUFFER) if a buffer is too small. *pdwIdentityBufferLength,
//              *pdwArchitectureBufferLength, *pdwCodebaseBufferLength, *pdwProviderBufferLength have the length needed.
//              other failure HRESULTs.
//
// Remarks
//              Caller's responsibility to clean up the activation URL. E.g. escaping, removing query string.
//              Caller's responsibility to limit input length. E.g. max url length to 2k.
//
//
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\fusion.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for fusion.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __fusion_h__
#define __fusion_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IAssemblyCache_FWD_DEFINED__
#define __IAssemblyCache_FWD_DEFINED__
typedef interface IAssemblyCache IAssemblyCache;
#endif 	/* __IAssemblyCache_FWD_DEFINED__ */


#ifndef __IAssemblyCacheItem_FWD_DEFINED__
#define __IAssemblyCacheItem_FWD_DEFINED__
typedef interface IAssemblyCacheItem IAssemblyCacheItem;
#endif 	/* __IAssemblyCacheItem_FWD_DEFINED__ */


#ifndef __IAssemblyName_FWD_DEFINED__
#define __IAssemblyName_FWD_DEFINED__
typedef interface IAssemblyName IAssemblyName;
#endif 	/* __IAssemblyName_FWD_DEFINED__ */


#ifndef __IAssemblyEnum_FWD_DEFINED__
#define __IAssemblyEnum_FWD_DEFINED__
typedef interface IAssemblyEnum IAssemblyEnum;
#endif 	/* __IAssemblyEnum_FWD_DEFINED__ */


#ifndef __IInstallReferenceItem_FWD_DEFINED__
#define __IInstallReferenceItem_FWD_DEFINED__
typedef interface IInstallReferenceItem IInstallReferenceItem;
#endif 	/* __IInstallReferenceItem_FWD_DEFINED__ */


#ifndef __IInstallReferenceEnum_FWD_DEFINED__
#define __IInstallReferenceEnum_FWD_DEFINED__
typedef interface IInstallReferenceEnum IInstallReferenceEnum;
#endif 	/* __IInstallReferenceEnum_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_fusion_0000 */
/* [local] */ 


#ifdef _MSC_VER
#pragma comment(lib,"uuid.lib")
#endif

//---------------------------------------------------------------------------=
// Fusion Interfaces.

#ifdef _MSC_VER
#pragma once
#endif




typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0000_0001
    {	ASM_CACHE_ZAP	= 0x1,
	ASM_CACHE_GAC	= 0x2,
	ASM_CACHE_DOWNLOAD	= 0x4,
	ASM_CACHE_ROOT	= 0x8
    } 	ASM_CACHE_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_fusion_0000_0002
    {	peNone	= 0,
	peMSIL	= 0x1,
	peI386	= 0x2,
	peIA64	= 0x3,
	peAMD64	= 0x4,
	peInvalid	= 0xffffffff
    } 	PEKIND;



extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0000_v0_0_s_ifspec;

#ifndef __IAssemblyCache_INTERFACE_DEFINED__
#define __IAssemblyCache_INTERFACE_DEFINED__

/* interface IAssemblyCache */
/* [unique][uuid][object][local] */ 

// {8cedc215-ac4b-488b-93c0-a50a49cb2fb8}
EXTERN_GUID(FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID, 0x8cedc215, 0xac4b, 0x488b, 0x93, 0xc0, 0xa5, 0x0a, 0x49, 0xcb, 0x2f, 0xb8);

// {b02f9d65-fb77-4f7a-afa5-b391309f11c9}
EXTERN_GUID(FUSION_REFCOUNT_FILEPATH_GUID, 0xb02f9d65, 0xfb77, 0x4f7a, 0xaf, 0xa5, 0xb3, 0x91, 0x30, 0x9f, 0x11, 0xc9);

// {2ec93463-b0c3-45e1-8364-327e96aea856}
EXTERN_GUID(FUSION_REFCOUNT_OPAQUE_STRING_GUID, 0x2ec93463, 0xb0c3, 0x45e1, 0x83, 0x64, 0x32, 0x7e, 0x96, 0xae, 0xa8, 0x56);
 // {25df0fc1-7f97-4070-add7-4b13bbfd7cb8} // this GUID cannot be used for installing into GAC.
EXTERN_GUID(FUSION_REFCOUNT_MSI_GUID,  0x25df0fc1, 0x7f97, 0x4070, 0xad, 0xd7, 0x4b, 0x13, 0xbb, 0xfd, 0x7c, 0xb8); 
 // {d16d444c-56d8-11d5-882d-0080c847b195}
EXTERN_GUID(FUSION_REFCOUNT_OSINSTALL_GUID, 0xd16d444c, 0x56d8, 0x11d5, 0x88, 0x2d, 0x00, 0x80, 0xc8, 0x47, 0xb1, 0x95); 
typedef struct _FUSION_INSTALL_REFERENCE_
    {
    DWORD cbSize;
    DWORD dwFlags;
    GUID guidScheme;
    LPCWSTR szIdentifier;
    LPCWSTR szNonCannonicalData;
    } 	FUSION_INSTALL_REFERENCE;

typedef struct _FUSION_INSTALL_REFERENCE_ *LPFUSION_INSTALL_REFERENCE;

typedef const FUSION_INSTALL_REFERENCE *LPCFUSION_INSTALL_REFERENCE;

typedef struct _ASSEMBLY_INFO
    {
    ULONG cbAssemblyInfo;
    DWORD dwAssemblyFlags;
    ULARGE_INTEGER uliAssemblySizeInKB;
    LPWSTR pszCurrentAssemblyPathBuf;
    ULONG cchBuf;
    } 	ASSEMBLY_INFO;

#define IASSEMBLYCACHE_INSTALL_FLAG_REFRESH       (0x00000001)
#define IASSEMBLYCACHE_INSTALL_FLAG_FORCE_REFRESH (0x00000002)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED (1)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE (2)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED (3)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING (4)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_HAS_INSTALL_REFERENCES (5)
#define IASSEMBLYCACHE_UNINSTALL_DISPOSITION_REFERENCE_NOT_FOUND (6)
#define QUERYASMINFO_FLAG_VALIDATE        (0x00000001)
#define QUERYASMINFO_FLAG_GETSIZE         (0x00000002)
#define ASSEMBLYINFO_FLAG_INSTALLED       (0x00000001)
#define ASSEMBLYINFO_FLAG_PAYLOADRESIDENT (0x00000002)

EXTERN_C const IID IID_IAssemblyCache;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("e707dcde-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCache : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE UninstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QueryAssemblyInfo( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyCacheItem( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAssemblyScavenger( 
            /* [out] */ IUnknown **ppUnkReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallAssembly( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCache * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCache * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCache * This);
        
        HRESULT ( STDMETHODCALLTYPE *UninstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *QueryAssemblyInfo )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAssemblyName,
            /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyCacheItem )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ PVOID pvReserved,
            /* [out] */ IAssemblyCacheItem **ppAsmItem,
            /* [optional][in] */ LPCWSTR pszAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAssemblyScavenger )( 
            IAssemblyCache * This,
            /* [out] */ IUnknown **ppUnkReserved);
        
        HRESULT ( STDMETHODCALLTYPE *InstallAssembly )( 
            IAssemblyCache * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszManifestFilePath,
            /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData);
        
        END_INTERFACE
    } IAssemblyCacheVtbl;

    interface IAssemblyCache
    {
        CONST_VTBL struct IAssemblyCacheVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCache_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCache_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCache_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCache_UninstallAssembly(This,dwFlags,pszAssemblyName,pRefData,pulDisposition)	\
    (This)->lpVtbl -> UninstallAssembly(This,dwFlags,pszAssemblyName,pRefData,pulDisposition)

#define IAssemblyCache_QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)	\
    (This)->lpVtbl -> QueryAssemblyInfo(This,dwFlags,pszAssemblyName,pAsmInfo)

#define IAssemblyCache_CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)	\
    (This)->lpVtbl -> CreateAssemblyCacheItem(This,dwFlags,pvReserved,ppAsmItem,pszAssemblyName)

#define IAssemblyCache_CreateAssemblyScavenger(This,ppUnkReserved)	\
    (This)->lpVtbl -> CreateAssemblyScavenger(This,ppUnkReserved)

#define IAssemblyCache_InstallAssembly(This,dwFlags,pszManifestFilePath,pRefData)	\
    (This)->lpVtbl -> InstallAssembly(This,dwFlags,pszManifestFilePath,pRefData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCache_UninstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCache_UninstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_QueryAssemblyInfo_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAssemblyName,
    /* [out][in] */ ASSEMBLY_INFO *pAsmInfo);


void __RPC_STUB IAssemblyCache_QueryAssemblyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyCacheItem_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ PVOID pvReserved,
    /* [out] */ IAssemblyCacheItem **ppAsmItem,
    /* [optional][in] */ LPCWSTR pszAssemblyName);


void __RPC_STUB IAssemblyCache_CreateAssemblyCacheItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_CreateAssemblyScavenger_Proxy( 
    IAssemblyCache * This,
    /* [out] */ IUnknown **ppUnkReserved);


void __RPC_STUB IAssemblyCache_CreateAssemblyScavenger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCache_InstallAssembly_Proxy( 
    IAssemblyCache * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszManifestFilePath,
    /* [in] */ LPCFUSION_INSTALL_REFERENCE pRefData);


void __RPC_STUB IAssemblyCache_InstallAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCache_INTERFACE_DEFINED__ */


#ifndef __IAssemblyCacheItem_INTERFACE_DEFINED__
#define __IAssemblyCacheItem_INTERFACE_DEFINED__

/* interface IAssemblyCacheItem */
/* [unique][uuid][object][local] */ 

#define STREAM_FORMAT_COMPLIB_MODULE    0
#define STREAM_FORMAT_COMPLIB_MANIFEST  1
#define STREAM_FORMAT_WIN32_MODULE      2
#define STREAM_FORMAT_WIN32_MANIFEST    4
#define IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH       (0x00000001)
#define IASSEMBLYCACHEITEM_COMMIT_FLAG_FORCE_REFRESH (0x00000002)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED (1)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED (2)
#define IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED (3)

EXTERN_C const IID IID_IAssemblyCacheItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae")
    IAssemblyCacheItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateStream( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AbortItem( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyCacheItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyCacheItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyCacheItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyCacheItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateStream )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszStreamName,
            /* [in] */ DWORD dwFormat,
            /* [in] */ DWORD dwFormatFlags,
            /* [out] */ IStream **ppIStream,
            /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);
        
        HRESULT ( STDMETHODCALLTYPE *Commit )( 
            IAssemblyCacheItem * This,
            /* [in] */ DWORD dwFlags,
            /* [optional][out] */ ULONG *pulDisposition);
        
        HRESULT ( STDMETHODCALLTYPE *AbortItem )( 
            IAssemblyCacheItem * This);
        
        END_INTERFACE
    } IAssemblyCacheItemVtbl;

    interface IAssemblyCacheItem
    {
        CONST_VTBL struct IAssemblyCacheItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyCacheItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyCacheItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyCacheItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyCacheItem_CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)	\
    (This)->lpVtbl -> CreateStream(This,dwFlags,pszStreamName,dwFormat,dwFormatFlags,ppIStream,puliMaxSize)

#define IAssemblyCacheItem_Commit(This,dwFlags,pulDisposition)	\
    (This)->lpVtbl -> Commit(This,dwFlags,pulDisposition)

#define IAssemblyCacheItem_AbortItem(This)	\
    (This)->lpVtbl -> AbortItem(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_CreateStream_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszStreamName,
    /* [in] */ DWORD dwFormat,
    /* [in] */ DWORD dwFormatFlags,
    /* [out] */ IStream **ppIStream,
    /* [optional][in] */ ULARGE_INTEGER *puliMaxSize);


void __RPC_STUB IAssemblyCacheItem_CreateStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_Commit_Proxy( 
    IAssemblyCacheItem * This,
    /* [in] */ DWORD dwFlags,
    /* [optional][out] */ ULONG *pulDisposition);


void __RPC_STUB IAssemblyCacheItem_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyCacheItem_AbortItem_Proxy( 
    IAssemblyCacheItem * This);


void __RPC_STUB IAssemblyCacheItem_AbortItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyCacheItem_INTERFACE_DEFINED__ */


#ifndef __IAssemblyName_INTERFACE_DEFINED__
#define __IAssemblyName_INTERFACE_DEFINED__

/* interface IAssemblyName */
/* [unique][uuid][object][local] */ 

typedef /* [unique] */ IAssemblyName *LPASSEMBLYNAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0001
    {	CANOF_PARSE_DISPLAY_NAME	= 0x1,
	CANOF_SET_DEFAULT_VALUES	= 0x2,
	CANOF_VERIFY_FRIEND_ASSEMBLYNAME	= 0x4,
	CANOF_PARSE_FRIEND_DISPLAY_NAME	= CANOF_PARSE_DISPLAY_NAME | CANOF_VERIFY_FRIEND_ASSEMBLYNAME
    } 	CREATE_ASM_NAME_OBJ_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0002
    {	ASM_NAME_PUBLIC_KEY	= 0,
	ASM_NAME_PUBLIC_KEY_TOKEN	= ASM_NAME_PUBLIC_KEY + 1,
	ASM_NAME_HASH_VALUE	= ASM_NAME_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NAME	= ASM_NAME_HASH_VALUE + 1,
	ASM_NAME_MAJOR_VERSION	= ASM_NAME_NAME + 1,
	ASM_NAME_MINOR_VERSION	= ASM_NAME_MAJOR_VERSION + 1,
	ASM_NAME_BUILD_NUMBER	= ASM_NAME_MINOR_VERSION + 1,
	ASM_NAME_REVISION_NUMBER	= ASM_NAME_BUILD_NUMBER + 1,
	ASM_NAME_CULTURE	= ASM_NAME_REVISION_NUMBER + 1,
	ASM_NAME_PROCESSOR_ID_ARRAY	= ASM_NAME_CULTURE + 1,
	ASM_NAME_OSINFO_ARRAY	= ASM_NAME_PROCESSOR_ID_ARRAY + 1,
	ASM_NAME_HASH_ALGID	= ASM_NAME_OSINFO_ARRAY + 1,
	ASM_NAME_ALIAS	= ASM_NAME_HASH_ALGID + 1,
	ASM_NAME_CODEBASE_URL	= ASM_NAME_ALIAS + 1,
	ASM_NAME_CODEBASE_LASTMOD	= ASM_NAME_CODEBASE_URL + 1,
	ASM_NAME_NULL_PUBLIC_KEY	= ASM_NAME_CODEBASE_LASTMOD + 1,
	ASM_NAME_NULL_PUBLIC_KEY_TOKEN	= ASM_NAME_NULL_PUBLIC_KEY + 1,
	ASM_NAME_CUSTOM	= ASM_NAME_NULL_PUBLIC_KEY_TOKEN + 1,
	ASM_NAME_NULL_CUSTOM	= ASM_NAME_CUSTOM + 1,
	ASM_NAME_MVID	= ASM_NAME_NULL_CUSTOM + 1,
	ASM_NAME_FILE_MAJOR_VERSION	= ASM_NAME_MVID + 1,
	ASM_NAME_FILE_MINOR_VERSION	= ASM_NAME_FILE_MAJOR_VERSION + 1,
	ASM_NAME_FILE_BUILD_NUMBER	= ASM_NAME_FILE_MINOR_VERSION + 1,
	ASM_NAME_FILE_REVISION_NUMBER	= ASM_NAME_FILE_BUILD_NUMBER + 1,
	ASM_NAME_RETARGET	= ASM_NAME_FILE_REVISION_NUMBER + 1,
	ASM_NAME_SIGNATURE_BLOB	= ASM_NAME_RETARGET + 1,
	ASM_NAME_CONFIG_MASK	= ASM_NAME_SIGNATURE_BLOB + 1,
	ASM_NAME_ARCHITECTURE	= ASM_NAME_CONFIG_MASK + 1,
	ASM_NAME_MAX_PARAMS	= ASM_NAME_ARCHITECTURE + 1
    } 	ASM_NAME;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0003
    {	ASM_DISPLAYF_VERSION	= 0x1,
	ASM_DISPLAYF_CULTURE	= 0x2,
	ASM_DISPLAYF_PUBLIC_KEY_TOKEN	= 0x4,
	ASM_DISPLAYF_PUBLIC_KEY	= 0x8,
	ASM_DISPLAYF_CUSTOM	= 0x10,
	ASM_DISPLAYF_PROCESSORARCHITECTURE	= 0x20,
	ASM_DISPLAYF_LANGUAGEID	= 0x40,
	ASM_DISPLAYF_RETARGET	= 0x80,
	ASM_DISPLAYF_CONFIG_MASK	= 0x100,
	ASM_DISPLAYF_MVID	= 0x200,
	ASM_DISPLAYF_FULL	= ASM_DISPLAYF_VERSION | ASM_DISPLAYF_CULTURE | ASM_DISPLAYF_PUBLIC_KEY_TOKEN | ASM_DISPLAYF_RETARGET | ASM_DISPLAYF_PROCESSORARCHITECTURE
    } 	ASM_DISPLAY_FLAGS;

typedef /* [public] */ 
enum __MIDL_IAssemblyName_0004
    {	ASM_CMPF_NAME	= 0x1,
	ASM_CMPF_MAJOR_VERSION	= 0x2,
	ASM_CMPF_MINOR_VERSION	= 0x4,
	ASM_CMPF_BUILD_NUMBER	= 0x8,
	ASM_CMPF_REVISION_NUMBER	= 0x10,
	ASM_CMPF_VERSION	= ASM_CMPF_MAJOR_VERSION | ASM_CMPF_MINOR_VERSION | ASM_CMPF_BUILD_NUMBER | ASM_CMPF_REVISION_NUMBER,
	ASM_CMPF_PUBLIC_KEY_TOKEN	= 0x20,
	ASM_CMPF_CULTURE	= 0x40,
	ASM_CMPF_CUSTOM	= 0x80,
	ASM_CMPF_DEFAULT	= 0x100,
	ASM_CMPF_RETARGET	= 0x200,
	ASM_CMPF_ARCHITECTURE	= 0x400,
	ASM_CMPF_CONFIG_MASK	= 0x800,
	ASM_CMPF_MVID	= 0x1000,
	ASM_CMPF_SIGNATURE	= 0x2000,
	ASM_CMPF_IL_ALL	= ASM_CMPF_NAME | ASM_CMPF_VERSION | ASM_CMPF_PUBLIC_KEY_TOKEN | ASM_CMPF_CULTURE,
	ASM_CMPF_IL_NO_VERSION	= ASM_CMPF_NAME | ASM_CMPF_PUBLIC_KEY_TOKEN | ASM_CMPF_CULTURE
    } 	ASM_CMP_FLAGS;


EXTERN_C const IID IID_IAssemblyName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CD193BC0-B4BC-11d2-9833-00C04FC31D2E")
    IAssemblyName : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finalize( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDisplayName( 
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reserved( 
            /* [in] */ REFIID refIID,
            /* [in] */ IUnknown *pUnkReserved1,
            /* [in] */ IUnknown *pUnkReserved2,
            /* [in] */ LPCOLESTR szReserved,
            /* [in] */ LONGLONG llReserved,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsEqual( 
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyName **pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyName * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [in] */ LPVOID pvProperty,
            /* [in] */ DWORD cbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IAssemblyName * This,
            /* [in] */ DWORD PropertyId,
            /* [out] */ LPVOID pvProperty,
            /* [out][in] */ LPDWORD pcbProperty);
        
        HRESULT ( STDMETHODCALLTYPE *Finalize )( 
            IAssemblyName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetDisplayName )( 
            IAssemblyName * This,
            /* [out] */ LPOLESTR szDisplayName,
            /* [out][in] */ LPDWORD pccDisplayName,
            /* [in] */ DWORD dwDisplayFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Reserved )( 
            IAssemblyName * This,
            /* [in] */ REFIID refIID,
            /* [in] */ IUnknown *pUnkReserved1,
            /* [in] */ IUnknown *pUnkReserved2,
            /* [in] */ LPCOLESTR szReserved,
            /* [in] */ LONGLONG llReserved,
            /* [in] */ LPVOID pvReserved,
            /* [in] */ DWORD cbReserved,
            /* [out] */ LPVOID *ppReserved);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            IAssemblyName * This,
            /* [out][in] */ LPDWORD lpcwBuffer,
            /* [out] */ WCHAR *pwzName);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            IAssemblyName * This,
            /* [out] */ LPDWORD pdwVersionHi,
            /* [out] */ LPDWORD pdwVersionLow);
        
        HRESULT ( STDMETHODCALLTYPE *IsEqual )( 
            IAssemblyName * This,
            /* [in] */ IAssemblyName *pName,
            /* [in] */ DWORD dwCmpFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyName * This,
            /* [out] */ IAssemblyName **pName);
        
        END_INTERFACE
    } IAssemblyNameVtbl;

    interface IAssemblyName
    {
        CONST_VTBL struct IAssemblyNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyName_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyName_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyName_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyName_SetProperty(This,PropertyId,pvProperty,cbProperty)	\
    (This)->lpVtbl -> SetProperty(This,PropertyId,pvProperty,cbProperty)

#define IAssemblyName_GetProperty(This,PropertyId,pvProperty,pcbProperty)	\
    (This)->lpVtbl -> GetProperty(This,PropertyId,pvProperty,pcbProperty)

#define IAssemblyName_Finalize(This)	\
    (This)->lpVtbl -> Finalize(This)

#define IAssemblyName_GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)	\
    (This)->lpVtbl -> GetDisplayName(This,szDisplayName,pccDisplayName,dwDisplayFlags)

#define IAssemblyName_Reserved(This,refIID,pUnkReserved1,pUnkReserved2,szReserved,llReserved,pvReserved,cbReserved,ppReserved)	\
    (This)->lpVtbl -> Reserved(This,refIID,pUnkReserved1,pUnkReserved2,szReserved,llReserved,pvReserved,cbReserved,ppReserved)

#define IAssemblyName_GetName(This,lpcwBuffer,pwzName)	\
    (This)->lpVtbl -> GetName(This,lpcwBuffer,pwzName)

#define IAssemblyName_GetVersion(This,pdwVersionHi,pdwVersionLow)	\
    (This)->lpVtbl -> GetVersion(This,pdwVersionHi,pdwVersionLow)

#define IAssemblyName_IsEqual(This,pName,dwCmpFlags)	\
    (This)->lpVtbl -> IsEqual(This,pName,dwCmpFlags)

#define IAssemblyName_Clone(This,pName)	\
    (This)->lpVtbl -> Clone(This,pName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyName_SetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [in] */ LPVOID pvProperty,
    /* [in] */ DWORD cbProperty);


void __RPC_STUB IAssemblyName_SetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetProperty_Proxy( 
    IAssemblyName * This,
    /* [in] */ DWORD PropertyId,
    /* [out] */ LPVOID pvProperty,
    /* [out][in] */ LPDWORD pcbProperty);


void __RPC_STUB IAssemblyName_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Finalize_Proxy( 
    IAssemblyName * This);


void __RPC_STUB IAssemblyName_Finalize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetDisplayName_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPOLESTR szDisplayName,
    /* [out][in] */ LPDWORD pccDisplayName,
    /* [in] */ DWORD dwDisplayFlags);


void __RPC_STUB IAssemblyName_GetDisplayName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Reserved_Proxy( 
    IAssemblyName * This,
    /* [in] */ REFIID refIID,
    /* [in] */ IUnknown *pUnkReserved1,
    /* [in] */ IUnknown *pUnkReserved2,
    /* [in] */ LPCOLESTR szReserved,
    /* [in] */ LONGLONG llReserved,
    /* [in] */ LPVOID pvReserved,
    /* [in] */ DWORD cbReserved,
    /* [out] */ LPVOID *ppReserved);


void __RPC_STUB IAssemblyName_Reserved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetName_Proxy( 
    IAssemblyName * This,
    /* [out][in] */ LPDWORD lpcwBuffer,
    /* [out] */ WCHAR *pwzName);


void __RPC_STUB IAssemblyName_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_GetVersion_Proxy( 
    IAssemblyName * This,
    /* [out] */ LPDWORD pdwVersionHi,
    /* [out] */ LPDWORD pdwVersionLow);


void __RPC_STUB IAssemblyName_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_IsEqual_Proxy( 
    IAssemblyName * This,
    /* [in] */ IAssemblyName *pName,
    /* [in] */ DWORD dwCmpFlags);


void __RPC_STUB IAssemblyName_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyName_Clone_Proxy( 
    IAssemblyName * This,
    /* [out] */ IAssemblyName **pName);


void __RPC_STUB IAssemblyName_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyName_INTERFACE_DEFINED__ */


#ifndef __IAssemblyEnum_INTERFACE_DEFINED__
#define __IAssemblyEnum_INTERFACE_DEFINED__

/* interface IAssemblyEnum */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAssemblyEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21b8916c-f28e-11d2-a473-00c04f8ef448")
    IAssemblyEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextAssembly( 
            /* [in] */ LPVOID pvReserved,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IAssemblyEnum **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAssemblyEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAssemblyEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAssemblyEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextAssembly )( 
            IAssemblyEnum * This,
            /* [in] */ LPVOID pvReserved,
            /* [out] */ IAssemblyName **ppName,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IAssemblyEnum * This,
            /* [out] */ IAssemblyEnum **ppEnum);
        
        END_INTERFACE
    } IAssemblyEnumVtbl;

    interface IAssemblyEnum
    {
        CONST_VTBL struct IAssemblyEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAssemblyEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAssemblyEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAssemblyEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAssemblyEnum_GetNextAssembly(This,pvReserved,ppName,dwFlags)	\
    (This)->lpVtbl -> GetNextAssembly(This,pvReserved,ppName,dwFlags)

#define IAssemblyEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IAssemblyEnum_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAssemblyEnum_GetNextAssembly_Proxy( 
    IAssemblyEnum * This,
    /* [in] */ LPVOID pvReserved,
    /* [out] */ IAssemblyName **ppName,
    /* [in] */ DWORD dwFlags);


void __RPC_STUB IAssemblyEnum_GetNextAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Reset_Proxy( 
    IAssemblyEnum * This);


void __RPC_STUB IAssemblyEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAssemblyEnum_Clone_Proxy( 
    IAssemblyEnum * This,
    /* [out] */ IAssemblyEnum **ppEnum);


void __RPC_STUB IAssemblyEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAssemblyEnum_INTERFACE_DEFINED__ */


#ifndef __IInstallReferenceItem_INTERFACE_DEFINED__
#define __IInstallReferenceItem_INTERFACE_DEFINED__

/* interface IInstallReferenceItem */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInstallReferenceItem;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("582dac66-e678-449f-aba6-6faaec8a9394")
    IInstallReferenceItem : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetReference( 
            /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallReferenceItemVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallReferenceItem * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallReferenceItem * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallReferenceItem * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetReference )( 
            IInstallReferenceItem * This,
            /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved);
        
        END_INTERFACE
    } IInstallReferenceItemVtbl;

    interface IInstallReferenceItem
    {
        CONST_VTBL struct IInstallReferenceItemVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallReferenceItem_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstallReferenceItem_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstallReferenceItem_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstallReferenceItem_GetReference(This,ppRefData,dwFlags,pvReserved)	\
    (This)->lpVtbl -> GetReference(This,ppRefData,dwFlags,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstallReferenceItem_GetReference_Proxy( 
    IInstallReferenceItem * This,
    /* [out] */ LPFUSION_INSTALL_REFERENCE *ppRefData,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPVOID pvReserved);


void __RPC_STUB IInstallReferenceItem_GetReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstallReferenceItem_INTERFACE_DEFINED__ */


#ifndef __IInstallReferenceEnum_INTERFACE_DEFINED__
#define __IInstallReferenceEnum_INTERFACE_DEFINED__

/* interface IInstallReferenceEnum */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IInstallReferenceEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("56b1a988-7c0c-4aa2-8639-c3eb5a90226f")
    IInstallReferenceEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNextInstallReferenceItem( 
            /* [out] */ IInstallReferenceItem **ppRefItem,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInstallReferenceEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInstallReferenceEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInstallReferenceEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInstallReferenceEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNextInstallReferenceItem )( 
            IInstallReferenceEnum * This,
            /* [out] */ IInstallReferenceItem **ppRefItem,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPVOID pvReserved);
        
        END_INTERFACE
    } IInstallReferenceEnumVtbl;

    interface IInstallReferenceEnum
    {
        CONST_VTBL struct IInstallReferenceEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInstallReferenceEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInstallReferenceEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInstallReferenceEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInstallReferenceEnum_GetNextInstallReferenceItem(This,ppRefItem,dwFlags,pvReserved)	\
    (This)->lpVtbl -> GetNextInstallReferenceItem(This,ppRefItem,dwFlags,pvReserved)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IInstallReferenceEnum_GetNextInstallReferenceItem_Proxy( 
    IInstallReferenceEnum * This,
    /* [out] */ IInstallReferenceItem **ppRefItem,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPVOID pvReserved);


void __RPC_STUB IInstallReferenceEnum_GetNextInstallReferenceItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInstallReferenceEnum_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_fusion_0098 */
/* [local] */ 

typedef 
enum _tagAssemblyComparisonResult
    {	ACR_Unknown	= 0,
	ACR_EquivalentFullMatch	= ACR_Unknown + 1,
	ACR_EquivalentWeakNamed	= ACR_EquivalentFullMatch + 1,
	ACR_EquivalentFXUnified	= ACR_EquivalentWeakNamed + 1,
	ACR_EquivalentUnified	= ACR_EquivalentFXUnified + 1,
	ACR_NonEquivalentVersion	= ACR_EquivalentUnified + 1,
	ACR_NonEquivalent	= ACR_NonEquivalentVersion + 1,
	ACR_EquivalentPartialMatch	= ACR_NonEquivalent + 1,
	ACR_EquivalentPartialWeakNamed	= ACR_EquivalentPartialMatch + 1,
	ACR_EquivalentPartialUnified	= ACR_EquivalentPartialWeakNamed + 1,
	ACR_EquivalentPartialFXUnified	= ACR_EquivalentPartialUnified + 1,
	ACR_NonEquivalentPartialVersion	= ACR_EquivalentPartialFXUnified + 1
    } 	AssemblyComparisonResult;

STDAPI CompareAssemblyIdentity(LPCWSTR pwzAssemblyIdentity1, BOOL fUnified1, LPCWSTR pwzAssemblyIdentity2, BOOL fUnified2, BOOL *pfEquivalent, AssemblyComparisonResult *pResult); 
STDAPI CreateInstallReferenceEnum(IInstallReferenceEnum **ppRefEnum, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      
STDAPI CreateAssemblyEnum(IAssemblyEnum **pEnum, IUnknown *pUnkReserved, IAssemblyName *pName, DWORD dwFlags, LPVOID pvReserved);      
STDAPI CreateAssemblyNameObject(LPASSEMBLYNAME *ppAssemblyNameObj, LPCWSTR szAssemblyName, DWORD dwFlags, LPVOID pvReserved);             
STDAPI CreateAssemblyCache(IAssemblyCache **ppAsmCache, DWORD dwReserved); 
STDAPI GetCachePath(ASM_CACHE_FLAGS dwCacheFlags, LPWSTR pwzCachePath, PDWORD pcchPath); 
STDAPI GetAssemblyIdentityFromFile(LPCWSTR pwzFilePAth, REFIID riid, IUnknown **ppIdentity); 
STDAPI ClearDownloadCache();


extern RPC_IF_HANDLE __MIDL_itf_fusion_0098_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_fusion_0098_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\gchost.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for gchost.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __gchost_h__
#define __gchost_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IGCHost_FWD_DEFINED__
#define __IGCHost_FWD_DEFINED__
typedef interface IGCHost IGCHost;
#endif 	/* __IGCHost_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_gchost_0000 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_gchost_0000_0001
    {	COR_GC_COUNTS	= 0x1,
	COR_GC_MEMORYUSAGE	= 0x2
    } 	COR_GC_STAT_TYPES;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_gchost_0000_0002
    {	COR_GC_THREAD_HAS_PROMOTED_BYTES	= 0x1
    } 	COR_GC_THREAD_STATS_TYPES;

typedef struct _COR_GC_STATS
    {
    ULONG Flags;
    SIZE_T ExplicitGCCount;
    SIZE_T GenCollectionsTaken[ 3 ];
    SIZE_T CommittedKBytes;
    SIZE_T ReservedKBytes;
    SIZE_T Gen0HeapSizeKBytes;
    SIZE_T Gen1HeapSizeKBytes;
    SIZE_T Gen2HeapSizeKBytes;
    SIZE_T LargeObjectHeapSizeKBytes;
    SIZE_T KBytesPromotedFromGen0;
    SIZE_T KBytesPromotedFromGen1;
    } 	COR_GC_STATS;

typedef struct _COR_GC_THREAD_STATS
    {
    ULONGLONG PerThreadAllocation;
    ULONG Flags;
    } 	COR_GC_THREAD_STATS;



extern RPC_IF_HANDLE __MIDL_itf_gchost_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_gchost_0000_v0_0_s_ifspec;

#ifndef __IGCHost_INTERFACE_DEFINED__
#define __IGCHost_INTERFACE_DEFINED__

/* interface IGCHost */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IGCHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FAC34F6E-0DCD-47b5-8021-531BC5ECCA63")
    IGCHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGCStartupLimits( 
            /* [in] */ DWORD SegmentSize,
            /* [in] */ DWORD MaxGen0Size) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Collect( 
            /* [in] */ LONG Generation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStats( 
            /* [out][in] */ COR_GC_STATS *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadStats( 
            /* [in] */ DWORD *pFiberCookie,
            /* [out][in] */ COR_GC_THREAD_STATS *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetVirtualMemLimit( 
            /* [in] */ SIZE_T sztMaxVirtualMemMB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGCHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGCHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGCHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGCHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetGCStartupLimits )( 
            IGCHost * This,
            /* [in] */ DWORD SegmentSize,
            /* [in] */ DWORD MaxGen0Size);
        
        HRESULT ( STDMETHODCALLTYPE *Collect )( 
            IGCHost * This,
            /* [in] */ LONG Generation);
        
        HRESULT ( STDMETHODCALLTYPE *GetStats )( 
            IGCHost * This,
            /* [out][in] */ COR_GC_STATS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadStats )( 
            IGCHost * This,
            /* [in] */ DWORD *pFiberCookie,
            /* [out][in] */ COR_GC_THREAD_STATS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *SetVirtualMemLimit )( 
            IGCHost * This,
            /* [in] */ SIZE_T sztMaxVirtualMemMB);
        
        END_INTERFACE
    } IGCHostVtbl;

    interface IGCHost
    {
        CONST_VTBL struct IGCHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGCHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGCHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGCHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGCHost_SetGCStartupLimits(This,SegmentSize,MaxGen0Size)	\
    (This)->lpVtbl -> SetGCStartupLimits(This,SegmentSize,MaxGen0Size)

#define IGCHost_Collect(This,Generation)	\
    (This)->lpVtbl -> Collect(This,Generation)

#define IGCHost_GetStats(This,pStats)	\
    (This)->lpVtbl -> GetStats(This,pStats)

#define IGCHost_GetThreadStats(This,pFiberCookie,pStats)	\
    (This)->lpVtbl -> GetThreadStats(This,pFiberCookie,pStats)

#define IGCHost_SetVirtualMemLimit(This,sztMaxVirtualMemMB)	\
    (This)->lpVtbl -> SetVirtualMemLimit(This,sztMaxVirtualMemMB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGCHost_SetGCStartupLimits_Proxy( 
    IGCHost * This,
    /* [in] */ DWORD SegmentSize,
    /* [in] */ DWORD MaxGen0Size);


void __RPC_STUB IGCHost_SetGCStartupLimits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCHost_Collect_Proxy( 
    IGCHost * This,
    /* [in] */ LONG Generation);


void __RPC_STUB IGCHost_Collect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCHost_GetStats_Proxy( 
    IGCHost * This,
    /* [out][in] */ COR_GC_STATS *pStats);


void __RPC_STUB IGCHost_GetStats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCHost_GetThreadStats_Proxy( 
    IGCHost * This,
    /* [in] */ DWORD *pFiberCookie,
    /* [out][in] */ COR_GC_THREAD_STATS *pStats);


void __RPC_STUB IGCHost_GetThreadStats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCHost_SetVirtualMemLimit_Proxy( 
    IGCHost * This,
    /* [in] */ SIZE_T sztMaxVirtualMemMB);


void __RPC_STUB IGCHost_SetVirtualMemLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGCHost_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\ICeeFileGen.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
/*****************************************************************************
 **                                                                         **
 ** ICeeFileGen.h - code generator interface.                               **
 **                                                                         **
 ** This interface provides functionality to create a CLR PE executable.    **
 ** This will typically be used by compilers to generate their compiled     **
 ** output executable.                                                      **
 **                                                                         **
 ** The implemenation lives in mscorpe.dll                                  **
 **                                                                         **
 *****************************************************************************/

/*
  This is how this is typically used:

  CreateICeeFileGen(...);       // Get a ICeeFileGen

  CreateCeeFile(...);           // Get a HCEEFILE (called for every output file needed)
  SetOutputFileName(...);       // Set the name for the output file
  pEmit = IMetaDataEmit object; // Get a metadata emitter
  GetSectionBlock(...);, AddSectionReloc(...); ... // Get blocks, write non-metadata information, and add necessary relocation
  EmitMetaDataEx(pEmit);        // Write out the metadata
  GenerateCeeFile(...);         // Write out the file. Implicitly calls LinkCeeFile and FixupCeeFile

  DestroyICeeFileGen(...);      // Release the ICeeFileGen object
*/


#ifndef _ICEEFILEGEN_H_
#define _ICEEFILEGEN_H_

#include <ole2.h>
#include "cor.h"

class ICeeFileGen;

typedef void *HCEEFILE;

EXTERN_C HRESULT __stdcall CreateICeeFileGen(ICeeFileGen **ceeFileGen); // call this to instantiate an ICeeFileGen interface
EXTERN_C HRESULT __stdcall DestroyICeeFileGen(ICeeFileGen **ceeFileGen); // call this to delete an ICeeFileGen

#define ICEE_CREATE_FILE_PE32	       0x00000001  // Create a PE  (32-bit)
#define ICEE_CREATE_FILE_PE64	       0x00000002  // Create a PE+ (64-bit) 
#define ICEE_CREATE_FILE_CORMAIN_STUB  0x00000004  // add a mscoree!_Cor___Main call stub 
#define ICEE_CREATE_FILE_STRIP_RELOCS  0x00000008  // strip the .reloc section
#define ICEE_CREATE_FILE_EMIT_FIXUPS   0x00000010  // emit fixups for use by Vulcan

#define ICEE_CREATE_MACHINE_MASK       0x0000FF00  // space for up to 256 machine targets
#define ICEE_CREATE_MACHINE_ILLEGAL    0x00000000  // An illegal machine name
#define ICEE_CREATE_MACHINE_I386       0x00000100  // Create a IMAGE_FILE_MACHINE_I386 
#define ICEE_CREATE_MACHINE_IA64       0x00000200  // Create a IMAGE_FILE_MACHINE_IA64
#define ICEE_CREATE_MACHINE_AMD64      0x00000400  // Create a IMAGE_FILE_MACHINE_AMD64

    // Pass this to CreateCeeFileEx to create a pure IL Exe or DLL
#define ICEE_CREATE_FILE_PURE_IL  ICEE_CREATE_FILE_PE32         | \
                                  ICEE_CREATE_FILE_CORMAIN_STUB | \
                                  ICEE_CREATE_MACHINE_I386

class ICeeFileGen {
  public:
    virtual HRESULT CreateCeeFile(HCEEFILE *ceeFile); // call this to instantiate a file handle

    // <TODO>@FUTURE: remove this function. We no longer support mdScope.</TODO>
    virtual HRESULT EmitMetaData (HCEEFILE ceeFile, IMetaDataEmit *emitter, mdScope scope);
    virtual HRESULT EmitLibraryName (HCEEFILE ceeFile, IMetaDataEmit *emitter, mdScope scope);
    virtual HRESULT EmitMethod (); // <TODO>@FUTURE: remove</TODO>
    virtual HRESULT GetMethodRVA (HCEEFILE ceeFile, ULONG codeOffset, ULONG *codeRVA); 
    virtual HRESULT EmitSignature (); // <TODO>@FUTURE: remove</TODO>

    virtual HRESULT EmitString (HCEEFILE ceeFile,__in LPWSTR strValue, ULONG *strRef);
    virtual HRESULT GenerateCeeFile (HCEEFILE ceeFile);

    virtual HRESULT SetOutputFileName (HCEEFILE ceeFile, __in LPWSTR outputFileName);
    __success(return == S_OK)
    virtual HRESULT GetOutputFileName (HCEEFILE ceeFile, __out LPWSTR *outputFileName);

    virtual HRESULT SetResourceFileName (HCEEFILE ceeFile, __in LPWSTR resourceFileName);

    __success(return == S_OK)
    virtual HRESULT GetResourceFileName (HCEEFILE ceeFile, __out LPWSTR *resourceFileName);

    virtual HRESULT SetImageBase(HCEEFILE ceeFile, size_t imageBase);

    virtual HRESULT SetSubsystem(HCEEFILE ceeFile, DWORD subsystem, DWORD major, DWORD minor);

    virtual HRESULT SetEntryClassToken (); //<TODO>@FUTURE: remove</TODO>
    virtual HRESULT GetEntryClassToken (); //<TODO>@FUTURE: remove</TODO>

    virtual HRESULT SetEntryPointDescr (); //<TODO>@FUTURE: remove</TODO>
    virtual HRESULT GetEntryPointDescr (); //<TODO>@FUTURE: remove</TODO>

    virtual HRESULT SetEntryPointFlags (); //<TODO>@FUTURE: remove</TODO>
    virtual HRESULT GetEntryPointFlags (); //<TODO>@FUTURE: remove</TODO>

    virtual HRESULT SetDllSwitch (HCEEFILE ceeFile, BOOL dllSwitch);
    virtual HRESULT GetDllSwitch (HCEEFILE ceeFile, BOOL *dllSwitch);

    virtual HRESULT SetLibraryName (HCEEFILE ceeFile, __in LPWSTR LibraryName);
    __success( return == S_OK )
    virtual HRESULT GetLibraryName (HCEEFILE ceeFile, __out LPWSTR *LibraryName);

    virtual HRESULT SetLibraryGuid (HCEEFILE ceeFile, __in LPWSTR LibraryGuid);

    virtual HRESULT DestroyCeeFile(HCEEFILE *ceeFile); // call this to delete a file handle

    virtual HRESULT GetSectionCreate (HCEEFILE ceeFile, const char *name, DWORD flags, HCEESECTION *section);
    virtual HRESULT GetIlSection (HCEEFILE ceeFile, HCEESECTION *section);
    virtual HRESULT GetRdataSection (HCEEFILE ceeFile, HCEESECTION *section);

    virtual HRESULT GetSectionDataLen (HCEESECTION section, ULONG *dataLen);
    virtual HRESULT GetSectionBlock (HCEESECTION section, ULONG len, ULONG align=1, void **ppBytes=0);
    virtual HRESULT TruncateSection (HCEESECTION section, ULONG len);
    virtual HRESULT AddSectionReloc (HCEESECTION section, ULONG offset, HCEESECTION relativeTo, CeeSectionRelocType relocType);

    // deprecated: use SetDirectoryEntry instead
    virtual HRESULT SetSectionDirectoryEntry (HCEESECTION section, ULONG num);

    virtual HRESULT CreateSig (); //<TODO>@FUTURE: Remove</TODO>
    virtual HRESULT AddSigArg (); //<TODO>@FUTURE: Remove</TODO>
    virtual HRESULT SetSigReturnType (); //<TODO>@FUTURE: Remove</TODO>
    virtual HRESULT SetSigCallingConvention (); //<TODO>@FUTURE: Remove</TODO>
    virtual HRESULT DeleteSig (); //<TODO>@FUTURE: Remove</TODO>

    virtual HRESULT SetEntryPoint (HCEEFILE ceeFile, mdMethodDef method);
    virtual HRESULT GetEntryPoint (HCEEFILE ceeFile, mdMethodDef *method);

    virtual HRESULT SetComImageFlags (HCEEFILE ceeFile, DWORD mask);
    virtual HRESULT GetComImageFlags (HCEEFILE ceeFile, DWORD *mask);

    // get IMapToken interface for tracking mapped tokens
    virtual HRESULT GetIMapTokenIface(HCEEFILE ceeFile, IMetaDataEmit *emitter, IUnknown **pIMapToken);
    virtual HRESULT SetDirectoryEntry (HCEEFILE ceeFile, HCEESECTION section, ULONG num, ULONG size, ULONG offset = 0);

    // Write out the metadata in "emitter" to the metadata section in "ceeFile"
    // Use EmitMetaDataAt() for more control
    virtual HRESULT EmitMetaDataEx (HCEEFILE ceeFile, IMetaDataEmit *emitter); 

    virtual HRESULT EmitLibraryNameEx (HCEEFILE ceeFile, IMetaDataEmit *emitter);
    virtual HRESULT GetIMapTokenIfaceEx(HCEEFILE ceeFile, IMetaDataEmit *emitter, IUnknown **pIMapToken);

    virtual HRESULT EmitMacroDefinitions(HCEEFILE ceeFile, void *pData, DWORD cData);
    virtual HRESULT CreateCeeFileFromICeeGen(
        ICeeGen *pFromICeeGen, HCEEFILE *ceeFile, DWORD createFlags = ICEE_CREATE_FILE_PURE_IL); // call this to instantiate a file handle

    virtual HRESULT SetManifestEntry(HCEEFILE ceeFile, ULONG size, ULONG offset);

    virtual HRESULT SetEnCRVABase(HCEEFILE ceeFile, ULONG dataBase, ULONG rdataBase);
    virtual HRESULT GenerateCeeMemoryImage (HCEEFILE ceeFile, void **ppImage);

    virtual HRESULT ComputeSectionOffset(HCEESECTION section, __in char *ptr,
                                         unsigned *offset);
    
    virtual HRESULT ComputeOffset(HCEEFILE file, __in char *ptr,
                                  HCEESECTION *pSection, unsigned *offset);
    
    virtual HRESULT GetCorHeader(HCEEFILE ceeFile, 
                                 IMAGE_COR20_HEADER **header);
    
    // Layout the sections and assign their starting addresses
    virtual HRESULT LinkCeeFile (HCEEFILE ceeFile);     

    // Apply relocations to any pointer data. Also generate PE base relocs
    virtual HRESULT FixupCeeFile (HCEEFILE ceeFile);

    // Base RVA assinged to the section. To be called only after LinkCeeFile()
    virtual HRESULT GetSectionRVA (HCEESECTION section, ULONG *rva);
    
    __success(return == S_OK)
    virtual HRESULT ComputeSectionPointer(HCEESECTION section, ULONG offset,
                                          __out char **ptr);

    virtual HRESULT SetObjSwitch (HCEEFILE ceeFile, BOOL objSwitch);
    virtual HRESULT GetObjSwitch (HCEEFILE ceeFile, BOOL *objSwitch);
    virtual HRESULT SetVTableEntry(HCEEFILE ceeFile, ULONG size, ULONG offset);
    // See the end of interface for another overload of AetVTableEntry

    virtual HRESULT SetStrongNameEntry(HCEEFILE ceeFile, ULONG size, ULONG offset);

    // Emit the metadata from "emitter".
    // If 'section != 0, it will put the data in 'buffer'.  This
    // buffer is assumed to be in 'section' at 'offset' and of size 'buffLen'
    // (should use GetSaveSize to insure that buffer is big enough
    virtual HRESULT EmitMetaDataAt (HCEEFILE ceeFile, IMetaDataEmit *emitter, 
                                    HCEESECTION section, DWORD offset, 
                                    BYTE* buffer, unsigned buffLen);

    virtual HRESULT GetFileTimeStamp (HCEEFILE ceeFile, DWORD *pTimeStamp);

    // Add a notification handler. If it implements an interface that
    // the ICeeFileGen understands, S_OK is returned. Otherwise,
    // E_NOINTERFACE.
    virtual HRESULT AddNotificationHandler(HCEEFILE ceeFile,
                                           IUnknown *pHandler);

    virtual HRESULT SetFileAlignment(HCEEFILE ceeFile, ULONG fileAlignment);

    virtual HRESULT ClearComImageFlags (HCEEFILE ceeFile, DWORD mask);

    // call this to instantiate a PE+ (64-bit PE file)
    virtual HRESULT CreateCeeFileEx(HCEEFILE *ceeFile, ULONG createFlags);
    virtual HRESULT SetImageBase64(HCEEFILE ceeFile, ULONGLONG imageBase);

    virtual HRESULT GetHeaderInfo (HCEEFILE ceeFile, PIMAGE_NT_HEADERS *ppNtHeaders,
                                                     PIMAGE_SECTION_HEADER *ppSections,
                                                     ULONG *pNumSections);

    // Seed file is a base file which is copied over into the output file
    // Note that there are restrictions on the seed file (the sections
    // cannot be relocated), and that the copy is not complete as the new
    // headers overwrite the seed file headers.
    virtual HRESULT CreateCeeFileEx2(HCEEFILE *ceeFile, ULONG createFlags,
                                     LPCWSTR seedFileName = NULL);

    virtual HRESULT SetVTableEntry64(HCEEFILE ceeFile, ULONG size, void* ptr);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\isolation.h ===
/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include <specstrings.h>

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __isolation_h__
#define __isolation_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IReferenceIdentity_FWD_DEFINED__
#define __IReferenceIdentity_FWD_DEFINED__
typedef interface IReferenceIdentity IReferenceIdentity;
#endif 	/* __IReferenceIdentity_FWD_DEFINED__ */


#ifndef __IDefinitionIdentity_FWD_DEFINED__
#define __IDefinitionIdentity_FWD_DEFINED__
typedef interface IDefinitionIdentity IDefinitionIdentity;
#endif 	/* __IDefinitionIdentity_FWD_DEFINED__ */


#ifndef __IEnumIDENTITY_ATTRIBUTE_FWD_DEFINED__
#define __IEnumIDENTITY_ATTRIBUTE_FWD_DEFINED__
typedef interface IEnumIDENTITY_ATTRIBUTE IEnumIDENTITY_ATTRIBUTE;
#endif 	/* __IEnumIDENTITY_ATTRIBUTE_FWD_DEFINED__ */


#ifndef __IEnumDefinitionIdentity_FWD_DEFINED__
#define __IEnumDefinitionIdentity_FWD_DEFINED__
typedef interface IEnumDefinitionIdentity IEnumDefinitionIdentity;
#endif 	/* __IEnumDefinitionIdentity_FWD_DEFINED__ */


#ifndef __IEnumReferenceIdentity_FWD_DEFINED__
#define __IEnumReferenceIdentity_FWD_DEFINED__
typedef interface IEnumReferenceIdentity IEnumReferenceIdentity;
#endif 	/* __IEnumReferenceIdentity_FWD_DEFINED__ */


#ifndef __IDefinitionAppId_FWD_DEFINED__
#define __IDefinitionAppId_FWD_DEFINED__
typedef interface IDefinitionAppId IDefinitionAppId;
#endif 	/* __IDefinitionAppId_FWD_DEFINED__ */


#ifndef __IReferenceAppId_FWD_DEFINED__
#define __IReferenceAppId_FWD_DEFINED__
typedef interface IReferenceAppId IReferenceAppId;
#endif 	/* __IReferenceAppId_FWD_DEFINED__ */


#ifndef __IIdentityAuthority_FWD_DEFINED__
#define __IIdentityAuthority_FWD_DEFINED__
typedef interface IIdentityAuthority IIdentityAuthority;
#endif 	/* __IIdentityAuthority_FWD_DEFINED__ */


#ifndef __IAppIdAuthority_FWD_DEFINED__
#define __IAppIdAuthority_FWD_DEFINED__
typedef interface IAppIdAuthority IAppIdAuthority;
#endif 	/* __IAppIdAuthority_FWD_DEFINED__ */


#ifndef __IIdentityAuthority_FWD_DEFINED__
#define __IIdentityAuthority_FWD_DEFINED__
typedef interface IIdentityAuthority IIdentityAuthority;
#endif 	/* __IIdentityAuthority_FWD_DEFINED__ */


#ifndef __IAppIdAuthority_FWD_DEFINED__
#define __IAppIdAuthority_FWD_DEFINED__
typedef interface IAppIdAuthority IAppIdAuthority;
#endif 	/* __IAppIdAuthority_FWD_DEFINED__ */


#ifndef __IDefinitionIdentity_FWD_DEFINED__
#define __IDefinitionIdentity_FWD_DEFINED__
typedef interface IDefinitionIdentity IDefinitionIdentity;
#endif 	/* __IDefinitionIdentity_FWD_DEFINED__ */


#ifndef __IReferenceIdentity_FWD_DEFINED__
#define __IReferenceIdentity_FWD_DEFINED__
typedef interface IReferenceIdentity IReferenceIdentity;
#endif 	/* __IReferenceIdentity_FWD_DEFINED__ */


#ifndef __IDefinitionAppId_FWD_DEFINED__
#define __IDefinitionAppId_FWD_DEFINED__
typedef interface IDefinitionAppId IDefinitionAppId;
#endif 	/* __IDefinitionAppId_FWD_DEFINED__ */


#ifndef __IReferenceAppId_FWD_DEFINED__
#define __IReferenceAppId_FWD_DEFINED__
typedef interface IReferenceAppId IReferenceAppId;
#endif 	/* __IReferenceAppId_FWD_DEFINED__ */


#ifndef __IEnumIDENTITY_ATTRIBUTE_FWD_DEFINED__
#define __IEnumIDENTITY_ATTRIBUTE_FWD_DEFINED__
typedef interface IEnumIDENTITY_ATTRIBUTE IEnumIDENTITY_ATTRIBUTE;
#endif 	/* __IEnumIDENTITY_ATTRIBUTE_FWD_DEFINED__ */


#ifndef __IEnumDefinitionIdentity_FWD_DEFINED__
#define __IEnumDefinitionIdentity_FWD_DEFINED__
typedef interface IEnumDefinitionIdentity IEnumDefinitionIdentity;
#endif 	/* __IEnumDefinitionIdentity_FWD_DEFINED__ */


#ifndef __IEnumReferenceIdentity_FWD_DEFINED__
#define __IEnumReferenceIdentity_FWD_DEFINED__
typedef interface IEnumReferenceIdentity IEnumReferenceIdentity;
#endif 	/* __IEnumReferenceIdentity_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "ocidl.h"
#include "propidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 


typedef struct _IDENTITY_ATTRIBUTE
    {
    LPCWSTR pszNamespace;
    LPCWSTR pszName;
    LPCWSTR pszValue;
    } 	IDENTITY_ATTRIBUTE;

typedef struct _IDENTITY_ATTRIBUTE *PIDENTITY_ATTRIBUTE;

typedef const IDENTITY_ATTRIBUTE *PCIDENTITY_ATTRIBUTE;


#ifndef __IReferenceIdentity_INTERFACE_DEFINED__
#define __IReferenceIdentity_INTERFACE_DEFINED__

/* interface IReferenceIdentity */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IReferenceIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6eaf5ace-7917-4f3c-b129-e046a9704766")
    IReferenceIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ LPWSTR *ppszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [unique][in] */ LPCWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAttributes( 
            /* [retval][out] */ IEnumIDENTITY_ATTRIBUTE **ppIEnumIDENTITY_ATTRIBUTE) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ SIZE_T cDeltas,
            /* [size_is][in] */ const IDENTITY_ATTRIBUTE rgDeltas[  ],
            /* [retval][out] */ IReferenceIdentity **ppIReferenceIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReferenceIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReferenceIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReferenceIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReferenceIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            IReferenceIdentity * This,
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ LPWSTR *ppszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IReferenceIdentity * This,
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [unique][in] */ LPCWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAttributes )( 
            IReferenceIdentity * This,
            /* [retval][out] */ IEnumIDENTITY_ATTRIBUTE **ppIEnumIDENTITY_ATTRIBUTE);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IReferenceIdentity * This,
            /* [in] */ SIZE_T cDeltas,
            /* [size_is][in] */ const IDENTITY_ATTRIBUTE rgDeltas[  ],
            /* [retval][out] */ IReferenceIdentity **ppIReferenceIdentity);
        
        END_INTERFACE
    } IReferenceIdentityVtbl;

    interface IReferenceIdentity
    {
        CONST_VTBL struct IReferenceIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReferenceIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReferenceIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReferenceIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReferenceIdentity_GetAttribute(This,pszNamespace,pszName,ppszValue)	\
    (This)->lpVtbl -> GetAttribute(This,pszNamespace,pszName,ppszValue)

#define IReferenceIdentity_SetAttribute(This,pszNamespace,pszName,pszValue)	\
    (This)->lpVtbl -> SetAttribute(This,pszNamespace,pszName,pszValue)

#define IReferenceIdentity_EnumAttributes(This,ppIEnumIDENTITY_ATTRIBUTE)	\
    (This)->lpVtbl -> EnumAttributes(This,ppIEnumIDENTITY_ATTRIBUTE)

#define IReferenceIdentity_Clone(This,cDeltas,rgDeltas,ppIReferenceIdentity)	\
    (This)->lpVtbl -> Clone(This,cDeltas,rgDeltas,ppIReferenceIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IReferenceIdentity_GetAttribute_Proxy( 
    IReferenceIdentity * This,
    /* [unique][in] */ LPCWSTR pszNamespace,
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ LPWSTR *ppszValue);


void __RPC_STUB IReferenceIdentity_GetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceIdentity_SetAttribute_Proxy( 
    IReferenceIdentity * This,
    /* [unique][in] */ LPCWSTR pszNamespace,
    /* [in] */ LPCWSTR pszName,
    /* [unique][in] */ LPCWSTR pszValue);


void __RPC_STUB IReferenceIdentity_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceIdentity_EnumAttributes_Proxy( 
    IReferenceIdentity * This,
    /* [retval][out] */ IEnumIDENTITY_ATTRIBUTE **ppIEnumIDENTITY_ATTRIBUTE);


void __RPC_STUB IReferenceIdentity_EnumAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceIdentity_Clone_Proxy( 
    IReferenceIdentity * This,
    /* [in] */ SIZE_T cDeltas,
    /* [size_is][in] */ const IDENTITY_ATTRIBUTE rgDeltas[  ],
    /* [retval][out] */ IReferenceIdentity **ppIReferenceIdentity);


void __RPC_STUB IReferenceIdentity_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReferenceIdentity_INTERFACE_DEFINED__ */


#ifndef __IDefinitionIdentity_INTERFACE_DEFINED__
#define __IDefinitionIdentity_INTERFACE_DEFINED__

/* interface IDefinitionIdentity */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDefinitionIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("587bf538-4d90-4a3c-9ef1-58a200a8a9e7")
    IDefinitionIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetAttribute( 
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ LPWSTR *ppszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAttribute( 
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [unique][in] */ LPCWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAttributes( 
            /* [retval][out] */ IEnumIDENTITY_ATTRIBUTE **ppIEAIA) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ SIZE_T cDeltas,
            /* [size_is][in] */ const IDENTITY_ATTRIBUTE prgDeltas[  ],
            /* [retval][out] */ IDefinitionIdentity **ppIDefinitionIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDefinitionIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDefinitionIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDefinitionIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDefinitionIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetAttribute )( 
            IDefinitionIdentity * This,
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [retval][out] */ LPWSTR *ppszValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetAttribute )( 
            IDefinitionIdentity * This,
            /* [unique][in] */ LPCWSTR pszNamespace,
            /* [in] */ LPCWSTR pszName,
            /* [unique][in] */ LPCWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAttributes )( 
            IDefinitionIdentity * This,
            /* [retval][out] */ IEnumIDENTITY_ATTRIBUTE **ppIEAIA);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDefinitionIdentity * This,
            /* [in] */ SIZE_T cDeltas,
            /* [size_is][in] */ const IDENTITY_ATTRIBUTE prgDeltas[  ],
            /* [retval][out] */ IDefinitionIdentity **ppIDefinitionIdentity);
        
        END_INTERFACE
    } IDefinitionIdentityVtbl;

    interface IDefinitionIdentity
    {
        CONST_VTBL struct IDefinitionIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDefinitionIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDefinitionIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDefinitionIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDefinitionIdentity_GetAttribute(This,pszNamespace,pszName,ppszValue)	\
    (This)->lpVtbl -> GetAttribute(This,pszNamespace,pszName,ppszValue)

#define IDefinitionIdentity_SetAttribute(This,pszNamespace,pszName,pszValue)	\
    (This)->lpVtbl -> SetAttribute(This,pszNamespace,pszName,pszValue)

#define IDefinitionIdentity_EnumAttributes(This,ppIEAIA)	\
    (This)->lpVtbl -> EnumAttributes(This,ppIEAIA)

#define IDefinitionIdentity_Clone(This,cDeltas,prgDeltas,ppIDefinitionIdentity)	\
    (This)->lpVtbl -> Clone(This,cDeltas,prgDeltas,ppIDefinitionIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDefinitionIdentity_GetAttribute_Proxy( 
    IDefinitionIdentity * This,
    /* [unique][in] */ LPCWSTR pszNamespace,
    /* [in] */ LPCWSTR pszName,
    /* [retval][out] */ LPWSTR *ppszValue);


void __RPC_STUB IDefinitionIdentity_GetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefinitionIdentity_SetAttribute_Proxy( 
    IDefinitionIdentity * This,
    /* [unique][in] */ LPCWSTR pszNamespace,
    /* [in] */ LPCWSTR pszName,
    /* [unique][in] */ LPCWSTR pszValue);


void __RPC_STUB IDefinitionIdentity_SetAttribute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefinitionIdentity_EnumAttributes_Proxy( 
    IDefinitionIdentity * This,
    /* [retval][out] */ IEnumIDENTITY_ATTRIBUTE **ppIEAIA);


void __RPC_STUB IDefinitionIdentity_EnumAttributes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefinitionIdentity_Clone_Proxy( 
    IDefinitionIdentity * This,
    /* [in] */ SIZE_T cDeltas,
    /* [size_is][in] */ const IDENTITY_ATTRIBUTE prgDeltas[  ],
    /* [retval][out] */ IDefinitionIdentity **ppIDefinitionIdentity);


void __RPC_STUB IDefinitionIdentity_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDefinitionIdentity_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_isolation_0320 */
/* [local] */ 

typedef struct _IDENTITY_ATTRIBUTE_BLOB
    {
    DWORD ofsNamespace;
    DWORD ofsName;
    DWORD ofsValue;
    } 	IDENTITY_ATTRIBUTE_BLOB;

typedef struct _IDENTITY_ATTRIBUTE_BLOB *PIDENTITY_ATTRIBUTE_BLOB;



extern RPC_IF_HANDLE __MIDL_itf_isolation_0320_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_isolation_0320_v0_0_s_ifspec;

#ifndef __IEnumIDENTITY_ATTRIBUTE_INTERFACE_DEFINED__
#define __IEnumIDENTITY_ATTRIBUTE_INTERFACE_DEFINED__

/* interface IEnumIDENTITY_ATTRIBUTE */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumIDENTITY_ATTRIBUTE;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9cdaae75-246e-4b00-a26d-b9aec137a3eb")
    IEnumIDENTITY_ATTRIBUTE : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDENTITY_ATTRIBUTE rgAttributes[  ],
            /* [optional][out] */ ULONG *pceltWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CurrentIntoBuffer( 
            /* [in] */ SIZE_T cbAvailable,
            /* [length_is][size_is][out][in] */ BYTE pbData[  ],
            /* [out] */ SIZE_T *pcbUsed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumIDENTITY_ATTRIBUTE **ppIEnumIDENTITY_ATTRIBUTE) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumIDENTITY_ATTRIBUTEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumIDENTITY_ATTRIBUTE * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumIDENTITY_ATTRIBUTE * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumIDENTITY_ATTRIBUTE * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumIDENTITY_ATTRIBUTE * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDENTITY_ATTRIBUTE rgAttributes[  ],
            /* [optional][out] */ ULONG *pceltWritten);
        
        HRESULT ( STDMETHODCALLTYPE *CurrentIntoBuffer )( 
            IEnumIDENTITY_ATTRIBUTE * This,
            /* [in] */ SIZE_T cbAvailable,
            /* [length_is][size_is][out][in] */ BYTE pbData[  ],
            /* [out] */ SIZE_T *pcbUsed);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumIDENTITY_ATTRIBUTE * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumIDENTITY_ATTRIBUTE * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumIDENTITY_ATTRIBUTE * This,
            /* [out] */ IEnumIDENTITY_ATTRIBUTE **ppIEnumIDENTITY_ATTRIBUTE);
        
        END_INTERFACE
    } IEnumIDENTITY_ATTRIBUTEVtbl;

    interface IEnumIDENTITY_ATTRIBUTE
    {
        CONST_VTBL struct IEnumIDENTITY_ATTRIBUTEVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumIDENTITY_ATTRIBUTE_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumIDENTITY_ATTRIBUTE_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumIDENTITY_ATTRIBUTE_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumIDENTITY_ATTRIBUTE_Next(This,celt,rgAttributes,pceltWritten)	\
    (This)->lpVtbl -> Next(This,celt,rgAttributes,pceltWritten)

#define IEnumIDENTITY_ATTRIBUTE_CurrentIntoBuffer(This,cbAvailable,pbData,pcbUsed)	\
    (This)->lpVtbl -> CurrentIntoBuffer(This,cbAvailable,pbData,pcbUsed)

#define IEnumIDENTITY_ATTRIBUTE_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumIDENTITY_ATTRIBUTE_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumIDENTITY_ATTRIBUTE_Clone(This,ppIEnumIDENTITY_ATTRIBUTE)	\
    (This)->lpVtbl -> Clone(This,ppIEnumIDENTITY_ATTRIBUTE)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumIDENTITY_ATTRIBUTE_Next_Proxy( 
    IEnumIDENTITY_ATTRIBUTE * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDENTITY_ATTRIBUTE rgAttributes[  ],
    /* [optional][out] */ ULONG *pceltWritten);


void __RPC_STUB IEnumIDENTITY_ATTRIBUTE_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumIDENTITY_ATTRIBUTE_CurrentIntoBuffer_Proxy( 
    IEnumIDENTITY_ATTRIBUTE * This,
    /* [in] */ SIZE_T cbAvailable,
    /* [length_is][size_is][out][in] */ BYTE pbData[  ],
    /* [out] */ SIZE_T *pcbUsed);


void __RPC_STUB IEnumIDENTITY_ATTRIBUTE_CurrentIntoBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumIDENTITY_ATTRIBUTE_Skip_Proxy( 
    IEnumIDENTITY_ATTRIBUTE * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumIDENTITY_ATTRIBUTE_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumIDENTITY_ATTRIBUTE_Reset_Proxy( 
    IEnumIDENTITY_ATTRIBUTE * This);


void __RPC_STUB IEnumIDENTITY_ATTRIBUTE_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumIDENTITY_ATTRIBUTE_Clone_Proxy( 
    IEnumIDENTITY_ATTRIBUTE * This,
    /* [out] */ IEnumIDENTITY_ATTRIBUTE **ppIEnumIDENTITY_ATTRIBUTE);


void __RPC_STUB IEnumIDENTITY_ATTRIBUTE_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumIDENTITY_ATTRIBUTE_INTERFACE_DEFINED__ */


#ifndef __IEnumDefinitionIdentity_INTERFACE_DEFINED__
#define __IEnumDefinitionIdentity_INTERFACE_DEFINED__

/* interface IEnumDefinitionIdentity */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumDefinitionIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("f3549d9c-fc73-4793-9c00-1cd204254c0c")
    IEnumDefinitionIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDefinitionIdentity *rgpIDefinitionIdentity[  ],
            /* [out] */ ULONG *pceltWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDefinitionIdentity **ppIEnumDefinitionIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDefinitionIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumDefinitionIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumDefinitionIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumDefinitionIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumDefinitionIdentity * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IDefinitionIdentity *rgpIDefinitionIdentity[  ],
            /* [out] */ ULONG *pceltWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumDefinitionIdentity * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumDefinitionIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumDefinitionIdentity * This,
            /* [out] */ IEnumDefinitionIdentity **ppIEnumDefinitionIdentity);
        
        END_INTERFACE
    } IEnumDefinitionIdentityVtbl;

    interface IEnumDefinitionIdentity
    {
        CONST_VTBL struct IEnumDefinitionIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDefinitionIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDefinitionIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDefinitionIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDefinitionIdentity_Next(This,celt,rgpIDefinitionIdentity,pceltWritten)	\
    (This)->lpVtbl -> Next(This,celt,rgpIDefinitionIdentity,pceltWritten)

#define IEnumDefinitionIdentity_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDefinitionIdentity_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDefinitionIdentity_Clone(This,ppIEnumDefinitionIdentity)	\
    (This)->lpVtbl -> Clone(This,ppIEnumDefinitionIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDefinitionIdentity_Next_Proxy( 
    IEnumDefinitionIdentity * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IDefinitionIdentity *rgpIDefinitionIdentity[  ],
    /* [out] */ ULONG *pceltWritten);


void __RPC_STUB IEnumDefinitionIdentity_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDefinitionIdentity_Skip_Proxy( 
    IEnumDefinitionIdentity * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDefinitionIdentity_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDefinitionIdentity_Reset_Proxy( 
    IEnumDefinitionIdentity * This);


void __RPC_STUB IEnumDefinitionIdentity_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDefinitionIdentity_Clone_Proxy( 
    IEnumDefinitionIdentity * This,
    /* [out] */ IEnumDefinitionIdentity **ppIEnumDefinitionIdentity);


void __RPC_STUB IEnumDefinitionIdentity_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDefinitionIdentity_INTERFACE_DEFINED__ */


#ifndef __IEnumReferenceIdentity_INTERFACE_DEFINED__
#define __IEnumReferenceIdentity_INTERFACE_DEFINED__

/* interface IEnumReferenceIdentity */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumReferenceIdentity;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b30352cf-23da-4577-9b3f-b4e6573be53b")
    IEnumReferenceIdentity : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IReferenceIdentity **prgpIReferenceIdentity,
            /* [out] */ ULONG *pceltWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            IEnumReferenceIdentity **ppIEnumReferenceIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumReferenceIdentityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumReferenceIdentity * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumReferenceIdentity * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumReferenceIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumReferenceIdentity * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IReferenceIdentity **prgpIReferenceIdentity,
            /* [out] */ ULONG *pceltWritten);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumReferenceIdentity * This,
            ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumReferenceIdentity * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumReferenceIdentity * This,
            IEnumReferenceIdentity **ppIEnumReferenceIdentity);
        
        END_INTERFACE
    } IEnumReferenceIdentityVtbl;

    interface IEnumReferenceIdentity
    {
        CONST_VTBL struct IEnumReferenceIdentityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumReferenceIdentity_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumReferenceIdentity_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumReferenceIdentity_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumReferenceIdentity_Next(This,celt,prgpIReferenceIdentity,pceltWritten)	\
    (This)->lpVtbl -> Next(This,celt,prgpIReferenceIdentity,pceltWritten)

#define IEnumReferenceIdentity_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumReferenceIdentity_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumReferenceIdentity_Clone(This,ppIEnumReferenceIdentity)	\
    (This)->lpVtbl -> Clone(This,ppIEnumReferenceIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumReferenceIdentity_Next_Proxy( 
    IEnumReferenceIdentity * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IReferenceIdentity **prgpIReferenceIdentity,
    /* [out] */ ULONG *pceltWritten);


void __RPC_STUB IEnumReferenceIdentity_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumReferenceIdentity_Skip_Proxy( 
    IEnumReferenceIdentity * This,
    ULONG celt);


void __RPC_STUB IEnumReferenceIdentity_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumReferenceIdentity_Reset_Proxy( 
    IEnumReferenceIdentity * This);


void __RPC_STUB IEnumReferenceIdentity_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumReferenceIdentity_Clone_Proxy( 
    IEnumReferenceIdentity * This,
    IEnumReferenceIdentity **ppIEnumReferenceIdentity);


void __RPC_STUB IEnumReferenceIdentity_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumReferenceIdentity_INTERFACE_DEFINED__ */


#ifndef __IDefinitionAppId_INTERFACE_DEFINED__
#define __IDefinitionAppId_INTERFACE_DEFINED__

/* interface IDefinitionAppId */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IDefinitionAppId;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d91e12d8-98ed-47fa-9936-39421283d59b")
    IDefinitionAppId : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SubscriptionId( 
            /* [retval][out] */ LPWSTR *ppszSubscription) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SubscriptionId( 
            /* [in] */ LPCWSTR pszSubscription) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Codebase( 
            /* [retval][out] */ LPWSTR *ppszCodebase) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Codebase( 
            /* [in] */ LPCWSTR pszCodebase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAppPath( 
            /* [out] */ IEnumDefinitionIdentity **ppIEnumDefinitionIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAppPath( 
            /* [in] */ ULONG cIDefinitionIdentity,
            /* [size_is][in] */ IDefinitionIdentity *rgIDefinitionIdentity[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDefinitionAppIdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDefinitionAppId * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDefinitionAppId * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDefinitionAppId * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubscriptionId )( 
            IDefinitionAppId * This,
            /* [retval][out] */ LPWSTR *ppszSubscription);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SubscriptionId )( 
            IDefinitionAppId * This,
            /* [in] */ LPCWSTR pszSubscription);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Codebase )( 
            IDefinitionAppId * This,
            /* [retval][out] */ LPWSTR *ppszCodebase);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Codebase )( 
            IDefinitionAppId * This,
            /* [in] */ LPCWSTR pszCodebase);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAppPath )( 
            IDefinitionAppId * This,
            /* [out] */ IEnumDefinitionIdentity **ppIEnumDefinitionIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppPath )( 
            IDefinitionAppId * This,
            /* [in] */ ULONG cIDefinitionIdentity,
            /* [size_is][in] */ IDefinitionIdentity *rgIDefinitionIdentity[  ]);
        
        END_INTERFACE
    } IDefinitionAppIdVtbl;

    interface IDefinitionAppId
    {
        CONST_VTBL struct IDefinitionAppIdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDefinitionAppId_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDefinitionAppId_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDefinitionAppId_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDefinitionAppId_get_SubscriptionId(This,ppszSubscription)	\
    (This)->lpVtbl -> get_SubscriptionId(This,ppszSubscription)

#define IDefinitionAppId_put_SubscriptionId(This,pszSubscription)	\
    (This)->lpVtbl -> put_SubscriptionId(This,pszSubscription)

#define IDefinitionAppId_get_Codebase(This,ppszCodebase)	\
    (This)->lpVtbl -> get_Codebase(This,ppszCodebase)

#define IDefinitionAppId_put_Codebase(This,pszCodebase)	\
    (This)->lpVtbl -> put_Codebase(This,pszCodebase)

#define IDefinitionAppId_EnumAppPath(This,ppIEnumDefinitionIdentity)	\
    (This)->lpVtbl -> EnumAppPath(This,ppIEnumDefinitionIdentity)

#define IDefinitionAppId_SetAppPath(This,cIDefinitionIdentity,rgIDefinitionIdentity)	\
    (This)->lpVtbl -> SetAppPath(This,cIDefinitionIdentity,rgIDefinitionIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IDefinitionAppId_get_SubscriptionId_Proxy( 
    IDefinitionAppId * This,
    /* [retval][out] */ LPWSTR *ppszSubscription);


void __RPC_STUB IDefinitionAppId_get_SubscriptionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDefinitionAppId_put_SubscriptionId_Proxy( 
    IDefinitionAppId * This,
    /* [in] */ LPCWSTR pszSubscription);


void __RPC_STUB IDefinitionAppId_put_SubscriptionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDefinitionAppId_get_Codebase_Proxy( 
    IDefinitionAppId * This,
    /* [retval][out] */ __deref_out_opt LPWSTR *ppszCodebase);


void __RPC_STUB IDefinitionAppId_get_Codebase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDefinitionAppId_put_Codebase_Proxy( 
    IDefinitionAppId * This,
    /* [in] */ LPCWSTR pszCodebase);


void __RPC_STUB IDefinitionAppId_put_Codebase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefinitionAppId_EnumAppPath_Proxy( 
    IDefinitionAppId * This,
    /* [out] */ IEnumDefinitionIdentity **ppIEnumDefinitionIdentity);


void __RPC_STUB IDefinitionAppId_EnumAppPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDefinitionAppId_SetAppPath_Proxy( 
    IDefinitionAppId * This,
    /* [in] */ ULONG cIDefinitionIdentity,
    /* [size_is][in] */ IDefinitionIdentity *rgIDefinitionIdentity[  ]);


void __RPC_STUB IDefinitionAppId_SetAppPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDefinitionAppId_INTERFACE_DEFINED__ */


#ifndef __IReferenceAppId_INTERFACE_DEFINED__
#define __IReferenceAppId_INTERFACE_DEFINED__

/* interface IReferenceAppId */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_IReferenceAppId;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("054f0bef-9e45-4363-8f5a-2f8e142d9a3b")
    IReferenceAppId : public IUnknown
    {
    public:
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SubscriptionId( 
            /* [retval][out] */ LPWSTR *ppszSubscription) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_SubscriptionId( 
            /* [in] */ LPCWSTR pszSubscription) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Codebase( 
            /* [retval][out] */ LPWSTR *ppszCodebase) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Codebase( 
            /* [in] */ LPCWSTR pszCodebase) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumAppPath( 
            /* [out] */ IEnumReferenceIdentity **ppIReferenceAppId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReferenceAppIdVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IReferenceAppId * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IReferenceAppId * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IReferenceAppId * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_SubscriptionId )( 
            IReferenceAppId * This,
            /* [retval][out] */ LPWSTR *ppszSubscription);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_SubscriptionId )( 
            IReferenceAppId * This,
            /* [in] */ LPCWSTR pszSubscription);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE *get_Codebase )( 
            IReferenceAppId * This,
            /* [retval][out] */ LPWSTR *ppszCodebase);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE *put_Codebase )( 
            IReferenceAppId * This,
            /* [in] */ LPCWSTR pszCodebase);
        
        HRESULT ( STDMETHODCALLTYPE *EnumAppPath )( 
            IReferenceAppId * This,
            /* [out] */ IEnumReferenceIdentity **ppIReferenceAppId);
        
        END_INTERFACE
    } IReferenceAppIdVtbl;

    interface IReferenceAppId
    {
        CONST_VTBL struct IReferenceAppIdVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReferenceAppId_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReferenceAppId_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReferenceAppId_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReferenceAppId_get_SubscriptionId(This,ppszSubscription)	\
    (This)->lpVtbl -> get_SubscriptionId(This,ppszSubscription)

#define IReferenceAppId_put_SubscriptionId(This,pszSubscription)	\
    (This)->lpVtbl -> put_SubscriptionId(This,pszSubscription)

#define IReferenceAppId_get_Codebase(This,ppszCodebase)	\
    (This)->lpVtbl -> get_Codebase(This,ppszCodebase)

#define IReferenceAppId_put_Codebase(This,pszCodebase)	\
    (This)->lpVtbl -> put_Codebase(This,pszCodebase)

#define IReferenceAppId_EnumAppPath(This,ppIReferenceAppId)	\
    (This)->lpVtbl -> EnumAppPath(This,ppIReferenceAppId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget] */ HRESULT STDMETHODCALLTYPE IReferenceAppId_get_SubscriptionId_Proxy( 
    IReferenceAppId * This,
    /* [retval][out] */ LPWSTR *ppszSubscription);


void __RPC_STUB IReferenceAppId_get_SubscriptionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IReferenceAppId_put_SubscriptionId_Proxy( 
    IReferenceAppId * This,
    /* [in] */ LPCWSTR pszSubscription);


void __RPC_STUB IReferenceAppId_put_SubscriptionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IReferenceAppId_get_Codebase_Proxy( 
    IReferenceAppId * This,
    /* [retval][out] */ __deref_out_opt LPWSTR *ppszCodebase);


void __RPC_STUB IReferenceAppId_get_Codebase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IReferenceAppId_put_Codebase_Proxy( 
    IReferenceAppId * This,
    /* [in] */ LPCWSTR pszCodebase);


void __RPC_STUB IReferenceAppId_put_Codebase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IReferenceAppId_EnumAppPath_Proxy( 
    IReferenceAppId * This,
    /* [out] */ IEnumReferenceIdentity **ppIReferenceAppId);


void __RPC_STUB IReferenceAppId_EnumAppPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReferenceAppId_INTERFACE_DEFINED__ */


#ifndef __IIdentityAuthority_INTERFACE_DEFINED__
#define __IIdentityAuthority_INTERFACE_DEFINED__

/* interface IIdentityAuthority */
/* [local][unique][uuid][object] */ 

/* [v1_enum] */ 
enum _TEXT_TO_DEFINITION_IDENTITY_FLAGS
    {	TEXT_TO_DEFINITION_IDENTITY_FLAG_ALLOW_UNKNOWN_ATTRIBUTES_IN_NULL_NAMESPACE	= 0x1
    } ;
/* [v1_enum] */ 
enum _TEXT_TO_REFERENCE_IDENTITY_FLAGS
    {	TEXT_TO_REFERENCE_IDENTITY_FLAG_ALLOW_UNKNOWN_ATTRIBUTES_IN_NULL_NAMESPACE	= 0x1
    } ;
/* [v1_enum] */ 
enum _DEFINITION_IDENTITY_TO_TEXT_FLAGS
    {	DEFINITION_IDENTITY_TO_TEXT_FLAG_CANONICAL	= 0x1
    } ;
/* [v1_enum] */ 
enum _REFERENCE_IDENTITY_TO_TEXT_FLAGS
    {	REFERENCE_IDENTITY_TO_TEXT_FLAG_CANONICAL	= 0x1
    } ;
/* [v1_enum] */ 
enum _IIDENTITYAUTHORITY_DOES_DEFINITION_MATCH_REFERENCE_FLAGS
    {	IIDENTITYAUTHORITY_DOES_DEFINITION_MATCH_REFERENCE_FLAG_EXACT_MATCH_REQUIRED	= 0x1
    } ;
/* [v1_enum] */ 
enum _IIDENTITYAUTHORITY_DOES_TEXTUAL_DEFINITION_MATCH_TEXTUAL_REFERENCE_FLAGS
    {	IIDENTITYAUTHORITY_DOES_TEXTUAL_DEFINITION_MATCH_TEXTUAL_REFERENCE_FLAG_EXACT_MATCH_REQUIRED	= 0x1
    } ;

EXTERN_C const IID IID_IIdentityAuthority;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("261a6983-c35d-4d0d-aa5b-7867259e77bc")
    IIdentityAuthority : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TextToDefinition( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IDefinitionIdentity **ppIDefinitionIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextToReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IReferenceIdentity **ppIReferenceIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefinitionToText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszFormattedIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefinitionToTextBuffer( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [in] */ ULONG cchBufferSize,
            /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
            /* [out] */ ULONG *pcchBufferRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceToText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszFormattedIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceToTextBuffer( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [in] */ ULONG cchBufferSize,
            /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
            /* [out] */ ULONG *pcchBufferRequired) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreDefinitionsEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pDefinition1,
            /* [in] */ IDefinitionIdentity *pDefinition2,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreReferencesEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pReference1,
            /* [in] */ IReferenceIdentity *pReference2,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreTextualDefinitionsEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentityLeft,
            /* [in] */ LPCWSTR pszIdentityRight,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreTextualReferencesEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentityLeft,
            /* [in] */ LPCWSTR pszIdentityRight,
            /* [out] */ BOOL *pfEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesDefinitionMatchReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesTextualDefinitionMatchTextualReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszDefinition,
            /* [in] */ LPCWSTR pszReference,
            /* [out] */ BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashDefinition( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateDefinitionKey( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszKeyForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateReferenceKey( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszKeyForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDefinition( 
            /* [retval][out] */ IDefinitionIdentity **ppNewIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReference( 
            /* [retval][out] */ IReferenceIdentity **ppNewIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IIdentityAuthorityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IIdentityAuthority * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IIdentityAuthority * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IIdentityAuthority * This);
        
        HRESULT ( STDMETHODCALLTYPE *TextToDefinition )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IDefinitionIdentity **ppIDefinitionIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *TextToReference )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IReferenceIdentity **ppIReferenceIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *DefinitionToText )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszFormattedIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *DefinitionToTextBuffer )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [in] */ ULONG cchBufferSize,
            /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
            /* [out] */ ULONG *pcchBufferRequired);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceToText )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszFormattedIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceToTextBuffer )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [in] */ ULONG cchBufferSize,
            /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
            /* [out] */ ULONG *pcchBufferRequired);
        
        HRESULT ( STDMETHODCALLTYPE *AreDefinitionsEqual )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pDefinition1,
            /* [in] */ IDefinitionIdentity *pDefinition2,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreReferencesEqual )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pReference1,
            /* [in] */ IReferenceIdentity *pReference2,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreTextualDefinitionsEqual )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentityLeft,
            /* [in] */ LPCWSTR pszIdentityRight,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreTextualReferencesEqual )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentityLeft,
            /* [in] */ LPCWSTR pszIdentityRight,
            /* [out] */ BOOL *pfEqual);
        
        HRESULT ( STDMETHODCALLTYPE *DoesDefinitionMatchReference )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *DoesTextualDefinitionMatchTextualReference )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszDefinition,
            /* [in] */ LPCWSTR pszReference,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *HashReference )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey);
        
        HRESULT ( STDMETHODCALLTYPE *HashDefinition )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateDefinitionKey )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszKeyForm);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateReferenceKey )( 
            IIdentityAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceIdentity *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszKeyForm);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDefinition )( 
            IIdentityAuthority * This,
            /* [retval][out] */ IDefinitionIdentity **ppNewIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *CreateReference )( 
            IIdentityAuthority * This,
            /* [retval][out] */ IReferenceIdentity **ppNewIdentity);
        
        END_INTERFACE
    } IIdentityAuthorityVtbl;

    interface IIdentityAuthority
    {
        CONST_VTBL struct IIdentityAuthorityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IIdentityAuthority_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IIdentityAuthority_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IIdentityAuthority_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IIdentityAuthority_TextToDefinition(This,dwFlags,pszIdentity,ppIDefinitionIdentity)	\
    (This)->lpVtbl -> TextToDefinition(This,dwFlags,pszIdentity,ppIDefinitionIdentity)

#define IIdentityAuthority_TextToReference(This,dwFlags,pszIdentity,ppIReferenceIdentity)	\
    (This)->lpVtbl -> TextToReference(This,dwFlags,pszIdentity,ppIReferenceIdentity)

#define IIdentityAuthority_DefinitionToText(This,dwFlags,pIDefinitionIdentity,ppszFormattedIdentity)	\
    (This)->lpVtbl -> DefinitionToText(This,dwFlags,pIDefinitionIdentity,ppszFormattedIdentity)

#define IIdentityAuthority_DefinitionToTextBuffer(This,dwFlags,pIDefinitionIdentity,cchBufferSize,wchBuffer,pcchBufferRequired)	\
    (This)->lpVtbl -> DefinitionToTextBuffer(This,dwFlags,pIDefinitionIdentity,cchBufferSize,wchBuffer,pcchBufferRequired)

#define IIdentityAuthority_ReferenceToText(This,dwFlags,pIReferenceIdentity,ppszFormattedIdentity)	\
    (This)->lpVtbl -> ReferenceToText(This,dwFlags,pIReferenceIdentity,ppszFormattedIdentity)

#define IIdentityAuthority_ReferenceToTextBuffer(This,dwFlags,pIReferenceIdentity,cchBufferSize,wchBuffer,pcchBufferRequired)	\
    (This)->lpVtbl -> ReferenceToTextBuffer(This,dwFlags,pIReferenceIdentity,cchBufferSize,wchBuffer,pcchBufferRequired)

#define IIdentityAuthority_AreDefinitionsEqual(This,dwFlags,pDefinition1,pDefinition2,pfEqual)	\
    (This)->lpVtbl -> AreDefinitionsEqual(This,dwFlags,pDefinition1,pDefinition2,pfEqual)

#define IIdentityAuthority_AreReferencesEqual(This,dwFlags,pReference1,pReference2,pfEqual)	\
    (This)->lpVtbl -> AreReferencesEqual(This,dwFlags,pReference1,pReference2,pfEqual)

#define IIdentityAuthority_AreTextualDefinitionsEqual(This,dwFlags,pszIdentityLeft,pszIdentityRight,pfEqual)	\
    (This)->lpVtbl -> AreTextualDefinitionsEqual(This,dwFlags,pszIdentityLeft,pszIdentityRight,pfEqual)

#define IIdentityAuthority_AreTextualReferencesEqual(This,dwFlags,pszIdentityLeft,pszIdentityRight,pfEqual)	\
    (This)->lpVtbl -> AreTextualReferencesEqual(This,dwFlags,pszIdentityLeft,pszIdentityRight,pfEqual)

#define IIdentityAuthority_DoesDefinitionMatchReference(This,dwFlags,pIDefinitionIdentity,pIReferenceIdentity,pfMatches)	\
    (This)->lpVtbl -> DoesDefinitionMatchReference(This,dwFlags,pIDefinitionIdentity,pIReferenceIdentity,pfMatches)

#define IIdentityAuthority_DoesTextualDefinitionMatchTextualReference(This,dwFlags,pszDefinition,pszReference,pfMatches)	\
    (This)->lpVtbl -> DoesTextualDefinitionMatchTextualReference(This,dwFlags,pszDefinition,pszReference,pfMatches)

#define IIdentityAuthority_HashReference(This,dwFlags,pIReferenceIdentity,pullPseudoKey)	\
    (This)->lpVtbl -> HashReference(This,dwFlags,pIReferenceIdentity,pullPseudoKey)

#define IIdentityAuthority_HashDefinition(This,dwFlags,pIDefinitionIdentity,pullPseudoKey)	\
    (This)->lpVtbl -> HashDefinition(This,dwFlags,pIDefinitionIdentity,pullPseudoKey)

#define IIdentityAuthority_GenerateDefinitionKey(This,dwFlags,pIDefinitionIdentity,ppszKeyForm)	\
    (This)->lpVtbl -> GenerateDefinitionKey(This,dwFlags,pIDefinitionIdentity,ppszKeyForm)

#define IIdentityAuthority_GenerateReferenceKey(This,dwFlags,pIReferenceIdentity,ppszKeyForm)	\
    (This)->lpVtbl -> GenerateReferenceKey(This,dwFlags,pIReferenceIdentity,ppszKeyForm)

#define IIdentityAuthority_CreateDefinition(This,ppNewIdentity)	\
    (This)->lpVtbl -> CreateDefinition(This,ppNewIdentity)

#define IIdentityAuthority_CreateReference(This,ppNewIdentity)	\
    (This)->lpVtbl -> CreateReference(This,ppNewIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IIdentityAuthority_TextToDefinition_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentity,
    /* [out] */ IDefinitionIdentity **ppIDefinitionIdentity);


void __RPC_STUB IIdentityAuthority_TextToDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_TextToReference_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentity,
    /* [out] */ IReferenceIdentity **ppIReferenceIdentity);


void __RPC_STUB IIdentityAuthority_TextToReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_DefinitionToText_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszFormattedIdentity);


void __RPC_STUB IIdentityAuthority_DefinitionToText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_DefinitionToTextBuffer_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [in] */ ULONG cchBufferSize,
    /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
    /* [out] */ ULONG *pcchBufferRequired);


void __RPC_STUB IIdentityAuthority_DefinitionToTextBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_ReferenceToText_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszFormattedIdentity);


void __RPC_STUB IIdentityAuthority_ReferenceToText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_ReferenceToTextBuffer_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [in] */ ULONG cchBufferSize,
    /* [length_is][size_is][out][in] */ WCHAR wchBuffer[  ],
    /* [out] */ ULONG *pcchBufferRequired);


void __RPC_STUB IIdentityAuthority_ReferenceToTextBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_AreDefinitionsEqual_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pDefinition1,
    /* [in] */ IDefinitionIdentity *pDefinition2,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IIdentityAuthority_AreDefinitionsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_AreReferencesEqual_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pReference1,
    /* [in] */ IReferenceIdentity *pReference2,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IIdentityAuthority_AreReferencesEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_AreTextualDefinitionsEqual_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentityLeft,
    /* [in] */ LPCWSTR pszIdentityRight,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IIdentityAuthority_AreTextualDefinitionsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_AreTextualReferencesEqual_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentityLeft,
    /* [in] */ LPCWSTR pszIdentityRight,
    /* [out] */ BOOL *pfEqual);


void __RPC_STUB IIdentityAuthority_AreTextualReferencesEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_DoesDefinitionMatchReference_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB IIdentityAuthority_DoesDefinitionMatchReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_DoesTextualDefinitionMatchTextualReference_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszDefinition,
    /* [in] */ LPCWSTR pszReference,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB IIdentityAuthority_DoesTextualDefinitionMatchTextualReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_HashReference_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [out] */ ULONGLONG *pullPseudoKey);


void __RPC_STUB IIdentityAuthority_HashReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_HashDefinition_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [out] */ ULONGLONG *pullPseudoKey);


void __RPC_STUB IIdentityAuthority_HashDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_GenerateDefinitionKey_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionIdentity *pIDefinitionIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszKeyForm);


void __RPC_STUB IIdentityAuthority_GenerateDefinitionKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_GenerateReferenceKey_Proxy( 
    IIdentityAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceIdentity *pIReferenceIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszKeyForm);


void __RPC_STUB IIdentityAuthority_GenerateReferenceKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_CreateDefinition_Proxy( 
    IIdentityAuthority * This,
    /* [retval][out] */ IDefinitionIdentity **ppNewIdentity);


void __RPC_STUB IIdentityAuthority_CreateDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IIdentityAuthority_CreateReference_Proxy( 
    IIdentityAuthority * This,
    /* [retval][out] */ IReferenceIdentity **ppNewIdentity);


void __RPC_STUB IIdentityAuthority_CreateReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IIdentityAuthority_INTERFACE_DEFINED__ */


#ifndef __IAppIdAuthority_INTERFACE_DEFINED__
#define __IAppIdAuthority_INTERFACE_DEFINED__

/* interface IAppIdAuthority */
/* [local][unique][uuid][object] */ 

/* [v1_enum] */ 
enum IAPPIDAUTHORITY_ARE_DEFINITIONS_EQUAL_FLAGS
    {	IAPPIDAUTHORITY_ARE_DEFINITIONS_EQUAL_FLAG_IGNORE_VERSION	= 0x1
    } ;
/* [v1_enum] */ 
enum IAPPIDAUTHORITY_ARE_REFERENCES_EQUAL_FLAGS
    {	IAPPIDAUTHORITY_ARE_REFERENCES_EQUAL_FLAG_IGNORE_VERSION	= 0x1
    } ;

EXTERN_C const IID IID_IAppIdAuthority;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8c87810c-2541-4f75-b2d0-9af515488e23")
    IAppIdAuthority : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE TextToDefinition( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IDefinitionAppId **ppIDefinitionAppId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TextToReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IReferenceAppId **ppIReferenceAppId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefinitionToText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionAppId,
            /* [out] */ LPWSTR *ppszFormattedIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReferenceToText( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceAppId,
            /* [out] */ LPWSTR *ppszFormattedIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreDefinitionsEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pDefinition1,
            /* [in] */ IDefinitionAppId *pDefinition2,
            /* [out] */ BOOL *pfAreEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreReferencesEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pReference1,
            /* [in] */ IReferenceAppId *pReference2,
            /* [out] */ BOOL *pfAreEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreTextualDefinitionsEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAppIdLeft,
            /* [in] */ LPCWSTR pszAppIdRight,
            /* [out] */ BOOL *pfAreEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AreTextualReferencesEqual( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAppIdLeft,
            /* [in] */ LPCWSTR pszAppIdRight,
            /* [out] */ BOOL *pfAreEqual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesDefinitionMatchReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DoesTextualDefinitionMatchTextualReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszDefinition,
            /* [in] */ LPCWSTR pszReference,
            /* [out] */ BOOL *pfMatches) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashReference( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE HashDefinition( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateDefinitionKey( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszKeyForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateReferenceKey( 
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszKeyForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDefinition( 
            /* [retval][out] */ IDefinitionAppId **ppNewIdentity) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateReference( 
            /* [retval][out] */ IReferenceAppId **ppNewIdentity) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppIdAuthorityVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppIdAuthority * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppIdAuthority * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppIdAuthority * This);
        
        HRESULT ( STDMETHODCALLTYPE *TextToDefinition )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IDefinitionAppId **ppIDefinitionAppId);
        
        HRESULT ( STDMETHODCALLTYPE *TextToReference )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszIdentity,
            /* [out] */ IReferenceAppId **ppIReferenceAppId);
        
        HRESULT ( STDMETHODCALLTYPE *DefinitionToText )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionAppId,
            /* [out] */ LPWSTR *ppszFormattedIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *ReferenceToText )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceAppId,
            /* [out] */ LPWSTR *ppszFormattedIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *AreDefinitionsEqual )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pDefinition1,
            /* [in] */ IDefinitionAppId *pDefinition2,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreReferencesEqual )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pReference1,
            /* [in] */ IReferenceAppId *pReference2,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreTextualDefinitionsEqual )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAppIdLeft,
            /* [in] */ LPCWSTR pszAppIdRight,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *AreTextualReferencesEqual )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszAppIdLeft,
            /* [in] */ LPCWSTR pszAppIdRight,
            /* [out] */ BOOL *pfAreEqual);
        
        HRESULT ( STDMETHODCALLTYPE *DoesDefinitionMatchReference )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *DoesTextualDefinitionMatchTextualReference )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pszDefinition,
            /* [in] */ LPCWSTR pszReference,
            /* [out] */ BOOL *pfMatches);
        
        HRESULT ( STDMETHODCALLTYPE *HashReference )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey);
        
        HRESULT ( STDMETHODCALLTYPE *HashDefinition )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [out] */ ULONGLONG *pullPseudoKey);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateDefinitionKey )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
            /* [out] */ LPWSTR *ppszKeyForm);
        
        HRESULT ( STDMETHODCALLTYPE *GenerateReferenceKey )( 
            IAppIdAuthority * This,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IReferenceAppId *pIReferenceIdentity,
            /* [out] */ LPWSTR *ppszKeyForm);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDefinition )( 
            IAppIdAuthority * This,
            /* [retval][out] */ IDefinitionAppId **ppNewIdentity);
        
        HRESULT ( STDMETHODCALLTYPE *CreateReference )( 
            IAppIdAuthority * This,
            /* [retval][out] */ IReferenceAppId **ppNewIdentity);
        
        END_INTERFACE
    } IAppIdAuthorityVtbl;

    interface IAppIdAuthority
    {
        CONST_VTBL struct IAppIdAuthorityVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppIdAuthority_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppIdAuthority_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppIdAuthority_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppIdAuthority_TextToDefinition(This,dwFlags,pszIdentity,ppIDefinitionAppId)	\
    (This)->lpVtbl -> TextToDefinition(This,dwFlags,pszIdentity,ppIDefinitionAppId)

#define IAppIdAuthority_TextToReference(This,dwFlags,pszIdentity,ppIReferenceAppId)	\
    (This)->lpVtbl -> TextToReference(This,dwFlags,pszIdentity,ppIReferenceAppId)

#define IAppIdAuthority_DefinitionToText(This,dwFlags,pIDefinitionAppId,ppszFormattedIdentity)	\
    (This)->lpVtbl -> DefinitionToText(This,dwFlags,pIDefinitionAppId,ppszFormattedIdentity)

#define IAppIdAuthority_ReferenceToText(This,dwFlags,pIReferenceAppId,ppszFormattedIdentity)	\
    (This)->lpVtbl -> ReferenceToText(This,dwFlags,pIReferenceAppId,ppszFormattedIdentity)

#define IAppIdAuthority_AreDefinitionsEqual(This,dwFlags,pDefinition1,pDefinition2,pfAreEqual)	\
    (This)->lpVtbl -> AreDefinitionsEqual(This,dwFlags,pDefinition1,pDefinition2,pfAreEqual)

#define IAppIdAuthority_AreReferencesEqual(This,dwFlags,pReference1,pReference2,pfAreEqual)	\
    (This)->lpVtbl -> AreReferencesEqual(This,dwFlags,pReference1,pReference2,pfAreEqual)

#define IAppIdAuthority_AreTextualDefinitionsEqual(This,dwFlags,pszAppIdLeft,pszAppIdRight,pfAreEqual)	\
    (This)->lpVtbl -> AreTextualDefinitionsEqual(This,dwFlags,pszAppIdLeft,pszAppIdRight,pfAreEqual)

#define IAppIdAuthority_AreTextualReferencesEqual(This,dwFlags,pszAppIdLeft,pszAppIdRight,pfAreEqual)	\
    (This)->lpVtbl -> AreTextualReferencesEqual(This,dwFlags,pszAppIdLeft,pszAppIdRight,pfAreEqual)

#define IAppIdAuthority_DoesDefinitionMatchReference(This,dwFlags,pIDefinitionIdentity,pIReferenceIdentity,pfMatches)	\
    (This)->lpVtbl -> DoesDefinitionMatchReference(This,dwFlags,pIDefinitionIdentity,pIReferenceIdentity,pfMatches)

#define IAppIdAuthority_DoesTextualDefinitionMatchTextualReference(This,dwFlags,pszDefinition,pszReference,pfMatches)	\
    (This)->lpVtbl -> DoesTextualDefinitionMatchTextualReference(This,dwFlags,pszDefinition,pszReference,pfMatches)

#define IAppIdAuthority_HashReference(This,dwFlags,pIReferenceIdentity,pullPseudoKey)	\
    (This)->lpVtbl -> HashReference(This,dwFlags,pIReferenceIdentity,pullPseudoKey)

#define IAppIdAuthority_HashDefinition(This,dwFlags,pIDefinitionIdentity,pullPseudoKey)	\
    (This)->lpVtbl -> HashDefinition(This,dwFlags,pIDefinitionIdentity,pullPseudoKey)

#define IAppIdAuthority_GenerateDefinitionKey(This,dwFlags,pIDefinitionIdentity,ppszKeyForm)	\
    (This)->lpVtbl -> GenerateDefinitionKey(This,dwFlags,pIDefinitionIdentity,ppszKeyForm)

#define IAppIdAuthority_GenerateReferenceKey(This,dwFlags,pIReferenceIdentity,ppszKeyForm)	\
    (This)->lpVtbl -> GenerateReferenceKey(This,dwFlags,pIReferenceIdentity,ppszKeyForm)

#define IAppIdAuthority_CreateDefinition(This,ppNewIdentity)	\
    (This)->lpVtbl -> CreateDefinition(This,ppNewIdentity)

#define IAppIdAuthority_CreateReference(This,ppNewIdentity)	\
    (This)->lpVtbl -> CreateReference(This,ppNewIdentity)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAppIdAuthority_TextToDefinition_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentity,
    /* [out] */ IDefinitionAppId **ppIDefinitionAppId);


void __RPC_STUB IAppIdAuthority_TextToDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_TextToReference_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszIdentity,
    /* [out] */ IReferenceAppId **ppIReferenceAppId);


void __RPC_STUB IAppIdAuthority_TextToReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_DefinitionToText_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pIDefinitionAppId,
    /* [out] */ __deref_out_opt LPWSTR *ppszFormattedIdentity);


void __RPC_STUB IAppIdAuthority_DefinitionToText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_ReferenceToText_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceAppId *pIReferenceAppId,
    /* [out] */ __deref_out_opt LPWSTR *ppszFormattedIdentity);


void __RPC_STUB IAppIdAuthority_ReferenceToText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_AreDefinitionsEqual_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pDefinition1,
    /* [in] */ IDefinitionAppId *pDefinition2,
    /* [out] */ BOOL *pfAreEqual);


void __RPC_STUB IAppIdAuthority_AreDefinitionsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_AreReferencesEqual_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceAppId *pReference1,
    /* [in] */ IReferenceAppId *pReference2,
    /* [out] */ BOOL *pfAreEqual);


void __RPC_STUB IAppIdAuthority_AreReferencesEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_AreTextualDefinitionsEqual_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAppIdLeft,
    /* [in] */ LPCWSTR pszAppIdRight,
    /* [out] */ BOOL *pfAreEqual);


void __RPC_STUB IAppIdAuthority_AreTextualDefinitionsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_AreTextualReferencesEqual_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszAppIdLeft,
    /* [in] */ LPCWSTR pszAppIdRight,
    /* [out] */ BOOL *pfAreEqual);


void __RPC_STUB IAppIdAuthority_AreTextualReferencesEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_DoesDefinitionMatchReference_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
    /* [in] */ IReferenceAppId *pIReferenceIdentity,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB IAppIdAuthority_DoesDefinitionMatchReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_DoesTextualDefinitionMatchTextualReference_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pszDefinition,
    /* [in] */ LPCWSTR pszReference,
    /* [out] */ BOOL *pfMatches);


void __RPC_STUB IAppIdAuthority_DoesTextualDefinitionMatchTextualReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_HashReference_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceAppId *pIReferenceIdentity,
    /* [out] */ ULONGLONG *pullPseudoKey);


void __RPC_STUB IAppIdAuthority_HashReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_HashDefinition_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
    /* [out] */ ULONGLONG *pullPseudoKey);


void __RPC_STUB IAppIdAuthority_HashDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_GenerateDefinitionKey_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IDefinitionAppId *pIDefinitionIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszKeyForm);


void __RPC_STUB IAppIdAuthority_GenerateDefinitionKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_GenerateReferenceKey_Proxy( 
    IAppIdAuthority * This,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IReferenceAppId *pIReferenceIdentity,
    /* [out] */ __deref_out_opt LPWSTR *ppszKeyForm);


void __RPC_STUB IAppIdAuthority_GenerateReferenceKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_CreateDefinition_Proxy( 
    IAppIdAuthority * This,
    /* [retval][out] */ IDefinitionAppId **ppNewIdentity);


void __RPC_STUB IAppIdAuthority_CreateDefinition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAppIdAuthority_CreateReference_Proxy( 
    IAppIdAuthority * This,
    /* [retval][out] */ IReferenceAppId **ppNewIdentity);


void __RPC_STUB IAppIdAuthority_CreateReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppIdAuthority_INTERFACE_DEFINED__ */


/* [local] */ HRESULT __stdcall GetAppIdAuthority( 
    /* [out] */ IAppIdAuthority **ppIAppIdAuthority);

/* [local] */ HRESULT __stdcall GetIdentityAuthority( 
    /* [out] */ IIdentityAuthority **ppIIdentityAuthority);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\ivehandler.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for ivehandler.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ivehandler_h__
#define __ivehandler_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __VEHandlerClass_FWD_DEFINED__
#define __VEHandlerClass_FWD_DEFINED__

#ifdef __cplusplus
typedef class VEHandlerClass VEHandlerClass;
#else
typedef struct VEHandlerClass VEHandlerClass;
#endif /* __cplusplus */

#endif 	/* __VEHandlerClass_FWD_DEFINED__ */


#ifndef __IVEHandler_FWD_DEFINED__
#define __IVEHandler_FWD_DEFINED__
typedef interface IVEHandler IVEHandler;
#endif 	/* __IVEHandler_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ivehandler_0000 */
/* [local] */ 

typedef struct tag_VerError
    {
    unsigned long flags;
    unsigned long opcode;
    unsigned long uOffset;
    unsigned long Token;
    unsigned long item1_flags;
    int *item1_data;
    unsigned long item2_flags;
    int *item2_data;
    } 	_VerError;

typedef _VerError VEContext;




extern RPC_IF_HANDLE __MIDL_itf_ivehandler_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ivehandler_0000_v0_0_s_ifspec;


#ifndef __VEHandlerLib_LIBRARY_DEFINED__
#define __VEHandlerLib_LIBRARY_DEFINED__

/* library VEHandlerLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_VEHandlerLib;

EXTERN_C const CLSID CLSID_VEHandlerClass;

#ifdef __cplusplus

class DECLSPEC_UUID("856CA1B1-7DAB-11d3-ACEC-00C04F86C309")
VEHandlerClass;
#endif
#endif /* __VEHandlerLib_LIBRARY_DEFINED__ */

#ifndef __IVEHandler_INTERFACE_DEFINED__
#define __IVEHandler_INTERFACE_DEFINED__

/* interface IVEHandler */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IVEHandler;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("856CA1B2-7DAB-11d3-ACEC-00C04F86C309")
    IVEHandler : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE VEHandler( 
            /* [in] */ HRESULT VECode,
            /* [in] */ VEContext Context,
            /* [in] */ SAFEARRAY * psa) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetReporterFtn( 
            /* [in] */ __int64 lFnPtr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVEHandlerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IVEHandler * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IVEHandler * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IVEHandler * This);
        
        HRESULT ( STDMETHODCALLTYPE *VEHandler )( 
            IVEHandler * This,
            /* [in] */ HRESULT VECode,
            /* [in] */ VEContext Context,
            /* [in] */ SAFEARRAY * psa);
        
        HRESULT ( STDMETHODCALLTYPE *SetReporterFtn )( 
            IVEHandler * This,
            /* [in] */ __int64 lFnPtr);
        
        END_INTERFACE
    } IVEHandlerVtbl;

    interface IVEHandler
    {
        CONST_VTBL struct IVEHandlerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVEHandler_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVEHandler_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVEHandler_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVEHandler_VEHandler(This,VECode,Context,psa)	\
    (This)->lpVtbl -> VEHandler(This,VECode,Context,psa)

#define IVEHandler_SetReporterFtn(This,lFnPtr)	\
    (This)->lpVtbl -> SetReporterFtn(This,lFnPtr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IVEHandler_VEHandler_Proxy( 
    IVEHandler * This,
    /* [in] */ HRESULT VECode,
    /* [in] */ VEContext Context,
    /* [in] */ SAFEARRAY * psa);


void __RPC_STUB IVEHandler_VEHandler_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IVEHandler_SetReporterFtn_Proxy( 
    IVEHandler * This,
    /* [in] */ __int64 lFnPtr);


void __RPC_STUB IVEHandler_SetReporterFtn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVEHandler_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\ivalidator.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for ivalidator.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __ivalidator_h__
#define __ivalidator_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IValidator_FWD_DEFINED__
#define __IValidator_FWD_DEFINED__
typedef interface IValidator IValidator;
#endif 	/* __IValidator_FWD_DEFINED__ */


#ifndef __ICLRValidator_FWD_DEFINED__
#define __ICLRValidator_FWD_DEFINED__
typedef interface ICLRValidator ICLRValidator;
#endif 	/* __ICLRValidator_FWD_DEFINED__ */


/* header files for imported files */
#include "ivehandler.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_ivalidator_0000 */
/* [local] */ 




enum ValidatorFlags
    {	VALIDATOR_EXTRA_VERBOSE	= 0x1,
	VALIDATOR_SHOW_SOURCE_LINES	= 0x2,
	VALIDATOR_CHECK_ILONLY	= 0x4,
	VALIDATOR_CHECK_PEFORMAT_ONLY	= 0x8,
	VALIDATOR_NOCHECK_PEFORMAT	= 0x10
    } ;


extern RPC_IF_HANDLE __MIDL_itf_ivalidator_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_ivalidator_0000_v0_0_s_ifspec;

#ifndef __IValidator_INTERFACE_DEFINED__
#define __IValidator_INTERFACE_DEFINED__

/* interface IValidator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IValidator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63DF8730-DC81-4062-84A2-1FF943F59FAC")
    IValidator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Validate( 
            /* [in] */ IVEHandler *veh,
            /* [in] */ IUnknown *pAppDomain,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ LPWSTR fileName,
            /* [size_is][in] */ BYTE *pe,
            /* [in] */ unsigned long ulSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatEventInfo( 
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ SAFEARRAY * psa) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IValidatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IValidator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IValidator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IValidator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Validate )( 
            IValidator * This,
            /* [in] */ IVEHandler *veh,
            /* [in] */ IUnknown *pAppDomain,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ LPWSTR fileName,
            /* [size_is][in] */ BYTE *pe,
            /* [in] */ unsigned long ulSize);
        
        HRESULT ( STDMETHODCALLTYPE *FormatEventInfo )( 
            IValidator * This,
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ SAFEARRAY * psa);
        
        END_INTERFACE
    } IValidatorVtbl;

    interface IValidator
    {
        CONST_VTBL struct IValidatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IValidator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IValidator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IValidator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IValidator_Validate(This,veh,pAppDomain,ulFlags,ulMaxError,token,fileName,pe,ulSize)	\
    (This)->lpVtbl -> Validate(This,veh,pAppDomain,ulFlags,ulMaxError,token,fileName,pe,ulSize)

#define IValidator_FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa)	\
    (This)->lpVtbl -> FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IValidator_Validate_Proxy( 
    IValidator * This,
    /* [in] */ IVEHandler *veh,
    /* [in] */ IUnknown *pAppDomain,
    /* [in] */ unsigned long ulFlags,
    /* [in] */ unsigned long ulMaxError,
    /* [in] */ unsigned long token,
    /* [in] */ LPWSTR fileName,
    /* [size_is][in] */ BYTE *pe,
    /* [in] */ unsigned long ulSize);


void __RPC_STUB IValidator_Validate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IValidator_FormatEventInfo_Proxy( 
    IValidator * This,
    /* [in] */ HRESULT hVECode,
    /* [in] */ VEContext Context,
    /* [out][in] */ LPWSTR msg,
    /* [in] */ unsigned long ulMaxLength,
    /* [in] */ SAFEARRAY * psa);


void __RPC_STUB IValidator_FormatEventInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IValidator_INTERFACE_DEFINED__ */


#ifndef __ICLRValidator_INTERFACE_DEFINED__
#define __ICLRValidator_INTERFACE_DEFINED__

/* interface ICLRValidator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRValidator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("63DF8730-DC81-4062-84A2-1FF943F59FDD")
    ICLRValidator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Validate( 
            /* [in] */ IVEHandler *veh,
            /* [in] */ unsigned long ulAppDomainId,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ LPWSTR fileName,
            /* [size_is][in] */ BYTE *pe,
            /* [in] */ unsigned long ulSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatEventInfo( 
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ SAFEARRAY * psa) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRValidatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRValidator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRValidator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRValidator * This);
        
        HRESULT ( STDMETHODCALLTYPE *Validate )( 
            ICLRValidator * This,
            /* [in] */ IVEHandler *veh,
            /* [in] */ unsigned long ulAppDomainId,
            /* [in] */ unsigned long ulFlags,
            /* [in] */ unsigned long ulMaxError,
            /* [in] */ unsigned long token,
            /* [in] */ LPWSTR fileName,
            /* [size_is][in] */ BYTE *pe,
            /* [in] */ unsigned long ulSize);
        
        HRESULT ( STDMETHODCALLTYPE *FormatEventInfo )( 
            ICLRValidator * This,
            /* [in] */ HRESULT hVECode,
            /* [in] */ VEContext Context,
            /* [out][in] */ LPWSTR msg,
            /* [in] */ unsigned long ulMaxLength,
            /* [in] */ SAFEARRAY * psa);
        
        END_INTERFACE
    } ICLRValidatorVtbl;

    interface ICLRValidator
    {
        CONST_VTBL struct ICLRValidatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRValidator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRValidator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRValidator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRValidator_Validate(This,veh,ulAppDomainId,ulFlags,ulMaxError,token,fileName,pe,ulSize)	\
    (This)->lpVtbl -> Validate(This,veh,ulAppDomainId,ulFlags,ulMaxError,token,fileName,pe,ulSize)

#define ICLRValidator_FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa)	\
    (This)->lpVtbl -> FormatEventInfo(This,hVECode,Context,msg,ulMaxLength,psa)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRValidator_Validate_Proxy( 
    ICLRValidator * This,
    /* [in] */ IVEHandler *veh,
    /* [in] */ unsigned long ulAppDomainId,
    /* [in] */ unsigned long ulFlags,
    /* [in] */ unsigned long ulMaxError,
    /* [in] */ unsigned long token,
    /* [in] */ LPWSTR fileName,
    /* [size_is][in] */ BYTE *pe,
    /* [in] */ unsigned long ulSize);


void __RPC_STUB ICLRValidator_Validate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRValidator_FormatEventInfo_Proxy( 
    ICLRValidator * This,
    /* [in] */ HRESULT hVECode,
    /* [in] */ VEContext Context,
    /* [out][in] */ LPWSTR msg,
    /* [in] */ unsigned long ulMaxLength,
    /* [in] */ SAFEARRAY * psa);


void __RPC_STUB ICLRValidator_FormatEventInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRValidator_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  LPSAFEARRAY_UserSize(     unsigned long *, unsigned long            , LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserMarshal(  unsigned long *, unsigned char *, LPSAFEARRAY * ); 
unsigned char * __RPC_USER  LPSAFEARRAY_UserUnmarshal(unsigned long *, unsigned char *, LPSAFEARRAY * ); 
void                      __RPC_USER  LPSAFEARRAY_UserFree(     unsigned long *, LPSAFEARRAY * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\sos_stacktrace.h ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--== 
/* ---------------------------------------------------------------------------

   SOS_Stacktrace.h

   API exported from SOS.DLL for retrieving managed stack traces.
   This extension function is called through the Windows Debugger extension
   interfaces (dbgeng.h).

   Additional functions exported from SOS are documented here as well.

Notes:

HRESULT CALLBACK _EFN_StackTrace(
    PDEBUG_CLIENT Client,
    WCHAR wszTextOut[],
    UINT *puiTextLength,
    LPVOID pTransitionContexts,
    UINT *puiTransitionContextCount,
    UINT uiSizeOfContext);

uiSizeOfContext must be either sizeof(SimpleContext) or sizeof(CONTEXT) for the 
architecture (x86, IA64, x64).

if wszTextOut is NULL and *puiTextLength is non-NULL, the function will return 
the necessary string length in *puiTextLength.

If wszTextOut is non-NULL, the function will fill wszTextOut up to the point 
given by *puiTextLength, returning success if there was enough room in the 
buffer or E_OUTOFMEMORY if the buffer wasn't long enough.

The transition portion of the function will be completely ignored if 
pTransitionContexts and puiTransitionContextCount are both NULL. Some callers
would just like text output of the function names.

If pTransitionContexts is NULL and puiTransitionContextCount is non NULL, the 
function will return the necessary number of context entries in 
*puiTransitionContextCount.

If pTransitionContexts is non NULL, the function will treat it as an array of 
structures of length *puiTransitionContextCount. The structure size is given 
by uiSizeOfContext, and must be the size of SimpleContext or CONTEXT for the 
architecture.

wszTextOut will be written in the following format:

"<ModuleName>!<Function Name>[+<offset in hex>]
...
(TRANSITION)
..."

if the offset in hex is 0, no offset will be written (this matches KB output).

If there is no managed code on the thread currently in context, 
SOS_E_NOMANAGEDCODE will be returned. 
   ------------------------------------------------------------------------ */
#ifndef __STACKTRACE_H
#define __STACKTRACE_H
#include <windows.h>
#include <winerror.h>

#ifndef FACILITY_SOS
#define FACILITY_SOS            0xa0
#endif

#ifndef EMAKEHR
#define EMAKEHR(val)            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_SOS, val)
#endif

// Custom Error returns
#define SOS_E_NOMANAGEDCODE                EMAKEHR(0x1000)     // No managed code on the stack

// Flags
//
// Turn on SOS_STACKTRACE_SHOWADDRESSES to see EBP ESP in front of each 
// module!functionname line. By default this is off.
#define SOS_STACKTRACE_SHOWADDRESSES        0x00000001

struct StackTrace_SimpleContext
{
    ULONG64 StackOffset; // esp on x86
    ULONG64 FrameOffset; // ebp
    ULONG64 InstructionOffset; // eip
};

HRESULT CALLBACK _EFN_StackTrace(
    PDEBUG_CLIENT Client,
    WCHAR wszTextOut[],
    size_t *puiTextLength,
    LPVOID pTransitionContexts,
    size_t *puiTransitionContextCount,
    size_t uiSizeOfContext,
    DWORD Flags);

/* ---------------------------------------------------------------------------

    Additional functions are exported from SOS, and are useful
    for debugging tasks with managed object pointers.
    
   ------------------------------------------------------------------------ */
   
// _EFN_GetManagedExcepStack - given a managed exception object address, returns a string
//                             version of the stack trace contained inside.
// 
// StackObjAddr - a managed object pointer, must be derived from System.Exception
// szStackString - the string returned (out parameter)
// cbString - number of characters available in the string buffer. 
// 
// The output will be truncated of cbString is not long enough for the full stack trace.
HRESULT _EFN_GetManagedExcepStack(
    PDEBUG_CLIENT Client,
    ULONG64 StackObjAddr,
    __out_ecount(cbString) PSTR szStackString,
    ULONG cbString
    );

// _EFN_GetManagedObjectName - given a managed object pointer, return the type name
//
// objAddr - a managed object pointer
// szName - a buffer to be filled with the full type name
// cbName - the number of characters available in the buffer
//
HRESULT _EFN_GetManagedObjectName(
    PDEBUG_CLIENT Client,
    ULONG64 objAddr,
    __out_ecount(cbName) PSTR szName,
    ULONG cbName
    );

// _EFN_GetManagedObjectFieldInfo - given an object pointer and a field name, returns
//                                  the offset to the field from the start of the object,
//                                  and the field's value.
//
// objAddr - a managed object pointer
// szFieldName - the field name you are interested in
// pValue - the field value is written here. This parameter can be NULL.
// pOffset - the offset from objAddr to the field. This parameter can be NULL.
//
// At least one of pValue and pOffset must be non-NULL.
HRESULT _EFN_GetManagedObjectFieldInfo(
    PDEBUG_CLIENT Client,
    ULONG64 objAddr,
    __out_ecount (mdNameLen) PSTR szFieldName,
    PULONG64 pValue,
    PULONG pOffset
    );

#endif // __STACKTRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\StrongName.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#ifndef __STRONG_NAME_H
#define __STRONG_NAME_H

// ===========================================================================
// File: StrongName.h
// 
// Wrappers for signing and hashing functions needed to implement strong names
// ===========================================================================


#include <windows.h>
#include <wincrypt.h>
#include <ole2.h>

#include <corerror.h>


#ifdef __cplusplus
extern "C"{
#endif 


// Public key blob binary format.
typedef struct {
    unsigned int SigAlgID;       // (ALG_ID) signature algorithm used to create the signature
    unsigned int HashAlgID;      // (ALG_ID) hash algorithm used to create the signature
    ULONG        cbPublicKey;    // length of the key in bytes
    BYTE         PublicKey[1];   // variable length byte array containing the key value in format output by CryptoAPI
} PublicKeyBlob;


// Location in the registry (under HKLM) that strong name configuration info is
// stored.
#define SN_CONFIG_KEY               "Software\\Microsoft\\StrongName"
#define SN_CONFIG_CSP               "CSP"                   // REG_SZ
#define SN_CONFIG_MACHINE_KEYSET    "MachineKeyset"         // REG_DWORD
#define SN_CONFIG_KEYSPEC           "KeySpec"               // REG_DWORD
#define SN_CONFIG_HASH_ALG          "HashAlgorithm"         // REG_DWORD
#define SN_CONFIG_SIGN_ALG          "SignAlgorithm"         // REG_DWORD
#define SN_CONFIG_VERIFICATION      "Verification"          // Registry subkey
#define SN_CONFIG_USERLIST          "UserList"              // REG_MULTI_SZ
#define SN_CONFIG_CACHE_VERIFY      "CacheVerify"           // REG_DWORD

#define SN_CONFIG_KEY_W             L"Software\\Microsoft\\StrongName"
#define SN_CONFIG_CSP_W             L"CSP"                  // REG_SZ
#define SN_CONFIG_MACHINE_KEYSET_W  L"MachineKeyset"        // REG_DWORD
#define SN_CONFIG_KEYSPEC_W         L"KeySpec"              // REG_DWORD
#define SN_CONFIG_HASH_ALG_W        L"HashAlgorithm"        // REG_DWORD
#define SN_CONFIG_SIGN_ALG_W        L"SignAlgorithm"        // REG_DWORD
#define SN_CONFIG_VERIFICATION_W    L"Verification"         // Registry subkey
#define SN_CONFIG_USERLIST_W        L"UserList"             // REG_MULTI_SZ
#define SN_CONFIG_TESTPUBLICKEY_W   L"TestPublicKey"        // REG_SZ
#define SN_CONFIG_CACHE_VERIFY_W    L"CacheVerify"          // REG_DWORD

#define SNAPI BOOLEAN __stdcall
#define SNAPI_(_type) _type __stdcall

// Return last error.
SNAPI_(DWORD) StrongNameErrorInfo(VOID);


// Free buffer allocated by routines below.
SNAPI_(VOID) StrongNameFreeBuffer(BYTE *pbMemory);  // [in] address of memory to free


// Generate a new key pair for strong name use.
SNAPI StrongNameKeyGen(LPCWSTR  wszKeyContainer,    // [in] desired key container name
                       DWORD    dwFlags,            // [in] flags (see below)
                       BYTE   **ppbKeyBlob,         // [out] public/private key blob
                       ULONG   *pcbKeyBlob);

// Generate a new key pair with the specified key size for strong name use.
SNAPI StrongNameKeyGenEx(LPCWSTR  wszKeyContainer,    // [in] desired key container name, must be a non-empty string
                         DWORD    dwFlags,            // [in] flags (see below)
                         DWORD    dwKeySize,          // [in] desired key size.
                         BYTE   **ppbKeyBlob,         // [out] public/private key blob
                         ULONG   *pcbKeyBlob);

// Flags for StrongNameKeyGen.
#define SN_LEAVE_KEY    0x00000001                  // Leave key pair registered with CSP


// Import key pair into a key container.
SNAPI StrongNameKeyInstall(LPCWSTR  wszKeyContainer,// [in] desired key container name, must be a non-empty string
                           BYTE    *pbKeyBlob,      // [in] public/private key pair blob
                           ULONG    cbKeyBlob);


// Delete a key pair.
SNAPI StrongNameKeyDelete(LPCWSTR wszKeyContainer); // [in] desired key container name


// Retrieve the public portion of a key pair.
SNAPI StrongNameGetPublicKey (LPCWSTR   wszKeyContainer,    // [in] desired key container name
                              BYTE     *pbKeyBlob,          // [in] public/private key blob (optional)
                              ULONG     cbKeyBlob,
                              BYTE    **ppbPublicKeyBlob,   // [out] public key blob
                              ULONG    *pcbPublicKeyBlob);


// Hash and sign a manifest.
SNAPI StrongNameSignatureGeneration(LPCWSTR     wszFilePath,        // [in] valid path to the PE file for the assembly
                                    LPCWSTR     wszKeyContainer,    // [in] desired key container name
                                    BYTE       *pbKeyBlob,          // [in] public/private key blob (optional)
                                    ULONG       cbKeyBlob,
                                    BYTE      **ppbSignatureBlob,   // [out] signature blob
                                    ULONG      *pcbSignatureBlob);

SNAPI StrongNameSignatureGenerationEx(LPCWSTR     wszFilePath,        // [in] valid path to the PE file for the assembly
                                      LPCWSTR     wszKeyContainer,    // [in] desired key container name
                                      BYTE       *pbKeyBlob,          // [in] public/private key blob (optional)
                                      ULONG       cbKeyBlob,
                                      BYTE      **ppbSignatureBlob,   // [out] signature blob
                                      ULONG      *pcbSignatureBlob,
                                      DWORD       dwFlags);           // [in] modifer flags; see below

#define SN_SIGN_ALL_FILES   0x00000001      // Rehash all linked modules as well as resigning the manifest
#define SN_TEST_SIGN        0x00000002      // Test sign the assembly

// Create a strong name token from an assembly file.
SNAPI StrongNameTokenFromAssembly(LPCWSTR   wszFilePath,            // [in] valid path to the PE file for the assembly
                                  BYTE    **ppbStrongNameToken,     // [out] strong name token 
                                  ULONG    *pcbStrongNameToken);

// Create a strong name token from an assembly file and additionally return the full public key.
SNAPI StrongNameTokenFromAssemblyEx(LPCWSTR   wszFilePath,            // [in] valid path to the PE file for the assembly
                                    BYTE    **ppbStrongNameToken,     // [out] strong name token 
                                    ULONG    *pcbStrongNameToken,
                                    BYTE    **ppbPublicKeyBlob,       // [out] public key blob
                                    ULONG    *pcbPublicKeyBlob);

// Create a strong name token from a public key blob.
SNAPI StrongNameTokenFromPublicKey(BYTE    *pbPublicKeyBlob,        // [in] public key blob
                                   ULONG    cbPublicKeyBlob,
                                   BYTE   **ppbStrongNameToken,     // [out] strong name token 
                                   ULONG   *pcbStrongNameToken);


// Verify a strong name/manifest against a public key blob.
SNAPI StrongNameSignatureVerification(LPCWSTR wszFilePath,      // [in] valid path to the PE file for the assembly
                                      DWORD   dwInFlags,        // [in] flags modifying behaviour (see below)
                                      DWORD  *pdwOutFlags);     // [out] additional output info (see below)


// Verify a strong name/manifest against a public key blob.
SNAPI StrongNameSignatureVerificationEx(LPCWSTR     wszFilePath,        // [in] valid path to the PE file for the assembly
                                        BOOLEAN     fForceVerification, // [in] verify even if settings in the registry disable it
                                        BOOLEAN    *pfWasVerified);     // [out] set to false if verify succeeded due to registry settings


// Verify a strong name/manifest against a public key blob when the assembly is
// already memory mapped.
SNAPI StrongNameSignatureVerificationFromImage(BYTE     *pbBase,             // [in] base address of mapped manifest file
                                               DWORD     dwLength,           // [in] length of mapped image in bytes
                                               DWORD     dwInFlags,          // [in] flags modifying behaviour (see below)
                                               DWORD    *pdwOutFlags);       // [out] additional output info (see below)

// Flags for use with the verify routines.
#define SN_INFLAG_FORCE_VER      0x00000001     // verify even if settings in the registry disable it
#define SN_INFLAG_INSTALL        0x00000002     // verification is the first (on entry to the cache)
#define SN_INFLAG_ADMIN_ACCESS   0x00000004     // cache protects assembly from all but admin access
#define SN_INFLAG_USER_ACCESS    0x00000008     // cache protects user's assembly from other users
#define SN_INFLAG_ALL_ACCESS     0x00000010     // cache provides no access restriction guarantees
#define SN_INFLAG_RUNTIME        0x80000000     // internal debugging use only 

#define SN_OUTFLAG_WAS_VERIFIED  0x00000001     // set to false if verify succeeded due to registry settings


// Verify that two assemblies differ only by signature blob.
SNAPI StrongNameCompareAssemblies(LPCWSTR   wszAssembly1,           // [in] file name of first assembly
                                  LPCWSTR   wszAssembly2,           // [in] file name of second assembly
                                  DWORD    *pdwResult);             // [out] result of comparison (see codes below)

#define SN_CMP_DIFFERENT    0   // Assemblies contain different data
#define SN_CMP_IDENTICAL    1   // Assemblies are exactly the same, even signatures
#define SN_CMP_SIGONLY      2   // Assemblies differ only by signature (and checksum etc.)


// Compute the size of buffer needed to hold a hash for a given hash algorithm.
SNAPI StrongNameHashSize(ULONG  ulHashAlg,  // [in] hash algorithm
                         DWORD *pcbSize);   // [out] size of the hash in bytes


// Compute the size that needs to be allocated for a signature in an assembly.
SNAPI StrongNameSignatureSize(BYTE    *pbPublicKeyBlob,    // [in] public key blob
                              ULONG    cbPublicKeyBlob,
                              DWORD   *pcbSize);           // [out] size of the signature in bytes


SNAPI_(DWORD) GetHashFromAssemblyFile(LPCSTR szFilePath, // [IN] location of file to be hashed
                                      unsigned int *piHashAlg, // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                                      BYTE   *pbHash,    // [OUT] hash buffer
                                      DWORD  cchHash,    // [IN]  max size of buffer
                                      DWORD  *pchHash);  // [OUT] length of hash byte array
    
SNAPI_(DWORD) GetHashFromAssemblyFileW(LPCWSTR wszFilePath, // [IN] location of file to be hashed
                                       unsigned int *piHashAlg, // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                                       BYTE   *pbHash,    // [OUT] hash buffer
                                       DWORD  cchHash,    // [IN]  max size of buffer
                                       DWORD  *pchHash);  // [OUT] length of hash byte array
    
SNAPI_(DWORD) GetHashFromFile(LPCSTR szFilePath, // [IN] location of file to be hashed
                              unsigned int *piHashAlg,   // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                              BYTE   *pbHash,    // [OUT] hash buffer
                              DWORD  cchHash,    // [IN]  max size of buffer
                              DWORD  *pchHash);  // [OUT] length of hash byte array
    
SNAPI_(DWORD) GetHashFromFileW(LPCWSTR wszFilePath, // [IN] location of file to be hashed
                               unsigned int *piHashAlg,   // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                               BYTE   *pbHash,    // [OUT] hash buffer
                               DWORD  cchHash,    // [IN]  max size of buffer
                               DWORD  *pchHash);  // [OUT] length of hash byte array
    
SNAPI_(DWORD) GetHashFromHandle(HANDLE hFile,      // [IN] handle of file to be hashed
                                unsigned int *piHashAlg,   // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                                BYTE   *pbHash,    // [OUT] hash buffer
                                DWORD  cchHash,    // [IN]  max size of buffer
                                DWORD  *pchHash);  // [OUT] length of hash byte array

SNAPI_(DWORD) GetHashFromBlob(BYTE   *pbBlob,       // [IN] pointer to memory block to hash
                              DWORD  cchBlob,       // [IN] length of blob
                              unsigned int *piHashAlg,  // [IN/OUT] constant specifying the hash algorithm (set to 0 if you want the default)
                              BYTE   *pbHash,       // [OUT] hash buffer
                              DWORD  cchHash,       // [IN]  max size of buffer
                              DWORD  *pchHash);     // [OUT] length of hash byte array

SNAPI StrongNameGetBlob(LPCWSTR            wszFilePath,         // [in] valid path to the PE file for the assembly
                        BYTE               *pbBlob,             // [in] buffer to fill with blob
                        DWORD              *pcbBlob);           // [in/out] size of buffer/number of bytes put into buffer

SNAPI StrongNameGetBlobFromImage(BYTE      *pbBase,             // [in] base address of mapped manifest file
                                 DWORD     dwLength,            // [in] length of mapped image in bytes
                                 BYTE      *pbBlob,             // [in] buffer to fill with blob
                                 DWORD     *pcbBlob);           // [in/out] size of buffer/number of bytes put into buffer

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\mscoree.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for mscoree.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __mscoree_h__
#define __mscoree_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IObjectHandle_FWD_DEFINED__
#define __IObjectHandle_FWD_DEFINED__
typedef interface IObjectHandle IObjectHandle;
#endif 	/* __IObjectHandle_FWD_DEFINED__ */


#ifndef __IAppDomainBinding_FWD_DEFINED__
#define __IAppDomainBinding_FWD_DEFINED__
typedef interface IAppDomainBinding IAppDomainBinding;
#endif 	/* __IAppDomainBinding_FWD_DEFINED__ */


#ifndef __IGCThreadControl_FWD_DEFINED__
#define __IGCThreadControl_FWD_DEFINED__
typedef interface IGCThreadControl IGCThreadControl;
#endif 	/* __IGCThreadControl_FWD_DEFINED__ */


#ifndef __IGCHostControl_FWD_DEFINED__
#define __IGCHostControl_FWD_DEFINED__
typedef interface IGCHostControl IGCHostControl;
#endif 	/* __IGCHostControl_FWD_DEFINED__ */


#ifndef __ICorThreadpool_FWD_DEFINED__
#define __ICorThreadpool_FWD_DEFINED__
typedef interface ICorThreadpool ICorThreadpool;
#endif 	/* __ICorThreadpool_FWD_DEFINED__ */


#ifndef __IDebuggerThreadControl_FWD_DEFINED__
#define __IDebuggerThreadControl_FWD_DEFINED__
typedef interface IDebuggerThreadControl IDebuggerThreadControl;
#endif 	/* __IDebuggerThreadControl_FWD_DEFINED__ */


#ifndef __IDebuggerInfo_FWD_DEFINED__
#define __IDebuggerInfo_FWD_DEFINED__
typedef interface IDebuggerInfo IDebuggerInfo;
#endif 	/* __IDebuggerInfo_FWD_DEFINED__ */


#ifndef __ICorConfiguration_FWD_DEFINED__
#define __ICorConfiguration_FWD_DEFINED__
typedef interface ICorConfiguration ICorConfiguration;
#endif 	/* __ICorConfiguration_FWD_DEFINED__ */


#ifndef __ICorRuntimeHost_FWD_DEFINED__
#define __ICorRuntimeHost_FWD_DEFINED__
typedef interface ICorRuntimeHost ICorRuntimeHost;
#endif 	/* __ICorRuntimeHost_FWD_DEFINED__ */


#ifndef __ICLRMemoryNotificationCallback_FWD_DEFINED__
#define __ICLRMemoryNotificationCallback_FWD_DEFINED__
typedef interface ICLRMemoryNotificationCallback ICLRMemoryNotificationCallback;
#endif 	/* __ICLRMemoryNotificationCallback_FWD_DEFINED__ */


#ifndef __IHostMalloc_FWD_DEFINED__
#define __IHostMalloc_FWD_DEFINED__
typedef interface IHostMalloc IHostMalloc;
#endif 	/* __IHostMalloc_FWD_DEFINED__ */


#ifndef __IHostMemoryManager_FWD_DEFINED__
#define __IHostMemoryManager_FWD_DEFINED__
typedef interface IHostMemoryManager IHostMemoryManager;
#endif 	/* __IHostMemoryManager_FWD_DEFINED__ */


#ifndef __ICLRTask_FWD_DEFINED__
#define __ICLRTask_FWD_DEFINED__
typedef interface ICLRTask ICLRTask;
#endif 	/* __ICLRTask_FWD_DEFINED__ */


#ifndef __IHostTask_FWD_DEFINED__
#define __IHostTask_FWD_DEFINED__
typedef interface IHostTask IHostTask;
#endif 	/* __IHostTask_FWD_DEFINED__ */


#ifndef __ICLRTaskManager_FWD_DEFINED__
#define __ICLRTaskManager_FWD_DEFINED__
typedef interface ICLRTaskManager ICLRTaskManager;
#endif 	/* __ICLRTaskManager_FWD_DEFINED__ */


#ifndef __IHostTaskManager_FWD_DEFINED__
#define __IHostTaskManager_FWD_DEFINED__
typedef interface IHostTaskManager IHostTaskManager;
#endif 	/* __IHostTaskManager_FWD_DEFINED__ */


#ifndef __IHostThreadpoolManager_FWD_DEFINED__
#define __IHostThreadpoolManager_FWD_DEFINED__
typedef interface IHostThreadpoolManager IHostThreadpoolManager;
#endif 	/* __IHostThreadpoolManager_FWD_DEFINED__ */


#ifndef __ICLRIoCompletionManager_FWD_DEFINED__
#define __ICLRIoCompletionManager_FWD_DEFINED__
typedef interface ICLRIoCompletionManager ICLRIoCompletionManager;
#endif 	/* __ICLRIoCompletionManager_FWD_DEFINED__ */


#ifndef __IHostIoCompletionManager_FWD_DEFINED__
#define __IHostIoCompletionManager_FWD_DEFINED__
typedef interface IHostIoCompletionManager IHostIoCompletionManager;
#endif 	/* __IHostIoCompletionManager_FWD_DEFINED__ */


#ifndef __ICLRDebugManager_FWD_DEFINED__
#define __ICLRDebugManager_FWD_DEFINED__
typedef interface ICLRDebugManager ICLRDebugManager;
#endif 	/* __ICLRDebugManager_FWD_DEFINED__ */


#ifndef __ICLRErrorReportingManager_FWD_DEFINED__
#define __ICLRErrorReportingManager_FWD_DEFINED__
typedef interface ICLRErrorReportingManager ICLRErrorReportingManager;
#endif 	/* __ICLRErrorReportingManager_FWD_DEFINED__ */


#ifndef __IHostCrst_FWD_DEFINED__
#define __IHostCrst_FWD_DEFINED__
typedef interface IHostCrst IHostCrst;
#endif 	/* __IHostCrst_FWD_DEFINED__ */


#ifndef __IHostAutoEvent_FWD_DEFINED__
#define __IHostAutoEvent_FWD_DEFINED__
typedef interface IHostAutoEvent IHostAutoEvent;
#endif 	/* __IHostAutoEvent_FWD_DEFINED__ */


#ifndef __IHostManualEvent_FWD_DEFINED__
#define __IHostManualEvent_FWD_DEFINED__
typedef interface IHostManualEvent IHostManualEvent;
#endif 	/* __IHostManualEvent_FWD_DEFINED__ */


#ifndef __IHostSemaphore_FWD_DEFINED__
#define __IHostSemaphore_FWD_DEFINED__
typedef interface IHostSemaphore IHostSemaphore;
#endif 	/* __IHostSemaphore_FWD_DEFINED__ */


#ifndef __ICLRSyncManager_FWD_DEFINED__
#define __ICLRSyncManager_FWD_DEFINED__
typedef interface ICLRSyncManager ICLRSyncManager;
#endif 	/* __ICLRSyncManager_FWD_DEFINED__ */


#ifndef __IHostSyncManager_FWD_DEFINED__
#define __IHostSyncManager_FWD_DEFINED__
typedef interface IHostSyncManager IHostSyncManager;
#endif 	/* __IHostSyncManager_FWD_DEFINED__ */


#ifndef __ICLRPolicyManager_FWD_DEFINED__
#define __ICLRPolicyManager_FWD_DEFINED__
typedef interface ICLRPolicyManager ICLRPolicyManager;
#endif 	/* __ICLRPolicyManager_FWD_DEFINED__ */


#ifndef __IHostPolicyManager_FWD_DEFINED__
#define __IHostPolicyManager_FWD_DEFINED__
typedef interface IHostPolicyManager IHostPolicyManager;
#endif 	/* __IHostPolicyManager_FWD_DEFINED__ */


#ifndef __IActionOnCLREvent_FWD_DEFINED__
#define __IActionOnCLREvent_FWD_DEFINED__
typedef interface IActionOnCLREvent IActionOnCLREvent;
#endif 	/* __IActionOnCLREvent_FWD_DEFINED__ */


#ifndef __ICLROnEventManager_FWD_DEFINED__
#define __ICLROnEventManager_FWD_DEFINED__
typedef interface ICLROnEventManager ICLROnEventManager;
#endif 	/* __ICLROnEventManager_FWD_DEFINED__ */


#ifndef __IHostGCManager_FWD_DEFINED__
#define __IHostGCManager_FWD_DEFINED__
typedef interface IHostGCManager IHostGCManager;
#endif 	/* __IHostGCManager_FWD_DEFINED__ */


#ifndef __ICLRGCManager_FWD_DEFINED__
#define __ICLRGCManager_FWD_DEFINED__
typedef interface ICLRGCManager ICLRGCManager;
#endif 	/* __ICLRGCManager_FWD_DEFINED__ */


#ifndef __ICLRAssemblyReferenceList_FWD_DEFINED__
#define __ICLRAssemblyReferenceList_FWD_DEFINED__
typedef interface ICLRAssemblyReferenceList ICLRAssemblyReferenceList;
#endif 	/* __ICLRAssemblyReferenceList_FWD_DEFINED__ */


#ifndef __ICLRReferenceAssemblyEnum_FWD_DEFINED__
#define __ICLRReferenceAssemblyEnum_FWD_DEFINED__
typedef interface ICLRReferenceAssemblyEnum ICLRReferenceAssemblyEnum;
#endif 	/* __ICLRReferenceAssemblyEnum_FWD_DEFINED__ */


#ifndef __ICLRProbingAssemblyEnum_FWD_DEFINED__
#define __ICLRProbingAssemblyEnum_FWD_DEFINED__
typedef interface ICLRProbingAssemblyEnum ICLRProbingAssemblyEnum;
#endif 	/* __ICLRProbingAssemblyEnum_FWD_DEFINED__ */


#ifndef __ICLRAssemblyIdentityManager_FWD_DEFINED__
#define __ICLRAssemblyIdentityManager_FWD_DEFINED__
typedef interface ICLRAssemblyIdentityManager ICLRAssemblyIdentityManager;
#endif 	/* __ICLRAssemblyIdentityManager_FWD_DEFINED__ */


#ifndef __ICLRHostBindingPolicyManager_FWD_DEFINED__
#define __ICLRHostBindingPolicyManager_FWD_DEFINED__
typedef interface ICLRHostBindingPolicyManager ICLRHostBindingPolicyManager;
#endif 	/* __ICLRHostBindingPolicyManager_FWD_DEFINED__ */


#ifndef __IHostAssemblyStore_FWD_DEFINED__
#define __IHostAssemblyStore_FWD_DEFINED__
typedef interface IHostAssemblyStore IHostAssemblyStore;
#endif 	/* __IHostAssemblyStore_FWD_DEFINED__ */


#ifndef __IHostAssemblyManager_FWD_DEFINED__
#define __IHostAssemblyManager_FWD_DEFINED__
typedef interface IHostAssemblyManager IHostAssemblyManager;
#endif 	/* __IHostAssemblyManager_FWD_DEFINED__ */


#ifndef __IHostControl_FWD_DEFINED__
#define __IHostControl_FWD_DEFINED__
typedef interface IHostControl IHostControl;
#endif 	/* __IHostControl_FWD_DEFINED__ */


#ifndef __ICLRControl_FWD_DEFINED__
#define __ICLRControl_FWD_DEFINED__
typedef interface ICLRControl ICLRControl;
#endif 	/* __ICLRControl_FWD_DEFINED__ */


#ifndef __ICLRRuntimeHost_FWD_DEFINED__
#define __ICLRRuntimeHost_FWD_DEFINED__
typedef interface ICLRRuntimeHost ICLRRuntimeHost;
#endif 	/* __ICLRRuntimeHost_FWD_DEFINED__ */


#ifndef __ICLRHostProtectionManager_FWD_DEFINED__
#define __ICLRHostProtectionManager_FWD_DEFINED__
typedef interface ICLRHostProtectionManager ICLRHostProtectionManager;
#endif 	/* __ICLRHostProtectionManager_FWD_DEFINED__ */


#ifndef __ITypeName_FWD_DEFINED__
#define __ITypeName_FWD_DEFINED__
typedef interface ITypeName ITypeName;
#endif 	/* __ITypeName_FWD_DEFINED__ */


#ifndef __ITypeNameBuilder_FWD_DEFINED__
#define __ITypeNameBuilder_FWD_DEFINED__
typedef interface ITypeNameBuilder ITypeNameBuilder;
#endif 	/* __ITypeNameBuilder_FWD_DEFINED__ */


#ifndef __ITypeNameFactory_FWD_DEFINED__
#define __ITypeNameFactory_FWD_DEFINED__
typedef interface ITypeNameFactory ITypeNameFactory;
#endif 	/* __ITypeNameFactory_FWD_DEFINED__ */


#ifndef __IApartmentCallback_FWD_DEFINED__
#define __IApartmentCallback_FWD_DEFINED__
typedef interface IApartmentCallback IApartmentCallback;
#endif 	/* __IApartmentCallback_FWD_DEFINED__ */


#ifndef __IManagedObject_FWD_DEFINED__
#define __IManagedObject_FWD_DEFINED__
typedef interface IManagedObject IManagedObject;
#endif 	/* __IManagedObject_FWD_DEFINED__ */


#ifndef __ICatalogServices_FWD_DEFINED__
#define __ICatalogServices_FWD_DEFINED__
typedef interface ICatalogServices ICatalogServices;
#endif 	/* __ICatalogServices_FWD_DEFINED__ */


#ifndef __ComCallUnmarshal_FWD_DEFINED__
#define __ComCallUnmarshal_FWD_DEFINED__

#ifdef __cplusplus
typedef class ComCallUnmarshal ComCallUnmarshal;
#else
typedef struct ComCallUnmarshal ComCallUnmarshal;
#endif /* __cplusplus */

#endif 	/* __ComCallUnmarshal_FWD_DEFINED__ */


#ifndef __CorRuntimeHost_FWD_DEFINED__
#define __CorRuntimeHost_FWD_DEFINED__

#ifdef __cplusplus
typedef class CorRuntimeHost CorRuntimeHost;
#else
typedef struct CorRuntimeHost CorRuntimeHost;
#endif /* __cplusplus */

#endif 	/* __CorRuntimeHost_FWD_DEFINED__ */


#ifndef __CLRRuntimeHost_FWD_DEFINED__
#define __CLRRuntimeHost_FWD_DEFINED__

#ifdef __cplusplus
typedef class CLRRuntimeHost CLRRuntimeHost;
#else
typedef struct CLRRuntimeHost CLRRuntimeHost;
#endif /* __cplusplus */

#endif 	/* __CLRRuntimeHost_FWD_DEFINED__ */


#ifndef __TypeNameFactory_FWD_DEFINED__
#define __TypeNameFactory_FWD_DEFINED__

#ifdef __cplusplus
typedef class TypeNameFactory TypeNameFactory;
#else
typedef struct TypeNameFactory TypeNameFactory;
#endif /* __cplusplus */

#endif 	/* __TypeNameFactory_FWD_DEFINED__ */


#ifndef __IHostSecurityContext_FWD_DEFINED__
#define __IHostSecurityContext_FWD_DEFINED__
typedef interface IHostSecurityContext IHostSecurityContext;
#endif 	/* __IHostSecurityContext_FWD_DEFINED__ */


#ifndef __IHostSecurityManager_FWD_DEFINED__
#define __IHostSecurityManager_FWD_DEFINED__
typedef interface IHostSecurityManager IHostSecurityManager;
#endif 	/* __IHostSecurityManager_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "gchost.h"
#include "ivalidator.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_mscoree_0000 */
/* [local] */ 

#define	CLR_MAJOR_VERSION	( 2 )

#define	CLR_MINOR_VERSION	( 0 )

#define	CLR_BUILD_VERSION	( 50727 )

#define	CLR_ASSEMBLY_MAJOR_VERSION	( 2 )

#define	CLR_ASSEMBLY_MINOR_VERSION	( 0 )

#define	CLR_ASSEMBLY_BUILD_VERSION	( 0 )

EXTERN_GUID(LIBID_mscoree, 0x5477469e,0x83b1,0x11d2,0x8b,0x49,0x00,0xa0,0xc9,0xb7,0xc9,0xc4);
EXTERN_GUID(CLSID_CorRuntimeHost, 0xcb2f6723, 0xab3a, 0x11d2, 0x9c, 0x40, 0x00, 0xc0, 0x4f, 0xa3, 0x0a, 0x3e);
EXTERN_GUID(CLSID_TypeNameFactory, 0xB81FF171, 0x20F3, 0x11d2, 0x8d, 0xcc, 0x00, 0xa0, 0xc9, 0xb0, 0x05, 0x25);
EXTERN_GUID(CLSID_CLRRuntimeHost, 0x90F1A06E, 0x7712, 0x4762, 0x86, 0xB5, 0x7A, 0x5E, 0xBA, 0x6B, 0xDB, 0x02);
EXTERN_GUID(CLSID_ComCallUnmarshal, 0x3F281000,0xE95A,0x11d2,0x88,0x6B,0x00,0xC0,0x4F,0x86,0x9F,0x04);
EXTERN_GUID(IID_IObjectHandle, 0xc460e2b4, 0xe199, 0x412a, 0x84, 0x56, 0x84, 0xdc, 0x3e, 0x48, 0x38, 0xc3);
EXTERN_GUID(IID_IManagedObject, 0xc3fcc19e, 0xa970, 0x11d2, 0x8b, 0x5a, 0x00, 0xa0, 0xc9, 0xb7, 0xc9, 0xc4);
EXTERN_GUID(IID_IApartmentCallback, 0x178e5337, 0x1528, 0x4591, 0xb1, 0xc9, 0x1c, 0x6e, 0x48, 0x46, 0x86, 0xd8);
EXTERN_GUID(IID_ICatalogServices, 0x04c6be1e, 0x1db1, 0x4058, 0xab, 0x7a, 0x70, 0x0c, 0xcc, 0xfb, 0xf2, 0x54);
EXTERN_GUID(IID_ICorRuntimeHost, 0xcb2f6722, 0xab3a, 0x11d2, 0x9c, 0x40, 0x00, 0xc0, 0x4f, 0xa3, 0x0a, 0x3e);
EXTERN_GUID(IID_ICorThreadpool, 0x84680D3A, 0xB2C1, 0x46e8, 0xAC, 0xC2, 0xDB, 0xC0, 0xA3, 0x59, 0x15, 0x9A);
EXTERN_GUID(IID_ICLRDebugManager, 0xdcaec6, 0x2ac0, 0x43a9, 0xac, 0xf9, 0x1e, 0x36, 0xc1, 0x39, 0xb1, 0xd);
EXTERN_GUID(IID_ICLRErrorReportingManager, 0x980d2f1a, 0xbf79, 0x4c08, 0x81, 0x2a, 0xbb, 0x97, 0x78, 0x92, 0x8f, 0x78);
EXTERN_GUID(IID_IHostMemoryNeededCallback, 0x47EB8E57, 0x0846, 0x4546, 0xAF, 0x76, 0x6F, 0x42, 0xFC, 0xFC, 0x26, 0x49);
EXTERN_GUID(IID_IHostMalloc, 0x1831991C, 0xCC53, 0x4A31, 0xB2, 0x18, 0x04, 0xE9, 0x10, 0x44, 0x64, 0x79);
EXTERN_GUID(IID_IHostMemoryManager, 0x7BC698D1, 0xF9E3, 0x4460, 0x9C, 0xDE, 0xD0, 0x42, 0x48, 0xE9, 0xFA, 0x25);
EXTERN_GUID(IID_ICLRTask, 0x28E66A4A, 0x9906, 0x4225, 0xB2, 0x31, 0x91, 0x87, 0xc3, 0xeb, 0x86, 0x11);
EXTERN_GUID(IID_IHostTask, 0xC2275828, 0xC4B1, 0x4B55, 0x82, 0xC9, 0x92, 0x13, 0x5F, 0x74, 0xDF, 0x1A);
EXTERN_GUID(IID_ICLRTaskManager, 0x4862efbe, 0x3ae5, 0x44f8, 0x8F, 0xEB, 0x34, 0x61, 0x90, 0xeE, 0x8A, 0x34);
EXTERN_GUID(IID_IHostTaskManager, 0x997FF24C, 0x43B7, 0x4352, 0x86, 0x67, 0x0D, 0xC0, 0x4F, 0xAF, 0xD3, 0x54);
EXTERN_GUID(IID_IHostThreadpoolManager, 0x983D50E2, 0xCB15, 0x466B, 0x80, 0xFC, 0x84, 0x5D, 0xC6, 0xE8, 0xC5, 0xFD);
EXTERN_GUID(IID_ICLRIoCompletionManager, 0x2D74CE86, 0xB8D6, 0x4C84, 0xB3, 0xA7, 0x97, 0x68, 0x93, 0x3B, 0x3C, 0x12);
EXTERN_GUID(IID_ICLRGCManager, 0x54D9007E, 0xA8E2, 0x4885, 0xB7, 0xBF, 0xF9, 0x98, 0xDE, 0xEE, 0x4F, 0x2A);
EXTERN_GUID(IID_IHostIoCompletionManager, 0x8BDE9D80, 0xEC06, 0x41D6, 0x83, 0xE6, 0x22, 0x58, 0x0E, 0xFF, 0xCC, 0x20);
EXTERN_GUID(IID_IHostSyncManager, 0x234330c7, 0x5f10, 0x4f20, 0x96, 0x15, 0x51, 0x22, 0xda, 0xb7, 0xa0, 0xac);
EXTERN_GUID(IID_IHostCrst, 0x6DF710A6, 0x26A4, 0x4a65, 0x8c, 0xd5, 0x72, 0x37, 0xb8, 0xbd, 0xa8, 0xdc);
EXTERN_GUID(IID_IHostAutoEvent, 0x50B0CFCE, 0x4063, 0x4278, 0x96, 0x73, 0xe5, 0xcb, 0x4e, 0xd0, 0xbd, 0xb8);
EXTERN_GUID(IID_IHostManualEvent, 0x1BF4EC38, 0xAFFE, 0x4fb9, 0x85, 0xa6, 0x52, 0x52, 0x68, 0xf1, 0x5b, 0x54);
EXTERN_GUID(IID_IHostSemaphore, 0x855efd47, 0xcc09, 0x463a, 0xa9, 0x7d, 0x16, 0xac, 0xab, 0x88, 0x26, 0x61);
EXTERN_GUID(IID_ICLRSyncManager, 0x55FF199D, 0xAD21, 0x48f9, 0xa1, 0x6c, 0xf2, 0x4e, 0xbb, 0xb8, 0x72, 0x7d);
EXTERN_GUID(IID_ICLRPolicyManager, 0x7D290010, 0xD781, 0x45da, 0xA6, 0xF8, 0xAA, 0x5D, 0x71, 0x1A, 0x73, 0x0E);
EXTERN_GUID(IID_IHostPolicyManager, 0x7AE49844, 0xB1E3, 0x4683, 0xBA, 0x7C, 0x1E, 0x82, 0x12, 0xEA, 0x3B, 0x79);
EXTERN_GUID(IID_IHostGCManager, 0x5D4EC34E, 0xF248, 0x457B, 0xB6, 0x03, 0x25, 0x5F, 0xAA, 0xBA, 0x0D, 0x21);
EXTERN_GUID(IID_IActionOnCLREvent, 0x607BE24B, 0xD91B, 0x4E28, 0xA2, 0x42, 0x61, 0x87, 0x1C, 0xE5, 0x6E, 0x35);
EXTERN_GUID(IID_ICLROnEventManager, 0x1D0E0132, 0xE64F, 0x493D, 0x92, 0x60, 0x02, 0x5C, 0x0E, 0x32, 0xC1, 0x75);
EXTERN_GUID(IID_ICLRRuntimeHost, 0x90F1A06C, 0x7712, 0x4762, 0x86, 0xB5, 0x7A, 0x5E, 0xBA, 0x6B, 0xDB, 0x02);
EXTERN_GUID(IID_ICLRHostProtectionManager, 0x89f25f5c, 0xceef, 0x43e1, 0x9c, 0xfa, 0xa6, 0x8c, 0xe8, 0x63, 0xaa, 0xac);
EXTERN_GUID(IID_IHostAssemblyStore, 0x7b102a88, 0x3f7f, 0x496d, 0x8f, 0xa2, 0xc3, 0x53, 0x74, 0xe0, 0x1a, 0xf3);
EXTERN_GUID(IID_IHostAssemblyManager, 0x613dabd7, 0x62b2, 0x493e, 0x9e, 0x65, 0xc1, 0xe3, 0x2a, 0x1e, 0x0c, 0x5e);
EXTERN_GUID(IID_IHostSecurityManager, 0x75ad2468, 0xa349, 0x4d02, 0xa7, 0x64, 0x76, 0xa6, 0x8a, 0xee, 0x0c, 0x4f);
EXTERN_GUID(IID_IHostSecurityContext, 0x7e573ce4, 0x343, 0x4423, 0x98, 0xd7, 0x63, 0x18, 0x34, 0x8a, 0x1d, 0x3c);
EXTERN_GUID(IID_ICLRAssemblyIdentityManager, 0x15f0a9da, 0x3ff6, 0x4393, 0x9d, 0xa9, 0xfd, 0xfd, 0x28, 0x4e, 0x69, 0x72);
EXTERN_GUID(IID_ITypeName, 0xB81FF171, 0x20F3, 0x11d2, 0x8d, 0xcc, 0x00, 0xa0, 0xc9, 0xb0, 0x05, 0x22);
EXTERN_GUID(IID_ICLRAssemblyReferenceList, 0x1b2c9750, 0x2e66, 0x4bda, 0x8b, 0x44, 0x0a, 0x64, 0x2c, 0x5c, 0xd7, 0x33);
EXTERN_GUID(IID_ICLRReferenceAssemblyEnum, 0xd509cb5d, 0xcf32, 0x4876, 0xae, 0x61, 0x67, 0x77, 0x0c, 0xf9, 0x19, 0x73);
EXTERN_GUID(IID_ICLRProbingAssemblyEnum, 0xd0c5fb1f, 0x416b, 0x4f97, 0x81, 0xf4, 0x7a, 0xc7, 0xdc, 0x24, 0xdd, 0x5d);
EXTERN_GUID(IID_ICLRHostBindingPolicyManager, 0x4b3545e7, 0x1856, 0x48c9, 0xa8, 0xba, 0x24, 0xb2, 0x1a, 0x75, 0x3c, 0x09);
EXTERN_GUID(IID_ITypeNameBuilder, 0xB81FF171, 0x20F3, 0x11d2, 0x8d, 0xcc, 0x00, 0xa0, 0xc9, 0xb0, 0x05, 0x23);
EXTERN_GUID(IID_ITypeNameFactory, 0xB81FF171, 0x20F3, 0x11d2, 0x8d, 0xcc, 0x00, 0xa0, 0xc9, 0xb0, 0x05, 0x21);
STDAPI GetCORSystemDirectory(LPWSTR pbuffer, DWORD  cchBuffer, DWORD* dwLength);
STDAPI GetCORVersion(LPWSTR pbBuffer, DWORD cchBuffer, DWORD* dwLength);
STDAPI GetFileVersion(LPCWSTR szFilename, LPWSTR szBuffer, DWORD cchBuffer, DWORD* dwLength);
STDAPI GetCORRequiredVersion(LPWSTR pbuffer, DWORD cchBuffer, DWORD* dwLength);
STDAPI GetRequestedRuntimeInfo(LPCWSTR pExe, LPCWSTR pwszVersion, LPCWSTR pConfigurationFile, DWORD startupFlags, DWORD runtimeInfoFlags, LPWSTR pDirectory, DWORD dwDirectory, DWORD *dwDirectoryLength, LPWSTR pVersion, DWORD cchBuffer, DWORD* dwlength);
STDAPI GetRequestedRuntimeVersion(LPWSTR pExe, LPWSTR pVersion, DWORD cchBuffer, DWORD* dwLength);
STDAPI CorBindToRuntimeHost(LPCWSTR pwszVersion, LPCWSTR pwszBuildFlavor, LPCWSTR pwszHostConfigFile, VOID* pReserved, DWORD startupFlags, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI CorBindToRuntimeEx(LPCWSTR pwszVersion, LPCWSTR pwszBuildFlavor, DWORD startupFlags, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI CorBindToRuntimeByCfg(IStream* pCfgStream, DWORD reserved, DWORD startupFlags, REFCLSID rclsid,REFIID riid, LPVOID FAR* ppv);
STDAPI CorBindToRuntime(LPCWSTR pwszVersion, LPCWSTR pwszBuildFlavor, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI CorBindToCurrentRuntime(LPCWSTR pwszFileName, REFCLSID rclsid, REFIID riid, LPVOID FAR *ppv);
STDAPI ClrCreateManagedInstance(LPCWSTR pTypeName, REFIID riid, void **ppObject);
void STDMETHODCALLTYPE CorMarkThreadInThreadPool();
STDAPI RunDll32ShimW(HWND hwnd, HINSTANCE hinst, LPCWSTR lpszCmdLine, int nCmdShow);
STDAPI LoadLibraryShim(LPCWSTR szDllName, LPCWSTR szVersion, LPVOID pvReserved, HMODULE *phModDll);
STDAPI CallFunctionShim(LPCWSTR szDllName, LPCSTR szFunctionName, LPVOID lpvArgument1, LPVOID lpvArgument2, LPCWSTR szVersion, LPVOID pvReserved);
STDAPI GetRealProcAddress(LPCSTR pwszProcName, VOID** ppv);
void STDMETHODCALLTYPE CorExitProcess(int exitCode);
STDAPI LoadStringRC(UINT iResouceID, LPWSTR szBuffer, int iMax, int bQuiet);
STDAPI LoadStringRCEx(LCID lcid, UINT iResouceID, LPWSTR szBuffer, int iMax, int bQuiet, int *pcwchUsed);
typedef HRESULT (__stdcall *FLockClrVersionCallback) ();
STDAPI LockClrVersion(FLockClrVersionCallback hostCallback,FLockClrVersionCallback *pBeginHostSetup,FLockClrVersionCallback *pEndHostSetup);
STDAPI CreateDebuggingInterfaceFromVersion(int iDebuggerVersion, LPCWSTR szDebuggeeVersion, IUnknown ** ppCordb);
STDAPI GetVersionFromProcess(HANDLE hProcess, LPWSTR pVersion, DWORD cchBuffer, DWORD* dwLength);
typedef /* [public] */ 
enum __MIDL___MIDL_itf_mscoree_0000_0001
    {	HOST_TYPE_DEFAULT	= 0,
	HOST_TYPE_APPLAUNCH	= 0x1,
	HOST_TYPE_CORFLAG	= 0x2
    } 	HOST_TYPE;

STDAPI CorLaunchApplication(HOST_TYPE dwClickOnceHost, LPCWSTR pwzAppFullName, DWORD dwManifestPaths, LPCWSTR* ppwzManifestPaths, DWORD dwActivationData, LPCWSTR* ppwzActivationData, LPPROCESS_INFORMATION lpProcessInformation);
typedef HRESULT ( __stdcall *FExecuteInAppDomainCallback )( 
    void *cookie);

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mscoree_0000_0002
    {	STARTUP_CONCURRENT_GC	= 0x1,
	STARTUP_LOADER_OPTIMIZATION_MASK	= 0x3 << 1,
	STARTUP_LOADER_OPTIMIZATION_SINGLE_DOMAIN	= 0x1 << 1,
	STARTUP_LOADER_OPTIMIZATION_MULTI_DOMAIN	= 0x2 << 1,
	STARTUP_LOADER_OPTIMIZATION_MULTI_DOMAIN_HOST	= 0x3 << 1,
	STARTUP_LOADER_SAFEMODE	= 0x10,
	STARTUP_LOADER_SETPREFERENCE	= 0x100,
	STARTUP_SERVER_GC	= 0x1000,
	STARTUP_HOARD_GC_VM	= 0x2000,
	STARTUP_SINGLE_VERSION_HOSTING_INTERFACE	= 0x4000,
	STARTUP_LEGACY_IMPERSONATION	= 0x10000,
	STARTUP_DISABLE_COMMITTHREADSTACK	= 0x20000,
	STARTUP_ALWAYSFLOW_IMPERSONATION	= 0x40000
    } 	STARTUP_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mscoree_0000_0003
    {	CLSID_RESOLUTION_DEFAULT	= 0,
	CLSID_RESOLUTION_REGISTERED	= 0x1
    } 	CLSID_RESOLUTION_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mscoree_0000_0004
    {	RUNTIME_INFO_UPGRADE_VERSION	= 0x1,
	RUNTIME_INFO_REQUEST_IA64	= 0x2,
	RUNTIME_INFO_REQUEST_AMD64	= 0x4,
	RUNTIME_INFO_REQUEST_X86	= 0x8,
	RUNTIME_INFO_DONT_RETURN_DIRECTORY	= 0x10,
	RUNTIME_INFO_DONT_RETURN_VERSION	= 0x20,
	RUNTIME_INFO_DONT_SHOW_ERROR_DIALOG	= 0x40
    } 	RUNTIME_INFO_FLAGS;

STDAPI GetRequestedRuntimeVersionForCLSID(REFCLSID rclsid, LPWSTR pVersion, DWORD cchBuffer, DWORD* dwLength, CLSID_RESOLUTION_FLAGS dwResolutionFlags);


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0000_v0_0_s_ifspec;

#ifndef __IObjectHandle_INTERFACE_DEFINED__
#define __IObjectHandle_INTERFACE_DEFINED__

/* interface IObjectHandle */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IObjectHandle;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C460E2B4-E199-412a-8456-84DC3E4838C3")
    IObjectHandle : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Unwrap( 
            /* [retval][out] */ VARIANT *ppv) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObjectHandleVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObjectHandle * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObjectHandle * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObjectHandle * This);
        
        HRESULT ( STDMETHODCALLTYPE *Unwrap )( 
            IObjectHandle * This,
            /* [retval][out] */ VARIANT *ppv);
        
        END_INTERFACE
    } IObjectHandleVtbl;

    interface IObjectHandle
    {
        CONST_VTBL struct IObjectHandleVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObjectHandle_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObjectHandle_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObjectHandle_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObjectHandle_Unwrap(This,ppv)	\
    (This)->lpVtbl -> Unwrap(This,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IObjectHandle_Unwrap_Proxy( 
    IObjectHandle * This,
    /* [retval][out] */ VARIANT *ppv);


void __RPC_STUB IObjectHandle_Unwrap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObjectHandle_INTERFACE_DEFINED__ */


#ifndef __IAppDomainBinding_INTERFACE_DEFINED__
#define __IAppDomainBinding_INTERFACE_DEFINED__

/* interface IAppDomainBinding */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IAppDomainBinding;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5C2B07A7-1E98-11d3-872F-00C04F79ED0D")
    IAppDomainBinding : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnAppDomain( 
            /* [in] */ IUnknown *pAppdomain) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAppDomainBindingVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAppDomainBinding * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAppDomainBinding * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAppDomainBinding * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnAppDomain )( 
            IAppDomainBinding * This,
            /* [in] */ IUnknown *pAppdomain);
        
        END_INTERFACE
    } IAppDomainBindingVtbl;

    interface IAppDomainBinding
    {
        CONST_VTBL struct IAppDomainBindingVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAppDomainBinding_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAppDomainBinding_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAppDomainBinding_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAppDomainBinding_OnAppDomain(This,pAppdomain)	\
    (This)->lpVtbl -> OnAppDomain(This,pAppdomain)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAppDomainBinding_OnAppDomain_Proxy( 
    IAppDomainBinding * This,
    /* [in] */ IUnknown *pAppdomain);


void __RPC_STUB IAppDomainBinding_OnAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAppDomainBinding_INTERFACE_DEFINED__ */


#ifndef __IGCThreadControl_INTERFACE_DEFINED__
#define __IGCThreadControl_INTERFACE_DEFINED__

/* interface IGCThreadControl */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IGCThreadControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F31D1788-C397-4725-87A5-6AF3472C2791")
    IGCThreadControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ThreadIsBlockingForSuspension( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspensionStarting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspensionEnding( 
            DWORD Generation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGCThreadControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGCThreadControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGCThreadControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGCThreadControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadIsBlockingForSuspension )( 
            IGCThreadControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuspensionStarting )( 
            IGCThreadControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuspensionEnding )( 
            IGCThreadControl * This,
            DWORD Generation);
        
        END_INTERFACE
    } IGCThreadControlVtbl;

    interface IGCThreadControl
    {
        CONST_VTBL struct IGCThreadControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGCThreadControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGCThreadControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGCThreadControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGCThreadControl_ThreadIsBlockingForSuspension(This)	\
    (This)->lpVtbl -> ThreadIsBlockingForSuspension(This)

#define IGCThreadControl_SuspensionStarting(This)	\
    (This)->lpVtbl -> SuspensionStarting(This)

#define IGCThreadControl_SuspensionEnding(This,Generation)	\
    (This)->lpVtbl -> SuspensionEnding(This,Generation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGCThreadControl_ThreadIsBlockingForSuspension_Proxy( 
    IGCThreadControl * This);


void __RPC_STUB IGCThreadControl_ThreadIsBlockingForSuspension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCThreadControl_SuspensionStarting_Proxy( 
    IGCThreadControl * This);


void __RPC_STUB IGCThreadControl_SuspensionStarting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IGCThreadControl_SuspensionEnding_Proxy( 
    IGCThreadControl * This,
    DWORD Generation);


void __RPC_STUB IGCThreadControl_SuspensionEnding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGCThreadControl_INTERFACE_DEFINED__ */


#ifndef __IGCHostControl_INTERFACE_DEFINED__
#define __IGCHostControl_INTERFACE_DEFINED__

/* interface IGCHostControl */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IGCHostControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5513D564-8374-4cb9-AED9-0083F4160A1D")
    IGCHostControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RequestVirtualMemLimit( 
            /* [in] */ SIZE_T sztMaxVirtualMemMB,
            /* [out][in] */ SIZE_T *psztNewMaxVirtualMemMB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGCHostControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IGCHostControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IGCHostControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IGCHostControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *RequestVirtualMemLimit )( 
            IGCHostControl * This,
            /* [in] */ SIZE_T sztMaxVirtualMemMB,
            /* [out][in] */ SIZE_T *psztNewMaxVirtualMemMB);
        
        END_INTERFACE
    } IGCHostControlVtbl;

    interface IGCHostControl
    {
        CONST_VTBL struct IGCHostControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGCHostControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGCHostControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGCHostControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGCHostControl_RequestVirtualMemLimit(This,sztMaxVirtualMemMB,psztNewMaxVirtualMemMB)	\
    (This)->lpVtbl -> RequestVirtualMemLimit(This,sztMaxVirtualMemMB,psztNewMaxVirtualMemMB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IGCHostControl_RequestVirtualMemLimit_Proxy( 
    IGCHostControl * This,
    /* [in] */ SIZE_T sztMaxVirtualMemMB,
    /* [out][in] */ SIZE_T *psztNewMaxVirtualMemMB);


void __RPC_STUB IGCHostControl_RequestVirtualMemLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGCHostControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0128 */
/* [local] */ 

#if (_MSC_VER < 1300 || _WIN32_WINNT < 0x0500)
typedef VOID ( __stdcall *WAITORTIMERCALLBACK )( 
    PVOID __MIDL_0011,
    BOOL __MIDL_0012);

#endif // (_MSC_VER < 1300 || _WIN32_WINNT < 0x0500)
#ifdef __midl
typedef DWORD ( __stdcall *LPTHREAD_START_ROUTINE )( 
    LPVOID lpThreadParameter);

typedef VOID ( *LPOVERLAPPED_COMPLETION_ROUTINE )( 
    DWORD dwErrorCode,
    DWORD dwNumberOfBytesTransfered,
    LPVOID lpOverlapped);

#endif // __midl
typedef VOID ( __stdcall *PTLS_CALLBACK_FUNCTION )( 
    PVOID __MIDL_0016);



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0128_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0128_v0_0_s_ifspec;

#ifndef __ICorThreadpool_INTERFACE_DEFINED__
#define __ICorThreadpool_INTERFACE_DEFINED__

/* interface ICorThreadpool */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICorThreadpool;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("84680D3A-B2C1-46e8-ACC2-DBC0A359159A")
    ICorThreadpool : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CorRegisterWaitForSingleObject( 
            /* [in] */ HANDLE *phNewWaitObject,
            /* [in] */ HANDLE hWaitObject,
            /* [in] */ WAITORTIMERCALLBACK Callback,
            /* [in] */ PVOID Context,
            /* [in] */ ULONG timeout,
            /* [in] */ BOOL executeOnlyOnce,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorUnregisterWait( 
            /* [in] */ HANDLE hWaitObject,
            /* [in] */ HANDLE CompletionEvent,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorQueueUserWorkItem( 
            /* [in] */ LPTHREAD_START_ROUTINE Function,
            /* [in] */ PVOID Context,
            /* [in] */ BOOL executeOnlyOnce,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorCreateTimer( 
            /* [in] */ HANDLE *phNewTimer,
            /* [in] */ WAITORTIMERCALLBACK Callback,
            /* [in] */ PVOID Parameter,
            /* [in] */ DWORD DueTime,
            /* [in] */ DWORD Period,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorChangeTimer( 
            /* [in] */ HANDLE Timer,
            /* [in] */ ULONG DueTime,
            /* [in] */ ULONG Period,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorDeleteTimer( 
            /* [in] */ HANDLE Timer,
            /* [in] */ HANDLE CompletionEvent,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorBindIoCompletionCallback( 
            /* [in] */ HANDLE fileHandle,
            /* [in] */ LPOVERLAPPED_COMPLETION_ROUTINE callback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorCallOrQueueUserWorkItem( 
            /* [in] */ LPTHREAD_START_ROUTINE Function,
            /* [in] */ PVOID Context,
            /* [out] */ BOOL *result) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorSetMaxThreads( 
            /* [in] */ DWORD MaxWorkerThreads,
            /* [in] */ DWORD MaxIOCompletionThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorGetMaxThreads( 
            /* [out] */ DWORD *MaxWorkerThreads,
            /* [out] */ DWORD *MaxIOCompletionThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CorGetAvailableThreads( 
            /* [out] */ DWORD *AvailableWorkerThreads,
            /* [out] */ DWORD *AvailableIOCompletionThreads) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorThreadpoolVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorThreadpool * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorThreadpool * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorThreadpool * This);
        
        HRESULT ( STDMETHODCALLTYPE *CorRegisterWaitForSingleObject )( 
            ICorThreadpool * This,
            /* [in] */ HANDLE *phNewWaitObject,
            /* [in] */ HANDLE hWaitObject,
            /* [in] */ WAITORTIMERCALLBACK Callback,
            /* [in] */ PVOID Context,
            /* [in] */ ULONG timeout,
            /* [in] */ BOOL executeOnlyOnce,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorUnregisterWait )( 
            ICorThreadpool * This,
            /* [in] */ HANDLE hWaitObject,
            /* [in] */ HANDLE CompletionEvent,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorQueueUserWorkItem )( 
            ICorThreadpool * This,
            /* [in] */ LPTHREAD_START_ROUTINE Function,
            /* [in] */ PVOID Context,
            /* [in] */ BOOL executeOnlyOnce,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorCreateTimer )( 
            ICorThreadpool * This,
            /* [in] */ HANDLE *phNewTimer,
            /* [in] */ WAITORTIMERCALLBACK Callback,
            /* [in] */ PVOID Parameter,
            /* [in] */ DWORD DueTime,
            /* [in] */ DWORD Period,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorChangeTimer )( 
            ICorThreadpool * This,
            /* [in] */ HANDLE Timer,
            /* [in] */ ULONG DueTime,
            /* [in] */ ULONG Period,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorDeleteTimer )( 
            ICorThreadpool * This,
            /* [in] */ HANDLE Timer,
            /* [in] */ HANDLE CompletionEvent,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorBindIoCompletionCallback )( 
            ICorThreadpool * This,
            /* [in] */ HANDLE fileHandle,
            /* [in] */ LPOVERLAPPED_COMPLETION_ROUTINE callback);
        
        HRESULT ( STDMETHODCALLTYPE *CorCallOrQueueUserWorkItem )( 
            ICorThreadpool * This,
            /* [in] */ LPTHREAD_START_ROUTINE Function,
            /* [in] */ PVOID Context,
            /* [out] */ BOOL *result);
        
        HRESULT ( STDMETHODCALLTYPE *CorSetMaxThreads )( 
            ICorThreadpool * This,
            /* [in] */ DWORD MaxWorkerThreads,
            /* [in] */ DWORD MaxIOCompletionThreads);
        
        HRESULT ( STDMETHODCALLTYPE *CorGetMaxThreads )( 
            ICorThreadpool * This,
            /* [out] */ DWORD *MaxWorkerThreads,
            /* [out] */ DWORD *MaxIOCompletionThreads);
        
        HRESULT ( STDMETHODCALLTYPE *CorGetAvailableThreads )( 
            ICorThreadpool * This,
            /* [out] */ DWORD *AvailableWorkerThreads,
            /* [out] */ DWORD *AvailableIOCompletionThreads);
        
        END_INTERFACE
    } ICorThreadpoolVtbl;

    interface ICorThreadpool
    {
        CONST_VTBL struct ICorThreadpoolVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorThreadpool_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorThreadpool_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorThreadpool_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorThreadpool_CorRegisterWaitForSingleObject(This,phNewWaitObject,hWaitObject,Callback,Context,timeout,executeOnlyOnce,result)	\
    (This)->lpVtbl -> CorRegisterWaitForSingleObject(This,phNewWaitObject,hWaitObject,Callback,Context,timeout,executeOnlyOnce,result)

#define ICorThreadpool_CorUnregisterWait(This,hWaitObject,CompletionEvent,result)	\
    (This)->lpVtbl -> CorUnregisterWait(This,hWaitObject,CompletionEvent,result)

#define ICorThreadpool_CorQueueUserWorkItem(This,Function,Context,executeOnlyOnce,result)	\
    (This)->lpVtbl -> CorQueueUserWorkItem(This,Function,Context,executeOnlyOnce,result)

#define ICorThreadpool_CorCreateTimer(This,phNewTimer,Callback,Parameter,DueTime,Period,result)	\
    (This)->lpVtbl -> CorCreateTimer(This,phNewTimer,Callback,Parameter,DueTime,Period,result)

#define ICorThreadpool_CorChangeTimer(This,Timer,DueTime,Period,result)	\
    (This)->lpVtbl -> CorChangeTimer(This,Timer,DueTime,Period,result)

#define ICorThreadpool_CorDeleteTimer(This,Timer,CompletionEvent,result)	\
    (This)->lpVtbl -> CorDeleteTimer(This,Timer,CompletionEvent,result)

#define ICorThreadpool_CorBindIoCompletionCallback(This,fileHandle,callback)	\
    (This)->lpVtbl -> CorBindIoCompletionCallback(This,fileHandle,callback)

#define ICorThreadpool_CorCallOrQueueUserWorkItem(This,Function,Context,result)	\
    (This)->lpVtbl -> CorCallOrQueueUserWorkItem(This,Function,Context,result)

#define ICorThreadpool_CorSetMaxThreads(This,MaxWorkerThreads,MaxIOCompletionThreads)	\
    (This)->lpVtbl -> CorSetMaxThreads(This,MaxWorkerThreads,MaxIOCompletionThreads)

#define ICorThreadpool_CorGetMaxThreads(This,MaxWorkerThreads,MaxIOCompletionThreads)	\
    (This)->lpVtbl -> CorGetMaxThreads(This,MaxWorkerThreads,MaxIOCompletionThreads)

#define ICorThreadpool_CorGetAvailableThreads(This,AvailableWorkerThreads,AvailableIOCompletionThreads)	\
    (This)->lpVtbl -> CorGetAvailableThreads(This,AvailableWorkerThreads,AvailableIOCompletionThreads)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorThreadpool_CorRegisterWaitForSingleObject_Proxy( 
    ICorThreadpool * This,
    /* [in] */ HANDLE *phNewWaitObject,
    /* [in] */ HANDLE hWaitObject,
    /* [in] */ WAITORTIMERCALLBACK Callback,
    /* [in] */ PVOID Context,
    /* [in] */ ULONG timeout,
    /* [in] */ BOOL executeOnlyOnce,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorRegisterWaitForSingleObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorUnregisterWait_Proxy( 
    ICorThreadpool * This,
    /* [in] */ HANDLE hWaitObject,
    /* [in] */ HANDLE CompletionEvent,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorUnregisterWait_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorQueueUserWorkItem_Proxy( 
    ICorThreadpool * This,
    /* [in] */ LPTHREAD_START_ROUTINE Function,
    /* [in] */ PVOID Context,
    /* [in] */ BOOL executeOnlyOnce,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorQueueUserWorkItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorCreateTimer_Proxy( 
    ICorThreadpool * This,
    /* [in] */ HANDLE *phNewTimer,
    /* [in] */ WAITORTIMERCALLBACK Callback,
    /* [in] */ PVOID Parameter,
    /* [in] */ DWORD DueTime,
    /* [in] */ DWORD Period,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorCreateTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorChangeTimer_Proxy( 
    ICorThreadpool * This,
    /* [in] */ HANDLE Timer,
    /* [in] */ ULONG DueTime,
    /* [in] */ ULONG Period,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorChangeTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorDeleteTimer_Proxy( 
    ICorThreadpool * This,
    /* [in] */ HANDLE Timer,
    /* [in] */ HANDLE CompletionEvent,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorDeleteTimer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorBindIoCompletionCallback_Proxy( 
    ICorThreadpool * This,
    /* [in] */ HANDLE fileHandle,
    /* [in] */ LPOVERLAPPED_COMPLETION_ROUTINE callback);


void __RPC_STUB ICorThreadpool_CorBindIoCompletionCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorCallOrQueueUserWorkItem_Proxy( 
    ICorThreadpool * This,
    /* [in] */ LPTHREAD_START_ROUTINE Function,
    /* [in] */ PVOID Context,
    /* [out] */ BOOL *result);


void __RPC_STUB ICorThreadpool_CorCallOrQueueUserWorkItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorSetMaxThreads_Proxy( 
    ICorThreadpool * This,
    /* [in] */ DWORD MaxWorkerThreads,
    /* [in] */ DWORD MaxIOCompletionThreads);


void __RPC_STUB ICorThreadpool_CorSetMaxThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorGetMaxThreads_Proxy( 
    ICorThreadpool * This,
    /* [out] */ DWORD *MaxWorkerThreads,
    /* [out] */ DWORD *MaxIOCompletionThreads);


void __RPC_STUB ICorThreadpool_CorGetMaxThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorThreadpool_CorGetAvailableThreads_Proxy( 
    ICorThreadpool * This,
    /* [out] */ DWORD *AvailableWorkerThreads,
    /* [out] */ DWORD *AvailableIOCompletionThreads);


void __RPC_STUB ICorThreadpool_CorGetAvailableThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorThreadpool_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0129 */
/* [local] */ 

EXTERN_GUID(IID_IDebuggerThreadControl, 0x23d86786, 0x0bb5, 0x4774, 0x8f, 0xb5, 0xe3, 0x52, 0x2a, 0xdd, 0x62, 0x46);


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0129_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0129_v0_0_s_ifspec;

#ifndef __IDebuggerThreadControl_INTERFACE_DEFINED__
#define __IDebuggerThreadControl_INTERFACE_DEFINED__

/* interface IDebuggerThreadControl */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IDebuggerThreadControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("23D86786-0BB5-4774-8FB5-E3522ADD6246")
    IDebuggerThreadControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ThreadIsBlockingForDebugger( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseAllRuntimeThreads( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartBlockingForDebugger( 
            DWORD dwUnused) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebuggerThreadControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebuggerThreadControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebuggerThreadControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebuggerThreadControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadIsBlockingForDebugger )( 
            IDebuggerThreadControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseAllRuntimeThreads )( 
            IDebuggerThreadControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartBlockingForDebugger )( 
            IDebuggerThreadControl * This,
            DWORD dwUnused);
        
        END_INTERFACE
    } IDebuggerThreadControlVtbl;

    interface IDebuggerThreadControl
    {
        CONST_VTBL struct IDebuggerThreadControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebuggerThreadControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebuggerThreadControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebuggerThreadControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebuggerThreadControl_ThreadIsBlockingForDebugger(This)	\
    (This)->lpVtbl -> ThreadIsBlockingForDebugger(This)

#define IDebuggerThreadControl_ReleaseAllRuntimeThreads(This)	\
    (This)->lpVtbl -> ReleaseAllRuntimeThreads(This)

#define IDebuggerThreadControl_StartBlockingForDebugger(This,dwUnused)	\
    (This)->lpVtbl -> StartBlockingForDebugger(This,dwUnused)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebuggerThreadControl_ThreadIsBlockingForDebugger_Proxy( 
    IDebuggerThreadControl * This);


void __RPC_STUB IDebuggerThreadControl_ThreadIsBlockingForDebugger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebuggerThreadControl_ReleaseAllRuntimeThreads_Proxy( 
    IDebuggerThreadControl * This);


void __RPC_STUB IDebuggerThreadControl_ReleaseAllRuntimeThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebuggerThreadControl_StartBlockingForDebugger_Proxy( 
    IDebuggerThreadControl * This,
    DWORD dwUnused);


void __RPC_STUB IDebuggerThreadControl_StartBlockingForDebugger_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebuggerThreadControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0130 */
/* [local] */ 

EXTERN_GUID(IID_IDebuggerInfo, 0xbf24142d, 0xa47d, 0x4d24, 0xa6, 0x6d, 0x8c, 0x21, 0x41, 0x94, 0x4e, 0x44);


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0130_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0130_v0_0_s_ifspec;

#ifndef __IDebuggerInfo_INTERFACE_DEFINED__
#define __IDebuggerInfo_INTERFACE_DEFINED__

/* interface IDebuggerInfo */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IDebuggerInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BF24142D-A47D-4d24-A66D-8C2141944E44")
    IDebuggerInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsDebuggerAttached( 
            /* [out] */ BOOL *pbAttached) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebuggerInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDebuggerInfo * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDebuggerInfo * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDebuggerInfo * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsDebuggerAttached )( 
            IDebuggerInfo * This,
            /* [out] */ BOOL *pbAttached);
        
        END_INTERFACE
    } IDebuggerInfoVtbl;

    interface IDebuggerInfo
    {
        CONST_VTBL struct IDebuggerInfoVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebuggerInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebuggerInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebuggerInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebuggerInfo_IsDebuggerAttached(This,pbAttached)	\
    (This)->lpVtbl -> IsDebuggerAttached(This,pbAttached)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebuggerInfo_IsDebuggerAttached_Proxy( 
    IDebuggerInfo * This,
    /* [out] */ BOOL *pbAttached);


void __RPC_STUB IDebuggerInfo_IsDebuggerAttached_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebuggerInfo_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0131 */
/* [local] */ 

EXTERN_GUID(IID_ICorConfiguration, 0x5c2b07a5, 0x1e98, 0x11d3, 0x87, 0x2f, 0x00, 0xc0, 0x4f, 0x79, 0xed, 0x0d);


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0131_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0131_v0_0_s_ifspec;

#ifndef __ICorConfiguration_INTERFACE_DEFINED__
#define __ICorConfiguration_INTERFACE_DEFINED__

/* interface ICorConfiguration */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICorConfiguration;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5C2B07A5-1E98-11d3-872F-00C04F79ED0D")
    ICorConfiguration : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetGCThreadControl( 
            /* [in] */ IGCThreadControl *pGCThreadControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGCHostControl( 
            /* [in] */ IGCHostControl *pGCHostControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDebuggerThreadControl( 
            /* [in] */ IDebuggerThreadControl *pDebuggerThreadControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddDebuggerSpecialThread( 
            /* [in] */ DWORD dwSpecialThreadId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorConfigurationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorConfiguration * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorConfiguration * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorConfiguration * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetGCThreadControl )( 
            ICorConfiguration * This,
            /* [in] */ IGCThreadControl *pGCThreadControl);
        
        HRESULT ( STDMETHODCALLTYPE *SetGCHostControl )( 
            ICorConfiguration * This,
            /* [in] */ IGCHostControl *pGCHostControl);
        
        HRESULT ( STDMETHODCALLTYPE *SetDebuggerThreadControl )( 
            ICorConfiguration * This,
            /* [in] */ IDebuggerThreadControl *pDebuggerThreadControl);
        
        HRESULT ( STDMETHODCALLTYPE *AddDebuggerSpecialThread )( 
            ICorConfiguration * This,
            /* [in] */ DWORD dwSpecialThreadId);
        
        END_INTERFACE
    } ICorConfigurationVtbl;

    interface ICorConfiguration
    {
        CONST_VTBL struct ICorConfigurationVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorConfiguration_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorConfiguration_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorConfiguration_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorConfiguration_SetGCThreadControl(This,pGCThreadControl)	\
    (This)->lpVtbl -> SetGCThreadControl(This,pGCThreadControl)

#define ICorConfiguration_SetGCHostControl(This,pGCHostControl)	\
    (This)->lpVtbl -> SetGCHostControl(This,pGCHostControl)

#define ICorConfiguration_SetDebuggerThreadControl(This,pDebuggerThreadControl)	\
    (This)->lpVtbl -> SetDebuggerThreadControl(This,pDebuggerThreadControl)

#define ICorConfiguration_AddDebuggerSpecialThread(This,dwSpecialThreadId)	\
    (This)->lpVtbl -> AddDebuggerSpecialThread(This,dwSpecialThreadId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorConfiguration_SetGCThreadControl_Proxy( 
    ICorConfiguration * This,
    /* [in] */ IGCThreadControl *pGCThreadControl);


void __RPC_STUB ICorConfiguration_SetGCThreadControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorConfiguration_SetGCHostControl_Proxy( 
    ICorConfiguration * This,
    /* [in] */ IGCHostControl *pGCHostControl);


void __RPC_STUB ICorConfiguration_SetGCHostControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorConfiguration_SetDebuggerThreadControl_Proxy( 
    ICorConfiguration * This,
    /* [in] */ IDebuggerThreadControl *pDebuggerThreadControl);


void __RPC_STUB ICorConfiguration_SetDebuggerThreadControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorConfiguration_AddDebuggerSpecialThread_Proxy( 
    ICorConfiguration * This,
    /* [in] */ DWORD dwSpecialThreadId);


void __RPC_STUB ICorConfiguration_AddDebuggerSpecialThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorConfiguration_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0132 */
/* [local] */ 

typedef void *HDOMAINENUM;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0132_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0132_v0_0_s_ifspec;

#ifndef __ICorRuntimeHost_INTERFACE_DEFINED__
#define __ICorRuntimeHost_INTERFACE_DEFINED__

/* interface ICorRuntimeHost */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICorRuntimeHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CB2F6722-AB3A-11d2-9C40-00C04FA30A3E")
    ICorRuntimeHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateLogicalThreadState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteLogicalThreadState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchInLogicalThreadState( 
            /* [in] */ DWORD *pFiberCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchOutLogicalThreadState( 
            /* [out] */ DWORD **pFiberCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LocksHeldByLogicalThread( 
            /* [out] */ DWORD *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapFile( 
            /* [in] */ HANDLE hFile,
            /* [out] */ HMODULE *hMapAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfiguration( 
            /* [out] */ ICorConfiguration **pConfiguration) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDomain( 
            /* [in] */ LPCWSTR pwzFriendlyName,
            /* [in] */ IUnknown *pIdentityArray,
            /* [out] */ IUnknown **pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultDomain( 
            /* [out] */ IUnknown **pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumDomains( 
            /* [out] */ HDOMAINENUM *hEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NextDomain( 
            /* [in] */ HDOMAINENUM hEnum,
            /* [out] */ IUnknown **pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseEnum( 
            /* [in] */ HDOMAINENUM hEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDomainEx( 
            /* [in] */ LPCWSTR pwzFriendlyName,
            /* [in] */ IUnknown *pSetup,
            /* [in] */ IUnknown *pEvidence,
            /* [out] */ IUnknown **pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateDomainSetup( 
            /* [out] */ IUnknown **pAppDomainSetup) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEvidence( 
            /* [out] */ IUnknown **pEvidence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadDomain( 
            /* [in] */ IUnknown *pAppDomain) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CurrentDomain( 
            /* [out] */ IUnknown **pAppDomain) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICorRuntimeHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICorRuntimeHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICorRuntimeHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICorRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateLogicalThreadState )( 
            ICorRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteLogicalThreadState )( 
            ICorRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchInLogicalThreadState )( 
            ICorRuntimeHost * This,
            /* [in] */ DWORD *pFiberCookie);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchOutLogicalThreadState )( 
            ICorRuntimeHost * This,
            /* [out] */ DWORD **pFiberCookie);
        
        HRESULT ( STDMETHODCALLTYPE *LocksHeldByLogicalThread )( 
            ICorRuntimeHost * This,
            /* [out] */ DWORD *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *MapFile )( 
            ICorRuntimeHost * This,
            /* [in] */ HANDLE hFile,
            /* [out] */ HMODULE *hMapAddress);
        
        HRESULT ( STDMETHODCALLTYPE *GetConfiguration )( 
            ICorRuntimeHost * This,
            /* [out] */ ICorConfiguration **pConfiguration);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            ICorRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ICorRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDomain )( 
            ICorRuntimeHost * This,
            /* [in] */ LPCWSTR pwzFriendlyName,
            /* [in] */ IUnknown *pIdentityArray,
            /* [out] */ IUnknown **pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultDomain )( 
            ICorRuntimeHost * This,
            /* [out] */ IUnknown **pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *EnumDomains )( 
            ICorRuntimeHost * This,
            /* [out] */ HDOMAINENUM *hEnum);
        
        HRESULT ( STDMETHODCALLTYPE *NextDomain )( 
            ICorRuntimeHost * This,
            /* [in] */ HDOMAINENUM hEnum,
            /* [out] */ IUnknown **pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *CloseEnum )( 
            ICorRuntimeHost * This,
            /* [in] */ HDOMAINENUM hEnum);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDomainEx )( 
            ICorRuntimeHost * This,
            /* [in] */ LPCWSTR pwzFriendlyName,
            /* [in] */ IUnknown *pSetup,
            /* [in] */ IUnknown *pEvidence,
            /* [out] */ IUnknown **pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *CreateDomainSetup )( 
            ICorRuntimeHost * This,
            /* [out] */ IUnknown **pAppDomainSetup);
        
        HRESULT ( STDMETHODCALLTYPE *CreateEvidence )( 
            ICorRuntimeHost * This,
            /* [out] */ IUnknown **pEvidence);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadDomain )( 
            ICorRuntimeHost * This,
            /* [in] */ IUnknown *pAppDomain);
        
        HRESULT ( STDMETHODCALLTYPE *CurrentDomain )( 
            ICorRuntimeHost * This,
            /* [out] */ IUnknown **pAppDomain);
        
        END_INTERFACE
    } ICorRuntimeHostVtbl;

    interface ICorRuntimeHost
    {
        CONST_VTBL struct ICorRuntimeHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICorRuntimeHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICorRuntimeHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICorRuntimeHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICorRuntimeHost_CreateLogicalThreadState(This)	\
    (This)->lpVtbl -> CreateLogicalThreadState(This)

#define ICorRuntimeHost_DeleteLogicalThreadState(This)	\
    (This)->lpVtbl -> DeleteLogicalThreadState(This)

#define ICorRuntimeHost_SwitchInLogicalThreadState(This,pFiberCookie)	\
    (This)->lpVtbl -> SwitchInLogicalThreadState(This,pFiberCookie)

#define ICorRuntimeHost_SwitchOutLogicalThreadState(This,pFiberCookie)	\
    (This)->lpVtbl -> SwitchOutLogicalThreadState(This,pFiberCookie)

#define ICorRuntimeHost_LocksHeldByLogicalThread(This,pCount)	\
    (This)->lpVtbl -> LocksHeldByLogicalThread(This,pCount)

#define ICorRuntimeHost_MapFile(This,hFile,hMapAddress)	\
    (This)->lpVtbl -> MapFile(This,hFile,hMapAddress)

#define ICorRuntimeHost_GetConfiguration(This,pConfiguration)	\
    (This)->lpVtbl -> GetConfiguration(This,pConfiguration)

#define ICorRuntimeHost_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define ICorRuntimeHost_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define ICorRuntimeHost_CreateDomain(This,pwzFriendlyName,pIdentityArray,pAppDomain)	\
    (This)->lpVtbl -> CreateDomain(This,pwzFriendlyName,pIdentityArray,pAppDomain)

#define ICorRuntimeHost_GetDefaultDomain(This,pAppDomain)	\
    (This)->lpVtbl -> GetDefaultDomain(This,pAppDomain)

#define ICorRuntimeHost_EnumDomains(This,hEnum)	\
    (This)->lpVtbl -> EnumDomains(This,hEnum)

#define ICorRuntimeHost_NextDomain(This,hEnum,pAppDomain)	\
    (This)->lpVtbl -> NextDomain(This,hEnum,pAppDomain)

#define ICorRuntimeHost_CloseEnum(This,hEnum)	\
    (This)->lpVtbl -> CloseEnum(This,hEnum)

#define ICorRuntimeHost_CreateDomainEx(This,pwzFriendlyName,pSetup,pEvidence,pAppDomain)	\
    (This)->lpVtbl -> CreateDomainEx(This,pwzFriendlyName,pSetup,pEvidence,pAppDomain)

#define ICorRuntimeHost_CreateDomainSetup(This,pAppDomainSetup)	\
    (This)->lpVtbl -> CreateDomainSetup(This,pAppDomainSetup)

#define ICorRuntimeHost_CreateEvidence(This,pEvidence)	\
    (This)->lpVtbl -> CreateEvidence(This,pEvidence)

#define ICorRuntimeHost_UnloadDomain(This,pAppDomain)	\
    (This)->lpVtbl -> UnloadDomain(This,pAppDomain)

#define ICorRuntimeHost_CurrentDomain(This,pAppDomain)	\
    (This)->lpVtbl -> CurrentDomain(This,pAppDomain)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CreateLogicalThreadState_Proxy( 
    ICorRuntimeHost * This);


void __RPC_STUB ICorRuntimeHost_CreateLogicalThreadState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_DeleteLogicalThreadState_Proxy( 
    ICorRuntimeHost * This);


void __RPC_STUB ICorRuntimeHost_DeleteLogicalThreadState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_SwitchInLogicalThreadState_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ DWORD *pFiberCookie);


void __RPC_STUB ICorRuntimeHost_SwitchInLogicalThreadState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_SwitchOutLogicalThreadState_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ DWORD **pFiberCookie);


void __RPC_STUB ICorRuntimeHost_SwitchOutLogicalThreadState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_LocksHeldByLogicalThread_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ DWORD *pCount);


void __RPC_STUB ICorRuntimeHost_LocksHeldByLogicalThread_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_MapFile_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ HANDLE hFile,
    /* [out] */ HMODULE *hMapAddress);


void __RPC_STUB ICorRuntimeHost_MapFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_GetConfiguration_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ ICorConfiguration **pConfiguration);


void __RPC_STUB ICorRuntimeHost_GetConfiguration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_Start_Proxy( 
    ICorRuntimeHost * This);


void __RPC_STUB ICorRuntimeHost_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_Stop_Proxy( 
    ICorRuntimeHost * This);


void __RPC_STUB ICorRuntimeHost_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CreateDomain_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ LPCWSTR pwzFriendlyName,
    /* [in] */ IUnknown *pIdentityArray,
    /* [out] */ IUnknown **pAppDomain);


void __RPC_STUB ICorRuntimeHost_CreateDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_GetDefaultDomain_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ IUnknown **pAppDomain);


void __RPC_STUB ICorRuntimeHost_GetDefaultDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_EnumDomains_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ HDOMAINENUM *hEnum);


void __RPC_STUB ICorRuntimeHost_EnumDomains_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_NextDomain_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ HDOMAINENUM hEnum,
    /* [out] */ IUnknown **pAppDomain);


void __RPC_STUB ICorRuntimeHost_NextDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CloseEnum_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ HDOMAINENUM hEnum);


void __RPC_STUB ICorRuntimeHost_CloseEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CreateDomainEx_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ LPCWSTR pwzFriendlyName,
    /* [in] */ IUnknown *pSetup,
    /* [in] */ IUnknown *pEvidence,
    /* [out] */ IUnknown **pAppDomain);


void __RPC_STUB ICorRuntimeHost_CreateDomainEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CreateDomainSetup_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ IUnknown **pAppDomainSetup);


void __RPC_STUB ICorRuntimeHost_CreateDomainSetup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CreateEvidence_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ IUnknown **pEvidence);


void __RPC_STUB ICorRuntimeHost_CreateEvidence_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_UnloadDomain_Proxy( 
    ICorRuntimeHost * This,
    /* [in] */ IUnknown *pAppDomain);


void __RPC_STUB ICorRuntimeHost_UnloadDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICorRuntimeHost_CurrentDomain_Proxy( 
    ICorRuntimeHost * This,
    /* [out] */ IUnknown **pAppDomain);


void __RPC_STUB ICorRuntimeHost_CurrentDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICorRuntimeHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0133 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_mscoree_0133_0001
    {	eMemoryAvailableLow	= 1,
	eMemoryAvailableNeutral	= 2,
	eMemoryAvailableHigh	= 3
    } 	EMemoryAvailable;

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_mscoree_0133_0002
    {	eTaskCritical	= 0,
	eAppDomainCritical	= 1,
	eProcessCritical	= 2
    } 	EMemoryCriticalLevel;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mscoree_0133_0003
    {	WAIT_MSGPUMP	= 0x1,
	WAIT_ALERTABLE	= 0x2,
	WAIT_NOTINDEADLOCK	= 0x4
    } 	WAIT_OPTION;

EXTERN_GUID(IID_ICLRMemoryNotificationCallback, 0x47EB8E57, 0x0846, 0x4546, 0xAF, 0x76, 0x6F, 0x42, 0xFC, 0xFC, 0x26, 0x49);


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0133_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0133_v0_0_s_ifspec;

#ifndef __ICLRMemoryNotificationCallback_INTERFACE_DEFINED__
#define __ICLRMemoryNotificationCallback_INTERFACE_DEFINED__

/* interface ICLRMemoryNotificationCallback */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRMemoryNotificationCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("47EB8E57-0846-4546-AF76-6F42FCFC2649")
    ICLRMemoryNotificationCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnMemoryNotification( 
            /* [in] */ EMemoryAvailable eMemoryAvailable) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRMemoryNotificationCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRMemoryNotificationCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRMemoryNotificationCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRMemoryNotificationCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnMemoryNotification )( 
            ICLRMemoryNotificationCallback * This,
            /* [in] */ EMemoryAvailable eMemoryAvailable);
        
        END_INTERFACE
    } ICLRMemoryNotificationCallbackVtbl;

    interface ICLRMemoryNotificationCallback
    {
        CONST_VTBL struct ICLRMemoryNotificationCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRMemoryNotificationCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRMemoryNotificationCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRMemoryNotificationCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRMemoryNotificationCallback_OnMemoryNotification(This,eMemoryAvailable)	\
    (This)->lpVtbl -> OnMemoryNotification(This,eMemoryAvailable)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRMemoryNotificationCallback_OnMemoryNotification_Proxy( 
    ICLRMemoryNotificationCallback * This,
    /* [in] */ EMemoryAvailable eMemoryAvailable);


void __RPC_STUB ICLRMemoryNotificationCallback_OnMemoryNotification_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRMemoryNotificationCallback_INTERFACE_DEFINED__ */


#ifndef __IHostMalloc_INTERFACE_DEFINED__
#define __IHostMalloc_INTERFACE_DEFINED__

/* interface IHostMalloc */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostMalloc;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1831991C-CC53-4A31-B218-04E910446479")
    IHostMalloc : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Alloc( 
            /* [in] */ SIZE_T cbSize,
            /* [in] */ EMemoryCriticalLevel eCriticalLevel,
            /* [out] */ void **ppMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DebugAlloc( 
            /* [in] */ SIZE_T cbSize,
            /* [in] */ EMemoryCriticalLevel eCriticalLevel,
            /* [in] */ char *pszFileName,
            /* [in] */ int iLineNo,
            /* [out] */ void **ppMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Free( 
            /* [in] */ void *pMem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostMallocVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostMalloc * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostMalloc * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostMalloc * This);
        
        HRESULT ( STDMETHODCALLTYPE *Alloc )( 
            IHostMalloc * This,
            /* [in] */ SIZE_T cbSize,
            /* [in] */ EMemoryCriticalLevel eCriticalLevel,
            /* [out] */ void **ppMem);
        
        HRESULT ( STDMETHODCALLTYPE *DebugAlloc )( 
            IHostMalloc * This,
            /* [in] */ SIZE_T cbSize,
            /* [in] */ EMemoryCriticalLevel eCriticalLevel,
            /* [in] */ char *pszFileName,
            /* [in] */ int iLineNo,
            /* [out] */ void **ppMem);
        
        HRESULT ( STDMETHODCALLTYPE *Free )( 
            IHostMalloc * This,
            /* [in] */ void *pMem);
        
        END_INTERFACE
    } IHostMallocVtbl;

    interface IHostMalloc
    {
        CONST_VTBL struct IHostMallocVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostMalloc_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostMalloc_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostMalloc_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostMalloc_Alloc(This,cbSize,eCriticalLevel,ppMem)	\
    (This)->lpVtbl -> Alloc(This,cbSize,eCriticalLevel,ppMem)

#define IHostMalloc_DebugAlloc(This,cbSize,eCriticalLevel,pszFileName,iLineNo,ppMem)	\
    (This)->lpVtbl -> DebugAlloc(This,cbSize,eCriticalLevel,pszFileName,iLineNo,ppMem)

#define IHostMalloc_Free(This,pMem)	\
    (This)->lpVtbl -> Free(This,pMem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostMalloc_Alloc_Proxy( 
    IHostMalloc * This,
    /* [in] */ SIZE_T cbSize,
    /* [in] */ EMemoryCriticalLevel eCriticalLevel,
    /* [out] */ void **ppMem);


void __RPC_STUB IHostMalloc_Alloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostMalloc_DebugAlloc_Proxy( 
    IHostMalloc * This,
    /* [in] */ SIZE_T cbSize,
    /* [in] */ EMemoryCriticalLevel eCriticalLevel,
    /* [in] */ char *pszFileName,
    /* [in] */ int iLineNo,
    /* [out] */ void **ppMem);


void __RPC_STUB IHostMalloc_DebugAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostMalloc_Free_Proxy( 
    IHostMalloc * This,
    /* [in] */ void *pMem);


void __RPC_STUB IHostMalloc_Free_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostMalloc_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0135 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mscoree_0135_0001
    {	MALLOC_THREADSAFE	= 0x1,
	MALLOC_EXECUTABLE	= 0x2
    } 	MALLOC_TYPE;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0135_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0135_v0_0_s_ifspec;

#ifndef __IHostMemoryManager_INTERFACE_DEFINED__
#define __IHostMemoryManager_INTERFACE_DEFINED__

/* interface IHostMemoryManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostMemoryManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7BC698D1-F9E3-4460-9CDE-D04248E9FA25")
    IHostMemoryManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateMalloc( 
            /* [in] */ DWORD dwMallocType,
            /* [out] */ IHostMalloc **ppMalloc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VirtualAlloc( 
            /* [in] */ void *pAddress,
            /* [in] */ SIZE_T dwSize,
            /* [in] */ DWORD flAllocationType,
            /* [in] */ DWORD flProtect,
            /* [in] */ EMemoryCriticalLevel eCriticalLevel,
            /* [out] */ void **ppMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VirtualFree( 
            /* [in] */ LPVOID lpAddress,
            /* [in] */ SIZE_T dwSize,
            /* [in] */ DWORD dwFreeType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VirtualQuery( 
            /* [in] */ void *lpAddress,
            /* [out] */ void *lpBuffer,
            /* [in] */ SIZE_T dwLength,
            /* [out] */ SIZE_T *pResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE VirtualProtect( 
            /* [in] */ void *lpAddress,
            /* [in] */ SIZE_T dwSize,
            /* [in] */ DWORD flNewProtect,
            /* [out] */ DWORD *pflOldProtect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemoryLoad( 
            /* [out] */ DWORD *pMemoryLoad,
            /* [out] */ SIZE_T *pAvailableBytes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterMemoryNotificationCallback( 
            /* [in] */ ICLRMemoryNotificationCallback *pCallback) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NeedsVirtualAddressSpace( 
            /* [in] */ LPVOID startAddress,
            /* [in] */ SIZE_T size) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AcquiredVirtualAddressSpace( 
            /* [in] */ LPVOID startAddress,
            /* [in] */ SIZE_T size) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleasedVirtualAddressSpace( 
            /* [in] */ LPVOID startAddress) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostMemoryManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostMemoryManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostMemoryManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostMemoryManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMalloc )( 
            IHostMemoryManager * This,
            /* [in] */ DWORD dwMallocType,
            /* [out] */ IHostMalloc **ppMalloc);
        
        HRESULT ( STDMETHODCALLTYPE *VirtualAlloc )( 
            IHostMemoryManager * This,
            /* [in] */ void *pAddress,
            /* [in] */ SIZE_T dwSize,
            /* [in] */ DWORD flAllocationType,
            /* [in] */ DWORD flProtect,
            /* [in] */ EMemoryCriticalLevel eCriticalLevel,
            /* [out] */ void **ppMem);
        
        HRESULT ( STDMETHODCALLTYPE *VirtualFree )( 
            IHostMemoryManager * This,
            /* [in] */ LPVOID lpAddress,
            /* [in] */ SIZE_T dwSize,
            /* [in] */ DWORD dwFreeType);
        
        HRESULT ( STDMETHODCALLTYPE *VirtualQuery )( 
            IHostMemoryManager * This,
            /* [in] */ void *lpAddress,
            /* [out] */ void *lpBuffer,
            /* [in] */ SIZE_T dwLength,
            /* [out] */ SIZE_T *pResult);
        
        HRESULT ( STDMETHODCALLTYPE *VirtualProtect )( 
            IHostMemoryManager * This,
            /* [in] */ void *lpAddress,
            /* [in] */ SIZE_T dwSize,
            /* [in] */ DWORD flNewProtect,
            /* [out] */ DWORD *pflOldProtect);
        
        HRESULT ( STDMETHODCALLTYPE *GetMemoryLoad )( 
            IHostMemoryManager * This,
            /* [out] */ DWORD *pMemoryLoad,
            /* [out] */ SIZE_T *pAvailableBytes);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterMemoryNotificationCallback )( 
            IHostMemoryManager * This,
            /* [in] */ ICLRMemoryNotificationCallback *pCallback);
        
        HRESULT ( STDMETHODCALLTYPE *NeedsVirtualAddressSpace )( 
            IHostMemoryManager * This,
            /* [in] */ LPVOID startAddress,
            /* [in] */ SIZE_T size);
        
        HRESULT ( STDMETHODCALLTYPE *AcquiredVirtualAddressSpace )( 
            IHostMemoryManager * This,
            /* [in] */ LPVOID startAddress,
            /* [in] */ SIZE_T size);
        
        HRESULT ( STDMETHODCALLTYPE *ReleasedVirtualAddressSpace )( 
            IHostMemoryManager * This,
            /* [in] */ LPVOID startAddress);
        
        END_INTERFACE
    } IHostMemoryManagerVtbl;

    interface IHostMemoryManager
    {
        CONST_VTBL struct IHostMemoryManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostMemoryManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostMemoryManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostMemoryManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostMemoryManager_CreateMalloc(This,dwMallocType,ppMalloc)	\
    (This)->lpVtbl -> CreateMalloc(This,dwMallocType,ppMalloc)

#define IHostMemoryManager_VirtualAlloc(This,pAddress,dwSize,flAllocationType,flProtect,eCriticalLevel,ppMem)	\
    (This)->lpVtbl -> VirtualAlloc(This,pAddress,dwSize,flAllocationType,flProtect,eCriticalLevel,ppMem)

#define IHostMemoryManager_VirtualFree(This,lpAddress,dwSize,dwFreeType)	\
    (This)->lpVtbl -> VirtualFree(This,lpAddress,dwSize,dwFreeType)

#define IHostMemoryManager_VirtualQuery(This,lpAddress,lpBuffer,dwLength,pResult)	\
    (This)->lpVtbl -> VirtualQuery(This,lpAddress,lpBuffer,dwLength,pResult)

#define IHostMemoryManager_VirtualProtect(This,lpAddress,dwSize,flNewProtect,pflOldProtect)	\
    (This)->lpVtbl -> VirtualProtect(This,lpAddress,dwSize,flNewProtect,pflOldProtect)

#define IHostMemoryManager_GetMemoryLoad(This,pMemoryLoad,pAvailableBytes)	\
    (This)->lpVtbl -> GetMemoryLoad(This,pMemoryLoad,pAvailableBytes)

#define IHostMemoryManager_RegisterMemoryNotificationCallback(This,pCallback)	\
    (This)->lpVtbl -> RegisterMemoryNotificationCallback(This,pCallback)

#define IHostMemoryManager_NeedsVirtualAddressSpace(This,startAddress,size)	\
    (This)->lpVtbl -> NeedsVirtualAddressSpace(This,startAddress,size)

#define IHostMemoryManager_AcquiredVirtualAddressSpace(This,startAddress,size)	\
    (This)->lpVtbl -> AcquiredVirtualAddressSpace(This,startAddress,size)

#define IHostMemoryManager_ReleasedVirtualAddressSpace(This,startAddress)	\
    (This)->lpVtbl -> ReleasedVirtualAddressSpace(This,startAddress)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostMemoryManager_CreateMalloc_Proxy( 
    IHostMemoryManager * This,
    /* [in] */ DWORD dwMallocType,
    /* [out] */ IHostMalloc **ppMalloc);


void __RPC_STUB IHostMemoryManager_CreateMalloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostMemoryManager_VirtualAlloc_Proxy( 
    IHostMemoryManager * This,
    /* [in] */ void *pAddress,
    /* [in] */ SIZE_T dwSize,
    /* [in] */ DWORD flAllocationType,
    /* [in] */ DWORD flProtect,
    /* [in] */ EMemoryCriticalLevel eCriticalLevel,
    /* [out] */ void **ppMem);


void __RPC_STUB IHostMemoryManager_VirtualAlloc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostMemoryManager_VirtualFree_Proxy( 
    IHostMemoryManager * This,
    /* [in] */ LPVOID lpAddress,
    /* [in] */ SIZE_T dwSize,
    /* [in] */ DWORD dwFreeType);


void __RPC_STUB IHostMemoryManager_VirtualFree_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostMemoryManager_VirtualQuery_Proxy( 
    IHostMemoryManager * This,
    /* [in] */ void *lpAddress,
    /* [out] */ void *lpBuffer,
    /* [in] */ SIZE_T dwLength,
    /* [out] */ SIZE_T *pResult);


void __RPC_STUB IHostMemoryManager_VirtualQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostMemoryManager_VirtualProtect_Proxy( 
    IHostMemoryManager * This,
    /* [in] */ void *lpAddress,
    /* [in] */ SIZE_T dwSize,
    /* [in] */ DWORD flNewProtect,
    /* [out] */ DWORD *pflOldProtect);


void __RPC_STUB IHostMemoryManager_VirtualProtect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostMemoryManager_GetMemoryLoad_Proxy( 
    IHostMemoryManager * This,
    /* [out] */ DWORD *pMemoryLoad,
    /* [out] */ SIZE_T *pAvailableBytes);


void __RPC_STUB IHostMemoryManager_GetMemoryLoad_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostMemoryManager_RegisterMemoryNotificationCallback_Proxy( 
    IHostMemoryManager * This,
    /* [in] */ ICLRMemoryNotificationCallback *pCallback);


void __RPC_STUB IHostMemoryManager_RegisterMemoryNotificationCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostMemoryManager_NeedsVirtualAddressSpace_Proxy( 
    IHostMemoryManager * This,
    /* [in] */ LPVOID startAddress,
    /* [in] */ SIZE_T size);


void __RPC_STUB IHostMemoryManager_NeedsVirtualAddressSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostMemoryManager_AcquiredVirtualAddressSpace_Proxy( 
    IHostMemoryManager * This,
    /* [in] */ LPVOID startAddress,
    /* [in] */ SIZE_T size);


void __RPC_STUB IHostMemoryManager_AcquiredVirtualAddressSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostMemoryManager_ReleasedVirtualAddressSpace_Proxy( 
    IHostMemoryManager * This,
    /* [in] */ LPVOID startAddress);


void __RPC_STUB IHostMemoryManager_ReleasedVirtualAddressSpace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostMemoryManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0136 */
/* [local] */ 

typedef UINT64 TASKID;

typedef DWORD CONNID;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0136_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0136_v0_0_s_ifspec;

#ifndef __ICLRTask_INTERFACE_DEFINED__
#define __ICLRTask_INTERFACE_DEFINED__

/* interface ICLRTask */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRTask;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("28E66A4A-9906-4225-B231-9187C3EB8611")
    ICLRTask : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SwitchIn( 
            /* [in] */ HANDLE threadHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchOut( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMemStats( 
            /* [out] */ COR_GC_THREAD_STATS *memUsage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( 
            BOOL fFull) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExitTask( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RudeAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NeedsPriorityScheduling( 
            /* [out] */ BOOL *pbNeedsPriorityScheduling) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE YieldTask( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LocksHeld( 
            /* [out] */ SIZE_T *pLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTaskIdentifier( 
            /* [in] */ TASKID asked) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRTaskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRTask * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRTask * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchIn )( 
            ICLRTask * This,
            /* [in] */ HANDLE threadHandle);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchOut )( 
            ICLRTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMemStats )( 
            ICLRTask * This,
            /* [out] */ COR_GC_THREAD_STATS *memUsage);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            ICLRTask * This,
            BOOL fFull);
        
        HRESULT ( STDMETHODCALLTYPE *ExitTask )( 
            ICLRTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *Abort )( 
            ICLRTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *RudeAbort )( 
            ICLRTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *NeedsPriorityScheduling )( 
            ICLRTask * This,
            /* [out] */ BOOL *pbNeedsPriorityScheduling);
        
        HRESULT ( STDMETHODCALLTYPE *YieldTask )( 
            ICLRTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *LocksHeld )( 
            ICLRTask * This,
            /* [out] */ SIZE_T *pLockCount);
        
        HRESULT ( STDMETHODCALLTYPE *SetTaskIdentifier )( 
            ICLRTask * This,
            /* [in] */ TASKID asked);
        
        END_INTERFACE
    } ICLRTaskVtbl;

    interface ICLRTask
    {
        CONST_VTBL struct ICLRTaskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRTask_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRTask_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRTask_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRTask_SwitchIn(This,threadHandle)	\
    (This)->lpVtbl -> SwitchIn(This,threadHandle)

#define ICLRTask_SwitchOut(This)	\
    (This)->lpVtbl -> SwitchOut(This)

#define ICLRTask_GetMemStats(This,memUsage)	\
    (This)->lpVtbl -> GetMemStats(This,memUsage)

#define ICLRTask_Reset(This,fFull)	\
    (This)->lpVtbl -> Reset(This,fFull)

#define ICLRTask_ExitTask(This)	\
    (This)->lpVtbl -> ExitTask(This)

#define ICLRTask_Abort(This)	\
    (This)->lpVtbl -> Abort(This)

#define ICLRTask_RudeAbort(This)	\
    (This)->lpVtbl -> RudeAbort(This)

#define ICLRTask_NeedsPriorityScheduling(This,pbNeedsPriorityScheduling)	\
    (This)->lpVtbl -> NeedsPriorityScheduling(This,pbNeedsPriorityScheduling)

#define ICLRTask_YieldTask(This)	\
    (This)->lpVtbl -> YieldTask(This)

#define ICLRTask_LocksHeld(This,pLockCount)	\
    (This)->lpVtbl -> LocksHeld(This,pLockCount)

#define ICLRTask_SetTaskIdentifier(This,asked)	\
    (This)->lpVtbl -> SetTaskIdentifier(This,asked)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRTask_SwitchIn_Proxy( 
    ICLRTask * This,
    /* [in] */ HANDLE threadHandle);


void __RPC_STUB ICLRTask_SwitchIn_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTask_SwitchOut_Proxy( 
    ICLRTask * This);


void __RPC_STUB ICLRTask_SwitchOut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTask_GetMemStats_Proxy( 
    ICLRTask * This,
    /* [out] */ COR_GC_THREAD_STATS *memUsage);


void __RPC_STUB ICLRTask_GetMemStats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTask_Reset_Proxy( 
    ICLRTask * This,
    BOOL fFull);


void __RPC_STUB ICLRTask_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTask_ExitTask_Proxy( 
    ICLRTask * This);


void __RPC_STUB ICLRTask_ExitTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTask_Abort_Proxy( 
    ICLRTask * This);


void __RPC_STUB ICLRTask_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTask_RudeAbort_Proxy( 
    ICLRTask * This);


void __RPC_STUB ICLRTask_RudeAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTask_NeedsPriorityScheduling_Proxy( 
    ICLRTask * This,
    /* [out] */ BOOL *pbNeedsPriorityScheduling);


void __RPC_STUB ICLRTask_NeedsPriorityScheduling_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTask_YieldTask_Proxy( 
    ICLRTask * This);


void __RPC_STUB ICLRTask_YieldTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTask_LocksHeld_Proxy( 
    ICLRTask * This,
    /* [out] */ SIZE_T *pLockCount);


void __RPC_STUB ICLRTask_LocksHeld_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTask_SetTaskIdentifier_Proxy( 
    ICLRTask * This,
    /* [in] */ TASKID asked);


void __RPC_STUB ICLRTask_SetTaskIdentifier_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRTask_INTERFACE_DEFINED__ */


#ifndef __IHostTask_INTERFACE_DEFINED__
#define __IHostTask_INTERFACE_DEFINED__

/* interface IHostTask */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostTask;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C2275828-C4B1-4B55-82C9-92135F74DF1A")
    IHostTask : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Alert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Join( 
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ DWORD option) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPriority( 
            /* [in] */ int newPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPriority( 
            /* [out] */ int *pPriority) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCLRTask( 
            /* [in] */ ICLRTask *pCLRTask) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostTaskVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostTask * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostTask * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IHostTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *Alert )( 
            IHostTask * This);
        
        HRESULT ( STDMETHODCALLTYPE *Join )( 
            IHostTask * This,
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ DWORD option);
        
        HRESULT ( STDMETHODCALLTYPE *SetPriority )( 
            IHostTask * This,
            /* [in] */ int newPriority);
        
        HRESULT ( STDMETHODCALLTYPE *GetPriority )( 
            IHostTask * This,
            /* [out] */ int *pPriority);
        
        HRESULT ( STDMETHODCALLTYPE *SetCLRTask )( 
            IHostTask * This,
            /* [in] */ ICLRTask *pCLRTask);
        
        END_INTERFACE
    } IHostTaskVtbl;

    interface IHostTask
    {
        CONST_VTBL struct IHostTaskVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostTask_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostTask_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostTask_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostTask_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IHostTask_Alert(This)	\
    (This)->lpVtbl -> Alert(This)

#define IHostTask_Join(This,dwMilliseconds,option)	\
    (This)->lpVtbl -> Join(This,dwMilliseconds,option)

#define IHostTask_SetPriority(This,newPriority)	\
    (This)->lpVtbl -> SetPriority(This,newPriority)

#define IHostTask_GetPriority(This,pPriority)	\
    (This)->lpVtbl -> GetPriority(This,pPriority)

#define IHostTask_SetCLRTask(This,pCLRTask)	\
    (This)->lpVtbl -> SetCLRTask(This,pCLRTask)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostTask_Start_Proxy( 
    IHostTask * This);


void __RPC_STUB IHostTask_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTask_Alert_Proxy( 
    IHostTask * This);


void __RPC_STUB IHostTask_Alert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTask_Join_Proxy( 
    IHostTask * This,
    /* [in] */ DWORD dwMilliseconds,
    /* [in] */ DWORD option);


void __RPC_STUB IHostTask_Join_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTask_SetPriority_Proxy( 
    IHostTask * This,
    /* [in] */ int newPriority);


void __RPC_STUB IHostTask_SetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTask_GetPriority_Proxy( 
    IHostTask * This,
    /* [out] */ int *pPriority);


void __RPC_STUB IHostTask_GetPriority_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTask_SetCLRTask_Proxy( 
    IHostTask * This,
    /* [in] */ ICLRTask *pCLRTask);


void __RPC_STUB IHostTask_SetCLRTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostTask_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0138 */
/* [local] */ 

typedef 
enum ETaskType
    {	TT_DEBUGGERHELPER	= 0x1,
	TT_GC	= 0x2,
	TT_FINALIZER	= 0x4,
	TT_THREADPOOL_TIMER	= 0x8,
	TT_THREADPOOL_GATE	= 0x10,
	TT_THREADPOOL_WORKER	= 0x20,
	TT_THREADPOOL_IOCOMPLETION	= 0x40,
	TT_ADUNLOAD	= 0x80,
	TT_USER	= 0x100,
	TT_THREADPOOL_WAIT	= 0x200,
	TT_UNKNOWN	= 0x80000000
    } 	ETaskType;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0138_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0138_v0_0_s_ifspec;

#ifndef __ICLRTaskManager_INTERFACE_DEFINED__
#define __ICLRTaskManager_INTERFACE_DEFINED__

/* interface ICLRTaskManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRTaskManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4862efbe-3ae5-44f8-8feb-346190ee8a34")
    ICLRTaskManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateTask( 
            /* [out] */ ICLRTask **pTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentTask( 
            /* [out] */ ICLRTask **pTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUILocale( 
            /* [in] */ LCID lcid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocale( 
            /* [in] */ LCID lcid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentTaskType( 
            /* [out] */ ETaskType *pTaskType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRTaskManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRTaskManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRTaskManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRTaskManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTask )( 
            ICLRTaskManager * This,
            /* [out] */ ICLRTask **pTask);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentTask )( 
            ICLRTaskManager * This,
            /* [out] */ ICLRTask **pTask);
        
        HRESULT ( STDMETHODCALLTYPE *SetUILocale )( 
            ICLRTaskManager * This,
            /* [in] */ LCID lcid);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocale )( 
            ICLRTaskManager * This,
            /* [in] */ LCID lcid);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentTaskType )( 
            ICLRTaskManager * This,
            /* [out] */ ETaskType *pTaskType);
        
        END_INTERFACE
    } ICLRTaskManagerVtbl;

    interface ICLRTaskManager
    {
        CONST_VTBL struct ICLRTaskManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRTaskManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRTaskManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRTaskManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRTaskManager_CreateTask(This,pTask)	\
    (This)->lpVtbl -> CreateTask(This,pTask)

#define ICLRTaskManager_GetCurrentTask(This,pTask)	\
    (This)->lpVtbl -> GetCurrentTask(This,pTask)

#define ICLRTaskManager_SetUILocale(This,lcid)	\
    (This)->lpVtbl -> SetUILocale(This,lcid)

#define ICLRTaskManager_SetLocale(This,lcid)	\
    (This)->lpVtbl -> SetLocale(This,lcid)

#define ICLRTaskManager_GetCurrentTaskType(This,pTaskType)	\
    (This)->lpVtbl -> GetCurrentTaskType(This,pTaskType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRTaskManager_CreateTask_Proxy( 
    ICLRTaskManager * This,
    /* [out] */ ICLRTask **pTask);


void __RPC_STUB ICLRTaskManager_CreateTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTaskManager_GetCurrentTask_Proxy( 
    ICLRTaskManager * This,
    /* [out] */ ICLRTask **pTask);


void __RPC_STUB ICLRTaskManager_GetCurrentTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTaskManager_SetUILocale_Proxy( 
    ICLRTaskManager * This,
    /* [in] */ LCID lcid);


void __RPC_STUB ICLRTaskManager_SetUILocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTaskManager_SetLocale_Proxy( 
    ICLRTaskManager * This,
    /* [in] */ LCID lcid);


void __RPC_STUB ICLRTaskManager_SetLocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRTaskManager_GetCurrentTaskType_Proxy( 
    ICLRTaskManager * This,
    /* [out] */ ETaskType *pTaskType);


void __RPC_STUB ICLRTaskManager_GetCurrentTaskType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRTaskManager_INTERFACE_DEFINED__ */


#ifndef __IHostTaskManager_INTERFACE_DEFINED__
#define __IHostTaskManager_INTERFACE_DEFINED__

/* interface IHostTaskManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostTaskManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("997FF24C-43B7-4352-8667-0DC04FAFD354")
    IHostTaskManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCurrentTask( 
            /* [out] */ IHostTask **pTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateTask( 
            /* [in] */ DWORD dwStackSize,
            /* [in] */ LPTHREAD_START_ROUTINE pStartAddress,
            /* [in] */ PVOID pParameter,
            /* [out] */ IHostTask **ppTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Sleep( 
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ DWORD option) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SwitchToTask( 
            /* [in] */ DWORD option) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUILocale( 
            /* [in] */ LCID lcid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocale( 
            /* [in] */ LCID lcid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CallNeedsHostHook( 
            /* [in] */ SIZE_T target,
            /* [out] */ BOOL *pbCallNeedsHostHook) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LeaveRuntime( 
            /* [in] */ SIZE_T target) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnterRuntime( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReverseLeaveRuntime( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReverseEnterRuntime( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginDelayAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndDelayAbort( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginThreadAffinity( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndThreadAffinity( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStackGuarantee( 
            /* [in] */ ULONG guarantee) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStackGuarantee( 
            /* [out] */ ULONG *pGuarantee) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCLRTaskManager( 
            /* [in] */ ICLRTaskManager *ppManager) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostTaskManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostTaskManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostTaskManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostTaskManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentTask )( 
            IHostTaskManager * This,
            /* [out] */ IHostTask **pTask);
        
        HRESULT ( STDMETHODCALLTYPE *CreateTask )( 
            IHostTaskManager * This,
            /* [in] */ DWORD dwStackSize,
            /* [in] */ LPTHREAD_START_ROUTINE pStartAddress,
            /* [in] */ PVOID pParameter,
            /* [out] */ IHostTask **ppTask);
        
        HRESULT ( STDMETHODCALLTYPE *Sleep )( 
            IHostTaskManager * This,
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ DWORD option);
        
        HRESULT ( STDMETHODCALLTYPE *SwitchToTask )( 
            IHostTaskManager * This,
            /* [in] */ DWORD option);
        
        HRESULT ( STDMETHODCALLTYPE *SetUILocale )( 
            IHostTaskManager * This,
            /* [in] */ LCID lcid);
        
        HRESULT ( STDMETHODCALLTYPE *SetLocale )( 
            IHostTaskManager * This,
            /* [in] */ LCID lcid);
        
        HRESULT ( STDMETHODCALLTYPE *CallNeedsHostHook )( 
            IHostTaskManager * This,
            /* [in] */ SIZE_T target,
            /* [out] */ BOOL *pbCallNeedsHostHook);
        
        HRESULT ( STDMETHODCALLTYPE *LeaveRuntime )( 
            IHostTaskManager * This,
            /* [in] */ SIZE_T target);
        
        HRESULT ( STDMETHODCALLTYPE *EnterRuntime )( 
            IHostTaskManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReverseLeaveRuntime )( 
            IHostTaskManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *ReverseEnterRuntime )( 
            IHostTaskManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginDelayAbort )( 
            IHostTaskManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndDelayAbort )( 
            IHostTaskManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginThreadAffinity )( 
            IHostTaskManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *EndThreadAffinity )( 
            IHostTaskManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetStackGuarantee )( 
            IHostTaskManager * This,
            /* [in] */ ULONG guarantee);
        
        HRESULT ( STDMETHODCALLTYPE *GetStackGuarantee )( 
            IHostTaskManager * This,
            /* [out] */ ULONG *pGuarantee);
        
        HRESULT ( STDMETHODCALLTYPE *SetCLRTaskManager )( 
            IHostTaskManager * This,
            /* [in] */ ICLRTaskManager *ppManager);
        
        END_INTERFACE
    } IHostTaskManagerVtbl;

    interface IHostTaskManager
    {
        CONST_VTBL struct IHostTaskManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostTaskManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostTaskManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostTaskManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostTaskManager_GetCurrentTask(This,pTask)	\
    (This)->lpVtbl -> GetCurrentTask(This,pTask)

#define IHostTaskManager_CreateTask(This,dwStackSize,pStartAddress,pParameter,ppTask)	\
    (This)->lpVtbl -> CreateTask(This,dwStackSize,pStartAddress,pParameter,ppTask)

#define IHostTaskManager_Sleep(This,dwMilliseconds,option)	\
    (This)->lpVtbl -> Sleep(This,dwMilliseconds,option)

#define IHostTaskManager_SwitchToTask(This,option)	\
    (This)->lpVtbl -> SwitchToTask(This,option)

#define IHostTaskManager_SetUILocale(This,lcid)	\
    (This)->lpVtbl -> SetUILocale(This,lcid)

#define IHostTaskManager_SetLocale(This,lcid)	\
    (This)->lpVtbl -> SetLocale(This,lcid)

#define IHostTaskManager_CallNeedsHostHook(This,target,pbCallNeedsHostHook)	\
    (This)->lpVtbl -> CallNeedsHostHook(This,target,pbCallNeedsHostHook)

#define IHostTaskManager_LeaveRuntime(This,target)	\
    (This)->lpVtbl -> LeaveRuntime(This,target)

#define IHostTaskManager_EnterRuntime(This)	\
    (This)->lpVtbl -> EnterRuntime(This)

#define IHostTaskManager_ReverseLeaveRuntime(This)	\
    (This)->lpVtbl -> ReverseLeaveRuntime(This)

#define IHostTaskManager_ReverseEnterRuntime(This)	\
    (This)->lpVtbl -> ReverseEnterRuntime(This)

#define IHostTaskManager_BeginDelayAbort(This)	\
    (This)->lpVtbl -> BeginDelayAbort(This)

#define IHostTaskManager_EndDelayAbort(This)	\
    (This)->lpVtbl -> EndDelayAbort(This)

#define IHostTaskManager_BeginThreadAffinity(This)	\
    (This)->lpVtbl -> BeginThreadAffinity(This)

#define IHostTaskManager_EndThreadAffinity(This)	\
    (This)->lpVtbl -> EndThreadAffinity(This)

#define IHostTaskManager_SetStackGuarantee(This,guarantee)	\
    (This)->lpVtbl -> SetStackGuarantee(This,guarantee)

#define IHostTaskManager_GetStackGuarantee(This,pGuarantee)	\
    (This)->lpVtbl -> GetStackGuarantee(This,pGuarantee)

#define IHostTaskManager_SetCLRTaskManager(This,ppManager)	\
    (This)->lpVtbl -> SetCLRTaskManager(This,ppManager)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostTaskManager_GetCurrentTask_Proxy( 
    IHostTaskManager * This,
    /* [out] */ IHostTask **pTask);


void __RPC_STUB IHostTaskManager_GetCurrentTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_CreateTask_Proxy( 
    IHostTaskManager * This,
    /* [in] */ DWORD dwStackSize,
    /* [in] */ LPTHREAD_START_ROUTINE pStartAddress,
    /* [in] */ PVOID pParameter,
    /* [out] */ IHostTask **ppTask);


void __RPC_STUB IHostTaskManager_CreateTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_Sleep_Proxy( 
    IHostTaskManager * This,
    /* [in] */ DWORD dwMilliseconds,
    /* [in] */ DWORD option);


void __RPC_STUB IHostTaskManager_Sleep_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_SwitchToTask_Proxy( 
    IHostTaskManager * This,
    /* [in] */ DWORD option);


void __RPC_STUB IHostTaskManager_SwitchToTask_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_SetUILocale_Proxy( 
    IHostTaskManager * This,
    /* [in] */ LCID lcid);


void __RPC_STUB IHostTaskManager_SetUILocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_SetLocale_Proxy( 
    IHostTaskManager * This,
    /* [in] */ LCID lcid);


void __RPC_STUB IHostTaskManager_SetLocale_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_CallNeedsHostHook_Proxy( 
    IHostTaskManager * This,
    /* [in] */ SIZE_T target,
    /* [out] */ BOOL *pbCallNeedsHostHook);


void __RPC_STUB IHostTaskManager_CallNeedsHostHook_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_LeaveRuntime_Proxy( 
    IHostTaskManager * This,
    /* [in] */ SIZE_T target);


void __RPC_STUB IHostTaskManager_LeaveRuntime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_EnterRuntime_Proxy( 
    IHostTaskManager * This);


void __RPC_STUB IHostTaskManager_EnterRuntime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_ReverseLeaveRuntime_Proxy( 
    IHostTaskManager * This);


void __RPC_STUB IHostTaskManager_ReverseLeaveRuntime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_ReverseEnterRuntime_Proxy( 
    IHostTaskManager * This);


void __RPC_STUB IHostTaskManager_ReverseEnterRuntime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_BeginDelayAbort_Proxy( 
    IHostTaskManager * This);


void __RPC_STUB IHostTaskManager_BeginDelayAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_EndDelayAbort_Proxy( 
    IHostTaskManager * This);


void __RPC_STUB IHostTaskManager_EndDelayAbort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_BeginThreadAffinity_Proxy( 
    IHostTaskManager * This);


void __RPC_STUB IHostTaskManager_BeginThreadAffinity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_EndThreadAffinity_Proxy( 
    IHostTaskManager * This);


void __RPC_STUB IHostTaskManager_EndThreadAffinity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_SetStackGuarantee_Proxy( 
    IHostTaskManager * This,
    /* [in] */ ULONG guarantee);


void __RPC_STUB IHostTaskManager_SetStackGuarantee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_GetStackGuarantee_Proxy( 
    IHostTaskManager * This,
    /* [out] */ ULONG *pGuarantee);


void __RPC_STUB IHostTaskManager_GetStackGuarantee_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostTaskManager_SetCLRTaskManager_Proxy( 
    IHostTaskManager * This,
    /* [in] */ ICLRTaskManager *ppManager);


void __RPC_STUB IHostTaskManager_SetCLRTaskManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostTaskManager_INTERFACE_DEFINED__ */


#ifndef __IHostThreadpoolManager_INTERFACE_DEFINED__
#define __IHostThreadpoolManager_INTERFACE_DEFINED__

/* interface IHostThreadpoolManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostThreadpoolManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("983D50E2-CB15-466B-80FC-845DC6E8C5FD")
    IHostThreadpoolManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE QueueUserWorkItem( 
            /* [in] */ LPTHREAD_START_ROUTINE Function,
            /* [in] */ PVOID Context,
            /* [in] */ ULONG Flags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxThreads( 
            /* [in] */ DWORD dwMaxWorkerThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxThreads( 
            /* [out] */ DWORD *pdwMaxWorkerThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAvailableThreads( 
            /* [out] */ DWORD *pdwAvailableWorkerThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMinThreads( 
            /* [in] */ DWORD dwMinIOCompletionThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinThreads( 
            /* [out] */ DWORD *pdwMinIOCompletionThreads) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostThreadpoolManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostThreadpoolManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostThreadpoolManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostThreadpoolManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *QueueUserWorkItem )( 
            IHostThreadpoolManager * This,
            /* [in] */ LPTHREAD_START_ROUTINE Function,
            /* [in] */ PVOID Context,
            /* [in] */ ULONG Flags);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxThreads )( 
            IHostThreadpoolManager * This,
            /* [in] */ DWORD dwMaxWorkerThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxThreads )( 
            IHostThreadpoolManager * This,
            /* [out] */ DWORD *pdwMaxWorkerThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableThreads )( 
            IHostThreadpoolManager * This,
            /* [out] */ DWORD *pdwAvailableWorkerThreads);
        
        HRESULT ( STDMETHODCALLTYPE *SetMinThreads )( 
            IHostThreadpoolManager * This,
            /* [in] */ DWORD dwMinIOCompletionThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinThreads )( 
            IHostThreadpoolManager * This,
            /* [out] */ DWORD *pdwMinIOCompletionThreads);
        
        END_INTERFACE
    } IHostThreadpoolManagerVtbl;

    interface IHostThreadpoolManager
    {
        CONST_VTBL struct IHostThreadpoolManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostThreadpoolManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostThreadpoolManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostThreadpoolManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostThreadpoolManager_QueueUserWorkItem(This,Function,Context,Flags)	\
    (This)->lpVtbl -> QueueUserWorkItem(This,Function,Context,Flags)

#define IHostThreadpoolManager_SetMaxThreads(This,dwMaxWorkerThreads)	\
    (This)->lpVtbl -> SetMaxThreads(This,dwMaxWorkerThreads)

#define IHostThreadpoolManager_GetMaxThreads(This,pdwMaxWorkerThreads)	\
    (This)->lpVtbl -> GetMaxThreads(This,pdwMaxWorkerThreads)

#define IHostThreadpoolManager_GetAvailableThreads(This,pdwAvailableWorkerThreads)	\
    (This)->lpVtbl -> GetAvailableThreads(This,pdwAvailableWorkerThreads)

#define IHostThreadpoolManager_SetMinThreads(This,dwMinIOCompletionThreads)	\
    (This)->lpVtbl -> SetMinThreads(This,dwMinIOCompletionThreads)

#define IHostThreadpoolManager_GetMinThreads(This,pdwMinIOCompletionThreads)	\
    (This)->lpVtbl -> GetMinThreads(This,pdwMinIOCompletionThreads)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostThreadpoolManager_QueueUserWorkItem_Proxy( 
    IHostThreadpoolManager * This,
    /* [in] */ LPTHREAD_START_ROUTINE Function,
    /* [in] */ PVOID Context,
    /* [in] */ ULONG Flags);


void __RPC_STUB IHostThreadpoolManager_QueueUserWorkItem_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostThreadpoolManager_SetMaxThreads_Proxy( 
    IHostThreadpoolManager * This,
    /* [in] */ DWORD dwMaxWorkerThreads);


void __RPC_STUB IHostThreadpoolManager_SetMaxThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostThreadpoolManager_GetMaxThreads_Proxy( 
    IHostThreadpoolManager * This,
    /* [out] */ DWORD *pdwMaxWorkerThreads);


void __RPC_STUB IHostThreadpoolManager_GetMaxThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostThreadpoolManager_GetAvailableThreads_Proxy( 
    IHostThreadpoolManager * This,
    /* [out] */ DWORD *pdwAvailableWorkerThreads);


void __RPC_STUB IHostThreadpoolManager_GetAvailableThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostThreadpoolManager_SetMinThreads_Proxy( 
    IHostThreadpoolManager * This,
    /* [in] */ DWORD dwMinIOCompletionThreads);


void __RPC_STUB IHostThreadpoolManager_SetMinThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostThreadpoolManager_GetMinThreads_Proxy( 
    IHostThreadpoolManager * This,
    /* [out] */ DWORD *pdwMinIOCompletionThreads);


void __RPC_STUB IHostThreadpoolManager_GetMinThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostThreadpoolManager_INTERFACE_DEFINED__ */


#ifndef __ICLRIoCompletionManager_INTERFACE_DEFINED__
#define __ICLRIoCompletionManager_INTERFACE_DEFINED__

/* interface ICLRIoCompletionManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRIoCompletionManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("2d74ce86-b8d6-4c84-b3a7-9768933b3c12")
    ICLRIoCompletionManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnComplete( 
            /* [in] */ DWORD dwErrorCode,
            /* [in] */ DWORD NumberOfBytesTransferred,
            /* [in] */ void *pvOverlapped) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRIoCompletionManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRIoCompletionManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRIoCompletionManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRIoCompletionManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnComplete )( 
            ICLRIoCompletionManager * This,
            /* [in] */ DWORD dwErrorCode,
            /* [in] */ DWORD NumberOfBytesTransferred,
            /* [in] */ void *pvOverlapped);
        
        END_INTERFACE
    } ICLRIoCompletionManagerVtbl;

    interface ICLRIoCompletionManager
    {
        CONST_VTBL struct ICLRIoCompletionManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRIoCompletionManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRIoCompletionManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRIoCompletionManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRIoCompletionManager_OnComplete(This,dwErrorCode,NumberOfBytesTransferred,pvOverlapped)	\
    (This)->lpVtbl -> OnComplete(This,dwErrorCode,NumberOfBytesTransferred,pvOverlapped)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRIoCompletionManager_OnComplete_Proxy( 
    ICLRIoCompletionManager * This,
    /* [in] */ DWORD dwErrorCode,
    /* [in] */ DWORD NumberOfBytesTransferred,
    /* [in] */ void *pvOverlapped);


void __RPC_STUB ICLRIoCompletionManager_OnComplete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRIoCompletionManager_INTERFACE_DEFINED__ */


#ifndef __IHostIoCompletionManager_INTERFACE_DEFINED__
#define __IHostIoCompletionManager_INTERFACE_DEFINED__

/* interface IHostIoCompletionManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostIoCompletionManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8bde9d80-ec06-41d6-83e6-22580effcc20")
    IHostIoCompletionManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CreateIoCompletionPort( 
            /* [out] */ HANDLE *phPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseIoCompletionPort( 
            /* [in] */ HANDLE hPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxThreads( 
            /* [in] */ DWORD dwMaxIOCompletionThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxThreads( 
            /* [out] */ DWORD *pdwMaxIOCompletionThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAvailableThreads( 
            /* [out] */ DWORD *pdwAvailableIOCompletionThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHostOverlappedSize( 
            /* [out] */ DWORD *pcbSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCLRIoCompletionManager( 
            /* [in] */ ICLRIoCompletionManager *pManager) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InitializeHostOverlapped( 
            /* [in] */ void *pvOverlapped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Bind( 
            /* [in] */ HANDLE hPort,
            /* [in] */ HANDLE hHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMinThreads( 
            /* [in] */ DWORD dwMinIOCompletionThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinThreads( 
            /* [out] */ DWORD *pdwMinIOCompletionThreads) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostIoCompletionManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostIoCompletionManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostIoCompletionManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostIoCompletionManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *CreateIoCompletionPort )( 
            IHostIoCompletionManager * This,
            /* [out] */ HANDLE *phPort);
        
        HRESULT ( STDMETHODCALLTYPE *CloseIoCompletionPort )( 
            IHostIoCompletionManager * This,
            /* [in] */ HANDLE hPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetMaxThreads )( 
            IHostIoCompletionManager * This,
            /* [in] */ DWORD dwMaxIOCompletionThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetMaxThreads )( 
            IHostIoCompletionManager * This,
            /* [out] */ DWORD *pdwMaxIOCompletionThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetAvailableThreads )( 
            IHostIoCompletionManager * This,
            /* [out] */ DWORD *pdwAvailableIOCompletionThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostOverlappedSize )( 
            IHostIoCompletionManager * This,
            /* [out] */ DWORD *pcbSize);
        
        HRESULT ( STDMETHODCALLTYPE *SetCLRIoCompletionManager )( 
            IHostIoCompletionManager * This,
            /* [in] */ ICLRIoCompletionManager *pManager);
        
        HRESULT ( STDMETHODCALLTYPE *InitializeHostOverlapped )( 
            IHostIoCompletionManager * This,
            /* [in] */ void *pvOverlapped);
        
        HRESULT ( STDMETHODCALLTYPE *Bind )( 
            IHostIoCompletionManager * This,
            /* [in] */ HANDLE hPort,
            /* [in] */ HANDLE hHandle);
        
        HRESULT ( STDMETHODCALLTYPE *SetMinThreads )( 
            IHostIoCompletionManager * This,
            /* [in] */ DWORD dwMinIOCompletionThreads);
        
        HRESULT ( STDMETHODCALLTYPE *GetMinThreads )( 
            IHostIoCompletionManager * This,
            /* [out] */ DWORD *pdwMinIOCompletionThreads);
        
        END_INTERFACE
    } IHostIoCompletionManagerVtbl;

    interface IHostIoCompletionManager
    {
        CONST_VTBL struct IHostIoCompletionManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostIoCompletionManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostIoCompletionManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostIoCompletionManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostIoCompletionManager_CreateIoCompletionPort(This,phPort)	\
    (This)->lpVtbl -> CreateIoCompletionPort(This,phPort)

#define IHostIoCompletionManager_CloseIoCompletionPort(This,hPort)	\
    (This)->lpVtbl -> CloseIoCompletionPort(This,hPort)

#define IHostIoCompletionManager_SetMaxThreads(This,dwMaxIOCompletionThreads)	\
    (This)->lpVtbl -> SetMaxThreads(This,dwMaxIOCompletionThreads)

#define IHostIoCompletionManager_GetMaxThreads(This,pdwMaxIOCompletionThreads)	\
    (This)->lpVtbl -> GetMaxThreads(This,pdwMaxIOCompletionThreads)

#define IHostIoCompletionManager_GetAvailableThreads(This,pdwAvailableIOCompletionThreads)	\
    (This)->lpVtbl -> GetAvailableThreads(This,pdwAvailableIOCompletionThreads)

#define IHostIoCompletionManager_GetHostOverlappedSize(This,pcbSize)	\
    (This)->lpVtbl -> GetHostOverlappedSize(This,pcbSize)

#define IHostIoCompletionManager_SetCLRIoCompletionManager(This,pManager)	\
    (This)->lpVtbl -> SetCLRIoCompletionManager(This,pManager)

#define IHostIoCompletionManager_InitializeHostOverlapped(This,pvOverlapped)	\
    (This)->lpVtbl -> InitializeHostOverlapped(This,pvOverlapped)

#define IHostIoCompletionManager_Bind(This,hPort,hHandle)	\
    (This)->lpVtbl -> Bind(This,hPort,hHandle)

#define IHostIoCompletionManager_SetMinThreads(This,dwMinIOCompletionThreads)	\
    (This)->lpVtbl -> SetMinThreads(This,dwMinIOCompletionThreads)

#define IHostIoCompletionManager_GetMinThreads(This,pdwMinIOCompletionThreads)	\
    (This)->lpVtbl -> GetMinThreads(This,pdwMinIOCompletionThreads)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostIoCompletionManager_CreateIoCompletionPort_Proxy( 
    IHostIoCompletionManager * This,
    /* [out] */ HANDLE *phPort);


void __RPC_STUB IHostIoCompletionManager_CreateIoCompletionPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostIoCompletionManager_CloseIoCompletionPort_Proxy( 
    IHostIoCompletionManager * This,
    /* [in] */ HANDLE hPort);


void __RPC_STUB IHostIoCompletionManager_CloseIoCompletionPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostIoCompletionManager_SetMaxThreads_Proxy( 
    IHostIoCompletionManager * This,
    /* [in] */ DWORD dwMaxIOCompletionThreads);


void __RPC_STUB IHostIoCompletionManager_SetMaxThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostIoCompletionManager_GetMaxThreads_Proxy( 
    IHostIoCompletionManager * This,
    /* [out] */ DWORD *pdwMaxIOCompletionThreads);


void __RPC_STUB IHostIoCompletionManager_GetMaxThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostIoCompletionManager_GetAvailableThreads_Proxy( 
    IHostIoCompletionManager * This,
    /* [out] */ DWORD *pdwAvailableIOCompletionThreads);


void __RPC_STUB IHostIoCompletionManager_GetAvailableThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostIoCompletionManager_GetHostOverlappedSize_Proxy( 
    IHostIoCompletionManager * This,
    /* [out] */ DWORD *pcbSize);


void __RPC_STUB IHostIoCompletionManager_GetHostOverlappedSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostIoCompletionManager_SetCLRIoCompletionManager_Proxy( 
    IHostIoCompletionManager * This,
    /* [in] */ ICLRIoCompletionManager *pManager);


void __RPC_STUB IHostIoCompletionManager_SetCLRIoCompletionManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostIoCompletionManager_InitializeHostOverlapped_Proxy( 
    IHostIoCompletionManager * This,
    /* [in] */ void *pvOverlapped);


void __RPC_STUB IHostIoCompletionManager_InitializeHostOverlapped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostIoCompletionManager_Bind_Proxy( 
    IHostIoCompletionManager * This,
    /* [in] */ HANDLE hPort,
    /* [in] */ HANDLE hHandle);


void __RPC_STUB IHostIoCompletionManager_Bind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostIoCompletionManager_SetMinThreads_Proxy( 
    IHostIoCompletionManager * This,
    /* [in] */ DWORD dwMinIOCompletionThreads);


void __RPC_STUB IHostIoCompletionManager_SetMinThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostIoCompletionManager_GetMinThreads_Proxy( 
    IHostIoCompletionManager * This,
    /* [out] */ DWORD *pdwMinIOCompletionThreads);


void __RPC_STUB IHostIoCompletionManager_GetMinThreads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostIoCompletionManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0143 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_mscoree_0143_0001
    {	eSymbolReadingNever	= 0,
	eSymbolReadingAlways	= 1,
	eSymbolReadingFullTrustOnly	= 2
    } 	ESymbolReadingPolicy;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0143_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0143_v0_0_s_ifspec;

#ifndef __ICLRDebugManager_INTERFACE_DEFINED__
#define __ICLRDebugManager_INTERFACE_DEFINED__

/* interface ICLRDebugManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRDebugManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("00DCAEC6-2AC0-43a9-ACF9-1E36C139B10D")
    ICLRDebugManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE BeginConnection( 
            /* [in] */ CONNID dwConnectionId,
            /* [string][in] */ wchar_t *szConnectionName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConnectionTasks( 
            /* [in] */ CONNID id,
            /* [in] */ DWORD dwCount,
            /* [size_is][in] */ ICLRTask **ppCLRTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndConnection( 
            /* [in] */ CONNID dwConnectionId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetDacl( 
            /* [in] */ PACL pacl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDacl( 
            /* [out] */ PACL *pacl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDebuggerAttached( 
            /* [out] */ BOOL *pbAttached) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSymbolReadingPolicy( 
            /* [in] */ ESymbolReadingPolicy policy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDebugManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDebugManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDebugManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDebugManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *BeginConnection )( 
            ICLRDebugManager * This,
            /* [in] */ CONNID dwConnectionId,
            /* [string][in] */ wchar_t *szConnectionName);
        
        HRESULT ( STDMETHODCALLTYPE *SetConnectionTasks )( 
            ICLRDebugManager * This,
            /* [in] */ CONNID id,
            /* [in] */ DWORD dwCount,
            /* [size_is][in] */ ICLRTask **ppCLRTask);
        
        HRESULT ( STDMETHODCALLTYPE *EndConnection )( 
            ICLRDebugManager * This,
            /* [in] */ CONNID dwConnectionId);
        
        HRESULT ( STDMETHODCALLTYPE *SetDacl )( 
            ICLRDebugManager * This,
            /* [in] */ PACL pacl);
        
        HRESULT ( STDMETHODCALLTYPE *GetDacl )( 
            ICLRDebugManager * This,
            /* [out] */ PACL *pacl);
        
        HRESULT ( STDMETHODCALLTYPE *IsDebuggerAttached )( 
            ICLRDebugManager * This,
            /* [out] */ BOOL *pbAttached);
        
        HRESULT ( STDMETHODCALLTYPE *SetSymbolReadingPolicy )( 
            ICLRDebugManager * This,
            /* [in] */ ESymbolReadingPolicy policy);
        
        END_INTERFACE
    } ICLRDebugManagerVtbl;

    interface ICLRDebugManager
    {
        CONST_VTBL struct ICLRDebugManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDebugManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDebugManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDebugManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDebugManager_BeginConnection(This,dwConnectionId,szConnectionName)	\
    (This)->lpVtbl -> BeginConnection(This,dwConnectionId,szConnectionName)

#define ICLRDebugManager_SetConnectionTasks(This,id,dwCount,ppCLRTask)	\
    (This)->lpVtbl -> SetConnectionTasks(This,id,dwCount,ppCLRTask)

#define ICLRDebugManager_EndConnection(This,dwConnectionId)	\
    (This)->lpVtbl -> EndConnection(This,dwConnectionId)

#define ICLRDebugManager_SetDacl(This,pacl)	\
    (This)->lpVtbl -> SetDacl(This,pacl)

#define ICLRDebugManager_GetDacl(This,pacl)	\
    (This)->lpVtbl -> GetDacl(This,pacl)

#define ICLRDebugManager_IsDebuggerAttached(This,pbAttached)	\
    (This)->lpVtbl -> IsDebuggerAttached(This,pbAttached)

#define ICLRDebugManager_SetSymbolReadingPolicy(This,policy)	\
    (This)->lpVtbl -> SetSymbolReadingPolicy(This,policy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDebugManager_BeginConnection_Proxy( 
    ICLRDebugManager * This,
    /* [in] */ CONNID dwConnectionId,
    /* [string][in] */ wchar_t *szConnectionName);


void __RPC_STUB ICLRDebugManager_BeginConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDebugManager_SetConnectionTasks_Proxy( 
    ICLRDebugManager * This,
    /* [in] */ CONNID id,
    /* [in] */ DWORD dwCount,
    /* [size_is][in] */ ICLRTask **ppCLRTask);


void __RPC_STUB ICLRDebugManager_SetConnectionTasks_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDebugManager_EndConnection_Proxy( 
    ICLRDebugManager * This,
    /* [in] */ CONNID dwConnectionId);


void __RPC_STUB ICLRDebugManager_EndConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDebugManager_SetDacl_Proxy( 
    ICLRDebugManager * This,
    /* [in] */ PACL pacl);


void __RPC_STUB ICLRDebugManager_SetDacl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDebugManager_GetDacl_Proxy( 
    ICLRDebugManager * This,
    /* [out] */ PACL *pacl);


void __RPC_STUB ICLRDebugManager_GetDacl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDebugManager_IsDebuggerAttached_Proxy( 
    ICLRDebugManager * This,
    /* [out] */ BOOL *pbAttached);


void __RPC_STUB ICLRDebugManager_IsDebuggerAttached_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDebugManager_SetSymbolReadingPolicy_Proxy( 
    ICLRDebugManager * This,
    /* [in] */ ESymbolReadingPolicy policy);


void __RPC_STUB ICLRDebugManager_SetSymbolReadingPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDebugManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0144 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_mscoree_0144_0001
    {	DUMP_FLAVOR_Mini	= 0,
	DUMP_FLAVOR_CriticalCLRState	= 1,
	DUMP_FLAVOR_NonHeapCLRState	= 2,
	DUMP_FLAVOR_Default	= DUMP_FLAVOR_Mini
    } 	ECustomDumpFlavor;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_mscoree_0144_0002
    {	DUMP_ITEM_None	= 0
    } 	ECustomDumpItemKind;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_mscoree_0144_0003
    {
    ECustomDumpItemKind itemKind;
    union 
        {
        UINT_PTR pReserved;
        } 	;
    } 	CustomDumpItem;

typedef struct _BucketParameters
    {
    BOOL fInited;
    WCHAR pszEventTypeName[ 255 ];
    WCHAR pszParams[ 10 ][ 255 ];
    } 	BucketParameters;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0144_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0144_v0_0_s_ifspec;

#ifndef __ICLRErrorReportingManager_INTERFACE_DEFINED__
#define __ICLRErrorReportingManager_INTERFACE_DEFINED__

/* interface ICLRErrorReportingManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRErrorReportingManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("980D2F1A-BF79-4c08-812A-BB9778928F78")
    ICLRErrorReportingManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetBucketParametersForCurrentException( 
            /* [out] */ BucketParameters *pParams) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginCustomDump( 
            /* [in] */ ECustomDumpFlavor dwFlavor,
            /* [in] */ DWORD dwNumItems,
            /* [length_is][size_is][in] */ CustomDumpItem *items,
            DWORD dwReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndCustomDump( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRErrorReportingManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRErrorReportingManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRErrorReportingManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRErrorReportingManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetBucketParametersForCurrentException )( 
            ICLRErrorReportingManager * This,
            /* [out] */ BucketParameters *pParams);
        
        HRESULT ( STDMETHODCALLTYPE *BeginCustomDump )( 
            ICLRErrorReportingManager * This,
            /* [in] */ ECustomDumpFlavor dwFlavor,
            /* [in] */ DWORD dwNumItems,
            /* [length_is][size_is][in] */ CustomDumpItem *items,
            DWORD dwReserved);
        
        HRESULT ( STDMETHODCALLTYPE *EndCustomDump )( 
            ICLRErrorReportingManager * This);
        
        END_INTERFACE
    } ICLRErrorReportingManagerVtbl;

    interface ICLRErrorReportingManager
    {
        CONST_VTBL struct ICLRErrorReportingManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRErrorReportingManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRErrorReportingManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRErrorReportingManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRErrorReportingManager_GetBucketParametersForCurrentException(This,pParams)	\
    (This)->lpVtbl -> GetBucketParametersForCurrentException(This,pParams)

#define ICLRErrorReportingManager_BeginCustomDump(This,dwFlavor,dwNumItems,items,dwReserved)	\
    (This)->lpVtbl -> BeginCustomDump(This,dwFlavor,dwNumItems,items,dwReserved)

#define ICLRErrorReportingManager_EndCustomDump(This)	\
    (This)->lpVtbl -> EndCustomDump(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRErrorReportingManager_GetBucketParametersForCurrentException_Proxy( 
    ICLRErrorReportingManager * This,
    /* [out] */ BucketParameters *pParams);


void __RPC_STUB ICLRErrorReportingManager_GetBucketParametersForCurrentException_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRErrorReportingManager_BeginCustomDump_Proxy( 
    ICLRErrorReportingManager * This,
    /* [in] */ ECustomDumpFlavor dwFlavor,
    /* [in] */ DWORD dwNumItems,
    /* [length_is][size_is][in] */ CustomDumpItem *items,
    DWORD dwReserved);


void __RPC_STUB ICLRErrorReportingManager_BeginCustomDump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRErrorReportingManager_EndCustomDump_Proxy( 
    ICLRErrorReportingManager * This);


void __RPC_STUB ICLRErrorReportingManager_EndCustomDump_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRErrorReportingManager_INTERFACE_DEFINED__ */


#ifndef __IHostCrst_INTERFACE_DEFINED__
#define __IHostCrst_INTERFACE_DEFINED__

/* interface IHostCrst */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostCrst;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6DF710A6-26A4-4a65-8CD5-7237B8BDA8DC")
    IHostCrst : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Enter( 
            /* [in] */ DWORD option) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Leave( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE TryEnter( 
            /* [in] */ DWORD option,
            /* [out] */ BOOL *pbSucceeded) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSpinCount( 
            /* [in] */ DWORD dwSpinCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostCrstVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostCrst * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostCrst * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostCrst * This);
        
        HRESULT ( STDMETHODCALLTYPE *Enter )( 
            IHostCrst * This,
            /* [in] */ DWORD option);
        
        HRESULT ( STDMETHODCALLTYPE *Leave )( 
            IHostCrst * This);
        
        HRESULT ( STDMETHODCALLTYPE *TryEnter )( 
            IHostCrst * This,
            /* [in] */ DWORD option,
            /* [out] */ BOOL *pbSucceeded);
        
        HRESULT ( STDMETHODCALLTYPE *SetSpinCount )( 
            IHostCrst * This,
            /* [in] */ DWORD dwSpinCount);
        
        END_INTERFACE
    } IHostCrstVtbl;

    interface IHostCrst
    {
        CONST_VTBL struct IHostCrstVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostCrst_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostCrst_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostCrst_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostCrst_Enter(This,option)	\
    (This)->lpVtbl -> Enter(This,option)

#define IHostCrst_Leave(This)	\
    (This)->lpVtbl -> Leave(This)

#define IHostCrst_TryEnter(This,option,pbSucceeded)	\
    (This)->lpVtbl -> TryEnter(This,option,pbSucceeded)

#define IHostCrst_SetSpinCount(This,dwSpinCount)	\
    (This)->lpVtbl -> SetSpinCount(This,dwSpinCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostCrst_Enter_Proxy( 
    IHostCrst * This,
    /* [in] */ DWORD option);


void __RPC_STUB IHostCrst_Enter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostCrst_Leave_Proxy( 
    IHostCrst * This);


void __RPC_STUB IHostCrst_Leave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostCrst_TryEnter_Proxy( 
    IHostCrst * This,
    /* [in] */ DWORD option,
    /* [out] */ BOOL *pbSucceeded);


void __RPC_STUB IHostCrst_TryEnter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostCrst_SetSpinCount_Proxy( 
    IHostCrst * This,
    /* [in] */ DWORD dwSpinCount);


void __RPC_STUB IHostCrst_SetSpinCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostCrst_INTERFACE_DEFINED__ */


#ifndef __IHostAutoEvent_INTERFACE_DEFINED__
#define __IHostAutoEvent_INTERFACE_DEFINED__

/* interface IHostAutoEvent */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostAutoEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("50B0CFCE-4063-4278-9673-E5CB4ED0BDB8")
    IHostAutoEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Wait( 
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ DWORD option) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Set( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostAutoEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostAutoEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostAutoEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostAutoEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *Wait )( 
            IHostAutoEvent * This,
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ DWORD option);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IHostAutoEvent * This);
        
        END_INTERFACE
    } IHostAutoEventVtbl;

    interface IHostAutoEvent
    {
        CONST_VTBL struct IHostAutoEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostAutoEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostAutoEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostAutoEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostAutoEvent_Wait(This,dwMilliseconds,option)	\
    (This)->lpVtbl -> Wait(This,dwMilliseconds,option)

#define IHostAutoEvent_Set(This)	\
    (This)->lpVtbl -> Set(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostAutoEvent_Wait_Proxy( 
    IHostAutoEvent * This,
    /* [in] */ DWORD dwMilliseconds,
    /* [in] */ DWORD option);


void __RPC_STUB IHostAutoEvent_Wait_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostAutoEvent_Set_Proxy( 
    IHostAutoEvent * This);


void __RPC_STUB IHostAutoEvent_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostAutoEvent_INTERFACE_DEFINED__ */


#ifndef __IHostManualEvent_INTERFACE_DEFINED__
#define __IHostManualEvent_INTERFACE_DEFINED__

/* interface IHostManualEvent */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostManualEvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1BF4EC38-AFFE-4fb9-85A6-525268F15B54")
    IHostManualEvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Wait( 
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ DWORD option) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Set( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostManualEventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostManualEvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostManualEvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostManualEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *Wait )( 
            IHostManualEvent * This,
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ DWORD option);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IHostManualEvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            IHostManualEvent * This);
        
        END_INTERFACE
    } IHostManualEventVtbl;

    interface IHostManualEvent
    {
        CONST_VTBL struct IHostManualEventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostManualEvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostManualEvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostManualEvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostManualEvent_Wait(This,dwMilliseconds,option)	\
    (This)->lpVtbl -> Wait(This,dwMilliseconds,option)

#define IHostManualEvent_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IHostManualEvent_Set(This)	\
    (This)->lpVtbl -> Set(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostManualEvent_Wait_Proxy( 
    IHostManualEvent * This,
    /* [in] */ DWORD dwMilliseconds,
    /* [in] */ DWORD option);


void __RPC_STUB IHostManualEvent_Wait_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostManualEvent_Reset_Proxy( 
    IHostManualEvent * This);


void __RPC_STUB IHostManualEvent_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostManualEvent_Set_Proxy( 
    IHostManualEvent * This);


void __RPC_STUB IHostManualEvent_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostManualEvent_INTERFACE_DEFINED__ */


#ifndef __IHostSemaphore_INTERFACE_DEFINED__
#define __IHostSemaphore_INTERFACE_DEFINED__

/* interface IHostSemaphore */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostSemaphore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("855efd47-cc09-463a-a97d-16acab882661")
    IHostSemaphore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Wait( 
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ DWORD option) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseSemaphore( 
            /* [in] */ LONG lReleaseCount,
            /* [out] */ LONG *lpPreviousCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostSemaphoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostSemaphore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostSemaphore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostSemaphore * This);
        
        HRESULT ( STDMETHODCALLTYPE *Wait )( 
            IHostSemaphore * This,
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ DWORD option);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseSemaphore )( 
            IHostSemaphore * This,
            /* [in] */ LONG lReleaseCount,
            /* [out] */ LONG *lpPreviousCount);
        
        END_INTERFACE
    } IHostSemaphoreVtbl;

    interface IHostSemaphore
    {
        CONST_VTBL struct IHostSemaphoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostSemaphore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostSemaphore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostSemaphore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostSemaphore_Wait(This,dwMilliseconds,option)	\
    (This)->lpVtbl -> Wait(This,dwMilliseconds,option)

#define IHostSemaphore_ReleaseSemaphore(This,lReleaseCount,lpPreviousCount)	\
    (This)->lpVtbl -> ReleaseSemaphore(This,lReleaseCount,lpPreviousCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostSemaphore_Wait_Proxy( 
    IHostSemaphore * This,
    /* [in] */ DWORD dwMilliseconds,
    /* [in] */ DWORD option);


void __RPC_STUB IHostSemaphore_Wait_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSemaphore_ReleaseSemaphore_Proxy( 
    IHostSemaphore * This,
    /* [in] */ LONG lReleaseCount,
    /* [out] */ LONG *lpPreviousCount);


void __RPC_STUB IHostSemaphore_ReleaseSemaphore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostSemaphore_INTERFACE_DEFINED__ */


#ifndef __ICLRSyncManager_INTERFACE_DEFINED__
#define __ICLRSyncManager_INTERFACE_DEFINED__

/* interface ICLRSyncManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRSyncManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("55FF199D-AD21-48f9-A16C-F24EBBB8727D")
    ICLRSyncManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMonitorOwner( 
            /* [in] */ SIZE_T Cookie,
            /* [out] */ IHostTask **ppOwnerHostTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRWLockOwnerIterator( 
            /* [in] */ SIZE_T Cookie,
            /* [out] */ SIZE_T *pIterator) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRWLockOwnerNext( 
            /* [in] */ SIZE_T Iterator,
            /* [out] */ IHostTask **ppOwnerHostTask) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteRWLockOwnerIterator( 
            /* [in] */ SIZE_T Iterator) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRSyncManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRSyncManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRSyncManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRSyncManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMonitorOwner )( 
            ICLRSyncManager * This,
            /* [in] */ SIZE_T Cookie,
            /* [out] */ IHostTask **ppOwnerHostTask);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRWLockOwnerIterator )( 
            ICLRSyncManager * This,
            /* [in] */ SIZE_T Cookie,
            /* [out] */ SIZE_T *pIterator);
        
        HRESULT ( STDMETHODCALLTYPE *GetRWLockOwnerNext )( 
            ICLRSyncManager * This,
            /* [in] */ SIZE_T Iterator,
            /* [out] */ IHostTask **ppOwnerHostTask);
        
        HRESULT ( STDMETHODCALLTYPE *DeleteRWLockOwnerIterator )( 
            ICLRSyncManager * This,
            /* [in] */ SIZE_T Iterator);
        
        END_INTERFACE
    } ICLRSyncManagerVtbl;

    interface ICLRSyncManager
    {
        CONST_VTBL struct ICLRSyncManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRSyncManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRSyncManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRSyncManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRSyncManager_GetMonitorOwner(This,Cookie,ppOwnerHostTask)	\
    (This)->lpVtbl -> GetMonitorOwner(This,Cookie,ppOwnerHostTask)

#define ICLRSyncManager_CreateRWLockOwnerIterator(This,Cookie,pIterator)	\
    (This)->lpVtbl -> CreateRWLockOwnerIterator(This,Cookie,pIterator)

#define ICLRSyncManager_GetRWLockOwnerNext(This,Iterator,ppOwnerHostTask)	\
    (This)->lpVtbl -> GetRWLockOwnerNext(This,Iterator,ppOwnerHostTask)

#define ICLRSyncManager_DeleteRWLockOwnerIterator(This,Iterator)	\
    (This)->lpVtbl -> DeleteRWLockOwnerIterator(This,Iterator)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRSyncManager_GetMonitorOwner_Proxy( 
    ICLRSyncManager * This,
    /* [in] */ SIZE_T Cookie,
    /* [out] */ IHostTask **ppOwnerHostTask);


void __RPC_STUB ICLRSyncManager_GetMonitorOwner_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRSyncManager_CreateRWLockOwnerIterator_Proxy( 
    ICLRSyncManager * This,
    /* [in] */ SIZE_T Cookie,
    /* [out] */ SIZE_T *pIterator);


void __RPC_STUB ICLRSyncManager_CreateRWLockOwnerIterator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRSyncManager_GetRWLockOwnerNext_Proxy( 
    ICLRSyncManager * This,
    /* [in] */ SIZE_T Iterator,
    /* [out] */ IHostTask **ppOwnerHostTask);


void __RPC_STUB ICLRSyncManager_GetRWLockOwnerNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRSyncManager_DeleteRWLockOwnerIterator_Proxy( 
    ICLRSyncManager * This,
    /* [in] */ SIZE_T Iterator);


void __RPC_STUB ICLRSyncManager_DeleteRWLockOwnerIterator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRSyncManager_INTERFACE_DEFINED__ */


#ifndef __IHostSyncManager_INTERFACE_DEFINED__
#define __IHostSyncManager_INTERFACE_DEFINED__

/* interface IHostSyncManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostSyncManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("234330c7-5f10-4f20-9615-5122dab7a0ac")
    IHostSyncManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetCLRSyncManager( 
            /* [in] */ ICLRSyncManager *pManager) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateCrst( 
            /* [out] */ IHostCrst **ppCrst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateCrstWithSpinCount( 
            /* [in] */ DWORD dwSpinCount,
            /* [out] */ IHostCrst **ppCrst) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateAutoEvent( 
            /* [out] */ IHostAutoEvent **ppEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateManualEvent( 
            /* [in] */ BOOL bInitialState,
            /* [out] */ IHostManualEvent **ppEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateMonitorEvent( 
            /* [in] */ SIZE_T Cookie,
            /* [out] */ IHostAutoEvent **ppEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRWLockWriterEvent( 
            /* [in] */ SIZE_T Cookie,
            /* [out] */ IHostAutoEvent **ppEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateRWLockReaderEvent( 
            /* [in] */ BOOL bInitialState,
            /* [in] */ SIZE_T Cookie,
            /* [out] */ IHostManualEvent **ppEvent) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSemaphore( 
            /* [in] */ DWORD dwInitial,
            /* [in] */ DWORD dwMax,
            /* [out] */ IHostSemaphore **ppSemaphore) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostSyncManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostSyncManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostSyncManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostSyncManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetCLRSyncManager )( 
            IHostSyncManager * This,
            /* [in] */ ICLRSyncManager *pManager);
        
        HRESULT ( STDMETHODCALLTYPE *CreateCrst )( 
            IHostSyncManager * This,
            /* [out] */ IHostCrst **ppCrst);
        
        HRESULT ( STDMETHODCALLTYPE *CreateCrstWithSpinCount )( 
            IHostSyncManager * This,
            /* [in] */ DWORD dwSpinCount,
            /* [out] */ IHostCrst **ppCrst);
        
        HRESULT ( STDMETHODCALLTYPE *CreateAutoEvent )( 
            IHostSyncManager * This,
            /* [out] */ IHostAutoEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *CreateManualEvent )( 
            IHostSyncManager * This,
            /* [in] */ BOOL bInitialState,
            /* [out] */ IHostManualEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *CreateMonitorEvent )( 
            IHostSyncManager * This,
            /* [in] */ SIZE_T Cookie,
            /* [out] */ IHostAutoEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRWLockWriterEvent )( 
            IHostSyncManager * This,
            /* [in] */ SIZE_T Cookie,
            /* [out] */ IHostAutoEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *CreateRWLockReaderEvent )( 
            IHostSyncManager * This,
            /* [in] */ BOOL bInitialState,
            /* [in] */ SIZE_T Cookie,
            /* [out] */ IHostManualEvent **ppEvent);
        
        HRESULT ( STDMETHODCALLTYPE *CreateSemaphore )( 
            IHostSyncManager * This,
            /* [in] */ DWORD dwInitial,
            /* [in] */ DWORD dwMax,
            /* [out] */ IHostSemaphore **ppSemaphore);
        
        END_INTERFACE
    } IHostSyncManagerVtbl;

    interface IHostSyncManager
    {
        CONST_VTBL struct IHostSyncManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostSyncManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostSyncManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostSyncManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostSyncManager_SetCLRSyncManager(This,pManager)	\
    (This)->lpVtbl -> SetCLRSyncManager(This,pManager)

#define IHostSyncManager_CreateCrst(This,ppCrst)	\
    (This)->lpVtbl -> CreateCrst(This,ppCrst)

#define IHostSyncManager_CreateCrstWithSpinCount(This,dwSpinCount,ppCrst)	\
    (This)->lpVtbl -> CreateCrstWithSpinCount(This,dwSpinCount,ppCrst)

#define IHostSyncManager_CreateAutoEvent(This,ppEvent)	\
    (This)->lpVtbl -> CreateAutoEvent(This,ppEvent)

#define IHostSyncManager_CreateManualEvent(This,bInitialState,ppEvent)	\
    (This)->lpVtbl -> CreateManualEvent(This,bInitialState,ppEvent)

#define IHostSyncManager_CreateMonitorEvent(This,Cookie,ppEvent)	\
    (This)->lpVtbl -> CreateMonitorEvent(This,Cookie,ppEvent)

#define IHostSyncManager_CreateRWLockWriterEvent(This,Cookie,ppEvent)	\
    (This)->lpVtbl -> CreateRWLockWriterEvent(This,Cookie,ppEvent)

#define IHostSyncManager_CreateRWLockReaderEvent(This,bInitialState,Cookie,ppEvent)	\
    (This)->lpVtbl -> CreateRWLockReaderEvent(This,bInitialState,Cookie,ppEvent)

#define IHostSyncManager_CreateSemaphore(This,dwInitial,dwMax,ppSemaphore)	\
    (This)->lpVtbl -> CreateSemaphore(This,dwInitial,dwMax,ppSemaphore)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostSyncManager_SetCLRSyncManager_Proxy( 
    IHostSyncManager * This,
    /* [in] */ ICLRSyncManager *pManager);


void __RPC_STUB IHostSyncManager_SetCLRSyncManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSyncManager_CreateCrst_Proxy( 
    IHostSyncManager * This,
    /* [out] */ IHostCrst **ppCrst);


void __RPC_STUB IHostSyncManager_CreateCrst_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSyncManager_CreateCrstWithSpinCount_Proxy( 
    IHostSyncManager * This,
    /* [in] */ DWORD dwSpinCount,
    /* [out] */ IHostCrst **ppCrst);


void __RPC_STUB IHostSyncManager_CreateCrstWithSpinCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSyncManager_CreateAutoEvent_Proxy( 
    IHostSyncManager * This,
    /* [out] */ IHostAutoEvent **ppEvent);


void __RPC_STUB IHostSyncManager_CreateAutoEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSyncManager_CreateManualEvent_Proxy( 
    IHostSyncManager * This,
    /* [in] */ BOOL bInitialState,
    /* [out] */ IHostManualEvent **ppEvent);


void __RPC_STUB IHostSyncManager_CreateManualEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSyncManager_CreateMonitorEvent_Proxy( 
    IHostSyncManager * This,
    /* [in] */ SIZE_T Cookie,
    /* [out] */ IHostAutoEvent **ppEvent);


void __RPC_STUB IHostSyncManager_CreateMonitorEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSyncManager_CreateRWLockWriterEvent_Proxy( 
    IHostSyncManager * This,
    /* [in] */ SIZE_T Cookie,
    /* [out] */ IHostAutoEvent **ppEvent);


void __RPC_STUB IHostSyncManager_CreateRWLockWriterEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSyncManager_CreateRWLockReaderEvent_Proxy( 
    IHostSyncManager * This,
    /* [in] */ BOOL bInitialState,
    /* [in] */ SIZE_T Cookie,
    /* [out] */ IHostManualEvent **ppEvent);


void __RPC_STUB IHostSyncManager_CreateRWLockReaderEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSyncManager_CreateSemaphore_Proxy( 
    IHostSyncManager * This,
    /* [in] */ DWORD dwInitial,
    /* [in] */ DWORD dwMax,
    /* [out] */ IHostSemaphore **ppSemaphore);


void __RPC_STUB IHostSyncManager_CreateSemaphore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostSyncManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0151 */
/* [local] */ 

typedef /* [public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_mscoree_0151_0001
    {	OPR_ThreadAbort	= 0,
	OPR_ThreadRudeAbortInNonCriticalRegion	= OPR_ThreadAbort + 1,
	OPR_ThreadRudeAbortInCriticalRegion	= OPR_ThreadRudeAbortInNonCriticalRegion + 1,
	OPR_AppDomainUnload	= OPR_ThreadRudeAbortInCriticalRegion + 1,
	OPR_AppDomainRudeUnload	= OPR_AppDomainUnload + 1,
	OPR_ProcessExit	= OPR_AppDomainRudeUnload + 1,
	OPR_FinalizerRun	= OPR_ProcessExit + 1,
	MaxClrOperation	= OPR_FinalizerRun + 1
    } 	EClrOperation;

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_mscoree_0151_0002
    {	FAIL_NonCriticalResource	= 0,
	FAIL_CriticalResource	= FAIL_NonCriticalResource + 1,
	FAIL_FatalRuntime	= FAIL_CriticalResource + 1,
	FAIL_OrphanedLock	= FAIL_FatalRuntime + 1,
	FAIL_StackOverflow	= FAIL_OrphanedLock + 1,
	MaxClrFailure	= FAIL_StackOverflow + 1
    } 	EClrFailure;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_mscoree_0151_0003
    {	eRuntimeDeterminedPolicy	= 0,
	eHostDeterminedPolicy	= eRuntimeDeterminedPolicy + 1
    } 	EClrUnhandledException;

typedef /* [public][public][public][public][public][public][public][public] */ 
enum __MIDL___MIDL_itf_mscoree_0151_0004
    {	eNoAction	= 0,
	eThrowException	= eNoAction + 1,
	eAbortThread	= eThrowException + 1,
	eRudeAbortThread	= eAbortThread + 1,
	eUnloadAppDomain	= eRudeAbortThread + 1,
	eRudeUnloadAppDomain	= eUnloadAppDomain + 1,
	eExitProcess	= eRudeUnloadAppDomain + 1,
	eFastExitProcess	= eExitProcess + 1,
	eRudeExitProcess	= eFastExitProcess + 1,
	eDisableRuntime	= eRudeExitProcess + 1,
	MaxPolicyAction	= eDisableRuntime + 1
    } 	EPolicyAction;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0151_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0151_v0_0_s_ifspec;

#ifndef __ICLRPolicyManager_INTERFACE_DEFINED__
#define __ICLRPolicyManager_INTERFACE_DEFINED__

/* interface ICLRPolicyManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRPolicyManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7D290010-D781-45da-A6F8-AA5D711A730E")
    ICLRPolicyManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetDefaultAction( 
            /* [in] */ EClrOperation operation,
            /* [in] */ EPolicyAction action) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimeout( 
            /* [in] */ EClrOperation operation,
            /* [in] */ DWORD dwMilliseconds) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActionOnTimeout( 
            /* [in] */ EClrOperation operation,
            /* [in] */ EPolicyAction action) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTimeoutAndAction( 
            /* [in] */ EClrOperation operation,
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ EPolicyAction action) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActionOnFailure( 
            /* [in] */ EClrFailure failure,
            /* [in] */ EPolicyAction action) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUnhandledExceptionPolicy( 
            /* [in] */ EClrUnhandledException policy) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRPolicyManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRPolicyManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRPolicyManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRPolicyManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetDefaultAction )( 
            ICLRPolicyManager * This,
            /* [in] */ EClrOperation operation,
            /* [in] */ EPolicyAction action);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeout )( 
            ICLRPolicyManager * This,
            /* [in] */ EClrOperation operation,
            /* [in] */ DWORD dwMilliseconds);
        
        HRESULT ( STDMETHODCALLTYPE *SetActionOnTimeout )( 
            ICLRPolicyManager * This,
            /* [in] */ EClrOperation operation,
            /* [in] */ EPolicyAction action);
        
        HRESULT ( STDMETHODCALLTYPE *SetTimeoutAndAction )( 
            ICLRPolicyManager * This,
            /* [in] */ EClrOperation operation,
            /* [in] */ DWORD dwMilliseconds,
            /* [in] */ EPolicyAction action);
        
        HRESULT ( STDMETHODCALLTYPE *SetActionOnFailure )( 
            ICLRPolicyManager * This,
            /* [in] */ EClrFailure failure,
            /* [in] */ EPolicyAction action);
        
        HRESULT ( STDMETHODCALLTYPE *SetUnhandledExceptionPolicy )( 
            ICLRPolicyManager * This,
            /* [in] */ EClrUnhandledException policy);
        
        END_INTERFACE
    } ICLRPolicyManagerVtbl;

    interface ICLRPolicyManager
    {
        CONST_VTBL struct ICLRPolicyManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRPolicyManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRPolicyManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRPolicyManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRPolicyManager_SetDefaultAction(This,operation,action)	\
    (This)->lpVtbl -> SetDefaultAction(This,operation,action)

#define ICLRPolicyManager_SetTimeout(This,operation,dwMilliseconds)	\
    (This)->lpVtbl -> SetTimeout(This,operation,dwMilliseconds)

#define ICLRPolicyManager_SetActionOnTimeout(This,operation,action)	\
    (This)->lpVtbl -> SetActionOnTimeout(This,operation,action)

#define ICLRPolicyManager_SetTimeoutAndAction(This,operation,dwMilliseconds,action)	\
    (This)->lpVtbl -> SetTimeoutAndAction(This,operation,dwMilliseconds,action)

#define ICLRPolicyManager_SetActionOnFailure(This,failure,action)	\
    (This)->lpVtbl -> SetActionOnFailure(This,failure,action)

#define ICLRPolicyManager_SetUnhandledExceptionPolicy(This,policy)	\
    (This)->lpVtbl -> SetUnhandledExceptionPolicy(This,policy)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRPolicyManager_SetDefaultAction_Proxy( 
    ICLRPolicyManager * This,
    /* [in] */ EClrOperation operation,
    /* [in] */ EPolicyAction action);


void __RPC_STUB ICLRPolicyManager_SetDefaultAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRPolicyManager_SetTimeout_Proxy( 
    ICLRPolicyManager * This,
    /* [in] */ EClrOperation operation,
    /* [in] */ DWORD dwMilliseconds);


void __RPC_STUB ICLRPolicyManager_SetTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRPolicyManager_SetActionOnTimeout_Proxy( 
    ICLRPolicyManager * This,
    /* [in] */ EClrOperation operation,
    /* [in] */ EPolicyAction action);


void __RPC_STUB ICLRPolicyManager_SetActionOnTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRPolicyManager_SetTimeoutAndAction_Proxy( 
    ICLRPolicyManager * This,
    /* [in] */ EClrOperation operation,
    /* [in] */ DWORD dwMilliseconds,
    /* [in] */ EPolicyAction action);


void __RPC_STUB ICLRPolicyManager_SetTimeoutAndAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRPolicyManager_SetActionOnFailure_Proxy( 
    ICLRPolicyManager * This,
    /* [in] */ EClrFailure failure,
    /* [in] */ EPolicyAction action);


void __RPC_STUB ICLRPolicyManager_SetActionOnFailure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRPolicyManager_SetUnhandledExceptionPolicy_Proxy( 
    ICLRPolicyManager * This,
    /* [in] */ EClrUnhandledException policy);


void __RPC_STUB ICLRPolicyManager_SetUnhandledExceptionPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRPolicyManager_INTERFACE_DEFINED__ */


#ifndef __IHostPolicyManager_INTERFACE_DEFINED__
#define __IHostPolicyManager_INTERFACE_DEFINED__

/* interface IHostPolicyManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostPolicyManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7AE49844-B1E3-4683-BA7C-1E8212EA3B79")
    IHostPolicyManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnDefaultAction( 
            /* [in] */ EClrOperation operation,
            /* [in] */ EPolicyAction action) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTimeout( 
            /* [in] */ EClrOperation operation,
            /* [in] */ EPolicyAction action) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnFailure( 
            /* [in] */ EClrFailure failure,
            /* [in] */ EPolicyAction action) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostPolicyManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostPolicyManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostPolicyManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostPolicyManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefaultAction )( 
            IHostPolicyManager * This,
            /* [in] */ EClrOperation operation,
            /* [in] */ EPolicyAction action);
        
        HRESULT ( STDMETHODCALLTYPE *OnTimeout )( 
            IHostPolicyManager * This,
            /* [in] */ EClrOperation operation,
            /* [in] */ EPolicyAction action);
        
        HRESULT ( STDMETHODCALLTYPE *OnFailure )( 
            IHostPolicyManager * This,
            /* [in] */ EClrFailure failure,
            /* [in] */ EPolicyAction action);
        
        END_INTERFACE
    } IHostPolicyManagerVtbl;

    interface IHostPolicyManager
    {
        CONST_VTBL struct IHostPolicyManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostPolicyManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostPolicyManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostPolicyManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostPolicyManager_OnDefaultAction(This,operation,action)	\
    (This)->lpVtbl -> OnDefaultAction(This,operation,action)

#define IHostPolicyManager_OnTimeout(This,operation,action)	\
    (This)->lpVtbl -> OnTimeout(This,operation,action)

#define IHostPolicyManager_OnFailure(This,failure,action)	\
    (This)->lpVtbl -> OnFailure(This,failure,action)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostPolicyManager_OnDefaultAction_Proxy( 
    IHostPolicyManager * This,
    /* [in] */ EClrOperation operation,
    /* [in] */ EPolicyAction action);


void __RPC_STUB IHostPolicyManager_OnDefaultAction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostPolicyManager_OnTimeout_Proxy( 
    IHostPolicyManager * This,
    /* [in] */ EClrOperation operation,
    /* [in] */ EPolicyAction action);


void __RPC_STUB IHostPolicyManager_OnTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostPolicyManager_OnFailure_Proxy( 
    IHostPolicyManager * This,
    /* [in] */ EClrFailure failure,
    /* [in] */ EPolicyAction action);


void __RPC_STUB IHostPolicyManager_OnFailure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostPolicyManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0153 */
/* [local] */ 

typedef /* [public][public][public][public] */ 
enum __MIDL___MIDL_itf_mscoree_0153_0001
    {	Event_DomainUnload	= 0,
	Event_ClrDisabled	= Event_DomainUnload + 1,
	Event_MDAFired	= Event_ClrDisabled + 1,
	Event_StackOverflow	= Event_MDAFired + 1,
	MaxClrEvent	= Event_StackOverflow + 1
    } 	EClrEvent;

typedef struct _MDAInfo
    {
    LPCWSTR lpMDACaption;
    LPCWSTR lpMDAMessage;
    LPCWSTR lpStackTrace;
    } 	MDAInfo;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mscoree_0153_0002
    {	SO_Managed	= 0,
	SO_ClrEngine	= SO_Managed + 1,
	SO_Other	= SO_ClrEngine + 1
    } 	StackOverflowType;

typedef struct _StackOverflowInfo
{
    StackOverflowType soType;
    EXCEPTION_POINTERS *pExceptionInfo;
} StackOverflowInfo;


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0153_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0153_v0_0_s_ifspec;

#ifndef __IActionOnCLREvent_INTERFACE_DEFINED__
#define __IActionOnCLREvent_INTERFACE_DEFINED__

/* interface IActionOnCLREvent */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IActionOnCLREvent;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("607BE24B-D91B-4E28-A242-61871CE56E35")
    IActionOnCLREvent : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OnEvent( 
            /* [in] */ EClrEvent event,
            /* [in] */ PVOID data) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActionOnCLREventVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActionOnCLREvent * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActionOnCLREvent * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActionOnCLREvent * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnEvent )( 
            IActionOnCLREvent * This,
            /* [in] */ EClrEvent event,
            /* [in] */ PVOID data);
        
        END_INTERFACE
    } IActionOnCLREventVtbl;

    interface IActionOnCLREvent
    {
        CONST_VTBL struct IActionOnCLREventVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActionOnCLREvent_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActionOnCLREvent_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActionOnCLREvent_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActionOnCLREvent_OnEvent(This,event,data)	\
    (This)->lpVtbl -> OnEvent(This,event,data)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActionOnCLREvent_OnEvent_Proxy( 
    IActionOnCLREvent * This,
    /* [in] */ EClrEvent event,
    /* [in] */ PVOID data);


void __RPC_STUB IActionOnCLREvent_OnEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActionOnCLREvent_INTERFACE_DEFINED__ */


#ifndef __ICLROnEventManager_INTERFACE_DEFINED__
#define __ICLROnEventManager_INTERFACE_DEFINED__

/* interface ICLROnEventManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLROnEventManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D0E0132-E64F-493D-9260-025C0E32C175")
    ICLROnEventManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterActionOnEvent( 
            /* [in] */ EClrEvent event,
            /* [in] */ IActionOnCLREvent *pAction) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterActionOnEvent( 
            /* [in] */ EClrEvent event,
            /* [in] */ IActionOnCLREvent *pAction) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLROnEventManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLROnEventManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLROnEventManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLROnEventManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterActionOnEvent )( 
            ICLROnEventManager * This,
            /* [in] */ EClrEvent event,
            /* [in] */ IActionOnCLREvent *pAction);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterActionOnEvent )( 
            ICLROnEventManager * This,
            /* [in] */ EClrEvent event,
            /* [in] */ IActionOnCLREvent *pAction);
        
        END_INTERFACE
    } ICLROnEventManagerVtbl;

    interface ICLROnEventManager
    {
        CONST_VTBL struct ICLROnEventManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLROnEventManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLROnEventManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLROnEventManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLROnEventManager_RegisterActionOnEvent(This,event,pAction)	\
    (This)->lpVtbl -> RegisterActionOnEvent(This,event,pAction)

#define ICLROnEventManager_UnregisterActionOnEvent(This,event,pAction)	\
    (This)->lpVtbl -> UnregisterActionOnEvent(This,event,pAction)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLROnEventManager_RegisterActionOnEvent_Proxy( 
    ICLROnEventManager * This,
    /* [in] */ EClrEvent event,
    /* [in] */ IActionOnCLREvent *pAction);


void __RPC_STUB ICLROnEventManager_RegisterActionOnEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLROnEventManager_UnregisterActionOnEvent_Proxy( 
    ICLROnEventManager * This,
    /* [in] */ EClrEvent event,
    /* [in] */ IActionOnCLREvent *pAction);


void __RPC_STUB ICLROnEventManager_UnregisterActionOnEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLROnEventManager_INTERFACE_DEFINED__ */


#ifndef __IHostGCManager_INTERFACE_DEFINED__
#define __IHostGCManager_INTERFACE_DEFINED__

/* interface IHostGCManager */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostGCManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5D4EC34E-F248-457B-B603-255FAABA0D21")
    IHostGCManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ThreadIsBlockingForSuspension( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspensionStarting( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SuspensionEnding( 
            DWORD Generation) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostGCManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostGCManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostGCManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostGCManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *ThreadIsBlockingForSuspension )( 
            IHostGCManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuspensionStarting )( 
            IHostGCManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SuspensionEnding )( 
            IHostGCManager * This,
            DWORD Generation);
        
        END_INTERFACE
    } IHostGCManagerVtbl;

    interface IHostGCManager
    {
        CONST_VTBL struct IHostGCManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostGCManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostGCManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostGCManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostGCManager_ThreadIsBlockingForSuspension(This)	\
    (This)->lpVtbl -> ThreadIsBlockingForSuspension(This)

#define IHostGCManager_SuspensionStarting(This)	\
    (This)->lpVtbl -> SuspensionStarting(This)

#define IHostGCManager_SuspensionEnding(This,Generation)	\
    (This)->lpVtbl -> SuspensionEnding(This,Generation)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostGCManager_ThreadIsBlockingForSuspension_Proxy( 
    IHostGCManager * This);


void __RPC_STUB IHostGCManager_ThreadIsBlockingForSuspension_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostGCManager_SuspensionStarting_Proxy( 
    IHostGCManager * This);


void __RPC_STUB IHostGCManager_SuspensionStarting_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostGCManager_SuspensionEnding_Proxy( 
    IHostGCManager * This,
    DWORD Generation);


void __RPC_STUB IHostGCManager_SuspensionEnding_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostGCManager_INTERFACE_DEFINED__ */


#ifndef __ICLRGCManager_INTERFACE_DEFINED__
#define __ICLRGCManager_INTERFACE_DEFINED__

/* interface ICLRGCManager */
/* [object][local][unique][version][uuid] */ 


EXTERN_C const IID IID_ICLRGCManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("54D9007E-A8E2-4885-B7BF-F998DEEE4F2A")
    ICLRGCManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Collect( 
            /* [in] */ LONG Generation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStats( 
            /* [out][in] */ COR_GC_STATS *pStats) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetGCStartupLimits( 
            /* [in] */ DWORD SegmentSize,
            /* [in] */ DWORD MaxGen0Size) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRGCManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRGCManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRGCManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRGCManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *Collect )( 
            ICLRGCManager * This,
            /* [in] */ LONG Generation);
        
        HRESULT ( STDMETHODCALLTYPE *GetStats )( 
            ICLRGCManager * This,
            /* [out][in] */ COR_GC_STATS *pStats);
        
        HRESULT ( STDMETHODCALLTYPE *SetGCStartupLimits )( 
            ICLRGCManager * This,
            /* [in] */ DWORD SegmentSize,
            /* [in] */ DWORD MaxGen0Size);
        
        END_INTERFACE
    } ICLRGCManagerVtbl;

    interface ICLRGCManager
    {
        CONST_VTBL struct ICLRGCManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRGCManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRGCManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRGCManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRGCManager_Collect(This,Generation)	\
    (This)->lpVtbl -> Collect(This,Generation)

#define ICLRGCManager_GetStats(This,pStats)	\
    (This)->lpVtbl -> GetStats(This,pStats)

#define ICLRGCManager_SetGCStartupLimits(This,SegmentSize,MaxGen0Size)	\
    (This)->lpVtbl -> SetGCStartupLimits(This,SegmentSize,MaxGen0Size)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRGCManager_Collect_Proxy( 
    ICLRGCManager * This,
    /* [in] */ LONG Generation);


void __RPC_STUB ICLRGCManager_Collect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRGCManager_GetStats_Proxy( 
    ICLRGCManager * This,
    /* [out][in] */ COR_GC_STATS *pStats);


void __RPC_STUB ICLRGCManager_GetStats_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRGCManager_SetGCStartupLimits_Proxy( 
    ICLRGCManager * This,
    /* [in] */ DWORD SegmentSize,
    /* [in] */ DWORD MaxGen0Size);


void __RPC_STUB ICLRGCManager_SetGCStartupLimits_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRGCManager_INTERFACE_DEFINED__ */


#ifndef __ICLRAssemblyReferenceList_INTERFACE_DEFINED__
#define __ICLRAssemblyReferenceList_INTERFACE_DEFINED__

/* interface ICLRAssemblyReferenceList */
/* [local][unique][helpstring][uuid][version][object] */ 


EXTERN_C const IID IID_ICLRAssemblyReferenceList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1b2c9750-2e66-4bda-8b44-0a642c5cd733")
    ICLRAssemblyReferenceList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE IsStringAssemblyReferenceInList( 
            /* [in] */ LPCWSTR pwzAssemblyName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsAssemblyReferenceInList( 
            /* [in] */ IUnknown *pName) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRAssemblyReferenceListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRAssemblyReferenceList * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRAssemblyReferenceList * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRAssemblyReferenceList * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsStringAssemblyReferenceInList )( 
            ICLRAssemblyReferenceList * This,
            /* [in] */ LPCWSTR pwzAssemblyName);
        
        HRESULT ( STDMETHODCALLTYPE *IsAssemblyReferenceInList )( 
            ICLRAssemblyReferenceList * This,
            /* [in] */ IUnknown *pName);
        
        END_INTERFACE
    } ICLRAssemblyReferenceListVtbl;

    interface ICLRAssemblyReferenceList
    {
        CONST_VTBL struct ICLRAssemblyReferenceListVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRAssemblyReferenceList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRAssemblyReferenceList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRAssemblyReferenceList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRAssemblyReferenceList_IsStringAssemblyReferenceInList(This,pwzAssemblyName)	\
    (This)->lpVtbl -> IsStringAssemblyReferenceInList(This,pwzAssemblyName)

#define ICLRAssemblyReferenceList_IsAssemblyReferenceInList(This,pName)	\
    (This)->lpVtbl -> IsAssemblyReferenceInList(This,pName)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRAssemblyReferenceList_IsStringAssemblyReferenceInList_Proxy( 
    ICLRAssemblyReferenceList * This,
    /* [in] */ LPCWSTR pwzAssemblyName);


void __RPC_STUB ICLRAssemblyReferenceList_IsStringAssemblyReferenceInList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRAssemblyReferenceList_IsAssemblyReferenceInList_Proxy( 
    ICLRAssemblyReferenceList * This,
    /* [in] */ IUnknown *pName);


void __RPC_STUB ICLRAssemblyReferenceList_IsAssemblyReferenceInList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRAssemblyReferenceList_INTERFACE_DEFINED__ */


#ifndef __ICLRReferenceAssemblyEnum_INTERFACE_DEFINED__
#define __ICLRReferenceAssemblyEnum_INTERFACE_DEFINED__

/* interface ICLRReferenceAssemblyEnum */
/* [local][unique][helpstring][uuid][version][object] */ 


EXTERN_C const IID IID_ICLRReferenceAssemblyEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d509cb5d-cf32-4876-ae61-67770cf91973")
    ICLRReferenceAssemblyEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ DWORD dwIndex,
            /* [size_is][out] */ LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBufferSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRReferenceAssemblyEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRReferenceAssemblyEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRReferenceAssemblyEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRReferenceAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            ICLRReferenceAssemblyEnum * This,
            /* [in] */ DWORD dwIndex,
            /* [size_is][out] */ LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBufferSize);
        
        END_INTERFACE
    } ICLRReferenceAssemblyEnumVtbl;

    interface ICLRReferenceAssemblyEnum
    {
        CONST_VTBL struct ICLRReferenceAssemblyEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRReferenceAssemblyEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRReferenceAssemblyEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRReferenceAssemblyEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRReferenceAssemblyEnum_Get(This,dwIndex,pwzBuffer,pcchBufferSize)	\
    (This)->lpVtbl -> Get(This,dwIndex,pwzBuffer,pcchBufferSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRReferenceAssemblyEnum_Get_Proxy( 
    ICLRReferenceAssemblyEnum * This,
    /* [in] */ DWORD dwIndex,
    /* [size_is][out] */ LPWSTR pwzBuffer,
    /* [out][in] */ DWORD *pcchBufferSize);


void __RPC_STUB ICLRReferenceAssemblyEnum_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRReferenceAssemblyEnum_INTERFACE_DEFINED__ */


#ifndef __ICLRProbingAssemblyEnum_INTERFACE_DEFINED__
#define __ICLRProbingAssemblyEnum_INTERFACE_DEFINED__

/* interface ICLRProbingAssemblyEnum */
/* [local][unique][helpstring][uuid][version][object] */ 


EXTERN_C const IID IID_ICLRProbingAssemblyEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d0c5fb1f-416b-4f97-81f4-7ac7dc24dd5d")
    ICLRProbingAssemblyEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ DWORD dwIndex,
            /* [size_is][out] */ LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBufferSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRProbingAssemblyEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRProbingAssemblyEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRProbingAssemblyEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRProbingAssemblyEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Get )( 
            ICLRProbingAssemblyEnum * This,
            /* [in] */ DWORD dwIndex,
            /* [size_is][out] */ LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBufferSize);
        
        END_INTERFACE
    } ICLRProbingAssemblyEnumVtbl;

    interface ICLRProbingAssemblyEnum
    {
        CONST_VTBL struct ICLRProbingAssemblyEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRProbingAssemblyEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRProbingAssemblyEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRProbingAssemblyEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRProbingAssemblyEnum_Get(This,dwIndex,pwzBuffer,pcchBufferSize)	\
    (This)->lpVtbl -> Get(This,dwIndex,pwzBuffer,pcchBufferSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRProbingAssemblyEnum_Get_Proxy( 
    ICLRProbingAssemblyEnum * This,
    /* [in] */ DWORD dwIndex,
    /* [size_is][out] */ LPWSTR pwzBuffer,
    /* [out][in] */ DWORD *pcchBufferSize);


void __RPC_STUB ICLRProbingAssemblyEnum_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRProbingAssemblyEnum_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0160 */
/* [local] */ 

typedef 
enum _CLRAssemblyIdentityFlags
    {	CLR_ASSEMBLY_IDENTITY_FLAGS_DEFAULT	= 0
    } 	ECLRAssemblyIdentityFlags;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0160_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0160_v0_0_s_ifspec;

#ifndef __ICLRAssemblyIdentityManager_INTERFACE_DEFINED__
#define __ICLRAssemblyIdentityManager_INTERFACE_DEFINED__

/* interface ICLRAssemblyIdentityManager */
/* [local][unique][helpstring][uuid][version][object] */ 


EXTERN_C const IID IID_ICLRAssemblyIdentityManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("15f0a9da-3ff6-4393-9da9-fdfd284e6972")
    ICLRAssemblyIdentityManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCLRAssemblyReferenceList( 
            /* [in] */ LPCWSTR *ppwzAssemblyReferences,
            /* [in] */ DWORD dwNumOfReferences,
            /* [out] */ ICLRAssemblyReferenceList **ppReferenceList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindingIdentityFromFile( 
            /* [in] */ LPCWSTR pwzFilePath,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out] */ LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetBindingIdentityFromStream( 
            /* [in] */ IStream *pStream,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out] */ LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReferencedAssembliesFromFile( 
            /* [in] */ LPCWSTR pwzFilePath,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ICLRAssemblyReferenceList *pExcludeAssembliesList,
            /* [out] */ ICLRReferenceAssemblyEnum **ppReferenceEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetReferencedAssembliesFromStream( 
            /* [in] */ IStream *pStream,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ICLRAssemblyReferenceList *pExcludeAssembliesList,
            /* [out] */ ICLRReferenceAssemblyEnum **ppReferenceEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProbingAssembliesFromReference( 
            /* [in] */ DWORD dwMachineType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pwzReferenceIdentity,
            /* [out] */ ICLRProbingAssemblyEnum **ppProbingAssemblyEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsStronglyNamed( 
            /* [in] */ LPCWSTR pwzAssemblyIdentity,
            /* [out] */ BOOL *pbIsStronglyNamed) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRAssemblyIdentityManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRAssemblyIdentityManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRAssemblyIdentityManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRAssemblyIdentityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLRAssemblyReferenceList )( 
            ICLRAssemblyIdentityManager * This,
            /* [in] */ LPCWSTR *ppwzAssemblyReferences,
            /* [in] */ DWORD dwNumOfReferences,
            /* [out] */ ICLRAssemblyReferenceList **ppReferenceList);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindingIdentityFromFile )( 
            ICLRAssemblyIdentityManager * This,
            /* [in] */ LPCWSTR pwzFilePath,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out] */ LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetBindingIdentityFromStream )( 
            ICLRAssemblyIdentityManager * This,
            /* [in] */ IStream *pStream,
            /* [in] */ DWORD dwFlags,
            /* [size_is][out] */ LPWSTR pwzBuffer,
            /* [out][in] */ DWORD *pcchBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetReferencedAssembliesFromFile )( 
            ICLRAssemblyIdentityManager * This,
            /* [in] */ LPCWSTR pwzFilePath,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ICLRAssemblyReferenceList *pExcludeAssembliesList,
            /* [out] */ ICLRReferenceAssemblyEnum **ppReferenceEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetReferencedAssembliesFromStream )( 
            ICLRAssemblyIdentityManager * This,
            /* [in] */ IStream *pStream,
            /* [in] */ DWORD dwFlags,
            /* [in] */ ICLRAssemblyReferenceList *pExcludeAssembliesList,
            /* [out] */ ICLRReferenceAssemblyEnum **ppReferenceEnum);
        
        HRESULT ( STDMETHODCALLTYPE *GetProbingAssembliesFromReference )( 
            ICLRAssemblyIdentityManager * This,
            /* [in] */ DWORD dwMachineType,
            /* [in] */ DWORD dwFlags,
            /* [in] */ LPCWSTR pwzReferenceIdentity,
            /* [out] */ ICLRProbingAssemblyEnum **ppProbingAssemblyEnum);
        
        HRESULT ( STDMETHODCALLTYPE *IsStronglyNamed )( 
            ICLRAssemblyIdentityManager * This,
            /* [in] */ LPCWSTR pwzAssemblyIdentity,
            /* [out] */ BOOL *pbIsStronglyNamed);
        
        END_INTERFACE
    } ICLRAssemblyIdentityManagerVtbl;

    interface ICLRAssemblyIdentityManager
    {
        CONST_VTBL struct ICLRAssemblyIdentityManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRAssemblyIdentityManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRAssemblyIdentityManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRAssemblyIdentityManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRAssemblyIdentityManager_GetCLRAssemblyReferenceList(This,ppwzAssemblyReferences,dwNumOfReferences,ppReferenceList)	\
    (This)->lpVtbl -> GetCLRAssemblyReferenceList(This,ppwzAssemblyReferences,dwNumOfReferences,ppReferenceList)

#define ICLRAssemblyIdentityManager_GetBindingIdentityFromFile(This,pwzFilePath,dwFlags,pwzBuffer,pcchBufferSize)	\
    (This)->lpVtbl -> GetBindingIdentityFromFile(This,pwzFilePath,dwFlags,pwzBuffer,pcchBufferSize)

#define ICLRAssemblyIdentityManager_GetBindingIdentityFromStream(This,pStream,dwFlags,pwzBuffer,pcchBufferSize)	\
    (This)->lpVtbl -> GetBindingIdentityFromStream(This,pStream,dwFlags,pwzBuffer,pcchBufferSize)

#define ICLRAssemblyIdentityManager_GetReferencedAssembliesFromFile(This,pwzFilePath,dwFlags,pExcludeAssembliesList,ppReferenceEnum)	\
    (This)->lpVtbl -> GetReferencedAssembliesFromFile(This,pwzFilePath,dwFlags,pExcludeAssembliesList,ppReferenceEnum)

#define ICLRAssemblyIdentityManager_GetReferencedAssembliesFromStream(This,pStream,dwFlags,pExcludeAssembliesList,ppReferenceEnum)	\
    (This)->lpVtbl -> GetReferencedAssembliesFromStream(This,pStream,dwFlags,pExcludeAssembliesList,ppReferenceEnum)

#define ICLRAssemblyIdentityManager_GetProbingAssembliesFromReference(This,dwMachineType,dwFlags,pwzReferenceIdentity,ppProbingAssemblyEnum)	\
    (This)->lpVtbl -> GetProbingAssembliesFromReference(This,dwMachineType,dwFlags,pwzReferenceIdentity,ppProbingAssemblyEnum)

#define ICLRAssemblyIdentityManager_IsStronglyNamed(This,pwzAssemblyIdentity,pbIsStronglyNamed)	\
    (This)->lpVtbl -> IsStronglyNamed(This,pwzAssemblyIdentity,pbIsStronglyNamed)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRAssemblyIdentityManager_GetCLRAssemblyReferenceList_Proxy( 
    ICLRAssemblyIdentityManager * This,
    /* [in] */ LPCWSTR *ppwzAssemblyReferences,
    /* [in] */ DWORD dwNumOfReferences,
    /* [out] */ ICLRAssemblyReferenceList **ppReferenceList);


void __RPC_STUB ICLRAssemblyIdentityManager_GetCLRAssemblyReferenceList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRAssemblyIdentityManager_GetBindingIdentityFromFile_Proxy( 
    ICLRAssemblyIdentityManager * This,
    /* [in] */ LPCWSTR pwzFilePath,
    /* [in] */ DWORD dwFlags,
    /* [size_is][out] */ LPWSTR pwzBuffer,
    /* [out][in] */ DWORD *pcchBufferSize);


void __RPC_STUB ICLRAssemblyIdentityManager_GetBindingIdentityFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRAssemblyIdentityManager_GetBindingIdentityFromStream_Proxy( 
    ICLRAssemblyIdentityManager * This,
    /* [in] */ IStream *pStream,
    /* [in] */ DWORD dwFlags,
    /* [size_is][out] */ LPWSTR pwzBuffer,
    /* [out][in] */ DWORD *pcchBufferSize);


void __RPC_STUB ICLRAssemblyIdentityManager_GetBindingIdentityFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRAssemblyIdentityManager_GetReferencedAssembliesFromFile_Proxy( 
    ICLRAssemblyIdentityManager * This,
    /* [in] */ LPCWSTR pwzFilePath,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ICLRAssemblyReferenceList *pExcludeAssembliesList,
    /* [out] */ ICLRReferenceAssemblyEnum **ppReferenceEnum);


void __RPC_STUB ICLRAssemblyIdentityManager_GetReferencedAssembliesFromFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRAssemblyIdentityManager_GetReferencedAssembliesFromStream_Proxy( 
    ICLRAssemblyIdentityManager * This,
    /* [in] */ IStream *pStream,
    /* [in] */ DWORD dwFlags,
    /* [in] */ ICLRAssemblyReferenceList *pExcludeAssembliesList,
    /* [out] */ ICLRReferenceAssemblyEnum **ppReferenceEnum);


void __RPC_STUB ICLRAssemblyIdentityManager_GetReferencedAssembliesFromStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRAssemblyIdentityManager_GetProbingAssembliesFromReference_Proxy( 
    ICLRAssemblyIdentityManager * This,
    /* [in] */ DWORD dwMachineType,
    /* [in] */ DWORD dwFlags,
    /* [in] */ LPCWSTR pwzReferenceIdentity,
    /* [out] */ ICLRProbingAssemblyEnum **ppProbingAssemblyEnum);


void __RPC_STUB ICLRAssemblyIdentityManager_GetProbingAssembliesFromReference_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRAssemblyIdentityManager_IsStronglyNamed_Proxy( 
    ICLRAssemblyIdentityManager * This,
    /* [in] */ LPCWSTR pwzAssemblyIdentity,
    /* [out] */ BOOL *pbIsStronglyNamed);


void __RPC_STUB ICLRAssemblyIdentityManager_IsStronglyNamed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRAssemblyIdentityManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0161 */
/* [local] */ 

typedef 
enum _hostBiningPolicyModifyFlags
    {	HOST_BINDING_POLICY_MODIFY_DEFAULT	= 0,
	HOST_BINDING_POLICY_MODIFY_CHAIN	= 1,
	HOST_BINDING_POLICY_MODIFY_REMOVE	= 2,
	HOST_BINDING_POLICY_MODIFY_MAX	= 3
    } 	EHostBindingPolicyModifyFlags;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0161_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0161_v0_0_s_ifspec;

#ifndef __ICLRHostBindingPolicyManager_INTERFACE_DEFINED__
#define __ICLRHostBindingPolicyManager_INTERFACE_DEFINED__

/* interface ICLRHostBindingPolicyManager */
/* [local][unique][helpstring][uuid][version][object] */ 


EXTERN_C const IID IID_ICLRHostBindingPolicyManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4b3545e7-1856-48c9-a8ba-24b21a753c09")
    ICLRHostBindingPolicyManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ModifyApplicationPolicy( 
            /* [in] */ LPCWSTR pwzSourceAssemblyIdentity,
            /* [in] */ LPCWSTR pwzTargetAssemblyIdentity,
            /* [in] */ BYTE *pbApplicationPolicy,
            /* [in] */ DWORD cbAppPolicySize,
            /* [in] */ DWORD dwPolicyModifyFlags,
            /* [size_is][out] */ BYTE *pbNewApplicationPolicy,
            /* [out][in] */ DWORD *pcbNewAppPolicySize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EvaluatePolicy( 
            /* [in] */ LPCWSTR pwzReferenceIdentity,
            /* [in] */ BYTE *pbApplicationPolicy,
            /* [in] */ DWORD cbAppPolicySize,
            /* [size_is][out] */ LPWSTR pwzPostPolicyReferenceIdentity,
            /* [out][in] */ DWORD *pcchPostPolicyReferenceIdentity,
            /* [out] */ DWORD *pdwPoliciesApplied) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRHostBindingPolicyManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRHostBindingPolicyManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRHostBindingPolicyManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRHostBindingPolicyManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *ModifyApplicationPolicy )( 
            ICLRHostBindingPolicyManager * This,
            /* [in] */ LPCWSTR pwzSourceAssemblyIdentity,
            /* [in] */ LPCWSTR pwzTargetAssemblyIdentity,
            /* [in] */ BYTE *pbApplicationPolicy,
            /* [in] */ DWORD cbAppPolicySize,
            /* [in] */ DWORD dwPolicyModifyFlags,
            /* [size_is][out] */ BYTE *pbNewApplicationPolicy,
            /* [out][in] */ DWORD *pcbNewAppPolicySize);
        
        HRESULT ( STDMETHODCALLTYPE *EvaluatePolicy )( 
            ICLRHostBindingPolicyManager * This,
            /* [in] */ LPCWSTR pwzReferenceIdentity,
            /* [in] */ BYTE *pbApplicationPolicy,
            /* [in] */ DWORD cbAppPolicySize,
            /* [size_is][out] */ LPWSTR pwzPostPolicyReferenceIdentity,
            /* [out][in] */ DWORD *pcchPostPolicyReferenceIdentity,
            /* [out] */ DWORD *pdwPoliciesApplied);
        
        END_INTERFACE
    } ICLRHostBindingPolicyManagerVtbl;

    interface ICLRHostBindingPolicyManager
    {
        CONST_VTBL struct ICLRHostBindingPolicyManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRHostBindingPolicyManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRHostBindingPolicyManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRHostBindingPolicyManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRHostBindingPolicyManager_ModifyApplicationPolicy(This,pwzSourceAssemblyIdentity,pwzTargetAssemblyIdentity,pbApplicationPolicy,cbAppPolicySize,dwPolicyModifyFlags,pbNewApplicationPolicy,pcbNewAppPolicySize)	\
    (This)->lpVtbl -> ModifyApplicationPolicy(This,pwzSourceAssemblyIdentity,pwzTargetAssemblyIdentity,pbApplicationPolicy,cbAppPolicySize,dwPolicyModifyFlags,pbNewApplicationPolicy,pcbNewAppPolicySize)

#define ICLRHostBindingPolicyManager_EvaluatePolicy(This,pwzReferenceIdentity,pbApplicationPolicy,cbAppPolicySize,pwzPostPolicyReferenceIdentity,pcchPostPolicyReferenceIdentity,pdwPoliciesApplied)	\
    (This)->lpVtbl -> EvaluatePolicy(This,pwzReferenceIdentity,pbApplicationPolicy,cbAppPolicySize,pwzPostPolicyReferenceIdentity,pcchPostPolicyReferenceIdentity,pdwPoliciesApplied)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRHostBindingPolicyManager_ModifyApplicationPolicy_Proxy( 
    ICLRHostBindingPolicyManager * This,
    /* [in] */ LPCWSTR pwzSourceAssemblyIdentity,
    /* [in] */ LPCWSTR pwzTargetAssemblyIdentity,
    /* [in] */ BYTE *pbApplicationPolicy,
    /* [in] */ DWORD cbAppPolicySize,
    /* [in] */ DWORD dwPolicyModifyFlags,
    /* [size_is][out] */ BYTE *pbNewApplicationPolicy,
    /* [out][in] */ DWORD *pcbNewAppPolicySize);


void __RPC_STUB ICLRHostBindingPolicyManager_ModifyApplicationPolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRHostBindingPolicyManager_EvaluatePolicy_Proxy( 
    ICLRHostBindingPolicyManager * This,
    /* [in] */ LPCWSTR pwzReferenceIdentity,
    /* [in] */ BYTE *pbApplicationPolicy,
    /* [in] */ DWORD cbAppPolicySize,
    /* [size_is][out] */ LPWSTR pwzPostPolicyReferenceIdentity,
    /* [out][in] */ DWORD *pcchPostPolicyReferenceIdentity,
    /* [out] */ DWORD *pdwPoliciesApplied);


void __RPC_STUB ICLRHostBindingPolicyManager_EvaluatePolicy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRHostBindingPolicyManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0162 */
/* [local] */ 

typedef /* [public] */ 
enum __MIDL___MIDL_itf_mscoree_0162_0001
    {	ePolicyLevelNone	= 0,
	ePolicyLevelRetargetable	= 0x1,
	ePolicyUnifiedToCLR	= 0x2,
	ePolicyLevelApp	= 0x4,
	ePolicyLevelPublisher	= 0x8,
	ePolicyLevelHost	= 0x10,
	ePolicyLevelAdmin	= 0x20
    } 	EBindPolicyLevels;

typedef struct _AssemblyBindInfo
    {
    DWORD dwAppDomainId;
    LPCWSTR lpReferencedIdentity;
    LPCWSTR lpPostPolicyIdentity;
    DWORD ePolicyLevel;
    } 	AssemblyBindInfo;

typedef struct _ModuleBindInfo
    {
    DWORD dwAppDomainId;
    LPCWSTR lpAssemblyIdentity;
    LPCWSTR lpModuleName;
    } 	ModuleBindInfo;

typedef 
enum _HostApplicationPolicy
    {	HOST_APPLICATION_BINDING_POLICY	= 1
    } 	EHostApplicationPolicy;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0162_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0162_v0_0_s_ifspec;

#ifndef __IHostAssemblyStore_INTERFACE_DEFINED__
#define __IHostAssemblyStore_INTERFACE_DEFINED__

/* interface IHostAssemblyStore */
/* [unique][helpstring][uuid][version][object][local] */ 


EXTERN_C const IID IID_IHostAssemblyStore;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7b102a88-3f7f-496d-8fa2-c35374e01af3")
    IHostAssemblyStore : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ProvideAssembly( 
            /* [in] */ AssemblyBindInfo *pBindInfo,
            /* [out] */ UINT64 *pAssemblyId,
            /* [out] */ UINT64 *pContext,
            /* [out] */ IStream **ppStmAssemblyImage,
            /* [out] */ IStream **ppStmPDB) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProvideModule( 
            /* [in] */ ModuleBindInfo *pBindInfo,
            /* [out] */ DWORD *pdwModuleId,
            /* [out] */ IStream **ppStmModuleImage,
            /* [out] */ IStream **ppStmPDB) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostAssemblyStoreVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostAssemblyStore * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostAssemblyStore * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostAssemblyStore * This);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideAssembly )( 
            IHostAssemblyStore * This,
            /* [in] */ AssemblyBindInfo *pBindInfo,
            /* [out] */ UINT64 *pAssemblyId,
            /* [out] */ UINT64 *pContext,
            /* [out] */ IStream **ppStmAssemblyImage,
            /* [out] */ IStream **ppStmPDB);
        
        HRESULT ( STDMETHODCALLTYPE *ProvideModule )( 
            IHostAssemblyStore * This,
            /* [in] */ ModuleBindInfo *pBindInfo,
            /* [out] */ DWORD *pdwModuleId,
            /* [out] */ IStream **ppStmModuleImage,
            /* [out] */ IStream **ppStmPDB);
        
        END_INTERFACE
    } IHostAssemblyStoreVtbl;

    interface IHostAssemblyStore
    {
        CONST_VTBL struct IHostAssemblyStoreVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostAssemblyStore_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostAssemblyStore_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostAssemblyStore_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostAssemblyStore_ProvideAssembly(This,pBindInfo,pAssemblyId,pContext,ppStmAssemblyImage,ppStmPDB)	\
    (This)->lpVtbl -> ProvideAssembly(This,pBindInfo,pAssemblyId,pContext,ppStmAssemblyImage,ppStmPDB)

#define IHostAssemblyStore_ProvideModule(This,pBindInfo,pdwModuleId,ppStmModuleImage,ppStmPDB)	\
    (This)->lpVtbl -> ProvideModule(This,pBindInfo,pdwModuleId,ppStmModuleImage,ppStmPDB)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostAssemblyStore_ProvideAssembly_Proxy( 
    IHostAssemblyStore * This,
    /* [in] */ AssemblyBindInfo *pBindInfo,
    /* [out] */ UINT64 *pAssemblyId,
    /* [out] */ UINT64 *pContext,
    /* [out] */ IStream **ppStmAssemblyImage,
    /* [out] */ IStream **ppStmPDB);


void __RPC_STUB IHostAssemblyStore_ProvideAssembly_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostAssemblyStore_ProvideModule_Proxy( 
    IHostAssemblyStore * This,
    /* [in] */ ModuleBindInfo *pBindInfo,
    /* [out] */ DWORD *pdwModuleId,
    /* [out] */ IStream **ppStmModuleImage,
    /* [out] */ IStream **ppStmPDB);


void __RPC_STUB IHostAssemblyStore_ProvideModule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostAssemblyStore_INTERFACE_DEFINED__ */


#ifndef __IHostAssemblyManager_INTERFACE_DEFINED__
#define __IHostAssemblyManager_INTERFACE_DEFINED__

/* interface IHostAssemblyManager */
/* [unique][helpstring][uuid][version][object][local] */ 


EXTERN_C const IID IID_IHostAssemblyManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("613dabd7-62b2-493e-9e65-c1e32a1e0c5e")
    IHostAssemblyManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNonHostStoreAssemblies( 
            /* [out] */ ICLRAssemblyReferenceList **ppReferenceList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyStore( 
            /* [out] */ IHostAssemblyStore **ppAssemblyStore) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostAssemblyManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostAssemblyManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostAssemblyManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostAssemblyManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNonHostStoreAssemblies )( 
            IHostAssemblyManager * This,
            /* [out] */ ICLRAssemblyReferenceList **ppReferenceList);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyStore )( 
            IHostAssemblyManager * This,
            /* [out] */ IHostAssemblyStore **ppAssemblyStore);
        
        END_INTERFACE
    } IHostAssemblyManagerVtbl;

    interface IHostAssemblyManager
    {
        CONST_VTBL struct IHostAssemblyManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostAssemblyManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostAssemblyManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostAssemblyManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostAssemblyManager_GetNonHostStoreAssemblies(This,ppReferenceList)	\
    (This)->lpVtbl -> GetNonHostStoreAssemblies(This,ppReferenceList)

#define IHostAssemblyManager_GetAssemblyStore(This,ppAssemblyStore)	\
    (This)->lpVtbl -> GetAssemblyStore(This,ppAssemblyStore)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostAssemblyManager_GetNonHostStoreAssemblies_Proxy( 
    IHostAssemblyManager * This,
    /* [out] */ ICLRAssemblyReferenceList **ppReferenceList);


void __RPC_STUB IHostAssemblyManager_GetNonHostStoreAssemblies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostAssemblyManager_GetAssemblyStore_Proxy( 
    IHostAssemblyManager * This,
    /* [out] */ IHostAssemblyStore **ppAssemblyStore);


void __RPC_STUB IHostAssemblyManager_GetAssemblyStore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostAssemblyManager_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0164 */
/* [local] */ 

STDAPI GetCLRIdentityManager(REFIID riid, IUnknown **ppManager);
EXTERN_GUID(IID_IHostControl, 0x02CA073C, 0x7079, 0x4860, 0x88, 0x0A, 0xC2, 0xF7, 0xA4, 0x49, 0xC9, 0x91);


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0164_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0164_v0_0_s_ifspec;

#ifndef __IHostControl_INTERFACE_DEFINED__
#define __IHostControl_INTERFACE_DEFINED__

/* interface IHostControl */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_IHostControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("02CA073C-7079-4860-880A-C2F7A449C991")
    IHostControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetHostManager( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAppDomainManager( 
            /* [in] */ DWORD dwAppDomainID,
            /* [in] */ IUnknown *pUnkAppDomainManager) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetHostManager )( 
            IHostControl * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppDomainManager )( 
            IHostControl * This,
            /* [in] */ DWORD dwAppDomainID,
            /* [in] */ IUnknown *pUnkAppDomainManager);
        
        END_INTERFACE
    } IHostControlVtbl;

    interface IHostControl
    {
        CONST_VTBL struct IHostControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostControl_GetHostManager(This,riid,ppObject)	\
    (This)->lpVtbl -> GetHostManager(This,riid,ppObject)

#define IHostControl_SetAppDomainManager(This,dwAppDomainID,pUnkAppDomainManager)	\
    (This)->lpVtbl -> SetAppDomainManager(This,dwAppDomainID,pUnkAppDomainManager)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostControl_GetHostManager_Proxy( 
    IHostControl * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppObject);


void __RPC_STUB IHostControl_GetHostManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostControl_SetAppDomainManager_Proxy( 
    IHostControl * This,
    /* [in] */ DWORD dwAppDomainID,
    /* [in] */ IUnknown *pUnkAppDomainManager);


void __RPC_STUB IHostControl_SetAppDomainManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostControl_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0165 */
/* [local] */ 

EXTERN_GUID(IID_ICLRControl, 0x9065597E, 0xD1A1, 0x4fb2, 0xB6, 0xBA, 0x7E, 0x1F, 0xCE, 0x23, 0x0F, 0x61);


extern RPC_IF_HANDLE __MIDL_itf_mscoree_0165_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0165_v0_0_s_ifspec;

#ifndef __ICLRControl_INTERFACE_DEFINED__
#define __ICLRControl_INTERFACE_DEFINED__

/* interface ICLRControl */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRControl;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9065597E-D1A1-4fb2-B6BA-7E1FCE230F61")
    ICLRControl : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCLRManager( 
            /* [in] */ REFIID riid,
            /* [out] */ void **ppObject) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAppDomainManagerType( 
            /* [in] */ LPCWSTR pwzAppDomainManagerAssembly,
            /* [in] */ LPCWSTR pwzAppDomainManagerType) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRControlVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRControl * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRControl * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRControl * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLRManager )( 
            ICLRControl * This,
            /* [in] */ REFIID riid,
            /* [out] */ void **ppObject);
        
        HRESULT ( STDMETHODCALLTYPE *SetAppDomainManagerType )( 
            ICLRControl * This,
            /* [in] */ LPCWSTR pwzAppDomainManagerAssembly,
            /* [in] */ LPCWSTR pwzAppDomainManagerType);
        
        END_INTERFACE
    } ICLRControlVtbl;

    interface ICLRControl
    {
        CONST_VTBL struct ICLRControlVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRControl_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRControl_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRControl_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRControl_GetCLRManager(This,riid,ppObject)	\
    (This)->lpVtbl -> GetCLRManager(This,riid,ppObject)

#define ICLRControl_SetAppDomainManagerType(This,pwzAppDomainManagerAssembly,pwzAppDomainManagerType)	\
    (This)->lpVtbl -> SetAppDomainManagerType(This,pwzAppDomainManagerAssembly,pwzAppDomainManagerType)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRControl_GetCLRManager_Proxy( 
    ICLRControl * This,
    /* [in] */ REFIID riid,
    /* [out] */ void **ppObject);


void __RPC_STUB ICLRControl_GetCLRManager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRControl_SetAppDomainManagerType_Proxy( 
    ICLRControl * This,
    /* [in] */ LPCWSTR pwzAppDomainManagerAssembly,
    /* [in] */ LPCWSTR pwzAppDomainManagerType);


void __RPC_STUB ICLRControl_SetAppDomainManagerType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRControl_INTERFACE_DEFINED__ */


#ifndef __ICLRRuntimeHost_INTERFACE_DEFINED__
#define __ICLRRuntimeHost_INTERFACE_DEFINED__

/* interface ICLRRuntimeHost */
/* [object][local][unique][helpstring][version][uuid] */ 


EXTERN_C const IID IID_ICLRRuntimeHost;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("90F1A06C-7712-4762-86B5-7A5EBA6BDB02")
    ICLRRuntimeHost : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHostControl( 
            /* [in] */ IHostControl *pHostControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCLRControl( 
            /* [out] */ ICLRControl **pCLRControl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnloadAppDomain( 
            /* [in] */ DWORD dwAppDomainId,
            /* [in] */ BOOL fWaitUntilDone) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteInAppDomain( 
            /* [in] */ DWORD dwAppDomainId,
            /* [in] */ FExecuteInAppDomainCallback pCallback,
            /* [in] */ void *cookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentAppDomainId( 
            /* [out] */ DWORD *pdwAppDomainId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteApplication( 
            /* [in] */ LPCWSTR pwzAppFullName,
            /* [in] */ DWORD dwManifestPaths,
            /* [in] */ LPCWSTR *ppwzManifestPaths,
            /* [in] */ DWORD dwActivationData,
            /* [in] */ LPCWSTR *ppwzActivationData,
            /* [out] */ int *pReturnValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecuteInDefaultAppDomain( 
            /* [in] */ LPCWSTR pwzAssemblyPath,
            /* [in] */ LPCWSTR pwzTypeName,
            /* [in] */ LPCWSTR pwzMethodName,
            /* [in] */ LPCWSTR pwzArgument,
            /* [out] */ DWORD *pReturnValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRRuntimeHostVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRRuntimeHost * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRRuntimeHost * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            ICLRRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *Stop )( 
            ICLRRuntimeHost * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetHostControl )( 
            ICLRRuntimeHost * This,
            /* [in] */ IHostControl *pHostControl);
        
        HRESULT ( STDMETHODCALLTYPE *GetCLRControl )( 
            ICLRRuntimeHost * This,
            /* [out] */ ICLRControl **pCLRControl);
        
        HRESULT ( STDMETHODCALLTYPE *UnloadAppDomain )( 
            ICLRRuntimeHost * This,
            /* [in] */ DWORD dwAppDomainId,
            /* [in] */ BOOL fWaitUntilDone);
        
        HRESULT ( STDMETHODCALLTYPE *ExecuteInAppDomain )( 
            ICLRRuntimeHost * This,
            /* [in] */ DWORD dwAppDomainId,
            /* [in] */ FExecuteInAppDomainCallback pCallback,
            /* [in] */ void *cookie);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentAppDomainId )( 
            ICLRRuntimeHost * This,
            /* [out] */ DWORD *pdwAppDomainId);
        
        HRESULT ( STDMETHODCALLTYPE *ExecuteApplication )( 
            ICLRRuntimeHost * This,
            /* [in] */ LPCWSTR pwzAppFullName,
            /* [in] */ DWORD dwManifestPaths,
            /* [in] */ LPCWSTR *ppwzManifestPaths,
            /* [in] */ DWORD dwActivationData,
            /* [in] */ LPCWSTR *ppwzActivationData,
            /* [out] */ int *pReturnValue);
        
        HRESULT ( STDMETHODCALLTYPE *ExecuteInDefaultAppDomain )( 
            ICLRRuntimeHost * This,
            /* [in] */ LPCWSTR pwzAssemblyPath,
            /* [in] */ LPCWSTR pwzTypeName,
            /* [in] */ LPCWSTR pwzMethodName,
            /* [in] */ LPCWSTR pwzArgument,
            /* [out] */ DWORD *pReturnValue);
        
        END_INTERFACE
    } ICLRRuntimeHostVtbl;

    interface ICLRRuntimeHost
    {
        CONST_VTBL struct ICLRRuntimeHostVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRRuntimeHost_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRRuntimeHost_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRRuntimeHost_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRRuntimeHost_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define ICLRRuntimeHost_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define ICLRRuntimeHost_SetHostControl(This,pHostControl)	\
    (This)->lpVtbl -> SetHostControl(This,pHostControl)

#define ICLRRuntimeHost_GetCLRControl(This,pCLRControl)	\
    (This)->lpVtbl -> GetCLRControl(This,pCLRControl)

#define ICLRRuntimeHost_UnloadAppDomain(This,dwAppDomainId,fWaitUntilDone)	\
    (This)->lpVtbl -> UnloadAppDomain(This,dwAppDomainId,fWaitUntilDone)

#define ICLRRuntimeHost_ExecuteInAppDomain(This,dwAppDomainId,pCallback,cookie)	\
    (This)->lpVtbl -> ExecuteInAppDomain(This,dwAppDomainId,pCallback,cookie)

#define ICLRRuntimeHost_GetCurrentAppDomainId(This,pdwAppDomainId)	\
    (This)->lpVtbl -> GetCurrentAppDomainId(This,pdwAppDomainId)

#define ICLRRuntimeHost_ExecuteApplication(This,pwzAppFullName,dwManifestPaths,ppwzManifestPaths,dwActivationData,ppwzActivationData,pReturnValue)	\
    (This)->lpVtbl -> ExecuteApplication(This,pwzAppFullName,dwManifestPaths,ppwzManifestPaths,dwActivationData,ppwzActivationData,pReturnValue)

#define ICLRRuntimeHost_ExecuteInDefaultAppDomain(This,pwzAssemblyPath,pwzTypeName,pwzMethodName,pwzArgument,pReturnValue)	\
    (This)->lpVtbl -> ExecuteInDefaultAppDomain(This,pwzAssemblyPath,pwzTypeName,pwzMethodName,pwzArgument,pReturnValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRRuntimeHost_Start_Proxy( 
    ICLRRuntimeHost * This);


void __RPC_STUB ICLRRuntimeHost_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRRuntimeHost_Stop_Proxy( 
    ICLRRuntimeHost * This);


void __RPC_STUB ICLRRuntimeHost_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRRuntimeHost_SetHostControl_Proxy( 
    ICLRRuntimeHost * This,
    /* [in] */ IHostControl *pHostControl);


void __RPC_STUB ICLRRuntimeHost_SetHostControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRRuntimeHost_GetCLRControl_Proxy( 
    ICLRRuntimeHost * This,
    /* [out] */ ICLRControl **pCLRControl);


void __RPC_STUB ICLRRuntimeHost_GetCLRControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRRuntimeHost_UnloadAppDomain_Proxy( 
    ICLRRuntimeHost * This,
    /* [in] */ DWORD dwAppDomainId,
    /* [in] */ BOOL fWaitUntilDone);


void __RPC_STUB ICLRRuntimeHost_UnloadAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRRuntimeHost_ExecuteInAppDomain_Proxy( 
    ICLRRuntimeHost * This,
    /* [in] */ DWORD dwAppDomainId,
    /* [in] */ FExecuteInAppDomainCallback pCallback,
    /* [in] */ void *cookie);


void __RPC_STUB ICLRRuntimeHost_ExecuteInAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRRuntimeHost_GetCurrentAppDomainId_Proxy( 
    ICLRRuntimeHost * This,
    /* [out] */ DWORD *pdwAppDomainId);


void __RPC_STUB ICLRRuntimeHost_GetCurrentAppDomainId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRRuntimeHost_ExecuteApplication_Proxy( 
    ICLRRuntimeHost * This,
    /* [in] */ LPCWSTR pwzAppFullName,
    /* [in] */ DWORD dwManifestPaths,
    /* [in] */ LPCWSTR *ppwzManifestPaths,
    /* [in] */ DWORD dwActivationData,
    /* [in] */ LPCWSTR *ppwzActivationData,
    /* [out] */ int *pReturnValue);


void __RPC_STUB ICLRRuntimeHost_ExecuteApplication_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRRuntimeHost_ExecuteInDefaultAppDomain_Proxy( 
    ICLRRuntimeHost * This,
    /* [in] */ LPCWSTR pwzAssemblyPath,
    /* [in] */ LPCWSTR pwzTypeName,
    /* [in] */ LPCWSTR pwzMethodName,
    /* [in] */ LPCWSTR pwzArgument,
    /* [out] */ DWORD *pReturnValue);


void __RPC_STUB ICLRRuntimeHost_ExecuteInDefaultAppDomain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRRuntimeHost_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_mscoree_0167 */
/* [local] */ 

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_mscoree_0167_0001
    {	eNoChecks	= 0,
	eSynchronization	= 0x1,
	eSharedState	= 0x2,
	eExternalProcessMgmt	= 0x4,
	eSelfAffectingProcessMgmt	= 0x8,
	eExternalThreading	= 0x10,
	eSelfAffectingThreading	= 0x20,
	eSecurityInfrastructure	= 0x40,
	eUI	= 0x80,
	eMayLeakOnAbort	= 0x100,
	eAll	= 0x1ff
    } 	EApiCategories;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0167_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0167_v0_0_s_ifspec;

#ifndef __ICLRHostProtectionManager_INTERFACE_DEFINED__
#define __ICLRHostProtectionManager_INTERFACE_DEFINED__

/* interface ICLRHostProtectionManager */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_ICLRHostProtectionManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("89F25F5C-CEEF-43e1-9CFA-A68CE863AAAC")
    ICLRHostProtectionManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetProtectedCategories( 
            /* [in] */ EApiCategories categories) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetEagerSerializeGrantSets( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRHostProtectionManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRHostProtectionManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRHostProtectionManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRHostProtectionManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *SetProtectedCategories )( 
            ICLRHostProtectionManager * This,
            /* [in] */ EApiCategories categories);
        
        HRESULT ( STDMETHODCALLTYPE *SetEagerSerializeGrantSets )( 
            ICLRHostProtectionManager * This);
        
        END_INTERFACE
    } ICLRHostProtectionManagerVtbl;

    interface ICLRHostProtectionManager
    {
        CONST_VTBL struct ICLRHostProtectionManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRHostProtectionManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRHostProtectionManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRHostProtectionManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRHostProtectionManager_SetProtectedCategories(This,categories)	\
    (This)->lpVtbl -> SetProtectedCategories(This,categories)

#define ICLRHostProtectionManager_SetEagerSerializeGrantSets(This)	\
    (This)->lpVtbl -> SetEagerSerializeGrantSets(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRHostProtectionManager_SetProtectedCategories_Proxy( 
    ICLRHostProtectionManager * This,
    /* [in] */ EApiCategories categories);


void __RPC_STUB ICLRHostProtectionManager_SetProtectedCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRHostProtectionManager_SetEagerSerializeGrantSets_Proxy( 
    ICLRHostProtectionManager * This);


void __RPC_STUB ICLRHostProtectionManager_SetEagerSerializeGrantSets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRHostProtectionManager_INTERFACE_DEFINED__ */



#ifndef __mscoree_LIBRARY_DEFINED__
#define __mscoree_LIBRARY_DEFINED__

/* library mscoree */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_mscoree;

#ifndef __ITypeName_INTERFACE_DEFINED__
#define __ITypeName_INTERFACE_DEFINED__

/* interface ITypeName */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_ITypeName;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B81FF171-20F3-11d2-8DCC-00A0C9B00522")
    ITypeName : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetNameCount( 
            /* [retval][out] */ DWORD *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetNames( 
            /* [in] */ DWORD count,
            /* [out] */ BSTR *rgbszNames,
            /* [retval][out] */ DWORD *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeArgumentCount( 
            /* [retval][out] */ DWORD *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeArguments( 
            /* [in] */ DWORD count,
            /* [out] */ ITypeName **rgpArguments,
            /* [retval][out] */ DWORD *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModifierLength( 
            /* [retval][out] */ DWORD *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetModifiers( 
            /* [in] */ DWORD count,
            /* [out] */ DWORD *rgModifiers,
            /* [retval][out] */ DWORD *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAssemblyName( 
            /* [retval][out] */ BSTR *rgbszAssemblyNames) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeNameVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITypeName * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITypeName * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITypeName * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetNameCount )( 
            ITypeName * This,
            /* [retval][out] */ DWORD *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetNames )( 
            ITypeName * This,
            /* [in] */ DWORD count,
            /* [out] */ BSTR *rgbszNames,
            /* [retval][out] */ DWORD *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeArgumentCount )( 
            ITypeName * This,
            /* [retval][out] */ DWORD *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeArguments )( 
            ITypeName * This,
            /* [in] */ DWORD count,
            /* [out] */ ITypeName **rgpArguments,
            /* [retval][out] */ DWORD *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetModifierLength )( 
            ITypeName * This,
            /* [retval][out] */ DWORD *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetModifiers )( 
            ITypeName * This,
            /* [in] */ DWORD count,
            /* [out] */ DWORD *rgModifiers,
            /* [retval][out] */ DWORD *pCount);
        
        HRESULT ( STDMETHODCALLTYPE *GetAssemblyName )( 
            ITypeName * This,
            /* [retval][out] */ BSTR *rgbszAssemblyNames);
        
        END_INTERFACE
    } ITypeNameVtbl;

    interface ITypeName
    {
        CONST_VTBL struct ITypeNameVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeName_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeName_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeName_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeName_GetNameCount(This,pCount)	\
    (This)->lpVtbl -> GetNameCount(This,pCount)

#define ITypeName_GetNames(This,count,rgbszNames,pCount)	\
    (This)->lpVtbl -> GetNames(This,count,rgbszNames,pCount)

#define ITypeName_GetTypeArgumentCount(This,pCount)	\
    (This)->lpVtbl -> GetTypeArgumentCount(This,pCount)

#define ITypeName_GetTypeArguments(This,count,rgpArguments,pCount)	\
    (This)->lpVtbl -> GetTypeArguments(This,count,rgpArguments,pCount)

#define ITypeName_GetModifierLength(This,pCount)	\
    (This)->lpVtbl -> GetModifierLength(This,pCount)

#define ITypeName_GetModifiers(This,count,rgModifiers,pCount)	\
    (This)->lpVtbl -> GetModifiers(This,count,rgModifiers,pCount)

#define ITypeName_GetAssemblyName(This,rgbszAssemblyNames)	\
    (This)->lpVtbl -> GetAssemblyName(This,rgbszAssemblyNames)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITypeName_GetNameCount_Proxy( 
    ITypeName * This,
    /* [retval][out] */ DWORD *pCount);


void __RPC_STUB ITypeName_GetNameCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeName_GetNames_Proxy( 
    ITypeName * This,
    /* [in] */ DWORD count,
    /* [out] */ BSTR *rgbszNames,
    /* [retval][out] */ DWORD *pCount);


void __RPC_STUB ITypeName_GetNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeName_GetTypeArgumentCount_Proxy( 
    ITypeName * This,
    /* [retval][out] */ DWORD *pCount);


void __RPC_STUB ITypeName_GetTypeArgumentCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeName_GetTypeArguments_Proxy( 
    ITypeName * This,
    /* [in] */ DWORD count,
    /* [out] */ ITypeName **rgpArguments,
    /* [retval][out] */ DWORD *pCount);


void __RPC_STUB ITypeName_GetTypeArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeName_GetModifierLength_Proxy( 
    ITypeName * This,
    /* [retval][out] */ DWORD *pCount);


void __RPC_STUB ITypeName_GetModifierLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeName_GetModifiers_Proxy( 
    ITypeName * This,
    /* [in] */ DWORD count,
    /* [out] */ DWORD *rgModifiers,
    /* [retval][out] */ DWORD *pCount);


void __RPC_STUB ITypeName_GetModifiers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeName_GetAssemblyName_Proxy( 
    ITypeName * This,
    /* [retval][out] */ BSTR *rgbszAssemblyNames);


void __RPC_STUB ITypeName_GetAssemblyName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeName_INTERFACE_DEFINED__ */


#ifndef __ITypeNameBuilder_INTERFACE_DEFINED__
#define __ITypeNameBuilder_INTERFACE_DEFINED__

/* interface ITypeNameBuilder */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_ITypeNameBuilder;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B81FF171-20F3-11d2-8DCC-00A0C9B00523")
    ITypeNameBuilder : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OpenGenericArguments( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseGenericArguments( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenGenericArgument( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseGenericArgument( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddName( 
            /* [in] */ LPCWSTR szName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddPointer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddByRef( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddSzArray( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddArray( 
            /* [in] */ DWORD rank) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddAssemblySpec( 
            /* [in] */ LPCWSTR szAssemblySpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToString( 
            /* [retval][out] */ BSTR *pszStringRepresentation) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeNameBuilderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITypeNameBuilder * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITypeNameBuilder * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITypeNameBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenGenericArguments )( 
            ITypeNameBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *CloseGenericArguments )( 
            ITypeNameBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenGenericArgument )( 
            ITypeNameBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *CloseGenericArgument )( 
            ITypeNameBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddName )( 
            ITypeNameBuilder * This,
            /* [in] */ LPCWSTR szName);
        
        HRESULT ( STDMETHODCALLTYPE *AddPointer )( 
            ITypeNameBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddByRef )( 
            ITypeNameBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddSzArray )( 
            ITypeNameBuilder * This);
        
        HRESULT ( STDMETHODCALLTYPE *AddArray )( 
            ITypeNameBuilder * This,
            /* [in] */ DWORD rank);
        
        HRESULT ( STDMETHODCALLTYPE *AddAssemblySpec )( 
            ITypeNameBuilder * This,
            /* [in] */ LPCWSTR szAssemblySpec);
        
        HRESULT ( STDMETHODCALLTYPE *ToString )( 
            ITypeNameBuilder * This,
            /* [retval][out] */ BSTR *pszStringRepresentation);
        
        HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ITypeNameBuilder * This);
        
        END_INTERFACE
    } ITypeNameBuilderVtbl;

    interface ITypeNameBuilder
    {
        CONST_VTBL struct ITypeNameBuilderVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeNameBuilder_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeNameBuilder_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeNameBuilder_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeNameBuilder_OpenGenericArguments(This)	\
    (This)->lpVtbl -> OpenGenericArguments(This)

#define ITypeNameBuilder_CloseGenericArguments(This)	\
    (This)->lpVtbl -> CloseGenericArguments(This)

#define ITypeNameBuilder_OpenGenericArgument(This)	\
    (This)->lpVtbl -> OpenGenericArgument(This)

#define ITypeNameBuilder_CloseGenericArgument(This)	\
    (This)->lpVtbl -> CloseGenericArgument(This)

#define ITypeNameBuilder_AddName(This,szName)	\
    (This)->lpVtbl -> AddName(This,szName)

#define ITypeNameBuilder_AddPointer(This)	\
    (This)->lpVtbl -> AddPointer(This)

#define ITypeNameBuilder_AddByRef(This)	\
    (This)->lpVtbl -> AddByRef(This)

#define ITypeNameBuilder_AddSzArray(This)	\
    (This)->lpVtbl -> AddSzArray(This)

#define ITypeNameBuilder_AddArray(This,rank)	\
    (This)->lpVtbl -> AddArray(This,rank)

#define ITypeNameBuilder_AddAssemblySpec(This,szAssemblySpec)	\
    (This)->lpVtbl -> AddAssemblySpec(This,szAssemblySpec)

#define ITypeNameBuilder_ToString(This,pszStringRepresentation)	\
    (This)->lpVtbl -> ToString(This,pszStringRepresentation)

#define ITypeNameBuilder_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITypeNameBuilder_OpenGenericArguments_Proxy( 
    ITypeNameBuilder * This);


void __RPC_STUB ITypeNameBuilder_OpenGenericArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeNameBuilder_CloseGenericArguments_Proxy( 
    ITypeNameBuilder * This);


void __RPC_STUB ITypeNameBuilder_CloseGenericArguments_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeNameBuilder_OpenGenericArgument_Proxy( 
    ITypeNameBuilder * This);


void __RPC_STUB ITypeNameBuilder_OpenGenericArgument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeNameBuilder_CloseGenericArgument_Proxy( 
    ITypeNameBuilder * This);


void __RPC_STUB ITypeNameBuilder_CloseGenericArgument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeNameBuilder_AddName_Proxy( 
    ITypeNameBuilder * This,
    /* [in] */ LPCWSTR szName);


void __RPC_STUB ITypeNameBuilder_AddName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeNameBuilder_AddPointer_Proxy( 
    ITypeNameBuilder * This);


void __RPC_STUB ITypeNameBuilder_AddPointer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeNameBuilder_AddByRef_Proxy( 
    ITypeNameBuilder * This);


void __RPC_STUB ITypeNameBuilder_AddByRef_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeNameBuilder_AddSzArray_Proxy( 
    ITypeNameBuilder * This);


void __RPC_STUB ITypeNameBuilder_AddSzArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeNameBuilder_AddArray_Proxy( 
    ITypeNameBuilder * This,
    /* [in] */ DWORD rank);


void __RPC_STUB ITypeNameBuilder_AddArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeNameBuilder_AddAssemblySpec_Proxy( 
    ITypeNameBuilder * This,
    /* [in] */ LPCWSTR szAssemblySpec);


void __RPC_STUB ITypeNameBuilder_AddAssemblySpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeNameBuilder_ToString_Proxy( 
    ITypeNameBuilder * This,
    /* [retval][out] */ BSTR *pszStringRepresentation);


void __RPC_STUB ITypeNameBuilder_ToString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeNameBuilder_Clear_Proxy( 
    ITypeNameBuilder * This);


void __RPC_STUB ITypeNameBuilder_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeNameBuilder_INTERFACE_DEFINED__ */


#ifndef __ITypeNameFactory_INTERFACE_DEFINED__
#define __ITypeNameFactory_INTERFACE_DEFINED__

/* interface ITypeNameFactory */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_ITypeNameFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("B81FF171-20F3-11d2-8DCC-00A0C9B00521")
    ITypeNameFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ParseTypeName( 
            /* [in] */ LPCWSTR szName,
            /* [out] */ DWORD *pError,
            /* [retval][out] */ ITypeName **ppTypeName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTypeNameBuilder( 
            /* [retval][out] */ ITypeNameBuilder **ppTypeBuilder) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ITypeNameFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ITypeNameFactory * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ITypeNameFactory * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ITypeNameFactory * This);
        
        HRESULT ( STDMETHODCALLTYPE *ParseTypeName )( 
            ITypeNameFactory * This,
            /* [in] */ LPCWSTR szName,
            /* [out] */ DWORD *pError,
            /* [retval][out] */ ITypeName **ppTypeName);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeNameBuilder )( 
            ITypeNameFactory * This,
            /* [retval][out] */ ITypeNameBuilder **ppTypeBuilder);
        
        END_INTERFACE
    } ITypeNameFactoryVtbl;

    interface ITypeNameFactory
    {
        CONST_VTBL struct ITypeNameFactoryVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ITypeNameFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITypeNameFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITypeNameFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITypeNameFactory_ParseTypeName(This,szName,pError,ppTypeName)	\
    (This)->lpVtbl -> ParseTypeName(This,szName,pError,ppTypeName)

#define ITypeNameFactory_GetTypeNameBuilder(This,ppTypeBuilder)	\
    (This)->lpVtbl -> GetTypeNameBuilder(This,ppTypeBuilder)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ITypeNameFactory_ParseTypeName_Proxy( 
    ITypeNameFactory * This,
    /* [in] */ LPCWSTR szName,
    /* [out] */ DWORD *pError,
    /* [retval][out] */ ITypeName **ppTypeName);


void __RPC_STUB ITypeNameFactory_ParseTypeName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ITypeNameFactory_GetTypeNameBuilder_Proxy( 
    ITypeNameFactory * This,
    /* [retval][out] */ ITypeNameBuilder **ppTypeBuilder);


void __RPC_STUB ITypeNameFactory_GetTypeNameBuilder_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITypeNameFactory_INTERFACE_DEFINED__ */


#ifndef __IApartmentCallback_INTERFACE_DEFINED__
#define __IApartmentCallback_INTERFACE_DEFINED__

/* interface IApartmentCallback */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IApartmentCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("178E5337-1528-4591-B1C9-1C6E484686D8")
    IApartmentCallback : public IUnknown
    {
    public:
        virtual HRESULT __stdcall DoCallback( 
            /* [in] */ SIZE_T pFunc,
            /* [in] */ SIZE_T pData) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApartmentCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IApartmentCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IApartmentCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IApartmentCallback * This);
        
        HRESULT ( __stdcall *DoCallback )( 
            IApartmentCallback * This,
            /* [in] */ SIZE_T pFunc,
            /* [in] */ SIZE_T pData);
        
        END_INTERFACE
    } IApartmentCallbackVtbl;

    interface IApartmentCallback
    {
        CONST_VTBL struct IApartmentCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApartmentCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApartmentCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApartmentCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApartmentCallback_DoCallback(This,pFunc,pData)	\
    (This)->lpVtbl -> DoCallback(This,pFunc,pData)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IApartmentCallback_DoCallback_Proxy( 
    IApartmentCallback * This,
    /* [in] */ SIZE_T pFunc,
    /* [in] */ SIZE_T pData);


void __RPC_STUB IApartmentCallback_DoCallback_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApartmentCallback_INTERFACE_DEFINED__ */


#ifndef __IManagedObject_INTERFACE_DEFINED__
#define __IManagedObject_INTERFACE_DEFINED__

/* interface IManagedObject */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_IManagedObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("C3FCC19E-A970-11d2-8B5A-00A0C9B7C9C4")
    IManagedObject : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSerializedBuffer( 
            /* [out] */ BSTR *pBSTR) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectIdentity( 
            /* [out] */ BSTR *pBSTRGUID,
            /* [out] */ int *AppDomainID,
            /* [out] */ int *pCCW) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManagedObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IManagedObject * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IManagedObject * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IManagedObject * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSerializedBuffer )( 
            IManagedObject * This,
            /* [out] */ BSTR *pBSTR);
        
        HRESULT ( STDMETHODCALLTYPE *GetObjectIdentity )( 
            IManagedObject * This,
            /* [out] */ BSTR *pBSTRGUID,
            /* [out] */ int *AppDomainID,
            /* [out] */ int *pCCW);
        
        END_INTERFACE
    } IManagedObjectVtbl;

    interface IManagedObject
    {
        CONST_VTBL struct IManagedObjectVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManagedObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IManagedObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IManagedObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IManagedObject_GetSerializedBuffer(This,pBSTR)	\
    (This)->lpVtbl -> GetSerializedBuffer(This,pBSTR)

#define IManagedObject_GetObjectIdentity(This,pBSTRGUID,AppDomainID,pCCW)	\
    (This)->lpVtbl -> GetObjectIdentity(This,pBSTRGUID,AppDomainID,pCCW)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IManagedObject_GetSerializedBuffer_Proxy( 
    IManagedObject * This,
    /* [out] */ BSTR *pBSTR);


void __RPC_STUB IManagedObject_GetSerializedBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IManagedObject_GetObjectIdentity_Proxy( 
    IManagedObject * This,
    /* [out] */ BSTR *pBSTRGUID,
    /* [out] */ int *AppDomainID,
    /* [out] */ int *pCCW);


void __RPC_STUB IManagedObject_GetObjectIdentity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IManagedObject_INTERFACE_DEFINED__ */


#ifndef __ICatalogServices_INTERFACE_DEFINED__
#define __ICatalogServices_INTERFACE_DEFINED__

/* interface ICatalogServices */
/* [unique][helpstring][uuid][oleautomation][object] */ 


EXTERN_C const IID IID_ICatalogServices;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("04C6BE1E-1DB1-4058-AB7A-700CCCFBF254")
    ICatalogServices : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Autodone( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotAutodone( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatalogServicesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICatalogServices * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICatalogServices * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICatalogServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *Autodone )( 
            ICatalogServices * This);
        
        HRESULT ( STDMETHODCALLTYPE *NotAutodone )( 
            ICatalogServices * This);
        
        END_INTERFACE
    } ICatalogServicesVtbl;

    interface ICatalogServices
    {
        CONST_VTBL struct ICatalogServicesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatalogServices_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatalogServices_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatalogServices_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatalogServices_Autodone(This)	\
    (This)->lpVtbl -> Autodone(This)

#define ICatalogServices_NotAutodone(This)	\
    (This)->lpVtbl -> NotAutodone(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatalogServices_Autodone_Proxy( 
    ICatalogServices * This);


void __RPC_STUB ICatalogServices_Autodone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatalogServices_NotAutodone_Proxy( 
    ICatalogServices * This);


void __RPC_STUB ICatalogServices_NotAutodone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatalogServices_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_ComCallUnmarshal;

#ifdef __cplusplus

class DECLSPEC_UUID("3F281000-E95A-11d2-886B-00C04F869F04")
ComCallUnmarshal;
#endif

EXTERN_C const CLSID CLSID_CorRuntimeHost;

#ifdef __cplusplus

class DECLSPEC_UUID("CB2F6723-AB3A-11d2-9C40-00C04FA30A3E")
CorRuntimeHost;
#endif

EXTERN_C const CLSID CLSID_CLRRuntimeHost;

#ifdef __cplusplus

class DECLSPEC_UUID("90F1A06E-7712-4762-86B5-7A5EBA6BDB02")
CLRRuntimeHost;
#endif

EXTERN_C const CLSID CLSID_TypeNameFactory;

#ifdef __cplusplus

class DECLSPEC_UUID("B81FF171-20F3-11d2-8DCC-00A0C9B00525")
TypeNameFactory;
#endif
#endif /* __mscoree_LIBRARY_DEFINED__ */

/* interface __MIDL_itf_mscoree_0174 */
/* [local] */ 

typedef /* [public][public][public] */ 
enum __MIDL___MIDL_itf_mscoree_0174_0001
    {	eCurrentContext	= 0,
	eRestrictedContext	= 0x1
    } 	EContextType;



extern RPC_IF_HANDLE __MIDL_itf_mscoree_0174_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_mscoree_0174_v0_0_s_ifspec;

#ifndef __IHostSecurityContext_INTERFACE_DEFINED__
#define __IHostSecurityContext_INTERFACE_DEFINED__

/* interface IHostSecurityContext */
/* [local][unique][helpstring][uuid][version][object] */ 


EXTERN_C const IID IID_IHostSecurityContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("7E573CE4-0343-4423-98D7-6318348A1D3C")
    IHostSecurityContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Capture( 
            /* [out] */ IHostSecurityContext **ppClonedContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostSecurityContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostSecurityContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostSecurityContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostSecurityContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Capture )( 
            IHostSecurityContext * This,
            /* [out] */ IHostSecurityContext **ppClonedContext);
        
        END_INTERFACE
    } IHostSecurityContextVtbl;

    interface IHostSecurityContext
    {
        CONST_VTBL struct IHostSecurityContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostSecurityContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostSecurityContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostSecurityContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostSecurityContext_Capture(This,ppClonedContext)	\
    (This)->lpVtbl -> Capture(This,ppClonedContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostSecurityContext_Capture_Proxy( 
    IHostSecurityContext * This,
    /* [out] */ IHostSecurityContext **ppClonedContext);


void __RPC_STUB IHostSecurityContext_Capture_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostSecurityContext_INTERFACE_DEFINED__ */


#ifndef __IHostSecurityManager_INTERFACE_DEFINED__
#define __IHostSecurityManager_INTERFACE_DEFINED__

/* interface IHostSecurityManager */
/* [local][unique][helpstring][uuid][version][object] */ 


EXTERN_C const IID IID_IHostSecurityManager;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("75ad2468-a349-4d02-a764-76a68aee0c4f")
    IHostSecurityManager : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE ImpersonateLoggedOnUser( 
            /* [in] */ HANDLE hToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevertToSelf( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenThreadToken( 
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ BOOL bOpenAsSelf,
            /* [out] */ HANDLE *phThreadToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadToken( 
            /* [in] */ HANDLE hToken) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecurityContext( 
            /* [in] */ EContextType eContextType,
            /* [out] */ IHostSecurityContext **ppSecurityContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecurityContext( 
            /* [in] */ EContextType eContextType,
            /* [in] */ IHostSecurityContext *pSecurityContext) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHostSecurityManagerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHostSecurityManager * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHostSecurityManager * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHostSecurityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *ImpersonateLoggedOnUser )( 
            IHostSecurityManager * This,
            /* [in] */ HANDLE hToken);
        
        HRESULT ( STDMETHODCALLTYPE *RevertToSelf )( 
            IHostSecurityManager * This);
        
        HRESULT ( STDMETHODCALLTYPE *OpenThreadToken )( 
            IHostSecurityManager * This,
            /* [in] */ DWORD dwDesiredAccess,
            /* [in] */ BOOL bOpenAsSelf,
            /* [out] */ HANDLE *phThreadToken);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadToken )( 
            IHostSecurityManager * This,
            /* [in] */ HANDLE hToken);
        
        HRESULT ( STDMETHODCALLTYPE *GetSecurityContext )( 
            IHostSecurityManager * This,
            /* [in] */ EContextType eContextType,
            /* [out] */ IHostSecurityContext **ppSecurityContext);
        
        HRESULT ( STDMETHODCALLTYPE *SetSecurityContext )( 
            IHostSecurityManager * This,
            /* [in] */ EContextType eContextType,
            /* [in] */ IHostSecurityContext *pSecurityContext);
        
        END_INTERFACE
    } IHostSecurityManagerVtbl;

    interface IHostSecurityManager
    {
        CONST_VTBL struct IHostSecurityManagerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHostSecurityManager_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHostSecurityManager_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHostSecurityManager_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHostSecurityManager_ImpersonateLoggedOnUser(This,hToken)	\
    (This)->lpVtbl -> ImpersonateLoggedOnUser(This,hToken)

#define IHostSecurityManager_RevertToSelf(This)	\
    (This)->lpVtbl -> RevertToSelf(This)

#define IHostSecurityManager_OpenThreadToken(This,dwDesiredAccess,bOpenAsSelf,phThreadToken)	\
    (This)->lpVtbl -> OpenThreadToken(This,dwDesiredAccess,bOpenAsSelf,phThreadToken)

#define IHostSecurityManager_SetThreadToken(This,hToken)	\
    (This)->lpVtbl -> SetThreadToken(This,hToken)

#define IHostSecurityManager_GetSecurityContext(This,eContextType,ppSecurityContext)	\
    (This)->lpVtbl -> GetSecurityContext(This,eContextType,ppSecurityContext)

#define IHostSecurityManager_SetSecurityContext(This,eContextType,pSecurityContext)	\
    (This)->lpVtbl -> SetSecurityContext(This,eContextType,pSecurityContext)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHostSecurityManager_ImpersonateLoggedOnUser_Proxy( 
    IHostSecurityManager * This,
    /* [in] */ HANDLE hToken);


void __RPC_STUB IHostSecurityManager_ImpersonateLoggedOnUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSecurityManager_RevertToSelf_Proxy( 
    IHostSecurityManager * This);


void __RPC_STUB IHostSecurityManager_RevertToSelf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSecurityManager_OpenThreadToken_Proxy( 
    IHostSecurityManager * This,
    /* [in] */ DWORD dwDesiredAccess,
    /* [in] */ BOOL bOpenAsSelf,
    /* [out] */ HANDLE *phThreadToken);


void __RPC_STUB IHostSecurityManager_OpenThreadToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSecurityManager_SetThreadToken_Proxy( 
    IHostSecurityManager * This,
    /* [in] */ HANDLE hToken);


void __RPC_STUB IHostSecurityManager_SetThreadToken_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSecurityManager_GetSecurityContext_Proxy( 
    IHostSecurityManager * This,
    /* [in] */ EContextType eContextType,
    /* [out] */ IHostSecurityContext **ppSecurityContext);


void __RPC_STUB IHostSecurityManager_GetSecurityContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHostSecurityManager_SetSecurityContext_Proxy( 
    IHostSecurityManager * This,
    /* [in] */ EContextType eContextType,
    /* [in] */ IHostSecurityContext *pSecurityContext);


void __RPC_STUB IHostSecurityManager_SetSecurityContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHostSecurityManager_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long *, unsigned long            , VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserMarshal(  unsigned long *, unsigned char *, VARIANT * ); 
unsigned char * __RPC_USER  VARIANT_UserUnmarshal(unsigned long *, unsigned char *, VARIANT * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long *, VARIANT * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\include\VerError.h ===
// ==++==
//
//   Copyright (c) Microsoft Corporation.  All rights reserved.
//
// ==--==
/**************************************************************************************
 **                                                                                  **
 ** Vererror.h - definitions of data structures, needed to report verifier errors.   **
 **                                                                                  **
 **************************************************************************************/

#ifndef __VERERROR_h__
#define __VERERROR_h__

#ifndef _VER_RAW_STRUCT_FOR_IDL_
#ifndef _JIT64_PEV_
#include "corhdr.h"
#include "openum.h"
#include "corerror.h"
#endif // !_JIT64_PEV_

// Set these flags if the error info fields are valid.

#define VER_ERR_FATAL		0x80000000L	// Cannot Continue
#define VER_ERR_OFFSET		0x00000001L
#define VER_ERR_OPCODE	  	0x00000002L
#define VER_ERR_OPERAND		0x00000004L
#define VER_ERR_TOKEN		0x00000008L
#define VER_ERR_EXCEP_NUM_1	0x00000010L
#define VER_ERR_EXCEP_NUM_2	0x00000020L
#define VER_ERR_STACK_SLOT  0x00000040L
#define VER_ERR_ITEM_1      0x00000080L
#define VER_ERR_ITEM_2      0x00000100L
#define VER_ERR_ITEM_F      0x00000200L
#define VER_ERR_ITEM_E      0x00000400L
#define VER_ERR_TYPE_1      0x00000800L
#define VER_ERR_TYPE_2      0x00001000L
#define VER_ERR_TYPE_F      0x00002000L
#define VER_ERR_TYPE_E      0x00004000L
#define VER_ERR_ADDL_MSG    0x00008000L

#define VER_ERR_SIG_MASK	0x07000000L	// Enum
#define VER_ERR_METHOD_SIG 	0x01000000L
#define VER_ERR_LOCAL_SIG  	0x02000000L
#define VER_ERR_FIELD_SIG	0x03000000L
#define VER_ERR_CALL_SIG	0x04000000L

#define VER_ERR_OPCODE_OFFSET (VER_ERR_OPCODE|VER_ERR_OFFSET)

#define VER_ERR_LOCAL_VAR   VER_ERR_LOCAL_SIG
#define VER_ERR_ARGUMENT    VER_ERR_METHOD_SIG

#define VER_ERR_ARG_RET	    0xFFFFFFFEL		// The Argument # is return
#define VER_ERR_NO_ARG	    0xFFFFFFFFL		// Argument # is not valid
#define VER_ERR_NO_LOC	    VER_ERR_NO_ARG	// Local # is not valid

typedef struct
{
	DWORD dwFlags;	// BYREF / BOXED etc.. see veritem.hpp
	void* pv;		// TypeHandle / MethodDesc * etc.
} _VerItem;

// This structure is used to fully define a verification error.
// Verification error codes are found in CorError.h
// The error resource strings are found in src/dlls/mscorrc/mscor.rc

typedef struct VerErrorStruct
{
	DWORD   dwFlags;            // VER_ERR_XXX

    union {
#ifndef _JIT64_PEV_
        OPCODE  opcode;
#endif // !_JIT64_PEV_
        unsigned long padding1; // to match with idl generated struct size
    };

    union {
        DWORD   dwOffset;       // #of bytes from start of method
        long    uOffset;        // for backward compat with Metadata validator
    };

    union {
        mdToken         token;
        mdToken         Token;  // for backward compat with metadata validator
        BYTE	        bCallConv;
        CorElementType  elem;
        DWORD           dwStackSlot; // positon in the Stack
        unsigned long   padding2;    // to match with idl generated struct size
    };

    union {
        _VerItem sItem1;
        _VerItem sItemFound;
        WCHAR* wszType1;
        WCHAR* wszTypeFound;
        DWORD dwException1;		// Exception Record #
        DWORD dwVarNumber;	    // Variable #
        DWORD dwArgNumber;	    // Argument #
        DWORD dwOperand;        // Operand for the opcode
        WCHAR* wszAdditionalMessage; // message from getlasterror
    };

    union {
        _VerItem sItem2;
        _VerItem sItemExpected;
        WCHAR* wszType2;
        WCHAR* wszTypeExpected;
        DWORD dwException2;	        // Exception Record #
    };

} VerError;

#else

// Assert that sizeof(_VerError) == sizeof(VerError) in Verifier.cpp
typedef struct tag_VerError
{
    unsigned long flags;            // DWORD
    unsigned long opcode;           // OPCODE, padded to ulong
    unsigned long uOffset;           // DWORD
    unsigned long Token;            // mdToken
    unsigned long item1_flags;      // _VerItem.DWORD
    int           *item1_data;      // _VerItem.PVOID
    unsigned long item2_flags;      // _VerItem.DWORD
    int           *item2_data;      // _VerItem.PVOID
}  _VerError;
#endif

#endif  // __VERERROR_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\CLRSDK\v2.0.50727\lib\clrdata.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0366 */
/* Compiler settings for clrdata.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#pragma warning( disable: 4049 )  /* more than 64k source lines */


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __clrdata_h__
#define __clrdata_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICLRDataTarget_FWD_DEFINED__
#define __ICLRDataTarget_FWD_DEFINED__
typedef interface ICLRDataTarget ICLRDataTarget;
#endif 	/* __ICLRDataTarget_FWD_DEFINED__ */


#ifndef __ICLRDataTarget2_FWD_DEFINED__
#define __ICLRDataTarget2_FWD_DEFINED__
typedef interface ICLRDataTarget2 ICLRDataTarget2;
#endif 	/* __ICLRDataTarget2_FWD_DEFINED__ */


#ifndef __ICLRMetadataLocator_FWD_DEFINED__
#define __ICLRMetadataLocator_FWD_DEFINED__
typedef interface ICLRMetadataLocator ICLRMetadataLocator;
#endif 	/* __ICLRMetadataLocator_FWD_DEFINED__ */


#ifndef __ICLRDataEnumMemoryRegionsCallback_FWD_DEFINED__
#define __ICLRDataEnumMemoryRegionsCallback_FWD_DEFINED__
typedef interface ICLRDataEnumMemoryRegionsCallback ICLRDataEnumMemoryRegionsCallback;
#endif 	/* __ICLRDataEnumMemoryRegionsCallback_FWD_DEFINED__ */


#ifndef __ICLRDataEnumMemoryRegions_FWD_DEFINED__
#define __ICLRDataEnumMemoryRegions_FWD_DEFINED__
typedef interface ICLRDataEnumMemoryRegions ICLRDataEnumMemoryRegions;
#endif 	/* __ICLRDataEnumMemoryRegions_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_clrdata_0000 */
/* [local] */ 






typedef ULONG64 CLRDATA_ADDRESS;

STDAPI CLRDataCreateInstance(REFIID iid, ICLRDataTarget* target, void** iface);
typedef HRESULT (STDAPICALLTYPE* PFN_CLRDataCreateInstance)(REFIID iid, ICLRDataTarget* target, void** iface);


extern RPC_IF_HANDLE __MIDL_itf_clrdata_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_clrdata_0000_v0_0_s_ifspec;

#ifndef __ICLRDataTarget_INTERFACE_DEFINED__
#define __ICLRDataTarget_INTERFACE_DEFINED__

/* interface ICLRDataTarget */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRDataTarget;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3E11CCEE-D08B-43e5-AF01-32717A64DA03")
    ICLRDataTarget : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMachineType( 
            /* [out] */ ULONG32 *machineType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPointerSize( 
            /* [out] */ ULONG32 *pointerSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImageBase( 
            /* [string][in] */ LPCWSTR imagePath,
            /* [out] */ CLRDATA_ADDRESS *baseAddress) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReadVirtual( 
            /* [in] */ CLRDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesRead) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE WriteVirtual( 
            /* [in] */ CLRDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesWritten) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetTLSValue( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [out] */ CLRDATA_ADDRESS *value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetTLSValue( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [in] */ CLRDATA_ADDRESS value) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCurrentThreadID( 
            /* [out] */ ULONG32 *threadID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadContext( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetThreadContext( 
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Request( 
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataTargetVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataTarget * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataTarget * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataTarget * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineType )( 
            ICLRDataTarget * This,
            /* [out] */ ULONG32 *machineType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointerSize )( 
            ICLRDataTarget * This,
            /* [out] */ ULONG32 *pointerSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageBase )( 
            ICLRDataTarget * This,
            /* [string][in] */ LPCWSTR imagePath,
            /* [out] */ CLRDATA_ADDRESS *baseAddress);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVirtual )( 
            ICLRDataTarget * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesRead);
        
        HRESULT ( STDMETHODCALLTYPE *WriteVirtual )( 
            ICLRDataTarget * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesWritten);
        
        HRESULT ( STDMETHODCALLTYPE *GetTLSValue )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [out] */ CLRDATA_ADDRESS *value);
        
        HRESULT ( STDMETHODCALLTYPE *SetTLSValue )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [in] */ CLRDATA_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadID )( 
            ICLRDataTarget * This,
            /* [out] */ ULONG32 *threadID);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            ICLRDataTarget * This,
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer);
        
        END_INTERFACE
    } ICLRDataTargetVtbl;

    interface ICLRDataTarget
    {
        CONST_VTBL struct ICLRDataTargetVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataTarget_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataTarget_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataTarget_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataTarget_GetMachineType(This,machineType)	\
    (This)->lpVtbl -> GetMachineType(This,machineType)

#define ICLRDataTarget_GetPointerSize(This,pointerSize)	\
    (This)->lpVtbl -> GetPointerSize(This,pointerSize)

#define ICLRDataTarget_GetImageBase(This,imagePath,baseAddress)	\
    (This)->lpVtbl -> GetImageBase(This,imagePath,baseAddress)

#define ICLRDataTarget_ReadVirtual(This,address,buffer,bytesRequested,bytesRead)	\
    (This)->lpVtbl -> ReadVirtual(This,address,buffer,bytesRequested,bytesRead)

#define ICLRDataTarget_WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)	\
    (This)->lpVtbl -> WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)

#define ICLRDataTarget_GetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> GetTLSValue(This,threadID,index,value)

#define ICLRDataTarget_SetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> SetTLSValue(This,threadID,index,value)

#define ICLRDataTarget_GetCurrentThreadID(This,threadID)	\
    (This)->lpVtbl -> GetCurrentThreadID(This,threadID)

#define ICLRDataTarget_GetThreadContext(This,threadID,contextFlags,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,threadID,contextFlags,contextSize,context)

#define ICLRDataTarget_SetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,threadID,contextSize,context)

#define ICLRDataTarget_Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)	\
    (This)->lpVtbl -> Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetMachineType_Proxy( 
    ICLRDataTarget * This,
    /* [out] */ ULONG32 *machineType);


void __RPC_STUB ICLRDataTarget_GetMachineType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetPointerSize_Proxy( 
    ICLRDataTarget * This,
    /* [out] */ ULONG32 *pointerSize);


void __RPC_STUB ICLRDataTarget_GetPointerSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetImageBase_Proxy( 
    ICLRDataTarget * This,
    /* [string][in] */ LPCWSTR imagePath,
    /* [out] */ CLRDATA_ADDRESS *baseAddress);


void __RPC_STUB ICLRDataTarget_GetImageBase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_ReadVirtual_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ CLRDATA_ADDRESS address,
    /* [length_is][size_is][out] */ BYTE *buffer,
    /* [in] */ ULONG32 bytesRequested,
    /* [out] */ ULONG32 *bytesRead);


void __RPC_STUB ICLRDataTarget_ReadVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_WriteVirtual_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ CLRDATA_ADDRESS address,
    /* [size_is][in] */ BYTE *buffer,
    /* [in] */ ULONG32 bytesRequested,
    /* [out] */ ULONG32 *bytesWritten);


void __RPC_STUB ICLRDataTarget_WriteVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetTLSValue_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 index,
    /* [out] */ CLRDATA_ADDRESS *value);


void __RPC_STUB ICLRDataTarget_GetTLSValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_SetTLSValue_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 index,
    /* [in] */ CLRDATA_ADDRESS value);


void __RPC_STUB ICLRDataTarget_SetTLSValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetCurrentThreadID_Proxy( 
    ICLRDataTarget * This,
    /* [out] */ ULONG32 *threadID);


void __RPC_STUB ICLRDataTarget_GetCurrentThreadID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_GetThreadContext_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 contextFlags,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][out] */ BYTE *context);


void __RPC_STUB ICLRDataTarget_GetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_SetThreadContext_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 threadID,
    /* [in] */ ULONG32 contextSize,
    /* [size_is][in] */ BYTE *context);


void __RPC_STUB ICLRDataTarget_SetThreadContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget_Request_Proxy( 
    ICLRDataTarget * This,
    /* [in] */ ULONG32 reqCode,
    /* [in] */ ULONG32 inBufferSize,
    /* [size_is][in] */ BYTE *inBuffer,
    /* [in] */ ULONG32 outBufferSize,
    /* [size_is][out] */ BYTE *outBuffer);


void __RPC_STUB ICLRDataTarget_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataTarget_INTERFACE_DEFINED__ */


#ifndef __ICLRDataTarget2_INTERFACE_DEFINED__
#define __ICLRDataTarget2_INTERFACE_DEFINED__

/* interface ICLRDataTarget2 */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRDataTarget2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6d05fae3-189c-4630-a6dc-1c251e1c01ab")
    ICLRDataTarget2 : public ICLRDataTarget
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AllocVirtual( 
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags,
            /* [in] */ ULONG32 protectFlags,
            /* [out] */ CLRDATA_ADDRESS *virt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeVirtual( 
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataTarget2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataTarget2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataTarget2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataTarget2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMachineType )( 
            ICLRDataTarget2 * This,
            /* [out] */ ULONG32 *machineType);
        
        HRESULT ( STDMETHODCALLTYPE *GetPointerSize )( 
            ICLRDataTarget2 * This,
            /* [out] */ ULONG32 *pointerSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetImageBase )( 
            ICLRDataTarget2 * This,
            /* [string][in] */ LPCWSTR imagePath,
            /* [out] */ CLRDATA_ADDRESS *baseAddress);
        
        HRESULT ( STDMETHODCALLTYPE *ReadVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesRead);
        
        HRESULT ( STDMETHODCALLTYPE *WriteVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [size_is][in] */ BYTE *buffer,
            /* [in] */ ULONG32 bytesRequested,
            /* [out] */ ULONG32 *bytesWritten);
        
        HRESULT ( STDMETHODCALLTYPE *GetTLSValue )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [out] */ CLRDATA_ADDRESS *value);
        
        HRESULT ( STDMETHODCALLTYPE *SetTLSValue )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 index,
            /* [in] */ CLRDATA_ADDRESS value);
        
        HRESULT ( STDMETHODCALLTYPE *GetCurrentThreadID )( 
            ICLRDataTarget2 * This,
            /* [out] */ ULONG32 *threadID);
        
        HRESULT ( STDMETHODCALLTYPE *GetThreadContext )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextFlags,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][out] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *SetThreadContext )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 threadID,
            /* [in] */ ULONG32 contextSize,
            /* [size_is][in] */ BYTE *context);
        
        HRESULT ( STDMETHODCALLTYPE *Request )( 
            ICLRDataTarget2 * This,
            /* [in] */ ULONG32 reqCode,
            /* [in] */ ULONG32 inBufferSize,
            /* [size_is][in] */ BYTE *inBuffer,
            /* [in] */ ULONG32 outBufferSize,
            /* [size_is][out] */ BYTE *outBuffer);
        
        HRESULT ( STDMETHODCALLTYPE *AllocVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags,
            /* [in] */ ULONG32 protectFlags,
            /* [out] */ CLRDATA_ADDRESS *virt);
        
        HRESULT ( STDMETHODCALLTYPE *FreeVirtual )( 
            ICLRDataTarget2 * This,
            /* [in] */ CLRDATA_ADDRESS addr,
            /* [in] */ ULONG32 size,
            /* [in] */ ULONG32 typeFlags);
        
        END_INTERFACE
    } ICLRDataTarget2Vtbl;

    interface ICLRDataTarget2
    {
        CONST_VTBL struct ICLRDataTarget2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataTarget2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataTarget2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataTarget2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataTarget2_GetMachineType(This,machineType)	\
    (This)->lpVtbl -> GetMachineType(This,machineType)

#define ICLRDataTarget2_GetPointerSize(This,pointerSize)	\
    (This)->lpVtbl -> GetPointerSize(This,pointerSize)

#define ICLRDataTarget2_GetImageBase(This,imagePath,baseAddress)	\
    (This)->lpVtbl -> GetImageBase(This,imagePath,baseAddress)

#define ICLRDataTarget2_ReadVirtual(This,address,buffer,bytesRequested,bytesRead)	\
    (This)->lpVtbl -> ReadVirtual(This,address,buffer,bytesRequested,bytesRead)

#define ICLRDataTarget2_WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)	\
    (This)->lpVtbl -> WriteVirtual(This,address,buffer,bytesRequested,bytesWritten)

#define ICLRDataTarget2_GetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> GetTLSValue(This,threadID,index,value)

#define ICLRDataTarget2_SetTLSValue(This,threadID,index,value)	\
    (This)->lpVtbl -> SetTLSValue(This,threadID,index,value)

#define ICLRDataTarget2_GetCurrentThreadID(This,threadID)	\
    (This)->lpVtbl -> GetCurrentThreadID(This,threadID)

#define ICLRDataTarget2_GetThreadContext(This,threadID,contextFlags,contextSize,context)	\
    (This)->lpVtbl -> GetThreadContext(This,threadID,contextFlags,contextSize,context)

#define ICLRDataTarget2_SetThreadContext(This,threadID,contextSize,context)	\
    (This)->lpVtbl -> SetThreadContext(This,threadID,contextSize,context)

#define ICLRDataTarget2_Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)	\
    (This)->lpVtbl -> Request(This,reqCode,inBufferSize,inBuffer,outBufferSize,outBuffer)


#define ICLRDataTarget2_AllocVirtual(This,addr,size,typeFlags,protectFlags,virt)	\
    (This)->lpVtbl -> AllocVirtual(This,addr,size,typeFlags,protectFlags,virt)

#define ICLRDataTarget2_FreeVirtual(This,addr,size,typeFlags)	\
    (This)->lpVtbl -> FreeVirtual(This,addr,size,typeFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataTarget2_AllocVirtual_Proxy( 
    ICLRDataTarget2 * This,
    /* [in] */ CLRDATA_ADDRESS addr,
    /* [in] */ ULONG32 size,
    /* [in] */ ULONG32 typeFlags,
    /* [in] */ ULONG32 protectFlags,
    /* [out] */ CLRDATA_ADDRESS *virt);


void __RPC_STUB ICLRDataTarget2_AllocVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICLRDataTarget2_FreeVirtual_Proxy( 
    ICLRDataTarget2 * This,
    /* [in] */ CLRDATA_ADDRESS addr,
    /* [in] */ ULONG32 size,
    /* [in] */ ULONG32 typeFlags);


void __RPC_STUB ICLRDataTarget2_FreeVirtual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataTarget2_INTERFACE_DEFINED__ */


#ifndef __ICLRMetadataLocator_INTERFACE_DEFINED__
#define __ICLRMetadataLocator_INTERFACE_DEFINED__

/* interface ICLRMetadataLocator */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_ICLRMetadataLocator;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("aa8fa804-bc05-4642-b2c5-c353ed22fc63")
    ICLRMetadataLocator : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetMetadata( 
            /* [in] */ LPCWSTR imagePath,
            /* [in] */ ULONG32 imageTimestamp,
            /* [in] */ ULONG32 imageSize,
            /* [in] */ GUID *mvid,
            /* [in] */ ULONG32 mdRva,
            /* [in] */ ULONG32 flags,
            /* [in] */ ULONG32 bufferSize,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [out] */ ULONG32 *dataSize) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRMetadataLocatorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRMetadataLocator * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRMetadataLocator * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRMetadataLocator * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetMetadata )( 
            ICLRMetadataLocator * This,
            /* [in] */ LPCWSTR imagePath,
            /* [in] */ ULONG32 imageTimestamp,
            /* [in] */ ULONG32 imageSize,
            /* [in] */ GUID *mvid,
            /* [in] */ ULONG32 mdRva,
            /* [in] */ ULONG32 flags,
            /* [in] */ ULONG32 bufferSize,
            /* [length_is][size_is][out] */ BYTE *buffer,
            /* [out] */ ULONG32 *dataSize);
        
        END_INTERFACE
    } ICLRMetadataLocatorVtbl;

    interface ICLRMetadataLocator
    {
        CONST_VTBL struct ICLRMetadataLocatorVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRMetadataLocator_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRMetadataLocator_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRMetadataLocator_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRMetadataLocator_GetMetadata(This,imagePath,imageTimestamp,imageSize,mvid,mdRva,flags,bufferSize,buffer,dataSize)	\
    (This)->lpVtbl -> GetMetadata(This,imagePath,imageTimestamp,imageSize,mvid,mdRva,flags,bufferSize,buffer,dataSize)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRMetadataLocator_GetMetadata_Proxy( 
    ICLRMetadataLocator * This,
    /* [in] */ LPCWSTR imagePath,
    /* [in] */ ULONG32 imageTimestamp,
    /* [in] */ ULONG32 imageSize,
    /* [in] */ GUID *mvid,
    /* [in] */ ULONG32 mdRva,
    /* [in] */ ULONG32 flags,
    /* [in] */ ULONG32 bufferSize,
    /* [length_is][size_is][out] */ BYTE *buffer,
    /* [out] */ ULONG32 *dataSize);


void __RPC_STUB ICLRMetadataLocator_GetMetadata_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRMetadataLocator_INTERFACE_DEFINED__ */


#ifndef __ICLRDataEnumMemoryRegionsCallback_INTERFACE_DEFINED__
#define __ICLRDataEnumMemoryRegionsCallback_INTERFACE_DEFINED__

/* interface ICLRDataEnumMemoryRegionsCallback */
/* [uuid][object] */ 


EXTERN_C const IID IID_ICLRDataEnumMemoryRegionsCallback;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("BCDD6908-BA2D-4ec5-96CF-DF4D5CDCB4A4")
    ICLRDataEnumMemoryRegionsCallback : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumMemoryRegion( 
            /* [in] */ CLRDATA_ADDRESS address,
            /* [in] */ ULONG32 size) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataEnumMemoryRegionsCallbackVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataEnumMemoryRegionsCallback * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataEnumMemoryRegionsCallback * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataEnumMemoryRegionsCallback * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMemoryRegion )( 
            ICLRDataEnumMemoryRegionsCallback * This,
            /* [in] */ CLRDATA_ADDRESS address,
            /* [in] */ ULONG32 size);
        
        END_INTERFACE
    } ICLRDataEnumMemoryRegionsCallbackVtbl;

    interface ICLRDataEnumMemoryRegionsCallback
    {
        CONST_VTBL struct ICLRDataEnumMemoryRegionsCallbackVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataEnumMemoryRegionsCallback_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataEnumMemoryRegionsCallback_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataEnumMemoryRegionsCallback_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataEnumMemoryRegionsCallback_EnumMemoryRegion(This,address,size)	\
    (This)->lpVtbl -> EnumMemoryRegion(This,address,size)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataEnumMemoryRegionsCallback_EnumMemoryRegion_Proxy( 
    ICLRDataEnumMemoryRegionsCallback * This,
    /* [in] */ CLRDATA_ADDRESS address,
    /* [in] */ ULONG32 size);


void __RPC_STUB ICLRDataEnumMemoryRegionsCallback_EnumMemoryRegion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataEnumMemoryRegionsCallback_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_clrdata_0012 */
/* [local] */ 

typedef 
enum CLRDataEnumMemoryFlags
    {	CLRDATA_ENUM_MEM_DEFAULT	= 0,
	CLRDATA_ENUM_MEM_MINI	= CLRDATA_ENUM_MEM_DEFAULT,
	CLRDATA_ENUM_MEM_HEAP	= 0x1
    } 	CLRDataEnumMemoryFlags;



extern RPC_IF_HANDLE __MIDL_itf_clrdata_0012_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_clrdata_0012_v0_0_s_ifspec;

#ifndef __ICLRDataEnumMemoryRegions_INTERFACE_DEFINED__
#define __ICLRDataEnumMemoryRegions_INTERFACE_DEFINED__

/* interface ICLRDataEnumMemoryRegions */
/* [uuid][object] */ 


EXTERN_C const IID IID_ICLRDataEnumMemoryRegions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("471c35b4-7c2f-4ef0-a945-00f8c38056f1")
    ICLRDataEnumMemoryRegions : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumMemoryRegions( 
            /* [in] */ ICLRDataEnumMemoryRegionsCallback *callback,
            /* [in] */ ULONG32 miniDumpFlags,
            /* [in] */ CLRDataEnumMemoryFlags clrFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICLRDataEnumMemoryRegionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICLRDataEnumMemoryRegions * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICLRDataEnumMemoryRegions * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICLRDataEnumMemoryRegions * This);
        
        HRESULT ( STDMETHODCALLTYPE *EnumMemoryRegions )( 
            ICLRDataEnumMemoryRegions * This,
            /* [in] */ ICLRDataEnumMemoryRegionsCallback *callback,
            /* [in] */ ULONG32 miniDumpFlags,
            /* [in] */ CLRDataEnumMemoryFlags clrFlags);
        
        END_INTERFACE
    } ICLRDataEnumMemoryRegionsVtbl;

    interface ICLRDataEnumMemoryRegions
    {
        CONST_VTBL struct ICLRDataEnumMemoryRegionsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICLRDataEnumMemoryRegions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICLRDataEnumMemoryRegions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICLRDataEnumMemoryRegions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICLRDataEnumMemoryRegions_EnumMemoryRegions(This,callback,miniDumpFlags,clrFlags)	\
    (This)->lpVtbl -> EnumMemoryRegions(This,callback,miniDumpFlags,clrFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICLRDataEnumMemoryRegions_EnumMemoryRegions_Proxy( 
    ICLRDataEnumMemoryRegions * This,
    /* [in] */ ICLRDataEnumMemoryRegionsCallback *callback,
    /* [in] */ ULONG32 miniDumpFlags,
    /* [in] */ CLRDataEnumMemoryFlags clrFlags);


void __RPC_STUB ICLRDataEnumMemoryRegions_EnumMemoryRegions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICLRDataEnumMemoryRegions_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x64\cache.h ===
/**************************************************************************************
* Microsoft Confidential.  Copyright (c) Microsoft Corporation.  All rights reserved. *
***************************************************************************************/
#pragma once

#include <list>

template <class T_ITEM>
class CCache
{
public:
    DWORD Add(__in PWSTR pwszKey, __in T_ITEM tItem);
    T_ITEM Find(__in PWSTR pwszKey);
    VOID Clear(__in_opt VOID *(T_ITEM) = NULL);

private:
    DWORD QuickHash(__in PWSTR pwszString);

    class CNode
    {
      public:
        CNode(__in PWSTR pwszKey, __in DWORD dwHash, __in T_ITEM tItem);
        ~CNode();

        BOOL Is(__in PWSTR pwszKey, __in DWORD dwHash);
        T_ITEM Item();

      private:
        DWORD m_cchKey;
        PWSTR m_pwszKey;
        DWORD m_dwHash;

        T_ITEM m_tItem;
    };

    std::list<CNode> m_Items;
};

template <class T_ITEM>
VOID CCache<T_ITEM>::Clear(__in_opt VOID *pfnHandler(T_ITEM))
{
    while (!m_Items.empty())
    {
        if (pfnHandler != NULL)
        {
            pfnHandler(m_Items.First());
        }

        m_Items.pop_first();
    }
}

template <class T_ITEM>
DWORD CCache<T_ITEM>::Add(__in PWSTR pwszKey, __in T_ITEM tItem)
{
    DWORD dwHash = QuickHash(pwszKey);

    CNode *pNode = new CNode(pwszKey, dwHash, tItem);

    if (pNode == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }

    m_Items.push_back(*pNode);
    return ERROR_SUCCESS;
}

template <class T_ITEM>
T_ITEM CCache<T_ITEM>::Find(__in PWSTR pwszKey)
{
    DWORD dwHash = QuickHash(pwszKey);

    for (std::list<CNode>::iterator irNode = m_Items.begin(); irNode != m_Items.end(); ++irNode)
    {
        if (irNode->Is(pwszKey, dwHash))
        {
            return irNode->Item();
        }
    }

    return (T_ITEM)0;
}

template <class T_ITEM>
DWORD CCache<T_ITEM>::QuickHash(__in PWSTR pwszString)
{
    DWORD dwHash = 0;

    for (; *pwszString != 0; ++pwszString)
    {
        if (dwHash != 0)
        {
            dwHash = dwHash << 1;
        }

        dwHash += (DWORD)towupper(*pwszString);
    }

    return dwHash;
}

template <class T_ITEM>
CCache<T_ITEM>::CNode::CNode(__in PWSTR pwszKey, __in DWORD dwHash, __in T_ITEM tItem)
{
    m_cchKey = wcslen(pwszKey);
    m_pwszKey = new WCHAR[m_cchKey + 1];
    memcpy(m_pwszKey, pwszKey, (m_cchKey + 1)*sizeof(WCHAR));
    m_dwHash = dwHash;
    m_tItem = tItem;
}

template <class T_ITEM>
CCache<T_ITEM>::CNode::~CNode()
{
    if (m_pwszKey != NULL)
    {
        delete[](m_pwszKey);
    }
}

template <class T_ITEM>
BOOL CCache<T_ITEM>::CNode::Is(__in PWSTR pwszKey, __in DWORD dwHash)
{
    if (dwHash != m_dwHash)
    {
        return FALSE;
    }

    if (wcsicmp(pwszKey, m_pwszKey) != 0)
    {
        return FALSE;
    }

    return TRUE;
}

template <class T_ITEM>
T_ITEM CCache<T_ITEM>::CNode::Item()
{
    return m_tItem;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\public\ext\ComChk\1.2\x64\comchk.cpp ===
/***********************************************************************
* Microsoft COMCHK
*
* Microsoft Confidential.  Copyright (c) Microsoft Corporation.  All rights reserved.
*
* File Comments:
*
*
***********************************************************************/

#define _CRT_SECURE_NO_DEPRECATE
// #define _HAS_EXCEPTIONS 0

#include <map>
#include <share.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>

#define STRICT
#include "windows.h"

#include "activscp.h"
#include "comcat.h"
#include "dispex.h"
#include "idispids.h"
#include "msdatsrc.h"
#include "mshtml.h"
#include "mshtmdid.h"
#include "mshtmhst.h"
#include "objsafe.h"
#include "perhist.h"
#include "shlguid.h"

#include "delayimp.h"

#include "verstamp.h"
#include "comchk.h"

#define DBG_PRINTEXCEPTION_C  0x40010006
#define DBG_RIPEXCEPTION      0x40010007

#define EXCEPTION_MSVC	      0xE06D7363    // 0xE0000000 | 'msc'
#define EXCEPTION_COMPLUS     0xE0434F4D    // 0xE0000000 | 'COM'
#define EXCEPTION_MSXML       0xE0000001

#ifndef IID_PPV_ARGS
#define IID_PPV_ARGS(ppType) __uuidof(**(ppType)), (static_cast<IUnknown *>(*(ppType)),reinterpret_cast<void**>(ppType))
#endif


struct __declspec(uuid("BBCBDE60-C3FF-11CE-8350-444553540000")) Folder;
struct __declspec(uuid("F0D2D8EF-3890-11D2-BF8B-00C04FB93661")) Folder2;
struct __declspec(uuid("A7AE5F64-C4D7-4D7F-9307-4D24EE54B841")) Folder3;
struct __declspec(uuid("c7c3f5a4-88a3-11d0-abcb-00a0c90fffc0")) IFile;		    // SCRRUN.DLL
struct __declspec(uuid("0AB5A3D0-E5B6-11D0-ABF5-00A0C90FFFC0")) IFileSystem;	    // SCRRUN.DLL
struct __declspec(uuid("2A0B9D10-4B87-11d3-A97A-00104B365C9F")) IFileSystem3;	    // SCRRUN.DLL
struct __declspec(uuid("c7c3f5a2-88a3-11d0-abcb-00a0c90fffc0")) IFolder;	    // SCRRUN.DLL
struct __declspec(uuid("c7c3f5a3-88a3-11d0-abcb-00a0c90fffc0")) IFolderCollection;  // SCRRUN.DLL
struct __declspec(uuid("736a9095-a80e-4f47-a0a6-87f43d57027c")) ILogonUser;


enum ATD
{
	atdNo,
	atdBefore,
	atdAfter,
};


struct ARG
{
	VARENUM  vt;
	bool     fIn;
	bool     fOut;
	bool     fOptional;
	bool     fDidOptional;
	unsigned iValue;
	unsigned iType;
};


ATD atd = atdBefore;
size_t ciMax = 10;
CLSID clsid;
DISPID dispidMax = 300;
DWORD dwClass;
DWORD dwClassLocked;
DWORD dwClsctx = CLSCTX_ALL;
DWORD dwCoinit2;
DWORD dwDebugSequence;
DWORD dwDispatchMax = 1000;
DWORD dwNonClass;
DWORD dwTimeout = 30000;
DWORD dwZone;
bool fAggregate;
bool fAllClsids;
bool fAllIids;
bool fAllProgids;
bool fBindToObject;
bool fBindToStorage;
bool fCheckSafety;
bool fClsidsFromFile;
bool fCreateOnly;
bool fExistsA;
bool fFakeDebugger;
bool fFreeCO;
bool fHTML;
bool fIgnoreRpcExcept;
bool fIsChild = false;
bool fIidsFromFile;
bool fInReportFailure;
bool fMTA;
bool fNoCategoryCheck;
bool fNoFakeDebugger;
bool fNoFree;
bool fNoIDispatch;
bool fNoIDispatchFuzz;
bool fNoIgnoreBreakpoint;
bool fNoIgnoreClrExcept;
bool fNoIgnoreCppExcept;
bool fNoIgnoreDelayLoadExcept;
bool fNoIgnoreFloatExcept;
bool fNoIgnoreXmlExcept;
bool fNoOverrideSafety;
bool fNoPatchBreakpoint;
bool fNoVectoredExceptions;
bool fNoWindowHook;
bool fObjrefMoniker;
bool fProgidsFromFile;
bool fRemovePrivileges;
bool fSafeForInitializing;
bool fSafeForScripting;
bool fSDL;
bool fSilent;
bool fStdModes;
bool fTryQI;
bool fUrlMoniker;
bool fUseCF;
bool fUsePS;
bool fVerbose;
bool fWebBrowser;
int	 ilevel = 9;			// default level for output
bool blevel = false;		// was a non-default level specified
HHOOK hhook;
HMODULE hmodHook;
IID iid = IID_IUnknown;
HHOOK (*pfnInstallHook)(void (*pfn)(HWND));
void (*pfnUninstallHook)(HHOOK);
wchar_t *szAddToDocument;
wchar_t *szClsctx;
wchar_t *szClsid;
wchar_t *szData;
wchar_t *szDispatchMax;
wchar_t *szHookDll;
wchar_t *szIid;
wchar_t *szInvoke;
wchar_t *szInvokePrefix;
wchar_t *szMoniker;
wchar_t *szMT;
wchar_t *szOut;
wchar_t *szSad = NULL;		// filename for SAD output (master copy only)
const wchar_t *szPrefix;
const wchar_t *szQualifier;
wchar_t *szProgid;
wchar_t *szTimeout;
wchar_t *szUrl;
wchar_t *szZone;


HANDLE hPipeInfoSend = INVALID_HANDLE_VALUE;    // pipe handle for sending data

SAD *sad = NULL;


const IID iidUndefined =	       // f63f9e48-593f-4413-bc80-11734f40ef8a
{
	0xF63F9E48,
	0x593F,
	0x4413,
	{ 0xBC, 0x80, 0x11, 0x73, 0x4F, 0x40, 0xEF, 0x8A }
};


enum COMCAT
{
#if 0
	// activaut.h

	comcatActiveScriptAuthor,
#endif

#if 0				       // Defined in header but not present in uuid.lib
	// activscp.h

	comcatActiveScript,
	comcatActiveScriptParse,
	comcatActiveScriptEncode,
#endif

	// cguid.h

	comcatMARSHALER,

#if 0
	// cluscfgguids.h

	comcatClusCfgCapabilities,
	comcatEnumClusCfgManagedResources,
	comcatClusCfgResourceTypes,
	comcatClusCfgMemberSetChangeListeners,
	comcatClusCfgStartupListeners,
	comcatClusCfgEvictListeners,
#endif

	// comcat.h

	comcatInsertable,
	comcatControl,
	comcatProgrammable,
	comcatIsShortcut,
	comcatNeverShowExt,
	comcatDocObject,
	comcatPrintable,
	comcatRequiresDataPathHost,
	comcatPersistsToMoniker,
	comcatPersistsToStorage,
	comcatPersistsToStreamInit,
	comcatPersistsToStream,
	comcatPersistsToMemory,
	comcatPersistsToFile,
	comcatPersistsToPropertyBag,
	comcatInternetAware,
	comcatDesignTimeUIActivatableControl,

#if 0
	// dxtrans.h

	comcatDXImageTransform,
	comcatDX3DTransform,
	comcatDXAuthoringTransform,
	comcatDXSurface,
#endif

#if 0
	// nt\admin\activec\nodemgr\guids.h

	catidConsoleControl,
	catidConsoleMonitorControl,
#endif

#if 0
	// junkfilter.h

	comcatJunkFilters
#endif

#if 0				       // Declared but never defined
	// msdatsrc.h

	comcatDataSource,
	comcatDataConsumer,
#endif

#if 0
	// msoav.h

	comcatMSOfficeAntiVirus,
#endif

	// objsafe.h

	comcatSafeForScripting,
	comcatSafeForInitializing,

	// shlguid.h

	comcatBrowsableShellExt,
	comcatBrowseInPlace,
	comcatDeskBand,
	comcatInfoBand,
	comcatCommBand,

#if 0
	// wincodec.h

	comcatWICBitmapDecoders,
	comcatWICBitmapEncoders,
	comcatWICPixelFormats,
	comcatWICFormatConverters,
	comcatWICMetadataReader,
	comcatWICMetadataWriter,
#endif

#if 0
	// wmscatid.h

	comcatIWMSControlProtocols,
	comcatIWMSAuthentication,
	comcatIWMSEventPlugins,
	comcatIWMSDataProtocols,
	comcatIWMSFeedbackProtocols,
	comcatIWMSUnicastDataSinks,
	comcatIWMSAuthenticationResponse,
	comcatIWMSCredentialPlugins,
	comcatIWMSPlaylistParsers,
	comcatIWMSStorageSystem,
	comcatIWMSNetworkSource,
	comcatIWMSMediaParsers,
	comcatIWMSCacheProxyPlugins,
	comcatIWMSBroadcastDataSinks,
#endif

	comcatMax
};



const CATID rgcatid[] =
{
#if 0
	// activaut.h

	CATID_ActiveScriptAuthor,
#endif

#if 0				       // Defined in header but not present in uuid.lib
	// activscp.h

	CATID_ActiveScript,
	CATID_ActiveScriptParse,
	CATID_ActiveScriptEncode,
#endif

	// cguid.h

	CATID_MARSHALER,

#if 0
	// cluscfgguids.h

	CATID_ClusCfgCapabilities,
	CATID_EnumClusCfgManagedResources,
	CATID_ClusCfgResourceTypes,
	CATID_ClusCfgMemberSetChangeListeners,
	CATID_ClusCfgStartupListeners,
	CATID_ClusCfgEvictListeners,
#endif

	// comcat.h

	CATID_Insertable,
	CATID_Control,
	CATID_Programmable,
	CATID_IsShortcut,
	CATID_NeverShowExt,
	CATID_DocObject,
	CATID_Printable,
	CATID_RequiresDataPathHost,
	CATID_PersistsToMoniker,
	CATID_PersistsToStorage,
	CATID_PersistsToStreamInit,
	CATID_PersistsToStream,
	CATID_PersistsToMemory,
	CATID_PersistsToFile,
	CATID_PersistsToPropertyBag,
	CATID_InternetAware,
	CATID_DesignTimeUIActivatableControl,

#if 0
	// dxtrans.h

	CATID_DXImageTransform,
	CATID_DX3DTransform,
	CATID_DXAuthoringTransform,
	CATID_DXSurface,
#endif

#if 0
	// nt\admin\activec\nodemgr\guids.h

	CATID_ConsoleControl,
	CATID_ConsoleMonitorControl,
#endif

#if 0
	// junkfilter.h

	CATID_JunkFilters
#endif

#if 0				       // Declared but never defined
	// msdatsrc.h

	CATID_DataSource,
	CATID_DataConsumer,
#endif

#if 0
	// msoav.h

	CATID_MSOfficeAntiVirus,
#endif

	// objsafe.h

	CATID_SafeForScripting,
	CATID_SafeForInitializing,

	// shlguid.h

	CATID_BrowsableShellExt,
	CATID_BrowseInPlace,
	CATID_DeskBand,
	CATID_InfoBand,
	CATID_CommBand,

#if 0
	// wincodec.h

	CATID_WICBitmapDecoders,
	CATID_WICBitmapEncoders,
	CATID_WICPixelFormats,
	CATID_WICFormatConverters,
	CATID_WICMetadataReader,
	CATID_WICMetadataWriter,
#endif

#if 0
	// wmscatid.h

	CATID_IWMSControlProtocols,
	CATID_IWMSAuthentication,
	CATID_IWMSEventPlugins,
	CATID_IWMSDataProtocols,
	CATID_IWMSFeedbackProtocols,
	CATID_IWMSUnicastDataSinks,
	CATID_IWMSAuthenticationResponse,
	CATID_IWMSCredentialPlugins,
	CATID_IWMSPlaylistParsers,
	CATID_IWMSStorageSystem,
	CATID_IWMSNetworkSource,
	CATID_IWMSMediaParsers,
	CATID_IWMSCacheProxyPlugins,
	CATID_IWMSBroadcastDataSinks,
#endif
};

const size_t ccatid = _countof(rgcatid);

bool rgfCatid[ccatid];

int TestAndReleaseInterface(IUnknown *punk, const CLSID *pclsid, bool fIsIUnknown, bool fClassObject, bool fCheckRefCount);
int TestInterface(IUnknown *punk, const CLSID *pclsid, bool fIsIUnknown, bool fClassObject);

const void *PvMethod(const void *pv, int ifn)
{
	const void * const *pvVtbl = *(const void * const **) pv;

	const void *pvMethod = pvVtbl[ifn];

	return(pvMethod);
}


void ReportFailure(int rc, bool fStdout, const void *pv, int ifn, const wchar_t *szMsg, ...)
{
	int lvl;
	LPWSTR pName;
	bool b = FindWarningInfo(rc, &pName, &lvl);
	bool bOutput = true;
	if (lvl >= ilevel) bOutput = false;

	va_list valist;
	va_start(valist, szMsg);

	if (!fSilent || fStdout)
	{
		const void *pvReport = pv;

		if ((pvReport != NULL) && (ifn >= 0))
		{
			// We have a vtable index.  Index into the vtable

			// UNDONE: Ugly hack.	We need to supress the vectored exception handlers
			// UNDONE: first chance handling of access violations for the next block.
			// UNDONE: Currently this can only happen for the main thread so we
			// UNDONE: cheat and use a global.

			fInReportFailure = true;

			__try
			{
				pvReport = PvMethod(pv, ifn);
			}

			__except (EXCEPTION_EXECUTE_HANDLER)
			{
				pvReport = NULL;
			}

			fInReportFailure = false;
		}

		wchar_t szModule[_MAX_PATH];
		const wchar_t *szFilename = NULL;

		if (pvReport != NULL)
		{
			MEMORY_BASIC_INFORMATION mbi;

			if (VirtualQuery(pvReport, &mbi, sizeof(mbi)) != 0)
			{
				if ((mbi.State & MEM_COMMIT) != 0)
				{
					static HMODULE hmodOLEAUT32 = GetModuleHandle(L"OLEAUT32.DLL");
					static HMODULE hmodRPCRT4 = GetModuleHandle(L"RPCRT4.DLL");

					HMODULE hmod = HMODULE(mbi.AllocationBase);

					if (hmod == NULL)
					{
						// Do not treat NULL as a module handle as it maps to the current EXE

						pvReport = NULL;
					}

					else if (fMTA && (ifn >= 0) && ((hmod == hmodOLEAUT32) || (hmod == hmodRPCRT4)))
					{
						// Don't display method addresses within OLEAUT32 or RPCRT4.
						// These are usually proxy addresses

						pvReport = NULL;
					}

					else if (GetModuleFileName(hmod, szModule, _countof(szModule)) != 0)
					{
						szFilename = szModule;
					}
				}
			}
		}

		// Lock stream to prevent other thread from entering in the middle of this.
		// While most code occurs on a single thread, WindowHookCallback and unhandled
		// exceptions can and do occur on other threads

		//
		// Also send info to master.

		PipeMsg pmWarn;
		pmWarn.AddDWORD(3);
		pmWarn.AddDWORD(rc);

		_lock_file(stdout);

		if (bOutput)
			wprintf(L"%08X: %s%s: ", rc, szPrefix, (szQualifier != NULL) ? szQualifier : L"");
		pmWarn.AddFormatString(L"%s%s", szPrefix, (szQualifier != NULL) ? szQualifier : L"");

		if (bOutput)
			vwprintf(szMsg, valist);
		pmWarn.AddFormatVString(szMsg, valist);

		if (pvReport != NULL)
		{	 
			if (bOutput)
				wprintf(L": %p", pvReport);

			pmWarn.AddFormatString(L"%p", pvReport);

			if (szFilename != NULL)
			{
				if (bOutput)
					wprintf(L" (%s)", szFilename);
				pmWarn.AppendFormatString(L" (%s)", szFilename);
			}
		}
		else
		{
			pmWarn.AddDWORD(0);	// extra terminator (OK, two of them)
		}

		if (bOutput)
		{
			_fputwc_nolock(L'\n', stdout);
			_fflush_nolock(stdout);
		}

		pmWarn.Send(hPipeInfoSend);

		_unlock_file(stdout);
	}
	va_end(valist);

}


bool FDefaultNoFakeDebugger()
{
	OSVERSIONINFO ovi;

	ovi.dwOSVersionInfoSize = sizeof(ovi);

	if (!GetVersionEx(&ovi))
	{
		return(false);
	}

	if (ovi.dwMajorVersion < 6)
	{
		// For pre-Longhorn we do fake the debugger by default

		return(false);
	}

	if ((ovi.dwMajorVersion > 6) || (ovi.dwMinorVersion > 0))
	{
		// For post-Longhorn we do not fake the debugger by default

		return(true);
	}

	// Longhorn winmain build 5438 does not need to fake being a debugger

	return(ovi.dwBuildNumber >= 5438);
}


bool FRemovePrivilege(HANDLE hToken, const wchar_t *szPrivilege)
{
	LUID luid;

	if (!LookupPrivilegeValue(NULL, szPrivilege, &luid))
	{
		return(false);
	}

	TOKEN_PRIVILEGES tp;

	tp.PrivilegeCount = 1;
	tp.Privileges[0].Luid = luid;
	tp.Privileges[0].Attributes = SE_PRIVILEGE_REMOVED;

	if (!AdjustTokenPrivileges(hToken,
		FALSE,
		&tp,
		sizeof(tp),
		NULL,
		NULL))
	{
		return(false);
	}

	if (fVerbose && (GetLastError() == ERROR_SUCCESS))
	{
		wprintf(L"Removed privilege %s\n", szPrivilege);
	}

	return(true);
}


void RemovePrivileges()
{
	HANDLE hToken;

	if (!OpenProcessToken(GetCurrentProcess(),
		TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
		&hToken))
	{
		wprintf(L"OpenProcessToken failed.  GetLastError() = %u\n", GetLastError());
		return;
	}

	static const wchar_t * const rgszPrivilege[] =
	{
		SE_CREATE_TOKEN_NAME,
		SE_ASSIGNPRIMARYTOKEN_NAME,
		SE_LOCK_MEMORY_NAME,
		SE_INCREASE_QUOTA_NAME,
		SE_UNSOLICITED_INPUT_NAME,
		SE_MACHINE_ACCOUNT_NAME,
		SE_TCB_NAME,
		SE_SECURITY_NAME,
		SE_TAKE_OWNERSHIP_NAME,
		SE_LOAD_DRIVER_NAME,
		SE_SYSTEM_PROFILE_NAME,
		SE_SYSTEMTIME_NAME,
		SE_PROF_SINGLE_PROCESS_NAME,
		SE_INC_BASE_PRIORITY_NAME,
		SE_CREATE_PAGEFILE_NAME,
		SE_CREATE_PERMANENT_NAME,
		SE_BACKUP_NAME,
		SE_RESTORE_NAME,
		SE_SHUTDOWN_NAME,
		SE_DEBUG_NAME,
		SE_AUDIT_NAME,
		SE_SYSTEM_ENVIRONMENT_NAME,
		//	SE_CHANGE_NOTIFY_NAME,
		SE_REMOTE_SHUTDOWN_NAME,
		SE_UNDOCK_NAME,
		SE_SYNC_AGENT_NAME,
		SE_ENABLE_DELEGATION_NAME,
		SE_MANAGE_VOLUME_NAME,
		SE_IMPERSONATE_NAME,
		SE_CREATE_GLOBAL_NAME,

		// The following are ifdefed to support old build
		// environments like that used by SWI.

#ifdef	SE_TRUSTED_CREDMAN_ACCESS_NAME
		SE_TRUSTED_CREDMAN_ACCESS_NAME,
#endif
#ifdef	SE_RELABEL_NAME
		SE_RELABEL_NAME,
#endif
#ifdef	SE_INC_WORKING_SET_NAME
		SE_INC_WORKING_SET_NAME,
#endif
#ifdef	SE_TIME_ZONE_NAME
		SE_TIME_ZONE_NAME,
#endif
#ifdef	SE_CREATE_SYMBOLIC_LINK_NAME
		SE_CREATE_SYMBOLIC_LINK_NAME,
#endif
	};

	const size_t cszPrivilege = _countof(rgszPrivilege);

	for (size_t isz = 0; isz < cszPrivilege; isz++)
	{
		FRemovePrivilege(hToken, rgszPrivilege[isz]);
	}

	CloseHandle(hToken);
}


HHOOK InstallHookStub(void (*pfn)(HWND))
{
	_putws(L"COMCHKHK.DLL is missing.  -nowindowhook assumed\n");

	fNoWindowHook = true;

	return(NULL);
}


LONG WINAPI MyUnhandledExceptionFilter(EXCEPTION_POINTERS *pep)
{
	_lock_file(stdout);

	PipeMsg pmExcept;

	pmExcept.AddDWORD(4);	// msg id
	pmExcept.AddDWORD(pep->ExceptionRecord->ExceptionCode);
	pmExcept.AddString(GetCommandLine());
	pmExcept.AddFormatString(L"%p", pep->ExceptionRecord->ExceptionAddress);
	wprintf(L"%08X: %s: %p", pep->ExceptionRecord->ExceptionCode, GetCommandLine(), pep->ExceptionRecord->ExceptionAddress);
	MEMORY_BASIC_INFORMATION mbi;

	if (VirtualQuery((void *) pep->ExceptionRecord->ExceptionAddress, &mbi, sizeof(mbi)) != 0)
	{
		if ((mbi.State & MEM_COMMIT) != 0)
		{
			HMODULE hmod = HMODULE(mbi.AllocationBase);

			wchar_t szFilename[_MAX_PATH];

			if (GetModuleFileName(hmod, szFilename, _countof(szFilename)) != 0)
			{
				pmExcept.AppendFormatString(L" (%s)", szFilename);
				wprintf(L" (%s)", szFilename);

			}
		}
	}
	pmExcept.Send(hPipeInfoSend);

	_fputwc_nolock(L'\n', stdout);
	_fflush_nolock(stdout);
	_unlock_file(stdout);

	TerminateProcess(GetCurrentProcess(), 0);

	__assume(0);
}


void SetMyUnhandledExceptionFilter(bool fCheckCurrent)
{
	LPTOP_LEVEL_EXCEPTION_FILTER pfnFilterPrev = SetUnhandledExceptionFilter(&MyUnhandledExceptionFilter);

	if (fCheckCurrent && (pfnFilterPrev != &MyUnhandledExceptionFilter))
	{
		ReportFailure(0x2C01, false, (void *) pfnFilterPrev, -1, L"UnhandledExceptionFilter changed");
	}
}


void DoOutputDebugString(const char *sz, size_t cch)
{
	char *szT = (char *) _alloca(cch);

	while (cch != 0)
	{
		size_t ich = 0;

		while (cch != 0)
		{
			cch--;

			char ch = *sz++;

			if (ch == '\0')
			{
				break;
			}

			if (ch == '\r')
			{
				// Ignore CR

				continue;
			}

			if (ch == '\n')
			{
				// Treat LF as line break

				break;
			}

			szT[ich++] = ch;
		}

		if (ich != 0)
		{
			szT[ich] = '\0';

			// Increment sequence so that when output is sorted these remain in order

			DWORD dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);

			ReportFailure(0x0101, false, NULL, 0, L"%08X OutputDebugString: \"%hs\"", dwSequence, szT);
		}
	}
}


bool FDoBreakpoint(EXCEPTION_POINTERS *pep)
{
#if	defined(_M_IX86)

	// From nt\base\published\nti386.w

	//
	//  Values put in ExceptionRecord.ExceptionInformation[0]
	//  First parameter is always in ExceptionInformation[1],
	//  Second parameter is always in ExceptionInformation[2]
	//

#define BREAKPOINT_BREAK	    0
#define BREAKPOINT_PRINT	    1
#define BREAKPOINT_PROMPT	    2
#define BREAKPOINT_LOAD_SYMBOLS     3
#define BREAKPOINT_UNLOAD_SYMBOLS   4
#define BREAKPOINT_COMMAND_STRING   5

	BYTE *pb = (BYTE *) pep->ContextRecord->Eip;

	// Under WoW64 the exception address is a RET not an Int 3 and we don't do anything
	// If you ignore this you will find that at least on x64 the exception arguments
	// are not correct as the special breakpoints are handled by 64-bit code not 32-bit.

	if (*pb == 0xCC)
	{
		if (pep->ExceptionRecord->NumberParameters > 0)
		{
			DWORD dwType = (DWORD) pep->ExceptionRecord->ExceptionInformation[0];

			switch (dwType)
			{
				DWORD dwSequence;
				const char *pch;
				size_t cch;
				char *pchIn;
				size_t cchIn;

			case BREAKPOINT_BREAK :
				ReportFailure(0x0103, false, pb, -1, L"Breakpoint");
				break;

			case BREAKPOINT_PROMPT :
				// Increment sequence so that when output is sorted these remain in order

				dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);

				pch = (char *) pep->ContextRecord->Ecx;
				cch = (size_t) pep->ContextRecord->Edx;
				pchIn = (char *) pep->ContextRecord->Ebx;
				cchIn = (size_t) pep->ContextRecord->Edi;

				ReportFailure(0x0104, false, NULL, 0, L"%08X DebugPrompt: %*S", dwSequence, cch, pch);

				if (cchIn == 0)
				{
					pep->ContextRecord->Eax = 0;
				}

				else
				{
					*pchIn = 'I';        // Ignore

					pep->ContextRecord->Eax = 1;
				}
				break;

			default :
				// Increment sequence so that when output is sorted these remain in order

				dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);

				ReportFailure(0x0105, false, pb, -1, L"%08X Breakpoint(%08X)", dwSequence, dwType);
				break;
			}
		}

		else
		{
			ReportFailure(0x0106, false, pb, -1, L"Breakpoint");
		}

		if (!fNoPatchBreakpoint)
		{
			DWORD dwOldProtect;

			if (VirtualProtect(pb, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
			{
				// Replace INT 3 with NOP

				*pb = 0x90;

				// Restore protection and ignore any error

				DWORD dwT;

				VirtualProtect(pb, 1, dwOldProtect, &dwT);
			}
		}

		pep->ContextRecord->Eip += 1;

		return(true);
	}

#elif	defined(_M_AMD64)

	// From nt\base\published\ntamd64.w

	//
	//  ?? Values put in ExceptionRecord.ExceptionInformation[0]
	//  ?? First parameter is always in ExceptionInformation[1],
	//  ?? Second parameter is always in ExceptionInformation[2]
	//

#define BREAKPOINT_BREAK 0
#define BREAKPOINT_PRINT 1
#define BREAKPOINT_PROMPT 2
#define BREAKPOINT_LOAD_SYMBOLS 3
#define BREAKPOINT_UNLOAD_SYMBOLS 4
#define BREAKPOINT_COMMAND_STRING 5

	BYTE *pb = (BYTE *) pep->ContextRecord->Rip;

	if (*pb == 0xCC)
	{
		if (pep->ExceptionRecord->NumberParameters > 0)
		{
			DWORD dwType = (DWORD) pep->ExceptionRecord->ExceptionInformation[0];

			switch (dwType)
			{
				DWORD dwSequence;
				const char *pch;
				size_t cch;
				char *pchIn;
				size_t cchIn;

			case BREAKPOINT_BREAK :
				ReportFailure(0x0103, false, pb, -1, L"Breakpoint");
				break;

			case BREAKPOINT_PROMPT :
				// Increment sequence so that when output is sorted these remain in order

				dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);

				pch = (char *) pep->ContextRecord->Rcx;
				cch = (WORD) pep->ContextRecord->Rdx;
				pchIn = (char *) pep->ContextRecord->R8;
				cchIn = (WORD) pep->ContextRecord->R9;

				ReportFailure(0x0104, false, NULL, 0, L"%08X DebugPrompt: %*S", dwSequence, cch, pch);

				if (cchIn == 0)
				{
					pep->ContextRecord->Rax = 0;
				}

				else
				{
					*pchIn = 'I';        // Ignore

					pep->ContextRecord->Rax = 1;
				}
				break;

			default :
				// Increment sequence so that when output is sorted these remain in order

				dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);

				ReportFailure(0x0105, false, pb, -1, L"%08X Breakpoint(%08X)", dwSequence, dwType);
				break;
			}
		}

		else
		{
			ReportFailure(0x0106, false, pb, -1, L"Breakpoint");
		}

		if (!fNoPatchBreakpoint)
		{
			DWORD dwOldProtect;

			if (VirtualProtect(pb, 1, PAGE_EXECUTE_READWRITE, &dwOldProtect))
			{
				// Replace INT 3 with NOP

				*pb = 0x90;

				// Restore protection and ignore any error

				DWORD dwT;

				VirtualProtect(pb, 1, dwOldProtect, &dwT);
			}
		}

		pep->ContextRecord->Rip += 1;

		return(true);
	}

#endif

	return(false);
}


LONG NTAPI VectoredExceptionHandler(EXCEPTION_POINTERS *pep)
{
	bool fFatal;
	DWORD dwSequence;

	DWORD ExceptionCode = pep->ExceptionRecord->ExceptionCode;

	switch (ExceptionCode)
	{
		size_t cch;
		const char *sz;
		DWORD dwType;
		DWORD dwError;

	case RPC_X_NO_MORE_ENTRIES :
	case RPC_X_SS_CHAR_TRANS_OPEN_FAIL :
	case RPC_X_SS_CHAR_TRANS_SHORT_FILE :
	case RPC_X_SS_IN_NULL_CONTEXT :
	case RPC_X_SS_CONTEXT_DAMAGED :
	case RPC_X_SS_HANDLES_MISMATCH :
	case RPC_X_SS_CANNOT_GET_CALL_HANDLE :
		//	case RPC_X_NULL_REF_POINTER :
	case RPC_X_ENUM_VALUE_OUT_OF_RANGE :
	case RPC_X_BYTE_COUNT_TOO_SMALL :
	case RPC_X_BAD_STUB_DATA :
	case RPC_X_INVALID_ES_ACTION :
	case RPC_X_WRONG_ES_VERSION :
	case RPC_X_WRONG_STUB_VERSION :
	case RPC_X_INVALID_PIPE_OBJECT :
	case RPC_X_WRONG_PIPE_ORDER :
	case RPC_X_WRONG_PIPE_VERSION :
	case RPC_X_PIPE_CLOSED :
	case RPC_X_PIPE_DISCIPLINE_ERROR :
	case RPC_X_PIPE_EMPTY :
		fFatal = !fIgnoreRpcExcept;
		break;

	case DBG_PRINTEXCEPTION_C :
		cch = pep->ExceptionRecord->ExceptionInformation[0];
		sz = (char *) pep->ExceptionRecord->ExceptionInformation[1];

		DoOutputDebugString(sz, cch);
		return(EXCEPTION_CONTINUE_EXECUTION);

	case DBG_RIPEXCEPTION :
		dwError = (DWORD) pep->ExceptionRecord->ExceptionInformation[0];
		dwType  = (DWORD) pep->ExceptionRecord->ExceptionInformation[1];

		dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);
		ReportFailure(0x0102, false, NULL, 0, L"%08X RIP: Error=%08X, Type=%08X", dwSequence, dwError, dwType);
		return(EXCEPTION_CONTINUE_EXECUTION);

	case EXCEPTION_COMPLUS :
		fFatal = fNoIgnoreClrExcept;
		break;

	case EXCEPTION_MSVC :
		fFatal = fNoIgnoreCppExcept;
		break;

	case EXCEPTION_MSXML :
		fFatal = fNoIgnoreXmlExcept;
		break;

	case VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND) :
	case VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND) :
		fFatal = fNoIgnoreDelayLoadExcept;
		break;

	case STATUS_BREAKPOINT :
		if (!fNoIgnoreBreakpoint && FDoBreakpoint(pep))
		{
			return(EXCEPTION_CONTINUE_EXECUTION);
		}

		fFatal = true;
		break;

	case STATUS_FLOAT_DENORMAL_OPERAND :
	case STATUS_FLOAT_DIVIDE_BY_ZERO :
	case STATUS_FLOAT_INEXACT_RESULT :
	case STATUS_FLOAT_INVALID_OPERATION :
	case STATUS_FLOAT_OVERFLOW :
	case STATUS_FLOAT_STACK_CHECK :
	case STATUS_FLOAT_UNDERFLOW :
		fFatal = fNoIgnoreFloatExcept;
		break;

	case STATUS_ACCESS_VIOLATION :
		if (fInReportFailure)
		{
			return(EXCEPTION_CONTINUE_SEARCH);
		}

		// Fall through

	default:
		// Error code have the high 2 bits set

		fFatal = (ExceptionCode & 0xC0000000) == 0xC0000000;
		break;
	}

	if (fFatal)
	{
		return(MyUnhandledExceptionFilter(pep));
	}

	dwSequence = (DWORD) InterlockedIncrement((LONG *) &dwDebugSequence);

	ReportFailure(0x0107, false, pep->ExceptionRecord->ExceptionAddress, -1, L"%08X Exception %08X", dwSequence, pep->ExceptionRecord->ExceptionCode);

	return(EXCEPTION_CONTINUE_SEARCH);
}


void WindowHookCallback(HWND hwnd)
{
	wchar_t szTitle[256];

	if (GetWindowText(hwnd, szTitle, _countof(szTitle)) == 0)
	{
		szTitle[0] = L'\0';
	}

	szTitle[_countof(szTitle) - 1] = L'\0';

	ReportFailure(0x0201, false, NULL, 0, L"Window hook caught window %p \"%s\"", hwnd, szTitle);
}


void QueryComponentCategories(REFCLSID clsid)
{
	ICatInformation *pici;

	HRESULT hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
		NULL,
		CLSCTX_ALL,
		IID_PPV_ARGS(&pici));

	if (FAILED(hr))
	{
		ReportFailure(0x0301, false, NULL, 0, L"CoCreateInstance(CLSID_StdComponentCategoriesMgr) failed.  hr = %08X", hr);
		return;
	}

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	for (size_t icatid = 0; icatid < ccatid; icatid++)
	{
		hr = pici->IsClassOfCategories(clsid, 1, (CATID *) &rgcatid[icatid], ((ULONG) -1), NULL);

		if (hr == S_OK)
		{
			rgfCatid[icatid] = true;
		}

		else if (hr == S_FALSE)
		{
			rgfCatid[icatid] = false;
		}

		else if (FAILED(hr))
		{
			// Don't report ERROR_FILE_NOT_FOUND.  This is returned when the CLSID is not registered

			if (hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
			{
				ReportFailure(0x0302, false, NULL, 0, L"ICatInformation::IsClassOfCategories failed.  hr = %08X", hr);
			}
		}

		else
		{
			ReportFailure(0x0303, false, NULL, 0, L"ICatInformation::IsClassOfCategories returned %08X", hr);
		}
	}

	pici->Release();
}


const wchar_t *SzIidDisplay()
{
	if (szIid != NULL)
	{
		return(szIid);
	}

	return L"IUnknown";
}


void FreeUnusedLibraries()
{
	if (fNoFree)
	{
		return;
	}

	if (!fFreeCO && (dwClass != 0) && (dwClassLocked == 0) && (dwNonClass == 0))
	{
		return;
	}

	CoFreeUnusedLibrariesEx(0, 0);
	CoFreeUnusedLibrariesEx(0, 0);

	SetMyUnhandledExceptionFilter(true);
}


void IncrementObjectCount(bool fClassObject)
{
	if (fClassObject)
	{
		dwClass++;
	}

	else
	{
		dwNonClass++;
	}
}


ULONG Release(IUnknown *punk, bool fClassObject)
{
	ULONG cref = punk->Release();

	if (fClassObject)
	{
		dwClass--;
	}

	else
	{
		dwNonClass--;
	}

	FreeUnusedLibraries();

	return(cref);
}


class Interface sealed
{
public:
	static bool FNoQINullCheck()
	{
		return(piHead->m_fNoQINullCheck);
	}

	static bool FNoRefCountCheck()
	{
		return(piHead->m_fNoRefCountCheck);
	}

	static bool FPush(IUnknown *punk, bool fClassObject)
	{
		for (Interface *pi = piHead; pi != NULL; pi = pi->m_piNext)
		{
			if (pi->m_punk == punk)
			{
				if (fVerbose)
				{
					wprintf(L"********: Skipping interface already on stack\n");
				}

				return(false);
			}
		}

		if (ci == ciMax)
		{
			if (fVerbose)
			{
				wprintf(L"********: Skipping interface because recursion limit\n");
			}

			return(false);
		}

		Interface *pi = new Interface(punk, fClassObject);

		return(true);
	}

	static ULONG PopAndRelease()
	{
		Interface *pi = piHead;

		piHead = pi->m_piNext;

		ULONG cref = Release(pi->m_punk, pi->m_fClassObject);

		delete pi;

		ci--;

		return(cref);
	}

	static void SetNoQINullCheck()
	{
		piHead->m_fNoQINullCheck = true;
	}

	static void SetNoRefCountCheck()
	{
		piHead->m_fNoRefCountCheck = true;
	}

private:
	Interface(IUnknown *punk, bool fClassObject) : m_punk(punk), m_fClassObject(fClassObject)
	{
#if 0
		wprintf(L"--> %*s punk = %p, vtbl = %p, QI = %p\n",
			ci, L"",
			punk,
			*(intptr_t *) punk,
			**(intptr_t **) punk);
#endif

		m_fNoQINullCheck = false;
		m_fNoRefCountCheck = false;

		ci++;

		m_piNext = piHead;

		piHead = this;
	}

	static Interface *piHead;
	static size_t ci;

	IUnknown *m_punk;
	bool m_fClassObject;
	bool m_fNoQINullCheck;
	bool m_fNoRefCountCheck;
	Interface *m_piNext;
};


size_t Interface::ci;
Interface *Interface::piHead;


HRESULT HrQueryInterface(IUnknown *punk, bool fClassObject, const wchar_t *szIid, REFIID riid, void **ppvObject)
{
	*ppvObject = (void *) (intptr_t) -1;

	HRESULT hr = punk->QueryInterface(riid, ppvObject);

	if (SUCCEEDED(hr))
	{
		IncrementObjectCount(fClassObject);
	}

	else
	{
		if (hr != E_NOINTERFACE)
		{
			ReportFailure(0x0401, false, punk, 0, L"QueryInterface(%s) failure did not E_NOINTERFACE.  hr = %08X", szIid, hr);
		}

		if (*ppvObject != NULL)
		{
			if (!Interface::FNoQINullCheck())
			{
				Interface::SetNoQINullCheck();

				ReportFailure(0x0402, false, punk, 0, L"QueryInterface(%s) failure did not set *ppvObject = NULL", szIid);
			}

			*ppvObject = NULL;
		}
	}

	FreeUnusedLibraries();

	return(hr);
}


void MyVariantInit(VARIANT *pvar)
{
	// Use memset and assignment of the vt member instead of VariantInit.  This
	// is because VariantInit doesn't initialize all the fields and we want to
	// catch access to the other members that should be guarded by checking the
	// type.

	memset(pvar, -1, sizeof(*pvar));

	pvar->vt = VT_EMPTY;
}


bool FSafeForInitializing(IUnknown *punk, REFCLSID clsid)
{
	if (rgfCatid[comcatSafeForInitializing])
	{
		return(true);
	}

	IObjectSafety *pios;

	HRESULT hr = punk->QueryInterface(IID_PPV_ARGS(&pios));

	if (FAILED(hr))
	{
		return(false);
	}

	static const IID rgiid[] =
	{
		IID_IPersist,
		IID_IPersistFile,
#if 0
		IID_IPersistHistory,
#endif
		IID_IPersistMoniker,
		IID_IPersistPropertyBag,
		IID_IPersistPropertyBag2,
		IID_IPersistStorage,
		IID_IPersistStream,
		IID_IPersistStreamInit,
	};

	const size_t ciid = _countof(rgiid);

	bool fSafe = false;

	for (size_t iiid = 0; iiid < ciid; iiid++)
	{
		DWORD dwSupported;
		DWORD dwEnabled;

		hr = pios->GetInterfaceSafetyOptions(rgiid[iiid], &dwSupported, &dwEnabled);

		if (SUCCEEDED(hr))
		{
			if ((dwSupported & INTERFACESAFE_FOR_UNTRUSTED_DATA) != 0)
			{
				fSafe = true;
				break;
			}
		}
	}

	pios->Release();

	return(fSafe);
}


bool FSafeForScripting(IUnknown *punk, REFCLSID clsid)
{
	if (rgfCatid[comcatSafeForScripting])
	{
		return(true);
	}

	IObjectSafety *pios;

	HRESULT hr = punk->QueryInterface(IID_PPV_ARGS(&pios));

	if (FAILED(hr))
	{
		return(false);
	}

	static const IID rgiid[] =
	{
		IID_IActiveScript,
		IID_IActiveScriptParse,
		IID_IDispatch,
		IID_IDispatchEx,
	};

	const size_t ciid = _countof(rgiid);

	bool fSafe = false;

	for (size_t iiid = 0; iiid < ciid; iiid++)
	{
		DWORD dwSupported;
		DWORD dwEnabled;

		hr = pios->GetInterfaceSafetyOptions(rgiid[iiid], &dwSupported, &dwEnabled);

		if (SUCCEEDED(hr))
		{
			if ((dwSupported & INTERFACESAFE_FOR_UNTRUSTED_CALLER) != 0)
			{
				fSafe = true;
				break;
			}
		}
	}

	pios->Release();

	return(fSafe);
}


bool FTestClass(IUnknown *punk, REFCLSID clsid)
{
	if (!fSafeForInitializing && !fSafeForScripting)
	{
		return(true);
	}

	if (fSafeForInitializing && FSafeForInitializing(punk, clsid))
	{
		return(true);
	}

	if (fSafeForScripting && FSafeForScripting(punk, clsid))
	{
		return(true);
	}

	return(false);
}


int SetSiteAlways(IUnknown *punk, IOleClientSite *piocs)
{
	IOleObject *pioo;

	HRESULT hr = HrQueryInterface(punk, false, L"IOleObject", IID_PPV_ARGS(&pioo));

	if (SUCCEEDED(hr))
	{
		hr = pioo->SetClientSite(piocs);

		if (FAILED(hr))
		{
			ReportFailure(0x0501, false, pioo, 3, L"IOleObject::SetClientSite failed.  hr = %08X", hr);
		}

		Release(pioo, false);

		return(FAILED(hr) ? 0x0501 : 0);
	}

	IObjectWithSite *piows;

	hr = HrQueryInterface(punk, false, L"IObjectWithSite", IID_PPV_ARGS(&piows));

	if (SUCCEEDED(hr))
	{
		hr = piows->SetSite(piocs);

		if (FAILED(hr))
		{
			ReportFailure(0x0502, false, piows, 3, L"IObjectWithSite::SetSite failed.  hr = %08X", hr);
		}

		Release(piows, false);

		return(FAILED(hr) ? 0x0502 : 0);
	}

	return(-1);
}


int SetSite(IUnknown *punk, IOleClientSite *piocs)
{
	if (fHTML)
	{
		// With -html we don't want to override the HTML site

		return(-1);
	}

	return(SetSiteAlways(punk, piocs));
}

class __declspec(uuid("f52e3884-8f28-4daa-9fa8-1f49bed0d496")) CTrigger sealed : public IClassFactory
{
public:
	CTrigger() : m_cref(1), m_clock(0)
	{
	};

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvObject);
	HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock);

public:
	ULONG m_cref;
	ULONG m_clock;
};


HRESULT STDMETHODCALLTYPE CTrigger::QueryInterface(REFIID riid, void **ppvObject)
{
	if (IsEqualGUID(riid, IID_IUnknown))
	{
		*ppvObject = (IUnknown *) this;
	}

	else if (IsEqualGUID(riid, IID_IClassFactory))
	{
		*ppvObject = (IClassFactory *) this;
	}

	else
	{
		*ppvObject = NULL;

		return(E_NOINTERFACE);
	}

	AddRef();

	return(S_OK);
}


ULONG STDMETHODCALLTYPE CTrigger::AddRef()
{
	return(++m_cref);
}


ULONG STDMETHODCALLTYPE CTrigger::Release()
{
	ULONG cref = --m_cref;

	if (cref == 0)
	{
		delete this;
	}

	return(cref);
}


HRESULT STDMETHODCALLTYPE CTrigger::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppvObject)
{
	wchar_t szIidT[39];

	StringFromGUID2(iid, szIidT, _countof(szIidT));

	ReportFailure(0x3201, false, NULL, 0, L"CTrigger::CreateInstance(%p, %s)", punkOuter, szIidT);

	*ppvObject = NULL;

	return(E_ABORT);
}


HRESULT STDMETHODCALLTYPE CTrigger::LockServer(BOOL fLock)
{
	if (fLock)
	{
		m_clock++;
	}

	else
	{
		m_clock--;
	}

	return(S_OK);
}



class COuter sealed : public IUnknown
{
public:
	COuter() : m_cref(1), m_punkInner(NULL)
	{
	};

	~COuter();

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

public:
	ULONG m_cref;
	IUnknown *m_punkInner;
};


COuter::~COuter()
{
	if (m_punkInner != NULL)
	{
		// The inner object may call AddRef and Release on this object.
		// Dump the ref count so that this does not allow the ref count
		// to drop to zero again and reenter this code.

		AddRef();

		// Capture address of Release() method since after release the memory may be gone

		const void *pvRelease = PvMethod(m_punkInner, 2);

		// Don't call ::Release() since it is the grandparent of this call
		// and is already decrementing dwNonClass

		ULONG cref = m_punkInner->Release();

		if (cref != 0)
		{
			ReportFailure(0x0601, false, pvRelease, -1, L"IUnknown::Release returned %u", cref);
		}

		if (m_cref != 1)
		{
			ReportFailure(0x0602, false, pvRelease, -1, L"IUnknown::Release changed ref count of punkOuter (%u)", m_cref);
		}
	}
}


HRESULT STDMETHODCALLTYPE COuter::QueryInterface(REFIID riid, void **ppvObject)
{
	if (IsEqualGUID(riid, IID_IUnknown))
	{
		*ppvObject = (IUnknown *) this;
	}

	else if (m_punkInner != NULL)
	{
		return m_punkInner->QueryInterface(riid, ppvObject);
	}

	else
	{
		*ppvObject = NULL;

		return(E_NOINTERFACE);
	}

	AddRef();

	return(S_OK);
}


ULONG STDMETHODCALLTYPE COuter::AddRef()
{
	return(++m_cref);
}


ULONG STDMETHODCALLTYPE COuter::Release()
{
	ULONG cref = --m_cref;

	if (cref == 0)
	{
		delete this;
	}

	return(cref);
}


class CSite sealed : public IOleClientSite, public IOleControlSite, public IOleInPlaceSite, public IServiceProvider, public IDispatch, public IInternetSecurityManagerEx2
{
public:
	CSite() : m_cref(1) {};

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	// IOleClientSite

	HRESULT STDMETHODCALLTYPE SaveObject();
	HRESULT STDMETHODCALLTYPE GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
	HRESULT STDMETHODCALLTYPE GetContainer(IOleContainer **ppContainer);
	HRESULT STDMETHODCALLTYPE ShowObject();
	HRESULT STDMETHODCALLTYPE OnShowWindow(BOOL fShow);
	HRESULT STDMETHODCALLTYPE RequestNewObjectLayout();

	// IOleControlSite

	HRESULT STDMETHODCALLTYPE OnControlInfoChanged();
	HRESULT STDMETHODCALLTYPE LockInPlaceActive(BOOL fLock);
	HRESULT STDMETHODCALLTYPE GetExtendedControl(IDispatch **ppDisp);
	HRESULT STDMETHODCALLTYPE TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer, DWORD dwFlags);
	HRESULT STDMETHODCALLTYPE TranslateAccelerator(MSG *pMsg, DWORD grfModifiers);
	HRESULT STDMETHODCALLTYPE OnFocus(BOOL fGotFocus);
	HRESULT STDMETHODCALLTYPE ShowPropertyFrame();

	// IOleWindow

	HRESULT STDMETHODCALLTYPE GetWindow(HWND *phwnd);
	HRESULT STDMETHODCALLTYPE ContextSensitiveHelp(BOOL fEnterMode);

	// IOleInPlaceSite

	HRESULT STDMETHODCALLTYPE CanInPlaceActivate();
	HRESULT STDMETHODCALLTYPE OnInPlaceActivate();
	HRESULT STDMETHODCALLTYPE OnUIActivate();
	HRESULT STDMETHODCALLTYPE GetWindowContext(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo);
	HRESULT STDMETHODCALLTYPE Scroll(SIZE scrollExtant);
	HRESULT STDMETHODCALLTYPE OnUIDeactivate(BOOL fUndoable);
	HRESULT STDMETHODCALLTYPE OnInPlaceDeactivate();
	HRESULT STDMETHODCALLTYPE DiscardUndoState();
	HRESULT STDMETHODCALLTYPE DeactivateAndUndo();
	HRESULT STDMETHODCALLTYPE OnPosRectChange(LPCRECT lprcPosRect);

	// IServiceProvider

	HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, REFIID riid, void **ppvObject);

	// IDispatch

	HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
	HRESULT STDMETHODCALLTYPE GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
	HRESULT STDMETHODCALLTYPE GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId);
	HRESULT STDMETHODCALLTYPE Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr);

	// IInternetSecurityManager

	HRESULT STDMETHODCALLTYPE SetSecuritySite(IInternetSecurityMgrSite *pSite);
	HRESULT STDMETHODCALLTYPE GetSecuritySite(IInternetSecurityMgrSite **ppSite);
	HRESULT STDMETHODCALLTYPE MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags);
	HRESULT STDMETHODCALLTYPE GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved);
	HRESULT STDMETHODCALLTYPE ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved);
	HRESULT STDMETHODCALLTYPE QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved);
	HRESULT STDMETHODCALLTYPE SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags);
	HRESULT STDMETHODCALLTYPE GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags);

	// IInternetSecurityManagerEx

	HRESULT STDMETHODCALLTYPE ProcessUrlActionEx(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved, DWORD *pdwOutFlags);

	// IInternetSecurityManagerEx2

	HRESULT STDMETHODCALLTYPE MapUrlToZoneEx2(IUri *pUri, DWORD *pdwZone, DWORD dwFlags, LPWSTR *ppwszMappedUrl, DWORD *pdwOutFlags);
	HRESULT STDMETHODCALLTYPE ProcessUrlActionEx2(IUri *pUri, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD_PTR dwReserved, DWORD *pdwOutFlags);
	HRESULT STDMETHODCALLTYPE GetSecurityIdEx2(IUri *pUri, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved);
	HRESULT STDMETHODCALLTYPE QueryCustomPolicyEx2(IUri *pUri, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD_PTR dwReserved);

	// IDocHostUIHandler

	// UNDONE:

	// IDocHostUIHandler2

	// UNDONE:


public:
	ULONG m_cref;
};

HRESULT STDMETHODCALLTYPE CSite::QueryInterface(REFIID riid, void **ppvObject)
{
	if (IsEqualGUID(riid, IID_IUnknown))
	{
		*ppvObject = (IUnknown *) (IOleClientSite *) this;
	}

	else if (IsEqualGUID(riid, IID_IOleClientSite))
	{
		*ppvObject = (IOleClientSite *) this;
	}

	else if (IsEqualGUID(riid, IID_IOleControlSite))
	{
		*ppvObject = (IOleControlSite *) this;
	}

	else if (IsEqualGUID(riid, IID_IOleWindow))
	{
		*ppvObject = (IOleWindow *) (IOleInPlaceSite *) this;
	}

	else if (IsEqualGUID(riid, IID_IOleInPlaceSite))
	{
		*ppvObject = (IOleInPlaceSite *) this;
	}

	else if (IsEqualGUID(riid, IID_IServiceProvider))
	{
		*ppvObject = (IServiceProvider *) this;
	}

	else if (IsEqualGUID(riid, IID_IDispatch))
	{
		*ppvObject = (IDispatch *) this;
	}

	else if (IsEqualGUID(riid, __uuidof(IInternetSecurityManagerEx2)))
	{
		*ppvObject = (IInternetSecurityManagerEx2 *) this;
	}

	else if (IsEqualGUID(riid, IID_IInternetSecurityManagerEx))
	{
		*ppvObject = (IInternetSecurityManagerEx *) this;
	}

	else if (IsEqualGUID(riid, IID_IInternetSecurityManager))
	{
		*ppvObject = (IInternetSecurityManager *) this;
	}

	else
	{
		*ppvObject = NULL;

		return(E_NOINTERFACE);
	}

	AddRef();

	return(S_OK);
}


ULONG STDMETHODCALLTYPE CSite::AddRef()
{
	return(++m_cref);
}


ULONG STDMETHODCALLTYPE CSite::Release()
{
	ULONG cref = --m_cref;

	if (cref == 0)
	{
		delete this;
	}

	return(cref);
}


HRESULT STDMETHODCALLTYPE CSite::SaveObject()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
	*ppmk = NULL;

	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::GetContainer(IOleContainer **ppContainer)
{
	*ppContainer = NULL;

	return(E_NOINTERFACE);
}


HRESULT STDMETHODCALLTYPE CSite::ShowObject()
{
	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CSite::OnShowWindow(BOOL fShow)
{
	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CSite::RequestNewObjectLayout()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::OnControlInfoChanged()
{
	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CSite::LockInPlaceActive(BOOL fLock)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::GetExtendedControl(IDispatch **ppDisp)
{
	AddRef();

	*ppDisp = this;

	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::TransformCoords(POINTL *pPtlHimetric, POINTF *pPtfContainer, DWORD dwFlags)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::TranslateAccelerator(MSG *pMsg, DWORD grfModifiers)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::OnFocus(BOOL fGotFocus)
{
	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CSite::ShowPropertyFrame()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::GetWindow(HWND *phwnd)
{
	*phwnd = NULL;

	return(E_FAIL);
}


HRESULT STDMETHODCALLTYPE CSite::ContextSensitiveHelp(BOOL fEnterMode)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::CanInPlaceActivate()
{
	return(S_FALSE);
}


HRESULT STDMETHODCALLTYPE CSite::OnInPlaceActivate()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::OnUIActivate()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::GetWindowContext(IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc, LPRECT lprcPosRect, LPRECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo)
{
	*ppFrame = NULL;
	*ppDoc = NULL;

	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::Scroll(SIZE scrollExtant)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::OnUIDeactivate(BOOL fUndoable)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::OnInPlaceDeactivate()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::DiscardUndoState()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::DeactivateAndUndo()
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::OnPosRectChange(LPCRECT lprcPosRect)
{
	return(E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE CSite::QueryService(REFGUID guidService, REFIID riid, void **ppvObject)
{
	// Check if marshaling between MSHTML and COMCHK is expected.  If it is
	// do not support IInternetSecurityManager* because it will not work.
	// This is because URLMON passes NULL for parameters that RPC does not
	// allow to be NULL.

	bool fMarshal = (szMT == NULL) ? fMTA : ((dwCoinit2 & COINIT_APARTMENTTHREADED) == 0);
	if (!fMarshal)
	{

		if (IsEqualGUID(guidService, SID_SInternetSecurityManagerEx2) &&
			IsEqualGUID(riid, __uuidof(IInternetSecurityManagerEx2)))
		{
			// IE 7.0 or later

			return(QueryInterface(riid, ppvObject));
		}

		else if (IsEqualGUID(guidService, SID_SInternetSecurityManagerEx) &&
			IsEqualGUID(riid, IID_IInternetSecurityManagerEx))
		{
			// IE 6.0 SP2 or later

			return(QueryInterface(riid, ppvObject));
		}

		else if (IsEqualGUID(guidService, SID_SInternetSecurityManager) &&
			IsEqualGUID(riid, IID_IInternetSecurityManager))
		{
			return(QueryInterface(riid, ppvObject));
		}
	}

	*ppvObject = NULL;

	// UNDONE: What is correct return for when service not recognized

	return(E_NOINTERFACE);
}


HRESULT STDMETHODCALLTYPE CSite::GetTypeInfoCount(UINT *pctinfo)
{
	*pctinfo = 0;

	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CSite::GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo)
{
	*ppTInfo = NULL;

	return(DISP_E_BADINDEX);
}


HRESULT STDMETHODCALLTYPE CSite::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
{
	for (UINT i = 0; i < cNames; i++)
	{
		rgDispId[i] = DISPID_UNKNOWN;
	}

	return(DISP_E_UNKNOWNNAME);
}


HRESULT STDMETHODCALLTYPE CSite::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
{
	return(DISP_E_MEMBERNOTFOUND);
}

HRESULT STDMETHODCALLTYPE CSite::SetSecuritySite(IInternetSecurityMgrSite *pSite)
{
	return(INET_E_DEFAULT_ACTION);
}

HRESULT STDMETHODCALLTYPE CSite::GetSecuritySite(IInternetSecurityMgrSite **ppSite)
{
	*ppSite = NULL;

	return(INET_E_DEFAULT_ACTION);
}

HRESULT STDMETHODCALLTYPE CSite::MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwFlags)
{
	if (szZone != NULL)
	{
		*pdwZone = dwZone;

		return(S_OK);
	}

	return(INET_E_DEFAULT_ACTION);
}

HRESULT STDMETHODCALLTYPE CSite::GetSecurityId(LPCWSTR pwszUrl, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
{
	return(INET_E_DEFAULT_ACTION);
}

HRESULT STDMETHODCALLTYPE CSite::ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
{
	if (cbPolicy < sizeof(DWORD))
	{
		return(INET_E_DEFAULT_ACTION);
	}

	switch (dwAction)
	{
	case URLACTION_ACTIVEX_OVERRIDE_OPTIN :
	case URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION :
	case URLACTION_ACTIVEX_RUN :
	case URLACTION_BEHAVIOR_RUN :
	case URLACTION_SCRIPT_SAFE_ACTIVEX :
		break;

	case URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY :
	case URLACTION_SCRIPT_OVERRIDE_SAFETY :
		if (!fNoOverrideSafety)
		{
			break;
		}

		// Fall through

	default :
		return(INET_E_DEFAULT_ACTION);
	}

	*(DWORD *) pPolicy = URLPOLICY_ALLOW;

	return(S_OK);
}

HRESULT STDMETHODCALLTYPE CSite::QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwReserved)
{
	return(INET_E_DEFAULT_ACTION);
}


HRESULT STDMETHODCALLTYPE CSite::SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
{
	return(INET_E_DEFAULT_ACTION);
}


HRESULT STDMETHODCALLTYPE CSite::GetZoneMappings(DWORD dwZone, IEnumString **ppenumString, DWORD dwFlags)
{
	return(INET_E_DEFAULT_ACTION);
}

HRESULT STDMETHODCALLTYPE CSite::ProcessUrlActionEx(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved, DWORD *pdwOutFlags)
{
	if (cbPolicy < sizeof(DWORD))
	{
		return(INET_E_DEFAULT_ACTION);
	}

	switch (dwAction)
	{
	case URLACTION_ACTIVEX_OVERRIDE_OPTIN :
	case URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION :
	case URLACTION_ACTIVEX_RUN :
	case URLACTION_BEHAVIOR_RUN :
	case URLACTION_SCRIPT_SAFE_ACTIVEX :
		break;

	case URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY :
	case URLACTION_SCRIPT_OVERRIDE_SAFETY :
		if (!fNoOverrideSafety)
		{
			break;
		}

		// Fall through

	default :
		return(INET_E_DEFAULT_ACTION);
	}

	*(DWORD *) pPolicy = URLPOLICY_ALLOW;

	*pdwOutFlags = PUAFOUT_DEFAULT;

	return(S_OK);
}


HRESULT STDMETHODCALLTYPE CSite::MapUrlToZoneEx2(IUri *pUri, DWORD *pdwZone, DWORD dwFlags, LPWSTR *ppwszMappedUrl, DWORD *pdwOutFlags)
{
	if (szZone != NULL)
	{
		*pdwZone = dwZone;

		return(S_OK);
	}

	return(INET_E_DEFAULT_ACTION);
}

HRESULT STDMETHODCALLTYPE CSite::ProcessUrlActionEx2(IUri *pUri, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy, BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD_PTR dwReserved, DWORD *pdwOutFlags)
{
	if (cbPolicy < sizeof(DWORD))
	{
		return(INET_E_DEFAULT_ACTION);
	}

	switch (dwAction)
	{
	case URLACTION_ACTIVEX_OVERRIDE_OPTIN :
	case URLACTION_ACTIVEX_OVERRIDE_REPURPOSEDETECTION :
	case URLACTION_ACTIVEX_RUN :
	case URLACTION_BEHAVIOR_RUN :
	case URLACTION_SCRIPT_SAFE_ACTIVEX :
		break;

	case URLACTION_ACTIVEX_CONFIRM_NOOBJECTSAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_DATA_SAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_OBJECT_SAFETY :
	case URLACTION_ACTIVEX_OVERRIDE_SCRIPT_SAFETY :
	case URLACTION_SCRIPT_OVERRIDE_SAFETY :
		if (!fNoOverrideSafety)
		{
			break;
		}

		// Fall through

	default :
		return(INET_E_DEFAULT_ACTION);
	}

	*(DWORD *) pPolicy = URLPOLICY_ALLOW;

	*pdwOutFlags = PUAFOUT_DEFAULT;

	return(S_OK);
}

HRESULT STDMETHODCALLTYPE CSite::GetSecurityIdEx2(IUri *pUri, BYTE *pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
{
	return(INET_E_DEFAULT_ACTION);
}


HRESULT STDMETHODCALLTYPE CSite::QueryCustomPolicyEx2(IUri *pUri, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy, BYTE *pContext, DWORD cbContext, DWORD_PTR dwReserved)
{
	return(INET_E_DEFAULT_ACTION);
}




class PropName
{
public:
	PropName(const wchar_t *);
	PropName(const PropName&);
	~PropName();

	wchar_t *m_sz;
};


PropName::PropName(const wchar_t *sz)
{
	m_sz = _wcsdup(sz);
}


PropName::PropName(const PropName& pn)
{
	m_sz = _wcsdup(pn.m_sz);
}


PropName::~PropName()
{
	free(m_sz);
}


bool operator<(const PropName& pnLeft, const PropName& pnRight)
{
	return(wcscmp(pnLeft.m_sz, pnRight.m_sz) < 0);
}


template<>
struct std::pair<const PropName, VARIANT>
{
	pair(const PropName&, const VARIANT&);
	pair(const pair&);
	~pair();

	PropName first;		       // the first stored value
	VARIANT second;		       // the second stored value
};


std::pair<const PropName, VARIANT>::pair(const PropName& pn, const VARIANT& var) : first(pn)
{
	VariantInit(&second);
	VariantCopy(&second, (VARIANT *) &var);
}


std::pair<const PropName, VARIANT>::pair(const pair& p) : first(p.first)
{
	VariantInit(&second);
	VariantCopy(&second, (VARIANT *) &p.second);
}


std::pair<const PropName, VARIANT>::~pair()
{
	VariantClear(&second);
}


class CPropertyBag sealed : public IPropertyBag
{
public:
	CPropertyBag() : m_cref(1) {};

	HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	HRESULT STDMETHODCALLTYPE Read(LPCOLESTR szPropName, VARIANT *pvar, IErrorLog *piel);
	HRESULT STDMETHODCALLTYPE Write(LPCOLESTR szPropName, VARIANT *pvar);

public:
	typedef std::pair<const PropName, VARIANT> NameAndValue;
	typedef std::map<const PropName, VARIANT> PropertyMap;

	ULONG m_cref;

	PropertyMap m_pm;
};


HRESULT STDMETHODCALLTYPE CPropertyBag::QueryInterface(REFIID riid, void **ppvObject)
{
	if (IsEqualGUID(riid, IID_IUnknown))
	{
		*ppvObject = (IUnknown *) this;
	}

	else if (IsEqualGUID(riid, IID_IPropertyBag))
	{
		*ppvObject = (IPropertyBag *) this;
	}

	else
	{
		*ppvObject = NULL;

		return(E_NOINTERFACE);
	}

	AddRef();

	return(S_OK);
}


ULONG STDMETHODCALLTYPE CPropertyBag::AddRef()
{
	return(++m_cref);
}


ULONG STDMETHODCALLTYPE CPropertyBag::Release()
{
	ULONG cref = --m_cref;

	if (cref == 0)
	{
		delete this;
	}

	return(cref);
}


HRESULT STDMETHODCALLTYPE CPropertyBag::Read(LPCOLESTR szPropName, VARIANT *pvar, IErrorLog *piel)
{
#if 0
	wprintf(L"*** reading %s of type %u\n", szPropName, pvar->vt);
#endif

	if (piel != NULL)
	{
		TestInterface(piel, NULL, false, false);
	}

	VARTYPE vt = pvar->vt;

	// Initialize the output.  The only member that is required to be initialized
	// is vt.  Specifically, the value may be garbage.  Both VariantChangeType
	// and VariantCopy below will pass this to VariantClear which will do bad
	// things with the garbage.

	MyVariantInit(pvar);

	HRESULT hr;

	PropName pn(szPropName);

	PropertyMap::const_iterator it = m_pm.find(pn);

	if (it == m_pm.end())
	{
		// Property not found.  Always try to return some default value

		if (vt == VT_EMPTY)
		{
			// The VARIANT is already VT_EMPTY.  Don't call VariantChangeType because
			// it will store uninitialized values in the other members.  We want the
			// initialized values from MyVariantInit to be preserved.

			return(S_OK);
		}

		hr = VariantChangeType(pvar, pvar, 0, vt);

		return(SUCCEEDED(hr) ? hr : E_INVALIDARG);
	}

	if (vt == VT_EMPTY)
	{
		hr = VariantCopy(pvar, (VARIANT *) &it->second);
	}

	else
	{
		hr = VariantChangeType(pvar, (VARIANT *) &it->second, VARIANT_NOVALUEPROP, vt);
	}

	return(hr);
}


HRESULT STDMETHODCALLTYPE CPropertyBag::Write(LPCOLESTR szPropName, VARIANT *pvar)
{
#if 0
	wprintf(L"*** writing %s of type %u\n", szPropName, pvar->vt);
#endif

	switch (pvar->vt)
	{
	case VT_DISPATCH :
		if (V_DISPATCH(pvar) != NULL)
		{
			TestInterface(V_DISPATCH(pvar), NULL, false, false);
		}
		break;

	case VT_UNKNOWN :
		if (V_UNKNOWN(pvar) != NULL)
		{
			TestInterface(V_UNKNOWN(pvar), NULL, true, false);
		}
		break;

	case VT_STREAM :
	case VT_STORAGE :
	case VT_STREAMED_OBJECT :
	case VT_STORED_OBJECT :
	case VT_BLOB_OBJECT :
		break;
	}

	PropName pn(szPropName);
	NameAndValue nav(pn, *pvar);

	std::pair<PropertyMap::iterator, bool> pr = m_pm.insert(nav);

	if (!pr.second)
	{
		// Property already exists.  Update value

		VariantCopy(&pr.first->second, pvar);
	}

	return(S_OK);
}


void DoRecurse(const wchar_t *szPrefixT)
{
	fflush(NULL);

	STARTUPINFO si;

	memset(&si, 0, sizeof(STARTUPINFO));
	si.cb = sizeof(STARTUPINFO);

	PROCESS_INFORMATION pi;

	wchar_t szCommandLine[4096];
	const size_t cchCommandLine = _countof(szCommandLine);

	const wchar_t *szProgram = (szInvoke != NULL) ? szInvoke : _wpgmptr;

	wcscpy_s(szCommandLine, cchCommandLine, L"\"");
	wcsncat_s(szCommandLine, cchCommandLine, szProgram, _TRUNCATE);
	wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);

	if (szInvoke != NULL)
	{
		if (szInvokePrefix != NULL)
		{
			DWORD_PTR rgarg[3] =
			{
				(DWORD_PTR) szClsid,
				(DWORD_PTR) szProgid,
				(DWORD_PTR) szIid,
			};

			wchar_t *sz;

			DWORD dw = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
				FORMAT_MESSAGE_FROM_STRING |
				FORMAT_MESSAGE_ARGUMENT_ARRAY,
				szInvokePrefix,
				0,
				0,
				(LPWSTR) &sz,
				0,
				(va_list *) rgarg);

			if (dw == 0)
			{
				wprintf(L"FormatMessage failed.  GetLastError() = %u\n", GetLastError());
				return;
			}

			wcsncat_s(szCommandLine, cchCommandLine, L" ", _TRUNCATE);
			wcsncat_s(szCommandLine, cchCommandLine, sz, _TRUNCATE);

			LocalFree(sz);
		}

		wcsncat_s(szCommandLine, cchCommandLine, L" \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, _wpgmptr, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (blevel)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -level \"", _TRUNCATE);
		WCHAR wc[20];
		_itow(ilevel, wc, 10);
		wcsncat_s(szCommandLine, cchCommandLine, wc, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (szAddToDocument)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -addtodocument \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szAddToDocument, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fAggregate)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -aggregate", _TRUNCATE);
	}

	if (fBindToObject)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -bindtoobject", _TRUNCATE);
	}

	if (fBindToStorage)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -bindtostorage", _TRUNCATE);
	}

	if (fCheckSafety)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -checksafety", _TRUNCATE);
	}

	if (szClsctx != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -clsctx \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szClsctx, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if ((szClsid != NULL) && (szProgid == NULL))
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -clsid \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szClsid, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fCreateOnly)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -createonly", _TRUNCATE);
	}

	if (szData != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -data \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szData, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (szDispatchMax != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -dispatchmax \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szDispatchMax, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fFakeDebugger)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -fakedebugger", _TRUNCATE);
	}

	if (fFreeCO)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -freeco", _TRUNCATE);
	}


	if (fIgnoreRpcExcept)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -ignorerpcexcept", _TRUNCATE);
	}

	if (fHTML && !fWebBrowser)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -html", _TRUNCATE);
	}

	if (fStdModes)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -stdmodes", _TRUNCATE);
	}

	if (szHookDll != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -hookdll \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szHookDll, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (szIid != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -iid \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szIid, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (szMoniker != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -moniker \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szMoniker, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (szMT != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -mt \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szMT, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fMTA)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -mta", _TRUNCATE);
	}

	if (fNoCategoryCheck)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -nocategorycheck", _TRUNCATE);
	}

	if (fNoVectoredExceptions)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noexcept", _TRUNCATE);
	}

	if (fNoFakeDebugger)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -nofakedebugger", _TRUNCATE);
	}

	if (fNoFree)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -nofree", _TRUNCATE);
	}

	if (fNoIDispatch)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noidispatch", _TRUNCATE);
	}

	if (fNoIDispatchFuzz)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noidispatchfuzz", _TRUNCATE);
	}

	if (fNoIgnoreBreakpoint)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noignorebreakpoint", _TRUNCATE);
	}

	if (fNoIgnoreClrExcept)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noignoreclrexcept", _TRUNCATE);
	}

	if (fNoIgnoreCppExcept)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noignorecppexcept", _TRUNCATE);
	}

	if (fNoIgnoreDelayLoadExcept)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noignoredelayloadexcept", _TRUNCATE);
	}

	if (fNoIgnoreFloatExcept)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noignorefloatexcept", _TRUNCATE);
	}

	if (fNoIgnoreXmlExcept)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -noignorexmlexcept", _TRUNCATE);
	}

	if (fNoOverrideSafety)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -nooverridesafety", _TRUNCATE);
	}

	if (fNoPatchBreakpoint)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -nopatchbreakpoint", _TRUNCATE);
	}

	if (fNoWindowHook)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -nowindowhook", _TRUNCATE);
	}

	if (fObjrefMoniker)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -objref", _TRUNCATE);
	}

	if (szPrefixT != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -prefix \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szPrefixT, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (szProgid != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -progid \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szProgid, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fSafeForInitializing)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -safeforinitializing", _TRUNCATE);
	}

	if (fSafeForScripting)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -safeforscripting", _TRUNCATE);
	}

	if (fSDL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -sdlout", _TRUNCATE);
	}

	if (fSilent)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -silent", _TRUNCATE);
	}

	if (szTimeout != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -timeout \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szTimeout, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fTryQI)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -tryqi", _TRUNCATE);
	}

	if (szUrl != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -url \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szUrl, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}

	if (fUrlMoniker)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -urlmoniker", _TRUNCATE);
	}

	if (fUseCF)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -usecf", _TRUNCATE);
	}

	if (fUsePS)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -useps", _TRUNCATE);
	}

	if (fVerbose)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -verbose", _TRUNCATE);
	}

	if (fWebBrowser)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -webbrowser", _TRUNCATE);
	}

	if (szZone != NULL)
	{
		wcsncat_s(szCommandLine, cchCommandLine, L" -zone \"", _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, szZone, _TRUNCATE);
		wcsncat_s(szCommandLine, cchCommandLine, L"\"", _TRUNCATE);
	}


	if (!CreateProcess(szProgram,
		szCommandLine,
		NULL,
		NULL,
		FALSE,			
		0,
		NULL,
		NULL,
		&si,
		&pi))
	{
		wprintf(L"CreateProcess() failed.  GetLastError() = %u\n", GetLastError());

		return;
	}

	CloseHandle(pi.hThread);

	DWORD dw = WaitForSingleObject(pi.hProcess, fStdModes ? INFINITE : dwTimeout);

	if (dw == WAIT_TIMEOUT)
	{
		wprintf(L"*Timeout: %s\n", szCommandLine);

		PipeMsg pmTO;
		pmTO.AddDWORD(5);
		pmTO.AddString(szCommandLine);
		pmTO.Send(hPipeInfoSend);

		TerminateProcess(pi.hProcess, 0xFFFFFFFF);
	}

	else if (GetExitCodeProcess(pi.hProcess, &dw))
	{
		if (dw != 0)
		{
			// Richard -- is this necessary?  Should be already reported.
			//		   wprintf(L"%08X: %s\n", dw, szCommandLine);

		}
	}

	else
	{
		wprintf(L"????????: %s\n", szCommandLine);
		PipeMsg pmHuh;
		pmHuh.AddDWORD(6);
		pmHuh.AddString(szCommandLine);
		pmHuh.Send(hPipeInfoSend);
	}

	CloseHandle(pi.hProcess);

}




int DoStdModes()
{
	fStdModes = false;		// suppress for recursion

	_putws(L"--------: Start default parameters");

	DoRecurse(NULL);

	_putws(L"--------: Finished default parameters");

	_putws(L"--------: Start -mta");

	fMTA = true;

	DoRecurse(NULL);

	fMTA = false;

	_putws(L"--------: Finished -mta");

	_putws(L"--------: Start -aggregate");

	fAggregate = true;

	DoRecurse(NULL);

	fAggregate = false;

	_putws(L"--------: Finished -aggregate");

	_putws(L"--------: Start -aggregate -mta");

	fAggregate = true;
	fMTA = true;

	DoRecurse(NULL);

	fMTA = false;
	fAggregate = false;

	_putws(L"--------: Finished -aggregate -mta");

	if (!fUsePS)
	{
		_putws(L"--------: Start -usecf");

		fUseCF = true;

		DoRecurse(NULL);

		fUseCF = false;

		_putws(L"--------: Finished -usecf");

		_putws(L"--------: Start -mta -usecf");

		fMTA = true;
		fUseCF = true;

		DoRecurse(NULL);

		fMTA = false;
		fUseCF = false;

		_putws(L"--------: Finished -mta -usecf");

		_putws(L"--------: Start -html");

		fHTML = true;

		DoRecurse(NULL);

		fHTML = false;

		_putws(L"--------: Finished -html");

		_putws(L"--------: Start -webbrowser");

		fWebBrowser = true;

		DoRecurse(NULL);

		fWebBrowser = false;

		_putws(L"--------: Finished -webbrowser");
	}

	return(0);
}


int DoAllClsids()
{
	HKEY hkeyClsid;

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, KEY_READ, &hkeyClsid))
	{
		wprintf(L"RegOpenKeyEx() failed.  GetLastError() = %u\n", GetLastError());

		return(1);
	}

	wchar_t szClsidT[256];

	szClsid = szClsidT;

	for (DWORD ikey = 1; ; ikey++)
	{
		LONG l = RegEnumKey(hkeyClsid, ikey, szClsidT, _countof(szClsidT));

		if (l != 0)
		{
			// UNDONE: Check for proper error

			break;
		}

		if (szClsidT[0] != L'{')
		{
			continue;
		}

		DoRecurse(NULL);
	}

	if (RegCloseKey(hkeyClsid))
	{
		wprintf(L"RegCloseKey() failed.  GetLastError() = %u\n", GetLastError());

		return(1);
	}

	return(0);
}


int DoClsidsFromFile(const wchar_t *szFilename)
{
	FILE *pfile = _wfsopen(szFilename, L"rt,ccs=unicode", _SH_DENYWR);

	if (pfile == NULL)
	{
		wprintf(L"_wfsopen(\"%s\") failed.  _doserrno = %u\n", szFilename, _doserrno);

		return(1);
	}

	wchar_t szClsidT[256];

	while (fgetws(szClsidT, 256, pfile))
	{
		szClsid = szClsidT;

		// Skip leading white space.

		while ((szClsid[0] == L' ') || (szClsid[0] == L'\t'))
		{
			szClsid++;
		}

		if (szClsid[0] == L'\0')
		{
			// Empty line

			continue;
		}

		if (szClsid[0] == L';')
		{
			// Comment line

			continue;
		}

		wchar_t *pchEnd = szClsid;

		for (wchar_t *pch = szClsid; *pch != L'\0'; pch++)
		{
			if ((*pch == L'\n') || (*pch == L'\r'))
			{
				// Terminate at end of line

				*pch = L'\0';
				break;
			}

			if ((*pch != L' ') && (*pch != L'\t'))
			{
				// Remember last non-white space character

				pchEnd = pch + 1;
			}
		}

		// Trim trailing white space

		*pchEnd = L'\0';

		DoRecurse(NULL);
	}

	fclose(pfile);

	return(0);
}


int DoAllIids()
{
	HKEY hkeyInterface;

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("Interface"), 0, KEY_READ, &hkeyInterface))
	{
		wprintf(L"RegOpenKeyEx() failed.  GetLastError() = %u\n", GetLastError());

		return(1);
	}

	wchar_t szIidT[256];

	szIid = szIidT;

	for (DWORD ikey = 1; ; ikey++)
	{
		LONG l = RegEnumKey(hkeyInterface, ikey, szIidT, _countof(szIidT));

		if (l != 0)
		{
			// UNDONE: Check for proper error

			break;
		}

		// UNDONE: Compose prefix if szProgid or szClsid != NULL

		DoRecurse(NULL);
	}

	if (RegCloseKey(hkeyInterface))
	{
		wprintf(L"RegCloseKey() failed.  GetLastError() = %u\n", GetLastError());

		return(1);
	}

	return(0);
}


int DoIidsFromFile(const wchar_t *szFilename)
{
	FILE *pfile = _wfsopen(szFilename, L"rt,ccs=unicode", _SH_DENYWR);

	if (pfile == NULL)
	{
		wprintf(L"_wfsopen(\"%s\") failed.  _doserrno = %u\n", szFilename, _doserrno);

		return(1);
	}

	wchar_t szIidT[256];

	while (fgetws(szIidT, 256, pfile))
	{
		szIid = szIidT;

		// Skip leading white space.

		while ((szIid[0] == L' ') || (szIid[0] == L'\t'))
		{
			szIid++;
		}

		if (szIid[0] == L'\0')
		{
			// Empty line

			continue;
		}

		if (szIid[0] == L';')
		{
			// Comment line

			continue;
		}

		wchar_t *pchEnd = szIid;

		for (wchar_t *pch = szIid; *pch != L'\0'; pch++)
		{
			if ((*pch == L'\n') || (*pch == L'\r'))
			{
				// Terminate at end of line

				*pch = L'\0';
				break;
			}

			if ((*pch != L' ') && (*pch != L'\t'))
			{
				// Remember last non-white space character

				pchEnd = pch + 1;
			}
		}

		// Trim trailing white space

		*pchEnd = L'\0';

		// UNDONE: Compose prefix if szProgid or szClsid != NULL

		DoRecurse(NULL);
	}

	fclose(pfile);

	return(0);
}


int QueryInterfaceAllIids(IUnknown *punk, bool fClassObject)
{
	HKEY hkeyInterface;

	if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("Interface"), 0, KEY_READ, &hkeyInterface))
	{
		wprintf(L"RegOpenKeyEx() failed.  GetLastError() = %u\n", GetLastError());

		return(1);
	}

	wchar_t szIidT[256];

	szIid = szIidT;

	for (DWORD ikey = 1; ; ikey++)
	{
		LONG l = RegEnumKey(hkeyInterface, ikey, szIidT, _countof(szIidT));

		if (l != 0)
		{
			// UNDONE: Check for proper error

			break;
		}

		IID iidT;

		HRESULT hr = IIDFromString(szIidT, &iidT);

		if (FAILED(hr))
		{
			wprintf(L"Invalid IID \"%s\".  HRESULT = %08X\n", szIidT, hr);
			continue;
		}

		const wchar_t *szIidName;

		wchar_t szName[256];
		long cbName = sizeof(szName);

		if (RegQueryValue(hkeyInterface, szIidT, szName, &cbName) == 0)
		{
			szName[255] = L'\0';

			szIidName = szName;
		}

		else
		{
			szIidName = szIidT;
		}

		IUnknown *punkT;

		hr = HrQueryInterface(punk, fClassObject, szIidName, iidT, (void **) &punkT);

		if (SUCCEEDED(hr))
		{
			if (szIidName != szIidT)
			{
				ReportFailure(0x0701, fCreateOnly, NULL, 0, L"QueryInterface(%s) succeeded: %s", szIidT, szIidName);
			}
			else
			{
				ReportFailure(0x0701, fCreateOnly, NULL, 0, L"QueryInterface(%s) succeeded", szIidT);
			}

			Release(punkT, fClassObject);
		}
	}

	if (RegCloseKey(hkeyInterface))
	{
		wprintf(L"RegCloseKey() failed.  GetLastError() = %u\n", GetLastError());

		return(1);
	}

	return(0);
}


int QueryInterfaceIidsFromFile(IUnknown *punk, bool fClassObject, const wchar_t *szFilename)
{
	FILE *pfile = _wfsopen(szFilename, L"rt,ccs=unicode", _SH_DENYWR);

	if (pfile == NULL)
	{
		wprintf(L"_wfsopen(\"%s\") failed.  _doserrno = %u\n", szFilename, _doserrno);

		return(1);
	}

	wchar_t szIidT[256];

	while (fgetws(szIidT, 256, pfile))
	{
		szIid = szIidT;

		// Skip leading white space.

		while ((szIid[0] == L' ') || (szIid[0] == L'\t'))
		{
			szIid++;
		}

		if (szIid[0] == L'\0')
		{
			// Empty line

			continue;
		}

		if (szIid[0] == L';')
		{
			// Comment line

			continue;
		}

		wchar_t *pchEnd = szIid;

		for (wchar_t *pch = szIid; *pch != L'\0'; pch++)
		{
			if ((*pch == L'\n') || (*pch == L'\r'))
			{
				// Terminate at end of line

				*pch = L'\0';
				break;
			}

			if ((*pch != L' ') && (*pch != L'\t'))
			{
				// Remember last non-white space character

				pchEnd = pch + 1;
			}
		}

		// Trim trailing white space

		*pchEnd = L'\0';

		IID iidT;

		HRESULT hr = IIDFromString(szIidT, &iidT);

		if (FAILED(hr))
		{
			wprintf(L"Invalid IID \"%s\".  HRESULT = %08X\n", szIidT, hr);
			continue;
		}

		IUnknown *punkT;

		hr = HrQueryInterface(punk, fClassObject, szIidT, iidT, (void **) &punkT);

		if (SUCCEEDED(hr))
		{
			ReportFailure(0x0801, fCreateOnly, NULL, 0, L"QueryInterface(%s) succeeded", szIidT);

			Release(punkT, fClassObject);
		}
	}

	fclose(pfile);

	return(0);
}


int DoAllProgids()
{
	wchar_t szProgidT[MAX_PATH];

	szProgid = szProgidT;

	for (DWORD ikey = 1; ; ikey++)
	{
		LONG l = RegEnumKey(HKEY_CLASSES_ROOT, ikey, szProgidT, _countof(szProgidT));

		if (l != 0)
		{
			// UNDONE: Check for proper error

			break;
		}

		if (szProgid[0] == L'.')
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"*") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"APPID") == 0)
		{
			continue;
		}

#if 0
		if (_wcsicmp(szProgid, L"CLSID") == 0)
		{
			continue;
		}
#endif

		if (_wcsicmp(szProgid, L"Component Categories") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"Interface") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"MIME") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"PROTOCOLS") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"SystemFileAssociations") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"TypeLib") == 0)
		{
			continue;
		}

		if (_wcsicmp(szProgid, L"Wow6432Node") == 0)
		{
			continue;
		}

		wchar_t szT[MAX_PATH + 6];

		wcscpy_s(szT, _countof(szT), szProgid);
		wcscat_s(szT, _countof(szT), L"\\CLSID");

		LONG cbClsid;

		l = RegQueryValue(HKEY_CLASSES_ROOT, szT, NULL, &cbClsid);

		if (l == ERROR_PATH_NOT_FOUND)
		{
			continue;
		}

		CLSID clsidT;

		HRESULT hr = CLSIDFromProgID(szProgid, &clsidT);

		if (FAILED(hr))
		{
			continue;
		}

		DoRecurse(NULL);
	}

	return(0);
}


int DoProgidsFromFile(const wchar_t *szFilename)
{
	FILE *pfile = _wfsopen(szFilename, L"rt,ccs=unicode", _SH_DENYWR);

	if (pfile == NULL)
	{
		wprintf(L"_wfsopen(\"%s\") failed.  _doserrno = %u\n", szFilename, _doserrno);

		return(1);
	}

	wchar_t szProgidT[256];

	while (fgetws(szProgidT, 256, pfile))
	{
		szProgid = szProgidT;

		// Skip leading white space.

		while ((szProgid[0] == L' ') || (szProgid[0] == L'\t'))
		{
			szProgid++;
		}

		if (szProgid[0] == L'\0')
		{
			// Empty line

			continue;
		}

		if (szProgid[0] == L';')
		{
			// Comment line

			continue;
		}

		wchar_t *pchEnd = szProgid;

		for (wchar_t *pch = szProgid; *pch != L'\0'; pch++)
		{
			if ((*pch == L'\n') || (*pch == L'\r'))
			{
				// Terminate at end of line

				*pch = L'\0';
				break;
			}

			if ((*pch != L' ') && (*pch != L'\t'))
			{
				// Remember last non-white space character

				pchEnd = pch + 1;
			}
		}

		// Trim trailing white space

		*pchEnd = L'\0';

		DoRecurse(NULL);
	}

	fclose(pfile);

	return(0);
}


int CheckObjrefMoniker(IUnknown *punk, bool fClassObject)
{
	IMoniker *pmk;

	HRESULT hr = CreateObjrefMoniker(punk, &pmk);

	if (SUCCEEDED(hr))
	{
		IncrementObjectCount(fClassObject);

		FreeUnusedLibraries();

		IBindCtx *pbc = NULL;

		HRESULT hr = CreateBindCtx(0, &pbc);

		if (SUCCEEDED(hr))
		{
			wchar_t *szDisplayName;

			hr = pmk->GetDisplayName(pbc, NULL, &szDisplayName);

			if (SUCCEEDED(hr))
			{
#if 0
				wprintf(L"Moniker: %s\n", szDisplayName);
#endif

				DWORD cchEaten;
				IMoniker *pmk2;

				hr = MkParseDisplayName(pbc, szDisplayName, &cchEaten, &pmk2);

				if (SUCCEEDED(hr))
				{
					IncrementObjectCount(fClassObject);

					FreeUnusedLibraries();

					if (cchEaten != wcslen(szDisplayName))
					{
						ReportFailure(0x0901, false, NULL, 0, L"MkParseDisplayName consumed only part of OBJREF");
					}

					// Capture address of Release() method since after release the memory may be gone

					const void *pvRelease = PvMethod(pmk2, 2);

					ULONG cref = Release(pmk2, fClassObject);

					if (cref != 0)
					{
						ReportFailure(0x0902, false, pvRelease, -1, L"IMoniker::Release returned %u", cref);
					}
				}

				else
				{
					ReportFailure(0x0903, false, NULL, 0, L"MkParseDisplayName(\"%s\") failed.  hr = %08X", szDisplayName, hr);
				}

				CoTaskMemFree(szDisplayName);
			}

			else
			{
				ReportFailure(0x0904, false, pmk, 20, L"IMoniker::GetDisplayName failed.  hr = %08X", hr);
			}

			// Capture address of Release() method since after release the memory may be gone

			const void *pvRelease = PvMethod(pbc, 2);

			ULONG cref = pbc->Release();

			if (cref != 0)
			{
				ReportFailure(0x0905, false, pvRelease, -1, L"IBindCtx::Release returned %u", cref);
			}
		}

		// Capture address of Release() method since after release the memory may be gone

		const void *pvRelease = PvMethod(pmk, 2);

		ULONG cref = Release(pmk, fClassObject);

		if (cref != 0)
		{
			ReportFailure(0x0906, false, pvRelease, -1, L"IMoniker::Release returned %u", cref);
		}
	}

	return(0);
}



int GetInterfaceSafetyOptions(IObjectSafety *pios, REFIID iid, const wchar_t *szIid, bool *pfSupported, DWORD *pdwSupported, DWORD *pdwEnabled)
{
	HRESULT hr = pios->GetInterfaceSafetyOptions(iid, pdwSupported, pdwEnabled);

	*pfSupported = SUCCEEDED(hr);

	if (*pfSupported)
	{
		if (*pdwSupported & ~(INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA | INTERFACE_USES_DISPEX | INTERFACE_USES_SECURITY_MANAGER))
		{
			ReportFailure(0x0A01, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s): Undefined options supported.  Supported=%08X, Enabled=%08X", szIid, *pdwSupported, *pdwEnabled);
		}

		if ((*pdwEnabled & ~*pdwSupported) != 0)
		{
			ReportFailure(0x0A02, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s): Unsupported options enabled.  Supported=%08X, Enabled=%08X", szIid, *pdwSupported, *pdwEnabled);
		}
	}

	else if (hr != E_NOINTERFACE)
	{
		ReportFailure(0x0A03, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) did not return E_NOINTERFACE.  hr = %08X", szIid, hr);
	}

	return(0);
}


int SetInterfaceSafetyOptions(IObjectSafety *pios, REFIID iid, const wchar_t *szIid, bool fSupported, DWORD dwSupported, DWORD dwEnabled)
{
	HRESULT hr = pios->SetInterfaceSafetyOptions(iid, dwSupported, dwEnabled);

	if (SUCCEEDED(hr))
	{
		if (!fSupported)
		{
			ReportFailure(0x0B01, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, %08X) succeeded when GetInterfaceSafetyOptions failed", szIid, dwSupported, dwEnabled);

			return(0x0B01);
		}

		DWORD dwSupportedT;
		DWORD dwEnabledT;

		hr = pios->GetInterfaceSafetyOptions(iid, &dwSupportedT, &dwEnabledT);

		if (SUCCEEDED(hr))
		{
			if (dwSupportedT != dwSupported)
			{
				ReportFailure(0x0B02, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwSupported changed from %08X to %08X", szIid, dwSupported, dwSupportedT);
			}

			if (dwEnabledT != dwEnabled)
			{
				ReportFailure(0x0B03, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwEnabled changed from %08X to %08X", szIid, dwEnabled, dwEnabledT);
			}
		}

		else
		{
			ReportFailure(0x0B04, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) failed.  hr = %08X", szIid, hr);

			return(0x0B04);
		}
	}

	// else if (fSupported)
	else if (fSupported && (dwSupported != 0))
	{
		ReportFailure(0x0B05, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, %08X) failed.  hr = %08X", szIid, dwSupported, dwEnabled, hr);
	}

	else
	{
		return(0);
	}

	hr = pios->SetInterfaceSafetyOptions(iid, ~dwSupported, 0);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x0B06, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, 00000000) succeeded", szIid, ~dwSupported);
	}

	else if (hr != E_FAIL)
	{
		ReportFailure(0x0B07, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, 00000000) did not return E_FAIL.  hr = %08X", szIid, ~dwSupported, hr);
	}

	hr = pios->SetInterfaceSafetyOptions(iid, dwSupported, 0);

	if (SUCCEEDED(hr))
	{
		DWORD dwSupportedT;
		DWORD dwEnabledT;

		hr = pios->GetInterfaceSafetyOptions(iid, &dwSupportedT, &dwEnabledT);

		if (SUCCEEDED(hr))
		{
			if (dwSupportedT != dwSupported)
			{
				ReportFailure(0x0B08, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwSupported changed from %08X to %08X", szIid, dwSupported, dwSupportedT);
			}

			if (dwEnabledT != 0)
			{
				ReportFailure(0x0B09, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, 00000000) set dwEnabled to %08X", szIid, dwSupported, dwEnabledT);
			}
		}

		else
		{
			ReportFailure(0x0B0A, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) failed.  hr = %08X", szIid, hr);
		}
	}

	else
	{
		ReportFailure(0x0B0B, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, 00000000) failed.  hr = %08X", szIid, dwSupported, hr);
	}

	hr = pios->SetInterfaceSafetyOptions(iid, dwSupported, dwEnabled);

	if (SUCCEEDED(hr))
	{
		DWORD dwSupportedT;
		DWORD dwEnabledT;

		hr = pios->GetInterfaceSafetyOptions(iid, &dwSupportedT, &dwEnabledT);

		if (SUCCEEDED(hr))
		{
			if (dwSupportedT != dwSupported)
			{
				ReportFailure(0x0B0C, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwSupported changed from %08X to %08X", szIid, dwSupported, dwSupportedT);
			}

			if (dwEnabledT != dwEnabled)
			{
				ReportFailure(0x0B0D, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, %08X) set dwEnabled to %08X", szIid, dwSupported, dwEnabled, dwEnabledT);
			}
		}

		else
		{
			ReportFailure(0x0B0E, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) failed.  hr = %08X", szIid, hr);
		}
	}

	else
	{
		ReportFailure(0x0B0F, false, pios, 4, L"IObjectSafety::SetInterfaceSafetyOptions(%s, %08X, %08X) failed.  hr = %08X", szIid, dwSupported, dwEnabled, hr);
	}

	return(0);
}


struct DISPIDS
{
	DISPID dispid;
	const wchar_t *sz;

};

const DISPIDS rgdispids[] =
{
	{ DISPID_VALUE,			     L"DISPID_VALUE"			       },
	{ DISPID_PROPERTYPUT,		     L"DISPID_PROPERTYPUT"		       },
	{ DISPID_NEWENUM,			     L"DISPID_NEWENUM"			       },
	{ DISPID_EVALUATE,			     L"DISPID_EVALUATE" 		       },
	{ DISPID_CONSTRUCTOR,		     L"DISPID_CONSTRUCTOR"		       },
	{ DISPID_DESTRUCTOR, 		     L"DISPID_DESTRUCTOR"		       },
	{ DISPID_COLLECT,			     L"DISPID_COLLECT"			       },

	{ DISPID_AUTOSIZE,			     L"DISPID_AUTOSIZE" 		       },
	{ DISPID_BACKCOLOR,			     L"DISPID_BACKCOLOR"		       },
	{ DISPID_BACKSTYLE,			     L"DISPID_BACKSTYLE"		       },
	{ DISPID_BORDERCOLOR,		     L"DISPID_BORDERCOLOR"		       },
	{ DISPID_BORDERSTYLE,		     L"DISPID_BORDERSTYLE"		       },
	{ DISPID_BORDERWIDTH,		     L"DISPID_BORDERWIDTH"		       },
	{ DISPID_DRAWMODE,			     L"DISPID_DRAWMODE" 		       },
	{ DISPID_DRAWSTYLE,			     L"DISPID_DRAWSTYLE"		       },
	{ DISPID_DRAWWIDTH,			     L"DISPID_DRAWWIDTH"		       },
	{ DISPID_FILLCOLOR,			     L"DISPID_FILLCOLOR"		       },
	{ DISPID_FILLSTYLE,			     L"DISPID_FILLSTYLE"		       },
	{ DISPID_FONT,			     L"DISPID_FONT"			       },
	{ DISPID_FORECOLOR,			     L"DISPID_FORECOLOR"		       },
	{ DISPID_ENABLED,			     L"DISPID_ENABLED"			       },
	{ DISPID_HWND,			     L"DISPID_HWND"			       },
	{ DISPID_TABSTOP,			     L"DISPID_TABSTOP"			       },
	{ DISPID_TEXT,			     L"DISPID_TEXT"			       },
	{ DISPID_CAPTION,			     L"DISPID_CAPTION"			       },
	{ DISPID_BORDERVISIBLE,		     L"DISPID_BORDERVISIBLE"		       },
	{ DISPID_APPEARANCE, 		     L"DISPID_APPEARANCE"		       },
	{ DISPID_MOUSEPOINTER,		     L"DISPID_MOUSEPOINTER"		       },
	{ DISPID_MOUSEICON,			     L"DISPID_MOUSEICON"		       },
	{ DISPID_PICTURE,			     L"DISPID_PICTURE"			       },
	{ DISPID_VALID,			     L"DISPID_VALID"			       },
	{ DISPID_READYSTATE, 		     L"DISPID_READYSTATE"		       },
	{ DISPID_LISTINDEX,			     L"DISPID_LISTINDEX"		       },
	{ DISPID_SELECTED,			     L"DISPID_SELECTED" 		       },
	{ DISPID_LIST,			     L"DISPID_LIST"			       },
	{ DISPID_COLUMN,			     L"DISPID_COLUMN"			       },
	{ DISPID_LISTCOUNT,			     L"DISPID_LISTCOUNT"		       },
	{ DISPID_MULTISELECT,		     L"DISPID_MULTISELECT"		       },
	{ DISPID_MAXLENGTH,			     L"DISPID_MAXLENGTH"		       },
	{ DISPID_PASSWORDCHAR,		     L"DISPID_PASSWORDCHAR"		       },
	{ DISPID_SCROLLBARS, 		     L"DISPID_SCROLLBARS"		       },
	{ DISPID_WORDWRAP,			     L"DISPID_WORDWRAP" 		       },
	{ DISPID_MULTILINE,			     L"DISPID_MULTILINE"		       },
	{ DISPID_NUMBEROFROWS,		     L"DISPID_NUMBEROFROWS"		       },
	{ DISPID_NUMBEROFCOLUMNS,		     L"DISPID_NUMBEROFCOLUMNS"		       },
	{ DISPID_DISPLAYSTYLE,		     L"DISPID_DISPLAYSTYLE"		       },
	{ DISPID_GROUPNAME,			     L"DISPID_GROUPNAME"		       },
	{ DISPID_IMEMODE,			     L"DISPID_IMEMODE"			       },
	{ DISPID_ACCELERATOR,		     L"DISPID_ACCELERATOR"		       },
	{ DISPID_ENTERKEYBEHAVIOR,		     L"DISPID_ENTERKEYBEHAVIOR" 	       },
	{ DISPID_TABKEYBEHAVIOR,		     L"DISPID_TABKEYBEHAVIOR"		       },
	{ DISPID_SELTEXT,			     L"DISPID_SELTEXT"			       },
	{ DISPID_SELSTART,			     L"DISPID_SELSTART" 		       },
	{ DISPID_SELLENGTH,			     L"DISPID_SELLENGTH"		       },
	{ DISPID_REFRESH,			     L"DISPID_REFRESH"			       },
	{ DISPID_DOCLICK,			     L"DISPID_DOCLICK"			       },
	{ DISPID_ABOUTBOX,			     L"DISPID_ABOUTBOX" 		       },
	{ DISPID_ADDITEM,			     L"DISPID_ADDITEM"			       },
	{ DISPID_CLEAR,			     L"DISPID_CLEAR"			       },
	{ DISPID_REMOVEITEM, 		     L"DISPID_REMOVEITEM"		       },
	{ DISPID_CLICK,			     L"DISPID_CLICK"			       },
	{ DISPID_DBLCLICK,			     L"DISPID_DBLCLICK" 		       },
	{ DISPID_KEYDOWN,			     L"DISPID_KEYDOWN"			       },
	{ DISPID_KEYPRESS,			     L"DISPID_KEYPRESS" 		       },
	{ DISPID_KEYUP,			     L"DISPID_KEYUP"			       },
	{ DISPID_MOUSEDOWN,			     L"DISPID_MOUSEDOWN"		       },
	{ DISPID_MOUSEMOVE,			     L"DISPID_MOUSEMOVE"		       },
	{ DISPID_MOUSEUP,			     L"DISPID_MOUSEUP"			       },
	{ DISPID_ERROREVENT, 		     L"DISPID_ERROREVENT"		       },
	{ DISPID_READYSTATECHANGE,		     L"DISPID_READYSTATECHANGE" 	       },
	{ DISPID_CLICK_VALUE,		     L"DISPID_CLICK_VALUE"		       },
	{ DISPID_RIGHTTOLEFT,		     L"DISPID_RIGHTTOLEFT"		       },
	{ DISPID_TOPTOBOTTOM,		     L"DISPID_TOPTOBOTTOM"		       },
	{ DISPID_THIS,			     L"DISPID_THIS"			       },
	{ DISPID_AMBIENT_BACKCOLOR,		     L"DISPID_AMBIENT_BACKCOLOR"	       },
	{ DISPID_AMBIENT_DISPLAYNAME,	     L"DISPID_AMBIENT_DISPLAYNAME"	       },
	{ DISPID_AMBIENT_FONT,		     L"DISPID_AMBIENT_FONT"		       },
	{ DISPID_AMBIENT_FORECOLOR,		     L"DISPID_AMBIENT_FORECOLOR"	       },
	{ DISPID_AMBIENT_LOCALEID,		     L"DISPID_AMBIENT_LOCALEID" 	       },
	{ DISPID_AMBIENT_MESSAGEREFLECT,	     L"DISPID_AMBIENT_MESSAGEREFLECT"	       },
	{ DISPID_AMBIENT_SCALEUNITS, 	     L"DISPID_AMBIENT_SCALEUNITS"	       },
	{ DISPID_AMBIENT_TEXTALIGN,		     L"DISPID_AMBIENT_TEXTALIGN"	       },
	{ DISPID_AMBIENT_USERMODE,		     L"DISPID_AMBIENT_USERMODE" 	       },
	{ DISPID_AMBIENT_UIDEAD,		     L"DISPID_AMBIENT_UIDEAD"		       },
	{ DISPID_AMBIENT_SHOWGRABHANDLES,	     L"DISPID_AMBIENT_SHOWGRABHANDLES"	       },
	{ DISPID_AMBIENT_SHOWHATCHING,	     L"DISPID_AMBIENT_SHOWHATCHING"	       },
	{ DISPID_AMBIENT_DISPLAYASDEFAULT,	     L"DISPID_AMBIENT_DISPLAYASDEFAULT"        },
	{ DISPID_AMBIENT_SUPPORTSMNEMONICS,	     L"DISPID_AMBIENT_SUPPORTSMNEMONICS"       },
	{ DISPID_AMBIENT_AUTOCLIP,		     L"DISPID_AMBIENT_AUTOCLIP" 	       },
	{ DISPID_AMBIENT_APPEARANCE, 	     L"DISPID_AMBIENT_APPEARANCE"	       },
	{ DISPID_AMBIENT_CODEPAGE,		     L"DISPID_AMBIENT_CODEPAGE" 	       },
	{ DISPID_AMBIENT_PALETTE,		     L"DISPID_AMBIENT_PALETTE"		       },
	{ DISPID_AMBIENT_CHARSET,		     L"DISPID_AMBIENT_CHARSET"		       },
	{ DISPID_AMBIENT_TRANSFERPRIORITY,	     L"DISPID_AMBIENT_TRANSFERPRIORITY"        },
	{ DISPID_AMBIENT_RIGHTTOLEFT,	     L"DISPID_AMBIENT_RIGHTTOLEFT"	       },
	{ DISPID_AMBIENT_TOPTOBOTTOM,	     L"DISPID_AMBIENT_TOPTOBOTTOM"	       },
	{ DISPID_Name,			     L"DISPID_Name"			       },
	{ DISPID_Delete,			     L"DISPID_Delete"			       },
	{ DISPID_Object,			     L"DISPID_Object"			       },
	{ DISPID_Parent,			     L"DISPID_Parent"			       },

	{ DISPID_MSDATASRCINTERFACE, 	     L"DISPID_MSDATASRCINTERFACE"	       },
	{ DISPID_ADVISEDATASRCCHANGEEVENT,	     L"DISPID_ADVISEDATASRCCHANGEEVENT"        },

	{ DISPID_AMBIENT_OFFLINEIFNOTCONNECTED,   L"DISPID_AMBIENT_OFFLINEIFNOTCONNECTED"   },
	{ DISPID_AMBIENT_SILENT,		     L"DISPID_AMBIENT_SILENT"		       },

	{ DISPID_WINDOWOBJECT,		     L"DISPID_WINDOWOBJECT"		       },
	{ DISPID_LOCATIONOBJECT,		     L"DISPID_LOCATIONOBJECT"		       },
	{ DISPID_HISTORYOBJECT,		     L"DISPID_HISTORYOBJECT"		       },
	{ DISPID_NAVIGATOROBJECT,		     L"DISPID_NAVIGATOROBJECT"		       },
	{ DISPID_SECURITYCTX,		     L"DISPID_SECURITYCTX"		       },
	{ DISPID_AMBIENT_DLCONTROL,		     L"DISPID_AMBIENT_DLCONTROL"	       },
	{ DISPID_AMBIENT_USERAGENT,		     L"DISPID_AMBIENT_USERAGENT"	       },
	{ DISPID_SECURITYDOMAIN,		     L"DISPID_SECURITYDOMAIN"		       },
	{ DISPID_DEBUG_ISSECUREPROXY,	     L"DISPID_DEBUG_ISSECUREPROXY"	       },
	{ DISPID_DEBUG_TRUSTEDPROXY, 	     L"DISPID_DEBUG_TRUSTEDPROXY"	       },
	{ DISPID_DEBUG_INTERNALWINDOW,	     L"DISPID_DEBUG_INTERNALWINDOW"	       },
	{ DISPID_DEBUG_ENABLESECUREPROXYASSERTS,  L"DISPID_DEBUG_ENABLESECUREPROXYASSERTS"  },
};

const size_t cdispids = _countof(rgdispids);


HRESULT HrCheckAndFreeExcepInfo(EXCEPINFO *pei, const void *pv, int ifn)
{
	if (pei->pfnDeferredFillIn != 0)
	{
		if (((intptr_t) pei->pfnDeferredFillIn) == -1)
		{
			ReportFailure(0x0C01, false, pv, ifn, L"EXCEPINFO::pfnDeferredFillIn %p is uninitialized", pei->pfnDeferredFillIn);
		}

		else if (IsBadCodePtr((FARPROC) pei->pfnDeferredFillIn))
		{
			ReportFailure(0x0C02, false, pv, ifn, L"EXCEPINFO::pfnDeferredFillIn %p is not valid code pointer", pei->pfnDeferredFillIn);
		}

		else
		{
			HRESULT hr = (*pei->pfnDeferredFillIn)(pei);

			if (FAILED(hr))
			{
				ReportFailure(0x0C03, false, pei->pfnDeferredFillIn, -1, L"EXCEPINFO::pfnDeferredFillIn failed.  hr = %08X", hr);
			}
		}
	}

	if (pei->wCode != 0)
	{
		ReportFailure(0x0C04, false, pv, ifn, L"EXCEPINFO::wCode == %04X", pei->wCode);
	}

	if (pei->wReserved != 0)
	{
		ReportFailure(0x0C05, false, pv, ifn, L"EXCEPINFO::wReserved == %04X", pei->wReserved);
	}

	if (pei->bstrSource != NULL)
	{
		SysFreeString(pei->bstrSource);
	}

	if (pei->bstrDescription != NULL)
	{
		SysFreeString(pei->bstrDescription);
	}

	if (pei->bstrHelpFile != NULL)
	{
		SysFreeString(pei->bstrHelpFile);
	}

	if (pei->pvReserved != 0)
	{
		ReportFailure(0x0C06, false, pv, ifn, L"EXCEPINFO::pvReserved == %p", pei->pvReserved);
	}

	if (pei->scode == 0)
	{
		ReportFailure(0x0C07, false, pv, ifn, L"EXCEPINFO::scode == 0");
	}

	return(pei->scode);
}


size_t CelemSafeArray(SAFEARRAY *psa)
{
	unsigned cdim = SafeArrayGetDim(psa);

	if (cdim == 0)
	{
		return(0);
	}

	size_t celem = 1;

	for (unsigned idim = 1; idim <= cdim; idim++)
	{
		long lbound;

		HRESULT hr = SafeArrayGetLBound(psa, idim, &lbound);

		if (FAILED(hr))
		{
			return(0);
		}

		long ubound;

		hr = SafeArrayGetUBound(psa, idim, &ubound);

		if (FAILED(hr))
		{
			return(0);
		}

		size_t celemDim = (size_t) (ubound - lbound + 1);

		celem *= celemDim;
	}

	return(celem);
}


int TestVariant(VARIANT& var)
{
	int rc = 0;

	if (var.vt == VT_DISPATCH)
	{
		if (var.pdispVal != NULL)
		{
			dwNonClass++;

			rc = TestInterface(var.pdispVal, NULL, false, false);

			dwNonClass--;
		}
	}

	else if (var.vt == VT_UNKNOWN)
	{
		if (var.punkVal != NULL)
		{
			dwNonClass++;

			rc = TestInterface(var.punkVal, NULL, true, false);

			dwNonClass--;
		}
	}

	else if (var.vt == (VT_ARRAY | VT_DISPATCH))
	{
		// UNDONE: Remove ReportFailure

		ReportFailure(0xFFFF, false, NULL, 0, L"VARIANT::vt == (VT_ARRAY | VT_DISPATCH)");

		SAFEARRAY *psa = var.parray;

		if (psa != NULL)
		{
			IDispatch **rgpid;

			HRESULT hr = SafeArrayAccessData(psa, (void **) &rgpid);

			if (SUCCEEDED(hr))
			{
				size_t celem = CelemSafeArray(psa);

				if (celem != 0)
				{
					for (size_t ielem = 0; ielem < celem; ielem++)
					{
						TestInterface(rgpid[ielem], NULL, false, false);
					}
				}

				SafeArrayUnaccessData(psa);
			}
		}
	}

	else if (var.vt == (VT_ARRAY | VT_UNKNOWN))
	{
		// UNDONE: Remove ReportFailure

		ReportFailure(0xFFFF, false, NULL, 0, L"VARIANT::vt == (VT_ARRAY | VT_UNKNOWN)");

		SAFEARRAY *psa = var.parray;

		if (psa != NULL)
		{
			IUnknown **rgpunk;

			HRESULT hr = SafeArrayAccessData(psa, (void **) &rgpunk);

			if (SUCCEEDED(hr))
			{
				size_t celem = CelemSafeArray(psa);

				if (celem != 0)
				{
					IID iidT;

					hr = SafeArrayGetIID(psa, &iidT);

					bool fIsIUnknown = SUCCEEDED(hr) && (iidT == IID_IUnknown);

					for (size_t ielem = 0; ielem < celem; ielem++)
					{
						TestInterface(rgpunk[ielem], NULL, fIsIUnknown, false);
					}
				}

				SafeArrayUnaccessData(psa);
			}
		}
	}

	else if (var.vt == (VT_ARRAY | VT_VARIANT))
	{
		SAFEARRAY *psa = var.parray;

		if (psa != NULL)
		{
			VARIANT *rgvar;

			HRESULT hr = SafeArrayAccessData(psa, (void **) &rgvar);

			if (SUCCEEDED(hr))
			{
				size_t celem = CelemSafeArray(psa);

				if (celem != 0)
				{
					for (size_t ielem = 0; ielem < celem; ielem++)
					{
						TestVariant(rgvar[ielem]);
					}
				}

				SafeArrayUnaccessData(psa);
			}
		}
	}

	else if ((var.vt & VT_BYREF) != 0)
	{
		ReportFailure(0xFFFF, false, NULL, 0, L"VARIANT::vt == %04X", var.vt);
	}

	return(rc);
}


int TestAndClearVariant(VARIANT& var)
{
	int rc = TestVariant(var);

	VariantClear(&var);

	return(rc);
}


int CheckIConnectionPointContainer(IUnknown *punk, bool fClassObject)
{
	IConnectionPointContainer *picpc;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IConnectionPointContainer", IID_PPV_ARGS(&picpc));

	if (FAILED(hr))
	{
		return(0);
	}

	IEnumConnectionPoints *piecp = (IEnumConnectionPoints *) (intptr_t) -1;

	hr = picpc->EnumConnectionPoints(&piecp);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			// OLEAUT32.DLL's CFont::EnumConnectionPoint, CPicture::EnumConnectionPoint,
			// and GEN_CPCONTAINER::EnumConnectionPoint return E_NOTIMPL.	If they don't
			// have to implement this we can't expect others to.

			ReportFailure(0x0D01, false, picpc, 3, L"IConnectionPointContainer::EnumConnectionPoints failed.  hr = %08X", hr);
		}
	}

	else
	{
		dwNonClass++;

		int rc = TestAndReleaseInterface(piecp, NULL, false, false, true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	IConnectionPoint *picp = (IConnectionPoint *) (intptr_t) -1;

	hr = picpc->FindConnectionPoint(IID_IUnknown, &picp);

	if (SUCCEEDED(hr))
	{
		dwNonClass++;

		ReportFailure(0x0D02, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(IUnknown) succeeded");

		Release(picp, false);
	}

	else
	{
		if (hr != CONNECT_E_NOCONNECTION)
		{
			ReportFailure(0x0D03, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(IUnknown) failure did not return CONNECT_E_NOCONNECTION.  hr = %08X", hr);
		}

		if (picp != NULL)
		{
			ReportFailure(0x0D04, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(IUnknown) failure did not set *ppcp = NULL");
		}
	}

	picp = (IConnectionPoint *) (intptr_t) -1;

	hr = picpc->FindConnectionPoint(IID_IDispatch, &picp);

	if (SUCCEEDED(hr))
	{
		dwNonClass++;

		ReportFailure(0x0D05, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(IDispatch) succeeded");

		Release(picp, false);
	}

	else
	{
		if (hr != CONNECT_E_NOCONNECTION)
		{
			ReportFailure(0x0D06, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(IDispatch) failure did not return CONNECT_E_NOCONNECTION.  hr = %08X", hr);
		}

		if (picp != NULL)
		{
			ReportFailure(0x0D07, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(IDispatch) failure did not set *ppcp = NULL");
		}
	}

	picp = (IConnectionPoint *) (intptr_t) -1;

	hr = picpc->FindConnectionPoint(iidUndefined, &picp);

	if (SUCCEEDED(hr))
	{
		dwNonClass++;

		ReportFailure(0x0D08, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(iidUndefined) succeeded");

		Release(picp, false);
	}

	else
	{
		if (hr != CONNECT_E_NOCONNECTION)
		{
			ReportFailure(0x0D09, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(iidUndefined) failure did not return CONNECT_E_NOCONNECTION.  hr = %08X", hr);
		}

		if (picp != NULL)
		{
			ReportFailure(0x0D0A, false, picpc, 4, L"IConnectionPointContainer::FindConnectionPoint(iidUndefined) failure did not set *ppcp = NULL");
		}
	}

	Release(picpc, fClassObject);

	return(0);
}


size_t CargInitRgarg(const FUNCDESC *pfd, ARG *rgarg)
{
	size_t carg = 0;

	for (int ied = 0; ied < pfd->cParams; ied++)
	{
		const ELEMDESC *ped = &pfd->lprgelemdescParam[ied];

		if (ped->paramdesc.wParamFlags & PARAMFLAG_FLCID)
		{
			continue;
		}

		if (ped->paramdesc.wParamFlags & PARAMFLAG_FRETVAL)
		{
			continue;
		}

		carg++;
	}

	if (carg > 256)
	{
		// UNDONE:

		ReportFailure(0xFFFF, false, NULL, 0, L"Argument limit of 256 exceeded (%u)", carg);

		return((size_t) -1);
	}

	size_t iarg = 0;

	for (int ied = 0; ied < pfd->cParams; ied++)
	{
		const ELEMDESC *ped = &pfd->lprgelemdescParam[ied];

		if (ped->paramdesc.wParamFlags & PARAMFLAG_FLCID)
		{
			continue;
		}

		if (ped->paramdesc.wParamFlags & PARAMFLAG_FRETVAL)
		{
			continue;
		}

		VARENUM vt = (VARENUM) ped->tdesc.vt;

		if (vt == VT_PTR)
		{
			vt = (VARENUM) ped->tdesc.lptdesc->vt;

			if (vt == VT_SAFEARRAY)
			{
				vt = (VARENUM) (ped->tdesc.lptdesc->lptdesc->vt | VT_ARRAY);
			}
		}

		else if (vt == VT_SAFEARRAY)
		{
			vt = (VARENUM) (ped->tdesc.lptdesc->vt | VT_ARRAY);
		}

		// UNDONE: Handle VT_CARRAY
		// UNDONE: Handle VT_USERDEFINED

		// We mark arguments as fIn if either PARAMFALG_FIN is set or neither
		// it nor PARAMFLAG_FOUT are set.  This is because some parameters may
		// have a wParamFlags value of 0.

		rgarg[iarg].vt = vt;
		rgarg[iarg].fIn = ((ped->paramdesc.wParamFlags & (PARAMFLAG_FIN | PARAMFLAG_FOUT)) != PARAMFLAG_FOUT);
		rgarg[iarg].fOut = ((ped->paramdesc.wParamFlags & PARAMFLAG_FOUT) != 0);
		rgarg[iarg].fOptional = false;
		rgarg[iarg].fDidOptional = false;
		rgarg[iarg].iValue = 0;
		rgarg[iarg].iType = 0;

		if (rgarg[iarg].fIn)
		{
			rgarg[iarg].fOptional = ((ped->paramdesc.wParamFlags & PARAMFLAG_FOPT) != 0);
		}

		iarg++;
	}

	return(carg);
}


bool FInitI2(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const __int16 rgi2[] =
	{
		0x0000,
		0x0001,
		-0x0001,
		0x007F,
		-0x007F,
		0x7FFF,
		-0x7FFF,
		-0x8000,
	};

	const unsigned ci2 = _countof(rgi2);

	V_VT(pvar) = VT_I2;
	V_I2(pvar) = rgi2[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == ci2)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitI4(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const __int32 rgi4[] =
	{
		0x00000000,
		0x00000001,
		-0x00000001,
		0x0000007F,
		-0x0000007F,
		0x00007FFF,
		-0x00007FFF,
		0x7FFFFFFF,
		-0x7FFFFFFF,
		-0x80000000,
	};

	const unsigned ci4 = _countof(rgi4);

	V_VT(pvar) = VT_I4;
	V_I4(pvar) = rgi4[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == ci4)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitR4(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const float rgr4[] =
	{
		0.0f,
		1.0f,
		-1.0f,
	};

	const unsigned cr4 = _countof(rgr4);

	V_VT(pvar) = VT_R4;
	V_R4(pvar) = rgr4[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cr4)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitR8(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const float rgr8[] =
	{
		0.0,
		1.0,
		-1.0,
	};

	const unsigned cr8 = _countof(rgr8);

	V_VT(pvar) = VT_R8;
	V_R8(pvar) = rgr8[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cr8)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitCY(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	VariantChangeType(pvar, pvar, 0, parg->vt);

	return(fAdvance);
}


bool FInitDATE(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	VariantChangeType(pvar, pvar, 0, parg->vt);

	return(fAdvance);
}


bool FInitBSTR(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const wchar_t * const rgsz[] =
	{
		//	NULL,
		L"",
		L"*",
		L"A",
		L"a",
		L"\x0001\x0002\x0003\x0004\x0005\x0006\x0007",
		L"C:\\test.txt",
		L"12345678901234567890123456789012345678901234567890123456789012345678901234567890"
		L"12345678901234567890123456789012345678901234567890123456789012345678901234567890"
		L"12345678901234567890123456789012345678901234567890123456789012345678901234567890"
		L"12345678901234567890123456789012345678901234567890123456789012345678901234567890",
	};

	const unsigned csz = _countof(rgsz);

	const wchar_t *sz = rgsz[parg->iValue];

	BSTR bstr = (sz == NULL) ? NULL : SysAllocString(sz);

	V_VT(pvar) = VT_BSTR;
	V_BSTR(pvar) = bstr;

	if (fAdvance)
	{
		if (++parg->iValue == csz)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitDISPATCH(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	pvar->vt = VT_DISPATCH;
	pvar->pdispVal = NULL;

	return(fAdvance);
}


bool FInitBOOL(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const VARIANT_BOOL rgvb[] =
	{
		VARIANT_FALSE,
		VARIANT_TRUE,
	};

	const unsigned cvb = _countof(rgvb);

	V_VT(pvar) = VT_BOOL;
	V_BOOL(pvar) = rgvb[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cvb)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitDECIMAL(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	VariantChangeType(pvar, pvar, 0, parg->vt);

	return(fAdvance);
}


bool FInitUNKNOWN(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	pvar->vt = VT_UNKNOWN;
	pvar->punkVal = NULL;

	return(fAdvance);
}


bool FInitI1(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const __int8 rgi1[] =
	{
		0x00,
		0x01,
		-0x01,
		0x7F,
		-0x7F,
		-0x80,
	};

	const unsigned ci1 = _countof(rgi1);

	V_VT(pvar) = VT_I1;
	V_I1(pvar) = rgi1[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == ci1)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitUI1(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const unsigned __int8 rgui1[] =
	{
		0x00,
		0x01,
		0x7F,
		0x80,
		0xFF,
	};

	const unsigned cui1 = _countof(rgui1);

	V_VT(pvar) = VT_UI1;
	V_UI1(pvar) = rgui1[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cui1)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitUI2(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const unsigned __int16 rgui2[] =
	{
		0x0000,
		0x0001,
		0x007F,
		0x7FFF,
		0x8000,
		0xFFFF,
	};

	const unsigned cui2 = _countof(rgui2);

	V_VT(pvar) = VT_UI2;
	V_UI2(pvar) = rgui2[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cui2)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitUI4(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const unsigned __int32 rgui4[] =
	{
		0x00000000,
		0x00000001,
		0x0000007F,
		0x00007FFF,
		0x7FFFFFFF,
		0x80000000,
		0xFFFFFFFF,
	};

	const unsigned cui4 = _countof(rgui4);

	V_VT(pvar) = VT_UI4;
	V_UI4(pvar) = rgui4[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cui4)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitI8(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const __int64 rgi8[] =
	{
		0x0000000000000000,
		0x0000000000000001,
		-0x0000000000000001,
		0x000000000000007F,
		-0x000000000000007F,
		0x0000000000007FFF,
		-0x0000000000007FFF,
		0x000000007FFFFFFF,
		-0x000000007FFFFFFF,
		0x7FFFFFFFFFFFFFFF,
		-0x7FFFFFFFFFFFFFFF,
		-0x8000000000000000,
	};

	const unsigned ci8 = _countof(rgi8);

	V_VT(pvar) = VT_I8;
	V_I8(pvar) = rgi8[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == ci8)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitUI8(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const unsigned __int64 rgui8[] =
	{
		0x0000000000000000,
		0x0000000000000001,
		0x000000000000007F,
		0x0000000000007FFF,
		0x000000007FFFFFFF,
		0x7FFFFFFFFFFFFFFF,
		0x8000000000000000,
		0xFFFFFFFFFFFFFFFF,
	};

	const unsigned cui8 = _countof(rgui8);

	V_VT(pvar) = VT_UI8;
	V_UI8(pvar) = rgui8[parg->iValue];

	if (fAdvance)
	{
		if (++parg->iValue == cui8)
		{
			parg->iValue = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitINT(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	fAdvance = FInitI4(fAdvance, parg, pvar);

	V_VT(pvar) = VT_INT;

	return(fAdvance);
}


bool FInitUINT(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	fAdvance = FInitUI4(fAdvance, parg, pvar);

	V_VT(pvar) = VT_UINT;

	return(fAdvance);
}


bool FInitVARIANT(bool fAdvance, ARG *parg, VARIANT *pvar)
{
	static const VARENUM rgvt[] =
	{
		VT_I2,
		VT_I4,
		//	VT_R4,
		VT_R8,
		//	VT_CY,
		//	VT_DATE,
		VT_BSTR,
		VT_BOOL,
		//	VT_DECIMAL,
		VT_I1,
		//	VT_UI1,
		//	VT_UI2,
		VT_UI4,
		//	VT_I8,
		//	VT_UI8,
		VT_INT,
		//	VT_UINT,
	};

	const unsigned cvt = _countof(rgvt);

	VARENUM vt = rgvt[parg->iType];

	switch (vt)
	{
	case VT_I2 :
		fAdvance = FInitI2(fAdvance, parg, pvar);
		break;

	case VT_I4 :
		fAdvance = FInitI4(fAdvance, parg, pvar);
		break;

	case VT_R4 :
		fAdvance = FInitR4(fAdvance, parg, pvar);
		break;

	case VT_R8 :
		fAdvance = FInitR8(fAdvance, parg, pvar);
		break;

	case VT_CY :
		fAdvance = FInitCY(fAdvance, parg, pvar);
		break;

	case VT_DATE :
		fAdvance = FInitDATE(fAdvance, parg, pvar);
		break;

	case VT_BSTR :
		fAdvance = FInitBSTR(fAdvance, parg, pvar);
		break;

	case VT_DISPATCH :
		fAdvance = FInitDISPATCH(fAdvance, parg, pvar);
		break;

	case VT_BOOL :
		fAdvance = FInitBOOL(fAdvance, parg, pvar);
		break;

	case VT_UNKNOWN :
		fAdvance = FInitUNKNOWN(fAdvance, parg, pvar);
		break;

	case VT_DECIMAL :
		fAdvance = FInitDECIMAL(fAdvance, parg, pvar);
		break;

	case VT_I1 :
		fAdvance = FInitI1(fAdvance, parg, pvar);
		break;

	case VT_UI1 :
		fAdvance = FInitUI1(fAdvance, parg, pvar);
		break;

	case VT_UI2 :
		fAdvance = FInitUI2(fAdvance, parg, pvar);
		break;

	case VT_UI4 :
		fAdvance = FInitUI4(fAdvance, parg, pvar);
		break;

	case VT_I8 :
		fAdvance = FInitI8(fAdvance, parg, pvar);
		break;

	case VT_UI8 :
		fAdvance = FInitUI8(fAdvance, parg, pvar);
		break;

	case VT_INT :
		fAdvance = FInitINT(fAdvance, parg, pvar);
		break;

	case VT_UINT :
		fAdvance = FInitUINT(fAdvance, parg, pvar);
		break;
	}

	if (fAdvance)
	{
		if (++parg->iType == cvt)
		{
			parg->iType = 0;
		}

		else
		{
			fAdvance = false;
		}
	}

	return(fAdvance);
}


bool FInitRgvar(size_t carg, ARG *rgarg, VARIANT *rgvar)
{
	bool fAdvance = true;

	for (size_t iarg = 0; iarg < carg; iarg++)
	{
		// VARIANTs in rgvarg are in reverse order

		size_t ivar = carg - (iarg + 1);

		VARIANT *pvar = &rgvar[ivar];

		MyVariantInit(pvar);

		ARG *parg = &rgarg[iarg];

		if (!parg->fIn)
		{
			if ((parg->vt & VT_ARRAY) != 0)
			{
				pvar->vt = parg->vt;
				pvar->parray = NULL;
			}

			continue;
		}

		if (parg->fOptional && !parg->fDidOptional)
		{
			pvar->vt = VT_ERROR;
			pvar->scode = DISP_E_PARAMNOTFOUND;

			parg->fDidOptional = fAdvance;

			fAdvance = false;

			continue;
		}

		switch (parg->vt & VT_TYPEMASK)
		{
		case VT_I2 :
			fAdvance = FInitI2(fAdvance, parg, pvar);
			break;

		case VT_I4 :
#ifndef _WIN64
		case VT_INT_PTR :
#endif
			fAdvance = FInitI4(fAdvance, parg, pvar);
			break;

		case VT_R4 :
			fAdvance = FInitR4(fAdvance, parg, pvar);
			break;

		case VT_R8 :
			fAdvance = FInitR8(fAdvance, parg, pvar);
			break;

		case VT_CY :
			fAdvance = FInitCY(fAdvance, parg, pvar);
			break;

		case VT_DATE :
			fAdvance = FInitDATE(fAdvance, parg, pvar);
			break;

		case VT_BSTR :
		case VT_LPSTR :
		case VT_LPWSTR :
			fAdvance = FInitBSTR(fAdvance, parg, pvar);
			break;

		case VT_DISPATCH :
			fAdvance = FInitDISPATCH(fAdvance, parg, pvar);
			break;

		case VT_BOOL :
			fAdvance = FInitBOOL(fAdvance, parg, pvar);
			break;

		case VT_VARIANT :
			fAdvance = FInitVARIANT(fAdvance, parg, pvar);
			break;

		case VT_UNKNOWN :
			fAdvance = FInitUNKNOWN(fAdvance, parg, pvar);
			break;

		case VT_DECIMAL :
			fAdvance = FInitDECIMAL(fAdvance, parg, pvar);
			break;

		case VT_I1 :
			fAdvance = FInitI1(fAdvance, parg, pvar);
			break;

		case VT_UI1 :
			fAdvance = FInitUI1(fAdvance, parg, pvar);
			break;

		case VT_UI2 :
			fAdvance = FInitUI2(fAdvance, parg, pvar);
			break;

		case VT_UI4 :
#ifndef _WIN64
		case VT_UINT_PTR :
#endif
			fAdvance = FInitUI4(fAdvance, parg, pvar);
			break;

		case VT_I8 :
#ifdef	_WIN64
		case VT_INT_PTR :
#endif
			fAdvance = FInitI8(fAdvance, parg, pvar);
			break;

		case VT_UI8 :
#ifdef	_WIN64
		case VT_UINT_PTR :
#endif
			fAdvance = FInitUI8(fAdvance, parg, pvar);
			break;

		case VT_INT :
			fAdvance = FInitINT(fAdvance, parg, pvar);
			break;

		case VT_UINT :
			fAdvance = FInitUINT(fAdvance, parg, pvar);
			break;

		default :
			VariantChangeType(pvar, pvar, 0, parg->vt);
			break;
		}
	}

	return(fAdvance);
}


int CheckIDispatchTypeInfo(IDispatch *pid, ITypeInfo *piti, size_t *pcfuncTotal)
{
	if (fNoIDispatchFuzz) return 0;		// don't fuzz methods -- can seriously screw up the system

	TYPEATTR *pta = (TYPEATTR *) (intptr_t) -1;

	HRESULT hr = piti->GetTypeAttr(&pta);

	if (FAILED(hr))
	{
		ReportFailure(0x0E01, false, piti, 3, L"ITypeInfo::GetTypeAttr failed.  hr = %08X", hr);

		// Indicate that GetTypetAttr fails so we can fall back to trying other DISPIDs

		return(-1);
	}

	if (pta->guid == IID_IUnknown)
	{
		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = 3;
		}
	}

	else if (pta->guid == IID_IDispatch)
	{
		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = 7;
		}
	}

	else if (pta->guid == IID_IDispatchEx)
	{
		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = 15;
		}
	}

	else
	{
		wchar_t szIidDispatch[39];

		StringFromGUID2(pta->guid, szIidDispatch, _countof(szIidDispatch));

		size_t cfuncBase = 0;

		if ((pta->typekind != TKIND_INTERFACE) && (pta->typekind != TKIND_DISPATCH))
		{
			ReportFailure(0x0E02, false, piti, 3, L"IID = %s.  ITypeInfo::GetTypeAttr returned typekind %u", szIidDispatch, pta->typekind);
		}

		else
		{
			IUnknown *punkT;

			hr = HrQueryInterface(pid, false, szIidDispatch, pta->guid, (void **) &punkT);

			if (SUCCEEDED(hr))
			{
				Release(punkT, false);
			}

			else
			{
				ReportFailure(0x0E07, false, pid, 0, L"IDispatch::QueryInterface(%s) failed.  hr = %08X", szIidDispatch, hr);
			}

			// Check for a base interface

			if (pta->cImplTypes != 1)
			{
				// There should be only one base interface

				ReportFailure(0x0E03, false, piti, 3, L"IID = %s.  ITypeInfo::GetTypeAttr returned cImplTypes = %u", szIidDispatch, pta->cImplTypes);
			}

			// Test the base interface first

			for (size_t i = 0; i < pta->cImplTypes; i++)
			{
				HREFTYPE ht = NULL;

				hr = piti->GetRefTypeOfImplType(i, &ht);

				if (SUCCEEDED(hr))
				{
					ITypeInfo *pitiImpl = (ITypeInfo *) (intptr_t) -1;

					hr = piti->GetRefTypeInfo(ht, &pitiImpl);

					if (SUCCEEDED(hr))
					{
						dwNonClass++;

						int rc = CheckIDispatchTypeInfo(pid, pitiImpl, &cfuncBase);

						Release(pitiImpl, false);

						if (rc != 0)
						{
							if (rc == -1)
							{
								// Only return -1 from top level

								rc = 0;
							}

							return(rc);
						}
					}
				}
			}
		}

		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = cfuncBase + pta->cFuncs;
		}

		size_t ifuncBase = 0;

		if ((pta->typekind == TKIND_DISPATCH) && ((pta->wTypeFlags & TYPEFLAG_FDUAL) != 0))
		{
			// For dual dispinterfaces GetFuncDesc treats the function index relative to
			// the start of the flattened interface not the start of this interface only.

			// UNDONE: Can we make this simpler?  We can if we know that all dispinterfaces
			// UNDONE: are derived from IDispatch and not other interfaces

			ifuncBase = cfuncBase;
		}

		bool fFolder = pta->guid == __uuidof(Folder);
		bool fFolder2 = pta->guid == __uuidof(Folder2);
		bool fFolder3 = pta->guid == __uuidof(Folder3);
		bool fIFile = pta->guid == __uuidof(IFile);
		bool fIFileSystem = pta->guid == __uuidof(IFileSystem);
		bool fIFileSystem3 = pta->guid == __uuidof(IFileSystem3);
		bool fIFolder = pta->guid == __uuidof(IFolder);
		bool fIFolderCollection = pta->guid == __uuidof(IFolderCollection);
		bool fILogonUser = pta->guid == __uuidof(ILogonUser);

		DISPID dispidPropertyPut = DISPID_PROPERTYPUT;

		ARG *rgarg = new ARG[256];
		VARIANT *rgvar = new VARIANT[256];

		for (size_t ifunc = ifuncBase; ifunc < pta->cFuncs; ifunc++)
		{
			FUNCDESC *pfd = (FUNCDESC *) (intptr_t) -1;

			HRESULT hr = piti->GetFuncDesc(ifunc, &pfd);

			if (FAILED(hr))
			{
				ReportFailure(0x0E04, false, piti, 5, L"IID = %s.  ITypeInfo::GetFuncDesc(%u) failed.  hr = %08X", szIidDispatch, ifunc, hr);
			}

			else
			{
				int ifn = 6;		  // Use index of Invoke as first choice

				// MSDN claims that oVft is valid for FUNC_VIRTUAL
				// only but it appears to be valid for FUNC_DISPATCH too

				if ((pfd->funckind == FUNC_VIRTUAL) || (pfd->funckind == FUNC_DISPATCH))
				{
					ifn = pfd->oVft / sizeof(void *);
				}

				BSTR bstrName;

				hr = piti->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL);

				if (FAILED(hr))
				{
					bstrName = NULL;
				}

				// Count number of non-lcid non-retval arguments

				size_t carg = CargInitRgarg(pfd, rgarg);

				if (fFolder || fFolder2 || fFolder3)
				{
					if (pfd->memid == 0x60020006)
					{
						// Avoid calling Folder::NewFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 0x60020007)
					{
						// Avoid calling Folder::MoveHere

						carg = (size_t) -1;
					}

					else if (pfd->memid == 0x60020008)
					{
						// Avoid calling Folder::CopyHere

						carg = (size_t) -1;
					}
				}

				else if (fIFile)
				{
					if ((pfd->memid == 1000) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFile::Name

						carg = (size_t) -1;
					}

					else if ((pfd->memid == 1003) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFile::Attributes

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1100)
					{
						// Avoid calling IFile::OpenTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1101)
					{
						// Avoid calling IFile::CreateTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1200)
					{
						// Avoid calling IFile::Delete

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1202)
					{
						// Avoid calling IFile::Copy

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1204)
					{
						// Avoid calling IFile::Move

						carg = (size_t) -1;
					}
				}

				else if (fIFileSystem || fIFileSystem3)
				{
					if (pfd->memid == 1100)
					{
						// Avoid calling IFileSystem::OpenAsTextStream

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1101)
					{
						// Avoid calling IFileSystem::CreateTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1120)
					{
						// Avoid calling IFileSystem::CreateFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1200)
					{
						// Avoid calling IFileSystem::DeleteFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1201)
					{
						// Avoid calling IFileSystem::DeleteFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1202)
					{
						// Avoid calling IFileSystem::CopyFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1203)
					{
						// Avoid calling IFileSystem::CopyFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1204)
					{
						// Avoid calling IFileSystem::MoveFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1205)
					{
						// Avoid calling IFileSystem::MoveFolder

						carg = (size_t) -1;
					}
				}

				else if (fIFolder)
				{
					if ((pfd->memid == 1000) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFolder::Name

						carg = (size_t) -1;
					}

					else if ((pfd->memid == 1003) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFolder::Attributes

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1101)
					{
						// Avoid calling IFileSystem::CreateTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1201)
					{
						// Avoid calling IFolder::Delete

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1203)
					{
						// Avoid calling IFolder::Copy

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1205)
					{
						// Avoid calling IFolder::Move

						carg = (size_t) -1;
					}
				}

				else if (fIFolderCollection)
				{
					if (pfd->memid == 2)
					{
						// Avoid calling IFolderCollection::Add

						carg = (size_t) -1;
					}
				}

				else if (fILogonUser)
				{
					if (pfd->memid == 0x60020008)
					{
						// Avoid calling ILogonUser::logoff

						carg = (size_t) -1;
					}

					else if (pfd->memid == 0x6002000a)
					{
						// Avoid calling ILogonUser::makeProfilePrivate

						carg = (size_t) -1;
					}
				}

				if (carg != ((size_t) -1))
				{
					DISPPARAMS dp;
					WORD wFlags = (WORD) pfd->invkind;
					VARIANT varResult;
					VARIANT *pvarResult = &varResult;
					EXCEPINFO ei;

					dp.rgvarg = (carg == 0) ? NULL : rgvar;
					dp.cArgs = carg;

					if ((pfd->invkind == INVOKE_PROPERTYPUT) ||
						(pfd->invkind == INVOKE_PROPERTYPUTREF))
					{
						dp.rgdispidNamedArgs = &dispidPropertyPut;
						dp.cNamedArgs = 1;

						if ((carg == 1) && (rgvar[0].vt != VT_DISPATCH))
						{
							wFlags = DISPATCH_PROPERTYPUT;
						}

						pvarResult = NULL;
					}

					else
					{
						dp.rgdispidNamedArgs = NULL;
						dp.cNamedArgs = 0;
					}

					HRESULT hrLastError = S_OK;

					// Limit permutations per method

					for (DWORD dwDispatch = 0; dwDispatch < dwDispatchMax; dwDispatch++)
					{
						bool fAdvance = FInitRgvar(carg, rgarg, rgvar);

						varResult.vt = VT_ILLEGAL;

						memset(&ei, -1, sizeof(ei));

						hr = pid->Invoke((DISPID) (pfd->memid),   // dispIdMember
							IID_NULL,		    // riid
							LOCALE_SYSTEM_DEFAULT,   // lcid
							wFlags,			// wFlags
							&dp, 		    // pDispParams
							pvarResult,		    // pVarResult
							&ei, 		    // pExcepInfo
							NULL);		    // puArgErr

						SetMyUnhandledExceptionFilter(true);

						if (!fExistsA)
						{
							fExistsA = _waccess_s(L"A", 0) == 0;

							if (fExistsA)
							{
								ReportFailure(0xFFFF, false, pid, ifn, L"IID = %s.  IDispatch::Invoke(%d, \"%s\") created A", szIidDispatch, pfd->memid, bstrName);
							}
						}


						if (SUCCEEDED(hr))
						{
							for (size_t iarg = 0; iarg < carg; iarg++)
							{
								// VARIANTs in rgvarg are in reverse order

								size_t ivar = carg - (iarg + 1);

								int rc = TestAndClearVariant(rgvar[ivar]);

								if (rc != 0)
								{
									return(rc);
								}
							}

							if (pvarResult != NULL)
							{
								if (varResult.vt == VT_ILLEGAL)
								{
									if (bstrName != NULL)
									{
										ReportFailure(0x0E05, false, pid, ifn, L"IID = %s.  IDispatch::Invoke(%d, \"%s\") did not initialize varResult", szIidDispatch, pfd->memid, bstrName);
									}

									else
									{
										ReportFailure(0x0E05, false, pid, ifn, L"IID = %s.  IDispatch::Invoke(%d) did not initialize varResult", szIidDispatch, pfd->memid);
									}
								}

								else
								{
									int rc = TestAndClearVariant(*pvarResult);

									if (rc != 0)
									{
										return(rc);
									}
								}
							}
						}

						else
						{
							for (size_t iarg = 0; iarg < carg; iarg++)
							{
								// VARIANTs in rgvarg are in reverse order

								size_t ivar = carg - (iarg + 1);

								VariantClear(&rgvar[ivar]);
							}

							if ((hr == DISP_E_MEMBERNOTFOUND) &&
								(pfd->memid >= 0) &&
								(pfd->wFuncFlags & FUNCFLAG_FRESTRICTED))
							{
								// CTypeInfo2::Invoke in OLEAUT32.DLL contains

								//     // New-format typelibs don't allow late-binding to restricted members
								//     if (memid >= 0 && (pFunc->funcflags & FUNCFLAG_FRESTRICTED)) {
								//	 return HresultOfScode(DISP_E_MEMBERNOTFOUND);
								//     }
							}

							else
							{
								if (hr == DISP_E_EXCEPTION)
								{
									hr = HrCheckAndFreeExcepInfo(&ei, pid, 6);
								}

								// Don't report invalid arguments as we try this often
								// Don't report consecutive instances of same error per method

								if ((hr != E_INVALIDARG) && (hr != hrLastError))
								{
									hrLastError = hr;

									if (bstrName != NULL)
									{
										ReportFailure(0x0E06, false, pid, ifn, L"IID = %s.  IDispatch::Invoke(%d, \"%s\") failed.  hr = %08X", szIidDispatch, pfd->memid, bstrName, hr);
									}

									else
									{
										ReportFailure(0x0E06, false, pid, ifn, L"IID = %s.  IDispatch::Invoke(%d) failed.  hr = %08X", szIidDispatch, pfd->memid, hr);
									}
								}
							}
						}

						if (fAdvance)
						{
							break;
						}
					}
				}

				if (bstrName != NULL)
				{
					SysFreeString(bstrName);
				}

				piti->ReleaseFuncDesc(pfd);
			}
		}

		delete [] rgvar;
		delete [] rgarg;
	}

	piti->ReleaseTypeAttr(pta);

	return(0);
}


int CheckIDispatch(IUnknown *punk, bool fClassObject)
{
	if (fNoIDispatch)
	{
		return(0);
	}

	IDispatch *pid;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IDispatch", IID_PPV_ARGS(&pid));

	if (FAILED(hr))
	{
		return(0);
	}

	bool fGetTypeInfoCountNotImpl = false;

	UINT ctinfo;

	hr = pid->GetTypeInfoCount(&ctinfo);

	if (FAILED(hr))
	{
		if (hr == E_NOTIMPL)
		{
			fGetTypeInfoCountNotImpl = true;
		}

		else
		{
			ReportFailure(0x0F01, false, pid, 3, L"IDispatch::GetTypeInfoCount failure did not return E_NOTIMPL.  hr = %08X", hr);
		}

		ctinfo = 0;
	}

	else if (ctinfo > 1)
	{
		ReportFailure(0x0F02, false, pid, 3, L"IDispatch::GetTypeInfoCount returned ctinfo of %u", ctinfo);
	}

	ITypeInfo *piti = (ITypeInfo *) (intptr_t) -1;

	hr = pid->GetTypeInfo(ctinfo, LOCALE_NEUTRAL, &piti);

	if (SUCCEEDED(hr))
	{
		dwNonClass++;

		ReportFailure(0x0F03, false, pid, 4, L"IDispatch::GetTypeInfo(%u) succeeded", ctinfo);

		// Don't check ref count.  ATL CComTypeInfoHolder may hold a reference

		int rc = TestAndReleaseInterface(piti, NULL, false, false, false);

		if (rc != 0)
		{
			return(rc);
		}
	}

	else if ((hr != DISP_E_BADINDEX) && !fGetTypeInfoCountNotImpl)
	{
		ReportFailure(0x0F04, false, pid, 4, L"IDispatch::GetTypeInfo(%u) failure did not return DISP_E_BADINDEX.  hr = %08X", ctinfo, hr);
	}

	if (ctinfo != 0)
	{
		piti = (ITypeInfo *) (intptr_t) -1;

		hr = pid->GetTypeInfo(0, LOCALE_NEUTRAL, &piti);

		if (SUCCEEDED(hr))
		{
			dwNonClass++;

			if (fGetTypeInfoCountNotImpl)
			{
				ReportFailure(0x0F05, false, pid, 4, L"IDispatch::GetTypeInfo(0) succeded but GetTypeInfoCount returned E_NOTIMPL");
			}

			int rc = TestInterface(piti, NULL, false, false);

			if (rc != 0)
			{
				return(rc);
			}
		}

		else
		{
			piti = NULL;

			if ((hr != E_NOTIMPL) && fGetTypeInfoCountNotImpl)
			{
				ReportFailure(0x0F06, false, pid, 4, L"IDispatch::GetTypeInfo(0) did not return E_NOTIMPL when GetTypeInfoCount did.  hr = %08X", hr);
			}
		}
	}

	else
	{
		piti = NULL;
	}

	wchar_t *rgszNames[1] =
	{
		L"Aj_34Hfm6",
	};

	DISPID dispid;

	hr = pid->GetIDsOfNames(IID_NULL,
		rgszNames,
		1,
		LOCALE_NEUTRAL,
		&dispid);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x0F0E, false, pid, 5, L"IDispatch::GetIDsOfNames(\"Aj_34Hfm6\") succeeded");
	}

	bool fMemberNotFound = false;

	DISPPARAMS dp;
	VARIANT varResult;
	EXCEPINFO ei;

	dp.rgvarg = NULL;
	dp.rgdispidNamedArgs = NULL;
	dp.cArgs = 0;
	dp.cNamedArgs = 0;

	varResult.vt = VT_ILLEGAL;

	memset(&ei, -1, sizeof(ei));

	hr = pid->Invoke(0x73529A4B, 			    // dispIdMember
		IID_NULL,				    // riid
		LOCALE_SYSTEM_DEFAULT,		    // lcid
		DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
		&dp,				    // pDispParams
		&varResult, 			    // pVarResult
		&ei,				    // pExcepInfo
		NULL);				    // puArgErr

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x0F07, false, pid, 6, L"IDispatch::Invoke(0x73529A4B) succeeded");

		if (varResult.vt == VT_ILLEGAL)
		{
			ReportFailure(0x0F08, false, pid, 6, L"IDispatch::Invoke(0x73529A4B) did not initialize varResult");
		}

		else
		{
			VariantClear(&varResult);
		}
	}

	else
	{
		if (hr == DISP_E_EXCEPTION)
		{
			hr = HrCheckAndFreeExcepInfo(&ei, pid, 6);
		}

		if (hr != DISP_E_MEMBERNOTFOUND)
		{
			fMemberNotFound = true;       // Report once only

			ReportFailure(0x0F09, false, pid, 6, L"IDispatch::Invoke(0x73529A4B) failure did not return DISP_E_MEMBERNOTFOUND.  hr = %08X", hr);
		}
	}

	// Try reserved DISPIDs

	for (size_t idispids = 0; idispids < cdispids; idispids++)
	{
		dispid = rgdispids[idispids].dispid;
		const wchar_t *szDispid = rgdispids[idispids].sz;

		dp.rgvarg = NULL;
		dp.rgdispidNamedArgs = NULL;
		dp.cArgs = 0;
		dp.cNamedArgs = 0;

		varResult.vt = VT_ILLEGAL;

		memset(&ei, -1, sizeof(ei));

		hr = pid->Invoke(dispid,				       // dispIdMember
			IID_NULL,			       // riid
			LOCALE_SYSTEM_DEFAULT,		       // lcid
			DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
			&dp,				       // pDispParams
			&varResult,			       // pVarResult
			&ei,				       // pExcepInfo
			NULL);				       // puArgErr

		SetMyUnhandledExceptionFilter(true);

		if (SUCCEEDED(hr))
		{
			if (varResult.vt == VT_ILLEGAL)
			{
				ReportFailure(0x0F0A, false, pid, 6, L"IDispatch::Invoke(%s) did not initialize varResult", szDispid);
			}

			else
			{
				int rc = TestAndClearVariant(varResult);

				if (rc != 0)
				{
					return(rc);
				}
			}
		}

		else
		{
			if (hr == DISP_E_EXCEPTION)
			{
				hr = HrCheckAndFreeExcepInfo(&ei, pid, 6);
			}

			if ((hr != DISP_E_MEMBERNOTFOUND) && (hr != DISP_E_BADPARAMCOUNT) && !fMemberNotFound)
			{
				fMemberNotFound = true;	  // Report once only

				ReportFailure(0x0F0B, false, pid, 6, L"IDispatch::Invoke(%s) failure did not return DISP_E_MEMBERNOTFOUND.  hr = %08X", szDispid, hr);
			}
		}
	}

	if (piti != NULL)
	{
		int rc = CheckIDispatchTypeInfo(pid, piti, NULL);

		if (rc == -1)
		{
			// Release piti and set to NULL so that we try fallback enumeration of DISPIDs

			Release(piti, false);

			piti = NULL;
		}

		else if (rc != 0)
		{
			return(rc);
		}
	}

	if (piti == NULL)
	{
		// We don't have an ITypeInfo.  Just try a range of DISPIDs.

		for (dispid = 1; dispid < dispidMax; dispid++)
		{
			dp.rgvarg = NULL;
			dp.rgdispidNamedArgs = NULL;
			dp.cArgs = 0;
			dp.cNamedArgs = 0;

			varResult.vt = VT_ILLEGAL;

			memset(&ei, -1, sizeof(ei));

			hr = pid->Invoke(dispid,				  // dispIdMember
				IID_NULL,				  // riid
				LOCALE_SYSTEM_DEFAULT,		  // lcid
				DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
				&dp,					  // pDispParams
				&varResult,				  // pVarResult
				&ei,					  // pExcepInfo
				NULL);				  // puArgErr

			SetMyUnhandledExceptionFilter(true);

			if (SUCCEEDED(hr))
			{
				if (varResult.vt == VT_ILLEGAL)
				{
					ReportFailure(0x0F0C, false, pid, 6, L"IDispatch::Invoke(%d) did not initialize varResult", dispid);
				}

				else
				{
					int rc = TestAndClearVariant(varResult);

					if (rc != 0)
					{
						return(rc);
					}
				}
			}

			else
			{
				if (hr == DISP_E_EXCEPTION)
				{
					hr = HrCheckAndFreeExcepInfo(&ei, pid, 6);
				}

				if ((hr != DISP_E_MEMBERNOTFOUND) && (hr != DISP_E_BADPARAMCOUNT) && !fMemberNotFound)
				{
					ReportFailure(0x0F0D, false, pid, 6, L"IDispatch::Invoke(%d) failed.  hr = %08X", dispid, hr);
				}
			}
		}
	}

	else
	{
		Release(piti, false);
	}

	Release(pid, fClassObject);

	return(0);
}


int CheckIDispatchExTypeInfo(IDispatchEx *pide, ITypeInfo *piti, size_t *pcfuncTotal)
{
	if (fNoIDispatchFuzz) return 0;				// don't fuzz methods -- can seriously screw up the system
	TYPEATTR *pta = (TYPEATTR *) (intptr_t) -1;

	HRESULT hr = piti->GetTypeAttr(&pta);

	if (FAILED(hr))
	{
		ReportFailure(0x2E01, false, piti, 3, L"ITypeInfo::GetTypeAttr failed.  hr = %08X", hr);

		// Indicate that GetTypetAttr fails so we can fall back to trying other DISPIDs

		return(-1);
	}

	if (pta->guid == IID_IUnknown)
	{
		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = 3;
		}
	}

	else if (pta->guid == IID_IDispatch)
	{
		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = 7;
		}
	}

	else if (pta->guid == IID_IDispatchEx)
	{
		if (pcfuncTotal != NULL)
		{
			*pcfuncTotal = 15;
		}
	}

	else
	{
		wchar_t szIidDispatch[39];

		StringFromGUID2(pta->guid, szIidDispatch, _countof(szIidDispatch));

		size_t cfuncBase = 0;

		if ((pta->typekind != TKIND_INTERFACE) && (pta->typekind != TKIND_DISPATCH))
		{
			ReportFailure(0x2E02, false, piti, 3, L"IID = %s.  ITypeInfo::GetTypeAttr returned typekind %u", szIidDispatch, pta->typekind);
		}

		else
		{
			IUnknown *punkT;

			hr = HrQueryInterface(pide, false, szIidDispatch, pta->guid, (void **) &punkT);

			if (SUCCEEDED(hr))
			{
				Release(punkT, false);
			}

			else
			{
				ReportFailure(0x2E07, false, pide, 0, L"IDispatch::QueryInterface(%s) failed.  hr = %08X", szIidDispatch, hr);
			}

			// Check for a base interface

			if (pta->cImplTypes != 1)
			{
				// There should be only one base interface

				ReportFailure(0x2E03, false, piti, 3, L"IID = %s.  ITypeInfo::GetTypeAttr returned cImplTypes = %u", szIidDispatch, pta->cImplTypes);
			}

			// Test the base interface first

			for (size_t i = 0; i < pta->cImplTypes; i++)
			{
				HREFTYPE ht = NULL;

				hr = piti->GetRefTypeOfImplType(i, &ht);

				if (SUCCEEDED(hr))
				{
					ITypeInfo *pitiImpl = (ITypeInfo *) (intptr_t) -1;

					hr = piti->GetRefTypeInfo(ht, &pitiImpl);

					if (SUCCEEDED(hr))
					{
						dwNonClass++;

						int rc = CheckIDispatchExTypeInfo(pide, pitiImpl, &cfuncBase);

						Release(pitiImpl, false);

						if (rc != 0)
						{
							if (rc == -1)
							{
								// Only return -1 from top level

								rc = 0;
							}

							return(rc);
						}
					}
				}
			}
		}

		size_t ifuncBase = 0;

		if ((pta->typekind == TKIND_DISPATCH) && ((pta->wTypeFlags & TYPEFLAG_FDUAL) != 0))
		{
			// For dual dispinterfaces GetFuncDesc treats the function index relative to
			// the start of the flattened interface not the start of this interface only.

			// UNDONE: Can we make this simpler?  We can if we know that all dispinterfaces
			// UNDONE: are derived from IDispatch and not other interfaces

			ifuncBase = cfuncBase;
		}

		bool fFolder = pta->guid == __uuidof(Folder);
		bool fFolder2 = pta->guid == __uuidof(Folder2);
		bool fFolder3 = pta->guid == __uuidof(Folder3);
		bool fIFile = pta->guid == __uuidof(IFile);
		bool fIFileSystem = pta->guid == __uuidof(IFileSystem);
		bool fIFileSystem3 = pta->guid == __uuidof(IFileSystem3);
		bool fIFolder = pta->guid == __uuidof(IFolder);
		bool fIFolderCollection = pta->guid == __uuidof(IFolderCollection);
		bool fILogonUser = pta->guid == __uuidof(ILogonUser);

		DISPID dispidPropertyPut = DISPID_PROPERTYPUT;

		ARG *rgarg = new ARG[256];
		VARIANT *rgvar = new VARIANT[256];

		for (size_t ifunc = ifuncBase; ifunc < pta->cFuncs; ifunc++)
		{
			FUNCDESC *pfd = (FUNCDESC *) (intptr_t) -1;

			HRESULT hr = piti->GetFuncDesc(ifunc, &pfd);

			if (FAILED(hr))
			{
				ReportFailure(0x2E04, false, piti, 5, L"IID = %s.  ITypeInfo::GetFuncDesc(%u) failed.  hr = %08X", szIidDispatch, ifunc, hr);
			}

			else
			{
				int ifn = 8;		  // Use index of InvokeEx as first choice

				// MSDN claims that oVft is valid for FUNC_VIRTUAL
				// only but it appears to be valid for FUNC_DISPATCH too

				if ((pfd->funckind == FUNC_VIRTUAL) || (pfd->funckind == FUNC_DISPATCH))
				{
					ifn = pfd->oVft / sizeof(void *);
				}

				BSTR bstrName;

				hr = piti->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL);

				if (FAILED(hr))
				{
					bstrName = NULL;
				}

				// Count number of non-lcid non-retval arguments

				size_t carg = CargInitRgarg(pfd, rgarg);

				if (fFolder || fFolder2 || fFolder3)
				{
					if (pfd->memid == 0x60020006)
					{
						// Avoid calling Folder::NewFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 0x60020007)
					{
						// Avoid calling Folder::MoveHere

						carg = (size_t) -1;
					}

					else if (pfd->memid == 0x60020008)
					{
						// Avoid calling Folder::CopyHere

						carg = (size_t) -1;
					}
				}

				else if (fIFile)
				{
					if ((pfd->memid == 1000) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFile::Name

						carg = (size_t) -1;
					}

					else if ((pfd->memid == 1003) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFile::Attributes

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1100)
					{
						// Avoid calling IFile::OpenTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1101)
					{
						// Avoid calling IFile::CreateTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1200)
					{
						// Avoid calling IFile::Delete

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1202)
					{
						// Avoid calling IFile::Copy

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1204)
					{
						// Avoid calling IFile::Move

						carg = (size_t) -1;
					}
				}

				else if (fIFileSystem || fIFileSystem3)
				{
					if (pfd->memid == 1100)
					{
						// Avoid calling IFileSystem::OpenAsTextStream

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1101)
					{
						// Avoid calling IFileSystem::CreateTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1120)
					{
						// Avoid calling IFileSystem::CreateFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1200)
					{
						// Avoid calling IFileSystem::DeleteFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1201)
					{
						// Avoid calling IFileSystem::DeleteFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1202)
					{
						// Avoid calling IFileSystem::CopyFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1203)
					{
						// Avoid calling IFileSystem::CopyFolder

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1204)
					{
						// Avoid calling IFileSystem::MoveFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1205)
					{
						// Avoid calling IFileSystem::MoveFolder

						carg = (size_t) -1;
					}
				}

				else if (fIFolder)
				{
					if ((pfd->memid == 1000) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFolder::Name

						carg = (size_t) -1;
					}

					else if ((pfd->memid == 1003) && (pfd->invkind == INVOKE_PROPERTYPUT))
					{
						// Avoid setting IFolder::Attributes

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1101)
					{
						// Avoid calling IFileSystem::CreateTextFile

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1201)
					{
						// Avoid calling IFolder::Delete

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1203)
					{
						// Avoid calling IFolder::Copy

						carg = (size_t) -1;
					}

					else if (pfd->memid == 1205)
					{
						// Avoid calling IFolder::Move

						carg = (size_t) -1;
					}
				}

				else if (fIFolderCollection)
				{
					if (pfd->memid == 2)
					{
						// Avoid calling IFolderCollection::Add

						carg = (size_t) -1;
					}
				}

				else if (fILogonUser)
				{
					if (pfd->memid == 0x60020008)
					{
						// Avoid calling ILogonUser::logoff

						carg = (size_t) -1;
					}

					else if (pfd->memid == 0x6002000a)
					{
						// Avoid calling ILogonUser::makeProfilePrivate

						carg = (size_t) -1;
					}
				}

				if (carg != ((size_t) -1))
				{
					DISPPARAMS dp;
					WORD wFlags = (WORD) pfd->invkind;
					VARIANT varResult;
					VARIANT *pvarResult = &varResult;
					EXCEPINFO ei;

					dp.rgvarg = (carg == 0) ? NULL : rgvar;
					dp.cArgs = carg;

					if ((pfd->invkind == INVOKE_PROPERTYPUT) ||
						(pfd->invkind == INVOKE_PROPERTYPUTREF))
					{
						dp.rgdispidNamedArgs = &dispidPropertyPut;
						dp.cNamedArgs = 1;

						if ((carg == 1) && (rgvar[0].vt != VT_DISPATCH))
						{
							wFlags = DISPATCH_PROPERTYPUT;
						}

						pvarResult = NULL;
					}

					else
					{
						dp.rgdispidNamedArgs = NULL;
						dp.cNamedArgs = 0;
					}

					HRESULT hrLastError = S_OK;

					// Limit permutations per method

					for (DWORD dwDispatch = 0; dwDispatch < dwDispatchMax; dwDispatch++)
					{
						bool fAdvance = FInitRgvar(carg, rgarg, rgvar);

						varResult.vt = VT_ILLEGAL;

						memset(&ei, -1, sizeof(ei));

						hr = pide->InvokeEx((DISPID) (pfd->memid),   // id
							LOCALE_SYSTEM_DEFAULT,   // lcid
							wFlags,				// wFlags
							&dp,		       // pdp
							pvarResult,	       // pVarRes
							&ei,		       // pei
							NULL);		       // pspCaller

						SetMyUnhandledExceptionFilter(true);

						if (!fExistsA)
						{
							fExistsA = _waccess_s(L"A", 0) == 0;

							if (fExistsA)
							{
								ReportFailure(0xFFFF, false, pide, ifn, L"IID = %s.  IDispatchEx::InvokeEx(%d, \"%s\") created A", szIidDispatch, pfd->memid, bstrName);
							}
						}

						if (SUCCEEDED(hr))
						{
							for (size_t iarg = 0; iarg < carg; iarg++)
							{
								// VARIANTs in rgvarg are in reverse order

								size_t ivar = carg - (iarg + 1);

								int rc = TestAndClearVariant(rgvar[ivar]);

								if (rc != 0)
								{
									return(rc);
								}
							}

							if (pvarResult != NULL)
							{
								if (varResult.vt == VT_ILLEGAL)
								{
									if (bstrName != NULL)
									{
										ReportFailure(0x2E05, false, pide, ifn, L"IID = %s.  IDispatchEx::InvokeEx(%d, \"%s\") did not initialize varResult", szIidDispatch, pfd->memid, bstrName);
									}

									else
									{
										ReportFailure(0x2E05, false, pide, ifn, L"IID = %s.  IDispatchEx::InvokeEx(%d) did not initialize varResult", szIidDispatch, pfd->memid);
									}
								}

								else
								{
									int rc = TestAndClearVariant(*pvarResult);

									if (rc != 0)
									{
										return(rc);
									}
								}
							}
						}

						else
						{
							for (size_t iarg = 0; iarg < carg; iarg++)
							{
								// VARIANTs in rgvarg are in reverse order

								size_t ivar = carg - (iarg + 1);

								VariantClear(&rgvar[ivar]);
							}

							if ((hr == DISP_E_MEMBERNOTFOUND) &&
								(pfd->memid >= 0) &&
								(pfd->wFuncFlags & FUNCFLAG_FRESTRICTED))
							{
								// CTypeInfo2::Invoke in OLEAUT32.DLL contains

								//     // New-format typelibs don't allow late-binding to restricted members
								//     if (memid >= 0 && (pFunc->funcflags & FUNCFLAG_FRESTRICTED)) {
								//	 return HresultOfScode(DISP_E_MEMBERNOTFOUND);
								//     }
							}

							else
							{
								if (hr == DISP_E_EXCEPTION)
								{
									hr = HrCheckAndFreeExcepInfo(&ei, pide, 8);
								}

								// Don't report invalid arguments as we try this often
								// Don't report consecutive instances of same error per method

								if ((hr != E_INVALIDARG) && (hr != hrLastError))
								{
									hrLastError = hr;

									if (bstrName != NULL)
									{
										ReportFailure(0x2E06, false, pide, ifn, L"IID = %s.  IDispatchEx::InvokeEx(%d, \"%s\") failed.  hr = %08X", szIidDispatch, pfd->memid, bstrName, hr);
									}

									else
									{
										ReportFailure(0x2E06, false, pide, ifn, L"IID = %s.  IDispatchEx::InvokeEx(%d) failed.  hr = %08X", szIidDispatch, pfd->memid, hr);
									}
								}
							}
						}

						if (fAdvance)
						{
							break;
						}
					}
				}

				if (bstrName != NULL)
				{
					SysFreeString(bstrName);
				}

				piti->ReleaseFuncDesc(pfd);
			}
		}

		delete [] rgvar;
		delete [] rgarg;
	}

	piti->ReleaseTypeAttr(pta);

	return(0);
}


int CheckIDispatchEx(IUnknown *punk, bool fClassObject)
{
	if (fNoIDispatch)
	{
		return(-1);
	}

	IDispatchEx *pide;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IDispatchEx", IID_PPV_ARGS(&pide));

	if (FAILED(hr))
	{
		// Return -1 to differentiate between this and success

		return(-1);
	}

	IDispatch *pid;

	hr = HrQueryInterface(punk, fClassObject, L"IDispatch", IID_PPV_ARGS(&pid));

	if (SUCCEEDED(hr))
	{
		Release(pid, fClassObject);
	}

	else
	{
		ReportFailure(0x2F01, false, punk, 0, L"IDispatchEx w/o IDispatch");
	}

	bool fGetTypeInfoCountNotImpl = false;

	UINT ctinfo;

	hr = pide->GetTypeInfoCount(&ctinfo);

	if (FAILED(hr))
	{
		if (hr == E_NOTIMPL)
		{
			fGetTypeInfoCountNotImpl = true;
		}

		else
		{
			ReportFailure(0x2F02, false, pide, 3, L"IDispatchEx::GetTypeInfoCount failure did not return E_NOTIMPL.  hr = %08X", hr);
		}

		ctinfo = 0;
	}

	else if (ctinfo > 1)
	{
		ReportFailure(0x2F03, false, pide, 3, L"IDispatchEx::GetTypeInfoCount returned ctinfo of %u", ctinfo);
	}

	ITypeInfo *piti = (ITypeInfo *) (intptr_t) -1;

	hr = pide->GetTypeInfo(ctinfo, LOCALE_NEUTRAL, &piti);

	if (SUCCEEDED(hr))
	{
		dwNonClass++;

		ReportFailure(0x2F04, false, pide, 4, L"IDispatchEx::GetTypeInfo(%u) succeeded", ctinfo);

		// Don't check ref count.  ATL CComTypeInfoHolder may hold a reference

		int rc = TestAndReleaseInterface(piti, NULL, false, false, false);

		if (rc != 0)
		{
			return(rc);
		}
	}

	else if ((hr != DISP_E_BADINDEX) && !fGetTypeInfoCountNotImpl)
	{
		ReportFailure(0x2F05, false, pide, 4, L"IDispatchEx::GetTypeInfo(%u) failure did not return DISP_E_BADINDEX.  hr = %08X", ctinfo, hr);
	}

	if (ctinfo != 0)
	{
		piti = (ITypeInfo *) (intptr_t) -1;

		hr = pide->GetTypeInfo(0, LOCALE_NEUTRAL, &piti);

		if (SUCCEEDED(hr))
		{
			dwNonClass++;

			if (fGetTypeInfoCountNotImpl)
			{
				ReportFailure(0x2F06, false, pide, 4, L"IDispatchEx::GetTypeInfo(0) succeded but GetTypeInfoCount returned E_NOTIMPL");
			}

			int rc = TestInterface(piti, NULL, false, false);

			if (rc != 0)
			{
				return(rc);
			}
		}

		else
		{
			piti = NULL;

			if ((hr != E_NOTIMPL) && fGetTypeInfoCountNotImpl)
			{
				ReportFailure(0x2F07, false, pide, 4, L"IDispatchEx::GetTypeInfo(0) did not return E_NOTIMPL when GetTypeInfoCount did.  hr = %08X", hr);
			}
		}
	}

	else
	{
		piti = NULL;
	}

	wchar_t *rgszNames[1] =
	{
		L"Aj_34Hfm6",
	};

	DISPID dispid;

	hr = pide->GetIDsOfNames(IID_NULL,
		rgszNames,
		1,
		LOCALE_NEUTRAL,
		&dispid);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x2F15, false, pide, 5, L"IDispatchEx::GetIDsOfNames(\"Aj_34Hfm6\") succeeded");
	}


	bool fMemberNotFound = false;

	DISPPARAMS dp;
	VARIANT varResult;
	EXCEPINFO ei;

	dp.rgvarg = NULL;
	dp.rgdispidNamedArgs = NULL;
	dp.cArgs = 0;
	dp.cNamedArgs = 0;

	varResult.vt = VT_ILLEGAL;

	memset(&ei, -1, sizeof(ei));

	hr = pide->InvokeEx(0x73529A4B,			       // id
		LOCALE_SYSTEM_DEFAULT,		       // lcid
		DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
		&dp,				       // pdp
		&varResult,			       // pVarRes
		&ei,				       // pei
		NULL);				       // pspCaller

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x2F08, false, pide, 8, L"IDispatchEx::InvokeEx(0x73529A4B) succeeded");

		if (varResult.vt == VT_ILLEGAL)
		{
			ReportFailure(0x2F09, false, pide, 8, L"IDispatchEx::InvokeEx(0x73529A4B) did not initialize varResult");
		}

		else
		{
			VariantClear(&varResult);
		}
	}

	else
	{
		if (hr == DISP_E_EXCEPTION)
		{
			hr = HrCheckAndFreeExcepInfo(&ei, pide, 8);
		}

		if (hr != DISP_E_MEMBERNOTFOUND)
		{
			fMemberNotFound = true;       // Report once only

			ReportFailure(0x2F0A, false, pide, 8, L"IDispatchEx::InvokeEx(0x73529A4B) failure did not return DISP_E_MEMBERNOTFOUND.  hr = %08X", hr);
		}
	}

	// Try reserved DISPIDs

	for (size_t idispids = 0; idispids < cdispids; idispids++)
	{
		dispid = rgdispids[idispids].dispid;
		const wchar_t *szDispid = rgdispids[idispids].sz;

		// UNDONE: Use GetMemberProperties to decide how to call

		dp.rgvarg = NULL;
		dp.rgdispidNamedArgs = NULL;
		dp.cArgs = 0;
		dp.cNamedArgs = 0;

		varResult.vt = VT_ILLEGAL;

		memset(&ei, -1, sizeof(ei));

		hr = pide->InvokeEx(dispid,				  // id
			LOCALE_SYSTEM_DEFAULT,		  // lcid
			DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
			&dp,					  // pdp
			&varResult,				  // pVarRes
			&ei,					  // pei
			NULL);				  // pspCaller

		SetMyUnhandledExceptionFilter(true);

		if (SUCCEEDED(hr))
		{
			if (varResult.vt == VT_ILLEGAL)
			{
				ReportFailure(0x2F0B, false, pide, 8, L"IDispatchEx::InvokeEx(%s) did not initialize varResult", szDispid);
			}

			else
			{
				int rc = TestAndClearVariant(varResult);

				if (rc != 0)
				{
					return(rc);
				}
			}
		}

		else
		{
			if (hr == DISP_E_EXCEPTION)
			{
				hr = HrCheckAndFreeExcepInfo(&ei, pide, 8);
			}

			if ((hr != DISP_E_MEMBERNOTFOUND) && (hr != DISP_E_BADPARAMCOUNT) && !fMemberNotFound)
			{
				fMemberNotFound = true;	  // Report once only

				ReportFailure(0x2F0C, false, pide, 8, L"IDispatchEx::InvokeEx(%s) failure did not return DISP_E_MEMBERNOTFOUND.  hr = %08X", szDispid, hr);
			}
		}
	}

	if (piti != NULL)
	{
		int rc = CheckIDispatchExTypeInfo(pide, piti, NULL);

		if (rc == -1)
		{
			// Release piti and set to NULL so that we try fallback enumeration of DISPIDs

			Release(piti, false);

			piti = NULL;
		}

		else if (rc != 0)
		{
			return(rc);
		}
	}

	if (piti == NULL)
	{
		// We don't have an ITypeInfo.  Just try a range of DISPIDs.

		bool fGetNext = false;

		dispid = DISPID_STARTENUM;

		for (;;)
		{
			DISPID dispidNext;

			hr = pide->GetNextDispID(fdexEnumAll, dispid, &dispidNext);

			if (FAILED(hr))
			{
				if (hr != E_NOTIMPL)
				{
					ReportFailure(0x2F0D, false, pide, 13, L"IDispatchEx::GetNextDispID(%d) failure did not return E_NOTIMPL.  Returned%08X", dispid, hr);
				}
				break;
			}

			if (hr == S_FALSE)
			{
				break;
			}

			fGetNext = true;

			dispid = dispidNext;

			BSTR bstrName;

			hr = pide->GetMemberName(dispid, &bstrName);

			if (FAILED(hr))
			{
				if (hr != E_NOTIMPL)
				{
					ReportFailure(0x2F0E, false, pide, 12, L"IDispatchEx::GetMemberName(%d) failed.  hr = %08X", dispid, hr);
				}

				bstrName = NULL;
			}

			// UNDONE: Use GetMemberProperties to decide how to call

			dp.rgvarg = NULL;
			dp.rgdispidNamedArgs = NULL;
			dp.cArgs = 0;
			dp.cNamedArgs = 0;

			varResult.vt = VT_ILLEGAL;

			memset(&ei, -1, sizeof(ei));

			hr = pide->InvokeEx(dispid,				     // id
				LOCALE_SYSTEM_DEFAULT,		     // lcid
				DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
				&dp,				     // pdp
				&varResult,			     // pVarRes
				&ei,				     // pei
				NULL);				     // pspCaller

			SetMyUnhandledExceptionFilter(true);

			if (SUCCEEDED(hr))
			{
				if (varResult.vt == VT_ILLEGAL)
				{
					ReportFailure(0x2F0F, false, pide, 8, L"IDispatchEx::InvokeEx(%d) did not initialize varResult", dispid);
				}

				else
				{
					int rc = TestAndClearVariant(varResult);

					if (rc != 0)
					{
						return(rc);
					}
				}
			}

			else
			{
				if (hr == DISP_E_EXCEPTION)
				{
					hr = HrCheckAndFreeExcepInfo(&ei, pide, 8);
				}

				if (hr == DISP_E_MEMBERNOTFOUND)
				{
					ReportFailure(0x2F10, false, pide, 8, L"IDispatchEx::InvokeEx(%d \"%s\") returned DISP_E_MEMBERNOTFOUND", dispid, (bstrName == NULL) ? L"" : bstrName);
				}

#if 1
				else if (hr != DISP_E_BADPARAMCOUNT)
				{
					ReportFailure(0x2F11, false, pide, 8, L"IDispatchEx::InvokeEx(%d \"%s\") failed.  hr = %08X", dispid, (bstrName == NULL) ? L"" : bstrName, hr);
				}
#endif
			}

			if (bstrName != NULL)
			{
				SysFreeString(bstrName);
			}
		}

		if (!fGetNext)
		{
			for (dispid = 1; dispid < dispidMax; dispid++)
			{
				BSTR bstrName;

				hr = pide->GetMemberName(dispid, &bstrName);

				if (FAILED(hr))
				{
					if (hr != E_NOTIMPL)
					{
						ReportFailure(0x2F12, false, pide, 12, L"IDispatchEx::GetMemberName(%d) failed.  hr = %08X", dispid, hr);
					}

					bstrName = NULL;
				}

				// UNDONE: Use GetMemberProperties to decide how to call

				dp.rgvarg = NULL;
				dp.rgdispidNamedArgs = NULL;
				dp.cArgs = 0;
				dp.cNamedArgs = 0;

				varResult.vt = VT_ILLEGAL;

				memset(&ei, -1, sizeof(ei));

				hr = pide->InvokeEx(dispid, 				// id
					LOCALE_SYSTEM_DEFAULT,			// lcid
					DISPATCH_METHOD | DISPATCH_PROPERTYGET, // wFlags
					&dp,					// pdp
					&varResult,				// pVarRes
					&ei,					// pei
					NULL);					// pspCaller

				SetMyUnhandledExceptionFilter(true);

				if (SUCCEEDED(hr))
				{
					if (varResult.vt == VT_ILLEGAL)
					{
						ReportFailure(0x2F13, false, pide, 8, L"IDispatchEx::InvokeEx(%d) did not initialize varResult", dispid);
					}

					else
					{
						int rc = TestAndClearVariant(varResult);

						if (rc != 0)
						{
							return(rc);
						}
					}
				}

				else
				{
					if (hr == DISP_E_EXCEPTION)
					{
						hr = HrCheckAndFreeExcepInfo(&ei, pide, 8);
					}

					if ((hr != DISP_E_MEMBERNOTFOUND) && (hr != DISP_E_BADPARAMCOUNT))
					{
						if (bstrName != NULL)
						{
							ReportFailure(0x2F14, false, pide, 8, L"IDispatchEx::InvokeEx(%d \"%s\") failed.  hr = %08X", dispid, bstrName, hr);
						}

						else
						{
							ReportFailure(0x2F14, false, pide, 8, L"IDispatchEx::InvokeEx(%d) failed.  hr = %08X", dispid, hr);
						}
					}
				}

				if (bstrName != NULL)
				{
					SysFreeString(bstrName);
				}
			}
		}
	}

	else
	{
		Release(piti, false);
	}

	Release(pide, fClassObject);

	return(0);
}


int CheckIEnumConnectionPoints(IUnknown *punk, bool fClassObject)
{
	IEnumConnectionPoints *piecp;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IEnumConnectionPoints", IID_PPV_ARGS(&piecp));

	if (FAILED(hr))
	{
		return(0);
	}

	IConnectionPoint *picp = (IConnectionPoint *) (intptr_t) -1;

	hr = piecp->Next(1, &picp, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1001, false, piecp, 3, L"IEnumConnectionPoints::Next(1, &picp, NULL) failed.  hr = %08X", hr);
	}

	else if (hr != S_FALSE)
	{
		if (picp == NULL)
		{
			ReportFailure(0x1002, false, piecp, 3, L"IEnumConnectionPoints::Next(1, &picp, NULL) returned NULL");
		}

		else
		{
			dwNonClass++;

			Release(picp, false);
		}
	}

	hr = piecp->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1003, false, piecp, 5, L"IEnumConnectionPoints::Reset failed.  hr = %08X", hr);
	}

	hr = piecp->Skip(1);

	if (FAILED(hr))
	{
		ReportFailure(0x1004, false, piecp, 4, L"IEnumConnectionPoints::Skip(1) failed.  hr = %08X", hr);
	}

	hr = piecp->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1005, false, piecp, 5, L"IEnumConnectionPoints::Reset failed.  hr = %08X", hr);
	}

	IID iidLast = iidUndefined;

	for (;;)
	{
		picp = (IConnectionPoint *) (intptr_t) -1;

		ULONG celtFetched;

		hr = piecp->Next(1, &picp, &celtFetched);

		if (FAILED(hr))
		{
			ReportFailure(0x1006, false, piecp, 3, L"IEnumConnectionPoints::Next failed.  hr = %08X", hr);

			break;
		}

		if (hr == S_FALSE)
		{
			if (celtFetched != 0)
			{
				ReportFailure(0x1007, false, piecp, 3, L"IEnumConnectionPoints::Next returned S_FALSE w/celtFetched = %u", celtFetched);
			}

			break;
		}

		if (celtFetched != 1)
		{
			ReportFailure(0x1008, false, piecp, 3, L"IEnumConnectionPoints::Next succeeded w/celtFetched = %u", celtFetched);

			if (celtFetched == 0)
			{
				// Avoid infinite loop

				break;
			}
		}

		if (picp != NULL)
		{
			dwNonClass++;

			IID iidT;

			hr = picp->GetConnectionInterface(&iidT);

			if (SUCCEEDED(hr))
			{
				if (iidT == iidLast)
				{
					// There looks to be an loop.  MSN Messenger has this bug.

					ReportFailure(0x1009, false, piecp, 3, L"IEnumConnectionPoints::Next returned duplicate connection point");

					Release(picp, false);
					break;
				}

				iidLast = iidT;
			}

			int rc = TestAndReleaseInterface(picp, NULL, false, false, true);

			if (rc != 0)
			{
				return(rc);
			}
		}
	}

	IEnumConnectionPoints *piecpClone;

	hr = piecp->Clone(&piecpClone);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x100A, false, piecp, 6, L"IEnumConnectionPoints::Clone failed.  hr = %08X", hr);
		}
	}

	else if (piecpClone == NULL)
	{
		ReportFailure(0x100B, false, piecp, 6, L"IEnumConnectionPoints::Clone returned NULL");
	}

	else
	{
		dwNonClass++;

		Release(piecpClone, false);
	}

	Release(piecp, fClassObject);

	return(0);
}


int CheckIEnumConnections(IUnknown *punk, bool fClassObject)
{
	IEnumConnections *piec;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IEnumConnections", IID_PPV_ARGS(&piec));

	if (FAILED(hr))
	{
		return(0);
	}

	CONNECTDATA cd;

	cd.pUnk = (IUnknown *) (intptr_t) -1;
	cd.dwCookie = (DWORD) -1;

	hr = piec->Next(1, &cd, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1101, false, piec, 3, L"IEnumConnections::Next(1, &cd, NULL) failed.  hr = %08X", hr);
	}

	else if (hr != S_FALSE)
	{
		dwNonClass++;

		Release(cd.pUnk, false);
	}

	hr = piec->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1102, false, piec, 5, L"IEnumConnections::Reset failed.  hr = %08X", hr);
	}

	hr = piec->Skip(1);

	if (FAILED(hr))
	{
		ReportFailure(0x1103, false, piec, 4, L"IEnumConnections::Skip(1) failed.  hr = %08X", hr);
	}

	hr = piec->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1104, false, piec, 5, L"IEnumConnections::Reset failed.  hr = %08X", hr);
	}

	for (;;)
	{
		cd.pUnk = (IUnknown *) (intptr_t) -1;
		cd.dwCookie = (DWORD) -1;

		ULONG celtFetched;

		hr = piec->Next(1, &cd, &celtFetched);

		if (FAILED(hr))
		{
			ReportFailure(0x1105, false, piec, 3, L"IEnumConnections::Next failed.  hr = %08X", hr);

			break;
		}

		if (hr == S_FALSE)
		{
			if (celtFetched != 0)
			{
				ReportFailure(0x1106, false, piec, 3, L"IEnumConnections::Next returned S_FALSE w/celtFetched = %u", celtFetched);
			}

			break;
		}

		if (celtFetched != 1)
		{
			ReportFailure(0x1107, false, piec, 3, L"IEnumConnections::Next succeeded w/celtFetched = %u", celtFetched);

			if (celtFetched == 0)
			{
				// Avoid infinite loop

				break;
			}
		}

		dwNonClass++;

		int rc = TestAndReleaseInterface(cd.pUnk, NULL, true, false, true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	IEnumConnections *piecClone;

	hr = piec->Clone(&piecClone);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x1108, false, piec, 6, L"IEnumConnections::Clone failed.  hr = %08X", hr);
		}
	}

	else if (piecClone == NULL)
	{
		ReportFailure(0x1109, false, piec, 6, L"IEnumConnections::Clone returned NULL");
	}

	else
	{
		dwNonClass++;

		Release(piecClone, false);
	}

	Release(piec, fClassObject);

	return(0);
}


int CheckIEnumMoniker(IUnknown *punk, bool fClassObject)
{
	IEnumMoniker *piem;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IEnumMoniker", IID_PPV_ARGS(&piem));

	if (FAILED(hr))
	{
		return(0);
	}

	IMoniker *pmk = (IMoniker *) (intptr_t) -1;

	hr = piem->Next(1, &pmk, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1201, false, piem, 3, L"IEnumMoniker::Next(1, &pmk, NULL) failed.  hr = %08X", hr);
	}

	else if (hr != S_FALSE)
	{
		dwNonClass++;

		Release(pmk, false);
	}

	hr = piem->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1202, false, piem, 5, L"IEnumMoniker::Reset failed.  hr = %08X", hr);
	}

	hr = piem->Skip(1);

	if (FAILED(hr))
	{
		ReportFailure(0x1203, false, piem, 4, L"IEnumMoniker::Skip(1) failed.  hr = %08X", hr);
	}

	hr = piem->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1204, false, piem, 5, L"IEnumMoniker::Reset failed.  hr = %08X", hr);
	}

	for (;;)
	{
		pmk = (IMoniker *) (intptr_t) -1;

		ULONG celtFetched;

		hr = piem->Next(1, &pmk, &celtFetched);

		if (FAILED(hr))
		{
			ReportFailure(0x1205, false, piem, 3, L"IEnumMoniker::Next failed.  hr = %08X", hr);

			break;
		}

		if (hr == S_FALSE)
		{
			if (celtFetched != 0)
			{
				ReportFailure(0x1206, false, piem, 3, L"IEnumMoniker::Next returned S_FALSE w/celtFetched = %u", celtFetched);
			}

			break;
		}

		if (celtFetched != 1)
		{
			ReportFailure(0x1207, false, piem, 3, L"IEnumMoniker::Next succeeded w/celtFetched = %u", celtFetched);

			if (celtFetched == 0)
			{
				// Avoid infinite loop

				break;
			}
		}

		if (pmk != NULL)
		{
			dwNonClass++;

			int rc = TestAndReleaseInterface(pmk, NULL, false, false, true);

			if (rc != 0)
			{
				return(rc);
			}
		}
	}

	IEnumMoniker *piemClone;

	hr = piem->Clone(&piemClone);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x1208, false, piem, 6, L"IEnumMoniker::Clone failed.  hr = %08X", hr);
		}
	}

	else if (piemClone == NULL)
	{
		ReportFailure(0x1209, false, piem, 6, L"IEnumMoniker::Clone returned NULL");
	}

	else
	{
		dwNonClass++;

		Release(piemClone, false);
	}

	Release(piem, fClassObject);

	return(0);
}


int CheckIEnumUnknown(IUnknown *punk, bool fClassObject)
{
	IEnumUnknown *pieu;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IEnumUnknown", IID_PPV_ARGS(&pieu));

	if (FAILED(hr))
	{
		return(0);
	}

	IUnknown *punkEnum = (IUnknown *) (intptr_t) -1;

	hr = pieu->Next(1, &punkEnum, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1301, false, pieu, 3, L"IEnumUnknown::Next(1, &punk, NULL) failed.  hr = %08X", hr);
	}

	else if (hr != S_FALSE)
	{
		dwNonClass++;

		Release(punkEnum, false);
	}

	hr = pieu->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1302, false, pieu, 5, L"IEnumUnknown::Reset failed.  hr = %08X", hr);
	}

	hr = pieu->Skip(1);

	if (FAILED(hr))
	{
		ReportFailure(0x1303, false, pieu, 4, L"IEnumUnknown::Skip(1) failed.  hr = %08X", hr);
	}

	hr = pieu->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1304, false, pieu, 5, L"IEnumUnknown::Reset failed.  hr = %08X", hr);
	}

	for (;;)
	{
		punkEnum = (IUnknown *) (intptr_t) -1;

		ULONG celtFetched;

		hr = pieu->Next(1, &punkEnum, &celtFetched);

		if (FAILED(hr))
		{
			ReportFailure(0x1305, false, pieu, 3, L"IEnumUnknown::Next failed.  hr = %08X", hr);

			break;
		}

		if (hr == S_FALSE)
		{
			if (celtFetched != 0)
			{
				ReportFailure(0x1306, false, pieu, 3, L"IEnumUnknown::Next returned S_FALSE w/celtFetched = %u", celtFetched);
			}

			break;
		}

		if (celtFetched != 1)
		{
			ReportFailure(0x1307, false, pieu, 3, L"IEnumUnknown::Next succeeded w/celtFetched = %u", celtFetched);

			if (celtFetched == 0)
			{
				// Avoid infinite loop

				break;
			}
		}

		if (punkEnum != NULL)
		{
			dwNonClass++;

			int rc = TestAndReleaseInterface(punkEnum, NULL, true, false, true);

			if (rc != 0)
			{
				return(rc);
			}
		}
	}

	IEnumUnknown *pieuClone;

	hr = pieu->Clone(&pieuClone);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x1308, false, pieu, 6, L"IEnumUnknown::Clone failed.  hr = %08X", hr);
		}
	}

	else if (pieuClone == NULL)
	{
		ReportFailure(0x1309, false, pieu, 6, L"IEnumUnknown::Clone returned NULL");
	}

	else
	{
		dwNonClass++;

		Release(pieuClone, false);
	}

	Release(pieu, fClassObject);

	return(0);
}


int CheckIEnumVARIANT(IUnknown *punk, bool fClassObject)
{
	IEnumVARIANT *piev;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IEnumVARIANT", IID_PPV_ARGS(&piev));

	if (FAILED(hr))
	{
		return(0);
	}

	VARIANT var;

	hr = piev->Next(1, &var, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1401, false, piev, 3, L"IEnumVARIANT::Next(1, &var, NULL) failed.  hr = %08X", hr);
	}

	else if (hr != S_FALSE)
	{
		VariantClear(&var);
	}

	hr = piev->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1402, false, piev, 5, L"IEnumVARIANT::Reset failed.  hr = %08X", hr);
	}

	hr = piev->Skip(1);

	if (FAILED(hr))
	{
		ReportFailure(0x1403, false, piev, 4, L"IEnumVARIANT::Skip(1) failed.  hr = %08X", hr);
	}

	hr = piev->Reset();

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1404, false, piev, 5, L"IEnumVARIANT::Reset failed.  hr = %08X", hr);
	}

	for (;;)
	{
		ULONG celtFetched;

		hr = piev->Next(1, &var, &celtFetched);

		if (FAILED(hr))
		{
			ReportFailure(0x1405, false, piev, 3, L"IEnumVARIANT::Next failed.  hr = %08X", hr);

			break;
		}

		if (hr == S_FALSE)
		{
			if (celtFetched != 0)
			{
				ReportFailure(0x1406, false, piev, 3, L"IEnumVARIANT::Next returned S_FALSE w/celtFetched = %u", celtFetched);
			}

			break;
		}

		if (celtFetched != 1)
		{
			ReportFailure(0x1407, false, piev, 3, L"IEnumVARIANT::Next succeeded w/celtFetched = %u", celtFetched);

			if (celtFetched == 0)
			{
				// Avoid infinite loop

				break;
			}
		}

		int rc = TestAndClearVariant(var);

		if (rc != 0)
		{
			return(rc);
		}
	}

	IEnumVARIANT *pievClone;

	hr = piev->Clone(&pievClone);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x1408, false, piev, 6, L"IEnumVARIANT::Clone failed.  hr = %08X", hr);
		}
	}

	else if (pievClone == NULL)
	{
		ReportFailure(0x1409, false, piev, 6, L"IEnumVARIANT::Clone returned NULL");
	}

	else
	{
		dwNonClass++;

		Release(pievClone, false);
	}

	Release(piev, fClassObject);

	return(0);
}


int CheckIMoniker(IUnknown *punk, bool fClassObject)
{
	IMoniker *pmk;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IMoniker", IID_PPV_ARGS(&pmk));

	if (FAILED(hr))
	{
		return(0);
	}

	IBindCtx *pbc = NULL;

	hr = CreateBindCtx(0, &pbc);

	if (FAILED(hr))
	{
		pbc = NULL;
	}

	if (pbc != NULL)
	{
		// UNDONE: Use an IID other than IUnknown?

		IUnknown *punkBound = (IUnknown *) (intptr_t) -1;

		hr = pmk->BindToObject(pbc, pmk, IID_PPV_ARGS(&punkBound));

		if (SUCCEEDED(hr))
		{
			dwNonClass++;

			int rc = TestAndReleaseInterface(punkBound, NULL, true, false, true);

			if (rc != 0)
			{
				return(rc);
			}
		}

		else
		{
			if (hr != MK_E_NOOBJECT)
			{
				ReportFailure(0x2D01, false, pmk, 8, L"IMoniker::BindToObject failed.  hr = %08X", hr);
			}

			if (punkBound != NULL)
			{
				ReportFailure(0x2D02, false, pmk, 8, L"IMoniker::BindToObject failure did not set *ppvObject = NULL");
			}
		}
	}

	if (pbc != NULL)
	{
		// UNDONE: Use an IID other than IStream?

		IStream *pis = (IStream *) (intptr_t) -1;

		hr = pmk->BindToStorage(pbc, pmk, IID_PPV_ARGS(&pis));

		if (SUCCEEDED(hr))
		{
			dwNonClass++;

			int rc = TestAndReleaseInterface(pis, NULL, false, false, true);

			if (rc != 0)
			{
				return(rc);
			}
		}

		else
		{
			if ((hr != MK_E_NOSTORAGE) && (hr != E_NOINTERFACE))
			{
				ReportFailure(0x2D03, false, pmk, 9, L"IMoniker::BindToStorage failed.  hr = %08X", hr);
			}

			if (pis != NULL)
			{
				ReportFailure(0x2D04, false, pmk, 9, L"IMoniker::BindToStorage failure did not set *ppvObject = NULL");
			}
		}
	}

	IEnumMoniker *piem = (IEnumMoniker *) (intptr_t) -1;

	hr = pmk->Enum(TRUE, &piem);

	if (SUCCEEDED(hr))
	{
		// It is valid to return S_OK and piem == NULL

		if (piem != NULL)
		{
			dwNonClass++;

			int rc = TestAndReleaseInterface(piem, NULL, false, false, true);

			if (rc != 0)
			{
				return(rc);
			}
		}
	}

	else if (piem != NULL)
	{
		ReportFailure(0x2D05, false, pmk, 12, L"IMoniker::Enum failed.  hr = %08X", hr);

		if (punk != NULL)
		{
			ReportFailure(0x2D06, false, pmk, 12, L"IMoniker::Enum failure did not set *ppenum = NULL");
		}
	}

	DWORD dwHash;

	hr = pmk->Hash(&dwHash);

	if (pbc != NULL)
	{
		wchar_t *szDisplayName;

		hr = pmk->GetDisplayName(pbc, NULL, &szDisplayName);

		if (SUCCEEDED(hr))
		{
			DWORD cchEaten;
			IMoniker *pmk2;

			hr = MkParseDisplayName(pbc, szDisplayName, &cchEaten, &pmk2);

			if (SUCCEEDED(hr))
			{
				dwNonClass++;

				FreeUnusedLibraries();

				if (cchEaten != wcslen(szDisplayName))
				{
					ReportFailure(0x2D07, false, NULL, 0, L"MkParseDisplayName consumed only part of OBJREF");
				}

				// Capture address of Release() method since after release the memory may be gone

				const void *pvRelease = PvMethod(pmk2, 2);

				ULONG cref = Release(pmk2, fClassObject);

				if (cref != 0)
				{
					ReportFailure(0x2D08, false, pvRelease, -1, L"IMoniker::Release returned %u", cref);
				}
			}

			else
			{
				ReportFailure(0x2D09, false, NULL, 0, L"MkParseDisplayName(\"%s\") failed.  hr = %08X", szDisplayName, hr);
			}

			CoTaskMemFree(szDisplayName);
		}
	}

	if (pbc != NULL)
	{
		pbc->Release();
	}

	Release(pmk, fClassObject);

	return(0);
}


int CheckIObjectSafety(IUnknown *punk, bool fClassObject)
{
	struct SAFETYINTERFACE
	{
		REFIID iid;
		const wchar_t *szIid;
	};

	static const SAFETYINTERFACE rgsi[] =
	{
		{ IID_IActiveScript,	    L"IActiveScript"	    },
		{ IID_IActiveScriptParse,     L"IActiveScriptParse"   },
		{ IID_IDispatch,		    L"IDispatch"	    },
		{ IID_IDispatchEx,	    L"IDispatchEx"	    },
		{ IID_IPersist,		    L"IPersist" 	    },
		{ IID_IPersistFile,	    L"IPersistFile"	    },
#if 0
		{ IID_IPersistHistory,	    L"IPersistHistory"	    },
#endif
		{ IID_IPersistMoniker,	    L"IPersistMoniker"	    },
		{ IID_IPersistPropertyBag,    L"IPersistPropertyBag"  },
		{ IID_IPersistPropertyBag2,   L"IPersistPropertyBag2" },
		{ IID_IPersistStorage,	    L"IPersistStorage"	    },
		{ IID_IPersistStream,	    L"IPersistStream"	    },
		{ IID_IPersistStreamInit,     L"IPersistStreamInit"   },
	};

	const size_t csi = sizeof(rgsi) / sizeof(rgsi[0]);

	IObjectSafety *pios;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IObjectSafety", IID_PPV_ARGS(&pios));

	if (FAILED(hr))
	{
		return(0);
	}

	DWORD dwSupported;
	DWORD dwEnabled;

	hr = pios->GetInterfaceSafetyOptions(iidUndefined, &dwSupported, &dwEnabled);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x1501, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(iidUndefined) succeeded");
	}

	else if (hr != E_NOINTERFACE)
	{
		ReportFailure(0x1502, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(iidUndefined) failure did not return E_NOINTERFACE.  hr = %08X", hr);
	}

	int rc;

	bool rgfSupportedNoSite[csi];
	DWORD rgdwSupportedNoSite[csi];
	DWORD rgdwEnabledNoSite[csi];

	for (size_t isi = 0; isi < csi; isi++)
	{
		rc = GetInterfaceSafetyOptions(pios, rgsi[isi].iid, rgsi[isi].szIid, &rgfSupportedNoSite[isi], &rgdwSupportedNoSite[isi], &rgdwEnabledNoSite[isi]);

		if (rc != 0)
		{
			Release(pios, fClassObject);

			return(rc);
		}
	}

	if (fCheckSafety)
	{
		for (size_t isi = 0; isi < csi; isi++)
		{
			if (rgfSupportedNoSite[isi])
			{
				ReportFailure(0x15FF, false, pios, 3, L"GetInterfaceSafetyOptions: dwSupported=%08X, dwEnabled=%08X, %s", rgdwSupportedNoSite[isi], rgdwEnabledNoSite[isi], rgsi[isi].szIid);
			}
		}
	}

	if (fHTML || fCheckSafety)
	{
		// With -html we don't want to override the HTML site

		Release(pios, fClassObject);

		return(0);
	}

	for (size_t isi = 0; isi < csi; isi++)
	{
		rc = SetInterfaceSafetyOptions(pios, rgsi[isi].iid, rgsi[isi].szIid, rgfSupportedNoSite[isi], rgdwSupportedNoSite[isi], rgdwEnabledNoSite[isi]);

		if (rc != 0)
		{
			Release(pios, fClassObject);

			return(rc);
		}
	}

	{
		rc = SetSite(punk, NULL);

		if (rc != 0)
		{
			if (rc == -1)
			{
				// Neither IOleObject nor IObjectWithSite supported

				rc = 0;
			}

			Release(pios, fClassObject);

			return(rc);
		}

		bool rgfSupportedNullSite[csi];
		DWORD rgdwSupportedNullSite[csi];
		DWORD rgdwEnabledNullSite[csi];

		for (size_t isi = 0; isi < csi; isi++)
		{
			rc = GetInterfaceSafetyOptions(pios, rgsi[isi].iid, rgsi[isi].szIid, &rgfSupportedNullSite[isi], &rgdwSupportedNullSite[isi], &rgdwEnabledNullSite[isi]);

			if (rc != 0)
			{
				Release(pios, fClassObject);

				return(rc);
			}
		}

		for (size_t isi = 0; isi < csi; isi++)
		{
			rc = SetInterfaceSafetyOptions(pios, rgsi[isi].iid, rgsi[isi].szIid, rgfSupportedNullSite[isi], rgdwSupportedNullSite[isi], rgdwEnabledNullSite[isi]);

			if (rc != 0)
			{
				Release(pios, fClassObject);

				return(rc);
			}
		}

		for (size_t isi = 0; isi < csi; isi++)
		{
			if (rgfSupportedNoSite[isi] != rgfSupportedNullSite[isi])
			{
				ReportFailure(0x1503, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) failure changed between no site and NULL site", rgsi[isi].szIid);
			}

			else if (rgfSupportedNoSite[isi])
			{
				if (rgdwSupportedNoSite[isi] != rgdwSupportedNullSite[isi])
				{
					ReportFailure(0x1504, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwSupported for no site %08X != NULL site %08X", rgsi[isi].szIid, rgdwSupportedNoSite[isi], rgdwSupportedNullSite[isi]);
				}

				if (rgdwEnabledNoSite[isi] != rgdwEnabledNullSite[isi])
				{
					ReportFailure(0x1505, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwEnabled for no site %08X != NULL site %08X", rgsi[isi].szIid, rgdwEnabledNoSite[isi], rgdwEnabledNullSite[isi]);
				}
			}
		}
	}

	{
		CSite cs;

		rc = SetSite(punk, &cs);

		if (rc != 0)
		{
			if (rc == -1)
			{
				// Neither IOleObject nor IObjectWithSite supported

				rc = 0x1506;
			}

			Release(pios, fClassObject);

			return(rc);
		}

		if (cs.m_cref <= 1)
		{
			ReportFailure(0x1507, false, NULL, 0, L"SetSite did not change ref count of IOleClientSite");
		}

		bool rgfSupportedDumbSite[csi];
		DWORD rgdwSupportedDumbSite[csi];
		DWORD rgdwEnabledDumbSite[csi];

		for (size_t isi = 0; isi < csi; isi++)
		{
			rc = GetInterfaceSafetyOptions(pios, rgsi[isi].iid, rgsi[isi].szIid, &rgfSupportedDumbSite[isi], &rgdwSupportedDumbSite[isi], &rgdwEnabledDumbSite[isi]);

			if (rc != 0)
			{
				Release(pios, fClassObject);

				return(rc);
			}
		}

		for (size_t isi = 0; isi < csi; isi++)
		{
			rc = SetInterfaceSafetyOptions(pios, rgsi[isi].iid, rgsi[isi].szIid, rgfSupportedDumbSite[isi], rgdwSupportedDumbSite[isi], rgdwEnabledDumbSite[isi]);

			if (rc != 0)
			{
				Release(pios, fClassObject);

				return(rc);
			}
		}

		for (size_t isi = 0; isi < csi; isi++)
		{
			if (rgfSupportedNoSite[isi] != rgfSupportedDumbSite[isi])
			{
				ReportFailure(0x1508, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) failure changed between no site and dumb site", rgsi[isi].szIid);
			}

			else if (rgfSupportedNoSite[isi])
			{
				if (rgdwSupportedNoSite[isi] != rgdwSupportedDumbSite[isi])
				{
					ReportFailure(0x1509, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwSupported for no site %08X != dumb site %08X", rgsi[isi].szIid, rgdwSupportedNoSite[isi], rgdwSupportedDumbSite[isi]);
				}

				if (rgdwEnabledNoSite[isi] != rgdwEnabledDumbSite[isi])
				{
					ReportFailure(0x150A, false, pios, 3, L"IObjectSafety::GetInterfaceSafetyOptions(%s) dwEnabled for no site %08X != dumb site %08X", rgsi[isi].szIid, rgdwEnabledNoSite[isi], rgdwEnabledDumbSite[isi]);
				}
			}
		}

		rc = SetSite(punk, NULL);

		if (rc != 0)
		{
			if (rc == -1)
			{
				// Neither IOleObject nor IObjectWithSite supported

				rc = 0x150B;
			}

			Release(pios, fClassObject);

			return(rc);
		}

		if (cs.m_cref != 1)
		{
			ReportFailure(0x150C, false, NULL, 0, L"SetSite(NULL) did not restore ref count of IOleClientSite");
		}
	}

	// UNDONE: Try more site variations

	Release(pios, fClassObject);

	return(rc);
}


int CheckIOleCommandTarget(IUnknown *punk, bool fClassObject)
{
	IOleCommandTarget *pioct;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IOleCommandTarget", IID_PPV_ARGS(&pioct));

	if (FAILED(hr))
	{
		return(0);
	}

	OLECMD olecmd;

	olecmd.cmdID = 0;		       // Undefined command
	olecmd.cmdf = 0;

	hr = pioct->QueryStatus(NULL, 1, &olecmd, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1601, false, pioct, 3, L"IOleCommandTarget::QueryStatus(NULL) return %08X", hr);
	}

	if (olecmd.cmdf & OLECMDF_SUPPORTED)
	{
		ReportFailure(0x1602, false, pioct, 3, L"IOleCommandTarget::QueryStatus(NULL) CMDID == 0 supported");
	}

	hr = pioct->Exec(NULL, 0, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x1603, false, pioct, 4, L"IOleCommandTarget::Exec(NULL, 0) succeeded");
	}

	else if (hr != OLECMDERR_E_NOTSUPPORTED)
	{
		ReportFailure(0x1604, false, pioct, 4, L"IOleCommandTarget::Exec(NULL, 0) failure did not return OLECMDERR_E_NOTSUPPORTED.  hr = %08X", hr);
	}

	hr = pioct->Exec(NULL, OLECMDID_REFRESH, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);

	if (FAILED(hr))
	{
		if (hr != OLECMDERR_E_NOTSUPPORTED)
		{
			ReportFailure(0x1605, false, pioct, 4, L"IOleCommandTarget::Exec(NULL, OLECMDID_REFRESH) failure did not return OLECMDERR_E_NOTSUPPORTED.  hr = %08X", hr);
		}
	}

	hr = pioct->Exec(NULL, OLECMDID_STOP, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);

	if (FAILED(hr))
	{
		if (hr != OLECMDERR_E_NOTSUPPORTED)
		{
			ReportFailure(0x1606, false, pioct, 4, L"IOleCommandTarget::Exec(NULL, OLECMDID_STOP) failure did not return OLECMDERR_E_NOTSUPPORTED.  hr = %08X", hr);
		}
	}

	olecmd.cmdID = 0;
	olecmd.cmdf = 0;

	hr = pioct->QueryStatus(&iidUndefined, 1, &olecmd, NULL);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x1607, false, pioct, 3, L"IOleCommandTarget::QueryStatus(iidUndefined) succeeded");
	}

	else if (hr != OLECMDERR_E_UNKNOWNGROUP)
	{
		ReportFailure(0x1608, false, pioct, 3, L"IOleCommandTarget::QueryStatus(iidUndefined) failure did not return OLECMDERR_E_UNKNOWNGROUP.  hr = %08X", hr);
	}

	hr = pioct->Exec(&iidUndefined, 0, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x1609, false, pioct, 4, L"IOleCommandTarget::Exec(iidUndefined) succeeded");
	}

	else if (hr != OLECMDERR_E_UNKNOWNGROUP)
	{
		ReportFailure(0x160A, false, pioct, 4, L"IOleCommandTarget::Exec(iidUndefined) failure did not return OLECMDERR_E_UNKNOWNGROUP.  hr = %08X", hr);
	}

	Release(pioct, fClassObject);

	return(0);
}


int CheckIOleControl(IUnknown *punk, bool fClassObject)
{
	IOleControl *pioc;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IOleControl", IID_PPV_ARGS(&pioc));

	if (FAILED(hr))
	{
		return(0);
	}

	CONTROLINFO ci;

	memset(&ci, 0xFF, sizeof(ci));

	ci.cb = sizeof(ci);

	hr = pioc->GetControlInfo(&ci);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x1701, false, pioc, 3, L"IOleControl::GetControlInfo failure did not return E_NOTIMPL.  hr = %08X", hr);
		}

		MSG msg;

		memset(&msg, 0, sizeof(msg));

		hr = pioc->OnMnemonic(&msg);

		if (SUCCEEDED(hr))
		{
			ReportFailure(0x1702, false, pioc, 4, L"IOleControl::OnMnemonic succeeded after GetControlInfo failure");
		}

		else if (hr != E_NOTIMPL)
		{
			ReportFailure(0x1703, false, pioc, 4, L"IOleControl::OnMnemonic() failure did not return E_NOTIMPL after GetControlInfo failure.  hr = %08X", hr);
		}
	}

	else
	{
		if (ci.cb != sizeof(ci))
		{
			ReportFailure(0x1704, false, pioc, 3, L"IOleControl::GetControlInfo returned CONTROLINFO::cb == %u", ci.cb);
		}

		if (ci.dwFlags & ~(CTRLINFO_EATS_RETURN | CTRLINFO_EATS_ESCAPE))
		{
			ReportFailure(0x1705, false, pioc, 3, L"IOleControl::GetControlInfo returned CONTROLINFO::dwFlags == %08X", ci.dwFlags);
		}

		if (ci.cAccel != 0)
		{
			ACCEL *rgaccel = new ACCEL[ci.cAccel];

			if (rgaccel == NULL)
			{
				// UNDONE: What?
			}

			else
			{
				int cAccel = CopyAcceleratorTable(ci.hAccel, NULL, 0);

				if (cAccel != ci.cAccel)
				{
					ReportFailure(0x1706, false, pioc, 3, L"IOleControl::GetControlInfo ci.hAccel size (%d) != ci.cAccel (%u)", cAccel, ci.cAccel);
				}

				else
				{
					cAccel = CopyAcceleratorTable(ci.hAccel, rgaccel, ci.cAccel);

					if (cAccel != ci.cAccel)
					{
						// UNDONE: What?
					}

					for (DWORD iaccel = 0; iaccel < ci.cAccel; iaccel++)
					{
						if (rgaccel[iaccel].fVirt & ~(FVIRTKEY | FNOINVERT | FSHIFT | FCONTROL | FALT))
						{
							ReportFailure(0x1707, false, pioc, 3, L"IOleControl::GetControlInfo rgaccel[%u].fVirt == %08X", iaccel, rgaccel[iaccel].fVirt);
						}

						// UNDONE: Call IOleControl::OnMnemonic
					}

					delete [] rgaccel;
				}
			}
		}

		else
		{
			MSG msg;

			memset(&msg, 0, sizeof(msg));

			hr = pioc->OnMnemonic(&msg);

			if (SUCCEEDED(hr))
			{
				ReportFailure(0x1708, false, pioc, 4, L"IOleControl::OnMnemonic() succeeded w/cAccel == 0");
			}

			else if (hr != E_NOTIMPL)
			{
				ReportFailure(0x1709, false, pioc, 4, L"IOleControl::OnMnemonic() failure did not return E_NOTIMPL w/cAccel == 0.  hr = %08X", hr);
			}
		}
	}

	hr = pioc->OnAmbientPropertyChange(DISPID_VALUE);

	if (hr != S_OK)
	{
		ReportFailure(0x170A, false, pioc, 5, L"IOleControl::OnAmbientPropertyChange(DISPID_VALUE) did not return S_OK.  hr = %08X", hr);
	}

	hr = pioc->OnAmbientPropertyChange(DISPID_UNKNOWN);

	if (hr != S_OK)
	{
		ReportFailure(0x170B, false, pioc, 5, L"IOleControl::OnAmbientPropertyChange(DISPID_UNKNOWN) did not return S_OK.  hr = %08X", hr);
	}

	hr = pioc->FreezeEvents(TRUE);

	if (hr != S_OK)
	{
		ReportFailure(0x170C, false, pioc, 6, L"IOleControl::FreezeEvents(TRUE) did not return S_OK.  hr = %08X", hr);
	}

	hr = pioc->FreezeEvents(FALSE);

	if (hr != S_OK)
	{
		ReportFailure(0x170E, false, pioc, 6, L"IOleControl::FreezeEvents(FALSE) did not return S_OK.  hr = %08X", hr);
	}

	Release(pioc, fClassObject);

	return(0);
}


int CheckIPersist(const CLSID *pclsid, IUnknown *punk, bool fClassObject)
{
	IPersist *pip;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IPersist", IID_PPV_ARGS(&pip));

	if (FAILED(hr))
	{
		return(0);
	}

	CLSID clsid2;

	hr = pip->GetClassID(&clsid2);

	if (FAILED(hr))
	{
		ReportFailure(0x1801, false, pip, 3, L"IPersist::GetClassID failed.  hr = %08X", hr);
	}

	else if ((pclsid != NULL) && !IsEqualGUID(*pclsid, clsid2))
	{
		wchar_t szClsid2[39];

		if (StringFromGUID2(clsid2, szClsid2, _countof(szClsid2)) == 0)
		{
			wcscpy_s(szClsid2, _countof(szClsid2), L"different clsid");
		}

		ReportFailure(0x1802, false, pip, 3, L"IPersist::GetClassID returned %s", szClsid2);
	}

	Release(pip, fClassObject);

	return(0);
}


int CheckIPersistHistory(const CLSID *pclsid, IUnknown *punk, bool fClassObject)
{
	IPersistHistory *piph;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IPersistHistory", IID_PPV_ARGS(&piph));

	if (FAILED(hr))
	{
		return(0);
	}

	IPersist *pip;

	hr = HrQueryInterface(punk, fClassObject, L"IPersist", IID_PPV_ARGS(&pip));

	if (SUCCEEDED(hr))
	{
		Release(pip, fClassObject);
	}

	else
	{
		ReportFailure(0x2401, false, punk, 0, L"IPersistHistory w/o IPersist");

		CLSID clsid2;

		hr = piph->GetClassID(&clsid2);

		if (FAILED(hr))
		{
			ReportFailure(0x2402, false, piph, 3, L"IPersistHistory::GetClassID failed.  hr = %08X", hr);
		}

		else if ((pclsid != NULL) && !IsEqualGUID(*pclsid, clsid2))
		{
			wchar_t szClsid2[39];

			if (StringFromGUID2(clsid2, szClsid2, _countof(szClsid2)) == 0)
			{
				wcscpy_s(szClsid2, _countof(szClsid2), L"different clsid");
			}

			ReportFailure(0x2403, false, piph, 3, L"IPersistHistory::GetClassID returned %s", szClsid2);
		}
	}

	// We set a site here because some classes like those from WMP fail IPersistHistory methods when no site has been site

	CSite cs;

	int rc = SetSite(punk, &cs);

	bool fSiteSet = (rc == 0);

	if (fSiteSet)
	{
		if (cs.m_cref <= 1)
		{
			ReportFailure(0x2404, false, NULL, 0, L"SetSite did not change ref count of IOleClientSite");
		}
	}

	else
	{
		if (cs.m_cref != 1)
		{
			ReportFailure(0x2411, false, NULL, 0, L"SetSite failed but changed ref count of IOleClientSite");
		}
	}

	DWORD dwPositionCookie;

	hr = piph->GetPositionCookie(&dwPositionCookie);

	if (FAILED(hr))
	{
		ReportFailure(0x2405, false, piph, 4, L"IPersistHistory::GetPositionCookie failed.  hr = %08X", hr);
	}

	IStream *pis = (IStream *) (intptr_t) -1;

	hr = CreateStreamOnHGlobal(NULL, TRUE, &pis);

	if (FAILED(hr))
	{
		ReportFailure(0x2406, false, NULL, 0, L"CreateStreamOnHGlobal failed.  hr = %08X", hr);
	}

	else
	{
		ULARGE_INTEGER uli0;

		uli0.QuadPart = 0;

		hr = pis->SetSize(uli0);

		if (FAILED(hr))
		{
			ReportFailure(0x2407, false, pis, 6, L"IStream::SetSize(0) failed.  hr = %08X", hr);
		}

		hr = piph->SaveHistory(pis);

		// UNDONE: We should wrap IStream so that we do not rely on system class implementation

		pis->AddRef();

		ULONG cref = pis->Release();

		if (cref != 1)
		{
			ReportFailure(0x2408, false, piph, 6, L"IPersistHistory::Save held reference to stream (%u)", cref);
		}

		if (FAILED(hr))
		{
			if (hr != E_NOTIMPL)
			{
				ReportFailure(0x2409, false, piph, 6, L"IPersistHistory::SaveHistory failed.  hr = %08X", hr);
			}
		}

		else
		{
			LARGE_INTEGER li0;

			li0.QuadPart = 0;

			unsigned __int64 ibNew;

			hr = pis->Seek(li0, STREAM_SEEK_SET, (ULARGE_INTEGER *) &ibNew);

			if (FAILED(hr))
			{
				ReportFailure(0x240A, false, pis, 5, L"IStream::Seek(0, STREAM_SEEK_SET) failed.  hr = %08X", hr);
			}

			else
			{
				IBindCtx *pbc = NULL;

				hr = CreateBindCtx(0, &pbc);

				if (SUCCEEDED(hr))
				{
					hr = piph->LoadHistory(pis, pbc);

					// UNDONE: We should wrap IStream so that we do not rely on system class implementation

					pis->AddRef();

					cref = pis->Release();

					if (cref != 1)
					{
						ReportFailure(0x240B, false, piph, 5, L"IPersistHistory::LoadHistory held reference to stream (%u)", cref);
					}

					if (FAILED(hr))
					{
						ReportFailure(0x240C, false, piph, 5, L"IPersistHistory::Load failed.  hr = %08X", hr);
					}

					// Capture address of Release() method since after release the memory may be gone

					const void *pvRelease = PvMethod(pbc, 2);

					cref = pbc->Release();

					if (cref != 0)
					{
						ReportFailure(0x240D, false, pvRelease, -1, L"IBindCtx::Release returned %u", cref);
					}
				}
			}
		}

		// Capture address of Release() method since after release the memory may be gone

		const void *pvRelease = PvMethod(pis, 2);

		cref = pis->Release();

		if (cref != 0)
		{
			ReportFailure(0x240E, false, pvRelease, -1, L"IStream::Release returned %u", cref);
		}
	}

	hr = piph->SetPositionCookie(dwPositionCookie);

	if (FAILED(hr))
	{
		ReportFailure(0x240F, false, piph, 7, L"IPersistHistory::SetPositionCookie failed.  hr = %08X", hr);
	}

	if (fSiteSet)
	{
		rc = SetSite(punk, NULL);

		if (rc == 0)
		{
			if (cs.m_cref != 1)
			{
				ReportFailure(0x2410, false, NULL, 0, L"SetSite(NULL) did not restore ref count of IOleClientSite");
			}
		}
	}

	Release(piph, fClassObject);

	return(0);
}


int CheckIPersistPropertyBag(const CLSID *pclsid, IUnknown *punk, bool fClassObject)
{
	IPersistPropertyBag *pippb;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IPersistPropertyBag", IID_PPV_ARGS(&pippb));

	if (FAILED(hr))
	{
		return(0);
	}

	IPersist *pip;

	hr = HrQueryInterface(punk, fClassObject, L"IPersist", IID_PPV_ARGS(&pip));

	if (SUCCEEDED(hr))
	{
		Release(pip, fClassObject);
	}

	else
	{
		ReportFailure(0x1901, false, punk, 0, L"IPersistPropertyBag w/o IPersist");

		CLSID clsid2;

		hr = pippb->GetClassID(&clsid2);

		if (FAILED(hr))
		{
			ReportFailure(0x1902, false, pippb, 3, L"IPersistPropertyBag::GetClassID failed.  hr = %08X", hr);
		}

		else if ((pclsid != NULL) && !IsEqualGUID(*pclsid, clsid2))
		{
			wchar_t szClsid2[39];

			if (StringFromGUID2(clsid2, szClsid2, _countof(szClsid2)) == 0)
			{
				wcscpy_s(szClsid2, _countof(szClsid2), L"different clsid");
			}

			ReportFailure(0x1903, false, pippb, 3, L"IPersistPropertyBag::GetClassID returned %s", szClsid2);
		}
	}

	// We set a site here because some classes like those from WMP fail IPersistPropertyBag methods when no site has been site

	CSite cs;

	int rc = SetSite(punk, &cs);

	bool fSiteSet = (rc == 0);

	if (fSiteSet)
	{
		if (cs.m_cref <= 1)
		{
			ReportFailure(0x1904, false, NULL, 0, L"SetSite did not change ref count of IOleClientSite");
		}
	}

	else
	{
		if (cs.m_cref != 1)
		{
			ReportFailure(0x190A, false, NULL, 0, L"SetSite failed but changed ref count of IOleClientSite");
		}
	}

	if (!fHTML)
	{
		hr = pippb->InitNew();

		if (FAILED(hr))
		{
			ReportFailure(0x1905, false, pippb, 4, L"IPersistPropertyBag::InitNew failed.  hr = %08X", hr);
		}
	}

	CPropertyBag *pcpb = new CPropertyBag;

	hr = pippb->Save(pcpb, FALSE, TRUE);

	if (FAILED(hr) && (hr != E_NOTIMPL))
	{
		ReportFailure(0x1906, false, pippb, 6, L"IPersistPropertyBag::Save failed.  hr = %08X", hr);
	}

	hr = pippb->Load(pcpb, NULL);

	if (FAILED(hr))
	{
		ReportFailure(0x1907, false, pippb, 5, L"IPersistPropertyBag::Load failed.  hr = %08X", hr);
	}

	if (pcpb->m_cref != 1)
	{
		ReportFailure(0x1909, false, pippb, 5, L"IPersistPropertyBag::Load held reference to property bag (%u)", pcpb->m_cref);
	}

	if (fSiteSet)
	{
		rc = SetSite(punk, NULL);

		if (rc == 0)
		{
			if (cs.m_cref != 1)
			{
				ReportFailure(0x1908, false, NULL, 0, L"SetSite(NULL) did not restore ref count of IOleClientSite");
			}
		}
	}

	pcpb->Release();

	Release(pippb, fClassObject);

	return(0);
}


int CheckIPersistStream(const CLSID *pclsid, IUnknown *punk, bool fClassObject)
{
	IPersistStream *pips;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IPersistStream", IID_PPV_ARGS(&pips));

	if (FAILED(hr))
	{
		return(0);
	}

	IPersist *pip;

	hr = HrQueryInterface(punk, fClassObject, L"IPersist", IID_PPV_ARGS(&pip));

	if (SUCCEEDED(hr))
	{
		Release(pip, fClassObject);
	}

	else
	{
		ReportFailure(0x3001, false, punk, 0, L"IPersistStream w/o IPersist");

		CLSID clsid2;

		hr = pips->GetClassID(&clsid2);

		if (FAILED(hr))
		{
			ReportFailure(0x3002, false, pips, 3, L"IPersistStream::GetClassID failed.  hr = %08X", hr);
		}

		else if ((pclsid != NULL) && !IsEqualGUID(*pclsid, clsid2))
		{
			wchar_t szClsid2[39];

			if (StringFromGUID2(clsid2, szClsid2, _countof(szClsid2)) == 0)
			{
				wcscpy_s(szClsid2, _countof(szClsid2), L"different clsid");
			}

			ReportFailure(0x3003, false, pips, 3, L"IPersistStream::GetClassID returned %s", szClsid2);
		}
	}

	// We set a site here because some classes like those from WMP fail IPersistStream methods when no site has been site

	CSite cs;

	int rc = SetSite(punk, &cs);

	bool fSiteSet = (rc == 0);

	if (fSiteSet)
	{
		if (cs.m_cref <= 1)
		{
			ReportFailure(0x3004, false, NULL, 0, L"SetSite did not change ref count of IOleClientSite");
		}
	}

	else
	{
		if (cs.m_cref != 1)
		{
			ReportFailure(0x300E, false, NULL, 0, L"SetSite failed but changed ref count of IOleClientSite");
		}
	}

	unsigned __int64 cb = 0;

	hr = pips->GetSizeMax((ULARGE_INTEGER *) &cb);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x3005, false, pips, 7, L"IPersistStream::GetSizeMax failed.  hr = %08X", hr);
		}

		// Let's assume 64K

		cb = 65536;
	}

	if (cb > 0x7FFFFFFF)
	{
		ReportFailure(0x3006, false, pips, 7, L"IPersistStream::GetSizeMax returned cb = %I64u", cb);
	}

	HGLOBAL hStream = GlobalAlloc(GMEM_MOVEABLE, (size_t) cb);

	if (hStream == NULL)
	{
		ReportFailure(0x3007, false, NULL, 0, L"GlobalAlloc failed.  GetLastError(%I64u) = %u", cb, GetLastError());
	}

	else
	{
		IStream *pis = (IStream *) (intptr_t) -1;

		hr = CreateStreamOnHGlobal(hStream, TRUE, &pis);

		if (FAILED(hr))
		{
			ReportFailure(0x3008, false, NULL, 0, L"CreateStreamOnHGlobal failed.  hr = %08X", hr);

			GlobalFree(hStream);
		}

		else
		{
			ULARGE_INTEGER uli0;

			uli0.QuadPart = 0;

			hr = pis->SetSize(uli0);

			if (FAILED(hr))
			{
				ReportFailure(0x3009, false, pis, 6, L"IStream::SetSize(0) failed.  hr = %08X", hr);
			}

			hr = pips->Save(pis, FALSE);

			if (FAILED(hr))
			{
				if (hr != E_NOTIMPL)
				{
					ReportFailure(0x300A, false, pips, 6, L"IPersistStream::Save failed.  hr = %08X", hr);
				}
			}

			else
			{
				LARGE_INTEGER li0;

				li0.QuadPart = 0;

				unsigned __int64 ibNew;

				hr = pis->Seek(li0, STREAM_SEEK_SET, (ULARGE_INTEGER *) &ibNew);

				if (FAILED(hr))
				{
					ReportFailure(0x300B, false, pis, 5, L"IStream::Seek(0, STREAM_SEEK_SET) failed.  hr = %08X", hr);
				}

				else
				{
					hr = pips->Load(pis);

					if (FAILED(hr))
					{
						ReportFailure(0x300C, false, pips, 5, L"IPersistStream::Load failed.  hr = %08X", hr);
					}
				}
			}

			// IPersistStream implementation may retain a reference

			pis->Release();
		}
	}

	if (fSiteSet)
	{
		rc = SetSite(punk, NULL);

		if (rc == 0)
		{
			if (cs.m_cref != 1)
			{
				ReportFailure(0x300D, false, NULL, 0, L"SetSite(NULL) did not restore ref count of IOleClientSite");
			}
		}
	}

	Release(pips, fClassObject);

	return(0);
}


int CheckIPersistStreamInit(const CLSID *pclsid, IUnknown *punk, bool fClassObject)
{
	IPersistStreamInit *pipsi;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IPersistStreamInit", IID_PPV_ARGS(&pipsi));

	if (FAILED(hr))
	{
		return(0);
	}

	IPersist *pip;

	hr = HrQueryInterface(punk, fClassObject, L"IPersist", IID_PPV_ARGS(&pip));

	if (SUCCEEDED(hr))
	{
		Release(pip, fClassObject);
	}

	else
	{
		ReportFailure(0x3101, false, punk, 0, L"IPersistStreamInit w/o IPersist");

		CLSID clsid2;

		hr = pipsi->GetClassID(&clsid2);

		if (FAILED(hr))
		{
			ReportFailure(0x3102, false, pipsi, 3, L"IPersistStreamInit::GetClassID failed.  hr = %08X", hr);
		}

		else if ((pclsid != NULL) && !IsEqualGUID(*pclsid, clsid2))
		{
			wchar_t szClsid2[39];

			if (StringFromGUID2(clsid2, szClsid2, _countof(szClsid2)) == 0)
			{
				wcscpy_s(szClsid2, _countof(szClsid2), L"different clsid");
			}

			ReportFailure(0x3103, false, pipsi, 3, L"IPersistStreamInit::GetClassID returned %s", szClsid2);
		}
	}

	// We set a site here because some classes like those from WMP fail IPersistStream methods when no site has been site

	CSite cs;

	int rc = SetSite(punk, &cs);

	bool fSiteSet = (rc == 0);

	if (fSiteSet)
	{
		if (cs.m_cref <= 1)
		{
			ReportFailure(0x3104, false, NULL, 0, L"SetSite did not change ref count of IOleClientSite");
		}
	}

	else
	{
		if (cs.m_cref != 1)
		{
			ReportFailure(0x310F, false, NULL, 0, L"SetSite failed but changed ref count of IOleClientSite");
		}
	}

	if (!fHTML)
	{
		hr = pipsi->InitNew();

		if (FAILED(hr) && (hr != E_NOTIMPL))
		{
			ReportFailure(0x3105, false, pipsi, 8, L"IPersistStreamInit::InitNew failed.  hr = %08X", hr);
		}
	}

	unsigned __int64 cb = 0;

	hr = pipsi->GetSizeMax((ULARGE_INTEGER *) &cb);

	if (FAILED(hr))
	{
		if (hr != E_NOTIMPL)
		{
			ReportFailure(0x3106, false, pipsi, 7, L"IPersistStreamInit::GetSizeMax failed.  hr = %08X", hr);
		}

		// Let's assume 64K

		cb = 65536;
	}

	if (cb > 0x7FFFFFFF)
	{
		ReportFailure(0x3107, false, pipsi, 7, L"IPersistStreamInit::GetSizeMax returned cb = %I64u", cb);
	}

	HGLOBAL hStream = GlobalAlloc(GMEM_MOVEABLE, (size_t) cb);

	if (hStream == NULL)
	{
		ReportFailure(0x3108, false, NULL, 0, L"GlobalAlloc failed.  GetLastError(%I64u) = %u", cb, GetLastError());
	}

	else
	{
		IStream *pis = (IStream *) (intptr_t) -1;

		hr = CreateStreamOnHGlobal(hStream, TRUE, &pis);

		if (FAILED(hr))
		{
			ReportFailure(0x3109, false, NULL, 0, L"CreateStreamOnHGlobal failed.  hr = %08X", hr);

			GlobalFree(hStream);
		}

		else
		{
			ULARGE_INTEGER uli0;

			uli0.QuadPart = 0;

			hr = pis->SetSize(uli0);

			if (FAILED(hr))
			{
				ReportFailure(0x310A, false, pis, 6, L"IStream::SetSize(0) failed.  hr = %08X", hr);
			}

			hr = pipsi->Save(pis, FALSE);

			if (FAILED(hr))
			{
				if (hr != E_NOTIMPL)
				{
					ReportFailure(0x310B, false, pipsi, 6, L"IPersistStreamInit::Save failed.  hr = %08X", hr);
				}
			}

			else
			{
				LARGE_INTEGER li0;

				li0.QuadPart = 0;

				unsigned __int64 ibNew;

				hr = pis->Seek(li0, STREAM_SEEK_SET, (ULARGE_INTEGER *) &ibNew);

				if (FAILED(hr))
				{
					ReportFailure(0x310C, false, pis, 5, L"IStream::Seek(0, STREAM_SEEK_SET) failed.  hr = %08X", hr);
				}

				else
				{
					hr = pipsi->Load(pis);

					if (FAILED(hr))
					{
						ReportFailure(0x310D, false, pipsi, 5, L"IPersistStreamInit::Load failed.  hr = %08X", hr);
					}
				}
			}

			// IPersistStream implementation may retain a reference

			pis->Release();
		}
	}

	if (fSiteSet)
	{
		rc = SetSite(punk, NULL);

		if (rc == 0)
		{
			if (cs.m_cref != 1)
			{
				ReportFailure(0x310E, false, NULL, 0, L"SetSite(NULL) did not restore ref count of IOleClientSite");
			}
		}
	}

	Release(pipsi, fClassObject);

	return(0);
}


int CheckIProvideClassInfo(IUnknown *punk, bool fClassObject)
{
	IProvideClassInfo *pipci;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IProvideClassInfo", IID_PPV_ARGS(&pipci));

	if (FAILED(hr))
	{
		return(0);
	}

	ITypeInfo *piti = (ITypeInfo *) (intptr_t) -1;

	hr = pipci->GetClassInfo(&piti);

	if (FAILED(hr))
	{
		ReportFailure(0x1A01, false, pipci, 3, L"IProvideClassInfo::GetClassInfo failed.  hr = %08X", hr);
	}

	else
	{
		dwNonClass++;

		// Don't check ref count.  ATL CComTypeInfoHolder may hold a reference

		int rc = TestAndReleaseInterface(piti, NULL, false, false, false);

		if (rc != 0)
		{
			return(rc);
		}
	}

	Release(pipci, fClassObject);

	return(0);
}


int CheckIProvideClassInfo2(IUnknown *punk, bool fClassObject)
{
	IProvideClassInfo2 *pipci2;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IProvideClassInfo2", IID_PPV_ARGS(&pipci2));

	if (FAILED(hr))
	{
		// Return -1 to differentiate between this and success

		return(-1);
	}

	IProvideClassInfo *pipci;

	hr = HrQueryInterface(punk, fClassObject, L"IProvideClassInfo", IID_PPV_ARGS(&pipci));

	if (SUCCEEDED(hr))
	{
		Release(pipci, fClassObject);
	}

	else
	{
		ReportFailure(0x1B01, false, punk, 0, L"IProvideClassInfo2 w/o IProvideClassInfo");
	}

	IConnectionPointContainer *picpc;

	hr = HrQueryInterface(punk, fClassObject, L"IConnectionPointContainer", IID_PPV_ARGS(&picpc));

	if (FAILED(hr))
	{
		ReportFailure(0x1B02, false, punk, 0, L"IProvideClassInfo2 w/o IConnectionPointContainer");
	}

	ITypeInfo *piti = (ITypeInfo *) (intptr_t) -1;

	hr = pipci2->GetClassInfo(&piti);

	if (FAILED(hr))
	{
		ReportFailure(0x1B03, false, pipci2, 3, L"IProvideClassInfo2::GetClassInfo failed.  hr = %08X", hr);
	}

	else
	{
		dwNonClass++;

		// Don't check ref count.  ATL CComTypeInfoHolder may hold a reference

		int rc = TestAndReleaseInterface(piti, NULL, false, false, false);

		if (rc != 0)
		{
			return(rc);
		}
	}

	IID iidT;

	memset(&iidT, -1, sizeof(&iidT));

	hr = pipci2->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, &iidT);

	if (FAILED(hr))
	{
		ReportFailure(0x1B04, false, pipci2, 4, L"IProvideClassInfo2::GetGUID failed.  hr = %08X", hr);
	}

	else if (picpc != NULL)
	{
		IConnectionPoint *picp = (IConnectionPoint *) (intptr_t) -1;

		hr = picpc->FindConnectionPoint(iidT, &picp);

		if (FAILED(hr))
		{
			ReportFailure(0x1B05, false, pipci2, 4, L"IConnectionPointContainer::FindConnectionPoint of IProvideClassInfo2::GetGUID failed.  hr = %08X", hr);
		}

		else
		{
			dwNonClass++;

			// Don't test this interface here.  We do in CheckIConnectionPointContainer

			Release(picp, false);
		}
	}

	if (picpc != NULL)
	{
		Release(picpc, fClassObject);
	}

	Release(pipci2, fClassObject);

	return(0);
}


int CheckIProvideMultipleClassInfo(IUnknown *punk, bool fClassObject)
{
	IProvideMultipleClassInfo *pipmci;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IProvideMultipleClassInfo", IID_PPV_ARGS(&pipmci));

	if (FAILED(hr))
	{
		// Return -1 to differentiate between this and success

		return(-1);
	}

	IProvideClassInfo2 *pipci2;

	hr = HrQueryInterface(punk, fClassObject, L"IProvideClassInfo2", IID_PPV_ARGS(&pipci2));

	if (SUCCEEDED(hr))
	{
		Release(pipci2, fClassObject);
	}

	else
	{
		ReportFailure(0x1C01, false, punk, 0, L"IProvideMultipleClassInfo w/o IProvideClassInfo2");
	}

	IProvideClassInfo *pipci;

	hr = HrQueryInterface(punk, fClassObject, L"IProvideClassInfo", IID_PPV_ARGS(&pipci));

	if (SUCCEEDED(hr))
	{
		Release(pipci, fClassObject);
	}

	else
	{
		ReportFailure(0x1C02, false, punk, 0, L"IProvideMultipleClassInfo w/o IProvideClassInfo");
	}

	IConnectionPointContainer *picpc;

	hr = HrQueryInterface(punk, fClassObject, L"IConnectionPointContainer", IID_PPV_ARGS(&picpc));

	if (FAILED(hr))
	{
		// Don't report failure yet.  GetMultiTypeInfo can be used without this
	}

	ITypeInfo *piti = (ITypeInfo *) (intptr_t) -1;

	hr = pipmci->GetClassInfo(&piti);

	if (FAILED(hr))
	{
		ReportFailure(0x1C03, false, pipmci, 3, L"IProvideMultipleClassInfo::GetClassInfo failed.  hr = %08X", hr);
	}

	else
	{
		dwNonClass++;

		// Don't check ref count.  ATL CComTypeInfoHolder may hold a reference

		int rc = TestAndReleaseInterface(piti, NULL, false, false, false);

		if (rc != 0)
		{
			return(rc);
		}
	}

	IID iidT;

	memset(&iidT, -1, sizeof(&iidT));

	hr = pipmci->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, &iidT);

	if (FAILED(hr))
	{
		ReportFailure(0x1C04, false, pipmci, 4, L"IProvideMultipleClassInfo::GetGUID failed.  hr = %08X", hr);
	}

	else if (picpc == NULL)
	{
		ReportFailure(0x1C05, false, punk, 0, L"IProvideMultipleClassInfo::GetGUID w/o IConnectionPointContainer");
	}

	else
	{
		IConnectionPoint *picp = (IConnectionPoint *) (intptr_t) -1;

		hr = picpc->FindConnectionPoint(iidT, &picp);

		if (FAILED(hr))
		{
			ReportFailure(0x1C06, false, pipmci, 4, L"IConnectionPointContainer::FindConnectionPoint of IProvideMultipleClassInfo::GetGUID failed.  hr = %08X", hr);
		}

		else
		{
			dwNonClass++;

			// Don't test this interface here.  We do in CheckIConnectionPointContainer

			Release(picp, false);
		}
	}

	ULONG cti;

	hr = pipmci->GetMultiTypeInfoCount(&cti);

	if (FAILED(hr))
	{
		ReportFailure(0x1C07, false, pipmci, 5, L"IProvideMultipleClassInfo::GetMultiTypeInfoCount failed.  hr = %08X", hr);

		cti = 0;
	}

	for (ULONG iti = 0; iti < cti; iti++)
	{
		piti = (ITypeInfo *) (intptr_t) -1;

		DWORD dwTIFlags = (DWORD) -1;
		ULONG cdispidReserved = (ULONG) -1;
		IID iidPrimary;
		IID iidSource;

		memset(&iidPrimary, -1, sizeof(&iidPrimary));
		memset(&iidSource, -1, sizeof(&iidSource));

		hr = pipmci->GetInfoOfIndex(iti,
			MULTICLASSINFO_GETTYPEINFO |
			MULTICLASSINFO_GETNUMRESERVEDDISPIDS |
			MULTICLASSINFO_GETIIDPRIMARY |
			MULTICLASSINFO_GETIIDSOURCE,
			&piti,
			&dwTIFlags,
			&cdispidReserved,
			&iidPrimary,
			&iidSource);

		if (FAILED(hr))
		{
			ReportFailure(0x1C08, false, pipmci, 6, L"IProvideMultipleClassInfo::GetInfoOfIndex(%u) failed.  hr = %08X", iti, hr);
		}

		else
		{
			dwNonClass++;

			// Don't check ref count.  ATL CComTypeInfoHolder may hold a reference

			int rc = TestAndReleaseInterface(piti, NULL, false, false, false);

			if (rc != 0)
			{
				return(rc);
			}
		}

		// UNDONE: Check dwTiFlags, cdispidReserved

		if (iidPrimary != IID_NULL)
		{
			IUnknown *punkPrimary;

			HRESULT hr = HrQueryInterface(punk, fClassObject, L"IProvideMultipleClassInfo::GetInfoOfIndex iidPrimary", iidPrimary, (void **) &punkPrimary);

			if (FAILED(hr))
			{
				ReportFailure(0x1C09, false, pipmci, 6, L"QueryInterface of IProvideMultipleClassInfo::GetInfoOfIndex iidPrimary failed.  hr = %08X", hr);
			}

			else
			{
				int rc = TestAndReleaseInterface(punkPrimary, NULL, false, fClassObject, false);

				if (rc != 0)
				{
					return(rc);
				}
			}
		}

		if (iidSource != IID_NULL)
		{
			if (picpc == NULL)
			{
				ReportFailure(0x1C0A, false, punk, 0, L"IProvideMultipleClassInfo::GetInfoOfIndex iidSource w/o IConnectionPointContainer");
			}

			else
			{
				IConnectionPoint *picp = (IConnectionPoint *) (intptr_t) -1;

				hr = picpc->FindConnectionPoint(iidT, &picp);

				if (FAILED(hr))
				{
					ReportFailure(0x1C0B, false, pipmci, 4, L"IConnectionPointContainer::FindConnectionPoint of IProvideMultipleClassInfo::GetInfoOfIndex iidSource failed.  hr = %08X", hr);
				}

				else
				{
					dwNonClass++;

					// Don't test this interface here.  We do in CheckIConnectionPointContainer

					Release(picp, false);
				}
			}
		}
	}

	if (picpc != NULL)
	{
		Release(picpc, fClassObject);
	}

	Release(pipmci, fClassObject);

	return(0);
}


int CheckISpecifyPropertyPages(IUnknown *punk, bool fClassObject)
{
	ISpecifyPropertyPages *pispp;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"ISpecifyPropertyPages", IID_PPV_ARGS(&pispp));

	if (FAILED(hr))
	{
		return(0);
	}

	CAUUID cauuid;

	hr = pispp->GetPages(&cauuid);

	if (FAILED(hr))
	{
		ReportFailure(0x1D01, false, pispp, 3, L"ISpecifyPropertyPages::GetPages failed.  hr = %08X", hr);
	}

	else
	{
		if (cauuid.cElems == 0)
		{
			ReportFailure(0x1D02, false, pispp, 3, L"ISpecifyPropertyPages::GetPages returned cElems == 0");
		}

		for (ULONG ielem = 0; ielem < cauuid.cElems; ielem++)
		{
			CLSID clsidPage = cauuid.pElems[ielem];

			IUnknown *punkPage = (IUnknown *) (intptr_t) -1;

			HRESULT hr = CoGetClassObject(clsidPage,
				CLSCTX_INPROC_SERVER,
				NULL,
				IID_PPV_ARGS(&punkPage));

			if (FAILED(hr))
			{
				wchar_t szClsidPage[39];

				if (StringFromGUID2(clsidPage, szClsidPage, _countof(szClsidPage)) == 0)
				{
					szClsidPage[0] = L'\0';
				}

				if (hr == REGDB_E_CLASSNOTREG)
				{
					ReportFailure(0x1D03, false, pispp, 3, L"ISpecifyPropertyPages::GetPages CLSID[%u] %s not registered", ielem, szClsidPage);
				}

				else
				{
					ReportFailure(0x1D04, false, pispp, 3, L"CoGetClassObject(%s) from ISpecifyPropertyPages::GetPages failed.  hr = %08X", szClsidPage, hr);
				}
			}

			else
			{
				// We reset the unhandled exception filter because the CRT screws with it

				SetMyUnhandledExceptionFilter(true);

				punkPage->Release();
			}
		}

		CoTaskMemFree(cauuid.pElems);
	}

	Release(pispp, fClassObject);

	return(0);
}


int TestInnerInterface(COuter *pouter, const void *pv, int ifn, const wchar_t *szMethod, IUnknown *punk, ULONG crefExpected)
{
	if (punk == pouter)
	{
		ReportFailure(0x1E01, false, pv, ifn, L"%s(%s) returned punkOuter", szMethod, szClsid);

		return(0x1E01);
	}

	if (pouter->m_cref != crefExpected)
	{
		ReportFailure(0x1E02, false, pv, ifn, L"%s(%s) changed ref count of punkOuter (%u)", szMethod, szClsid, pouter->m_cref);
	}

	// Check that AddRef and Release do not delegate to outer object

	ULONG crefSave = pouter->m_cref;

	punk->AddRef();

	dwNonClass++;

	if (pouter->m_cref != crefSave)
	{
		ReportFailure(0x1E03, false, punk, 1, L"AddRef changed ref count of punkOuter (%u -> %u)", crefSave, pouter->m_cref);
	}

	crefSave = pouter->m_cref;

	Release(punk, false);

	if (pouter->m_cref != crefSave)
	{
		ReportFailure(0x1E04, false, punk, 2, L"Release changed ref count of punkOuter (%u -> %u)", crefSave, pouter->m_cref);
	}

	// Check that QI(IUnknown) does not delegate to outer object

	crefSave = pouter->m_cref;

	IUnknown *punk2;

	HRESULT hr = HrQueryInterface(punk, false, L"IUnknown", IID_PPV_ARGS(&punk2));

	if (FAILED(hr))
	{
		ReportFailure(0x1E05, false, punk, 0, L"QueryInterface(IUnknown) failed.  hr = %08X", hr);

		return(0x1E05);
	}

	if (pouter->m_cref != crefSave)
	{
		ReportFailure(0x1E06, false, punk, 0, L"QueryInterface(IUnknown) changed ref count of punkOuter (%u -> %u)", crefSave, pouter->m_cref);
	}

	if (punk != punk2)
	{
		ReportFailure(0x1E07, false, punk, 0, L"QueryInterface(IUnknown) does not match original IUnknown");

		return(0x1E07);
	}

	crefSave = pouter->m_cref;

	IUnknown *punk3;

	hr = HrQueryInterface(punk2, false, L"IUnknown", IID_PPV_ARGS(&punk3));

	if (FAILED(hr))
	{
		ReportFailure(0x1E08, false, punk2, 0, L"QueryInterface(IUnknown) failed.  hr = %08X", hr);

		return(0x1808);
	}

	if (pouter->m_cref != crefSave)
	{
		ReportFailure(0x1E09, false, punk2, 0, L"QueryInterface(IUnknown) changed ref count of punkOuter (%u -> %u)", crefSave, pouter->m_cref);
	}

	if (punk2 != punk3)
	{
		ReportFailure(0x1E0A, false, punk2, 0, L"QueryInterface(IUnknown) does not match original IUnknown");

		return(0x1E0A);
	}

	crefSave = pouter->m_cref;

	Release(punk3, false);

	if (pouter->m_cref != crefSave)
	{
		ReportFailure(0x1E0B, false, punk3, 2, L"Release changed ref count of punkOuter (%u -> %u)", crefSave, pouter->m_cref);
	}

	crefSave = pouter->m_cref;

	Release(punk2, false);

	if (pouter->m_cref != crefSave)
	{
		ReportFailure(0x1E0C, false, punk2, 2, L"Release changed ref count of punkOuter (%u -> %u)", crefSave, pouter->m_cref);
	}

	return(0);
}


int TestInterface(IUnknown *punk, const CLSID *pclsid, bool fIsIUnknown, bool fClassObject)
{
	FreeUnusedLibraries();

	if (punk == NULL)
	{
		return(0);
	}

	IUnknown *punk2;

	HRESULT hr = HrQueryInterface(punk, fClassObject, L"IUnknown", IID_PPV_ARGS(&punk2));

	if (FAILED(hr))
	{
		ReportFailure(0x1F01, false, punk, 0, L"QueryInterface(IUnknown) failed.  hr = %08X", hr);

		return(0x0101);
	}

	if (fIsIUnknown && (punk != punk2))
	{
		ReportFailure(0x1F02, false, punk, 0, L"QueryInterface(IUnknown) does not match original IUnknown");
	}

	if (!Interface::FPush(punk2, fClassObject))
	{
		Release(punk2, fClassObject);

		return(0);
	}

	ULONG cref1 = punk->AddRef();

	IncrementObjectCount(fClassObject);

	ULONG cref2 = punk->AddRef();

	IncrementObjectCount(fClassObject);

	if (cref2 != (cref1 + 1))
	{
		// If this is a proxy with a CLSID from the following list it is implemented
		// by a singleton in OLEAUT32.DLL.  Don't warn if we know this to be the case

		//    CLSID_PSDispatch
		//    CLSID_PSTypeInfo
		//    CLSID_PSTypeLib
		//    CLSID_PSTypeComp
		//    CLSID_PSAutomation
		//    CLSID_PSEnumVARIANT
		//    CLSID_PSSupportErrorInfo

		ReportFailure(0x1F03, false, punk, 1, L"AddRef doesn't increment reference count by one (%u -> %u)", cref1, cref2);
	}

	Release(punk, fClassObject);
	Release(punk, fClassObject);

	IUnknown *punk3;

	hr = HrQueryInterface(punk2, fClassObject, L"IUnknown", IID_PPV_ARGS(&punk3));

	if (FAILED(hr))
	{
		ReportFailure(0x1F04, false, punk2, 0, L"QueryInterface(IUnknown) failed.  hr = %08X", hr);

		return(0x1F04);
	}

	if (punk2 != punk3)
	{
		ReportFailure(0x1F05, false, punk2, 0, L"QueryInterface(IUnknown) does not match original IUnknown");

		return(0x1F05);
	}

	Release(punk3, fClassObject);

	IUnknown *punkUndefined;

	hr = HrQueryInterface(punk, fClassObject, L"iidUndefined", iidUndefined, (void **) &punkUndefined);

	if (SUCCEEDED(hr))
	{
		ReportFailure(0x1F06, false, punk, 0, L"QueryInterface(iidUndefined) succeeded");
	}

	if (fTryQI)
	{
		if (fAllIids)
		{
			QueryInterfaceAllIids(punk, fClassObject);
		}

		if (fIidsFromFile)
		{
			QueryInterfaceIidsFromFile(punk, fClassObject, szIid + 1);
		}
	}

	int rc;

	if (!fCreateOnly && !fCheckSafety)
	{
		if (fObjrefMoniker)
		{
			rc = CheckObjrefMoniker(punk, fClassObject);

			SetMyUnhandledExceptionFilter(true);

			if (rc != 0)
			{
				return(rc);
			}
		}

		rc = CheckIConnectionPointContainer(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIDispatchEx(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc == -1)
		{
			rc = CheckIDispatch(punk, fClassObject);
		}

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIEnumConnectionPoints(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIEnumConnections(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIEnumMoniker(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIEnumUnknown(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIEnumVARIANT(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIMoniker(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	if (!fCreateOnly)
	{
		rc = CheckIObjectSafety(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	if (!fCreateOnly && !fCheckSafety)
	{
		rc = CheckIOleCommandTarget(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIOleControl(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIPersist(pclsid, punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIPersistHistory(pclsid, punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIPersistPropertyBag(pclsid, punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIPersistStream(pclsid, punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIPersistStreamInit(pclsid, punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckIProvideMultipleClassInfo(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc == -1)
		{
			rc = CheckIProvideClassInfo2(punk, fClassObject);
		}

		SetMyUnhandledExceptionFilter(true);

		if (rc == -1)
		{
			rc = CheckIProvideClassInfo(punk, fClassObject);
		}

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}

		rc = CheckISpecifyPropertyPages(punk, fClassObject);

		SetMyUnhandledExceptionFilter(true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	Interface::PopAndRelease();

	return(0);
}


int TestAndReleaseInterface(IUnknown *punk, const CLSID *pclsid, bool fIsIUnknown, bool fClassObject, bool fCheckRefCount)
{
	int rc = TestInterface(punk, pclsid, fIsIUnknown, fClassObject);

	if (punk != NULL)
	{
		// Capture address of Release() method since after release the memory may be gone

		const void *pvRelease = PvMethod(punk, 2);

		ULONG cref = Release(punk, fClassObject);

		if ((cref != 0) && fCheckRefCount)
		{
			ReportFailure(0x2001, false, pvRelease, -1, L"IUnknown::Release returned %u", cref);
		}
	}

	return(rc);
}

int CheckErrorInfo()
{
	IErrorInfo *piei = (IErrorInfo *) (intptr_t) -1;

	HRESULT hr = GetErrorInfo(0, &piei);

	if (FAILED(hr))
	{
		// UNDONE: Better error.	This should not fail.

		return(0xFFFF);
	}

	if (hr == S_FALSE)
	{
		return(0);
	}

	if (piei == NULL)
	{
		// UNDONE: Better error.	This should never be NULL.

		return(0xFFFF);
	}

	dwNonClass++;

	return(TestAndReleaseInterface(piei, NULL, false, false, true));
}

void PumpMessages()
{
	MSG msg;

	while (PeekMessage(&msg, NULL,  0, 0, PM_REMOVE))
	{
		TranslateMessage(&msg);

		// wprintf(L"** Dispatching message %X\n", msg.message);

		DispatchMessage(&msg);
	}
}

int AddObjectToDocument(IHTMLDocument2 *pihd2, IHTMLElement *piheObject)
{
	PumpMessages();		       // Pump in case MSHTML has something queued

	// Get the BODY element so that we can insert an OBJECT element as a child

	IHTMLElement *piheBody = (IHTMLElement *) (intptr_t) -1;

	HRESULT hr = pihd2->get_body(&piheBody);

	if (FAILED(hr))
	{
		ReportFailure(0x2101, false, NULL, 0, L"IHTMLDocument2::get_body failed.  hr = %08X", hr);

		return(0x2101);
	}

	if (piheBody == NULL)
	{
		ReportFailure(0x2102, false, NULL, 0, L"IHTMLDocument2::get_body returned NULL");

		return(0x2102);
	}

	dwNonClass++;

	int rc = CheckErrorInfo();

	if (rc != 0)
	{
		return(rc);
	}

	IHTMLDOMNode *pihdnBody;

	hr = HrQueryInterface(piheBody, false, L"IHTMLDOMNode", IID_PPV_ARGS(&pihdnBody));

	if (FAILED(hr))
	{
		ReportFailure(0x2103, false, piheBody, 0, L"IHTMLElement::QueryInterface(IHTMLDOMNode) failed.  hr = %08X", hr);

		return(0x2103);
	}

	Release(piheBody, false);

	IHTMLDOMNode *pihdnObject;

	hr = HrQueryInterface(piheObject, false, L"IHTMLDOMNode", IID_PPV_ARGS(&pihdnObject));

	if (FAILED(hr))
	{
		ReportFailure(0x2104, false, piheObject, 0, L"IHTMLElement::QueryInterface(IHTMLDOMNode) failed.  hr = %08X", hr);

		return(0x2104);
	}

	// Append new OBJECT element as child of BODY element

	IHTMLDOMNode *pihdnObject2 = (IHTMLDOMNode *) (intptr_t) -1;

	hr = pihdnBody->appendChild(pihdnObject, &pihdnObject2);

	if (FAILED(hr))
	{
		ReportFailure(0x2105, false, pihdnBody, 19, L"IHTMLDOMNode::appendChild failed.  hr = %08X", hr);

		return(0x2105);
	}

	if (pihdnObject2 == NULL)
	{
		ReportFailure(0x2106, false, pihdnBody, 19, L"IHTMLDOMNode::appendChild returned NULL");

		return(0x2106);
	}

	dwNonClass++;

	Release(pihdnObject, false);

	Release(pihdnObject2, false);

	Release(pihdnBody, false);

	PumpMessages();		       // Pump in case MSHTML has something queued


	return(0);
}


int CreateObjectInDocument(IHTMLDocument2 *pihd2, const wchar_t *szClassid, const CLSID *pclsid)
{
	for (unsigned i = 0; i < 10; i++)
	{
		PumpMessages();		       // Pump in case MSHTML has something queued

		BSTR bstrReadyState = NULL;

		HRESULT hr = pihd2->get_readyState(&bstrReadyState);

		if (FAILED(hr))
		{
			ReportFailure(0x2201, false, pihd2, 22, L"IHTMLDocument2::get_readyState failed.  hr = %08X", hr);
		}

		else if (bstrReadyState == NULL)
		{
			ReportFailure(0x2202, false, pihd2, 22, L"IHTMLDocument2::get_readyState returned NULL");
		}

		else
		{
			bool fComplete = _wcsicmp(bstrReadyState, L"complete") == 0;

#if 0
		if (!fComplete && (i == 9))
		{
			ReportFailure(0x220F, false, pihd2, 22, L"IHTMLDocument2::get_readyState returned \"%s\"", bstrReadyState);
		}
#endif

			SysFreeString(bstrReadyState);

			if (fComplete)
			{
				break;
			}
		}

		Sleep(100);
	}

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	int rc = CheckErrorInfo();

	if (rc != 0)
	{
		return(rc);
	}

	// Create an OBJECT element

	BSTR bstrObject = SysAllocString(L"object");

	if (bstrObject == NULL)
	{
		ReportFailure(0x2203, false, NULL, 0, L"SysAllocString(\"object\") failed");

		return(0x2203);
	}

	IHTMLElement *piheObject = (IHTMLElement *) (intptr_t) -1;

	HRESULT hr = pihd2->createElement(bstrObject, &piheObject);

	if (FAILED(hr))
	{
		ReportFailure(0x2204, false, pihd2, 72, L"IHTMLDocument2::createElement failed.  hr = %08X", hr);

		return(0x2204);
	}

	if (piheObject == NULL)
	{
		ReportFailure(0x2205, false, pihd2, 72, L"IHTMLDocument2::createElement returned NULL");

		return(0x2205);
	}

	dwNonClass++;

	rc = CheckErrorInfo();

	if (rc != 0)
	{
		return(rc);
	}

	SysFreeString(bstrObject);

	if (atd == atdBefore)
	{
		int rc = AddObjectToDocument(pihd2, piheObject);

		if (rc != 0)
		{
			return(rc);
		}
		rc = CheckErrorInfo();

		if (rc != 0)
		{
			return(rc);
		}
	}

	// At this point we have the IHTMLDocument2 *pihd2 and IHTMLElement *piheObject

	IHTMLObjectElement2 *pihoe2Object;

	hr = HrQueryInterface(piheObject, false, L"IHTMLObjectElement2", IID_PPV_ARGS(&pihoe2Object));

	if (FAILED(hr))
	{
		ReportFailure(0x2206, false, piheObject, 0, L"IHTMLElement::QueryInterface(IHTMLObjectElement2) failed.  hr = %08X", hr);

		return(0x2206);
	}

	if (szData != NULL)
	{
		// UNDONE: Use FormatMessage to compose data URL

		BSTR bstrData = SysAllocString(szData);

		if (bstrData == NULL)
		{
			ReportFailure(0x2207, false, NULL, 0, L"SysAllocString(\"%s\") failed", szData);
		}

		else
		{
			hr = pihoe2Object->put_data(bstrData);

			if (FAILED(hr))
			{
				ReportFailure(0x2208, false, pihoe2Object, 10, L"IHTMLObjectElement2::put_data failed.  hr = %08X", hr);
			}

			rc = CheckErrorInfo();

			if (rc != 0)
			{
				return(rc);
			}

			SysFreeString(bstrData);
		}
	}

	if (szClassid != NULL)
	{
		// UNDONE: Use FormatMessage to compose classid moniker

		BSTR bstrClassid = SysAllocString(szClassid);

		if (bstrClassid == NULL)
		{
			ReportFailure(0x2209, false, NULL, 0, L"SysAllocString(\"%s\") failed", szClassid);
		}

		else
		{
			hr = pihoe2Object->put_classid(bstrClassid);

			// Don't report access denied.  It's good when that happens.

			if (FAILED(hr) && (hr != E_ACCESSDENIED))
			{
				ReportFailure(0x220A, false, pihoe2Object, 8, L"IHTMLObjectElement2::put_classid failed.  hr = %08X", hr);
			}

			rc = CheckErrorInfo();

			if (rc != 0)
			{
				return(rc);
			}

			SysFreeString(bstrClassid);
		}
	}

	Release(pihoe2Object, false);

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	PumpMessages();		       // Pump in case MSHTML has something queued

	// Wait for the OBJECT element to be ready

	IHTMLObjectElement *pihoeObject;

	hr = HrQueryInterface(piheObject, false, L"IHTMLObjectElement", IID_PPV_ARGS(&pihoeObject));

	if (FAILED(hr))
	{
		ReportFailure(0x220B, false, piheObject, 0, L"IHTMLElement::QueryInterface(IHTMLObjectElement) failed.  hr = %08X", hr);
	}

	else
	{
		for (unsigned i = 0; i < 10; i++)
		{
			long lReadyState;

			hr = pihoeObject->get_readyState(&lReadyState);

			if (FAILED(hr))
			{
				ReportFailure(0x220C, false, pihoeObject, 30, L"IHTMLObjectElement::get_readyState failed.  hr = %08X", hr);
			}

			else if (lReadyState == READYSTATE_COMPLETE)
			{
				break;
			}

			if (i == 9)
			{
				ReportFailure(0x2210, false, pihoeObject, 30, L"IHTMLObjectElement::get_readyState returned %d", lReadyState);
			}

			Sleep(100);

			PumpMessages();	       // Pump in case MSHTML has something queued
		}

		// We reset the unhandled exception filter because the CRT screws with it

		SetMyUnhandledExceptionFilter(true);
	}

	rc = CheckErrorInfo();

	if (rc != 0)
	{
		return(rc);
	}

	if (atd == atdAfter)
	{
		int rc = AddObjectToDocument(pihd2, piheObject);

		if (rc != 0)
		{
			return(rc);
		}
	}

	PumpMessages();		       // Pump in case MSHTML has something queued


	// If we can get to the COM class while hosted with HTML do so

	if (pihoeObject != NULL)
	{
		IDispatch *pid = (IDispatch *) (intptr_t) -1;

		hr = pihoeObject->get_object(&pid);

		if (FAILED(hr))
		{
			if (hr != E_ACCESSDENIED)
			{
				ReportFailure(0x220D, false, pihoeObject, 7, L"IHTMLObjectElement::get_object failed.  hr = %08X", hr);

#if 0
				int rc = CheckIDispatchEx(pihoeObject, false);

				if (rc == -1)
				{
					rc = CheckIDispatch(pihoeObject, false);
				}

				if (rc != 0)
				{
					return(rc);
				}
#elif 0
				int rc = TestInterface(pihoeObject, pclsid, false, false);

				if (rc != 0)
				{
					return(rc);
				}
#endif
			}
		}

		else if (pid == NULL)
		{
#if 0
			ReportFailure(0x220E, false, pihoeObject, 7, L"IHTMLObjectElement::get_object returned NULL");
#endif
		}

		else
		{
			dwNonClass++;

			rc = CheckErrorInfo();

			if (rc != 0)
			{
				return(rc);
			}

			rc = TestAndReleaseInterface(pid, pclsid, false, false, false);

			if (rc != 0)
			{
				return(rc);
			}
		}

		Release(pihoeObject, false);
	}

	Release(piheObject, false);

	return(0);
}


int DoHTML(const wchar_t *szClassid, const CLSID *pclsid)
{
	// UNDONE: Use FormatMessage to compose URL

	const wchar_t *szUrlToLoad = (szUrl != NULL) ? szUrl : L"about:blank";

	IHTMLDocument2 *pihd2;

	HRESULT hr = CoCreateInstance(CLSID_HTMLDocument, NULL, dwClsctx, IID_PPV_ARGS(&pihd2));

	if (FAILED(hr))
	{
		ReportFailure(0x2301, false, NULL, 0, L"CoCreateInstance(CLSID_HTMLDocument) failed.  hr = %08X", hr);

		return(0x2301);
	}

	dwNonClass++;

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	CSite cs;

	int rc = SetSiteAlways(pihd2, &cs);

	bool fSiteSet = (rc == 0);

	IPersistMoniker *pipm;

	hr = HrQueryInterface(pihd2, false, L"IPersistMoniker", IID_PPV_ARGS(&pipm));

	if (FAILED(hr))
	{
		ReportFailure(0x2302, false, pihd2, 0, L"IHTMLDocument2::QueryInterface(IPersistMoniker) failed.  hr = %08X", hr);

		return(0x2302);
	}

	IMoniker *pmk;

	hr = CreateURLMonikerEx(NULL, szUrlToLoad, &pmk, URL_MK_UNIFORM);

	if (FAILED(hr))
	{
		ReportFailure(0x2303, false, NULL, 0, L"CreateURLMonikerEx failed.  hr = %08X", hr);

		return(0x2303);
	}

	dwNonClass++;

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	hr = pipm->Load(TRUE, pmk, NULL, STGM_READ);

	if (FAILED(hr))
	{
		ReportFailure(0x2304, false, pipm, 5, L"IPersistMoniker::Load failed.  hr = %08X", hr);

		return(0x2304);
	}

	Release(pipm, false);

	Release(pmk, false);

	// There should be a WM_METHODCALL message queued up.  Pump messages or else the
	// load will not complete.  With -mta the COM infrastructure will pump.

	rc = CreateObjectInDocument(pihd2, szClassid, pclsid);

	if (rc != 0)
	{
		return(rc);
	}

	PumpMessages();

	if (fSiteSet)
	{
		rc = SetSiteAlways(pihd2, NULL);
	}

	Release(pihd2, false);

	return(0);
}


int DoHTMLWebBrowser(const wchar_t *szClassid, const CLSID *pclsid)
{
	// UNDONE: Use FormatMessage to compose URL

	const wchar_t *szUrlToLoad = (szUrl != NULL) ? szUrl : L"about:blank";

	IWebBrowser2 *piwb2;

	HRESULT hr = CoCreateInstance(CLSID_WebBrowser, NULL, dwClsctx, IID_PPV_ARGS(&piwb2));

	if (FAILED(hr))
	{
		ReportFailure(0x2501, false, NULL, 0, L"CoCreateInstance(CLSID_WebBrowser) failed.  hr = %08X", hr);

		return(0x2501);
	}

	dwNonClass++;

	// We reset the unhandled exception filter because the CRT screws with it

	SetMyUnhandledExceptionFilter(true);

	CSite cs;

	int rc = SetSiteAlways(piwb2, &cs);

	bool fSiteSet = (rc == 0);

	BSTR bstrUrl = SysAllocString(szUrlToLoad);

	if (bstrUrl == NULL)
	{
		ReportFailure(0x2502, false, NULL, 0, L"SysAllocString(\"%s\") failed", szUrlToLoad);
	}

	else
	{
		VARIANT varFlags;
		VARIANT varTargetFrameName;
		VARIANT varPostData;
		VARIANT varHeaders;

		MyVariantInit(&varFlags);
		MyVariantInit(&varTargetFrameName);
		MyVariantInit(&varPostData);
		MyVariantInit(&varHeaders);

		hr = piwb2->Navigate(bstrUrl, &varFlags, &varTargetFrameName, &varPostData, &varHeaders);

		// We reset the unhandled exception filter because the CRT screws with it

		SetMyUnhandledExceptionFilter(true);

		if (FAILED(hr))
		{
			ReportFailure(0x2503, false, piwb2, 11, L"IWebBrowser2::Navigate failed.  hr = %08X", hr);
		}

		else
		{
			for (unsigned i = 0; i < 10; i++)
			{
				PumpMessages();	       // Pump in case SHDOCVW or MSHTML has something queued

				READYSTATE readystate;

				hr = piwb2->get_ReadyState(&readystate);

				if (FAILED(hr))
				{
					ReportFailure(0x2507, false, piwb2, 56, L"IWebBrowser2::get_ReadyState failed.  hr = %08X", hr);
				}

				else if (readystate >= READYSTATE_INTERACTIVE)
				{
					break;
				}

				if (i == 9)
				{
					ReportFailure(0x2508, false, piwb2, 56, L"IWebBrowser2::get_ReadyState returned %d", readystate);
				}

				Sleep(100);
			}

			IDispatch *pidDocument = (IDispatch *) (intptr_t) -1;

			hr = piwb2->get_Document(&pidDocument);

			if (FAILED(hr))
			{
				ReportFailure(0x2504, false, piwb2, 18, L"IWebBrowser2::get_Document failed.  hr = %08X", hr);

				return(0x2504);
			}

			else if (hr == S_FALSE)
			{
				ReportFailure(0x2509, false, piwb2, 19, L"IWebBrowser2::get_Document returned S_FALSE");

				return(0x2509);
			}

			else if (pidDocument == NULL)
			{
				ReportFailure(0x2505, false, piwb2, 18, L"IWebBrowser2::get_Document returned NULL");

				return(0x2505);
			}

			else
			{
				dwNonClass++;

				IHTMLDocument2 *pihd2;

				hr = HrQueryInterface(pidDocument, false, L"IHTMLDocument2", IID_PPV_ARGS(&pihd2));

				Release(pidDocument, false);

				if (FAILED(hr))
				{
					ReportFailure(0x2506, false, piwb2, 0, L"IDispatch::QueryInterface(IHTMLDocument2) failed.  hr = %08X", hr);
				}

				else
				{
					rc = CreateObjectInDocument(pihd2, szClassid, pclsid);

					if (rc != 0)
					{
						return(rc);
					}

					Release(pihd2, false);
				}
			}
		}
	}

	if (fSiteSet)
	{
		rc = SetSiteAlways(piwb2, NULL);
	}

	Release(piwb2, false);

	return(0);
}


int DoMoniker(REFIID iid)
{
	DWORD_PTR rgarg[2] =
	{
		(DWORD_PTR) szClsid,
		(DWORD_PTR) szProgid,
	};

	wchar_t *sz;

	DWORD dw = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_STRING |
		FORMAT_MESSAGE_ARGUMENT_ARRAY,
		szMoniker,
		0,
		0,
		(LPWSTR) &sz,
		0,
		(va_list *) rgarg);

	if (dw == 0)
	{
		wprintf(L"FormatMessage failed.  GetLastError() = %u\n", GetLastError());
		return(1);
	}

	if (fHTML)
	{
		int iret = DoHTML(sz, NULL);

		LocalFree(sz);

		return(iret);
	}

	IBindCtx *pbc = NULL;

	HRESULT hr = CreateBindCtx(0, &pbc);

	if (FAILED(hr))
	{
		wprintf(L"CreateBindCtx failed.  hr = %08X\n", hr);
		return(1);
	}

	DWORD cchEaten;
	IMoniker *pmk = (IMoniker *) (intptr_t) -1;

	if (fUrlMoniker)
	{
		hr = MkParseDisplayNameEx(pbc, sz, &cchEaten, &pmk);

		if (FAILED(hr))
		{
			ReportFailure(0x2601, false, NULL, 0, L"MkParseDisplayNameEx(\"%s\") failed.  hr = %08X", sz, hr);

			pmk = NULL;

		}
	}

	else
	{
		hr = MkParseDisplayName(pbc, sz, &cchEaten, &pmk);

		if (FAILED(hr))
		{
			ReportFailure(0x2602, false, NULL, 0, L"MkParseDisplayName(\"%s\") failed.  hr = %08X", sz, hr);

			pmk = NULL;
		}
	}

	if (cchEaten != wcslen(sz))
	{
		ReportFailure(0x2603, false, NULL, 0, L"MkParseDisplayName[Ex](\"%s\") consumed only %u characters", sz, cchEaten);
	}

	LocalFree(sz);

	if (pmk != NULL)
	{
		dwNonClass++;

		int rc = TestAndReleaseInterface(pmk, NULL, false, false, true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	// Capture address of Release() method since after release the memory may be gone

	const void *pvRelease = PvMethod(pbc, 2);

	ULONG cref = pbc->Release();

	if (cref != 0)
	{
		ReportFailure(0x2604, false, pvRelease, -1, L"IBindCtx::Release returned %u", cref);
	}

	return(0);
}


int CheckIClassFactory(REFCLSID clsid, REFIID iid, IUnknown *punkClass)
{
	IClassFactory *pcf;

	HRESULT hr = HrQueryInterface(punkClass, true, L"IClassFactory", IID_PPV_ARGS(&pcf));

	if (FAILED(hr))
	{
		// Set this NULL so we can test for whether this worked later

		pcf = NULL;
	}

	else
	{
		hr = pcf->LockServer(TRUE);

		if (FAILED(hr))
		{
			ReportFailure(0x2701, false, pcf, 4, L"IClassFactory::LockServer(TRUE) failed.  hr = %08X", hr);
		}

		else
		{
			dwClassLocked++;
		}

		FreeUnusedLibraries();
	}

	IClassFactory2 *pcf2;

	hr = HrQueryInterface(punkClass, true, L"IClassFactory2", IID_PPV_ARGS(&pcf2));

	BSTR bstrKey = NULL;

	if (FAILED(hr))
	{
		// Set this NULL so we can test for whether this worked later

		pcf2 = NULL;
	}

	else
	{
		if (pcf == NULL)
		{
			ReportFailure(0x2702, false, punkClass, 0, L"Class factory supports IClassFactory2 but not IClassFactory");
		}

		hr = pcf2->LockServer(TRUE);

		if (FAILED(hr))
		{
			ReportFailure(0x2703, false, pcf2, 4, L"IClassFactory2::LockServer(TRUE) failed.  hr = %08X", hr);
		}

		else
		{
			dwClassLocked++;
		}

		FreeUnusedLibraries();

		LICINFO li;

		li.cbLicInfo = sizeof(li);
		li.fRuntimeKeyAvail = (BOOL) -1;
		li.fLicVerified = (BOOL) -1;

		hr = pcf2->GetLicInfo(&li);

		if (FAILED(hr))
		{
			ReportFailure(0x2704, false, pcf2, 5, L"IClassFactory2::GetLicInfo failed.  hr = %08X", hr);
		}

		else
		{
			if (li.cbLicInfo != sizeof(li))
			{
				ReportFailure(0x2705, false, pcf2, 5, L"IClassFactory2::LICINFO::cb = %u", li.cbLicInfo);
			}

			if ((li.fRuntimeKeyAvail != 0) && (li.fRuntimeKeyAvail != 1))
			{
				ReportFailure(0x2706, false, pcf2, 5, L"IClassFactory2::LICINFO::fRuntimeKeyAvail = %d", li.fRuntimeKeyAvail);
			}

			if ((li.fLicVerified != 0) && (li.fLicVerified != 1))
			{
				ReportFailure(0x2707, false, pcf2, 5, L"IClassFactory2::LICINFO::fLicVerified = %d", li.fLicVerified);
			}

			if (li.fRuntimeKeyAvail)
			{
				bstrKey = (BSTR) (intptr_t) -1;

				hr = pcf2->RequestLicKey(0, &bstrKey);

				if (FAILED(hr))
				{
					if (bstrKey != NULL)
					{
						ReportFailure(0x2708, false, pcf2, 6, L"IClassFactory2::RequestLicKey failure did not set *pbstrKey = NULL");

						bstrKey = NULL;
					}

					if (li.fRuntimeKeyAvail)
					{
						ReportFailure(0x2709, false, pcf2, 6, L"IClassFactory2::RequestLicKey failed.  hr = %08X", hr);
					}

					else if (hr != CLASS_E_NOTLICENSED)
					{
						ReportFailure(0x270A, false, pcf2, 6, L"IClassFactory2::RequestLicKey failure did not return CLASS_E_NOTLICENSED w/!fRuntimeKeyAvail.  hr = %08X", hr);
					}
				}
			}
		}
	}

	IClassFactory3 *pcf3;

	hr = HrQueryInterface(punkClass, true, L"IClassFactory3", IID_PPV_ARGS(&pcf3));

	if (FAILED(hr))
	{
		// Set this NULL so we can test for whether this worked later

		pcf3 = NULL;
	}

	else
	{
		if (pcf == NULL)
		{
			ReportFailure(0x270B, false, punkClass, 0, L"Class factory supports IClassFactory3 but not IClassFactory");
		}

		hr = pcf3->LockServer(TRUE);

		if (FAILED(hr))
		{
			ReportFailure(0x270C, false, pcf3, 4, L"IClassFactory3::LockServer(TRUE) failed.  hr = %08X", hr);
		}

		else
		{
			dwClassLocked++;
		}

		FreeUnusedLibraries();
	}

	if ((pcf == NULL) && (pcf2 == NULL) && (pcf3 == NULL))
	{
		// Return -1 to differentiate between this and success

		return(-1);
	}

	// Create an instance of this class

	const void *pv;
	int ifn;
	const wchar_t *szMethod;

	COuter *pouter = NULL;

	if (fAggregate)
	{
		pouter = new COuter;
	}

	IUnknown *punk = (IUnknown *) (intptr_t) -1;

	if (pcf3 != NULL)
	{
		pv = pcf3;
		ifn = 5;

		szMethod = L"IClassFactory3::CreateInstanceWithContext";

		// UNDONE: Provide meaningful context

		hr = pcf3->CreateInstanceWithContext(NULL,
			pouter,
			iid,
			(void **) &punk);
	}

	else if (pcf2 != NULL)
	{
		pv = pcf2;
		ifn = 7;

		szMethod = L"IClassFactory2::CreateInstanceLic";

		hr = pcf2->CreateInstanceLic(pouter,
			NULL,
			iid,
			bstrKey,
			(void **) &punk);
	}

	else
	{
		pv = pcf;
		ifn = 3;

		szMethod = L"IClassFactory::CreateInstance";

		hr = pcf->CreateInstance(pouter,
			iid,
			(void **) &punk);
	}

	if (FAILED(hr))
	{
		if (!fAggregate || (hr != CLASS_E_NOAGGREGATION))
		{
			ReportFailure(0x270D, false, pv, ifn, L"%s(%s) failed.  hr = %08X", szMethod, SzIidDisplay(), hr);
		}

		if (punk != NULL)
		{
			ReportFailure(0x270E, false, pv, ifn, L"%s(%s) failure did not set *ppvObject = NULL", szMethod, SzIidDisplay());

			punk = NULL;
		}
	}

	else if (punk == NULL)
	{
		ReportFailure(0x270F, false, pv, ifn, L"%s(%s) succeeded but *ppvObject == NULL", szMethod, SzIidDisplay());

		return(0x270F);
	}

	else
	{
		dwNonClass++;
	}

	if (pcf3 != NULL)
	{
		FreeUnusedLibraries();

		hr = pcf3->LockServer(FALSE);

		if (FAILED(hr))
		{
			ReportFailure(0x2710, false, pcf3, 4, L"IClassFactory3::LockServer(FALSE) failed.  hr = %08X", hr);
		}

		else
		{
			dwClassLocked--;
		}

		// Do not free unused libraries here because class factories do not need to
		// affect DllCanUnloadNow.

		Release(pcf3, true);
	}

	if (pcf2 != NULL)
	{
		FreeUnusedLibraries();

		hr = pcf2->LockServer(FALSE);

		if (FAILED(hr))
		{
			ReportFailure(0x2711, false, pcf2, 4, L"IClassFactory2::LockServer(FALSE) failed.  hr = %08X", hr);
		}

		else
		{
			dwClassLocked--;
		}

		// Do not free unused libraries here because class factories do not need to
		// affect DllCanUnloadNow.

		Release(pcf2, true);
	}

	if (pcf != NULL)
	{
		FreeUnusedLibraries();

		hr = pcf->LockServer(FALSE);

		if (FAILED(hr))
		{
			ReportFailure(0x2712, false, pcf, 4, L"IClassFactory::LockServer(FALSE) failed.  hr = %08X", hr);
		}

		else
		{
			dwClassLocked--;
		}

		// Do not free unused libraries here because class factories do not need to
		// affect DllCanUnloadNow.

		Release(pcf, true);
	}

	// The class object is no longer locked

	szQualifier = NULL;

	if (punk == NULL)
	{
		if (fAggregate)
		{
			pouter->Release();
		}

		return(0);
	}

	if (fAggregate)
	{
		pouter->m_punkInner = punk;

		int rc = TestInnerInterface(pouter, pv, ifn, szMethod, punk, 1);

		if (rc != 0)
		{
			return(rc);
		}
	}

	if (!FTestClass(punk, clsid))
	{
		// We don't want to test this class

		ReportFailure(0x2713, false, NULL, 0, L"Skipped");

		Release(fAggregate ? pouter : punk, false);

		return(0);
	}

	if (fCreateOnly || fSDL)
	{
		ReportFailure(0x2714, fCreateOnly || fSDL, pv, ifn, L"%s(%s) succeeded", szMethod, SzIidDisplay());
	}

	return(TestAndReleaseInterface(fAggregate ? pouter : punk, &clsid, fAggregate || IsEqualGUID(iid, IID_IUnknown), false, true));
}


int CheckIParseDisplayName(REFCLSID clsid, REFIID iid, IUnknown *punkClass)
{
	IParseDisplayName *ppdn;

	HRESULT hr = HrQueryInterface(punkClass, true, L"IParseDisplayName", IID_PPV_ARGS(&ppdn));

	if (FAILED(hr))
	{
		// Return -1 to differentiate between this and success

		return(-1);
	}

	IBindCtx *pbc = NULL;

	hr = CreateBindCtx(0, &pbc);

	if (FAILED(hr))
	{
		wprintf(L"CreateBindCtx failed.  hr = %08X", hr);
		return(1);
	}

	ULONG cchEaten;
	IMoniker *pmk = (IMoniker *) (intptr_t) -1;

	// UNDONE: Better moniker string

	hr = ppdn->ParseDisplayName(pbc, L"moniker:xyzzy", &cchEaten, &pmk);

	if (FAILED(hr))
	{
		ReportFailure(0x2801, false, ppdn, 3, L"IParseDisplayName::ParseDisplayName failed.  hr = %08X", hr);

		if (pmk != NULL)
		{
			ReportFailure(0x2802, false, ppdn, 3, L"IParseDisplayName::ParseDisplayName failure did not set *ppmk = NULL");
		}
	}

	else
	{
		dwNonClass++;

		if (fCreateOnly)
		{
			ReportFailure(0x2803, fCreateOnly, ppdn, 3, L"IParseDisplayName::ParseDisplayName succeeded.");
		}

		szQualifier = L" (Moniker)";

		int rc = TestAndReleaseInterface(pmk, NULL, false, false, true);

		if (rc != 0)
		{
			return(rc);
		}
	}

	// Capture address of Release() method since after release the memory may be gone

	const void *pvRelease = PvMethod(pbc, 2);

	ULONG cref = pbc->Release();

	if (cref != 0)
	{
		ReportFailure(0x2804, false, pvRelease, -1, L"IBindCtx::Release returned %u", cref);
	}

	Release(ppdn, true);

	return(0);
}


int CheckIPSFactoryBuffer(REFCLSID clsid, REFIID iid, IUnknown *punkClass)
{
	IPSFactoryBuffer *ppsfb;

	HRESULT hr = HrQueryInterface(punkClass, true, L"IPSFactoryBuffer", IID_PPV_ARGS(&ppsfb));

	if (FAILED(hr))
	{
		// Return -1 to differentiate between this and success

		return(-1);
	}

	COuter *pouter = NULL;

	if (fAggregate)
	{
		pouter = new COuter;
	}

	IRpcProxyBuffer *prpb = (IRpcProxyBuffer *) (intptr_t) -1;
	IUnknown *punk = (IUnknown *) (intptr_t) -1;

	hr = ppsfb->CreateProxy(pouter,
		iid,
		&prpb,
		(void **) &punk);

	if (FAILED(hr))
	{
		// Don't display an error if this is an unsupported interface and -useps not specified

		if ((hr != E_NOINTERFACE) || fUsePS)
		{
			ReportFailure(0x2901, false, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy failed.  hr = %08X", hr);
		}

		if (prpb != NULL)
		{
			ReportFailure(0x2902, false, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy failure did not set *ppProxy = NULL");
		}

		if (punk != NULL)
		{
			ReportFailure(0x2903, false, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy failure did not set *ppvObject = NULL");
		}
	}

	else
	{
		if (fCreateOnly)
		{
			ReportFailure(0x2904, fCreateOnly, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy succeeded.  CLSID = %s", szClsid);
		}

		if (prpb == NULL)
		{
			ReportFailure(0x2905, false, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy succeeded but *ppProxy == NULL");

			if (fAggregate)
			{
				pouter->Release();

				pouter = NULL;
			}
		}

		else
		{
			dwNonClass++;

			if (fAggregate)
			{
				pouter->m_punkInner = prpb;

				int rc = TestInnerInterface(pouter, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy", prpb, (punk == NULL) ? 1 : 2);

				if (rc != 0)
				{
					return(rc);
				}
			}
		}

		if (punk == NULL)
		{
			// If this is a proxy with a CLSID from the following list it is implemented
			// by OLEAUT32.DLL which doesn't return a proxy up front

			//    CLSID_PSDispatch
			//    CLSID_PSTypeInfo
			//    CLSID_PSTypeLib
			//    CLSID_PSTypeComp
			//    CLSID_PSAutomation
			//    CLSID_PSEnumVARIANT
			//    CLSID_PSSupportErrorInfo

#if 0
			ReportFailure(0x2906, false, ppsfb, 3, L"IPSFactoryBuffer::CreateProxy succeeded but *ppv == NULL");
#endif
		}

		else
		{
			dwNonClass++;

			szQualifier = L" (Proxy)";

			int rc = TestAndReleaseInterface(punk, NULL, IsEqualGUID(iid, IID_IUnknown), false, false);

			if (rc != 0)
			{
				return(rc);
			}
		}

		szQualifier = L" (ProxyBuffer)";

		int rc = TestAndReleaseInterface(fAggregate ? pouter : (IUnknown *) prpb, NULL, false, false, true);

		if 