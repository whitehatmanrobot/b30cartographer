, "\n**********************************************************\n");

    if(pdiagstruct->nv_pfifo_intr_0){       
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Fifo has Interrupts pending. NV_PFIFO_INTR_0=", (int) pdiagstruct->nv_pfifo_intr_0);
        if(!pdiagstruct->nv_pfifo_intr_en_0){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Fifo has Interrupts disabled. NV_PFIFO_INTR_EN_0=", (int) pdiagstruct->nv_pfifo_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING !!!--- The fifo will be stalled under these conditions.\n");
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Fifo has Interrupts enabled. NV_PFIFO_INTR_EN_0=", (int) pdiagstruct->nv_pfifo_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING !!!--- The fifo appears to be waiting for the RM for service.\n");
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "                  If this condition persists ... There could be a system problem.\n");
        }
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Fifo has NO Interrupts pending. NV_PFIFO_INTR_0=", (int) pdiagstruct->nv_pfifo_intr_0);
        if(!pdiagstruct->nv_pfifo_intr_en_0){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe Fifo has Interrupts disabled. NV_PFIFO_INTR_EN_0=", (int) pdiagstruct->nv_pfifo_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  -The fifo is in an idle state. (disabled)\n");
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Fifo has Interrupts enabled. NV_PFIFO_INTR_EN_0=", (int) pdiagstruct->nv_pfifo_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  -All appears to be normal here.\n\n");
        }
    }

    if(pdiagstruct->nv_pfifo_caches & NV_PFIFO_CACHES_REASSIGN_ENABLED){      
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "The Fifo REASSIGN is ENABLED allowing for lightweight fifo context switching.\n");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  -NV_PFIFO_CACHES=", (int) pdiagstruct->nv_pfifo_caches);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Fifo REASSIGN is DISABLED. NV_PFIFO_CACHES=", (int) pdiagstruct->nv_pfifo_caches);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING !!!---The fifo CANNOT context switch under this condition.\n\n");
    }

    if(pdiagstruct->nv_pfifo_cache1_push0 && pdiagstruct->nv_pfifo_cache1_pull0){ 
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The fifo pusher and puller are both ENABLED. NV_PFIFO_CACHE1_PUSH0=", (int) pdiagstruct->nv_pfifo_cache1_push0);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                             NV_PFIFO_CACHE1_PULL0=", (int) pdiagstruct->nv_pfifo_cache1_pull0);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "This is the standard running condition.\n\n");
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Either the fifo pusher or puller are DISABLED. NV_PFIFO_CACHE1_PUSH0=", (int) pdiagstruct->nv_pfifo_cache1_push0);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                               NV_PFIFO_CACHE1_PULL0=", (int) pdiagstruct->nv_pfifo_cache1_pull0);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING---The fifo will be STALLED under these conditions.\n\n");
    }
    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The current channel context in the fifo is channel ", (int) (pdiagstruct->nv_pfifo_cache1_push1 & 0xFF));
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "running in ");
    if(pdiagstruct->nv_pfifo_cache1_push1 & 0x100){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DMA mode.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PIO mode.\n");
    }
    
    if(IsNV4(pDev) || IsNV5(pDev) || IsNV0A(pDev)){
        if((pdiagstruct->nv_pfifo_cache1_push1 & 0xFF)==0xf){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING !!!--- This channel context indicates the fifo may be in an uninitialized state\n");
        }
    }else{
        if(IsNV10orBetter(pDev)){
            if((pdiagstruct->nv_pfifo_cache1_push1 & 0xFF)==0x1f){
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING !!!--- This channel context indicates the fifo may be in an uninitialized state\n");
            }
        }
    }
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
    
    if(pdiagstruct->nv_pfifo_dma_put == pdiagstruct->nv_pfifo_dma_get){      
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DMA PUT and GET are equal indicating the fifo is empty. ",(int) pdiagstruct->nv_pfifo_dma_get);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  -Use the d option from the main menu to view the fifo contents.\n");
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DMA PUT and GET are NOT equal indicating the fifo is NOT empty. NV_PFIFO_CACHE1_GET = ",(int) pdiagstruct->nv_pfifo_dma_get);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                                                NV_PFIFO_CACHE1_PUT = ",(int) pdiagstruct->nv_pfifo_dma_put);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "   -If this condition persists the fifo may be disabled or stalled.\n");
    }
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n**********************************************************\n");
}

VOID NvWatch_QuickDiag_master(PHWINFO pDev, PNVWATCHDIAGSTRUCT pdiagstruct)
{

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n**********************************************************\n");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Running Master Control diagnostic ...");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n**********************************************************\n");

    if(pdiagstruct->nv_pmc_intr_0){       
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Chip has Interrupts pending. NV_PMC_INTR_0=", (int) pdiagstruct->nv_pmc_intr_0);
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PMEDIA, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Media Port engine INT is PENDING.\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PFIFO, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Fifo engine INT is       PENDING.\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PGRAPH, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Graphics engine INT is   PENDING.\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PVIDEO, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Video engine INT is      PENDING.\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PTIMER, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Timer engine INT is      PENDING.\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "CRTC INT is              PENDING. (VBLANK)\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _PBUS, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Bus engine INT is        PENDING.\n");
        }
        if(pdiagstruct->nv_pmc_intr_0 & DRF_DEF(_PMC, _INTR_0, _SOFTWARE, _PENDING)){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Software engine INT is   PENDING.\n");
        }

        if(!pdiagstruct->nv_pmc_intr_en_0){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Chip has Interrupts disabled. NV_PMC_INTR_EN_0=", (int) pdiagstruct->nv_pmc_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "---WARNING !!!--- The Chip will be stalled under these conditions.\n\n");
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Chip has Interrupts enabled. NV_PMC_INTR_EN_0=", (int) pdiagstruct->nv_pmc_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  -All appears to be normal here.\n\n");
        }
    }else{
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Chip has NO Interrupts pending. NV_PMC_INTR_0=", (int) pdiagstruct->nv_pmc_intr_0);
        if (!pDev->Vga.Enabled){
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "---WARNING !!!---This would not be expected in hires mode.\n");
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "  -The CRTC should need to service VBLANK.\n");

        }
        if(!pdiagstruct->nv_pmc_intr_en_0){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe Chip has Interrupts disabled. NV_PMC_INTR_EN_0=", (int) pdiagstruct->nv_pmc_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  -The Chip is in an idle state. (disabled)\n\n");
        }else{
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The Chip has Interrupts enabled. NV_PMC_INTR_EN_0=", (int) pdiagstruct->nv_pmc_intr_en_0);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  -All appears to be normal here.\n\n");
        }
    }
    
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PMEDIA, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Media Port Engine is                    ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Media Port Engine is                    DISABLED.\n");
    }
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PFIFO, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Fifo Engine is                          ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Fifo Engine is                          DISABLED.\n");
    }
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PGRAPH, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Graphics Engine is                      ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Graphics Engine is                      DISABLED.\n");
    }
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PPMI, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Timer and bus mastering logic Engine is ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Timer and bus mastering logic Engine is DISABLED.\n");
    }
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PFB, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Frame Buffer Engine is                  ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Frame Buffer Engine is                  DISABLED.\n");
    }
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PCRTC, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Dac and CRTC devices are                ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Dac and CRTC devices are                DISABLED.\n");
    }
    if(pdiagstruct->nv_pmc_enable & DRF_DEF(_PMC, _ENABLE, _PVIDEO, _ENABLED)){
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Video Scalar device is                  ENABLED.\n");
    }else{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Video Scalar device is                  DISABLED.\n");
    }

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n**********************************************************\n");
}

int NvWatch_QuickDiag(PHWINFO pDev)
{
    NVWATCHDIAGSTRUCT diagstruct,*pdiagstruct;

    pdiagstruct = (PNVWATCHDIAGSTRUCT) &diagstruct;

    if(IsNV4(pDev) || IsNV5(pDev) || IsNV0A(pDev)){
        NvWatch_NV04_FillDiagStruct(pDev, pdiagstruct);
    }else{
         if(IsNV10orBetter(pDev)){
             NvWatch_NV04_FillDiagStruct(pDev, pdiagstruct);
         }else{
             DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: Aborting ... device is disabled.\n");
             return(-1);
         }
    }
  
  NvWatch_QuickDiag_master(pDev, pdiagstruct);
  NvWatch_QuickDiag_fifo(pDev, pdiagstruct);
  //NvWatch_QuickDiag_graphics(pDev, pdiagstruct);
  //NvWatch_QuickDiag_instancemem(pDev, pdiagstruct);
}

//****TOP LEVEL MENU***************************************************************************

U032 NvWatch_Edit_NvRegs(PHWINFO pDev)
{
  char instring[]="00000000";
  DWORD ddata=0, daddr=0, save_offset;
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \nEnter the Offset of the Nv Register to query.");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  \n->");

  if(!NvWatch_GetInputDword(&daddr)){
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
    return(0);
  }  
  save_offset = daddr; 
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe data read is ", REG_RD32(daddr));
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Enter the new value for this register ->");

  if(!NvWatch_GetInputDword(&ddata)){
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  Error: Abort action");
    return(0);
  }  

  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\nThe new value written is ", ddata);
  REG_WR32(save_offset, ddata);
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The data read from the register is ", REG_RD32(save_offset));
}

void NvWatch_help(void)
{
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Resource Manager System View Extension for NV4\n\r\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Commands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      sx  - Set Device Context for Queries (Default is Device0)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      f   - Dump Fifo state\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      g   - Dump Graphics state\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      m   - Dump Master Control state\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      v   - Dump Video state\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      c   - Dump CRTC registers\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      n   - Instance Memory Stuff\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      x   - Context Information\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      d   - Fifo Info\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      e   - Edit Nv Registers\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      r   - Resource Manager Data Structures\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      t   - Quick Diag\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit\n\r\n\r");
}

void NvWatch_DumpCRTCRegs(PHWINFO pDev)
{
    U008 oldCR1F;
    U008 data08;
    U032 index;

    U032 Head = 0;  // To get this to compile, I'm hardcoding to Head 0. Need to add Head # to user interface, dump multiple sets.

    // save off the contents of CR1F
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, oldCR1F, Head);

    // Unlock extended crtc registers.
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RO_VALUE, Head);

    // print the 64 CRTC registers.
    for (index = 0; index < 64; index++)
    {
        if ((index % 16) == 0)
        {
            // go to next line
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r");
        }

        CRTC_RD(index, data08, Head);
        vmmOutDebugStringValue("#AL", data08);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "  ");
    }

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\r");

    // restore contents of CR1F
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, oldCR1F, Head);
}


// This routine could be removed and the functions added to the pDev.
// For now this should be fine.
U032 NvWatch_Dispatch(PHWINFO pDev, U032 function)
{
    if(IsNV10orBetter(pDev)){
        switch(function){
            case NVWATCH_FUNC_GETHASHSIZE:
                return(NvWatch_NV10_GetHashSize(pDev)); break;
            case NVWATCH_FUNC_DUMP_FIFO:
                NvWatch_NV10_Dump_Fifo(pDev);             return(0); break;
            case NVWATCH_FUNC_DUMP_GRAPHICS:
                NvWatch_NV10_Dump_Graphics(pDev);         return(0); break;
            case NVWATCH_FUNC_DUMP_MASTER:
                NvWatch_NV10_Dump_Master(pDev);           return(0); break;
            case NVWATCH_FUNC_DUMP_VIDEO:
                NvWatch_NV10_Dump_Video(pDev);            return(0); break;
            case NVWATCH_FUNC_QUERYDEVICECONTEXT:
                NvWatch_NV10_Query_DeviceContext(pDev);   return(0); break;
            case NVWATCH_FUNC_DMAPUSH_AND_FIFO:
                NvWatch_NV10_DmaPushAndFifo(pDev);(pDev); return(0); break;
        }
    }else{
        switch(function){
            case NVWATCH_FUNC_GETHASHSIZE:
                return(NvWatch_NV04_GetHashSize(pDev)); break;
            case NVWATCH_FUNC_DUMP_FIFO:
                NvWatch_NV04_Dump_Fifo(pDev);             return(0); break;
            case NVWATCH_FUNC_DUMP_GRAPHICS:              
                NvWatch_NV04_Dump_Graphics(pDev);         return(0); break;
            case NVWATCH_FUNC_DUMP_MASTER:                
                NvWatch_NV04_Dump_Master(pDev);           return(0); break;
            case NVWATCH_FUNC_DUMP_VIDEO:                 
                NvWatch_NV04_Dump_Video(pDev);            return(0); break;
            case NVWATCH_FUNC_QUERYDEVICECONTEXT:         
                NvWatch_NV04_Query_DeviceContext(pDev);   return(0); break;
            case NVWATCH_FUNC_DMAPUSH_AND_FIFO:
                NvWatch_NV04_DmaPushAndFifo(pDev);(pDev); return(0); break;
        }
    }
}

#endif

// JJV - Just leave the prototype so that this can link. Basically no ifdef DEBUG in VXDSTUB.ASM.
void DotN_cmd_c(void)
{
#ifdef DEBUG
  BOOL keep_running=TRUE;
  char in_char;
  U032 dword_char;
  U032 hash_size;
  char pstring[]="NvWatch";
  PHWINFO pDev;

  pDev = NvDBPtr_Table[0];
 
  NvWatch_help();

  hash_size = NvWatch_Dispatch(pDev, NVWATCH_FUNC_GETHASHSIZE);
  hash_size >>= 16;
  hash_size &= 0x3;
  
  switch(hash_size){
    case 0:
      NvWatch_num_objects = 0x1000/8;
      break;
    case 1:
      NvWatch_num_objects = 0x2000/8;
      break;
    case 2:
      NvWatch_num_objects = 0x4000/8;
      break;
    case 3:
      NvWatch_num_objects = 0x8000/8;
      break;
  }
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
    in_char = get_winice_input();
    dword_char = (U032) in_char;

    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE; break;
      case 'f': // Fifo Registers
      case 'F': // Fifo Registers
        NvWatch_Dispatch(pDev, NVWATCH_FUNC_DUMP_FIFO); break;
      case 'g': // Graphics Registers
      case 'G': // Graphics Registers
        NvWatch_Dispatch(pDev,NVWATCH_FUNC_DUMP_GRAPHICS); break;
      case 'm': // Master Control Registers
      case 'M': // Master Control Registers
        NvWatch_Dispatch(pDev,NVWATCH_FUNC_DUMP_MASTER); break;
      case 'v': // Video Registers
      case 'V': // Video Registers
        NvWatch_Dispatch(pDev,NVWATCH_FUNC_DUMP_VIDEO); break;
      case 'e': // Edit Data
      case 'E': // Edit Data
        NvWatch_Edit_NvRegs(pDev);
        break;
      case 'n': // Instance Memory stuff
      case 'N': // Instance Memory stuff
        NvWatch_Query_InstanceMemory(pDev);
        break;
      case 'x': // Context Data
      case 'X': // Context Data
        NvWatch_Dispatch(pDev,NVWATCH_FUNC_QUERYDEVICECONTEXT);
      case 'r': // RM Stuff
      case 'R': // RM Stuff
        NvWatch_RMData(pDev);
        break;
      case 'd': // DmaPush and Fifo
      case 'D': // DmaPush and Fifo
        NvWatch_Dispatch(pDev,NVWATCH_FUNC_DMAPUSH_AND_FIFO); break;
      case 't': // Chip Diag
      case 'T': 
        NvWatch_QuickDiag(pDev);
        break;
      case 'p': // Crush11 Tests
      case 'P': 
        NvWatch_Crush11_Tests(pDev);
        break;
      case 's': // Switch device
      case 'S': // Switch Device
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "    Enter the Device to query. (0-8)");
        in_char = get_winice_input();
        switch (in_char)
        {
          case '0':
            pDev = NvDBPtr_Table[0]; break;
            //NvWatch_Device = 0; break;
          case '1':
            pDev = NvDBPtr_Table[1]; break;
            //NvWatch_Device = 1; break;
          case '2':
            pDev = NvDBPtr_Table[2]; break;
            //NvWatch_Device = 2; break;
          case '3':
            pDev = NvDBPtr_Table[3]; break;
            //NvWatch_Device = 3; break;
          case '4':
            pDev = NvDBPtr_Table[4]; break;
            //NvWatch_Device = 4; break;
          case '5':
            pDev = NvDBPtr_Table[5]; break;
            //NvWatch_Device = 5; break;
          case '6':
            pDev = NvDBPtr_Table[6]; break;
            //NvWatch_Device = 6; break;
          case '7':
            pDev = NvDBPtr_Table[7]; break;
            //NvWatch_Device = 7; break;
          case '8':
            pDev = NvDBPtr_Table[8]; break;
            //NvWatch_Device = 8; break;
        }

        if(pDev == NULL)
        {
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nError: Not a valid device. setting default ...\r\n");
          pDev = NvDBPtr_Table[0];
          //NvWatch_Device = 0;
        }
          
        break;
      case 'c':
      case 'C':
          // Dump crtc registers
          NvWatch_DumpCRTCRegs(pDev);
          break;

      default: // Help
        NvWatch_help();
        break;  
    }
  }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\OSINIT.C ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* Operating System Interface Routines *******************\
*                                                                           *
* ModuleI: INIT.C                                                           *
*   This is the OS initialization module.  One time initialization code     *
*   is present here so it can be unloaded after the OS initialization phase *
*   is complete.                                                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"
#include "vnvrmd.h"
#include "vpicd.h"
#include "vdd.h"
//#include "minivdd.h"
//#include "vpaged.h"
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include <state.h>
#include <class.h>
#include <os.h>
#include "oswin.h"
#include "vmm2.h"
#include "files.h"
#include "nvmisc.h"
#include "nvReg.h"
#include <nv10_hal.h>

#ifndef PC98
// PCI function ID for PC AT
#define PCI_FUNCTION_ID 0xB1
#else
// PCI function ID for PC98
#define PCI_FUNCTION_ID 0xCC
#endif // PC98

#define READ_CONFIG_BYTE        0x08
#define READ_CONFIG_DWORD       0x0A
#define WRITE_CONFIG_BYTE       0x0B
#define WRITE_CONFIG_DWORD      0x0D

//
// Globals
//
WIN9XHWINFO	win9xHwInfo[MAX_INSTANCE];

//
// Externs.
//
extern DISPLAYINFO osDisplayInfo;
extern VOID RmInitCpuInfo(PHWINFO);
extern VOID RmInitBusInfo(PHWINFO);

// This should already exist somewhere, right??
#define RM_GLOBAL_BASE_PATH    "SOFTWARE\\NVIDIA Corporation\\Global\\System"

//---------------------------------------------------------------------------
//
//  Initialization routines.
//
//---------------------------------------------------------------------------
RM_STATUS initStack_frame
(
    PHWINFO pDev
)
{
	PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;
    RM_STATUS status;
    U032      i;
    
    //
    // Allocate it.
    //
    status = osAllocMem((VOID **)&pOsHwInfo->NvIsrStackFrameBase, STACK_SIZE);
    if (status)
        return (status);
    //
    // Lock it.
    //
    vmmLinPageLock(PAGE(pOsHwInfo->NvIsrStackFrameBase), NPAGES(((U032)pOsHwInfo->NvIsrStackFrameBase & PAGEMASK) + STACK_SIZE), 0);
    //
    // Insert fence guard.
    //
    pOsHwInfo->NvIsrStackFrame = pOsHwInfo->NvIsrStackFrameBase;
    for (i = 0; i < STACK_SIZE / 4; i++)
        *(pOsHwInfo->NvIsrStackFrame)++ = 'MRVN';
    (pOsHwInfo->NvIsrStackFrame)--;
    
    return (RM_OK);
}

//
// Initialize the Resource Manager semaphores.
//
RM_STATUS initSemaphore
(
    VOID
)
{
    //
    // Create semaphores.
    //
    rmSemaphore = vmmCreateSemaphore(0);
    osSemaphore = vmmCreateSemaphore(0);
    // Multi-Mon support semaphore.
    mmSemaphore = vmmCreateSemaphore(0);
    //
    // Prime the semaphores.
    //
    vmmSignalSemaphore(rmSemaphore);
    vmmSignalSemaphore(osSemaphore);
    vmmSignalSemaphore(mmSemaphore);
    return (RM_OK);
}
//
// Initialize the callback structure free list.
//
RM_STATUS initCallbackFreeList
(
    VOID
)
{
    RM_STATUS status;
    U032      i;
    
    osCallbackList = NULL;
    status = osAllocMem((VOID **)&osCallbackTable, sizeof(CALLBACK) * NUM_CALLBACKS);
    if (status)
        return (status);
    osCallbackFreeList = osCallbackTable;    
    for (i = 0; i < NUM_CALLBACKS - 1; i++)
    {
        osCallbackFreeList[i].Next = &(osCallbackFreeList[i + 1]);
    }
    osCallbackFreeList[i].Next = NULL;
    return (RM_OK);
}

//
// Currently not used, but a useful routine to determine if the chipset driver has been
// loaded. If the DeviceID/VendorID is in the registry under the GARTMiniports key, we'll
// assume the driver has been loaded (registry entry is setup in the chipset INF).
//
static BOOL IsChipsetDriverLoaded( PHWINFO pDev, U016 vendorid, U016 deviceid)
{
    U032 data, csid = (deviceid << 16) | vendorid;
    UCHAR *strGARTMP = "System\\CurrentControlSet\\Services\\VxD\\PCI\\GARTMiniports\\DDDDVVVV";
    UCHAR *pDV = &strGARTMP[56];      // ptr to where DeviceID and VenderID are concatenated
    S032 i;

    // convert each nibble of the Device/Vendor IDs into chars and concatenate
    for (i = 7; i >= 0; i--) {
        U008 ch = (U008) ((csid >> (i * 4)) & 0xF);

        if (ch >= 0x0 && ch <= 0x9)
            *pDV++ = '0' + ch;
        else
            *pDV++ = 'A' + (ch - 0xA);
    }

    if (osReadRegistryDword(pDev, strGARTMP, "Instance", &data) != RM_OK)
        return FALSE;
    else
        return TRUE;
}

//
// Initialize the channel allocation database.
//
RM_STATUS initChannelInfo
(
    VOID
)
{
    return (RM_OK);
}    

// This is a helper proc to detect an ALI1541 chipset.
// Returns: TRUE if ALI1541 is detected,
//          FALSE otherwise.
//
static BOOL IsALI1541ChipSet(CLIENT_STRUCT *pcrs)
{
    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID; // PCI_FUNCTION_ID
    pcrs->CBRS.Client_AL  = 0x02;            // FIND_PCI_DEVICE
    pcrs->CWRS.Client_CX = 0x1541;          // Device ID
    pcrs->CWRS.Client_DX = 0x10B9;          // Vendor ID
    pcrs->CWRS.Client_SI = 0;               // Index
    PCI(pcrs);
    
    return (pcrs->CBRS.Client_AH == 0);
}

// This is a helper proc to detect an Crush11 North Bridge chipset.
// Returns: TRUE if Crush11 is detected,
//          FALSE otherwise.
//
static BOOL IsCrush11ChipSet(CLIENT_STRUCT *pcrs)
{
    pcrs->CBRS.Client_AH  = PCI_FUNCTION_ID; // PCI_FUNCTION_ID
    pcrs->CBRS.Client_AL  = 0x02;            // FIND_PCI_DEVICE
    pcrs->CWRS.Client_CX = 0x01B7;          // Device ID
    pcrs->CWRS.Client_DX = 0x10DE;          // Vendor ID
    pcrs->CWRS.Client_SI = 0;               // Index
    PCI(pcrs);
    
    return (pcrs->CBRS.Client_AH == 0);
}

#define FB_TEST_VALUE     0xA5A5A5A5

//
// Initialize the Device Information structure.
//
RM_STATUS initMapping
(
    PHWINFO pDev
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
	PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

    U032 data;
    CLIENT_STRUCT  crs;
    struct VPICD_IRQ_Descriptor picIRQDesc;
    U032 fb_test, status = 0;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initMapping\n\r");
    //
    // Initialize structure size.
    //
    pDev->Mapping.Size = sizeof(pDev->Mapping);
    osStringCopy(pDev->Mapping.ID, "Device Mapping");
    pDev->Mapping.IntPin  = 0x01;      // Int #A

    nvAddr = (PHWREG)vmmMapPhysToLinear(pDev->Mapping.PhysAddr, 0x01000000, 0);    
    fbAddr = (PHWREG)vmmMapPhysToLinear(pDev->Mapping.PhysFbAddr, pDev->Mapping.fbLength, 0);

    //
    // Attempt to determine the current CPU type
    //
    RmInitCpuInfo(pDev);

    //
    // Before going any further, let's do a quick verification that this memory mapping is correct.
    //
    fb_test = fbAddr->Reg032[0];
    fbAddr->Reg032[0] = FB_TEST_VALUE;                  // write fb or NV_CONFIG_PCI_NV_0 (READ ONLY)
    if((data = fbAddr->Reg032[0]) != FB_TEST_VALUE)     // if we read back, its fb
    {
        // is it possible the device manager gave us physical addresses in the "wrong" order?
        // try swapping them
        data = (U032)nvAddr;
        nvAddr = fbAddr;
        fbAddr = (PHWREG)data;

        fbAddr->Reg032[0] = FB_TEST_VALUE;
        if((data = fbAddr->Reg032[0]) != FB_TEST_VALUE)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: NV not found at physical address ", pDev->Mapping.PhysAddr);
            return(RM_ERROR);    
        }
    }       
    else    // its framebuffer, restore the data (important if we are secondary display and have a message)
        fbAddr->Reg032[0] = fb_test;

    if (!pDev->Mapping.IntLine)   // we got this IRQ from config mgr. this should never be 0.
    {
        // if BIOS assigned and IRQ,
        // read reg 3C and look for IRQ number       
        pDev->Mapping.IntLine = REG_RD32(NV_PBUS_PCI_NV_15) & 0XFF;
        if (!pDev->Mapping.IntLine)
        {
            //vmmFatalErrorHandler((DWORD)"NVVDD: Unable to connect to IRQ.", 0);
            return (RM_ERROR);
        }
    }

    // 
    // Determine the chip type and initialize the chip-specific data
    // in the pDev structure.
    //

    // The architecture bits changed after NV3, so check the device ID to rule out NV3
    if (REG_RD_DRF(_PBUS, _PCI_NV_0, _DEVICE_ID_CHIP) == 3)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: NV3 found, incorrect driver!\n\r");
        return (RM_ERROR);
    }

    //
    // Hook up data/code from the ROM.
    //
    initHal(pDev);

    // We need to know which chip this is early during boot.
    nvHalMcControl(pDev, MC_CONTROL_SETREVISION);

    //
    // I hate to do this here, but the fbstate isn't called until after we map the
    // chip (of course), but I need to figure out right now how big is our framebuffer.
    //
    // Configure validated framebuffer resolution.  Note that the BIOS will be setting these
    // bits during post, and he uses the extension bit to denote an 8meg framebuffer.  So
    // check that first...
    //
    status = nvHalFbControl(pDev, FB_CONTROL_INIT);

    if (status != RM_OK) //Was FB config set up correctly? Did we find false memory configs?
    {
        return RM_ERROR;
    }

    biosAddr = (PHWREG)((U008*)nvAddr + pDev->Pram.HalInfo.PraminOffset);

    //
    // Enable PPro write-combining using MTRR
    //
    // Framebuffer only, all fb space, fb cache type 2
    //
    // IKOS workaround for NV5/NV10 emulation.
    // If the FB is allowed to be write-combined, bad pixels may be read in during
    // these bursts, so during emulation, don't allow the FB to be write-combined.
    // 
#ifndef IKOS
    if (mtrrGetVersion() && !IsCrush11ChipSet(&crs))
        mtrrSetPhysicalCacheTypeRange(pDev->Mapping.PhysFbAddr, 0, pDev->Framebuffer.HalInfo.RamSize, 2);
#endif
    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: NV using physical address ", pDev->Mapping.PhysAddr);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: NV using linear   address ", (int)nvAddr);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB using physical address ", pDev->Mapping.PhysFbAddr);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB using linear   address ", (int)fbAddr);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: NV using IRQ line ", pDev->Mapping.IntLine);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: NV using IRQ pin  ", pDev->Mapping.IntPin);
    //
    // Map the the ROM address based on whether this is a motherboard or add in.
    //
    //
    // Add in NV board map ROM through NV Space.
    //
    romAddr = (PHWREG)((DWORD)nvAddr + DEVICE_BASE(NV_PROM));

    //
    // Some PCI BIOSs leave the ROM mapped.  This causes problems if it overlays
    // system RAM.  Just disable it.
    //
    REG_WR32(NV_PBUS_PCI_NV_12, 0);

    //
    // Make sure our PCI latency timer is sufficient (max it out)
    //
    REG_WR32(NV_PBUS_PCI_NV_3, DRF_NUM(_PBUS,_PCI_NV_3,_LATENCY_TIMER, NV_PBUS_PCI_NV_3_LATENCY_TIMER_248_CLOCKS));

    if (IsALI1541ChipSet(&crs))
    {
        // This chipset has a bug which causes it to read stale data.
        // An IO needs to be done to ensure all caches are flushed before
        // the Put is updated. 
        // This happens on both PCI and AGP.
        pDev->Mapping.doIOToFlushCache = 1;
        
        //
        // This chipset has another bug, confirmed by ALI, where it cannot
        // accept fast DEVSEL# at 100MHz bus speeds.  We cannot adjust our
        // DEVSEL# speeds, but we can delay our TRDY by one clock cycle, which
        // should have the same effect.
        //
        // Note that we (NV) have seen no improvement in any of the ALI1541
        // issues with this change, but ALI is adament there is a bug in the 1541
        // having to do with this logic.  Better safe than sorry.
        //
        // This bit is present in NV4, NV5, and NV10.
        //
        FLD_WR_DRF_DEF(_PBUS, _DEBUG_1, _PCIS_WRITE, _1_CYCLE);
        
        //
        // Force the drivers to not use AGP pushing for their command streams.  There is still
        // some unexplained cache coherency issues with memory when lots of AGP traffic is
        // present.  The problems are much less when running only PCI66 (or even PCI33) traffic.
        //
        // Only enable this flag if it doesn't already exist -- that way we have a method to
        // override the default behavior if necessary.  Since you tend not to change your motherboard
        // the first install of our drivers will enable the flag.
        //
        if (osReadRegistryDword(pDev, strDevNodeRM, NV_REG_SYS_SUPER7_COMPATIBILITY, &data) != RM_OK)
        {
            // Write to both local/global keys, since the drivers check in different paths
            osWriteRegistryDword(pDev, strDevNodeRM,        NV_REG_SYS_SUPER7_COMPATIBILITY, 1);
            osWriteRegistryDword(pDev, RM_GLOBAL_BASE_PATH, NV_REG_SYS_SUPER7_COMPATIBILITY, 1);
        }
    }
    else
    {
        // Also reset a stale NV_REG_SYS_SUPER7_COMPATIBILITY registry setting
        if (osReadRegistryDword(pDev, strDevNodeRM, NV_REG_SYS_SUPER7_COMPATIBILITY, &data) == RM_OK)
        {
            // Write to both local/global keys, since the drivers check in different paths
            osWriteRegistryDword(pDev, strDevNodeRM,        NV_REG_SYS_SUPER7_COMPATIBILITY, 0);
            osWriteRegistryDword(pDev, RM_GLOBAL_BASE_PATH, NV_REG_SYS_SUPER7_COMPATIBILITY, 0);
        }
    }
        
    //
    // Attempt to determine the FSB and Memory speeds
    //
    RmInitBusInfo(pDev);

    //
    // Backdoor AGP support.  If this is an AGP card and there is an Intel 440LX/BX in the
    // system, let's detect the current GART settings.  This allows us to use AGP outside
    // of DDraw in Win9X (specifically Win95)
    //
    // Are we AGP?
    //
    pRmInfo->AGP.AGPPhysStart = 0;
    pRmInfo->AGP.AGPLimit = 0;
    pDev->Chip.ReqAGPRate = 0x2;                  // default to AGP 2x    
    
    //
    // Instead of reading the strap, walk the PCI config space.  See if there is an AGP cap
    // after the power mgmt cap.
    //
    //if ((REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_BUS_TYPE) == NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP))
    if (REG_RD_DRF(_PBUS, _PCI_NV_24, _NEXT_PTR) == NV_PBUS_PCI_NV_24_NEXT_PTR_AGP)
    {
        U032 numRanges = 0;

        // Apply any AGP chipset workarounds or overrides
        NvUpdateAGPConfig(pDev);

        // Set the AGP limit to the WC part of the Aperture
        osUpdateAGPLimit(pDev);

    }  // AGP

#ifdef PC98
    //
    // POST the chip if we're running on a system with no VGA BIOS
    //
    NvPost();
    // set a mode to get VGA running, or else we will hang on DDC
    VBESetMode(0x101, NULL);
#endif // PC98
    
    //
    // Install hardware interrupt routine through PIC device.
    //
    picIRQDesc.VID_IRQ_Number       = (U016) pDev->Mapping.IntLine;
    picIRQDesc.VID_Options          = VPICD_OPT_CAN_SHARE;
    picIRQDesc.VID_Hw_Int_Proc      = (DWORD) osInterrupt;
    picIRQDesc.VID_IRET_Time_Out    = 500;
    picIRQDesc.VID_Virt_Int_Proc    = 0;
    picIRQDesc.VID_EOI_Proc         = 0;
    picIRQDesc.VID_Mask_Change_Proc = 0;
    picIRQDesc.VID_IRET_Proc        = 0;

    //
    // Wait for PMC state change to LOAD before re-enabling the interrupt line.
    //
    CLI
    pDev->Mapping.hpicIRQ = (U032) VPICD_Virtualize_IRQ(&picIRQDesc);
    STI
    VPICD_Physically_Mask(pDev->Mapping.hpicIRQ);
    VPICD_Physically_Unmask(pDev->Mapping.hpicIRQ);
//    picPhysicallyMask(hpicIRQ);
//    picPhysicallyUnmask(hpicIRQ);

    // Check if "DoIOToFlushCache" override exists.
    if (osReadRegistryDword(pDev, strDevNodeRM, "DoIOToFlushCache", &data) == RM_OK)
    {
        pDev->Mapping.doIOToFlushCache = 1;
    } 

    // write the name of the RM VXD in the registry
    if (osWriteRegistryBinary(pDev, strDevNodeRM, strRmCoreName, strRmCoreVxd, osStringLength(strRmCoreVxd)+1) != RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: WriteRegistry of RmCoreName failed\n\r");
    } 

    return (RM_OK);
}

RM_STATUS initFbEx
(
    PHWINFO pDev
)
{
    S032  fbCalcMemSize(VOID);
    U032 calc_max_bw (VOID);
    U032 size;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initFramebufferEx\n\r");
    //
    // Get screen resolution and framebuffer configuration from registry.
    //
    pDev->Dac.HalInfo.Depth = (osDisplayInfo.InfoFlags & REGISTRY_BPP_NOT_VALID) ? 8 : osDisplayInfo.Bpp;

//
//7/12(DDD) commenting out the ifdef below to fix for reboot keeping at 60Hz bug
// RM guys please fix approriately and remove my comments
// I'm placing these here so somebody will look at this
//
//#ifdef NV3_HW                    
    //
    // BUG WORKAROUND: If the user has set a specific refresh rate via the Win95 OSR2+ control
    // panel, the resulting refresh rate will always return MONITOR_INFO_NOT_VALID.  But the
    // refresh value is correct!  Huh...
    //
    // So until we can find the VDD (?) bug, if the refresh value is valid (>60,<250) for our
    // known refresh settings, let it through.
    //
    if ((osDisplayInfo.InfoFlags & MONITOR_INFO_NOT_VALID) &&
        (osDisplayInfo.InfoFlags & REFRESH_RATE_MAX_ONLY) &&
        (osDisplayInfo.RefreshRateMax >= 60) &&
        (osDisplayInfo.RefreshRateMax <= 250))
            osDisplayInfo.InfoFlags &= ~MONITOR_INFO_NOT_VALID;
//#endif // NV3_HW                    
    if ((osDisplayInfo.InfoFlags & (MONITOR_INFO_NOT_VALID | MONITOR_INFO_DISABLED_BY_USER))
     || (osDisplayInfo.RefreshRateMax == 0xFFFFFFFF)
     || (osDisplayInfo.RefreshRateMax == 0))
    {
        pDev->Framebuffer.HalInfo.RefreshRate  = 60;
        pDev->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
        pDev->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;
    }
    else
    {
        pDev->Framebuffer.HalInfo.RefreshRate  = osDisplayInfo.RefreshRateMax;
        pDev->Framebuffer.HSyncPolarity = osDisplayInfo.HorzSyncPolarity;
        pDev->Framebuffer.VSyncPolarity = osDisplayInfo.VertSyncPolarity;
    }
    // This is because we might have shut down with > 800x600, and then rebooted on TV,
    // in which case the registry will have a resolution we cannot support. 
    // The display driver should call in NvConfigSet to set new resolution. 
    // We should never see HorizDisplayWidth == 0, but just in case, we'll check and set to registry values if it is.
    if (pDev->Framebuffer.HalInfo.HorizDisplayWidth == 0) // display driver should have called NvSetConfig to set these
    {
        pDev->Framebuffer.HalInfo.HorizDisplayWidth = osDisplayInfo.XRes;
        pDev->Framebuffer.HalInfo.VertDisplayWidth  = osDisplayInfo.YRes;
    }
    pDev->Framebuffer.HorizFrontPorch = 0;
    pDev->Framebuffer.HorizSyncWidth  = 0;
    pDev->Framebuffer.HorizBackPorch  = 0;
    pDev->Framebuffer.VertFrontPorch  = 0;
    pDev->Framebuffer.VertSyncWidth   = 0;
    pDev->Framebuffer.VertBackPorch   = 0;
    pDev->Framebuffer.CSync           = BUFFER_CSYNC_DISABLED;
    pDev->Dac.HalInfo.VClk            = 0;
    //
    // Check for valid TV mode
    //
#if 0   // taking this out -- display driver is now responsible
    if (pDev->Framebuffer.MonitorType != MONITOR_TYPE_VGA)
        if (pDev->Framebuffer.HalInfo.HorizDisplayWidth > 800)
        {
            pDev->Framebuffer.HalInfo.HorizDisplayWidth = 640;
            pDev->Framebuffer.HalInfo.VertDisplayWidth  = 480;
        } 
#endif
    //
    // Calculate the framebuffer count based on the configuration with double buffering.
    //
    size = pDev->Dac.HalInfo.Depth / 8
         * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth
         * 2;
    if (size > pDev->Framebuffer.HalInfo.RamSize)
        size = 0;
    else
        size = pDev->Framebuffer.HalInfo.RamSize - size;

    //
    // Only enable single arch buffering
    //
    pDev->Framebuffer.Count = 1;

    return (RM_OK);
}

RM_STATUS initGrEx
(
    PHWINFO pDev
)
{
    return (RM_OK);
}
RM_STATUS initDacEx
(
    PHWINFO pDev
)
{ 
    // Setup the timing information for the initial mode set.
//    osSetupForNewStyleModeSet(pDev);
    return (RM_OK);
}
RM_STATUS initFifoEx
(
    PHWINFO pDev
)
{
//    pDev->Fifo.RetryCount = vmmGetProfileDecimalInt(pDev->Fifo.RetryCount, strNv, "FifoRetryCount");
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\VXDSTUB.ASM ===
;
;  (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
;
;********* Operating System Interface for NVidia Resource Manager **********;
;                                                                           ;
; Module: VXDSTUB.ASM                                                       ;
;       These routines provide an operating system independent layer        ;
;       between the Resource Manager and the underlying OS APIs.            ;
;                                                                           ;
;---------------------------------------------------------------------------;
;                                                                           ;
; History:                                                                  ;
;        David Schmenk (dschmenk)     11/17/93 - wrote it                   ;
;        David Schmenk (dschmenk)     06/15/94 - rewrote for real RM        ;
;        JohnH                        10/3/97 - rewrote for MS tools--      ;
;                                     include DDB and service table here    ;
;*********************** Copyright 1993 NVidia, Inc. ***********************;

.386p

INCLUDE BASEDEF.INC
INCLUDE VMM.INC
INCLUDE VWIN32.INC
INCLUDE VPICD.INC
INCLUDE V86MMGR.INC
INCLUDE VNVRMD.INC
INCLUDE DEBUG.INC
include         ..\..\..\..\..\sdk\nvidia\inc\rddapi.inc


VxD_LOCKED_DATA_SEG
PUBLIC  dwSrcLinearPageNum, dwDstLinearPageNum, dwLinearRegionSizeInPages, dwPageDirectoryBaseRegLinear
dwSrcLinearPageNum              DD      0
dwDstLinearPageNum              DD      0
dwLinearRegionSizeInPages       DD      0
dwPageDirectoryBaseRegLinear    DD      0

PUBLIC  dwPageTableEntry
dwPageTableEntry                DD      0
PUBLIC	dwGotNulPTE, dwNulPTE
dwGotNulPTE			DD	0
dwNulPTE			DD	0
VxD_LOCKED_DATA_ENDS


VxD_LOCKED_CODE_SEG

;   The Device Declartation Block

;Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
;    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

IFDEF NV4_HW
Declare_Virtual_Device  NVCORE, NVRM_Major_Version, NVRM_Minor_Version, rmControlEntry, UNDEFINED_DEVICE_ID, UNDEFINED_INIT_ORDER, \
                        ,                    \
                        rmUsrAPIEntry        \
                        ,
ENDIF

;---------------------------------------------------------------------------
;
;  These bogus routines are needed for the C compiler's optimizer function
;    Called as:
;               EAX = buffer offset
;               ECX = count
;               EDX = value
;
;---------------------------------------------------------------------------
BeginProc __STOSB
        jcxz    exitb
fillitb:
        dec     ecx
        mov     BYTE PTR [eax][ecx], dl
        jnz     fillitb
exitb:
        ret
EndProc __STOSB
BeginProc __STOSW
        jcxz    exitw
fillitw:
        dec     ecx
        mov     WORD PTR [eax][ecx*2], dx
        jnz     fillitw
exitw:
        ret
EndProc __STOSW
BeginProc __STOSD
        jcxz    exitd
fillitd:
        dec     ecx
        mov     DWORD PTR [eax][ecx*4], edx
        jnz     fillitd
exitd:
        ret
EndProc __STOSD
BeginProc _inpd
        push    edx
        mov     dx,  ax
        in      eax, dx
        pop     edx
        ret
EndProc _inpd
BeginProc _outpd
        xchg    eax, edx
        out     dx, eax
        ret
EndProc _outpd
BeginProc _inp
        push    edx
        mov     dx,  ax
        in      al, dx
        pop     edx
        ret
EndProc _inp
BeginProc _outp
        xchg    eax, edx
        out     dx, al
        ret
EndProc _outp
;---------------------------------------------------------------------------
;
;  VxD Control entrypoints.
;
;---------------------------------------------------------------------------
EXTRN   _rmControl : NEAR
public  rmControlEntry
BeginProc rmControlEntry
;       ebp points to the Client_Regiser_Structure
;       rmControl expects two args: msg, VMh
        push    ebx             ; VMh
        push    eax             ; msg
        call    _rmControl
        add     esp,2*4
        or      eax, eax
        stc
        jnz     @F
        clc
@@:     ret
EndProc rmControlEntry
;---------------------------------------------------------------------------
;
;  VxD User API entrypoints.
;
;---------------------------------------------------------------------------
EXTRN   @rmUsrAPI@8 : NEAR
public  rmUsrAPIEntry
BeginProc rmUsrAPIEntry
;       fix up arguments for the __fastcall protocol -- C function will use ecx & edx for first two args
        mov     ecx, ebx        ; VM handle
        mov     edx, ebp        ; user parameters (register structure)
        jmp     @rmUsrAPI@8     ; no arguments on stack, so no additional stack maintenance
EndProc rmUsrAPIEntry


;---------------------------------------------------------------------------
;
;  Moved from the RegisterDisplayDriover routine in the minivdd.
;
;---------------------------------------------------------------------------

; 200H bytes should be enough.
align   4
PUBLIC  LogdevSharedArea
LogdevSharedArea:
DD      200H    dup (0)

public  _RegisterDisplayDriver
BeginProc _RegisterDisplayDriver

        push    ebp
        mov     ebp,esp
        pushad
        mov     ebp,ss:[ebp + 8]

        ; The new architecture display driver needs some functions
        ; which can only be performed at the VxD level. I made a
        ; simple interface for these services out of the minivdd
        ; function RegisterDisplayDriver. The Client_EAX register
        ; is used up because it must hold the special code
        ; VDD_REGISTER_DISPLAY_DRIVER_INFO in order to get here,
        ; and Client_EBX is used up holding the system VM handle.
        ; The other registers are all free, so:
        ; CLIENT_ecx    - sub-function
        ; All other registers are sub-function specific.
        ;
        ; I placed the sub-function constants in nvrmarch at
        ; the time I wrote this code.
        mov     eax,[ebp].Client_Reg_Struc.Client_ECX
        cmp     eax,MVDD_ALLOC_LINEAR_ADDRESS_SPACE
        je      AllocLinearAddrSpace
        cmp     eax,MVDD_FREE_LINEAR_ADDRESS_SPACE
        je      FreeLinearAddrSpace
        cmp     eax,MVDD_COPY_PTES_FOR_LINEAR_RANGE
        je      CopyPtesForLinearRange
        cmp     eax,MVDD_ALLOC_MEMORY_BLOCK
        je      AllocSystemAreaMemory
        cmp     eax,MVDD_FREE_MEMORY_BLOCK
        je      FreeSystemAreaMemory
        cmp     eax,MVDD_GET_LOGDEV_SHARED_MEMORY
        je      GetLogdevSharedPtr
        jmp     MRDDExit

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_ALLOC_LINEAR_ADDRESS_SPACE -- this service allocates
        ; linear address space with no physical memory backing it.
        ;
        ; Parameters:
        ; Client_ECX = MVDD_ALLOC_LINEAR_ADDRESS_SPACE
        ; Client_EDX = amount of linear address space to alloc in bytes
        ;
        ; Returns:
        ; Client_EAX    Linear Base Address of linear space if successful
        ;               NULL if there was an error
AllocLinearAddrSpace:

        mov     eax,[ebp].Client_Reg_Struc.Client_EDX
        add     eax,0FFFH
        shr     eax,0CH
        VMMCall _PageReserve,<PR_SYSTEM,eax,PR_FIXED>
        mov     [ebp].Client_Reg_Struc.Client_EAX,eax
        cmp     eax,-1
        jne     MRDDExit
        mov     [ebp].Client_Reg_Struc.Client_EAX,0
        jmp     MRDDExit
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_FREE_LINEAR_ADDRESS_SPACE -- this service frees
        ; linear address space allocated via AllocLinearAddressSpace.
        ;
        ; Parameters:
        ; Client_ECX = MVDD_FREE_LINEAR_ADDRESS_SPACE
        ; Client_EDX = base of linear address space to free
        ; Client_EBX = length in bytes of the range to free
        ;
        ; Returns:      None
FreeLinearAddrSpace:
        mov     eax, [ebp].Client_Reg_Struc.Client_EDX
        shr     eax, 0CH
        mov     [dwDstLinearPageNum], eax
        mov     eax, [ebp].Client_Reg_Struc.Client_EBX
        add     eax, 0FFFH
        shr     eax, 0CH
        mov     [dwLinearRegionSizeInPages], eax

        ; First get a linear address for CR3 (The Page Directory Base Register)
        mov     eax, cr3
        and     eax, NOT 0FFFh
        VMMCall _MapPhysToLinear,<eax,1000H,0>
        mov     [dwPageDirectoryBaseRegLinear], eax
@@:
        ; We need to remap all the pages behind this linear address
        ; space to the nul PTE so that when we PageFree, Windows
        ; does not try and decommit anything.
        mov     eax, [dwPageDirectoryBaseRegLinear]
        mov     ebx, [dwDstLinearPageNum]
        shr     ebx, 10
        and     ebx, 3FFH
        lea     ebx, [eax][ebx * 4]

        mov     eax, [ebx]
        and     eax, 0FFFFF000H
        VMMCall _MapPhysToLinear,<eax,1000H,0>

        mov     ebx, [dwDstLinearPageNum]
        and     ebx, 3FFH
        lea     ebx, [eax][ebx * 4]

        ; We now have a ptr in ebx to the place to put the new PTE
        mov	eax,dwNulPTE
        mov     [ebx], eax

        ; Go to the next PTEs
        inc     [dwDstLinearPageNum]

        dec     [dwLinearRegionSizeInPages]
        jne     @B

	; Now that we have mapped all PTEs to NULL, we can free the
	; linear range and Windows won't try to decommit anything.
        mov     eax,[ebp].Client_Reg_Struc.Client_EDX
        VMMcall _PageFree,<eax,0>
        jmp     MRDDExit
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_COPY_PTES_FOR_LINEAR_RANGE -- this service copies page
        ; table entries for the pages behind one linear range to the
        ; PTEs for the pages behind another linear range. This makes
        ; the two linear ranges address the same physical memory.
        ;
        ; Parameters:
        ; Client_ECX = MVDD_COPY_PTES_FOR_LINEAR_RANGE
        ; Client_EDX = base of linear address space to copy PTEs from
        ; Client_EBX = base of linear address space to copy PTEs to
        ; Client_EDI = size of linear region in bytes to copy PTEs for
        ;
        ; Returns:      None
CopyPtesForLinearRange:
        mov     eax, [ebp].Client_Reg_Struc.Client_EDX
        shr     eax, 0CH
        mov     [dwSrcLinearPageNum], eax
        mov     eax, [ebp].Client_Reg_Struc.Client_EBX
        shr     eax, 0CH
        mov     [dwDstLinearPageNum], eax
        mov     eax, [ebp].Client_Reg_Struc.Client_EDI
        add     eax, 0FFFH
        shr     eax, 0CH
        mov     [dwLinearRegionSizeInPages], eax

IF 0
        ; CopyPageTable does NOT work when you are running SoftICE
        ; if the dst page table entry you are copying over was
        ; originally part of an AllocLinearAddrSpace. SoftICE marks
        ; PTES behind an AllocLinearAddrSpace call with 000B3000
        ; (if SoftICE isn't running, non-physically-backed pages
        ; on AllocLinearAddrSpace are marked differently).
        ; CopyPageTable seems to fail if a current dst PTE is
        ; set to 000B3000 (or maybe SoftICE hooks CopyPageTable as
        ; well and blocks if the current dst PTE is 000B3000).
@@:
        ; Get the first src PTE
        mov     eax, OFFSET [dwPageTableEntry]
        VMMcall _CopyPageTable,<dwSrcLinearPageNum,1,eax,0>
        inc     [dwSrcLinearPageNum]

        ; Write the PTE for the dst region
        mov     eax, [dwPageTableEntry]
        shr     eax, 0CH
        VMMcall _PageCommitPhys,<dwDstLinearPageNum,1,eax,PC_USER + PC_WRITEABLE>
        inc     [dwDstLinearPageNum]

        ; Do the whole range
        dec     [dwLinearRegionSizeInPages]
        jne     @B
ELSE
        ; Because of SoftICE, I must bang the PTEs myself!
        ; NOTE!  This WILL NOT WORK with Physical Address Extension - i.e. P6
        ; architecture extension to 36 address bits (currently available only
        ; in Intel Xeon processors).  This can be checked with the PAE flag
        ; (bit 5 of CR4).  If we are in 36 bit (PAE) mode, CR3 becomes a
        ; 27 bit page directory pointer table base address (PDPTR).  The top
        ; two bits of the linear address will select one of four entries in the
        ; page directory pointer table.  Also, PDEs and PTEs become 64 bits to
        ; accomodate 36 bit base addresses (i.e. there are 512 per 4K page).

        ; First get a linear address for CR3 (The Page Directory Base Register)
        mov     eax, cr3
        ; Mask off PCD, PWT flags and other detritus - fixes bug 1990807-124351
        and     eax, NOT 0FFFh
        VMMCall _MapPhysToLinear,<eax,1000H,0>
        mov     [dwPageDirectoryBaseRegLinear], eax

@@:
        mov     eax, [dwPageDirectoryBaseRegLinear]
        ; add in 4 * (top 10 bits of the address) to get the PDE
        mov     ebx, [dwSrcLinearPageNum]
        shr     ebx, 10
        and     ebx, 3FFH
        lea     ebx, [eax][ebx * 4]

        ; Now get an address with which we can reference the Page Directory
        mov     eax, [ebx]
        and     eax, 0FFFFF000H
        VMMCall _MapPhysToLinear,<eax,1000H,0>

        ; add in 4 * (bits 21:12 of the address) to get the PTE
        mov     ebx, [dwSrcLinearPageNum]
        and     ebx, 3FFH
        lea     ebx, [eax][ebx * 4]
        mov     eax, [ebx]
        push    eax

        ; Now go through a similar process with the dst page
        mov     eax, [dwPageDirectoryBaseRegLinear]
        mov     ebx, [dwDstLinearPageNum]
        shr     ebx, 10
        and     ebx, 3FFH
        lea     ebx, [eax][ebx * 4]

        mov     eax, [ebx]
        and     eax, 0FFFFF000H
        VMMCall _MapPhysToLinear,<eax,1000H,0>

        mov     ebx, [dwDstLinearPageNum]
        and     ebx, 3FFH
        lea     ebx, [eax][ebx * 4]

	; remember whatever is in the first dst PTE that we find.
	; This PTE will be what we want to restore them to when we
	; free the linear range.
	cmp	dwGotNulPTE,0
	jne	GotNulPTE
	mov	ecx,[ebx]
	mov	dwNulPTE,ecx
	inc dwGotNulPTE
GotNulPTE:
        ; We now have a ptr in ebx to the place to put the new PTE
        pop     eax
        mov     [ebx], eax

        ; Go to the next PTEs
        inc     [dwSrcLinearPageNum]
        inc     [dwDstLinearPageNum]

        dec     [dwLinearRegionSizeInPages]
        jne     @B
ENDIF
        mov     eax, cr3        ; Flush TLBs
        mov     cr3, eax
        jmp     MRDDExit
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


AllocSystemAreaMemory:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_ALLOC_MEMORY_BLOCK -- this service allocates memory in
        ; the system area (3Ggg-4Gig) and returns a flat ptr to it.
        ; Client_ECX = MVDD_ALLOC_MEMORY_BLOCK
        ; Client_EDX = amount of memory to buy in bytes
        ;
        ; Returns:      CLIENT_EAX      flat ptr to memory block
        ;                               0 if there was an error

        mov     eax,[ebp].Client_Reg_Struc.Client_EDX
        add     eax,0FFFH
        shr     eax,12
        VMMcall _PageAllocate, <eax,PG_SYS,ebx,0,0,0,0,PAGEZEROINIT>
        mov     [ebp].Client_Reg_Struc.Client_EAX,eax

	; clear out the memory block
	mov	edi,eax
        mov     ecx,[ebp].Client_Reg_Struc.Client_EDX
        sub	eax,eax
        rep	stos byte ptr es:[edi]
        jmp     MRDDExit

FreeSystemAreaMemory:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ; MVDD_FREE_MEMORY_BLOCK -- this service frees memory in
        ; the system area (3Gig-4Gig)
        ; Client_ECX = MVDD_ALLOC_MEMORY_BLOCK
        ; Client_EDX = ptr to memory to free
        ;
        ; Returns:      None

        mov     eax,[ebp].Client_Reg_Struc.Client_EDX
        VMMcall _PageFree, <eax,0>
        jmp     MRDDExit

GetLogdevSharedPtr:
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;  -- this service allocates memory in
        ; the system area (3Ggg-4Gig) and returns a flat ptr to it.
        ; Client_ECX = MVDD_GET_LOGDEV_SHARED_MEMORY
        ;
        ; Returns:      None

        mov     eax,OFFSET LogdevSharedArea
        mov     [ebp].Client_Reg_Struc.Client_EAX,eax
        jmp     MRDDExit

MRDDExit:
        popad
        pop     ebp
        ret
EndProc _RegisterDisplayDriver


;---------------------------------------------------------------------------
;
;  TIMER BIOS interface
;
;---------------------------------------------------------------------------
;
; BOOL TIMER(struct Client_Regs *);
;
BeginProc _TIMER
        push    ebp
        mov     ebp, esp
;
; Save all registers.
;
        pushad
;
; Load register structure for TIMER call.
;
        mov     esi, [ebp + 8]
        mov     eax, [esi + Client_EAX]
        mov     ebx, [esi + Client_EBX]
        mov     ecx, [esi + Client_ECX]
        mov     edx, [esi + Client_EDX]
        mov     edi, [esi + Client_EDI]
        mov     esi, [esi + Client_ESI]
;
; Call TIMER BIOS.
;
        push    ebp
        push    DWORD PTR 01ah
        VMMcall Exec_VxD_Int
        pop     ebp
;
; Fill register structure from TIMER call.
;
        push    esi
        mov     esi, [ebp + 8]
        mov     [esi + Client_EAX], eax
        mov     [esi + Client_EBX], ebx
        mov     [esi + Client_ECX], ecx
        mov     [esi + Client_EDX], edx
        mov     [esi + Client_EDI], edi
        pushfd
        pop     eax
        mov     [esi + Client_EFlags], eax
        pop     eax
        mov     [esi + Client_ESI], eax
;
; Restore registers and return.
;
        popad
        pop     ebp
        ret
EndProc _TIMER

;---------------------------------------------------------------------------
;
;  PCI BIOS interface
;
;---------------------------------------------------------------------------
;
; BOOL PCI(struct Client_Regs *);
;
BeginProc _PCI
        push    ebp
        mov     ebp, esp
;
; Save all registers.
;
        pushad
;
; Load register structure for PCI call.
;
        mov     esi, [ebp + 8]
        mov     eax, [esi + Client_EAX]
        mov     ebx, [esi + Client_EBX]
        mov     ecx, [esi + Client_ECX]
        mov     edx, [esi + Client_EDX]
        mov     edi, [esi + Client_EDI]
        mov     esi, [esi + Client_ESI]
;
; Call PCI BIOS.
;
        push    ebp
        push    DWORD PTR 01ah
        VMMcall Exec_VxD_Int
        pop     ebp
;
; Fill register structure from PCI call.
;
        push    esi
        mov     esi, [ebp + 8]
        mov     [esi + Client_EAX], eax
        mov     [esi + Client_EBX], ebx
        mov     [esi + Client_ECX], ecx
        mov     [esi + Client_EDX], edx
        mov     [esi + Client_EDI], edi
        pushfd
        pop     eax
        mov     [esi + Client_EFlags], eax
        pop     eax
        mov     [esi + Client_ESI], eax
;
; Restore registers and return.
;
        popad
        pop     ebp
        ret
EndProc _PCI

;---------------------------------------------------------------------------
;
;  Video BIOS interface
;
;---------------------------------------------------------------------------
;
; BOOL VBE(struct Client_Regs *);
;
BeginProc _VBE
        push    ebp
        mov     ebp, esp
;
; Save all registers.
;
        pushad
;
; Load register structure for PCI call.
;
        mov     esi, [ebp + 8]
        mov     eax, [esi + Client_EAX]
        mov     ebx, [esi + Client_EBX]
        mov     ecx, [esi + Client_ECX]
        mov     edx, [esi + Client_EDX]
        mov     edi, [esi + Client_EDI]
        mov     esi, [esi + Client_ESI]
;
; Call VBE BIOS.
;
        push    ebp
        push    DWORD PTR 010h
        VMMcall Exec_VxD_Int
        pop     ebp
;
; Fill register structure from PCI call.
;
        push    esi
        mov     esi, [ebp + 8]
        mov     [esi + Client_EAX], eax
        mov     [esi + Client_EBX], ebx
        mov     [esi + Client_ECX], ecx
        mov     [esi + Client_EDX], edx
        mov     [esi + Client_EDI], edi
        pop     eax
        mov     [esi + Client_ESI], eax
;
; Restore registers and return.
;
        popad
        pop     ebp
        ret
EndProc _VBE


;
; Use an int10h to our VGA BIOS to read the EDID from the Toshiba
; system BIOS (used for mobile systems).  Pass a buffer in crs.CRS.Client_EDI
; to copy the result to (128 bytes).  Based on the VBE30 function in this file.
; Called by the Win9x implementation of osGenerateInt10h.
;
; BOOL readToshibaEDID(struct Client_Regs *);
;
;
BeginProc _readToshibaEDID
        push    ebp
        mov     ebp, esp
;
; Save all registers.
;
        pushad
;
; Allocate 128 bytes in the local VM translation buffer, then
; use the returned v86 segment:offset as an absolute offset within
; the VM's real-mode space.
;
        mov     esi, [ebp + 8]
        mov     esi, [esi + Client_EDI] ; get flat offset of the table into esi
        push    esi                     ; store it for the copy back later

        VMMcall Get_Cur_VM_Handle       ; get the current vm handle into ebx

        push    ebp
        mov     ebp, [ebp + 8]          ; get a ptr to the client registers
        mov     ecx, 128                ;  buffer size
        stc                             ; set carry flag to copy, clear otherwise
;        clc
        push    ss                      ; pointer must be in fs:esi
        pop     fs
;fs:esi = source, ebp = destination, ebx = handle of current VM
        VxDcall V86MMGR_Allocate_Buffer
        pop     ebp                     ; v86 address in edi 
                                        ; (16 bits of seg, 16 bits of off)
                                        
                                        ; Should probably check cx to see if all
                                        ; data was allocated.  But 60 bytes should
                                        ; always fit in the default 4k translation

        mov     eax, edi                ; Break the v86 address into ax:di
        and     edi, 0FFFFh
        shr     eax, 16

        mov     esi, [ebp + 8]          ; Load it back into our local crs
        mov     [esi + Client_ES], ax
        mov     [esi + Client_EDI], edi

;
; Load register structure for PCI call.  Move the local crs values into the
; real registers.  Don't know if this is still required with the use of the 
; Push_Client_State macros, but it won't hurt for now.
;
        mov     esi, [ebp + 8]
        mov     eax, [esi + Client_EAX]
        mov     ebx, [esi + Client_EBX]
        mov     ecx, [esi + Client_ECX]
        mov     edx, [esi + Client_EDX]
        mov     edi, [esi + Client_EDI]
        mov     esi, [esi + Client_ESI]

;
; Call VBE BIOS.
;
;        push    ebp
;        push    DWORD PTR 010h
;        VMMcall Exec_VxD_Int
;        pop     ebp

        push    ebp                     ; save away ebp so we can get back 
                                        ; to our local crs
        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; 
        ; Move the register values from our local crs structure into
        ; the global vm crs that Exec_Int uses
        ;
        mov     esi, [ebp + 8]          ; esi points to local crs

                                        ; get the global vm crs from the
        VMMcall Get_Cur_VM_Handle       ; current vm handle
        mov     ebp, [ebx + CB_Client_Pointer]
                                        ; now ebp points to global crs

        push    ebx                     ; save the vm handle
        mov     ebx, [esi + Client_EBX] ; Copy over the regs
        mov     [ebp + Client_EBX], ebx
        mov     ecx, [esi + Client_ECX]
        mov     [ebp + Client_ECX], ecx
        mov     edx, [esi + Client_EDX]
        mov     [ebp + Client_EDX], edx
        mov     edi, [esi + Client_EDI]
        mov     [ebp + Client_EDI], edi
        mov     ax, [esi + Client_ES]
        mov     [ebp + Client_ES], ax
        mov     eax, [esi + Client_EAX]
        mov     [ebp + Client_EAX], eax
IF 1
        mov     esi, [esi + Client_ESI]
        mov     [ebp + Client_ESI], esi
        pop     ebx                     ; restore the handle

        push ebp    ;store global crs handle

        mov     eax, 010h
        VMMcall Exec_Int

        pop     ebp                     ;retrieve global crs handle
        mov     eax, [ebp + CLIENT_EAX] ;get success/failure code
ELSE
        mov     esi, [esi + Client_ESI]
        mov     [ebp + Client_ESI], esi
        pop     ebx                     ; restore the handle

        mov     eax, 010h
        VMMcall Exec_Int
ENDIF

        VMMcall End_Nest_Exec
        Pop_Client_State


        pop     ebp
;
; Fill register structure from PCI call.
;

        mov     esi, [ebp + 8]          ; now we need to copy data back to our
                                        ;   local crs
        mov     [esi + Client_EAX], eax ; really only eax is needed

;        push    esi
;        mov     esi, [ebp + 8]
;        mov     [esi + Client_EAX], eax
;        mov     [esi + Client_EBX], ebx
;        mov     [esi + Client_ECX], ecx
;        mov     [esi + Client_EDX], edx
;        mov     [esi + Client_EDI], edi
;        pop     eax
;        mov     [esi + Client_ESI], eax

;
; Now we must free the translation buffer we've allocated.
;

        VMMcall Get_Cur_VM_Handle       ; make sure we've got the right vm handle

        pop     esi                     ; address of extended memory buffer, stored at start of routine
        mov     ebp, [ebp + 8]          ; point to our local crs
        mov     ecx, 128                ; free buffer size
;        clc                             ; no copy back required
        push    ss                      ; pointer must be in fs:esi
        pop     fs
        stc                             ; copy back
        VxDcall V86MMGR_Free_Buffer
;
; Restore registers and return.
;
        popad
        pop     ebp
        ret
EndProc _readToshibaEDID




;
; BOOL VBE30(struct Client_Regs *);
;
;   VBE3.0 SetMode with custom refresh table
;
BeginProc _VBE30
        push    ebp
        mov     ebp, esp
;
; Save all registers.
;
        pushad
;
; Copy over the mode table into V86 space.  We need to allocate 60 bytes
; in the local VM translation buffer, copy the table over, and then
; use the returned v86 segment:offset as an absolute offset within
; the VM's real-mode space.
;
        mov     esi, [ebp + 8]
        mov     esi, [esi + Client_EDI] ; get flat offset of the table into esi

        VMMcall Get_Cur_VM_Handle       ; get the current vm handle into ebx

        push    ebp
        mov     ebp, [ebp + 8]          ; get a ptr to the client registers
        mov     ecx, 60                 ; need about 60 bytes
        stc                             ; set carry flag to copy, clear otherwise
        push    ss                      ; pointer must be in fs:esi
        pop     fs
        VxDcall V86MMGR_Allocate_Buffer
        pop     ebp                     ; v86 address in edi 
                                        ; (16 bits of seg, 16 bits of off)
                                        
                                        ; Should probably check cx to see if all
                                        ; data was allocated.  But 60 bytes should
                                        ; always fit in the default 4k translation

        mov     eax, edi                ; Break the v86 address into ax:di
        and     edi, 0FFFFh
        shr     eax, 16

        mov     esi, [ebp + 8]          ; Load it back into our local crs
        mov     [esi + Client_ES], ax
        mov     [esi + Client_EDI], edi

;
; Load register structure for PCI call.  Move the local crs values into the
; real registers.  Don't know if this is still required with the use of the 
; Push_Client_State macros, but it won't hurt for now.
;
        mov     esi, [ebp + 8]
        mov     eax, [esi + Client_EAX]
        mov     ebx, [esi + Client_EBX]
        mov     ecx, [esi + Client_ECX]
        mov     edx, [esi + Client_EDX]
        mov     edi, [esi + Client_EDI]
        mov     esi, [esi + Client_ESI]

;
; Call VBE BIOS.
;
;        push    ebp
;        push    DWORD PTR 010h
;        VMMcall Exec_VxD_Int
;        pop     ebp

        push    ebp                     ; save away ebp so we can get back 
                                        ; to our local crs
        Push_Client_State
        VMMcall Begin_Nest_V86_Exec

        ; 
        ; Move the register values from our local crs structure into
        ; the global vm crs that Exec_Int uses
        ;
        mov     esi, [ebp + 8]          ; esi points to local crs

                                        ; get the global vm crs from the
        VMMcall Get_Cur_VM_Handle       ; current vm handle
        mov     ebp, [ebx + CB_Client_Pointer]
                                        ; now ebp points to global crs

        push    ebx                     ; save the vm handle
        mov     ebx, [esi + Client_EBX] ; Copy over the regs
        mov     [ebp + Client_EBX], ebx
        mov     ecx, [esi + Client_ECX]
        mov     [ebp + Client_ECX], ecx
        mov     edx, [esi + Client_EDX]
        mov     [ebp + Client_EDX], edx
        mov     edi, [esi + Client_EDI]
        mov     [ebp + Client_EDI], edi
        mov     ax, [esi + Client_ES]
        mov     [ebp + Client_ES], ax
        mov     eax, [esi + Client_EAX]
        mov     [ebp + Client_EAX], eax
        mov     esi, [esi + Client_ESI]
        mov     [ebp + Client_ESI], esi
        pop     ebx                     ; restore the handle

        mov     eax, 010h
        VMMcall Exec_Int

        VMMcall End_Nest_Exec
        Pop_Client_State

        pop     ebp
;
; Fill register structure from PCI call.
;

        mov     esi, [ebp + 8]          ; now we need to copy data back to our
                                        ;   local crs
        mov     [esi + Client_EAX], eax ; really only eax is needed

;        push    esi
;        mov     esi, [ebp + 8]
;        mov     [esi + Client_EAX], eax
;        mov     [esi + Client_EBX], ebx
;        mov     [esi + Client_ECX], ecx
;        mov     [esi + Client_EDX], edx
;        mov     [esi + Client_EDI], edi
;        pop     eax
;        mov     [esi + Client_ESI], eax

;
; Now we must free the translation buffer we've allocated.
;

        VMMcall Get_Cur_VM_Handle       ; make sure we've got the right vm handle

        mov     ebp, [ebp + 8]          ; point to our local crs
        mov     ecx, 60                 ; free 60 bytes
        clc                             ; no copy back required
        VxDcall V86MMGR_Free_Buffer

;
; Restore registers and return.
;
        popad
        pop     ebp
        ret
EndProc _VBE30

;---------------------------------------------------------------------------
;
;  Read an IO port.
;
;---------------------------------------------------------------------------
BeginProc inp_
        push    edx
        mov     dx,  ax
        xor     eax, eax
        in      al, dx
        pop     edx
        ret
EndProc inp_
;---------------------------------------------------------------------------
;
;  Write an IO port.
;
;---------------------------------------------------------------------------
BeginProc outp_
        xchg    eax, edx
        out     dx, al
        ret
EndProc outp_

;IFDEF VPE_EXTRAS

; John Tobin : This was put here because it would not work compile
; in a 'C' environment...this was easier


public _vwin32CloseVxdHandle
public _vwin32SetWin32Event

BeginProc _vwin32SetWin32Event, CCALL, PUBLIC

ArgVar hEvent, DWORD

        EnterProc

        pushfd
        push    ecx
        push    edx
        mov     eax, [hEvent]

        VxDCall _VWIN32_SetWin32Event

        pop     edx
        pop     ecx
        popfd

        LeaveProc
        return 

EndProc _vwin32SetWin32Event

BeginProc _vwin32CloseVxdHandle, CCALL, PUBLIC

ArgVar hEvent, DWORD

        EnterProc

        push    ecx
        push    edx
        mov     eax, [hEvent]

        VxDCall _VWIN32_CloseVxDHandle

        pop     edx
        pop     ecx

        LeaveProc
        return

EndProc _vwin32CloseVxdHandle


;ENDIF

public  _DotN_help
_DotN_help db '.T - NVIDIA TnT Resource Manager Soft-Ice/W Extension handler.',0ah,0dh,00

EXTRN   _DotN_cmd_c:NEAR
public  _DotN_cmd_asm
BeginProc _DotN_cmd_asm
 
        push    ebp
        mov     ebp, esp
;
; Save all registers.
;
        pushad
        
        call _DotN_cmd_c
        
        popad
        pop     ebp
        retf
        
EndProc _DotN_cmd_asm

VxD_LOCKED_CODE_ENDS

VxD_REAL_INIT_SEG
;---------------------------------------------------------------------------;
;                                                                           ;
;       NVRM_Real_Init_Proc                                                 ;
;                                                                           ;
;   DESCRIPTION:                                                            ;
;       This code is called when the system is still in real mode, and      ;
;       the VxDs are being loaded.                                          ;
;                                                                           ;
;   PARAMETERS:                                                             ;
;       AX = VMM Version                                                    ;
;       BX = Flags                                                          ;
;               Bit 0: duplicate device ID already loaded                   ;
;               Bit 1: duplicate ID was from the INT 2F device list         ;
;               Bit 2: this device is from the INT 2F device list           ;
;       EDX = Reference data from INT 2F response, or 0                     ;
;       SI = Environment segment, passed from MS-DOS                        ;
;                                                                           ;
;   RETURN VALUES:                                                          ;
;       BX = ptr to list of pages to exclude (0, if none)                   ;
;       SI = ptr to list of instance data items (0, if none)                ;
;       EDX = DWORD of reference data to be passed to protect mode init     ;
;                                                                           ;
;---------------------------------------------------------------------------;
BeginProc NVRM_Real_Init_Proc
        test    bx, Duplicate_Device_ID ; check for already loaded NVRM
        jnz     short @F                ; jump if so
        xor     bx, bx                  ; no exclusion table
        xor     si, si                  ; no instance data table
        xor     edx, edx                ; no reference data
        mov     ax, Device_Load_Ok
        ret
@@:     mov     ax, Abort_Device_Load + No_Fail_Message
        ret
EndProc NVRM_Real_Init_Proc

VxD_REAL_INIT_ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\serial.c ===
#define WANTVXDWRAPS
#include <basedef.h>
#include <vmm.h>
#include <vxdwraps.h>
#include <configmg.h>
#include <vcomm.h>
#include <nvtypes.h>
#include <osdbg.h>
#include <serial.h>

#ifdef DEBUG

//
// Baud Rate Stuff
//
NvU32 dbgBaudRateTable[] = {
   1200, 96,
   2400, 48,
   3600, 32,
   4800, 24,
   7200, 16,
   9600, 12,
   19200, 6,
   38400, 3,
   57600, 2,
   115200, 1,
   230400, 32770,
   460800, 32769,
};

//
// PIO Offset
//
#define DBG_USE_COM_PORT_1 (0)
#define DBG_USE_COM_PORT_2 (1)
NvU16 dbgComPortTable[]={DBG_COM1_PORT, DBG_COM2_PORT};

DBGPORT DbgPort = {
   DBG_OBJECT_SERIAL, DBG_USE_COM_PORT_1, 115200,
   };

//
// Simple BaudRate Lookup Table Function
//
NvU16 dbgBaudRate(NvU32 uBaudRate)
{
   NvS32 i;
   NvU16 uReturn = 0x0c;
   
   for (i=0; i<sizeof(dbgBaudRateTable)/sizeof(NvU32); i+=2)
      {
      if (uBaudRate == dbgBaudRateTable[i])
         {
         uReturn = (NvU16)dbgBaudRateTable[i+1];
         break;
         }
      }

   return uReturn;
}


//
// Simple Init Serial Function
//
NvU32 nFirst=TRUE;
NvU16 dbgComPort = DBG_COM1_PORT;
NvU16 uBaudRate;
//
//  This is a cheap hack to fix a problem with hibernation
//  when we go into hibernation Serenum is called to reenum
//  the serial port and change it's baud rate
//  We check for this condition here
//
void ChkBaudRate(void)
{
   NvU16 ChkRate;

   //Make sure that we have the right baud rate
   // sometimes on returns from hibernation Serenum resets us to 9600 baud.. yuch
   // this is a quick check
   if (0x03 != (INB((NvU16)(dbgComPort+LCR_OFFSET))))
      {
      _asm {int 03};
		dbgInitSerial(&DbgPort);
      }
   else
      {

      // this is a long slow check but a bit more intensive
      // make sure baud rate is right
      OUTB((NvU16)(dbgComPort+LCR_OFFSET), 0x83);
      ChkRate = INB((NvU16)(dbgComPort+DHI_OFFSET));
      ChkRate = (ChkRate<<8) | INB((NvU16)(dbgComPort+DLOW_OFFSET));
      if (uBaudRate != ChkRate)
         {
         _asm {int 03};
   		dbgInitSerial(&DbgPort);
         }
      OUTB((NvU16)(dbgComPort+LCR_OFFSET), 0x03);
      }

}

VOID dbgInitSerial(PDBGPORT pDbgPort)
{
   WIN32DCB DCB;
   DWORD ulLength;
   extern DEVNODE dbgDevNode;

   uBaudRate = dbgBaudRate(pDbgPort->uTag.Serial.uBaud);

   // First Time do an enable
   if (nFirst)
      {
      dbgEnableDevice(pDbgPort->uTag.Serial.uPort);
      nFirst=FALSE;
      }

   dbgComPort = dbgComPortTable[pDbgPort->uTag.Serial.uPort];

   //
   //  Default is 8,n,1
   //
   OUTB((NvU16)(dbgComPort+ICR_OFFSET), 0x0);
   OUTB((NvU16)(dbgComPort+FIFO_OFFSET), 0x07);
   OUTB((NvU16)(dbgComPort+LCR_OFFSET), 0x83);
   OUTB((NvU16)(dbgComPort+DLOW_OFFSET), (NvU8)(uBaudRate & 0xFF));
   OUTB((NvU16)(dbgComPort+DHI_OFFSET), (NvU8)(uBaudRate>>8));
   OUTB((NvU16)(dbgComPort+LCR_OFFSET), 0x03);
   OUTB((NvU16)(dbgComPort+MCR_OFFSET), 0x0);
   OUTB((NvU16)(dbgComPort+SPARE_OFFSET), 0xAA);

   //
   // hack#9
   // we are in a fight with VCOMM for control of the serial port
   // when we input the baud, etc, they will try and change it.
   // we need to fix this here
   //
   ulLength = sizeof(DCB);
   if (CR_SUCCESS == CMxx_Read_Registry_Value(dbgDevNode, NULL, "DCB", REG_BINARY, &DCB, &ulLength, CM_REGISTRY_SOFTWARE))
      {
      // Ditto 8,n,1
      DCB.BaudRate = pDbgPort->uTag.Serial.uBaud;
      DCB.fFlags &= ~(DBG_FFLAGS_PARITY);
      DCB.ByteSize = 8;
      DCB.Parity = 0x0;
      DCB.StopBits = 0x0;
      CMxx_Write_Registry_Value(dbgDevNode, NULL, "DCB", REG_BINARY, &DCB, ulLength, CM_REGISTRY_SOFTWARE);
      } 

}


//
// Simple Poll Method to transmit string
// This is simple so the message is not lost if IRQ were used
//
VOID dbgDisplaySerial(PSTR pStr)
{
   NvU32 dbgCurrentState;
   NvU32 ulStateChange;
   extern NvU32 IsConfig98;
   extern NvU32 dbgPowerSysState;
   extern DEVNODE dbgDevNode;


   // If we are in a low power mode then turn the serial port on
   ulStateChange = FALSE;
   if (dbgPowerSysState)
      {
      if (IsConfig98)
         {
         if (CR_SUCCESS == CMxx_Get_DevNode_PowerState(dbgDevNode, &dbgCurrentState, 0x0))
            {
            if (CM_POWERSTATE_D0 != dbgCurrentState)
               {
               ulStateChange = TRUE;
               // Power On
               CMxx_Set_DevNode_PowerState(dbgDevNode, CM_POWERSTATE_D0, 0x0);
               // Initialize
               }
            dbgInitSerial(&DbgPort);
            }
         }
      }

   // Check to make sure baudrate is right
   ChkBaudRate();

	for (;*pStr!='\0'; pStr++)
      {
      while (0x20 != (INB((NvU16)(dbgComPort+LSR_OFFSET))&0x20))
         ;
      OUTB((NvU16)(dbgComPort+DATA_OFFSET), *pStr);
      if (0x0A == *pStr)
          {
          while (0x20 != (INB((NvU16)(dbgComPort+LSR_OFFSET))&0x20))
            ;
          OUTB((NvU16)(dbgComPort+DATA_OFFSET), 0x0D);
          }
      }

   // Turn if off if we are not going to D0
   if (dbgPowerSysState)
      {
      if (IsConfig98)
         {
         if (1 == dbgPowerSysState)
            {
            if (ulStateChange)
               CMxx_Set_DevNode_PowerState(dbgDevNode, dbgCurrentState, 0x0);
            }
         else
            {
            dbgPowerSysState = 0x0;
            dbgEnableDevice2(&DbgPort);
            }
         }
      }

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\vmmwrap.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1997. All rights reserved.
//
//	VMM Call functions
//	These are wrappers for VMM services (a few other VxD services too)
//  Some other services are defined as macros in VMM2.H

#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"
#include "vpicd.h"
#include "vdd.h"
// NVAUDIO does not want to include all
// kernel header files that nvrm.h includes
#if !defined NVAUDIO
#include <nvrm.h>
#include "nvrmwin.h"
#include "vnvrmd.h"
#include "oswin.h"
#else
#include <nvtypes.h>
#endif
#include "vmm2.h"		// more vmm services
//
// pragmas
//
#pragma warning(disable : 4035)

//	return 2 DWORDS of descriptor in address passed as argument	
VOID vmmBuildDescriptorDWORDs(U032 DESCBase, U032 DESCLimit, U032 DESCType, U032 DESCSize, U032 Flags, QUADWORD *DescQWORD)
{
			__asm {
				mov		eax, Flags
				push	eax
				mov		eax, DESCSize
				push	eax
				mov		eax, DESCType
				push	eax
				mov		eax, DESCLimit
				push	eax
				mov		eax, DESCBase
				push	eax
			}
	        CALL_VMM(BuildDescriptorDWORDs);
			// return descriptor via pointer DescQWORD
			__asm {
				push	esi
                mov		esi,DescQWORD
				mov		[esi], eax
				mov		[esi+4], edx
                pop		esi
				add		esp,5*4
			}
}

U032 vmmFreeLDTSelector(U032 vmh, U032 Selector, U032 Flags)
{
			__asm {
            	mov		eax, Flags		
				push	eax				
				mov		eax, Selector	
				push	eax				
				mov		eax, vmh		
				push	eax				
			}
	        CALL_VMM(Free_LDT_Selector)     
			_asm add	esp,3*4
}

U032 vmmAllocateGDTSelector(U032 DescDWORD1, U032 DescDWORD2, U032 Flags)
{
			__asm {
            	push	edx		
				mov		eax, Flags	
				push	eax		
			 	mov		eax, DescDWORD2	
			 	push 	eax		
			 	mov 	eax, DescDWORD1	
			 	push 	eax		
			}
	        CALL_VMM(Allocate_GDT_Selector) 
            __asm {
				add		esp,3*4
				pop		edx
            }
// return:  EAX = new selector 
//			EDX low =  GDT selector
//			EDX high = number of selectors in GDT
//			we don't use edx, so we push and pop to preserve it for the invoking code
}

U032 vmmAllocateLDTSelector(U032 vmh, U032 DescDWORD1, U032 DescDWORD2, U032 Count, U032 Flags)
{
			__asm {
            	push	edx				
				mov		eax, Flags		
				push	eax				
				mov		eax, Count		
				push	eax				
				mov		eax, DescDWORD2	
				push	eax				
				mov		eax, DescDWORD1	
				push	eax				
				mov		eax, vmh
                push	eax
			}
            CALL_VMM(Allocate_LDT_Selector) 
			__asm {
				add		esp, 5*4
				pop		edx		
			}
// return:  EAX = new selector 
//			EDX low =  GDT selector
//			EDX high = number of selectors in GDT
//			we don't use edx (or eax) so we push and pop to preserve it for the invoking code
}           


//	the only reason this needs to be a function is so it can be used as an expression
U032 vmmGetSystemTime()
{
            CALL_VMM(Get_System_Time)
}

U032 vmmCallPriorityVMEvent(U032 PriorityBoost, U032 vmh, U032 flags, U032 RefData, U032 Callback, U032 Timeout)
{
			_asm   mov eax, PriorityBoost 
			_asm   mov ebx, vmh
			_asm   mov ecx, flags		   
			_asm   mov edx, RefData
			_asm   mov esi, Callback
			_asm   mov edi, Timeout
			CALL_VMM(Call_Priority_VM_Event)	
			_asm   mov eax, esi
}


VOID vmmSimulatePush(U032 Value)
{
			_asm	mov eax, Value
            CALL_VMM(Simulate_Push)  
}

VOID vmmSimulateFarCall(U032 Segment, U032 Off)
{
			_asm	mov ecx, Segment
			_asm	mov edx, Off
			CALL_VMM(Simulate_Far_Call)
}

U032 vmmPageCheckLinRange(U032 PageBase, U032 PageCount, U032 flags) 
{
			_asm	mov	eax, flags		
			_asm 	push	eax			
			_asm	mov	eax, PageCount	
			_asm	push	eax			
			_asm	mov	eax, PageBase	
			_asm	push	eax			
            CALL_VMM(_PageCheckLinRange)           
			_asm 	add	esp,3*4
}

U032 vmmLinPageLock(U032 HLinPgNum, U032 nPages, U032 flags)
{
			_asm	mov	eax, flags		
			_asm 	push	eax			
			_asm	mov	eax, nPages		
			_asm	push	eax			
			_asm	mov	eax, HLinPgNum	
			_asm	push	eax			
            CALL_VMM(_LinPageLock)                  
			_asm 	add	esp,3*4
}

U032 vmmLinPageUnLock(U032 HLinPgNum, U032 nPages, U032 flags)
{
			_asm	mov	eax, flags		
			_asm 	push	eax			
			_asm	mov	eax, nPages		
			_asm	push	eax			
			_asm	mov	eax, HLinPgNum	
			_asm	push	eax			
            CALL_VMM(_LinPageUnLock)               
			_asm 	add	esp,3*4
}

U032 vmmPageReserve(U032 uPage, U032 nPages, U032 flags)
{
			_asm	mov	eax, flags		
			_asm 	push	eax			
			_asm	mov	eax, nPages		
			_asm	push	eax			
			_asm	mov	eax, uPage	
			_asm	push	eax			
            CALL_VMM(_PageReserve)               
			_asm 	add	esp,3*4
}

U032 vmmPageCommitPhys(U032 uLinPage, U032 nPages, U032 uPhysPage, U032 flags)
{
			_asm	mov	eax, flags		
			_asm 	push	eax			
			_asm	mov	eax, uPhysPage		
			_asm 	push	eax			
			_asm	mov	eax, nPages		
			_asm	push	eax			
			_asm	mov	eax, uLinPage	
			_asm	push	eax			
            CALL_VMM(_PageCommitPhys)               
			_asm 	add	esp,4*4
}

U032 vmmPageDecommit(U032 uLinPage, U032 nPages, U032 flags)
{
			_asm	mov	eax, flags		
			_asm 	push	eax			
			_asm	mov	eax, nPages		
			_asm	push	eax			
			_asm	mov	eax, uLinPage	
			_asm	push	eax			
            CALL_VMM(_PageDecommit)               
			_asm 	add	esp,3*4
}


VOID vmmPageAllocate(U032 nPages, 
			U032 pType, 
            U032 VM, 
            U032 AlignMask, 
			U032 minPhys, 
            U032 maxPhys, 
            U032 PhysAddr, 
            U032 flags, 
            QUADWORD *Desc)
{
			_asm {
				mov		eax,flags
                push	eax
				mov		eax,PhysAddr
                push	eax
				mov		eax,maxPhys
                push	eax
				mov		eax,minPhys
                push	eax
				mov		eax,AlignMask
                push	eax
				mov		eax,VM
                push	eax
				mov		eax,pType
                push	eax
				mov		eax,nPages
                push	eax
            }
            CALL_VMM(_PageAllocate)                 \
			_asm {
            	push	esi
                mov		esi, Desc
            	mov		[esi], eax
            	mov		[esi+4], edx
				pop		esi
			 	add		esp,8*4
			}
}

VOID vmmPageGetSizeAddr(U032 hMem, U032 flags, QUADWORD *desc64)
{
			_asm {
				mov		eax, flags		
				push	eax				
				mov		eax, hMem		
				push	eax				
			}
            CALL_VMM(_PageGetSizeAddr)
			_asm {
				push	esi
                mov		esi, desc64
            	mov		[esi], eax
                mov		[esi+4], edx
                pop		esi
				add		esp,2*4
			}
}

U032 vmmPageLock(U032 hMem, U032 nPages, U032 PageOff, U032 flags)
{
			_asm	mov		eax, flags		
			_asm	push	eax				
			_asm	mov		eax, PageOff	
			_asm	push	eax				
			_asm	mov		eax, nPages		
			_asm	push	eax				
			_asm	mov		eax, hMem		
			_asm	push	eax				
            CALL_VMM(_PageLock)                    
			_asm 	add		esp,4*4
}

U032 vmmPageUnLock(U032 hMem, U032 nPages, U032 PageOff, U032 flags) 
{
			_asm 	mov		eax, flags		
			_asm 	push	eax				
			_asm 	mov		eax, PageOff	
			_asm 	push	eax				
			_asm 	mov		eax, nPages		
			_asm 	push	eax				
			_asm 	mov		eax, hMem		
			_asm 	push	eax				
            CALL_VMM(_PageUnLock)                   
			_asm 	add 	esp,4*4
}

U032 vmmPageFree(U032 hMem, U032 flags)
{
			_asm	 mov	eax, flags		
			_asm	 push	eax				
			_asm	 mov	eax, hMem		
			_asm	 push	eax				
            CALL_VMM(_PageFree)  	
			_asm add esp,2*4
}

VOID vmmGetDescriptor(U032 Selector, U032 VM, U032 flags, QUADWORD *Desc)
{
			_asm {
            	mov		eax, flags		
			 	push	eax				
			 	mov		eax, VM			
			 	push	eax				
			 	mov		eax, Selector	
			 	push	eax				
			}
            CALL_VMM(_GetDescriptor)
			_asm {
            	push	esi
                mov		esi, Desc
			 	mov		[esi], eax	
			 	mov		[esi+4], edx
				pop		esi
			 	add		esp,3*4
			}
}

U032 vmmSetDescriptor(U032 Selector, U032 VM, U032 DescDWORD1, U032 DescDWORD2, U032 flags)
{
			_asm {
            	mov		eax, flags		
			 	push	eax				
			 	mov		eax, DescDWORD2	
			 	push	eax				
			 	mov		eax, DescDWORD1	
			 	push	eax				
			 	mov		eax, VM			
			 	push	eax				
			 	mov		eax, Selector	
			 	push	eax				
			}
            CALL_VMM(_SetDescriptor)
			_asm add	esp,5*4
}

U032 vmmSelectorMapFlat(U032 VMh, U032 Selector, U032 flags)
{
			_asm {
            	mov		eax, flags
			 	push	eax				
			 	mov		eax, Selector	
			 	push	eax				
			 	mov		eax, VMh
			 	push	eax				
			}
            CALL_VMM(_SelectorMapFlat)              
			_asm add	esp,3*4
}

U032 vmmGetSysVMHandle()
{
			CALL_VMM(Get_Sys_VM_Handle)
			_asm	mov		eax, ebx
}

U032 vmmGetCritSectionStatus(VOID)
{
			CALL_VMM(Get_Crit_Section_Status)
			_asm	mov		eax, ecx		// return # of times crit section claimed
}

U032 vmmCopyPageTable(U032 LinPgNum, U032 nPages, U032 PageBuf, U032 flags)
{
			_asm {
            	mov		eax, flags
                push	eax
                mov		eax, PageBuf
                push	eax
                mov		eax, nPages
                push	eax
                mov		eax, LinPgNum
                push	eax
              }
            CALL_VMM(_CopyPageTable)                
			_asm add	esp,4*4
}

U032 vmmMapPhysToLinear(U032 PhysAddr, U032 nBytes, U032 flags)
{
			_asm {
            	mov		eax, flags
                push	eax
                mov		eax, nBytes
                push	eax
                mov		eax, PhysAddr
                push	eax
			}
            CALL_VMM(_MapPhysToLinear)              
			_asm add	esp,3*4
}

U032 vmmGetCurrentContext(VOID)
{
            CALL_VMM(_GetCurrentContext)           
}

U032 vmmContextSwitch(U032 Context)
{
            _asm	mov		eax, Context
            _asm 	push	eax
            CALL_VMM(_ContextSwitch)
            _asm 	add	esp,4
}

U032 vmmGetProfileHexInt(U032 Default, char *Profile, char *Keyname)
{
			_asm {
                mov		eax, Default
                mov		esi, Profile
            	mov		edi, Keyname
			}
			CALL_VMM(Get_Profile_Hex_Int)
}            

U032 vmmGetProfileDecimalInt(U032 Default, char *Profile, char *Keyname)
{
			_asm {
                mov		eax, Default
                mov		esi, Profile
            	mov		edi, Keyname
			}
            CALL_VMM(Get_Profile_Decimal_Int)       
}

VOID vmmFatalErrorHandler(U032 MsgPtr, U032 ErrFlags)
{
			_asm 	mov		eax, ErrFlags		
			_asm 	mov		esi, MsgPtr	
            CALL_VMM(Fatal_Error_Handler)           
}

VOID vmmCallBackExit(U032 flag)
{
			_asm	mov		eax, flag	
            _asm 	stc                
            _asm 	or		eax, eax   
            _asm	jnz    cbExit      
            _asm	clc                
            _asm	cbExit:            
}

VOID vmmCallBackEntry(VOID)
{
}

VOID vmmSaveClientState(CRS *Buffer)		
{
			_asm	mov		edi, Buffer	
            CALL_VMM(Save_Client_State)             
}

VOID vmmRestoreClientState(CRS *Buffer)   
{
			_asm	mov		esi, Buffer	
            CALL_VMM(Restore_Client_State)          
}

U032 vmmYield(U032 timeout)
{
            _asm mov eax, timeout
            CALL_VMM(Time_Slice_Sleep);
}

U032 vmmCreateSemaphore(U032 TokenCount)	
{
			_asm	mov	ecx, TokenCount	
            CALL_VMM(Create_Semaphore)   
}

U032 vmmWaitSemaphore(U032 Semaphore, U032 Flags)	
{
			_asm	mov eax, Semaphore	
			_asm   mov ecx, Flags	
            CALL_VMM(Wait_Semaphore) 
}			

U032 vmmSignalSemaphore(U032 Semaphore)	
{
			_asm	mov	eax, Semaphore
            CALL_VMM(Signal_Semaphore)   
}			

U032 vmmCreateMutex(U032 Boost, U032 Flags)	
{
			_asm	mov	eax, Flags		
			_asm 	push	eax			
			_asm	mov	eax, Boost		
			_asm	push	eax			
            CALL_VMM(_CreateMutex)                  
			_asm 	add	esp,2*4
}

U032 vmmEnterMutex(U032 Mutex, U032 Flags)	
{
			_asm	mov	eax, Flags		
			_asm 	push	eax			
			_asm	mov	eax, Mutex		
			_asm	push	eax			
            CALL_VMM(_EnterMutex)                  
			_asm 	add	esp,2*4
}			

U032 vmmLeaveMutex(U032 Mutex)	
{
			_asm	mov	eax, Mutex		
			_asm	push	eax			
            CALL_VMM(_LeaveMutex)                  
			_asm 	add	esp,1*4
}			

U032 picGetIRQVirtualizedStatus(U032 IRQnum, U032 VMh)
{
            //
            // We need to preserve the CY flag, and if we use
            // the VPICD_Get() function the compiler will
            // readjust the stack upon return, therefore
            // destroying the CY flag.  So, let's just
            // call VPICD directly.
            //
            //VPICD_Get_IRQ_Complete_Status(IRQnum, VMh);
            __asm xor ecx,ecx
            __asm mov eax,IRQnum
            VxDCall(VPICD_Get_IRQ_Complete_Status)
			_asm	sbb		eax, eax				// set return value to carry value        
        
}

U032 vmmGARTReserve(U032 pDevObj, U032 ulNumPages, U032 ulAlignMask, U032 pulGARTDev, U032 ulFlags)
{
			_asm {
			        push	ulFlags
			        push	pulGARTDev			
			        push	ulAlignMask			
			        push	ulNumPages			
			        push	pDevObj
            }                    			
            CALL_VMM(_GARTReserve)                  
			_asm 	add	esp,5*4
}

U032 vmmGARTCommit(U032 pGARTLin, U032 ulPageOffset, U032 ulNumPages, U032 pulGARTDev, U032 ulFlags)
{
			_asm {
			        push	ulFlags
			        push	pulGARTDev			
			        push	ulNumPages			
			        push	ulPageOffset			
			        push	pGARTLin
            }                    			
            CALL_VMM(_GARTCommit)                  
			_asm 	add	esp,5*4
}

U032 vmmGARTUnCommit(U032 pGARTLin, U032 ulPageOffset, U032 ulNumPages)
{
			_asm {
			        push	ulNumPages			
			        push	ulPageOffset			
			        push	pGARTLin
            }                    			
            CALL_VMM(_GARTUncommit)                  
			_asm 	add	esp,3*4
}

U032 vmmGARTFree(U032 pGARTLin)
{
			_asm {
			        push	pGARTLin
            }                    			
            CALL_VMM(_GARTFree)                  
			_asm 	add	esp,1*4
}

U032 vmmGARTMemAttributes(U032 pGARTLin, U032 ulFlags)
{
			_asm {
			        push	ulFlags
			        push	pGARTLin
            }                    			
            CALL_VMM(_GARTMemAttributes)                  
			_asm 	add	esp,2*4
}

U032 mtrrGetVersion(VOID)
{
            CALL_VMM(_MTRR_Get_Version) 
}


// called as        mtrrSetPhysicalCacheTypeRange(nvInfo->Mapping.PhysFbAddr, 0, 0x400000, 0);
U032 mtrrSetPhysicalCacheTypeRange(U032 arg1, U032 arg2, U032 arg3, U032 arg4)
{
			_asm {
            	push	arg4
                push	arg3
                push	arg2
                push	arg1
			}
            CALL_VMM(_MTRRSetPhysicalCacheTypeRange)           
//			_asm	add	esp,16		// the callee adjusted the stack
}

U016 vddGetVersion(VOID)
{
            CALL_VDD(VDD_Get_Version)        
}

U032 vddGetDisplayInfo(U032 OsDeviceHandle, PDISPLAYINFO Info, U032 infoSize)
{
			_asm	mov		eax, Info
            _asm    mov     ebx, OsDeviceHandle
            _asm	mov		ecx, infoSize
            CALL_VDD(VDD_Get_DISPLAYINFO)    
}

//	write null terminated string to the debugging device
VOID vmmOutDebugString(char *String)	
{
		_asm	pushfd				
		_asm	pushad				
		_asm 	mov esi, String		
		CALL_VMM(Out_Debug_String)	
		_asm	popad				
		_asm	popfd
}

//	write null terminated string to the debugging device
//	the string contains a register placeholder, so the actual register value will be printed also
VOID vmmOutDebugStringValue(char *String, U032 Value)	
{
		_asm	mov eax, Value
		_asm	pushfd				
		_asm	pushad				
		_asm 	mov esi, String		
		CALL_VMM(Out_Debug_String)	
		_asm	popad				
		_asm	popfd
}

VOID	dbgBreakPoint()
{
	_asm	int	3
}

#ifdef DEBUG
// Test if the debugger is installed.
U032 vmmTestDebugInstalled(void)	
{
  U032 return_val;
          
  CALL_VMM(Test_Debug_Installed)
  _asm  mov    return_val,0  
  _asm	jz     installedExit      
  _asm  mov    return_val,1  
  _asm	installedExit:     
  return(return_val);       
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\inc\NVHW.H ===
#ifndef _NVHW_H_
#define _NVHW_H_
/**************************************************************************************************************
*
*	Module:  nvhw.h
*
*	Description:
*		Hardware access macros for the resource manager.
*
*
*	Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.   
*	                                                                 
*	NOTICE TO USER:   The source code  is copyrighted under  U.S. and
*	international laws.   NVIDIA, Corp. of Sunnyvale, California owns
*	the copyright  and as design patents  pending  on the design  and
*	interface  of the NV chips.   Users and possessors of this source
*	code are hereby granted  a nonexclusive,  royalty-free  copyright
*	and  design  patent license  to use this code  in individual  and
*	commercial software.                                             
*	                                                                 
*	Any use of this source code must include,  in the user documenta-
*	tion and  internal comments to the code,  notices to the end user
*	as follows:                                                      
*	                                                                 
*	Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents
*	pending in the U.S. and foreign countries.                       
*	                                                                 
*	NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF
*	THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT
*	EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS
*	ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL
*	IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A
*	PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE
*	FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,
*	OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR
*	PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER
*	TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR
*	PERFORMANCE OF THIS SOURCE CODE.                                 
*                                                                      
*************************************************************************************************************/

/*
	The REG_WR..() and REG_RD..() macros are used to access the NV registers.
	Actual address are passed in then scaled to the correct size of access,
	so no prescaling is necessary.  Just use the register address defined
	in the reference manuals, e.g. nv.._ref.h.
*/
#define REG_WR08(a,d)   (osWriteReg008((U008*)&nvAddr->Reg008[(a)  ], (U008)(d)))
#define REG_WR16(a,d)   (osWriteReg016((U016*)&nvAddr->Reg016[(a)/2], (U016)(d)))
#define REG_WR32(a,d)   (osWriteReg032((U032*)&nvAddr->Reg032[(a)/4], (U032)(d)))
#define REG_RD08(a)     (osReadReg008 ((U008*)&nvAddr->Reg008[(a)  ])			)
#define REG_RD16(a)     (osReadReg016 ((U016*)&nvAddr->Reg016[(a)/2])			)
#define REG_RD32(a)     (osReadReg032 ((U032*)&nvAddr->Reg032[(a)/4])			)

/*
	The REG_WR..DIRECT() and REG_RD..DIRECT() macros are used to access the NV 
    registers given as system addresses.  System addresses of the registers
    are passed in.  A read is made directly from that address, without manipulation. 
*/
#define REG_WR08_DIRECT(a,d)   (osWriteReg008((a), (d)))
#define REG_WR16_DIRECT(a,d)   (osWriteReg016((a), (d)))
#define REG_WR32_DIRECT(a,d)   (osWriteReg032((a), (d)))
#define REG_RD08_DIRECT(a)     (osReadReg008 ((a)     ))
#define REG_RD16_DIRECT(a)     (osReadReg016 ((a)     ))
#define REG_RD32_DIRECT(a)     (osReadReg032 ((a)     ))

/*
	The MEM_WR..() and MEM_RD..() macros are used to access the frame buffer
	memory.  Actual addresses are passed in then scaled to the correct size of
	access, so no prescaling is necessary.  Just use the actual byte address
	of the frame buffer that needs to be accessed.  

	Note:  For NV3, these macros are used to access instance memory directly.
	So, passing in a 0 would access the first location of instance memory, 
	which is at the end of the frame buffer, i.e. at an offset of NV_PRAMIN
	from the beginning of the frame buffer.
*/

// frame buffer access macros
// for NV4 and above, fbAddr actually points to the frame buffer
#define MEM_BASE		(0)
#define MEM_WR08(a,d)   (osWriteReg008((U008*)&fbAddr->Reg008[((a)-MEM_BASE)  ], (U008)(d)))
#define MEM_WR16(a,d)   (osWriteReg016((U016*)&fbAddr->Reg016[((a)-MEM_BASE)/2], (U016)(d)))
#define MEM_WR32(a,d)   (osWriteReg032((U032*)&fbAddr->Reg032[((a)-MEM_BASE)/4], (U032)(d)))
#define MEM_RD08(a)     (osReadReg008 ((U008*)&fbAddr->Reg008[((a)-MEM_BASE)  ])		   )
#define MEM_RD16(a)     (osReadReg016 ((U016*)&fbAddr->Reg016[((a)-MEM_BASE)/2])		   )
#define MEM_RD32(a)     (osReadReg032 ((U032*)&fbAddr->Reg032[((a)-MEM_BASE)/4])		   )

#define FB_WR08(a,d)   (osWriteReg008((U008*)&fbAddr->Reg008[(a)  ], (U008)(d)))
#define FB_WR16(a,d)   (osWriteReg016((U016*)&fbAddr->Reg016[(a)/2], (U016)(d)))
#define FB_WR32(a,d)   (osWriteReg032((U032*)&fbAddr->Reg032[(a)/4], (U032)(d)))
#define FB_RD08(a)     (osReadReg008 ((U008*)&fbAddr->Reg008[(a)  ])		   )
#define FB_RD16(a)     (osReadReg016 ((U016*)&fbAddr->Reg016[(a)/2])		   )
#define FB_RD32(a)     (osReadReg032 ((U032*)&fbAddr->Reg032[(a)/4])		   )

/*
	The ROM_RD..() and BIOS_RD..() macros are used to read data from the BIOS, an image of 
	which resides in the first 64K of instance memory.
*/

// ROM access macros
#define ROM_RD08(a)     ((osReadReg008((U008*)&romAddr->Reg008[(a)  ])    ))
#define ROM_RD16(a)     ((osReadReg008((U008*)&romAddr->Reg008[(a)  ])	  )\
                        |(osReadReg008((U008*)&romAddr->Reg008[(a)+1])<<8 ))
#define ROM_RD32(a)     ((osReadReg008((U008*)&romAddr->Reg008[(a)  ])    )\
                        |(osReadReg008((U008*)&romAddr->Reg008[(a)+1])<<8 )\
                        |(osReadReg008((U008*)&romAddr->Reg008[(a)+2])<<16)\
                        |(osReadReg008((U008*)&romAddr->Reg008[(a)+3])<<24))

// BIOS access macros
#define BIOS_RD08(a)    ((osReadReg008((U008*)&biosAddr->Reg008[(a)  ])    ))
#define BIOS_RD16(a)    ((osReadReg008((U008*)&biosAddr->Reg008[(a)  ])	  )\
                        |(osReadReg008((U008*)&biosAddr->Reg008[(a)+1])<<8 ))
#define BIOS_RD32(a)    ((osReadReg008((U008*)&biosAddr->Reg008[(a)  ])    )\
                        |(osReadReg008((U008*)&biosAddr->Reg008[(a)+1])<<8 )\
                        |(osReadReg008((U008*)&biosAddr->Reg008[(a)+2])<<16)\
                        |(osReadReg008((U008*)&biosAddr->Reg008[(a)+3])<<24))

#endif // _NVHW_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\nv4\nv04wtch.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995-2000. All rights reserved.
// (C) Copyright SGS-THOMSON Microelectronics Inc., 1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NV04wtch.C                                                        *
*   Winice .N Debug Interface. NV04 code                                    *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Vito 2/6/98
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"        // put this first. we redefine macro SF_BIT in nvrm.h
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vpicd.h"
#include "vdd.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vmm2.h"       // more vmm services
#include "vwin32.h"
#include "nv4_hal.h"

#ifdef DEBUG

//
// prototypes
//
U032 NvWatch_GetObjectFromInst  (PHWINFO, U032, U032 *);
U032 NvWatch_Dump_HT_Object_From_Handle(PHWINFO, U032);
VOID NvWatch_display_prompt     (PHWINFO, char *);
char get_winice_input           (VOID);

//
// defines
//
#define NVWATCH_SIMPLE      0
#define NVWATCH_COMPLEX     1
#define INSTANCE_MEM_SPACE  nvAddr 

//****NV CONTEXT MENU******************************************************************************

void NvWatch_NV04_Dump_SubChannelContext(PHWINFO pDev, U032 p_channel)
{
  U032  sub_counter;
  U032  nvwatch_fifo_engine_cache1;
  U032  enginet, *inst_ptr, tempv;

  nvwatch_fifo_engine_cache1 = REG_RD32(NV_PFIFO_CACHE1_ENGINE);
  // For each subchannel (Dump the Engine, then the object).
  for(sub_counter=0;sub_counter<NUM_SUBCHANNELS;sub_counter++){
    enginet = nvwatch_fifo_engine_cache1;
    enginet &= 3;
    switch(enginet){
      case 0:
        // We need to get the channel.
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Software Object in Fifo cache0 for Subchannel ",sub_counter);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Accessing pDev->DBfifoTable ...");
        if (pDev->DBfifoTable[p_channel].InUse == FALSE)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: pDev->DBfifoTable NOT InUse !??");
        else{
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Object Name = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->Name);
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Object Class = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->Class->Type);
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "CHID = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->ChID);
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Subchannel = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->Subchannel);
//////    U032       Name;
//////    PCLASS     Class;
//////    U032       ChID;
//////    U032       Subchannel;
//////    NODE       Node[NUM_FIFOS];
//////    POBJECT    Next;
//////    PDMAOBJECT NotifyXlate;
//////    U032       NotifyAction;
//////    U032       NotifyTrigger;
//////    PEVENTNOTIFICATION NotifyEvent;
        }  
        break;
      case 1:
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Graphics Object in Fifo cache0 for Subchannel ",sub_counter);
        
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE1 = ",REG_RD32(NV_PGRAPH_CTX_CACHE1(sub_counter)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE2 = ",REG_RD32(NV_PGRAPH_CTX_CACHE2(sub_counter)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE3 = ",REG_RD32(NV_PGRAPH_CTX_CACHE3(sub_counter)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE4 = ",REG_RD32(NV_PGRAPH_CTX_CACHE4(sub_counter)));
        
        tempv = (U032) REG_RD32( NV_PGRAPH_CTX_CACHE4(sub_counter) );
        tempv &= 0xFFFF;
        tempv <<= 4;
        tempv += (U032) (INSTANCE_MEM_SPACE + (pDev->Pram.HalInfo.PraminOffset/4));
        inst_ptr = (U032 *) tempv;
        
        {
          U032 DHandle;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nDumping the CTX_CACHE4 Object ...");
          tempv = (U032) REG_RD32( NV_PGRAPH_CTX_CACHE4(sub_counter) );
          tempv &= 0xFFFF;
          if(!NvWatch_GetObjectFromInst(pDev, tempv, &DHandle))
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: Object NOT FOUND !\n");
          else{  
            NvWatch_Dump_HT_Object_From_Handle(pDev, DHandle);
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n");
          }  
        }
        break;
      case 2:
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DVD Object in Fifo cache0 for Subchannel ",sub_counter);
        break;
      default:
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: INVALID Object in Fifo cache0!");
        break;
    }
    nvwatch_fifo_engine_cache1 >>= 4;
  }
}

void NvWatch_NV04_ContextInfo_help(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCommands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      s   - Query SubChannel Contexts (Currently supports active channel ONLY\n\r");
//  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "            Active Channel = ",NvWatch_channel);
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      ?   - ???\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      q   - quit this\n\r\n\r");
}

VOID NvWatch_NV04_Query_DeviceContext(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  U032 m_channel=0;
  char pstring[]="NvWatch Context";

  NvWatch_NV04_ContextInfo_help(pDev);
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;
      case 's':
      case 'S':
        {
          U032 save_pgraph_fifo;
          
          // Clear the NV_PGRAPH_FIFO so that it can be read.
          save_pgraph_fifo = REG_RD32(NV_PGRAPH_FIFO);
          REG_WR32(NV_PGRAPH_FIFO, 0);
          NvWatch_NV04_Dump_SubChannelContext(pDev, m_channel);
          // Restore the NV_PGRAPH_FIFO.
          REG_WR32(NV_PGRAPH_FIFO, save_pgraph_fifo);
        }  
        break;
      case 'c': // Dump hash table
      case 'C': // Dump hash table
        break;
      default: // Help
        NvWatch_NV04_ContextInfo_help(pDev);
        break;  
    }
  }
}

//****DMA PUSHER AND FIFO MENU******************************************************************************

// THE FIFO: Actually 2X the HW size. A second alias image exists.
//-----------------------------------------
//|0                                      | <-- PFIFO_PUT (word pointer)
//|---------------------------------------| <-- PFIFO_GET ( "     "    )
//|1                                      |
//|---------------------------------------| If PFIFO_PUT==PFIFO_GET then the Fifo is empty
//|2                                      |
//|---------------------------------------| If (PFIFO_PUT+128)%256==PFIFO_GET then the Fifo is full
//|...                                    |
//|---------------------------------------| 0 <= PFIFO_PUT, PFIFO_GET <= 255*4
//|---------------------------------------|
//|127                                    |
//|---------------------------------------|
//|128 == 0 alias                         |
//|---------------------------------------|
//|129 == 1 alias                         |
//|---------------------------------------|
//|...                                    |
//|---------------------------------------|
//|---------------------------------------|
//|255 == 127 alias                       |
//-----------------------------------------
void NvWatch_NV04_DumpFifoContents(PHWINFO pDev)
{
  U032 save_puller, save_pusher;
  U032 nvw_fifo_get,nvw_fifo_put;
  U032 fifo_count;
  BOOL fifo_is_empty=FALSE,fifo_is_full=FALSE;
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
  
  // In order to dump the fifo the puller and pusher must be disabled.
  save_puller = REG_RD32(NV_PFIFO_CACHE1_PULL0);
  save_pusher = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
  REG_WR32(NV_PFIFO_CACHE1_PULL0,0);
  REG_WR32(NV_PFIFO_CACHE1_PUSH0,0);

  // The Fifo is 128 entries deep.
  nvw_fifo_get = REG_RD32(NV_PFIFO_CACHE1_GET);
  nvw_fifo_put = REG_RD32(NV_PFIFO_CACHE1_PUT);

  for(fifo_count=0;fifo_count<128;fifo_count++){
    
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, fifo_count);
    
    if( ( ( (nvw_fifo_get%(128*4)) /4) == fifo_count) && (( (nvw_fifo_put%(128*4)) /4) == fifo_count)){
      if(nvw_fifo_get == nvw_fifo_put)
        fifo_is_empty = TRUE;
      else  
        fifo_is_full = TRUE;
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,    " PFIFO_GET->\n");
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,    "           PFIFO_PUT-> Method = ");
    }else{
      if(( (nvw_fifo_get%(128*4)) /4) == fifo_count)
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  " PFIFO_GET-> Method = ");
      else{  
        if(( (nvw_fifo_put%(128*4)) /4) == fifo_count)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS," PFIFO_PUT-> Method = ");
        else
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"             Method = ");
      }  
    }  
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, REG_RD32(NV_PFIFO_CACHE1_METHOD(fifo_count)) );
    
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"             Data = ");
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, REG_RD32(NV_PFIFO_CACHE1_DATA(fifo_count)) );
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
  }

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Fifo Methods decode as 15:13-Subchannel 12:2-Method offset.\n");

  if(fifo_is_empty){
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nThe Fifo is EMPTY\n\r");
  }else{
    if(fifo_is_full){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nThe Fifo is FULL\n\r");
    }else{
      // This should be an error !!! Never full and Empty!
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: The Fifo is Neither FULL or EMPTY!!!\n\r");
    }
  }  
  
  // Restore the pusher and puller registers.
  REG_WR32(NV_PFIFO_CACHE1_PULL0,save_puller);
  REG_WR32(NV_PFIFO_CACHE1_PUSH0,save_pusher);
}

void NvWatch_NV04_DumpUserDmaBuffersAtGet(PHWINFO pDev)
{
    U032 channel_count;
    U032 current_channel;
    U032 channel_get;
    U032 channel_dma_inst;
    U032 channel_get_page, channel_get_offset,channel_dmabuffer_physical;
    U032 *instance_data_ptr, *instance_pte_ptr;

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n*********************************************");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCalculating Physical addresses for PushBuffers\n");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,   "*********************************************\n");

    current_channel = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    for(channel_count=0;channel_count<NUM_FIFOS;channel_count++){
        // Is this channel running in DMA Mode ?
        if((REG_RD32(NV_PFIFO_MODE)>>channel_count)&1){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DMA Channel=",(int)channel_count);
            // Get the get pointer value.
            // From fifo context or the fifo engine ?
            if(channel_count==current_channel){
                // Go to the fifo engine.
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "This is the current channel=",(int)channel_count);
                channel_get = REG_RD32(NV_PFIFO_CACHE1_DMA_GET);
                channel_dma_inst = REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The get pointer from the fifo engine=",(int)         channel_get);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The dma instance from the fifo engine=",(int)channel_dma_inst);

            }else{
                // Go to the fifo context area in instance memory.
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "This is NOT the current channel=",(int)channel_count);
                {
                   U032 *ptr_fifocontextarea;

                   switch(REG_RD_DRF(_PFIFO, _RAMHT, _SIZE)){
                     case NV_PFIFO_RAMHT_SIZE_4K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x1000) /4) );
                       break;
                     case NV_PFIFO_RAMHT_SIZE_8K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x2000) /4) );
                       break;
                     case NV_PFIFO_RAMHT_SIZE_16K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x4000) /4) );
                       break;
                     case NV_PFIFO_RAMHT_SIZE_32K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x8000) /4) );
                       break;
                   }
                   channel_get = (U032) *(ptr_fifocontextarea+1+(channel_count*8));
                   channel_dma_inst = (U032) *(ptr_fifocontextarea+3+(channel_count*8));
                   channel_dma_inst &= 0xFFFF;
                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The get pointer from the fifo context=",(int)         channel_get);
                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The dma instance from the fifo context=",(int)channel_dma_inst);
                }
            } // equal current channel

            channel_get_page = (U032) channel_get >> 12;
            channel_get_offset = (U032) channel_get & 0xFFF;
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Channel get pointers page=",(int)   channel_get_page);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Channel get pointers offset=",(int) channel_get_offset);


            instance_data_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset+(channel_dma_inst<<4))/4));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Linear address of Push buffer context=",(int)instance_data_ptr);
            // System memory DMA contexts will have all of the PTE's listed in instance memory.(scatter/gather)
            // AGP and FB DMA Contexts will only require a base DMA context.
            // Check the type bits of the DMA context in instance memory.
            switch( ((*instance_data_ptr)>>16) & 3){
                case 2: /*system memory*/
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PUSH_BUFFER in SYSTEM MEMORY\n");
                    instance_pte_ptr = (U032 *) instance_data_ptr + (2+channel_get_page);
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Linear address of Push buffer context PTE=",(int)instance_pte_ptr);
                    channel_dmabuffer_physical = (U032) ((*instance_pte_ptr)&0xFFFFF000)+channel_get_offset;
                    break;
                case 3: /*AGP system memory*/
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PUSH_BUFFER in AGP SYSTEM MEMORY\n");
                    instance_pte_ptr = (U032 *) instance_data_ptr + (2);
                    channel_dmabuffer_physical = (U032) ((*instance_pte_ptr)&0xFFFFF000)+channel_get;
                    break;
                case 0: /*frame buffer NVM*/
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PUSH_BUFFER in FRAME BUFFER MEMORY\n");
                    instance_pte_ptr = (U032 *) instance_data_ptr + (2);
                    channel_dmabuffer_physical = (U032) ((*instance_pte_ptr)&0xFFFFF000)+channel_get;
                    break;
            }
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Physical address of Push buffer at the get pointer=",(int)channel_dmabuffer_physical);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Don't forget the 12bit ADJUST value for the DMA Context=",(int)((*instance_data_ptr)>>20));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "ADJUSTED Physical address of Push buffer at the get pointer=",(int)(channel_dmabuffer_physical+((*instance_data_ptr)>>20)));
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        } // DMA Mode
    }
}

void NvWatch_NV04_DmaPushAndFifo_help(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCommands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      f   - Dump Fifo Contents\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      c   - Get Physical address of DmaBuffers at Current Get ptr.(DmaPush channels only)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      d   - Dump DmaPusher Info (Not Implemented)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit this\n\r\n\r");
}

void NvWatch_NV04_DmaPushAndFifo(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  char pstring[]="NvWatch Fifo";

  NvWatch_NV04_DmaPushAndFifo_help(pDev);
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;
      case 'f': // Dump fifo 
      case 'F': // Dump fifo 
        NvWatch_NV04_DumpFifoContents(pDev);
        break;
      case 'c': 
      case 'C': 
        NvWatch_NV04_DumpUserDmaBuffersAtGet(pDev);
        break;
      case 'b': 
      case 'B': 
        break;
      default: // Help
        NvWatch_NV04_DmaPushAndFifo_help(pDev);
        break;  
    }
  }
}

void NvWatch_NV04_Dump_Graphics(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nGraphics Engine State:\r\n");
 
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_0             0x00400080  RW-4R  = ", REG_RD32(   NV_PGRAPH_DEBUG_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_1             0x00400084  RW-4R  = ", REG_RD32(   NV_PGRAPH_DEBUG_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_2             0x00400088  RW-4R  = ", REG_RD32(   NV_PGRAPH_DEBUG_2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_3             0x0040008C  RW-4R  = ", REG_RD32(   NV_PGRAPH_DEBUG_3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_INTR                0x00400100  RW-4R  = ", REG_RD32(   NV_PGRAPH_INTR                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_NSOURCE             0x00400108  R--4R  = ", REG_RD32(   NV_PGRAPH_NSOURCE               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_INTR_EN             0x00400140  RW-4R  = ", REG_RD32(   NV_PGRAPH_INTR_EN               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_SWITCH1         0x00400160  RW-4R  = ", REG_RD32(   NV_PGRAPH_CTX_SWITCH1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_SWITCH2         0x00400164  RW-4R  = ", REG_RD32(   NV_PGRAPH_CTX_SWITCH2           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_SWITCH3         0x00400168  RW-4R  = ", REG_RD32(   NV_PGRAPH_CTX_SWITCH3           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_CONTROL         0x00400170  RW-4R  = ", REG_RD32(   NV_PGRAPH_CTX_CONTROL           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_USER            0x00400174  RW-4R  = ", REG_RD32(   NV_PGRAPH_CTX_USER              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FIFO                0x00400720  RW-4R  = ", REG_RD32(   NV_PGRAPH_FIFO                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FFINTFC_ST2         0x00400754  RW-4R  = ", REG_RD32(   NV_PGRAPH_FFINTFC_ST2           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_STATUS              0x00400700  R--4R  = ", REG_RD32(   NV_PGRAPH_STATUS                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_TRAPPED_ADDR        0x00400704  R--4R  = ", REG_RD32(   NV_PGRAPH_TRAPPED_ADDR          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_TRAPPED_DATA        0x00400708  R--4R  = ", REG_RD32(   NV_PGRAPH_TRAPPED_DATA          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_SURFACE             0x0040070C  RW-4R  = ", REG_RD32(   NV_PGRAPH_SURFACE               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_NOTIFY              0x00400714  RW-4R  = ", REG_RD32(   NV_PGRAPH_NOTIFY                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET0            0x00400640  RW-4R  = ", REG_RD32(   NV_PGRAPH_BOFFSET0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET1            0x00400644  RW-4R  = ", REG_RD32(   NV_PGRAPH_BOFFSET1              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET2            0x00400648  RW-4R  = ", REG_RD32(   NV_PGRAPH_BOFFSET2              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET3            0x0040064C  RW-4R  = ", REG_RD32(   NV_PGRAPH_BOFFSET3              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET4            0x00400650  RW-4R  = ", REG_RD32(   NV_PGRAPH_BOFFSET4              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET5            0x00400654  RW-4R  = ", REG_RD32(   NV_PGRAPH_BOFFSET5              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE0              0x00400658  RW-4R  = ", REG_RD32(   NV_PGRAPH_BBASE0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE1              0x0040065c  RW-4R  = ", REG_RD32(   NV_PGRAPH_BBASE1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE2              0x00400660  RW-4R  = ", REG_RD32(   NV_PGRAPH_BBASE2                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE3              0x00400664  RW-4R  = ", REG_RD32(   NV_PGRAPH_BBASE3                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE4              0x00400668  RW-4R  = ", REG_RD32(   NV_PGRAPH_BBASE4                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE5              0x0040066C  RW-4R  = ", REG_RD32(   NV_PGRAPH_BBASE5                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH0             0x00400670  RW-4R  = ", REG_RD32(   NV_PGRAPH_BPITCH0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH1             0x00400674  RW-4R  = ", REG_RD32(   NV_PGRAPH_BPITCH1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH2             0x00400678  RW-4R  = ", REG_RD32(   NV_PGRAPH_BPITCH2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH3             0x0040067C  RW-4R  = ", REG_RD32(   NV_PGRAPH_BPITCH3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH4             0x00400680  RW-4R  = ", REG_RD32(   NV_PGRAPH_BPITCH4               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT0             0x00400684  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLIMIT0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT1             0x00400688  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLIMIT1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT2             0x0040068c  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLIMIT2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT3             0x00400690  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLIMIT3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT4             0x00400694  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLIMIT4               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT5             0x00400698  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLIMIT5               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BSWIZZLE2           0x0040069c  RW-4R  = ", REG_RD32(   NV_PGRAPH_BSWIZZLE2             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BSWIZZLE5           0x004006a0  RW-4R  = ", REG_RD32(   NV_PGRAPH_BSWIZZLE5             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPIXEL              0x00400724  RW-4R  = ", REG_RD32(   NV_PGRAPH_BPIXEL                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_LIMIT_VIOL_Z        0x00400614  RW-4R  = ", REG_RD32(   NV_PGRAPH_LIMIT_VIOL_Z          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_STATE               0x00400710  RW-4R  = ", REG_RD32(   NV_PGRAPH_STATE                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CACHE_INDEX         0x00400728  RW-4R  = ", REG_RD32(   NV_PGRAPH_CACHE_INDEX           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CACHE_RAM           0x0040072c  RW-4R  = ", REG_RD32(   NV_PGRAPH_CACHE_RAM             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_PITCH           0x00400760  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_PITCH             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DVD_COLORFMT        0x00400764  RW-4R  = ", REG_RD32(   NV_PGRAPH_DVD_COLORFMT          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_SCALED_FORMAT       0x00400768  RW-4R  = ", REG_RD32(   NV_PGRAPH_SCALED_FORMAT         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PATT_COLOR0         0x00400800  RW-4R  = ", REG_RD32(   NV_PGRAPH_PATT_COLOR0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PATT_COLOR1         0x00400804  RW-4R  = ", REG_RD32(   NV_PGRAPH_PATT_COLOR1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PATTERN_SHAPE       0x00400810  RW-4R  = ", REG_RD32(   NV_PGRAPH_PATTERN_SHAPE         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MONO_COLOR0         0x00400600  RW-4R  = ", REG_RD32(   NV_PGRAPH_MONO_COLOR0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ROP3                0x00400604  RW-4R  = ", REG_RD32(   NV_PGRAPH_ROP3                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CHROMA              0x00400814  RW-4R  = ", REG_RD32(   NV_PGRAPH_CHROMA                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BETA_AND            0x00400608  RW-4R  = ", REG_RD32(   NV_PGRAPH_BETA_AND              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BETA_PREMULT        0x0040060c  RW-4R  = ", REG_RD32(   NV_PGRAPH_BETA_PREMULT          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CONTROL0            0x00400818  RW-4R  = ", REG_RD32(   NV_PGRAPH_CONTROL0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CONTROL2            0x00400820  RW-4R  = ", REG_RD32(   NV_PGRAPH_CONTROL2              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLEND               0x00400824  RW-4R  = ", REG_RD32(   NV_PGRAPH_BLEND                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DPRAM_INDEX         0x00400828  RW-4R  = ", REG_RD32(   NV_PGRAPH_DPRAM_INDEX           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DPRAM_DATA          0x0040082c  RW-4R  = ", REG_RD32(   NV_PGRAPH_DPRAM_DATA            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_STORED_FMT          0x00400830  RW-4R  = ", REG_RD32(   NV_PGRAPH_STORED_FMT            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FORMATS             0x00400618  RW-4R  = ", REG_RD32(   NV_PGRAPH_FORMATS               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC0      0x00400514  RW-4R  = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC0        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC1      0x00400518  RW-4R  = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC1        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC2      0x0040051C  RW-4R  = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC2        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC3      0x00400520  RW-4R  = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC3        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_X_MISC              0x00400500  RW-4R  = ", REG_RD32(   NV_PGRAPH_X_MISC                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_Y_MISC              0x00400504  RW-4R  = ", REG_RD32(   NV_PGRAPH_Y_MISC                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_XMIN      0x0040053C  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_XMIN        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_XMAX      0x00400544  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_XMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_YMIN      0x00400540  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_YMIN        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_YMAX      0x00400548  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_YMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_XMIN     0x00400560  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_XMIN       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_XMAX     0x00400568  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_XMAX       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_YMIN     0x00400564  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_YMIN       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_YMAX     0x0040056C  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_YMAX       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_SOURCE_COLOR        0x0040050C  RW-4R  = ", REG_RD32(   NV_PGRAPH_SOURCE_COLOR          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_VALID1              0x00400508  RW-4R  = ", REG_RD32(   NV_PGRAPH_VALID1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_VALID2              0x00400578  RW-4R  = ", REG_RD32(   NV_PGRAPH_VALID2                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_ICLIP_XMAX      0x00400534  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_ICLIP_XMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_ICLIP_YMAX      0x00400538  RW-4R  = ", REG_RD32(   NV_PGRAPH_ABS_ICLIP_YMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPX_0             0x00400524  RW-4R  = ", REG_RD32(   NV_PGRAPH_CLIPX_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPX_1             0x00400528  RW-4R  = ", REG_RD32(   NV_PGRAPH_CLIPX_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPY_0             0x0040052c  RW-4R  = ", REG_RD32(   NV_PGRAPH_CLIPY_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPY_1             0x00400530  RW-4R  = ", REG_RD32(   NV_PGRAPH_CLIPY_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MISC24_0            0x00400510  RW-4R  = ", REG_RD32(   NV_PGRAPH_MISC24_0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MISC24_1            0x00400570  RW-4R  = ", REG_RD32(   NV_PGRAPH_MISC24_1              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MISC24_2            0x00400574  RW-4R  = ", REG_RD32(   NV_PGRAPH_MISC24_2              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PASSTHRU_0          0x0040057C  RW-4R  = ", REG_RD32(   NV_PGRAPH_PASSTHRU_0            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PASSTHRU_1          0x00400580  RW-4R  = ", REG_RD32(   NV_PGRAPH_PASSTHRU_1            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PASSTHRU_2          0x00400584  RW-4R  = ", REG_RD32(   NV_PGRAPH_PASSTHRU_2            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_XY              0x004005c0  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_XY                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_U0              0x004005c4  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_U0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_V0              0x004005c8  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_V0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_U1              0x004005cc  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_U1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_V1              0x004005d0  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_V1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_ZETA            0x004005d4  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_ZETA              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_RGB             0x004005d8  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_RGB               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_S               0x004005dc  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_S                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_M               0x004005e0  RW-4R  = ", REG_RD32(   NV_PGRAPH_D3D_M                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FORMAT0             0x004005A8  RW-4R  = ", REG_RD32(   NV_PGRAPH_FORMAT0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FORMAT1             0x004005AC  RW-4R  = ", REG_RD32(   NV_PGRAPH_FORMAT1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FILTER0             0x004005B0  RW-4R  = ", REG_RD32(   NV_PGRAPH_FILTER0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FILTER1             0x004005B4  RW-4R  = ", REG_RD32(   NV_PGRAPH_FILTER1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE0ALPHA       0x00400590  RW-4R  = ", REG_RD32(   NV_PGRAPH_COMBINE0ALPHA         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE0COLOR       0x00400594  RW-4R  = ", REG_RD32(   NV_PGRAPH_COMBINE0COLOR         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE1ALPHA       0x00400598  RW-4R  = ", REG_RD32(   NV_PGRAPH_COMBINE1ALPHA         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE1COLOR       0x0040059C  RW-4R  = ", REG_RD32(   NV_PGRAPH_COMBINE1COLOR         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_START_0         0x00401000  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_START_0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_START_1         0x00401004  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_START_1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_LENGTH          0x00401008  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_LENGTH            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_MISC            0x0040100C  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_MISC              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_DATA_0          0x00401020  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_DATA_0            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_DATA_1          0x00401024  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_DATA_1            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_RM              0x00401030  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_RM                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_XLATE_INST    0x00401040  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_XLATE_INST      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_CONTROL       0x00401044  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_CONTROL         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_LIMIT         0x00401048  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_LIMIT           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_TLB_PTE       0x0040104C  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_TLB_PTE         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_TLB_TAG       0x00401050  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_TLB_TAG         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_ADJ_OFFSET    0x00401054  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_ADJ_OFFSET      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_OFFSET        0x00401058  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_OFFSET          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_SIZE          0x0040105C  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_SIZE            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_Y_SIZE        0x00401060  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_A_Y_SIZE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_XLATE_INST    0x00401080  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_XLATE_INST      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_CONTROL       0x00401084  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_CONTROL         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_LIMIT         0x00401088  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_LIMIT           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_TLB_PTE       0x0040108C  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_TLB_PTE         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_TLB_TAG       0x00401090  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_TLB_TAG         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_ADJ_OFFSET    0x00401094  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_ADJ_OFFSET      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_OFFSET        0x00401098  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_OFFSET          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_SIZE          0x0040109C  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_SIZE            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_Y_SIZE        0x004010A0  RW-4R  = ", REG_RD32(   NV_PGRAPH_DMA_B_Y_SIZE          ));
}  

void NvWatch_NV04_Dump_Fifo(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nFifo State:\r\n");
  
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DELAY_0              0x00002040  RW-4R  = ", REG_RD32(   NV_PFIFO_DELAY_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DMA_TIMESLICE        0x00002044  RW-4R  = ", REG_RD32(   NV_PFIFO_DMA_TIMESLICE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_PIO_TIMESLICE        0x00002048  RW-4R  = ", REG_RD32(   NV_PFIFO_PIO_TIMESLICE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_TIMESLICE            0x0000204C  RW-4R  = ", REG_RD32(   NV_PFIFO_TIMESLICE              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_NEXT_CHANNEL         0x00002050  RW-4R  = ", REG_RD32(   NV_PFIFO_NEXT_CHANNEL           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DEBUG_0              0x00002080  R--4R  = ", REG_RD32(   NV_PFIFO_DEBUG_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_INTR_0               0x00002100  RW-4R  = ", REG_RD32(   NV_PFIFO_INTR_0                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_INTR_EN_0            0x00002140  RW-4R  = ", REG_RD32(   NV_PFIFO_INTR_EN_0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RAMHT                0x00002210  RW-4R  = ", REG_RD32(   NV_PFIFO_RAMHT                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RAMFC                0x00002214  RW-4R  = ", REG_RD32(   NV_PFIFO_RAMFC                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RAMRO                0x00002218  RW-4R  = ", REG_RD32(   NV_PFIFO_RAMRO                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHES               0x00002500  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHES                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_MODE                 0x00002504  RW-4R  = ", REG_RD32(   NV_PFIFO_MODE                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DMA                  0x00002508  RW-4R  = ", REG_RD32(   NV_PFIFO_DMA                    ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_SIZE                 0x0000250C  RW-4R  = ", REG_RD32(   NV_PFIFO_SIZE                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PUSH0         0x00003000  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_PUSH0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PUSH0         0x00003200  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_PUSH0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PUSH1         0x00003004  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_PUSH1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PUSH1         0x00003204  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_PUSH1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_PUSH      0x00003220  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_PUSH        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_FETCH     0x00003224  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_FETCH       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_PUT       0x00003240  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_PUT         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_GET       0x00003244  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_GET         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_STATE     0x00003228  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_STATE       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_INSTANCE  0x0000322C  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_INSTANCE    ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_CTL       0x00003230  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_CTL         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_LIMIT     0x00003234  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_LIMIT       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_TLB_TAG   0x00003238  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_TLB_TAG     ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_TLB_PTE   0x0000323C  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_TLB_PTE     ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PULL0         0x00003050  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_PULL0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PULL0         0x00003250  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_PULL0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PULL1         0x00003054  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_PULL1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PULL1         0x00003254  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_PULL1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_HASH          0x00003058  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_HASH            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_HASH          0x00003258  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_HASH            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_STATUS        0x00003014  R--4R  = ", REG_RD32(   NV_PFIFO_CACHE0_STATUS          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_STATUS        0x00003214  R--4R  = ", REG_RD32(   NV_PFIFO_CACHE1_STATUS          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_STATUS1       0x00003218  R--4R  = ", REG_RD32(   NV_PFIFO_CACHE1_STATUS1         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PUT           0x00003010  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_PUT             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PUT           0x00003210  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_PUT             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_GET           0x00003070  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_GET             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_GET           0x00003270  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_GET             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_ENGINE        0x00003080  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE0_ENGINE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_ENGINE        0x00003280  RW-4R  = ", REG_RD32(   NV_PFIFO_CACHE1_ENGINE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RUNOUT_STATUS        0x00002400  R--4R  = ", REG_RD32(   NV_PFIFO_RUNOUT_STATUS          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RUNOUT_PUT           0x00002410  RW-4R  = ", REG_RD32(   NV_PFIFO_RUNOUT_PUT             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RUNOUT_GET           0x00002420  RW-4R  = ", REG_RD32(   NV_PFIFO_RUNOUT_GET             ));
}

void NvWatch_NV04_Dump_Master(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nMaster Control State:\r\n");
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_BOOT_0                 0x00000000  R--4R  = ", REG_RD32(   NV_PMC_BOOT_0                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_INTR_0                 0x00000100  RW-4R  = ", REG_RD32(   NV_PMC_INTR_0                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_INTR_EN_0              0x00000140  RW-4R  = ", REG_RD32(   NV_PMC_INTR_EN_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_INTR_READ_0            0x00000160  R--4R  = ", REG_RD32(   NV_PMC_INTR_READ_0              ));
}

void NvWatch_NV04_Dump_Video(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nVideo State:\r\n");

  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_INTR_0              0x00680100  RWI4R  = ", REG_RD32(   NV_PVIDEO_INTR_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_INTR_EN_0           0x00680140  RWI4R  = ", REG_RD32(   NV_PVIDEO_INTR_EN_0             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_STEP_SIZE           0x00680200  RW-4R  = ", REG_RD32(   NV_PVIDEO_STEP_SIZE             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_CONTROL_Y           0x00680204  RW-4R  = ", REG_RD32(   NV_PVIDEO_CONTROL_Y             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_CONTROL_X           0x00680208  RW-4R  = ", REG_RD32(   NV_PVIDEO_CONTROL_X             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFF0_START         0x0068020c  RW-4R  = ", REG_RD32(   NV_PVIDEO_BUFF0_START           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFF1_START         0x00680210  RW-4R  = ", REG_RD32(   NV_PVIDEO_BUFF1_START           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFF0_PITCH         0x00680214  RW-4R  = ", REG_RD32(   NV_PVIDEO_BUFF0_PITCH           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFF1_PITCH         0x00680218  RW-4R  = ", REG_RD32(   NV_PVIDEO_BUFF1_PITCH           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFF0_OFFSET        0x0068021c  RW-4R  = ", REG_RD32(   NV_PVIDEO_BUFF0_OFFSET          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFF1_OFFSET        0x00680220  RW-4R  = ", REG_RD32(   NV_PVIDEO_BUFF1_OFFSET          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_OE_STATE            0x00680224  RW-4R  = ", REG_RD32(   NV_PVIDEO_OE_STATE              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_SU_STATE            0x00680228  RW-4R  = ", REG_RD32(   NV_PVIDEO_SU_STATE              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_RM_STATE            0x0068022c  RW-4R  = ", REG_RD32(   NV_PVIDEO_RM_STATE              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_WINDOW_START        0x00680230  RW-4R  = ", REG_RD32(   NV_PVIDEO_WINDOW_START          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_WINDOW_SIZE         0x00680234  RW-4R  = ", REG_RD32(   NV_PVIDEO_WINDOW_SIZE           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_FIFO_THRES          0x00680238  RW-4R  = ", REG_RD32(   NV_PVIDEO_FIFO_THRES            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_FIFO_BURST          0x0068023c  RW-4R  = ", REG_RD32(   NV_PVIDEO_FIFO_BURST            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_KEY                 0x00680240  RW-4R  = ", REG_RD32(   NV_PVIDEO_KEY                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_OVERLAY             0x00680244  RWI4R  = ", REG_RD32(   NV_PVIDEO_OVERLAY               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_RED_CSC             0x00680280  RW-4R  = ", REG_RD32(   NV_PVIDEO_RED_CSC               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_GREEN_CSC           0x00680284  RW-4R  = ", REG_RD32(   NV_PVIDEO_GREEN_CSC             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BLUE_CSC            0x00680288  RW-4R  = ", REG_RD32(   NV_PVIDEO_BLUE_CSC              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_CSC_ADJUST          0x0068028c  RW-4R  = ", REG_RD32(   NV_PVIDEO_CSC_ADJUST            ));
}

U032 NvWatch_NV04_GetHashSize(PHWINFO pDev)
{
  U032 return_val;
  
  return_val = REG_RD32(NV_PFIFO_RAMHT);

  return(return_val);
}
  
void NvWatch_NV04_FillDiagStruct(PHWINFO pDev, PNVWATCHDIAGSTRUCT pdiagstruct)
{
    pdiagstruct->nv_pfifo_intr_0       =  REG_RD32(NV_PFIFO_INTR_0      );
    pdiagstruct->nv_pfifo_intr_en_0    =  REG_RD32(NV_PFIFO_INTR_EN_0   );
    pdiagstruct->nv_pfifo_caches       =  REG_RD32(NV_PFIFO_CACHES      );
    pdiagstruct->nv_pfifo_mode         =  REG_RD32(NV_PFIFO_MODE        );
    pdiagstruct->nv_pfifo_cache1_push0 =  REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    pdiagstruct->nv_pfifo_cache1_push1 =  REG_RD32(NV_PFIFO_CACHE1_PUSH1);
    pdiagstruct->nv_pfifo_cache1_pull0 =  REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pdiagstruct->nv_pfifo_dma_put      =  REG_RD32(NV_PFIFO_CACHE1_PUT  );
    pdiagstruct->nv_pfifo_dma_get      =  REG_RD32(NV_PFIFO_CACHE1_GET  );
    pdiagstruct->nv_pmc_intr_0         =  REG_RD32(NV_PMC_INTR_0        );
    pdiagstruct->nv_pmc_intr_en_0      =  REG_RD32(NV_PMC_INTR_EN_0     );
    pdiagstruct->nv_pmc_intr_read_0    =  REG_RD32(NV_PMC_INTR_READ_0   );
    pdiagstruct->nv_pmc_enable         =  REG_RD32(NV_PMC_ENABLE        );

}

void NvWatch_NV04_DumpGrTableContents(PHWINFO pDev, U032 verbose_flag)
{
    PHALHWINFO pHalHwInfo = &pDev->halHwInfo;
    PGRHALINFO_NV04 pGrHalInfo;
    PFIFOHALINFO_NV04 pFifoHalInfo;
    U032 ChID;
    U032 i;

    pHalHwInfo = &pDev->halHwInfo;
    pGrHalInfo = (PGRHALINFO_NV04)pHalHwInfo->pGrHalInfo;
    pFifoHalInfo = (PFIFOHALINFO_NV04)pHalHwInfo->pFifoHalInfo;

    for(ChID=0;ChID<NUM_FIFOS;ChID++){
        if (pFifoHalInfo->InUse & (1 << ChID))
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\ngrTable dump of channel ", ChID);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch1 = ", pGrHalInfo->grChannels[ChID].ContextSwitch1);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch2 = ", pGrHalInfo->grChannels[ChID].ContextSwitch2);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch3 = ", pGrHalInfo->grChannels[ChID].ContextSwitch3);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch4 = ", pGrHalInfo->grChannels[ChID].ContextSwitch4);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch5 = ", pGrHalInfo->grChannels[ChID].ContextSwitch5);
      
        for (i = 0; i < 8; i++)
        {    
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Cached Context data for subchannel ", i);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache0 = ", pGrHalInfo->grChannels[ChID].ContextCache1[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache1 = ", pGrHalInfo->grChannels[ChID].ContextCache2[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache2 = ", pGrHalInfo->grChannels[ChID].ContextCache3[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache3 = ", pGrHalInfo->grChannels[ChID].ContextCache4[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache4 = ", pGrHalInfo->grChannels[ChID].ContextCache5[i]);
        }

        if(verbose_flag == NVWATCH_COMPLEX){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].ContextUser = ",          pGrHalInfo->grChannels[ChID].ContextUser       );                 

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaStart0 = ",        pGrHalInfo->grChannels[ChID].DmaStart0             );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaStart1 = ",        pGrHalInfo->grChannels[ChID].DmaStart1             );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaLength = ",        pGrHalInfo->grChannels[ChID].DmaLength             );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaMisc   = ",        pGrHalInfo->grChannels[ChID].DmaMisc               );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaPitch  = ",        pGrHalInfo->grChannels[ChID].DmaPitch              );             

            for (i = 0; i < 6; i++)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferOffset[i]  = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferOffset[i]   );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferBase[i]    = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferBase[i]     );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferLimit[i]   = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferLimit[i]    );
            }
            for (i = 0; i < 5; i++)
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPitch[i] = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPitch[i]      );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Surface           = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.Surface               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.State             = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.State                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[0]  = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[0]      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[1]  = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[1]      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPixel       = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPixel           );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Notify            = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.Notify                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor0     = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor0         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor1     = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor1         );

            for (i = 0; i < 64; i++)
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColorRam[i]  = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColorRam[i]);

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[0]         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[0]            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[1]         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[1]            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternShape       = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.PatternShape          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.MonoColor0         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.MonoColor0            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Rop3               = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Rop3                  );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Chroma             = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Chroma                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BetaAnd            = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.BetaAnd               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BetaPremult        = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.BetaPremult           );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control0           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control0              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control1           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control1              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control2           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control2              );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Blend              = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Blend                 );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.StoredFmt            = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.StoredFmt             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.SourceColor          = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.SourceColor           );

            for (i = 0; i < 32; i++)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsXRam[i]       = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.AbsXRam[i]        );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsYRam[i]       = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.AbsYRam[i]        );
            }

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMin        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMin          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMax          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMin        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMin          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMax          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMin       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMin         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMax       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMax         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMin       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMin         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMax       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMax         );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipXMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipXMax          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipYMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipYMax          );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc0        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc0          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc1        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc1          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc2        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc2          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc3        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc3          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX0              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX0                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX1                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY0              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY0                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY1                );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0Alpha       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0Alpha      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1Alpha       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1Alpha      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0Color       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0Color      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1Color       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1Color      );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Format0             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Format0               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Format1             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Format1               );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Filter0             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Filter0               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Filter1             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Filter1               );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_XY              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_XY                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_U0              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_U0                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_V0              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_V0                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_U1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_U1                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_V1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_V1                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_ZETA            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_ZETA              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_RGB             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_RGB               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_S               = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_S                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_M               = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.D3D_M                 );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru0           = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru0             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru1           = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru1             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru2           = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru2             );


            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.DVDColorFormat      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.DVDColorFormat        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ScaledFormat        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ScaledFormat          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_0            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_0              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_1            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_1              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_2            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_2              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XMisc               = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XMisc                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.YMisc               = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.YMisc                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Valid1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Valid1                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Valid2              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Valid2                );
        }
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\vid_mode.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: VID_MODE.C                                                        *
*   This is the VIDEO Mode OEM module.                                      *
*   Additional video modes can be added via this module.                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"
#include "vmmreg.h"
#include "vpicd.h"
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <mc.h>
#include <os.h>
#include <vga.h>
#include <tv.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vdd.h"
#include "vmm2.h"		// more vmm services
#include "modes.h"
#include "edid.h"
#include "vesadata.h"

extern char strRefreshOverride[];
//JJV-New Registry Process extern char strMaxRefreshRate[];
//JJV-New Registry Process extern char strMaxOptimalRefreshRate[];
//JJV-New Registry Process extern char strOptimalNotFromEDID[];
extern char strMemoryOverride[];
extern char strTilingOverride[];
extern char strRTLOverride[]; 
extern char strPBUSOverride[];
extern char strUnderscanXOverride[];
extern char strUnderscanYOverride[];
extern char strDevNodeRM[];
//JJV-New Registry Process extern char strDevNodeDisplay[];
//JJV-New Registry Process extern char strDMTOverride[];
//JJV-New Registry Process extern char strMonitorTiming[];
//JJV-New Registry Process extern char strCursorCacheOverride[];
extern char strFetchTriggerOverride[];
extern char strFetchSizeOverride[];
extern char strFetchMaxReqsOverride[];
extern char strGraphicsDebug0[];
extern char strGraphicsDebug1[];
extern char strGraphicsDebug2[];
extern char strGraphicsDebug3[];

//JJV-New Registry Process char strNewModeSet[] = "NewStyleModeSet";

RM_STATUS UpdateArbitrationSettings(PHWINFO);

#define NUMBER_OF_MODES 18	// this may change later
#define NUMBER_OF_DEPTHS 4
#define NUMBER_OF_RATES  13 // Double all the 60-120 Hz modes up to 240 Hz
#define DEFAULT_MODE 0x111
#define MODE_TABLE_LENGTH (NUMBER_OF_MODES * NUMBER_OF_DEPTHS * sizeof(U016))

//	this table translates resolutions into their VESA BIOS mode equivalents
U016 ModeSetTable[NUMBER_OF_MODES*NUMBER_OF_DEPTHS] =
{
	// depths: 4 (planar modes), 8, 16, 24/32
	//0:
	// 1600 x 1200
	0xff, 0x145, 0x146, 0x14E,
	//1:
	// 1280 x 1024
	0x106, 0x107, 0x11a, 0x14D,
	//2:
	// 1152 x 864
	0xff, 0x141, 0x142, 0x143,
	//3:
	// 1024 x 768
	0x104, 0x105, 0x117, 0x118,
	//4:
	// 960 x 720
	0xff, 0x14a, 0x14b, 0x14c,
	//5:
	// 800 x 600
	0x102, 0x103, 0x114, 0x115,
	//6:
	// 640 x 480
	0xff, 0x101, 0x111, 0x112,
	//7:
	// 640 x 400
	0xff, 0x100, 0x13d, 0x13e,
	//8:
	// 512 x 384
	0xff, 0x13a, 0x13b, 0x13c,
	//9:
	// 480 x 360
	0xff, 0x147, 0x148, 0x149,
	//10:
	// 400 x 300
	0xff, 0x137, 0x138, 0x139,
	//11:
	// 320 x 400
	0xff, 0x131, 0x132, 0x133,
	//12:
	// 320 x 240					   
	0xff, 0x134, 0x135, 0x136,
	//13:
	// 320 x 200
	0xff, 0x130, 0x10e, 0x10f,
	//14:
	// 1920 x 1200
	0xff, 0x154, 0x155, 0x156, 
	//15:
	// 1920 x 1080
	0xff, 0x151, 0x152, 0x153,
	//16:
	// 1800 x 1440
	0xff, 0x14f, 0x150, 0x157,
	//17:
	// 2048 x 1536
	0xff, 0x158, 0x159, 0x15A
};

//
// CRTC Timings modes for 60Hz, 70Hz, 72Hz, 75Hz, 85Hz, 100Hz, 120Hz
//
// Currently we're using hardcoded table values, but there is no reason why we
// don't just use the standard GTF algorithms and compute any frequency on the
// fly (once we've got a GTF function that doesn't use floating point).
//
// Horizontal Total, Start, End
// Vertical Total, Start, End
// DotClock, Refresh
// HSync polarity 
// VSync polarity 
//
// Max out all the modes above our pixclk (~250).
// 
U016 ModeTimingTable[NUMBER_OF_MODES*NUMBER_OF_RATES][10] =
{
	//0:
    // Settings for 1600x1200:
    2160,1704,1880,1242,1201,1204,16096,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1249,1201,1204,19025,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2176,1712,1888,1251,1201,1204,19600,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1253,1201,1204,20599,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2208,1728,1904,1272,1201,1204,28064,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2224,1736,1912,1286,1201,1204,34321,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2192,1720,1896,1260,1201,1204,23476,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //1:
    // Settings for 1280x1024:
    1712,1360,1496,1060,1025,1028,10888,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1066,1025,1028,12894,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1067,1025,1028,13275,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1728,1368,1504,1069,1025,1028,13854,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1744,1376,1512,1075,1025,1028,15936,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1760,1376,1520,1085,1025,1028,19096,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1097,1025,1028,23379,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1111,1025,1028,27624,14000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1113,1025,1028,28464,14400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1117,1025,1028,29757,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1792,1392,1536,1131,1025,1028,34455,17000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1097,1025,1028,23379,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1776,1384,1528,1097,1025,1028,23379,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //2:
    // Settings for 1152x864:
    1520,1216,1336,895,865,868,8162 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1536,1224,1344,900,865,868,9677 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1536,1224,1344,901,865,868,9964 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1552,1224,1352,902,865,868,10499,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1552,1224,1352,907,865,868,11965,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1568,1232,1360,915,865,868,14347,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1584,1240,1368,926,865,868,17601,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1600,1248,1376,937,865,868,20989,14000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1600,1248,1376,939,865,868,21635,14400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1600,1248,1376,943,865,868,22632,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1600,1248,1376,954,865,868,25949,17000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1616,1256,1384,972,865,868,31415,20000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1600,1248,1376,943,865,868,22632,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //3:
    // Settings for 1024x768:
    1344,1080,1184,795,769,772,6411 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,800,769,772,7616 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,801,769,772,7843 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1360,1080,1192,802,769,772,8180 ,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1376,1088,1200,807,769,772,9439 ,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //1392,1096,1208,814,769,772,11331,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1392,1096,1208,814,769,772,11370,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1408,1104,1216,823,769,772,13905,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1408,1104,1216,833,769,772,16420,14000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1408,1104,1216,835,769,772,16930,14400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1408,1104,1216,838,769,772,17699,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1424,1112,1224,848,769,772,20528,17000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1424,1112,1224,864,769,772,24607,20000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1440,1120,1232,886,769,772,30620,24000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //4:
    // Settings for 960x720:
    1248,1008,1104,746,721,724,5586 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1264,1008,1112,750,721,724,6636 ,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1264,1008,1112,751,721,724,6835 ,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1280,1016,1120,752,721,724,7219 ,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1280,1016,1120,756,721,724,8225 ,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1296,1024,1128,763,721,724,9888 ,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1312,1032,1136,772,721,724,12154,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1312,1032,1136,781,721,724,14345,14000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1328,1040,1144,783,721,724,14973,14400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1328,1040,1144,786,721,724,15657,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1328,1040,1144,795,721,724,17948,17000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1344,1048,1152,810,721,724,21773,20000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1344,1048,1152,831,721,724,26805,24000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //5:
    // Settings for 800x600:
    1024,832,912,622,601,604,3822,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,625,601,604,4550,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,626,601,604,4687,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1040,840,920,627,601,604,4891,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1056,840,928,630,601,604,5655,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1072,848,936,636,601,604,6818,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1088,856,944,643,601,604,8395,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1088,856,944,651,601,604,9916,14000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1088,856,944,653,601,604,10231,14400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1088,856,944,655,601,604,10690,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1104,864,952,663,601,604,12443,17000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1104,864,952,675,601,604,14904,20000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    1120,872,960,692,601,604,18601,24000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //6:
    // Settings for 640x480:
    800,656,720,497,481,484,2386,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,500,481,484,2856,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,501,481,484,2943,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,502,481,484,3072,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    832,672,736,505,481,484,3571,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,509,481,484,4316,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,515,481,484,5241,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    864,680,752,521,481,484,6302,14000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    864,680,752,522,481,484,6495,14400,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    864,680,752,524,481,484,6791,15000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    880,688,760,531,481,484,7944,17000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    880,688,760,540,481,484,9504,20000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    880,688,760,554,481,484,11700,24000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //7:
    // Settings for 640x400:
    //There is no 60Hz timings for 640x400 as defined by IBM VGA
    //784,648,712,415,401,404,1952,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,417,401,404,2335,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,418,401,404,2408,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    800,656,720,418,401,404,2508,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    816,664,728,421,401,404,2920,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    832,672,736,424,401,404,3528,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    848,680,744,429,401,404,4366,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //8:
    // Settings for 512x384:
    // NOTE: This is a scan-doubled version of 512x768 timings
    672,536,592,795,769,772,3205,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    672,536,592,800,769,772,3763,7000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,801,769,772,3968,7200,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,802,769,772,4138,7500,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,807,769,772,4719,8500,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    688,544,600,814,769,772,5600,10000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    704,552,608,823,769,772,6953,12000,BUFFER_HSYNC_NEGATIVE, BUFFER_VSYNC_POSITIVE,
    //9:
    // Settings for 480x360:
    // NOTE: This is a scan-doubled version of 480x720 timings
    624,504,552,746,721,724,2793,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,750,721,724,3360,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,751,721,724,3461,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,752,721,724,3610,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    640,512,560,756,721,724,4113,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,763,721,724,5005,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    656,512,568,772,721,724,6077,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //10:
    // Settings for 400x300:
    // NOTE: This is a scan-doubled version of 400x600 timings
    512,416,456,622,601,604,1911,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,625,601,604,2310,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,626,601,604,2380,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,627,601,604,2483,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,630,601,604,2827,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    528,424,464,636,601,604,3358,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    544,432,472,643,601,604,4198,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //11:
    // Settings for 320x400:
    //
    // !!! This mode should never be set !!! since DDraw doesn't support it yet
    //
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1204,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1254,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,421,401,404,1489,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,424,401,404,1764,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //12:
    // Settings for 320x240:
    // NOTE: This is a scan-doubled version of 320x480 timings
    400,328,360,497,481,484,1193,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,500,481,484,1400,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,501,481,484,1501,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,502,481,484,1566,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,505,481,484,1786,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,509,481,484,2117,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    432,344,376,515,481,484,2670,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    //13:
    // Settings for 320x200:
    // NOTE: This a scan-doubled version of 320x400 timings
    //There is no 60Hz timings for 320x200 as defined by IBM VGA
    //384,320,352,415,401,404,956 ,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,417,401,404,1168,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1204,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    400,328,360,418,401,404,1254,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,421,401,404,1489,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,424,401,404,1764,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    416,336,368,429,401,404,2142,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,


    //14:
    // Settings for 1920x1200:
    2592,2048,2256,1242,1201,1204,19316,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1249,1201,1204,22802,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1251,1201,1204,23635,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1253,1201,1204,24659,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2640,2072,2280,1260,1201,1204,28274,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2656,2072,2288,1271,1201,1204,33758,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2592,2048,2256,1242,1201,1204,19316,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //15:
    // Settings for 1920x1080:
    2576,2040,2248,1118,1081,1084,17280,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1124,1081,1084,20520,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1126,1081,1084,21144,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2608,2056,2264,1128,1081,1084,22064,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2640,2072,2280,1144,1081,1084,30202,10000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2656,2072,2288,1157,1081,1084,36876,12000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2624,2064,2272,1134,1081,1084,25293,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,

    //16:
    // Settings for 1800x1440:
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2472,1936,2136,1499,1441,1444,25939,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2472,1936,2136,1500,1441,1444,26698,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2472,1936,2136,1503,1441,1444,27866,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2488,1944,2144,1512,1441,1444,31976,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2456,1928,2128,1490,1441,1444,21957,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    
    //17:
    // Settings for 2048x1536:
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2816,2208,2432,1599,1537,1540,31519,7000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2816,2208,2432,1600,1537,1540,32440,7200,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2832,2216,2440,1603,1537,1540,34048,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2832,2216,2440,1612,1537,1540,38804,8500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    2800,2200,2424,1589,1537,1540,26695,6000,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_POSITIVE,
    
};

//
// VBE3.0A CRTC Table
//
typedef struct crtc_table_structure
{
    U016	horiz_total;
	U016	horiz_start;
	U016	horiz_end;
	U016	vertical_total;
	U016	vertical_start;
	U016	vertical_end;
	U008	horiz_polarity;
	U008	vertical_polarity;
	U008	flags;
	U016	dot_clock;
	U016	refresh;
	U008	reserved[40];
} CRTC_STRUCTURE, *PCRTC_STRUCTURE;

//
// VBE3.0P CRTC Table
//
typedef struct crtc_table_structure2
{
    U016	horiz_total;
	U016	horiz_start;
	U016	horiz_end;
	U016	vertical_total;
	U016	vertical_start;
	U016	vertical_end;
	U008	flags;
	U032	dot_clock;
	U016	refresh;
	U008	reserved[40];
} CRTC_STRUCTURE2, *PCRTC_STRUCTURE2;



//*****************************************************************************
// DMT (Discret Mode Timings) for older monitors
//*****************************************************************************

//*****************************************************************************
//
// Do VESA 1.0 rev 0.7 DMT timings for the following modes:
//
// DMT timing calculations were produced with the VESA DMT 1.0 rev 0.7 
// Monitor Timing Specifications and D.Reed's NV3 CRTC spreadsheet.
//
//       1600 x 1200 @ 60,70,75,85
//       1280 x 1024 @ 60,75,85
//       1152 x  864 @ 75
//       1024 x  768 @ 60,70,75,85
//        800 x  600 @ 60,72,75,85
//        640 x  480 @ 60,72,75,85
//
// The refresh rates in the Mode Table are specified in the following order:
//
//       60,70,72,75,85,100,120
//
//*****************************************************************************

#define POLAR_NEG_NEG        0x0c0
#define POLAR_POS_NEG        0x040
#define POLAR_NEG_POS        0x080
#define POLAR_POS_POS        0x000


U016 DMTOverrideTable[NUMBER_OF_MODES*NUMBER_OF_RATES][13] =
{
    //0:
    // Settings for 1600x1200:
    16200, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    18900, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    20250, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    22950, POLAR_POS_POS, 0x009, 0x0c7, 0x08d,0x0d1,0x009,0x0e0, 0x010, (0x0b1-1),(0x024-1) | 0x080, 0x0af,0x0e1,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    0    ,             0,     0,     0,     0,    0,    0,    0,     0,         0,                 0,     0,    0,
    //1:
    // Settings for 1280x1024:
    10800, POLAR_POS_POS, 0x0ce, 0x09f, 0x092, 0x0a7,   0x015, 0x028, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x029,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    13500, POLAR_POS_POS, 0x0ce, 0x09f, 0x092, 0x0a3,   0x015, 0x028, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x029,
    15750, POLAR_POS_POS, 0x0d3, 0x09f, 0x097, 0x0a9,   0x01d, 0x02e, 0x05a, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x02f,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,       0,     0,     0,         0,                  0,     0,     0,
    //2:
    // Settings for 1152x864:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    10800, POLAR_POS_POS, 0x0c3, 0x08f, 0x087, 0x099, 0x009, 0x082, 0x0ff, (0x061-1), (0x024-1) | 0x080, 0x05f, 0x083,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //3:
    // Settings for 1024x768:
    6500 , POLAR_NEG_NEG, 0x0a3, 0x07f, 0x087, 0x084, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
    7500 , POLAR_NEG_NEG, 0x0a1, 0x07f, 0x085, 0x084, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
// 72Hz does not appear in DMT, so this is a fudge of the GTF's    
    7843 , POLAR_NEG_NEG, 0x0a1, 0x07f, 0x085, 0x085, 0x095, 0x024, 0x0f5, (0x003-1), (0x029-1) | 0x080, 0x0ff, 0x025,
    7875 , POLAR_POS_POS, 0x09f, 0x07f, 0x083, 0x083, 0x08f, 0x01e, 0x0f5, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x01f,
    9450 , POLAR_POS_POS, 0x0a7, 0x07f, 0x08b, 0x087, 0x093, 0x026, 0x0f5, (0x001-1), (0x024-1) | 0x080, 0x0ff, 0x027,
// 100Hz does not appear in DMT, so this is a fudge of the GTF's    
    11370, POLAR_POS_POS, 0x0a9, 0x07f, 0x08D, 0x086, 0x098, 0x02C, 0x0f5, (0x002-1), (0x024-1) | 0x080, 0x0ff, 0x02D,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //4:
    // Settings for 960x720:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //5:
    // Settings for 800x600:
    4000 , POLAR_POS_POS, 0x07f, 0x063, 0x083, 0x06a, 0x01a, 0x072, 0x0f0, (0x059-1), (0x02d-1) | 0x080, 0x057, 0x073,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    5000 , POLAR_POS_POS, 0x07d, 0x063, 0x081, 0x06c, 0x01b, 0x098, 0x0f0, (0x07d-1), (0x023-1) | 0x080, 0x057, 0x099,
    4950 , POLAR_POS_POS, 0x07f, 0x063, 0x083, 0x067, 0x011, 0x06f, 0x0f0, (0x059-1), (0x02c-1) | 0x080, 0x057, 0x070,
    5625 , POLAR_POS_POS, 0x07e, 0x063, 0x082, 0x069, 0x011, 0x075, 0x0f0, (0x059-1), (0x02c-1) | 0x080, 0x057, 0x076,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //6:
    // Settings for 640x480:
    2517 , POLAR_NEG_NEG, 0x05f, 0x04f, 0x083, 0x053, 0x09f, 0x00b, 0x03e, (0x0ea-1), (0x02c-1) | 0x080, 0x0df, 0x00c,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    3150 , POLAR_NEG_NEG, 0x063, 0x04f, 0x087, 0x054, 0x099, 0x006, 0x03e, (0x0e9-1), (0x02c-1) | 0x080, 0x0df, 0x007,
    3150 , POLAR_NEG_NEG, 0x064, 0x04f, 0x088, 0x053, 0x09b, 0x0f2, 0x01f, (0x0e1-1), (0x024-1) | 0x080, 0x0df, 0x0f3,
    3600 , POLAR_NEG_NEG, 0x063, 0x04f, 0x087, 0x058, 0x09f, 0x0fb, 0x01f, (0x0e1-1), (0x024-1) | 0x080, 0x0df, 0x0fc,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //7:
    // Settings for 640x400:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //8:
    // Settings for 512x384:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //9:
    // Settings for 480x360:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //10:
    // Settings for 400x300:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //11:
    // Settings for 320x400:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //12:
    // Settings for 320x240:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    //13:
    // Settings for 320x200:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //14:
    // Settings for 1920x1200:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //15:
    // Settings for 1920x1080:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,

    //16:
    // Settings for 1800x1440:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    
    //17:
    // Settings for 2048x1536:
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    0    ,             0,     0,     0,     0,     0,     0,     0,     0,         0,                  0,     0,     0,
    
};

//---------------------------------------------------------------------------
//
//  Set the requested video mode
//
//---------------------------------------------------------------------------

RM_STATUS osSetVideoMode
(
    PHWINFO pDev
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT VidLutCurDac;
	PWIN9XHWINFO pOsHwInfo = (PWIN9XHWINFO) pDev->pOsHwInfo;

    U008    mode, bitdepth, doubled;
    CLIENT_STRUCT     crs;
    CRTC_STRUCTURE timings;
    CRTC_STRUCTURE2 timings2;
    U032    i, data32, temp32;
    U032    bios_revision;
    U032    UseDMTFlag;
    BOOL    monitorIsGTF;
    RM_STATUS status;
    DISPLAYINFO tmpDisplayInfo;
    BOOL    optimalRefreshSelected;
    U032    monitorTimingMode;
    GTF_TIMINGS vbe_timings;
    PDMT_OVERRIDES pDMTOverrides;
    U008 base_mode;
    U032 rate_table[] = {60,70,72,75,85,100,120,140,144,150,170,200,240};
    U032 validArb;

	mode = 0;
    doubled = 0;


    OEMEnableExtensions();          // Unlock the registers before DDC
    EDIDRead(pDev);
    OEMDisableExtensions();         // Lock the registers

	// get the index for the first dimension (resolution)
	switch (pDev->Framebuffer.VertDisplayWidth)
	{
		case 1440:
			mode = NUMBER_OF_DEPTHS*16; 
		    break;
		case 1080:
			mode = NUMBER_OF_DEPTHS*15; 
		    break;
		case 1200:
			// Just use a nested case for redundant vertical widths.
			switch (pDev->Framebuffer.HorizDisplayWidth)
			{
			  case 1920:
			    mode = NUMBER_OF_DEPTHS*14; 
			    break;
			  case 1600:
			    mode = NUMBER_OF_DEPTHS*0; 
			    break;
			  default:
			    break;
			}
	    	break;
		case 1024:
			mode = NUMBER_OF_DEPTHS*1; 
		    break;
		case 864:
			mode = NUMBER_OF_DEPTHS*2;
		    break;
		case 768:
			mode = NUMBER_OF_DEPTHS*3;
		    break;
		case 720:
			mode = NUMBER_OF_DEPTHS*4; 
		    break;
		case 600:
			mode = NUMBER_OF_DEPTHS*5; 
		    break;
		case 480:
			mode = NUMBER_OF_DEPTHS*6; 
			break;
		case 400:
			switch (pDev->Framebuffer.HorizDisplayWidth)
			{
			  case 640:
			    mode = NUMBER_OF_DEPTHS*7; 
			    break;
			  case 320:
                mode = NUMBER_OF_DEPTHS*11; 
			    break;
			  default:
			    break;
			}
			break;
		case 384:
			mode = NUMBER_OF_DEPTHS*8; 
            doubled = 1;
			break;
		case 360:
			mode = NUMBER_OF_DEPTHS*9; 
            doubled = 1;
			break;
		case 300:
			mode = NUMBER_OF_DEPTHS*10; 
            doubled = 1;
			break;
		case 240:
			mode = NUMBER_OF_DEPTHS*12; 
            doubled = 1;
			break;
		case 200:
			mode = NUMBER_OF_DEPTHS*13; 
            doubled = 1;
			break;
		default:
		    mode = NUMBER_OF_DEPTHS*6;
	}

	switch (pDev->Framebuffer.Depth)
	// the depth is 4,8,16,24, or 32. Add the second dimension.
	{
		case 4:
			break;
		case 8:
			bitdepth = mode + 1;
			break;
		case 16:
			bitdepth = mode + 2;
			break;
		case 24:
			bitdepth = mode + 3;
			break;
		case 32:
			bitdepth = mode + 3;
			break;
	    default:
			bitdepth = mode + 2;
    }
    
    // VBE SetMode
    crs.CWRS.Client_AX = 0x4F02;
	// get mode from the 2 dimensional array
	crs.CWRS.Client_BX = ModeSetTable[bitdepth];
	if ((crs.CWRS.Client_BX == 0xff) || (bitdepth > (MODE_TABLE_LENGTH)))
		crs.CWRS.Client_BX = DEFAULT_MODE;
    // linear/flat frame buffer, clear memory, use default CRTC/refresh values
    crs.CWRS.Client_BX |= 0x4000;

    //
    // Make sure we're not going into a mode that's not possible for boards with
    // less than 8meg of framebuffer
    //
    if ((pDev->Framebuffer.VertDisplayWidth >= 1024) && (pDev->Framebuffer.Depth >= 24)
        && (pDev->Framebuffer.RamSizeMb < 8))
		    crs.CWRS.Client_BX = DEFAULT_MODE;

    // Figure out what monitor timing mode we want. It is controlled by a registry flag "MonitorTiming".
    monitorTimingMode = 0; // By default, read the EDID of the monitor.
    if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strMonitorTiming, &data32) == RM_OK)
    {
        monitorTimingMode = data32;
    }
    switch (monitorTimingMode)
    {
        case 1:
            // Use DMT.
            UseDMTFlag = TRUE;
            break;
        case 2:
            // Use GTF.
            UseDMTFlag = FALSE;
            break;
        case 3:
            // Legacy mode.
            // Read the legacy DMT Override flag to see if we should use DMT. Otherwise use GTF.
            UseDMTFlag = FALSE;
            if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strDMTOverride, &data32) == RM_OK)
            {
                if (data32 == 1)
                    UseDMTFlag = TRUE;
            }
            break;
        default:
            // Automatically set it by reading the EDID.
            UseDMTFlag = TRUE; // default to DMT
            if (EDIDIsMonitorGTF(pDev, &monitorIsGTF) == RM_OK)
            {
                UseDMTFlag = (monitorIsGTF) ? FALSE : TRUE;
            }
            break;
            // 
    }

    //
    // If there's an override setting for the refresh rate, use it instead
    //
    if (osReadRegistryDword(strDevNodeRM, strRefreshOverride, &data32) == RM_OK)
        pDev->Framebuffer.HalInfo.RefreshRate = data32;


    //
    // The GTF timings for 640x400 at 70Hz and 72Hz are drastically different than
    // the original VGA timings (which officially only list 85Hz as a support rate
    // at this resolution).  Therefore, when we attempt to set the GTF rates the
    // monitors just aren't happy.
    //
    // We have two choices.  Tweak our 70Hz and 72Hz GTF numbers to mimic VGA, or
    // just use IBM VGA (70Hz) for these two rates.  Since we're doing it right, and
    // the monitors just aren't happy, I vote for the latter.
    //
    // Remember that IBM VGA 640x400 starts at 70Hz, not 60Hz.
    //
    if ((pDev->Framebuffer.HorizDisplayWidth == 640) && (pDev->Framebuffer.VertDisplayWidth == 400)
        && (pDev->Framebuffer.HalInfo.RefreshRate < 75))
            pDev->Framebuffer.HalInfo.RefreshRate = 60; // this will kick in BIOS default values (70Hz)

    //
    // NV4 limits for hires modes at 32bpp.  Windows will still send down optimal values larger
    // than the limits we placed in our INF.  Don't let them through.
    //
    if ((pDev->Framebuffer.HorizDisplayWidth == 1280) && (pDev->Framebuffer.VertDisplayWidth == 1024)
        && (pDev->Framebuffer.Depth >= 24)
        && (pDev->Framebuffer.HalInfo.RefreshRate > 100))
            pDev->Framebuffer.HalInfo.RefreshRate = 100; 
    
    if ((pDev->Framebuffer.HorizDisplayWidth == 1600) && (pDev->Framebuffer.VertDisplayWidth == 1200)
        && (pDev->Framebuffer.Depth >= 24)
        && (pDev->Framebuffer.HalInfo.RefreshRate > 75))
            pDev->Framebuffer.HalInfo.RefreshRate = 75; 
    
    if ((pDev->Framebuffer.HorizDisplayWidth == 1920) && (pDev->Framebuffer.VertDisplayWidth == 1080)
        && (pDev->Framebuffer.Depth >= 24)
        && (pDev->Framebuffer.HalInfo.RefreshRate > 72))
            pDev->Framebuffer.HalInfo.RefreshRate = 72; 
    
    if ((pDev->Framebuffer.HorizDisplayWidth == 1920) && (pDev->Framebuffer.VertDisplayWidth == 1200)
        && (pDev->Framebuffer.Depth >= 24)
        && (pDev->Framebuffer.HalInfo.RefreshRate > 60))
            pDev->Framebuffer.HalInfo.RefreshRate = 60; 
            
    //
    // There is a hardware bug in NV4's arbitration hardware having to do with memory refresh and
    // page misses.  This shows its ugly head during 64bit operation (8meg SDRAM).  If we see
    // a pixelclock setting above ~160Hz in 32bpp, drop it down to 60Hz.
    //
    // The user may have selected a different refresh rate (since the INF allows it), but they're
    // going to get 60Hz.  Sorry.
    //            
    // The highest resolution in 8meg is 1600x1200x32bpp, so just watch for that
    //
    if ((pDev->Chip.MaskRevision == NV_PMC_BOOT_0_MASK_REVISION_A)
        && (pDev->Framebuffer.RamSizeMb == 8) && (pDev->Dac.InputWidth == 64)
        && (pDev->Framebuffer.HorizDisplayWidth == 1600) 
        && (pDev->Framebuffer.VertDisplayWidth == 1200)
        && (pDev->Framebuffer.Depth >= 24)
        && (pDev->Framebuffer.HalInfo.RefreshRate > 60))
            pDev->Framebuffer.HalInfo.RefreshRate = 60; 

    // Check if "optimal" refresh rate was chosen. 
    // When "optimal" is chosen, both min and max refresh rates in DISPLAYINFO will have non-zero values. 
    // When a specific refresh rate is chosen, max will have that value and the min will have zero. 
    // When "default" is chosen, both min and max will be zero.
    tmpDisplayInfo.HdrSize = sizeof(DISPLAYINFO);
    vddGetDisplayInfo(pOsHwInfo->osDeviceHandle, &tmpDisplayInfo, sizeof(DISPLAYINFO));
    if ((tmpDisplayInfo.RefreshRateMax != 0) && (tmpDisplayInfo.RefreshRateMin != 0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "OPTIMAL REFRESH!!\n\r");

        // Try to get the max frequency for this mode from the EDID. 
        // If we get a refresh rate that is less than what we have now,
        // we will use the lower value.
        if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strOptimalNotFromEDID, &data32) != RM_OK)
        {
            // No registry entry that prohibits us from looking in the EDID.
            status = EDIDGetMaxRefreshRate(pDev, pDev->Framebuffer.HorizDisplayWidth, 
                                           pDev->Framebuffer.VertDisplayWidth,
                                           &data32);
            if (status == RM_OK     && 
                data32 != 0 &&
                data32 < pDev->Framebuffer.HalInfo.RefreshRate)
            {
                pDev->Framebuffer.HalInfo.RefreshRate = data32;
            }
        } // Get optimal from EDID

        // Read the registry to see if there is a limit for the "optimal" refresh rate.
        if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strMaxOptimalRefreshRate, &data32) == RM_OK)
        {
            // Ignore the value read if it is less than 60Hz.
            if (data32 >= 60 &&
                data32 < pDev->Framebuffer.HalInfo.RefreshRate)
            {
                pDev->Framebuffer.HalInfo.RefreshRate = data32;
            }
        }
    } // "optimal" refresh rate chosen
    
    //
    // If there's max refresh rate, make sure we don't exceed that.
    //
    if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strMaxRefreshRate, &data32) == RM_OK)
    {
        // Ignore the value read if it is less than 60Hz.
        if (data32 >= 60 &&
            pDev->Framebuffer.HalInfo.RefreshRate > data32)
        {
            pDev->Framebuffer.HalInfo.RefreshRate = data32;
        }
    }

    //
    // Plug in the refresh timings.  Until we have the real algorithm, just
    // use the predefined table.  Adjust all tweener rates to the real rates.
    //
    mode /= NUMBER_OF_DEPTHS;
    mode *= NUMBER_OF_RATES;
    base_mode = mode;
    crs.CWRS.Client_BX |= 0x0800;

    if (pDev->Framebuffer.HalInfo.RefreshRate >= 240)
    {        
        mode += 12;
        pDev->Framebuffer.HalInfo.RefreshRate = 240;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 200)
    {        
        mode += 11;
        pDev->Framebuffer.HalInfo.RefreshRate = 200;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 170)
    {        
        mode += 10;
        pDev->Framebuffer.HalInfo.RefreshRate = 170;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 150)
    {      
        //
        // Most monitors can support the vert range of 800x600x150Hz but cannot support the
        // horiz range.  We removed 150Hz from the INF, but in case Windows tries it anyway,
        // override with one lower rate.
        //
        if ((pDev->Framebuffer.HorizDisplayWidth == 800) && (pDev->Framebuffer.VertDisplayWidth == 600))
        {
            mode += 8;
            pDev->Framebuffer.HalInfo.RefreshRate = 144;
        }                
        else
        {        
            mode += 9;
            pDev->Framebuffer.HalInfo.RefreshRate = 150;
        }                
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 144)
    {        
        mode += 8;
        pDev->Framebuffer.HalInfo.RefreshRate = 144;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 140)
    {        
        mode += 7;
        pDev->Framebuffer.HalInfo.RefreshRate = 140;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 120)
    {        
        mode += 6;
        pDev->Framebuffer.HalInfo.RefreshRate = 120;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 100)
    {        
        mode += 5;
        pDev->Framebuffer.HalInfo.RefreshRate = 100;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 85)
    {        
        mode += 4;
        pDev->Framebuffer.HalInfo.RefreshRate = 85;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 75)
    {        
        mode += 3;
        pDev->Framebuffer.HalInfo.RefreshRate = 75;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 72)
    {        
        mode += 2;
        pDev->Framebuffer.HalInfo.RefreshRate = 72;
    }            
    else if (pDev->Framebuffer.HalInfo.RefreshRate >= 70)
    {        
        mode += 1;
        pDev->Framebuffer.HalInfo.RefreshRate = 70;
    }            
    else
    {        
        mode += 0;
        pDev->Framebuffer.HalInfo.RefreshRate = 60;
    }            

    //
    // The documented method for Windows to select refresh rates for a display/monitor
    // combination is to take the intersection of the monitor INF entries (EDID) and
    // the display device's INF values.  This will then dictate the rates that are
    // valid for both devices.
    //
    // Unfortunately, it seems Microsoft didn't follow their own documentation in all
    // cases.  If a user selects OPTIMAL from the refresh rate menu, Windows will ask
    // us to set a refresh rate that matches the monitor information.  It doesn't matter
    // if the rate is beyond the display device's INF entries.
    //
    // Due to clocking differences between all of our shipping chips, we need to
    // validate all attempted refresh rates.  If a rate is beyond our device's limits
    // based on memory and clock variables, we need to attempt one refresh rate lower.
    // Luckily, the user has selected OPTIMAL and doesn't know exactly what rate she
    // is choosing.  If we drop it by one or two values, it doesn't really matter.
    //

    nvHalDacValidateArbSettings(pDev, 
                                pDev->Framebuffer.Depth, 0, 0, 
                                (U032)(ModeTimingTable[mode][6] * 10000),
                                &validArb);

    while ((mode > base_mode) && (!validArb))
    {
        // drop a refresh rate
        mode--;
        pDev->Framebuffer.HalInfo.RefreshRate = rate_table[mode];
         
        nvHalDacValidateArbSettings(pDev, 
                                    pDev->Framebuffer.Depth, 0, 0, 
                                    (U032)(ModeTimingTable[mode][6] * 10000),
                                    &validArb);
    }                                                            

    if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strNewModeSet, &data32) == RM_OK)
    {
        // New style modeset.
        MODE_TIMING_VALUES timingValues;
        unsigned int vesaStatus;

        if ((pDev->Framebuffer.HorizDisplayWidth == 640) && 
            (pDev->Framebuffer.VertDisplayWidth == 480)  &&
            (pDev->Framebuffer.HalInfo.RefreshRate == 60))
        {
            // force 640x480 @60Hz into DMT mode.
            UseDMTFlag = TRUE;
        }

        if (UseDMTFlag)
        {
            // Get DMT timings for this mode. 
            vesaStatus = vesaGetDMTTimings(pDev->Framebuffer.HorizDisplayWidth, 
                                           pDev->Framebuffer.VertDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.RefreshRate,
                                           &timingValues);
            // If we failed to get DMT timings for this mode, force GTF
            if (vesaStatus != 0)
            {
                UseDMTFlag = FALSE;
            }
        }

        if (!UseDMTFlag)
        {
            // Get the GTF timings
            vesaStatus = vesaGetGTFTimings(pDev->Framebuffer.HorizDisplayWidth, 
                                           pDev->Framebuffer.VertDisplayWidth, 
                                           pDev->Framebuffer.HalInfo.RefreshRate,
                                           &timingValues);
        }

        // copy all the relevant data to the pDev and call dacProgramCRTC.
        if (vesaStatus == 0)
        {
            pDev->Dac.HorizontalVisible       = timingValues.HorizontalVisible;
            pDev->Dac.HorizontalBlankStart    = timingValues.HorizontalBlankStart;
            pDev->Dac.HorizontalRetraceStart  = timingValues.HorizontalRetraceStart;
            pDev->Dac.HorizontalRetraceEnd    = timingValues.HorizontalRetraceEnd;
            pDev->Dac.HorizontalBlankEnd      = timingValues.HorizontalBlankEnd;
            pDev->Dac.HorizontalTotal         = timingValues.HorizontalTotal;
            pDev->Dac.VerticalVisible         = timingValues.VerticalVisible;
            pDev->Dac.VerticalBlankStart      = timingValues.VerticalBlankStart;
            pDev->Dac.VerticalRetraceStart    = timingValues.VerticalRetraceStart;
            pDev->Dac.VerticalRetraceEnd      = timingValues.VerticalRetraceEnd;
            pDev->Dac.VerticalBlankEnd        = timingValues.VerticalBlankEnd;
            pDev->Dac.VerticalTotal           = timingValues.VerticalTotal;
            pDev->Dac.PixelDepth              = pDev->Framebuffer.Depth;
            pDev->Dac.HalInfo.PixelClock      = timingValues.PixelClock;
            pDev->Dac.HorizontalSyncPolarity  = timingValues.HSyncpolarity;
            pDev->Dac.VerticalSyncPolarity    = timingValues.VSyncpolarity;
            pDev->Dac.DoubleScannedMode       = (pDev->Framebuffer.VertDisplayWidth < 400) ? TRUE : FALSE;

            dacProgramCRTC(pDev);
        } // successfully obtained timing values.
        else
        {
            // What the heck are we going to do now! There is neither a valid DMT or GTF 
            // timing description for this mode.
            DBG_BREAKPOINT();
        }
    } // do new style modeset
    else
    {
        // old style modeset.

        //
        // Load up the VBE information table
        //
        vbe_timings.horiz_total     = ModeTimingTable[mode][0];
        vbe_timings.horiz_start     = ModeTimingTable[mode][1];
        vbe_timings.horiz_end       = ModeTimingTable[mode][2];
        vbe_timings.vertical_total  = ModeTimingTable[mode][3];
        vbe_timings.vertical_start  = ModeTimingTable[mode][4];
        vbe_timings.vertical_end    = ModeTimingTable[mode][5];
        vbe_timings.dot_clock       = (U032)(ModeTimingTable[mode][6] * 10000);
        vbe_timings.refresh         = ModeTimingTable[mode][7];
        vbe_timings.flags           = (doubled) ? 0x01 : 0x00;
        vbe_timings.flags |= (ModeTimingTable[mode][8] == BUFFER_HSYNC_POSITIVE) ? 0 : 0x04;
        vbe_timings.flags |= (ModeTimingTable[mode][9] == BUFFER_VSYNC_POSITIVE) ? 0 : 0x08;

        if (UseDMTFlag)
        {        
            pDMTOverrides = (PDMT_OVERRIDES)(&(DMTOverrideTable[mode][0]));
            //
            // If there is no DMT entry for this mode/refresh, fall back to default GTF
            //
            if (pDMTOverrides->DotClock == 0)
            {
                UseDMTFlag = FALSE;
            }
        }    

        if (!UseDMTFlag &&
            pDev->Framebuffer.HalInfo.RefreshRate == 60)
        {        
            // The GTF timings for 60Hz are not right. So just fall back to the VGA defaults.
            crs.CWRS.Client_AX = VBESetMode(crs.CWRS.Client_BX, NULL, NULL, FALSE);
        }        
        else
        {
            crs.CWRS.Client_AX = VBESetMode(crs.CWRS.Client_BX, &vbe_timings, pDMTOverrides, (U016)UseDMTFlag);
        }
    }

    //
    // Determine if it's possible to support a video overlay in this resolution
    //
    nvHalDacValidateArbSettings(pDev, 
                                pDev->Framebuffer.Depth, 1, 0, 
                                (U032)(ModeTimingTable[mode][6] * 10000),
                                &(pDev->Video.OverlayAllowed));
    
    // Check/Set any PFB overrides
    if (osReadRegistryDword(strDevNodeRM, strMemoryOverride, &data32) == RM_OK)
    {
        pDev->Framebuffer.HalInfo.Overrides.LoadMask |= FB_OVERRIDES_MEMORY;
        pDev->Framebuffer.HalInfo.Overrides.MemoryOverride = data32;
    }
    if (osReadRegistryDword(pDev, strDevNodeRM, strRTLOverride, &data32) == RM_OK)
    {
        pDev->Framebuffer.HalInfo.Overrides.LoadMask |= FB_OVERRIDES_RTL;
        pDev->Framebuffer.HalInfo.Overrides.RTLOverride = data32;
    }
    nvHalFbControl(pDev, FB_CONTROL_LOAD_OVERRIDES);

    //
    // If there's a dma fifo fetch trigger override, use it now
    //
    if (osReadRegistryDword(strDevNodeRM, strFetchTriggerOverride, &data32) == RM_OK)
    {
        pDev->Fifo.DmaFetchTrigger = data32;
    }
    
    //
    // If there's a dma fifo fetch size override, use it now
    //
    if (osReadRegistryDword(strDevNodeRM, strFetchSizeOverride, &data32) == RM_OK)
    {
        pDev->Fifo.DmaFetchSize = data32;
    }

    //
    // If there's a dma fifo fetch max reqs override, use it now
    //
    if (osReadRegistryDword(strDevNodeRM, strFetchMaxReqsOverride, &data32) == RM_OK)
    {
        pDev->Fifo.DmaFetchMaxReqs = data32;
    }

    //
    // If there are graphics debug overrides, use them now
    //
    if (osReadRegistryDword(strDevNodeRM, strGraphicsDebug0, &data32) == RM_OK)
    {
        pDev->Graphics.Debug0 = data32;
    }
    if (osReadRegistryDword(strDevNodeRM, strGraphicsDebug1, &data32) == RM_OK)
    {
        pDev->Graphics.Debug1 = data32;
    }
    if (osReadRegistryDword(strDevNodeRM, strGraphicsDebug2, &data32) == RM_OK)
    {
        pDev->Graphics.Debug2 = data32;
    }
    if (osReadRegistryDword(strDevNodeRM, strGraphicsDebug3, &data32) == RM_OK)
    {
        pDev->Graphics.Debug3 = data32;
    }
    
    //
    // Use the display cursor cache override if available
    //
    if (osReadRegistryDword(pDev->Registry.DBstrDevNodeDisplay, strCursorCacheOverride, &data32) == RM_OK)
    {
        if (data32 == 0)
            pDev->Dac.CursorCacheEnable = 0;
        else            
            pDev->Dac.CursorCacheEnable = 1;
    }
    
    //
    // If the modeset was successful, perform any more overrides required
    //
	if (crs.CWRS.Client_AX & 0xff00)
    {
        // let the miniVDD save new register states
        if (pOsHwInfo->miniVDDPostModeChange)  // if primary display, we got callback at init
            (*pOsHwInfo->miniVDDPostModeChange)();
    	return (crs.CRS.Client_EAX);
    }
    else
	{
        //
		// If 16 bit mode, turn on 565
        //
		if (pDev->Framebuffer.Depth == 16)
        {
			FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _SEL);
        }            
        
        //
        // If 16 or 32 bit mode, enable default gamma (no pixmix for these modes)
        //
		if ((pDev->Framebuffer.Depth == 16) || (pDev->Framebuffer.Depth == 32))
        {        
			FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIXMIX, _ON);
        }
            
		// Make sure we're using an 8bit palette
	    FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _8BITS);
         
        //
        // Update arb settings for each mode set
        //
        VidLutCurDac.Head = 0;
        nvHalDacUpdateArbSettings(pDev, (VOID*) &VidLutCurDac));

        // let the miniVDD save new register states
        if (pOsHwInfo->miniVDDPostModeChange)  // if primary display, we got callback at init
            (*pOsHwInfo->miniVDDPostModeChange)();

        //
        // For NV4, change the default flip functionality to end of vsync, not start
        //
        // BUG BUG BUG:  There is a hardware bug in NV4-A relating to this particular
        // register.  You must access another register in this general area before
        // accessing PCRTC_CONFIG
        //
        i = REG_RD32(NV_PCRTC_START);
        FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA);

    	return (RM_OK);
	}
}


BOOL nvIsResolutionValid(HWINFO info1)
{
  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\inc\OS.H ===
#ifndef _OS_H_
#define _OS_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OS.H                                                              *
*       Operating system wrapper functions used to abstract the OS.         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    06/22/94 - rewrote it.                  *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Debug macros.
//
//---------------------------------------------------------------------------

// debug module, levels, and defines
#include <nv_dbg.h>

#ifdef DEBUG

/*
#pragma warning(disable:4311)   // allow type cast truncation
#pragma warning(disable:4242)   // allow 
#pragma warning(disable:4244)   // allow 
#pragma warning(disable:4047)   // allow 
*/

extern int cur_debuglevel;

#endif // DEBUG

// registry path for RM AGP lookups
#define RM_REGISTRY_AGP_BASE_PATH    strDevNodeRM

#ifndef toupper
#define toupper(c)  (((c)>='a'&&(c)<='z')?((c)-'a'+'A'):(c))
#endif

// data types necessary for accessing binary registry data
// this seems to be what we get back on REG_BINARY -- couldn't find it documented tho
typedef struct
{
    U032 Length;
    U032 type;
    U008 buffer[1];
    
} RM_REG_BINARY_RECORD;
typedef union
{
    RM_REG_BINARY_RECORD record;
    U008 buffer[256];
    
} RM_REG_BINARY_BUFFER;

/* polymorphic 64-bit macros */
#ifdef IA64
typedef NvU64 SIZE_PTR; 
#else
typedef NvU32 SIZE_PTR;
#endif // IA64

#define PHYSICAL_ADDRESS_VALUE(p) ((p).LowPart)

typedef struct _def_winnt_hw_info
{
	U016	filler1;
	U008	filler2;

	U008	oldIrql;
	BOOL	rmInitialized;		// per device init flag
	VOID*	pRmSpinLock;
	VOID*	AgpServices;		// win2k's AGP services func ptrs
	VOID*	dmaAdapter;			// PVP_DMA_ADAPTER for 64 bit systems

} WINNTHWINFO, *PWINNTHWINFO;

// System memory allocation tracking

typedef struct _def_sys_mem_info
{
    NvU64   physAddr;           // aligned adaper address
    VOID*   pMdl;               // MDL for user mapping
    VOID*   sysAddr;            // original, potentially unaligned address
    NvU64   logicalAddr;        // address to be used by adapter
    NvU32   length;             // actual number of bytes allocated
    NvU32   clientClass;        // NV01_ROOT_USER or NV01_ROOT
} SYS_MEM_INFO, *PSYS_MEM_INFO;

//---------------------------------------------------------------------------
//
//  Function prototypes for OS interface.
//
//---------------------------------------------------------------------------

// macro to allow different syntax between NT and Win9x
#define OS_READ_REGISTRY_DWORD(pDev, a, b, c) osReadRegistryDword(pDev, a, b, c)

RM_STATUS	osCopyIn				(U008 *src, U008 *target, U032 count);
RM_STATUS	osCopyOut				(U008 *src, U008 *target, U032 count);
RM_STATUS	osAllocMem				(VOID **, U032);
RM_STATUS	osFreeMem				(VOID *);
RM_STATUS	osAllocPages			(PHWINFO, VOID **, U032, U032, U032, U032, U032, VOID **);
RM_STATUS	osFreePages				(PHWINFO, VOID **, U032, U032, VOID *, BOOL);
RM_STATUS   osAllocSystemPages      (PHWINFO, VOID **, U032, U032, VOID **);
RM_STATUS   osFreeSystemPages       (PHWINFO, VOID **, VOID *);
RM_STATUS   osAllocAGPPages         (PHWINFO, VOID **, U032, U032, VOID **);
RM_STATUS   osFreeAGPPages          (PHWINFO, VOID **, VOID *);
RM_STATUS	osAllocDmaListElement	(PDMAUSEROBJECT*);
RM_STATUS	osFreeDmaListElement	(PDMAUSEROBJECT);
RM_STATUS   osVirtualToPhysicalAddr (VOID*, VOID**);
RM_STATUS   osCalculatePteAdjust    (PHWINFO, U032, VOID*, U032*);
RM_STATUS	osGetAddressInfo		(PHWINFO, U032, U032, VOID**, U032, VOID**, U032 *);
RM_STATUS	osLockUserMem			(PHWINFO, U032, U032, VOID*, VOID*, U032 *, U032, U032, U032 *, VOID**, VOID**);
RM_STATUS	osUnlockUserMem			(PHWINFO, U032, VOID*, VOID*, U032, U032, U032, VOID*, U032);
RM_STATUS	osGetCurrentTime		(U032 *, U032 *, U032 *, U032 *, U032 *, U032 *, U032 *);
RM_STATUS	osError					(POBJECT, U032, V032, RM_STATUS);
RM_STATUS	osDelay					(U032);
RM_STATUS   osDelayUs               (U032);
RM_STATUS	osRedrawScreen			(VOID);
RM_STATUS	osBeginWatchCanvas		(U032);
RM_STATUS	osEndWatchCanvas		(U032);
RM_STATUS	osValidateVideoSink		(char *);
RM_STATUS	osValidateImageVideo	(char *, U032 *);
RM_STATUS	osValidateDMAObject		(char *, U032, U032 *);
char*    	osStringCopy			(char *, const char *);
U032    	osStringLength			(const char *);
unsigned char * osMemCopy			(unsigned char *, const unsigned char *, U032);
RM_STATUS	osMapPciMemoryUser		(PHWINFO, U032, U032, VOID**);
RM_STATUS	osUnmapPciMemoryUser	(PHWINFO, VOID*);
RM_STATUS  	osMapFrameBuffer		(PHWINFO, U032, U032, U032, VOID **);
RM_STATUS  	osMapInstanceMemory		(PHWINFO, U032, U032, U032, VOID **);
RM_STATUS  	osMapFifo				(PHWINFO, U032, U032, VOID **);
RM_STATUS  	osUnmapMemory			(PHWINFO, U032, VOID *, U032);
RM_STATUS   osSetFifoDmaParams      (PHWINFO, U032 *, U032 *, U032 *);
S032     	osStringCompare			(const char *, const char *);
RM_STATUS	osGetCurrentProcess		(U032*);
VOID     	osWriteReg008			(volatile V008*, V008);
VOID     	osWriteReg016			(volatile V016*, V016);
VOID     	osWriteReg032			(volatile V032*, V032);
U008     	osReadReg008			(volatile V008*);
U016     	osReadReg016			(volatile V016*);
U032     	osReadReg032			(volatile V032*);
RM_STATUS	osReadRegistryDword		(PHWINFO, char *, char *, U032 *);
RM_STATUS	osWriteRegistryDword	(PHWINFO, char*, char*, U032);
RM_STATUS	osReadRegistryString	(char*, char*, char*str, U032 *);
RM_STATUS	osWriteRegistryString	(char*, char*, char* str, U032);
RM_STATUS	osReadRegistryBinary	(PHWINFO, char*, char*, U008*, U032 *);
RM_STATUS	osWriteRegistryBinary	(PHWINFO, char*, char*, U008*, U032);
RM_STATUS	osDeviceNameToDeviceClass(char*, U032*);
U032     	osGetCpuFrequency		(VOID);
U032        osPciReadDword          (VOID*, U032);
U016        osPciReadWord           (VOID*, U032);
U008        osPciReadByte           (VOID*, U032);
VOID        osPciWriteDword         (VOID*, U032, U032);
VOID        osPciWriteWord          (VOID*, U032, U016);
VOID        osPciWriteByte          (VOID*, U032, U008);
VOID*       osPciInitHandle         (U008, U008, U008, U016*, U016*);
RM_STATUS	osUpdateAGPLimit		(PHWINFO);

RM_STATUS   osIsr                   (PHWINFO);
RM_STATUS   osMemSet                (VOID *, U032, U032);
RM_STATUS   osCallVideoBIOS         (PHWINFO, U032*, U032*, U032*, U032*, VOID*);

// Win2K interrupt handling
#if (_WIN32_WINNT >= 0x0500)
VOID        RmDpcForIsr             (VOID*, VOID*);
#endif

// Win2K processor synchronization
#if (_WIN32_WINNT >= 0x0500)

RM_STATUS   osInitSpinLock          (PHWINFO);
RM_STATUS   osEnterCriticalCode     (PHWINFO);
RM_STATUS   osExitCriticalCode      (PHWINFO);
RM_STATUS   osDldLinkImg            (VOID *);
RM_STATUS   osDldUnlinkImg          (VOID *);
#else

// define away Win2K only macros
#define osInitSpinLock(p) RM_OK
#define osEnterCriticalCode(p)
#define osExitCriticalCode(p)
#define osDldLinkImg(p) RM_ERROR
#define osDldUnlinkImg(p) RM_ERROR

#endif

#if defined(_WIN64)

RM_STATUS   osInitDmaAdapter        (PHWINFO);

#else

#define osInitDmaAdapter(p)         RM_OK

#endif

#define    osDisableHardwareInterrupts(pDev)    osEnterCriticalCode(pDev)
#define    osEnableHardwareInterrupts(pDev)     osExitCriticalCode(pDev)

// Define away win9x only functions
#define  	osEnsureDeviceEnabled(pDev) 
#define		osExit(s)				osDbgPrintStr("NVRM: "); osDbgPrintStr((s)); osDbgPrintStr("\n"); return RM_ERROR	
#define  	osStateEx(pDev, msg)
#define  	osStateDacEx(pDev, msg)
#define     osDisplayModeHook(pDev, msg)
#define     osmpCheckCallbacks(pDev, dwCallbackSelect)
#define     osPreModeSet(pDev, head)
#define     osPostModeSet(pDev, head)

#define     osFlushCpuCache(p) ((VOID)0)

// define away mac-only macros
#define osReadRegistryBoolean(a,b,c)    1

extern BOOL dacMonitorConnectStatus(PHWINFO, U032);
extern BOOL dacFlatPanelConnectStatus(PHWINFO, U032);
VOID        osPostModeSetEx         (PHWINFO, U032);
VOID        osPreModeSetEx          (PHWINFO, U032);

#define     OEMEnableExtensions()
#define     OEMDisableExtensions()

VOID		osLogInstMemAlloc		(U032, U032, U032);
VOID		osUnlogInstMemAlloc		(U032, U032);

// functions needed for nvagp
/* remap IO memory to kernel space */
void *osMapKernelSpace(unsigned int start, unsigned int size_bytes, U008 mode);
void osUnmapKernelSpace(void *addr, unsigned int size_bytes);

/* remap memory to user space */
void *osMapUserSpace(void *kaddr, void **priv, unsigned int size_bytes, U008 mode);
void osUnmapUserSpace(void *uaddr, void *priv);

/* remap memory to user space */
void *osMapIOSpace(U032 start, U032 size_bytes, void **priv, U008 mode);
void osUnmapIOSpace(void *addr, U032 size_bytes, void *priv, U008 mode);

/* set physical memory range attributes (like write combining) */
RM_STATUS osSetMemRange(U032 start, U032 size_bytes, U008 mode);

// like osAllocMem, but no debugging info written into pages
RM_STATUS osAllocPool(void **addr, unsigned int size_bytes);
RM_STATUS osFreePool(void *addr);

void *osAllocContigPages(unsigned long num_pages);
void osFreeContigPages(void *addr); 
U032 osGetKernPhysAddr(void *kern_virt_addr);
RM_STATUS osGetAGPPhysAddr(PHWINFO pDev, VOID *base, U032 index, U032 *paddr);


// these are in modehw.h which is in the miniport
VOID WriteIndexed(U032 addr, U016 datum);
U016 ReadIndexed(U032 addr, U008 reg);
VOID WritePriv32(U032 datum, U032 addr);
U032 ReadPriv32(U032 addr);
VOID WritePriv08(U032 addr, U008 datum);

VOID		osStateFbEx				(PHWINFO);
RM_STATUS	osSetVideoMode			(PHWINFO);
RM_STATUS	osNotifyEvent			(PHWINFO, POBJECT, U032, U032, U032, RM_STATUS, U032);
RM_STATUS 	initMapping				(PHWINFO);
RM_STATUS 	initFbEx				(PHWINFO);
RM_STATUS 	initFifoEx				(PHWINFO);
RM_STATUS 	initGrEx				(PHWINFO);
RM_STATUS 	initDacEx				(PHWINFO);
RM_STATUS 	initCodecEx				(PHWINFO);
BOOL        RmInitAGP               (PHWINFO);
VOID        NvUpdateAGPConfig       (PHWINFO);
RM_STATUS   NvGetAGPBaseLimit       (PHWINFO, U032 *, U032 *);

#define PENDING_INTERRUPTS \
    (DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING)|DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING))

VOID		RmEnableInterrupts		(PHWINFO);
VOID		RmDisableInterrupts		(PHWINFO);
BOOL		RmInterruptPending		(PHWINFO, BOOL*);

#if DBG
VOID osLogMemAlloc(VOID *address, U032 size);
VOID osUnlogMemAlloc(VOID *address);
#endif // DBG

//---------------------------------------------------------------------------
//
//  Required defines for OS interface.
//
//---------------------------------------------------------------------------

#define NV_MEMORY_TYPE_SYSTEM       0
#define NV_MEMORY_TYPE_AGP          1

#define NV_MEMORY_NONCONTIGUOUS     0
#define NV_MEMORY_CONTIGUOUS        1

#define NV_MEMORY_DEFAULT           0
#define NV_MEMORY_UNCACHED          1
#define NV_MEMORY_WRITECOMBINED     2
#define NV_MEMORY_WRITETHRU         3
#define NV_MEMORY_WRITEPROTECT      4
#define NV_MEMORY_WRITEBACK         5

/////////////////////////////////
#define DPC_IMPLEMENTATION 1
/////////////////////////////////


typedef struct
{
    U016  HdrSize;
    U016  InfoFlags;
    U032  DevNodeHandle;
    U008  DriverName[16];
    U016  XRes;
    U016  YRes;
    U016  DPI;
    U008  Planes;
    U008  Bpp;
    U016  RefreshRateMax;
    U016  RefreshRateMin;
    U016  LowHorz;
    U016  HighHorz;
    U016  LowVert;
    U016  HighVert;
    U032  MonitorDevNodeHandle;
    U008  HorzSyncPolarity;
    U008  VertSyncPolarity;
} DISPLAYINFO, *PDISPLAYINFO;

// DMA list element pool
#define DMALISTELEMENT_POOL_SIZE 16
typedef struct
{
	BOOL inUse;
	DMAUSEROBJECT dmaListElement;

} DMALISTELEMENT_POOL_ELEMENT, *PDMALISTELEMENT_POOL_ELEMENT;

// more globals
extern DISPLAYINFO osDisplayInfo;
extern PDMALISTELEMENT_POOL_ELEMENT dmaListElementPool;


// NT callbacks...

// notify callback action
#define NV_OS_WRITE_THEN_AWAKEN	   0x00000001

// This is callback function in the miniport.
// The argument is a device extension, and must be cast as such to be useful.
typedef VOID (*MINIPORT_CALLBACK)(VOID*);


// memory allocation
#define NV_MEMORY_TAG '  VN'

// AGP macros
#define BYTES_MAPPED_PER_PAGE   ((RM_PAGE_SIZE >> 2) * RM_PAGE_SIZE)

// Arguments to osMapIOSpace and friends

#define MAP_UNCACHED       0x0
#define MAP_CACHED         0x1
#define MAP_WRITECOMBINE   0x2
#define	MAP_KERNEL         0x0
#define	MAP_USER           0x4

// Arguments to osSetMemSpace

#define MEM_WRITECOMBINE   0x0

#if (_WIN32_WINNT < 0x500) && defined(NTRM)
extern VOID SignalModeSwitchEvent();
VOID RmSignalHotKeyEvent();
#endif

#endif // _OS_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\win9x\vxd\nv10\nv10wtch.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995-2000. All rights reserved.
// (C) Copyright SGS-THOMSON Microelectronics Inc., 1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: NV10wtch.C                                                        *
*   Winice .N Debug Interface. NV10 code                                    *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       Jim Vito 2/6/98
\***************************************************************************/
#include "basedef.h"
#include "vmmtypes.h"
#include "vmm.h"        // put this first. we redefine macro SF_BIT in nvrm.h
#include <nv_ref.h>
#include <nv10_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <fifo.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvrmwin.h"
#include "nvhw.h"
#include "vpicd.h"
#include "vdd.h"
#include "vnvrmd.h"
#include "oswin.h"
#include "vmm2.h"       // more vmm services
#include "vwin32.h"
#include "nv10_hal.h"

#ifdef DEBUG

//
// prototypes
//
U032 NvWatch_GetObjectFromInst  (PHWINFO, U032, U032 *);
U032 NvWatch_Dump_HT_Object_From_Handle(PHWINFO, U032);
VOID NvWatch_display_prompt     (PHWINFO, char *);
char get_winice_input           (VOID);

//
// defines
//
#define NVWATCH_SIMPLE      0
#define NVWATCH_COMPLEX     1
#define INSTANCE_MEM_SPACE  nvAddr 
#define CONTEXT_USE_PUT     0
#define CONTEXT_USE_GET     1

//****NV CONTEXT MENU******************************************************************************

void NvWatch_NV10_Dump_SubChannelContext(PHWINFO pDev, U032 p_channel)
{
  U032  sub_counter;
  U032  nvwatch_fifo_engine_cache1;
  U032  enginet, *inst_ptr, tempv;

  nvwatch_fifo_engine_cache1 = REG_RD32(NV_PFIFO_CACHE1_ENGINE);
  // For each subchannel (Dump the Engine, then the object).
  for(sub_counter=0;sub_counter<NUM_SUBCHANNELS;sub_counter++){
    enginet = nvwatch_fifo_engine_cache1;
    enginet &= 3;
    switch(enginet){
      case 0:
        // We need to get the channel.
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Software Object in Fifo cache0 for Subchannel ",sub_counter);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "Accessing pDev->DBfifoTable ...");
        if (pDev->DBfifoTable[p_channel].InUse == FALSE)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "ERROR: pDev->DBfifoTable NOT InUse !??");
        else{
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Object Name = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->Name);
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Object Class = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->Class->Type);
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "CHID = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->ChID);
          DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Subchannel = ",pDev->DBfifoTable[p_channel].SubchannelContext[sub_counter]->Subchannel);
//////    U032       Name;
//////    PCLASS     Class;
//////    U032       ChID;
//////    U032       Subchannel;
//////    NODE       Node[NUM_FIFOS];
//////    POBJECT    Next;
//////    PDMAOBJECT NotifyXlate;
//////    U032       NotifyAction;
//////    U032       NotifyTrigger;
//////    PEVENTNOTIFICATION NotifyEvent;
        }  
        break;
      case 1:
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Graphics Object in Fifo cache0 for Subchannel ",sub_counter);
        
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE1 = ",REG_RD32(NV_PGRAPH_CTX_CACHE1(sub_counter)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE2 = ",REG_RD32(NV_PGRAPH_CTX_CACHE2(sub_counter)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE3 = ",REG_RD32(NV_PGRAPH_CTX_CACHE3(sub_counter)));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "   NV_PGRAPH_CTX_CACHE4 = ",REG_RD32(NV_PGRAPH_CTX_CACHE4(sub_counter)));
        
        tempv = (U032) REG_RD32( NV_PGRAPH_CTX_CACHE4(sub_counter) );
        tempv &= 0xFFFF;
        tempv <<= 4;
        tempv += (U032) (INSTANCE_MEM_SPACE + (pDev->Pram.HalInfo.PraminOffset/4));
        inst_ptr = (U032 *) tempv;
        
        {
          U032 DHandle;
          
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nDumping the CTX_CACHE4 Object ...");
          tempv = (U032) REG_RD32( NV_PGRAPH_CTX_CACHE4(sub_counter) );
          tempv &= 0xFFFF;
          if(!NvWatch_GetObjectFromInst(pDev, tempv, &DHandle)){
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: Object NOT FOUND !\n");
          }else{  
              NvWatch_Dump_HT_Object_From_Handle(pDev, DHandle);
              DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n\n");
          }  
        }
        break;
      case 2:
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DVD Object in Fifo cache0 for Subchannel ",sub_counter);
        break;
      default:
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: INVALID Object in Fifo cache0!");
        break;
    }
    nvwatch_fifo_engine_cache1 >>= 4;
  }
}

void NvWatch_NV10_ContextInfo_help(PHWINFO pDev)
{

/////  NvWatch_channel = REG_RD32(NV_PGRAPH_CTX_USER);
/////  NvWatch_channel >>= 24;
/////  NvWatch_channel &= NUM_FIFOS-1; 
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCommands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      s   - Query SubChannel Contexts (Currently supports active channel ONLY\n\r");
//  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "            Active Channel = ",NvWatch_channel);
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      ?   - ???\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      q   - quit this\n\r\n\r");
}

VOID NvWatch_NV10_Query_DeviceContext(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  U032 m_channel=0;
  char pstring[]="NvWatch Context";

  NvWatch_NV10_ContextInfo_help(pDev);
  
  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;
      case 's':
      case 'S':
        {
          U032 save_pgraph_fifo;
          
          // Clear the NV_PGRAPH_FIFO so that it can be read.
          save_pgraph_fifo = REG_RD32(NV_PGRAPH_FIFO);
          REG_WR32(NV_PGRAPH_FIFO, 0);
          NvWatch_NV10_Dump_SubChannelContext(pDev, m_channel);
          // Restore the NV_PGRAPH_FIFO.
          REG_WR32(NV_PGRAPH_FIFO, save_pgraph_fifo);
        }  
        break;
      case 'c': // Dump hash table
      case 'C': // Dump hash table
        break;
      default: // Help
        NvWatch_NV10_ContextInfo_help(pDev);
        break;  
    }
  }
}

//****DMA PUSHER AND FIFO MENU******************************************************************************

// THE FIFO: Actually 2X the HW size. A second alias image exists.
//-----------------------------------------
//|0                                      | <-- PFIFO_PUT (word pointer)
//|---------------------------------------| <-- PFIFO_GET ( "     "    )
//|1                                      |
//|---------------------------------------| If PFIFO_PUT==PFIFO_GET then the Fifo is empty
//|2                                      |
//|---------------------------------------| If (PFIFO_PUT+128)%256==PFIFO_GET then the Fifo is full
//|...                                    |
//|---------------------------------------| 0 <= PFIFO_PUT, PFIFO_GET <= 255*4
//|---------------------------------------|
//|127                                    |
//|---------------------------------------|
//|128 == 0 alias                         |
//|---------------------------------------|
//|129 == 1 alias                         |
//|---------------------------------------|
//|...                                    |
//|---------------------------------------|
//|---------------------------------------|
//|255 == 127 alias                       |
//-----------------------------------------
void NvWatch_NV10_DumpFifoContents(PHWINFO pDev)
{

  U032 save_puller, save_pusher;
  U032 nvw_fifo_get,nvw_fifo_put;
  U032  fifo_count;
  BOOL fifo_is_empty=FALSE,fifo_is_full=FALSE;
  
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
  
  // In order to dump the fifo the puller and pusher must be disabled.
  save_puller = REG_RD32(NV_PFIFO_CACHE1_PULL0);
  save_pusher = REG_RD32(NV_PFIFO_CACHE1_PUSH0);
  REG_WR32(NV_PFIFO_CACHE1_PULL0,0);
  REG_WR32(NV_PFIFO_CACHE1_PUSH0,0);

  // The Fifo is 128 entries deep.
  nvw_fifo_get = REG_RD32(NV_PFIFO_CACHE1_GET);
  nvw_fifo_put = REG_RD32(NV_PFIFO_CACHE1_PUT);

  for(fifo_count=0;fifo_count<128;fifo_count++){
    
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, fifo_count);
    
    if(( ( (nvw_fifo_get%(128*4)) /4) == fifo_count)&&(( (nvw_fifo_put%(128*4)) /4) == fifo_count)){
      if(nvw_fifo_get == nvw_fifo_put)
        fifo_is_empty = TRUE;
      else  
        fifo_is_full = TRUE;
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,    " PFIFO_GET->\n");
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,    "           PFIFO_PUT-> Method = ");
    }else{
      if(( (nvw_fifo_get%(128*4)) /4) == fifo_count)
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,  " PFIFO_GET-> Method = ");
      else{  
        if(( (nvw_fifo_put%(128*4)) /4) == fifo_count)
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS," PFIFO_PUT-> Method = ");
        else
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"             Method = ");
      }  
    }  
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, REG_RD32(NV_PFIFO_CACHE1_METHOD(fifo_count)) );
    
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"             Data = ");
    DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, REG_RD32(NV_PFIFO_CACHE1_DATA(fifo_count)) );
    
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"\n");
  }

  if(fifo_is_empty){
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nThe Fifo is EMPTY\n\r");
  }else{
    if(fifo_is_full){
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nThe Fifo is FULL\n\r");
    }else{
      // This should be an error !!! Never full and Empty!
      DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nERROR: The Fifo is Neither FULL or EMPTY!!!\n\r");
    }
  }  
  
  // Restore the pusher and puller registers.
  REG_WR32(NV_PFIFO_CACHE1_PULL0,save_puller);
  REG_WR32(NV_PFIFO_CACHE1_PUSH0,save_pusher);
  
}

// Specify a device, channel and some format info.
void NvWatch_NV10_DumpPushBuffer(PHWINFO pDev, U032 p_channel, U032 ref_ptr, U032 bytes_before_ptr, U032 bytes_after_ptr)
{
    U032 page_ref, ref_pte, ref_offset;
    U032 dmacontext_inst, *dmacontext_inst_ptr;
    U032 *instance_fc_ptr;
    U032 *pte_ptr;

    // if this is the p_current channel.
    if(p_channel == (REG_RD32(NV_PFIFO_CACHE1_PUSH1) & 0x1F)){
      if(ref_ptr == CONTEXT_USE_PUT)
        ref_ptr = REG_RD32(NV_PFIFO_CACHE1_PUT);
      else
        ref_ptr = REG_RD32(NV_PFIFO_CACHE1_GET);

      dmacontext_inst = REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE);
    }else{
      // Get the DMA Context for the channels pusher. (Just grab it from the FC_Context in instance memory.
      instance_fc_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset+0x10000)/4) + 0x4000);

      // Point to the correct context.
      instance_fc_ptr += p_channel*8;   // 8 dwords per context.
      // Get the 3rd DWORD from the fifo contexts.
      dmacontext_inst = *(instance_fc_ptr+2);
      
      if(ref_ptr == CONTEXT_USE_PUT)
        ref_ptr = (U032) *(instance_fc_ptr);
      else
        ref_ptr = (U032) *(instance_fc_ptr+1);
      
    }
    // Get a pointer to the ContextDma for the push buffer.
    dmacontext_inst &= 0xFFFF;
    dmacontext_inst <<=4;
    dmacontext_inst += (U032) INSTANCE_MEM_SPACE/*nvAddr*/ + (U032) pDev->Pram.HalInfo.PraminOffset;
    dmacontext_inst_ptr = (U032 *) dmacontext_inst;

    // Get the Offset and the 4KB aligned PTE.
    ref_offset = ref_ptr & 0xfff;
    page_ref = ref_ptr >> 12;

    // Get the PTE from the instance data. Map it and add the offset to get the linear ptr.
    ref_pte = *(dmacontext_inst_ptr + 2 + page_ref);


    pte_ptr = (U032 *) vmmMapPhysToLinear(ref_pte, 0x02000, 0);
    pte_ptr += (ref_offset/4);

    ///// // The pointers should now be set up to fetch the data. 
    ///// DBG_PRINT_STRING(DEBUGLEVEL_ERRORS," DmaPush Buffer Dump for channel ");
    ///// DBG_PRINT_VALUE(DEBUGLEVEL_ERRORS, REG_RD32(fifo_count);
}

/////void NvWatch_NV10_DmaPushAndFifo_help(PHWINFO pDev)
/////{
/////  U032 x;
/////
/////
/////  if(REG_RD32(NV_PFIFO_CACHE1_PUSH1) & (NV_PFIFO_CACHE1_PUSH1_MODE_DMA<<8)){
/////      DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  The current channel is PUSH Channel # ",((REG_RD32(NV_PFIFO_CACHE1_PUSH1))&0x1F) );
/////  }else{
/////      DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  The current channel is PIO Channel # ", ((REG_RD32(NV_PFIFO_CACHE1_PUSH1))&0x1F) );
/////  }
/////
/////  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCommands as follows:\n\r");
/////  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      f   - Dump Fifo Contents\n\r");
/////  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       " ALL ITEMS BELOW ARE CURRENTLY NOT SUPPORTED\n\r");
/////  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      d   - Dump DmaPusher for Current Channel\n\r\n\r");
/////
/////  // Get the number of dmapush channels.
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      0   - Dump DmaPusher for Push Channel 0\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<1))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      1   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<2))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      2   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<3))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      3   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<4))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      4   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<5))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      5   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<6))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      6   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<7))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      7   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<8))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      8   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<9))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      9   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<10))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      a   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<11))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      b   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<12))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      c   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<13))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      d   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<14))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      e   - Dump DmaPusher for Push Channel 1\n\r");
/////  if(REG_RD32(NV_PFIFO_MODE) & (NV_PFIFO_MODE_CHANNEL_0_DMA<<15))
/////    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      f   - Dump DmaPusher for Push Channel 1\n\r");
/////  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit this\n\r\n\r");
/////}

void NvWatch_NV10_DumpUserDmaBuffersAtGet(PHWINFO pDev)
{
    U032 channel_count;
    U032 current_channel;
    U032 channel_get;
    U032 channel_dma_inst;
    U032 channel_get_page, channel_get_offset,channel_dmabuffer_physical;
    U032 *instance_data_ptr, *instance_pte_ptr;

    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n*********************************************");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCalculating Physical addresses for PushBuffers\n");
    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,   "*********************************************\n");

    current_channel = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    for(channel_count=0;channel_count<NUM_FIFOS;channel_count++){
        // Is this channel running in DMA Mode ?
        if((REG_RD32(NV_PFIFO_MODE)>>channel_count)&1){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DMA Channel=",(int)channel_count);
            // Get the get pointer value.
            // From fifo context or the fifo engine ?
            if(channel_count==current_channel){
                // Go to the fifo engine.
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "This is the current channel=",(int)channel_count);
                channel_get = REG_RD32(NV_PFIFO_CACHE1_DMA_GET);
                channel_dma_inst = REG_RD32(NV_PFIFO_CACHE1_DMA_INSTANCE);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The get pointer from the fifo engine=",(int)         channel_get);
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The dma instance from the fifo engine=",(int)channel_dma_inst);

            }else{
                // Go to the fifo context area in instance memory.
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "This is NOT the current channel=",(int)channel_count);
                {
                   U032 *ptr_fifocontextarea;

                   switch(REG_RD_DRF(_PFIFO, _RAMHT, _SIZE)){
                     case NV_PFIFO_RAMHT_SIZE_4K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x1000) /4) );
                       break;
                     case NV_PFIFO_RAMHT_SIZE_8K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x2000) /4) );
                       break;
                     case NV_PFIFO_RAMHT_SIZE_16K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x4000) /4) );
                       break;
                     case NV_PFIFO_RAMHT_SIZE_32K:
                       ptr_fifocontextarea = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ( (pDev->Pram.HalInfo.PraminOffset+0x10000+0x8000) /4) );
                       break;
                   }
                   channel_get = (U032) *(ptr_fifocontextarea+1+(channel_count*8));
                   channel_dma_inst = (U032) *(ptr_fifocontextarea+3+(channel_count*8));
                   channel_dma_inst &= 0xFFFF;
                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The get pointer from the fifo context=",(int)         channel_get);
                   DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "The dma instance from the fifo context=",(int)channel_dma_inst);
                }
            } // equal current channel

            channel_get_page = (U032) channel_get >> 12;
            channel_get_offset = (U032) channel_get & 0xFFF;
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Channel get pointers page=",(int)   channel_get_page);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Channel get pointers offset=",(int) channel_get_offset);


            instance_data_ptr = (U032 *) (INSTANCE_MEM_SPACE/*nvAddr*/ + ((pDev->Pram.HalInfo.PraminOffset+(channel_dma_inst<<4))/4));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Linear address of Push buffer context=",(int)instance_data_ptr);
            // System memory DMA contexts will have all of the PTE's listed in instance memory.(scatter/gather)
            // AGP and FB DMA Contexts will only require a base DMA context.
            // Check the type bits of the DMA context in instance memory.
            switch( ((*instance_data_ptr)>>16) & 3){
                case 2: /*system memory*/
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PUSH_BUFFER in SYSTEM MEMORY\n");
                    instance_pte_ptr = (U032 *) instance_data_ptr + (2+channel_get_page);
                    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Linear address of Push buffer context PTE=",(int)instance_pte_ptr);
                    channel_dmabuffer_physical = (U032) ((*instance_pte_ptr)&0xFFFFF000)+channel_get_offset;
                    break;
                case 3: /*AGP system memory*/
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PUSH_BUFFER in AGP SYSTEM MEMORY\n");
                    instance_pte_ptr = (U032 *) instance_data_ptr + (2);
                    channel_dmabuffer_physical = (U032) ((*instance_pte_ptr)&0xFFFFF000)+channel_get;
                    break;
                case 0: /*frame buffer NVM*/
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "PUSH_BUFFER in FRAME BUFFER MEMORY\n");
                    instance_pte_ptr = (U032 *) instance_data_ptr + (2);
                    channel_dmabuffer_physical = (U032) ((*instance_pte_ptr)&0xFFFFF000)+channel_get;
                    break;
            }
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Physical address of Push buffer at the get pointer=",(int)channel_dmabuffer_physical);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "Don't forget the 12bit ADJUST value for the DMA Context=",(int)((*instance_data_ptr)>>20));
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "ADJUSTED Physical address of Push buffer at the get pointer=",(int)(channel_dmabuffer_physical+((*instance_data_ptr)>>20)));
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\n");
        } // DMA Mode
    }
}

void NvWatch_NV10_DmaPushAndFifo_help(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\nCommands as follows:\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      f   - Dump Fifo Contents\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      c   - Get Physical address of DmaBuffers at Current Get ptr.(DmaPush channels only)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,       "      d   - Dump DmaPusher Info (Not Implemented)\n\r");
  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "      q   - quit this\n\r\n\r");
}

int NvWatch_NV10_DmaPushAndFifo(PHWINFO pDev)
{
  BOOL keep_running=TRUE;
  char in_char;
  // Go with 6 dwords pre and post.
  U032 bytes_before_ptr = 48;
  U032 bytes_after_ptr = 48;
  char pstring[]="NvWatch Fifo";
 
  NvWatch_NV10_DmaPushAndFifo_help(pDev);

  while(keep_running)
  {
    NvWatch_display_prompt(pDev, pstring);
  
    in_char = get_winice_input();
    switch(in_char){
      case 'q':
      case 'Q':
        keep_running = FALSE;
        break;
      case 'F': // Dump fifo 
      case 'f': // Dump fifo 
        NvWatch_NV10_DumpFifoContents(pDev);
        break;
      case 'd':
        //p_channel = REG_RD32(NV_PFIFO_CACHE1_PUSH1) & 0x1F;
        //ref_ptr = CONTEXT_USE_GET;
        //NvWatch_NV10_DumpPushBuffer(device, p_channel, ref_ptr, bytes_before_ptr, bytes_after_ptr)   
        break;
      case 'c': 
      case 'C': 
        NvWatch_NV10_DumpUserDmaBuffersAtGet(pDev);
        break;
      default: // Help
        NvWatch_NV10_DmaPushAndFifo_help(pDev);
        break;  
    }
  }

  return (RM_OK);
}

void NvWatch_NV10_Dump_Graphics(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nGraphics Engine State:\r\n");
 
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_0             = ", REG_RD32(   NV_PGRAPH_DEBUG_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_1             = ", REG_RD32(   NV_PGRAPH_DEBUG_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_2             = ", REG_RD32(   NV_PGRAPH_DEBUG_2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DEBUG_3             = ", REG_RD32(   NV_PGRAPH_DEBUG_3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_INTR                = ", REG_RD32(   NV_PGRAPH_INTR                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_NSOURCE             = ", REG_RD32(   NV_PGRAPH_NSOURCE               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_INTR_EN             = ", REG_RD32(   NV_PGRAPH_INTR_EN               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_SWITCH1         = ", REG_RD32(   NV_PGRAPH_CTX_SWITCH1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_SWITCH2         = ", REG_RD32(   NV_PGRAPH_CTX_SWITCH2           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_SWITCH3         = ", REG_RD32(   NV_PGRAPH_CTX_SWITCH3           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_CONTROL         = ", REG_RD32(   NV_PGRAPH_CTX_CONTROL           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CTX_USER            = ", REG_RD32(   NV_PGRAPH_CTX_USER              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FIFO                = ", REG_RD32(   NV_PGRAPH_FIFO                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FFINTFC_ST2         = ", REG_RD32(   NV_PGRAPH_FFINTFC_ST2           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_STATUS              = ", REG_RD32(   NV_PGRAPH_STATUS                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_TRAPPED_ADDR        = ", REG_RD32(   NV_PGRAPH_TRAPPED_ADDR          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_TRAPPED_DATA        = ", REG_RD32(   NV_PGRAPH_TRAPPED_DATA_LOW      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_SURFACE             = ", REG_RD32(   NV_PGRAPH_SURFACE               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_NOTIFY              = ", REG_RD32(   NV_PGRAPH_NOTIFY                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET0            = ", REG_RD32(   NV_PGRAPH_BOFFSET0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET1            = ", REG_RD32(   NV_PGRAPH_BOFFSET1              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET2            = ", REG_RD32(   NV_PGRAPH_BOFFSET2              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET3            = ", REG_RD32(   NV_PGRAPH_BOFFSET3              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET4            = ", REG_RD32(   NV_PGRAPH_BOFFSET4              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BOFFSET5            = ", REG_RD32(   NV_PGRAPH_BOFFSET5              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE0              = ", REG_RD32(   NV_PGRAPH_BBASE0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE1              = ", REG_RD32(   NV_PGRAPH_BBASE1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE2              = ", REG_RD32(   NV_PGRAPH_BBASE2                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE3              = ", REG_RD32(   NV_PGRAPH_BBASE3                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE4              = ", REG_RD32(   NV_PGRAPH_BBASE4                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BBASE5              = ", REG_RD32(   NV_PGRAPH_BBASE5                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH0             = ", REG_RD32(   NV_PGRAPH_BPITCH0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH1             = ", REG_RD32(   NV_PGRAPH_BPITCH1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH2             = ", REG_RD32(   NV_PGRAPH_BPITCH2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH3             = ", REG_RD32(   NV_PGRAPH_BPITCH3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPITCH4             = ", REG_RD32(   NV_PGRAPH_BPITCH4               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT0             = ", REG_RD32(   NV_PGRAPH_BLIMIT0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT1             = ", REG_RD32(   NV_PGRAPH_BLIMIT1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT2             = ", REG_RD32(   NV_PGRAPH_BLIMIT2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT3             = ", REG_RD32(   NV_PGRAPH_BLIMIT3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT4             = ", REG_RD32(   NV_PGRAPH_BLIMIT4               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLIMIT5             = ", REG_RD32(   NV_PGRAPH_BLIMIT5               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BSWIZZLE2           = ", REG_RD32(   NV_PGRAPH_BSWIZZLE2             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BSWIZZLE5           = ", REG_RD32(   NV_PGRAPH_BSWIZZLE5             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BPIXEL              = ", REG_RD32(   NV_PGRAPH_BPIXEL                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_LIMIT_VIOL_Z        = ", REG_RD32(   NV_PGRAPH_LIMIT_VIOL_Z          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_STATE               = ", REG_RD32(   NV_PGRAPH_STATE                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CACHE_INDEX         = ", REG_RD32(   NV_PGRAPH_CACHE_INDEX           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CACHE_RAM           = ", REG_RD32(   NV_PGRAPH_CACHE_RAM             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_PITCH           = ", REG_RD32(   NV_PGRAPH_DMA_PITCH             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DVD_COLORFMT        = ", REG_RD32(   NV_PGRAPH_DVD_COLORFMT          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_SCALED_FORMAT       = ", REG_RD32(   NV_PGRAPH_SCALED_FORMAT         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PATT_COLOR0         = ", REG_RD32(   NV_PGRAPH_PATT_COLOR0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PATT_COLOR1         = ", REG_RD32(   NV_PGRAPH_PATT_COLOR1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PATTERN_SHAPE       = ", REG_RD32(   NV_PGRAPH_PATTERN_SHAPE         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MONO_COLOR0         = ", REG_RD32(   NV_PGRAPH_MONO_COLOR0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ROP3                = ", REG_RD32(   NV_PGRAPH_ROP3                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CHROMA              = ", REG_RD32(   NV_PGRAPH_CHROMA                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BETA_AND            = ", REG_RD32(   NV_PGRAPH_BETA_AND              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BETA_PREMULT        = ", REG_RD32(   NV_PGRAPH_BETA_PREMULT          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CONTROL0            = ", REG_RD32(   NV_PGRAPH_CONTROL0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CONTROL2            = ", REG_RD32(   NV_PGRAPH_CONTROL2              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_BLEND               = ", REG_RD32(   NV_PGRAPH_BLEND                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DPRAM_INDEX         = ", REG_RD32(   NV_PGRAPH_DPRAM_INDEX           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DPRAM_DATA          = ", REG_RD32(   NV_PGRAPH_DPRAM_DATA            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_STORED_FMT          = ", REG_RD32(   NV_PGRAPH_STORED_FMT            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FORMATS             = ", REG_RD32(   NV_PGRAPH_FORMATS               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC0      = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC0        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC1      = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC1        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC2      = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC2        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_XY_LOGIC_MISC3      = ", REG_RD32(   NV_PGRAPH_XY_LOGIC_MISC3        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_X_MISC              = ", REG_RD32(   NV_PGRAPH_X_MISC                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_Y_MISC              = ", REG_RD32(   NV_PGRAPH_Y_MISC                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_XMIN      = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_XMIN        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_XMAX      = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_XMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_YMIN      = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_YMIN        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIP_YMAX      = ", REG_RD32(   NV_PGRAPH_ABS_UCLIP_YMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_XMIN     = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_XMIN       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_XMAX     = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_XMAX       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_YMIN     = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_YMIN       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_UCLIPA_YMAX     = ", REG_RD32(   NV_PGRAPH_ABS_UCLIPA_YMAX       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_SOURCE_COLOR        = ", REG_RD32(   NV_PGRAPH_SOURCE_COLOR          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_VALID1              = ", REG_RD32(   NV_PGRAPH_VALID1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_VALID2              = ", REG_RD32(   NV_PGRAPH_VALID2                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_ICLIP_XMAX      = ", REG_RD32(   NV_PGRAPH_ABS_ICLIP_XMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_ABS_ICLIP_YMAX      = ", REG_RD32(   NV_PGRAPH_ABS_ICLIP_YMAX        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPX_0             = ", REG_RD32(   NV_PGRAPH_CLIPX_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPX_1             = ", REG_RD32(   NV_PGRAPH_CLIPX_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPY_0             = ", REG_RD32(   NV_PGRAPH_CLIPY_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_CLIPY_1             = ", REG_RD32(   NV_PGRAPH_CLIPY_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MISC24_0            = ", REG_RD32(   NV_PGRAPH_MISC24_0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MISC24_1            = ", REG_RD32(   NV_PGRAPH_MISC24_1              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_MISC24_2            = ", REG_RD32(   NV_PGRAPH_MISC24_2              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PASSTHRU_0          = ", REG_RD32(   NV_PGRAPH_PASSTHRU_0            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PASSTHRU_1          = ", REG_RD32(   NV_PGRAPH_PASSTHRU_1            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_PASSTHRU_2          = ", REG_RD32(   NV_PGRAPH_PASSTHRU_2            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_XY              = ", REG_RD32(   NV_PGRAPH_D3D_XY                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_U0              = ", REG_RD32(   NV_PGRAPH_D3D_U0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_V0              = ", REG_RD32(   NV_PGRAPH_D3D_V0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_U1              = ", REG_RD32(   NV_PGRAPH_D3D_U1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_V1              = ", REG_RD32(   NV_PGRAPH_D3D_V1                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_ZETA            = ", REG_RD32(   NV_PGRAPH_D3D_ZETA              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_RGB             = ", REG_RD32(   NV_PGRAPH_D3D_RGB               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_S               = ", REG_RD32(   NV_PGRAPH_D3D_S                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_D3D_M               = ", REG_RD32(   NV_PGRAPH_D3D_M                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FORMAT0             = ", REG_RD32(   NV_PGRAPH_FORMAT0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FORMAT1             = ", REG_RD32(   NV_PGRAPH_FORMAT1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FILTER0             = ", REG_RD32(   NV_PGRAPH_FILTER0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_FILTER1             = ", REG_RD32(   NV_PGRAPH_FILTER1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE0ALPHA       = ", REG_RD32(   NV_PGRAPH_COMBINE0ALPHA         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE0COLOR       = ", REG_RD32(   NV_PGRAPH_COMBINE0COLOR         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE1ALPHA       = ", REG_RD32(   NV_PGRAPH_COMBINE1ALPHA         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_COMBINE1COLOR       = ", REG_RD32(   NV_PGRAPH_COMBINE1COLOR         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_START_0         = ", REG_RD32(   NV_PGRAPH_DMA_START_0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_START_1         = ", REG_RD32(   NV_PGRAPH_DMA_START_1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_LENGTH          = ", REG_RD32(   NV_PGRAPH_DMA_LENGTH            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_MISC            = ", REG_RD32(   NV_PGRAPH_DMA_MISC              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_DATA_0          = ", REG_RD32(   NV_PGRAPH_DMA_DATA_0            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_DATA_1          = ", REG_RD32(   NV_PGRAPH_DMA_DATA_1            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_RM              = ", REG_RD32(   NV_PGRAPH_DMA_RM                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_XLATE_INST    = ", REG_RD32(   NV_PGRAPH_DMA_A_XLATE_INST      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_CONTROL       = ", REG_RD32(   NV_PGRAPH_DMA_A_CONTROL         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_LIMIT         = ", REG_RD32(   NV_PGRAPH_DMA_A_LIMIT           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_TLB_PTE       = ", REG_RD32(   NV_PGRAPH_DMA_A_TLB_PTE         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_TLB_TAG       = ", REG_RD32(   NV_PGRAPH_DMA_A_TLB_TAG         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_ADJ_OFFSET    = ", REG_RD32(   NV_PGRAPH_DMA_A_ADJ_OFFSET      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_OFFSET        = ", REG_RD32(   NV_PGRAPH_DMA_A_OFFSET          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_SIZE          = ", REG_RD32(   NV_PGRAPH_DMA_A_SIZE            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_A_Y_SIZE        = ", REG_RD32(   NV_PGRAPH_DMA_A_Y_SIZE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_XLATE_INST    = ", REG_RD32(   NV_PGRAPH_DMA_B_XLATE_INST      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_CONTROL       = ", REG_RD32(   NV_PGRAPH_DMA_B_CONTROL         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_LIMIT         = ", REG_RD32(   NV_PGRAPH_DMA_B_LIMIT           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_TLB_PTE       = ", REG_RD32(   NV_PGRAPH_DMA_B_TLB_PTE         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_TLB_TAG       = ", REG_RD32(   NV_PGRAPH_DMA_B_TLB_TAG         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_ADJ_OFFSET    = ", REG_RD32(   NV_PGRAPH_DMA_B_ADJ_OFFSET      ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_OFFSET        = ", REG_RD32(   NV_PGRAPH_DMA_B_OFFSET          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_SIZE          = ", REG_RD32(   NV_PGRAPH_DMA_B_SIZE            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PGRAPH_DMA_B_Y_SIZE        = ", REG_RD32(   NV_PGRAPH_DMA_B_Y_SIZE          ));
}  

void NvWatch_NV10_Dump_Fifo(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nFifo State:\r\n");
  
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DELAY_0              = ", REG_RD32(   NV_PFIFO_DELAY_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DMA_TIMESLICE        = ", REG_RD32(   NV_PFIFO_DMA_TIMESLICE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_PIO_TIMESLICE        = ", REG_RD32(   NV_PFIFO_PIO_TIMESLICE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_TIMESLICE            = ", REG_RD32(   NV_PFIFO_TIMESLICE              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_NEXT_CHANNEL         = ", REG_RD32(   NV_PFIFO_NEXT_CHANNEL           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DEBUG_0              = ", REG_RD32(   NV_PFIFO_DEBUG_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_INTR_0               = ", REG_RD32(   NV_PFIFO_INTR_0                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_INTR_EN_0            = ", REG_RD32(   NV_PFIFO_INTR_EN_0              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RAMHT                = ", REG_RD32(   NV_PFIFO_RAMHT                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RAMFC                = ", REG_RD32(   NV_PFIFO_RAMFC                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RAMRO                = ", REG_RD32(   NV_PFIFO_RAMRO                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHES               = ", REG_RD32(   NV_PFIFO_CACHES                 ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_MODE                 = ", REG_RD32(   NV_PFIFO_MODE                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_DMA                  = ", REG_RD32(   NV_PFIFO_DMA                    ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_SIZE                 = ", REG_RD32(   NV_PFIFO_SIZE                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PUSH0         = ", REG_RD32(   NV_PFIFO_CACHE0_PUSH0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PUSH0         = ", REG_RD32(   NV_PFIFO_CACHE1_PUSH0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PUSH1         = ", REG_RD32(   NV_PFIFO_CACHE0_PUSH1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PUSH1         = ", REG_RD32(   NV_PFIFO_CACHE1_PUSH1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_PUSH      = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_PUSH        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_FETCH     = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_FETCH       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_PUT       = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_PUT         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_GET       = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_GET         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_STATE     = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_STATE       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_INSTANCE  = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_INSTANCE    ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_CTL       = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_CTL         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_LIMIT     = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_LIMIT       ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_TLB_TAG   = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_TLB_TAG     ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_DMA_TLB_PTE   = ", REG_RD32(   NV_PFIFO_CACHE1_DMA_TLB_PTE     ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PULL0         = ", REG_RD32(   NV_PFIFO_CACHE0_PULL0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PULL0         = ", REG_RD32(   NV_PFIFO_CACHE1_PULL0           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PULL1         = ", REG_RD32(   NV_PFIFO_CACHE0_PULL1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PULL1         = ", REG_RD32(   NV_PFIFO_CACHE1_PULL1           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_HASH          = ", REG_RD32(   NV_PFIFO_CACHE0_HASH            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_HASH          = ", REG_RD32(   NV_PFIFO_CACHE1_HASH            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_STATUS        = ", REG_RD32(   NV_PFIFO_CACHE0_STATUS          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_STATUS        = ", REG_RD32(   NV_PFIFO_CACHE1_STATUS          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_STATUS1       = ", REG_RD32(   NV_PFIFO_CACHE1_STATUS1         ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_PUT           = ", REG_RD32(   NV_PFIFO_CACHE0_PUT             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_PUT           = ", REG_RD32(   NV_PFIFO_CACHE1_PUT             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_GET           = ", REG_RD32(   NV_PFIFO_CACHE0_GET             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_GET           = ", REG_RD32(   NV_PFIFO_CACHE1_GET             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE0_ENGINE        = ", REG_RD32(   NV_PFIFO_CACHE0_ENGINE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_CACHE1_ENGINE        = ", REG_RD32(   NV_PFIFO_CACHE1_ENGINE          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RUNOUT_STATUS        = ", REG_RD32(   NV_PFIFO_RUNOUT_STATUS          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RUNOUT_PUT           = ", REG_RD32(   NV_PFIFO_RUNOUT_PUT             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PFIFO_RUNOUT_GET           = ", REG_RD32(   NV_PFIFO_RUNOUT_GET             ));
}

void NvWatch_NV10_Dump_Master(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nMaster Control State:\r\n");
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_BOOT_0                 = ", REG_RD32(   NV_PMC_BOOT_0                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_INTR_0                 = ", REG_RD32(   NV_PMC_INTR_0                   ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_INTR_EN_0              = ", REG_RD32(   NV_PMC_INTR_EN_0                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PMC_INTR_READ_0            = ", REG_RD32(   NV_PMC_INTR_READ_0              ));
}

void NvWatch_NV10_Dump_Video(PHWINFO pDev)
{

  DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "\r\nVideo State:\r\n");

  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_0               = ", REG_RD32(NV_PVIDEO_DEBUG_0               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_1               = ", REG_RD32(NV_PVIDEO_DEBUG_1               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_2               = ", REG_RD32(NV_PVIDEO_DEBUG_2               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_3               = ", REG_RD32(NV_PVIDEO_DEBUG_3               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_4               = ", REG_RD32(NV_PVIDEO_DEBUG_4               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_5               = ", REG_RD32(NV_PVIDEO_DEBUG_5               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_6               = ", REG_RD32(NV_PVIDEO_DEBUG_6               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_7               = ", REG_RD32(NV_PVIDEO_DEBUG_7               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_8               = ", REG_RD32(NV_PVIDEO_DEBUG_8               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DEBUG_9               = ", REG_RD32(NV_PVIDEO_DEBUG_9               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_INTR                  = ", REG_RD32(NV_PVIDEO_INTR                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_INTR_EN               = ", REG_RD32(NV_PVIDEO_INTR_EN               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BUFFER                = ", REG_RD32(NV_PVIDEO_BUFFER                ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_STOP                  = ", REG_RD32(NV_PVIDEO_STOP                  ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BASE(0)               = ", REG_RD32(NV_PVIDEO_BASE(0)               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_BASE(1)               = ", REG_RD32(NV_PVIDEO_BASE(1)               ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_LIMIT(0)              = ", REG_RD32(NV_PVIDEO_LIMIT(0)              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_LIMIT(1)              = ", REG_RD32(NV_PVIDEO_LIMIT(1)              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_LUMINANCE(0)          = ", REG_RD32(NV_PVIDEO_LUMINANCE(0)          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_LUMINANCE(1)          = ", REG_RD32(NV_PVIDEO_LUMINANCE(1)          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_CHROMINANCE(0)        = ", REG_RD32(NV_PVIDEO_CHROMINANCE(0)        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_CHROMINANCE(1)        = ", REG_RD32(NV_PVIDEO_CHROMINANCE(1)        ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_OFFSET(0)             = ", REG_RD32(NV_PVIDEO_OFFSET(0)             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_OFFSET(1)             = ", REG_RD32(NV_PVIDEO_OFFSET(1)             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_SIZE_IN(0)            = ", REG_RD32(NV_PVIDEO_SIZE_IN(0)            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_SIZE_IN(1)            = ", REG_RD32(NV_PVIDEO_SIZE_IN(1)            ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_POINT_IN(0)           = ", REG_RD32(NV_PVIDEO_POINT_IN(0)           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_POINT_IN(1)           = ", REG_RD32(NV_PVIDEO_POINT_IN(1)           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DS_DX(0)              = ", REG_RD32(NV_PVIDEO_DS_DX(0)              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DS_DX(1)              = ", REG_RD32(NV_PVIDEO_DS_DX(1)              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DT_DY(0)              = ", REG_RD32(NV_PVIDEO_DT_DY(0)              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_DT_DY(1)              = ", REG_RD32(NV_PVIDEO_DT_DY(1)              ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_POINT_OUT(0)          = ", REG_RD32(NV_PVIDEO_POINT_OUT(0)          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_POINT_OUT(1)          = ", REG_RD32(NV_PVIDEO_POINT_OUT(1)          ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_SIZE_OUT(0)           = ", REG_RD32(NV_PVIDEO_SIZE_OUT(0)           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_SIZE_OUT(1)           = ", REG_RD32(NV_PVIDEO_SIZE_OUT(1)           ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_FORMAT(0)             = ", REG_RD32(NV_PVIDEO_FORMAT(0)             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_FORMAT(1)             = ", REG_RD32(NV_PVIDEO_FORMAT(1)             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_COLOR_KEY             = ", REG_RD32(NV_PVIDEO_COLOR_KEY             ));
  DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NV_PVIDEO_TEST                  = ", REG_RD32(NV_PVIDEO_TEST                  ));
}

U032 NvWatch_NV10_GetHashSize(PHWINFO pDev)
{
  U032 return_val;
  
  return_val = REG_RD32(NV_PFIFO_RAMHT);

  return(return_val);
}

void NvWatch_NV10_FillDiagStruct(PHWINFO pDev, PNVWATCHDIAGSTRUCT pdiagstruct)
{
    pdiagstruct->nv_pfifo_intr_0       =  REG_RD32(NV_PFIFO_INTR_0      );
    pdiagstruct->nv_pfifo_intr_en_0    =  REG_RD32(NV_PFIFO_INTR_EN_0   );
    pdiagstruct->nv_pfifo_caches       =  REG_RD32(NV_PFIFO_CACHES      );
    pdiagstruct->nv_pfifo_mode         =  REG_RD32(NV_PFIFO_MODE        );
    pdiagstruct->nv_pfifo_cache1_push0 =  REG_RD32(NV_PFIFO_CACHE1_PUSH0);
    pdiagstruct->nv_pfifo_cache1_push1 =  REG_RD32(NV_PFIFO_CACHE1_PUSH1);
    pdiagstruct->nv_pfifo_cache1_pull0 =  REG_RD32(NV_PFIFO_CACHE1_PULL0);
    pdiagstruct->nv_pfifo_dma_put      =  REG_RD32(NV_PFIFO_CACHE1_PUT     );
    pdiagstruct->nv_pfifo_dma_get      =  REG_RD32(NV_PFIFO_CACHE1_GET     );
    pdiagstruct->nv_pmc_intr_0         =  REG_RD32(NV_PMC_INTR_0        );
    pdiagstruct->nv_pmc_intr_en_0      =  REG_RD32(NV_PMC_INTR_EN_0     );
    pdiagstruct->nv_pmc_intr_read_0    =  REG_RD32(NV_PMC_INTR_READ_0   );
    pdiagstruct->nv_pmc_enable         =  REG_RD32(NV_PMC_ENABLE        );
}

void NvWatch_NV10_DumpGrTableContents(PHWINFO pDev, U032 verbose_flag)
{
    PHALHWINFO pHalHwInfo = &pDev->halHwInfo;
    PGRHALINFO_NV10 pGrHalInfo;
    PFIFOHALINFO_NV10 pFifoHalInfo;
    U032 ChID;
    U032 i;

    pHalHwInfo = &pDev->halHwInfo;
    pGrHalInfo = (PGRHALINFO_NV10)pHalHwInfo->pGrHalInfo;
    pFifoHalInfo = (PFIFOHALINFO_NV10)pHalHwInfo->pFifoHalInfo;

    for(ChID=0;ChID<NUM_FIFOS;ChID++){
        if (pFifoHalInfo->InUse & (1 << ChID))
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "\ngrTable dump of channel ", ChID);

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch1 = ", pGrHalInfo->grChannels[ChID].ContextSwitch1);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch2 = ", pGrHalInfo->grChannels[ChID].ContextSwitch2);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch3 = ", pGrHalInfo->grChannels[ChID].ContextSwitch3);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch4 = ", pGrHalInfo->grChannels[ChID].ContextSwitch4);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  Context Switch5 = ", pGrHalInfo->grChannels[ChID].ContextSwitch5);
      
        for (i = 0; i < 8; i++)
        {    
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    Cached Context data for subchannel ", i);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache0 = ", pGrHalInfo->grChannels[ChID].ContextCache1[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache1 = ", pGrHalInfo->grChannels[ChID].ContextCache2[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache2 = ", pGrHalInfo->grChannels[ChID].ContextCache3[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache3 = ", pGrHalInfo->grChannels[ChID].ContextCache4[i]);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "      ContextCache4 = ", pGrHalInfo->grChannels[ChID].ContextCache5[i]);
        }

        if(verbose_flag == NVWATCH_COMPLEX){
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].ContextUser = ",          pGrHalInfo->grChannels[ChID].ContextUser       );                 

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaStart0 = ",        pGrHalInfo->grChannels[ChID].DmaStart0             );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaStart1 = ",        pGrHalInfo->grChannels[ChID].DmaStart1             );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaLength = ",        pGrHalInfo->grChannels[ChID].DmaLength             );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaMisc   = ",        pGrHalInfo->grChannels[ChID].DmaMisc               );             
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].DmaPitch  = ",        pGrHalInfo->grChannels[ChID].DmaPitch              );             

            for (i = 0; i < 6; i++)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferOffset[i]  = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferOffset[i]   );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferBase[i]    = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferBase[i]     );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferLimit[i]   = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferLimit[i]    );
            }
            for (i = 0; i < 5; i++)
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPitch[i] = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPitch[i]      );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Surface           = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.Surface               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.State             = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.State                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[0]  = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[0]      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[1]  = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.BufferSwizzle[1]      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPixel       = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.BufferPixel           );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Notify            = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.Notify                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor0     = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor0         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor1     = ",            pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColor1         );

            for (i = 0; i < 64; i++)
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColorRam[i]  = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.PatternColorRam[i]);

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[0]         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[0]            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[1]         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Pattern[1]            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PatternShape       = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.PatternShape          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.MonoColor0         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.MonoColor0            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Rop3               = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Rop3                  );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Chroma             = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Chroma                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BetaAnd            = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.BetaAnd               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BetaPremult        = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.BetaPremult           );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control0           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control0              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control1           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control1              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control2           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control2              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Control3           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Control3              );
            
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Blend              = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.Blend                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.BlendColor         = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.BlendColor            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.SetupRaster        = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.SetupRaster           );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.FogColor           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.FogColor              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ColorKeyColor0     = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.ColorKeyColor0        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ColorKeyColor1     = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.ColorKeyColor1        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.PointSize          = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.PointSize             );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ZOffsetFactor      = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.ZOffsetFactor         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ZOffsetBias        = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.ZOffsetBias           );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ZClipMin           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.ZClipMin              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ZClipMax           = ",           pGrHalInfo->grChannels[ChID].CurrentPatch.ZClipMax              );

            for (i = 0; i < 8; i++)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.WinClipHorz[i]   = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.WinClipHorz[i]    );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.WinClipVert[i]   = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.WinClipVert[i]    );
            }

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XFMode[0]            = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.XFMode[0]             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XFMode[1]            = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.XFMode[1]             );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.GlobalState0         = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.GlobalState0          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.GlobalState1         = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.GlobalState1          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.StoredFmt            = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.StoredFmt             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.SourceColor          = ",         pGrHalInfo->grChannels[ChID].CurrentPatch.SourceColor           );

            for (i = 0; i < 32; i++)
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsXRam[i]       = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.AbsXRam[i]        );
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsYRam[i]       = ",             pGrHalInfo->grChannels[ChID].CurrentPatch.AbsYRam[i]        );
            }

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMin        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMin          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipXMax          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMin        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMin          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipYMax          );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DXMin      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DXMin        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DXMax      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DXMax        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DYMin      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DYMin        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DYMax      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClip3DYMax        );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMin       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMin         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMax       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAXMax         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMin       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMin         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMax       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsUClipAYMax         );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipXMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipXMax          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipYMax        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.AbsIClipYMax          );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc0        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc0          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc1        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc1          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc2        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc2          );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc3        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XYLogicMisc3          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX0              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX0                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipX1                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY0              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY0                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ClipY1                );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0AlphaICW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0AlphaICW      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1AlphaICW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1AlphaICW      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0ColorICW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0ColorICW      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1ColorICW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1ColorICW      );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0Factor      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0Factor        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1Factor      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1Factor        );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0AlphaOCW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0AlphaOCW      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1AlphaOCW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1AlphaOCW      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0ColorOCW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine0ColorOCW      );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1ColorOCW    = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Combine1ColorOCW      );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.CombineSpecFogCW0   = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.CombineSpecFogCW0     );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.CombineSpecFogCW1   = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.CombineSpecFogCW1     );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TextureOffset0      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TextureOffset0        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TextureOffset1      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TextureOffset1        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexturePalette0     = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexturePalette0       );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexturePalette1     = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexturePalette1       );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexFormat0          = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexFormat0            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexFormat1          = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexFormat1            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl0_0       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl0_0         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl0_1       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl0_1         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl1_0       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl1_0         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl1_1       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl1_1         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl2_0       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl2_0         );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl2_1       = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.TexControl2_1         );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ImageRect0          = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ImageRect0            );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ImageRect1          = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ImageRect1            );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Filter0             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Filter0               );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Filter1             = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Filter1               );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru0           = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru0             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru1           = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru1             );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru2           = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Passthru2             );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.DimxTexture         = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.DimxTexture           );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.WdimxTexture        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.WdimxTexture          );

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.DVDColorFormat      = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.DVDColorFormat        );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.ScaledFormat        = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.ScaledFormat          );
                                                                                                                                                              
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_0            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_0              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_1            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_1              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_2            = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Misc24_2              );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.XMisc               = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.XMisc                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.YMisc               = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.YMisc                 );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Valid1              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Valid1                );
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "    pGrHalInfo->grChannels[ChID].CurrentPatch.Valid2              = ",          pGrHalInfo->grChannels[ChID].CurrentPatch.Valid2                );
        }
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\osapi.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************************************************************
*
*   File: osapi.c
*
*   Description:
*       This file contains the resource manager API for the NT miniport.  It
*   provides services to the miniport that directly access the device.
*
******************************************************************************/

#include <ntddk.h>
#include <nvrm.h>
#include <nvhw.h>
#include <os.h>

BOOL RmLoadState
(
	U032 deviceReference,
    U032 horizWidth,
    U032 vertWidth,
    U032 bitDepth,
    U032 refreshRate,
    BOOL vgaEnabled
)
{
    RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

	// allow hi res modes to happen
    // This value should be FALSE after a SetMode has occurred
    // This value should be TRUE when restoring from Hibernation (in VGA mode)
	pDev->Vga.Enabled = vgaEnabled;

	// transfer the arguments from the client into RM global state
	pDev->Dac.HalInfo.Depth 		    = bitDepth;
	pDev->Framebuffer.HalInfo.RefreshRate 	     = refreshRate;
    pDev->Framebuffer.HalInfo.HorizDisplayWidth  = horizWidth;
    pDev->Framebuffer.HalInfo.VertDisplayWidth   = vertWidth;

	// reload the state based on the new display mode
    rmStatus = stateNv(pDev, STATE_LOAD);
    
    return (rmStatus == RM_OK) ? TRUE : FALSE;
                        
} // end of RmLoadState()

BOOL RmUnloadState
(
	U032 deviceReference
)
{
    RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

	// unload the state
    rmStatus = stateNv(pDev, STATE_UNLOAD);
    
    return (rmStatus == RM_OK) ? TRUE : FALSE;
            
} // end of RmUnloadState()


BOOL RmUpdateAGPConfig
(
	U032 deviceReference
)
{
    RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

    NvUpdateAGPConfig(pDev);
        
    return (rmStatus == RM_OK) ? TRUE : FALSE;
            
} // end of RmUnloadState()


BOOL RmSetMode
(
	U032 deviceReference,
	U032 HorizontalVisible,
	U032 HorizontalBlankStart,
	U032 HorizontalRetraceStart,
	U032 HorizontalRetraceEnd,
	U032 HorizontalBlankEnd,
	U032 HorizontalTotal,
	U032 VerticalVisible,
	U032 VerticalBlankStart,
	U032 VerticalRetraceStart,
	U032 VerticalRetraceEnd,
	U032 VerticalBlankEnd,
	U032 VerticalTotal,
    U032 PixelDepth,
    U032 RefreshRate,
    U032 Width,
    U032 Height,
	U032 PixelClock,
	U032 HorizontalSyncPolarity,
	U032 VerticalSyncPolarity,
	U032 DoubleScannedMode     
)
{
    VIDEO_LUT_CURSOR_DAC_OBJECT DacObj;
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    // unload the state
    rmStatus = stateDac(pDev, STATE_UNLOAD);
    if (rmStatus == RM_OK)
    {
        // set the VESA parameters in the device context
        DacObj.HalObject.Dac[0].VisibleImageWidth = HorizontalVisible;
        DacObj.HalObject.Dac[0].HorizontalBlankStart = HorizontalBlankStart;
        DacObj.HalObject.Dac[0].HorizontalSyncStart = HorizontalRetraceStart;
        DacObj.HalObject.Dac[0].HorizontalSyncWidth = HorizontalRetraceEnd - HorizontalRetraceStart;
        DacObj.HalObject.Dac[0].HorizontalBlankWidth = HorizontalBlankEnd - HorizontalBlankStart;
        DacObj.HalObject.Dac[0].TotalWidth = HorizontalTotal;
        DacObj.HalObject.Dac[0].VisibleImageHeight = VerticalVisible;
        DacObj.HalObject.Dac[0].VerticalBlankStart = VerticalBlankStart;
        DacObj.HalObject.Dac[0].VerticalSyncStart = VerticalRetraceStart;
        DacObj.HalObject.Dac[0].VerticalSyncHeight = VerticalRetraceEnd - VerticalRetraceStart;
        DacObj.HalObject.Dac[0].VerticalBlankHeight = VerticalBlankEnd - VerticalBlankStart;
        DacObj.HalObject.Dac[0].TotalHeight = VerticalTotal;
        DacObj.HalObject.Dac[0].PixelDepth = PixelDepth;
        DacObj.HalObject.Dac[0].PixelClock = PixelClock;
        DacObj.HalObject.Dac[0].Format.HorizontalSyncPolarity = HorizontalSyncPolarity;
        DacObj.HalObject.Dac[0].Format.VerticalSyncPolarity = VerticalSyncPolarity;
        DacObj.HalObject.Dac[0].Format.DoubleScanMode = DoubleScannedMode;
        DacObj.HalObject.Head = 0;
        DacObj.DisplayType = GETDISPLAYTYPE(pDev, 0);

        // Set image parameters.
        DacObj.Image[0].Offset = 0;
        DacObj.Image[0].Pitch = Width * (PixelDepth >> 3);

        // reload the state -- this will reset the mode
        pDev->Vga.Enabled = FALSE;

        // transfer the arguments from the client into RM global state
        pDev->Dac.HalInfo.Depth             = PixelDepth;
        pDev->Framebuffer.HalInfo.RefreshRate        = RefreshRate;
        pDev->Framebuffer.HalInfo.HorizDisplayWidth  = Width;
        pDev->Framebuffer.HalInfo.VertDisplayWidth   = Height;

        rmStatus = stateDac(pDev, STATE_LOAD);
        if (rmStatus == RM_OK)
        {
            rmStatus = dacSetModeMulti(pDev, &DacObj);
        }
    } 

    return (rmStatus == RM_OK) ? TRUE : FALSE;  
                        
} // end of RmSetMode()

BOOL RmIsr
(
	U032 deviceReference
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

	// check for any valid NV interrupts that need to be serviced
	if (pDev)
	{
        rmStatus = osIsr(pDev);
	}

	return (rmStatus == RM_OK);

} // end of RmIsr()

BOOL RmInterruptPending
(
    PHWINFO pDev,
    BOOL   *serviced
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    V032         pmc;
    U032         hw_reg_value;

    // check interrupts only if the RM is initialized
    if (pOsHwInfo->rmInitialized)
    {
        // service interrupts only if they are enabled
        hw_reg_value = REG_RD32(NV_PMC_INTR_EN_0);
        // adi PMTE if the interrupts are enabled and if the hw registers are enabled
        if (hw_reg_value != 0 && hw_reg_value != 0xFFFFFFFF)
        {
            // service interrupts only if they are present
            pmc = REG_RD32(NV_PMC_INTR_0);
            if (pmc)
            {
                // disable interrupts
                RmDisableInterrupts(pDev);

                // only service interrupts locally for NT4
                #if (_WIN32_WINNT < 0x0500)
                // locally service high-priority interrupts immediately
                if (pmc & PENDING_INTERRUPTS)
                {
                    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Servicing VBLANK interrupt...\n");
                    VBlank(pDev);
                    *serviced = TRUE;
                }
                #endif // _WIN32_WINNT >= 0x0500

                // recheck to see if any interrupts occured during local servicing
                pmc = REG_RD32(NV_PMC_INTR_0);
                if (pmc)
                {
                    // a non-VBLANK interrupt is pending, so don't enable ints yet
                    return TRUE;
                }
                else
                {
                    // enable interrupts if all were serviced locally
                    RmEnableInterrupts(pDev);
                }
            }
        }
    }
    return FALSE;

} // end of RmInterruptPending()

VOID RmEnableInterrupts
(
	PHWINFO pDev
)
{
	//DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Enabling NV interrupts...\n");
	REG_WR32(NV_PMC_INTR_EN_0, pDev->Chip.IntrEn0);

} // end of RmEnableInterrupts();

VOID RmDisableInterrupts
(
	PHWINFO pDev
)
{
	//DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Disabling NV interrupts...\n");
	REG_WR32(NV_PMC_INTR_EN_0, 0x00000000);

} // end of RmDisableInterrupts();

BOOL RmConfigGetKernel
(
	U032 deviceReference,
	U032 index,
	U032* pValue
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];
	
    rmStatus = stateConfigGet(pDev, index, pValue);

	return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of RmConfigGetKernel()

BOOL RmConfigGetExKernel
(
	U032 deviceReference,
	U032 index,
    VOID* pParms,
    U032 parmSize
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];
	
    rmStatus = stateConfigGetEx(pDev, index, pParms, parmSize);

	return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of RmConfigGetExKernel()


BOOL RmConfigSetKernel
(
	U032  deviceReference,
   U032  index,
   U032  newvalue,
   U032* pOldvalue
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];
	
   rmStatus = stateConfigSet(pDev, index, newvalue, pOldvalue);

	return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of RmConfigSetKernel()

BOOL RmConfigSetExKernel
(
	U032 deviceReference,
	U032 index,
    VOID* pParms,
    U032 parmSize
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];
	
    rmStatus = stateConfigSetEx(pDev, index, pParms, parmSize);

	return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of RmConfigSetExKernel()

#if (_WIN32_WINNT >= 0x0500)
VOID RmSetAgpServices
(
    U032 deviceReference,
    VOID *AgpServices
)
{
    PHWINFO pDev = NvDBPtr_Table[deviceReference];
	PRMINFO pRmInfo = (PRMINFO) NvDBPtr_Table[deviceReference]->pRmInfo;
	PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    RM_STATUS status;

    pOsHwInfo->AgpServices = AgpServices;

    // setup our AGP base/limit
    if (pOsHwInfo->AgpServices) {
        PHYSICAL_ADDRESS AgpPhysBase;
        VOID *AgpLinearBase;

        // Get the AGP physical base and limit
        status = NvGetAGPBaseLimit(pDev, &pRmInfo->AGP.AGPPhysStart, &pRmInfo->AGP.AGPLimit);
        if (status != RM_OK) {
            // chipset isn't configured correctly
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: NvGetAGPBaseLimit call failed\n");
            pOsHwInfo->AgpServices = NULL;        // avoid AGP allocations
            return;
        }

        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,   "NVRM: AGP PhysBase:  ", pRmInfo->AGP.AGPPhysStart);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AGP PhysLimit: ", pRmInfo->AGP.AGPLimit);

        //
        // So we're not dependent on anyone else's mapping to exist, establish our
        // own virtual addr to the AGP physbase. We only need a single page mapped
        // and type of mapping doesn't really matter. This is used only by drivers
        // wanting to setup a context DMA for the whole AGP aperture.
        //
        AgpPhysBase.HighPart = 0x00000000;
        AgpPhysBase.LowPart = (ULONG)pRmInfo->AGP.AGPPhysStart;

        AgpLinearBase = MmMapIoSpace(AgpPhysBase, 0x1000, 0x2);
        if (AgpLinearBase == NULL) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Failed to establish AGP base mapping\n");
            return;
        }
        pRmInfo->AGP.AGPLinearStart = (VOID_PTR)AgpLinearBase;
    }
}
#endif

BOOL RmPreModeSet
(
	U032 deviceReference,
    U032 head
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];
    int i;

    pDev->Vga.Enabled = FALSE;

    // call the pre-mode set OS service
    osPreModeSetEx(pDev, head);
    
    // 
    // For a tiled primary surface, we delay setting the tiled bit in the hardware
    // until after we've modeswitched out of VGA to prevent a garbled splash screen.
    // Just in case we haven't set it yet, do it now.
    //
    for (i=0; i<MAX_CRTCS; i++) {
        if (pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i].hwResId != 0) {
            nvHalFbSetAllocParameters(pDev, &pDev->Framebuffer.HalInfo.PrimaryFbAllocInfo[i]);
        }
    }
    return (rmStatus == RM_OK) ? TRUE : FALSE;

}

BOOL RmPostModeSet
(
	U032 deviceReference,
    U032 head
)
{
    RM_STATUS rmStatus = RM_OK;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    // call the post-mode set OS service
    osPostModeSetEx(pDev, head);

    // 
    // At the completion of this modeset, check if there's been a
    // modeset on the other head, if not, call dacDisableDac.
    //
    if (pDev->Dac.CrtcInfo[head^1].pVidLutCurDac == (VOID_PTR)NULL)
        dacDisableDac(pDev, head^1);

    return (rmStatus == RM_OK) ? TRUE : FALSE;
}

// set a display's state: TRUE = on, FALSE = off
BOOL RmSetDisplayPowerState
(
	U032 deviceReference,
    U032 head,
    BOOL state
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        if (state)
        {
            // turn DAC on
            dacEnableDac(pDev, head);
            
            // signify that the sync state has not been set
            pDev->Dac.CrtcInfo[head].SyncStateIsSaved = FALSE;
            
        }
        else
        {
            // store away the sync states only on the first call
            if (!pDev->Dac.CrtcInfo[head].SyncStateIsSaved)
            {
                pDev->Dac.CrtcInfo[head].CurrentVsyncState = DAC_REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, head);
                pDev->Dac.CrtcInfo[head].CurrentHsyncState = DAC_REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, head);
                pDev->Dac.CrtcInfo[head].SyncStateIsSaved = TRUE;
            }
            
            // turn DAC off
            dacDisableDac(pDev, head);
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

	return (rmStatus == RM_OK);

} // end of RmSetDisplayPowerState()

// set I2C ownership to the given head
BOOL RmEnableHead
(
	U032 deviceReference,
    U032 head
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
	    EnableHead(pDev, head);
    }
    else
    {
        rmStatus = RM_ERROR;
    }    
    
	return (rmStatus == RM_OK);

} // end of RmEnableHead()

// TO DO:  these defines need to go to a file that is shared between the miniport.c and osapi.c
// power state definitions used by RmSet/GetPowerState() and RmGetCurrentPowerState()
#define NV_POWER_ADAPTER_STATE_0            0x00000001 // full on
#define NV_POWER_ADAPTER_STATE_1            0x00000002 // slowed clocks
#define NV_POWER_ADAPTER_STATE_2            0x00000004 // slowed clocks, mobile style *** not all devices supported ***
#define NV_POWER_ADAPTER_STATE_3            0x00000008 // very slow clocks, state saved (regs & instance memory)
#define NV_POWER_ADAPTER_STATE_4            0x00000010 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_5            0x00000020 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_6            0x00000040 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_7            0x00000080 // future lower adapter power state
#define NV_POWER_ADAPTER_FEATURE_CTXSAVED   0x00000100 // lowest power consumption state saves device context
#define NV_POWER_ADAPTER_STATE_HIBERNATE    0x00000200 // msoft hibernate mode
#define NV_POWER_ADAPTER_FEATURE_UNDEF_2    0x00000400 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_3    0x00000800 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_4    0x00001000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_5    0x00002000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_6    0x00004000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_7    0x00008000 // future feature
#define NV_POWER_MONITOR_STATE_0            0x00010000 // full on
#define NV_POWER_MONITOR_STATE_1            0x00020000 // no VSYNC nor HSYNC
#define NV_POWER_MONITOR_STATE_2            0x00040000 // future lower monitor power state 
#define NV_POWER_MONITOR_STATE_3            0x00080000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_4            0x00100000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_5            0x00200000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_6            0x00400000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_7            0x00800000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_HIBERNATE    0x01000000 // msoft hibernate mode
#define NV_POWER_UNDEF_1                    0x02000000 // future attribute
#define NV_POWER_UNDEF_2                    0x04000000 // future attribute
#define NV_POWER_UNDEF_3                    0x08000000 // future attribute
#define NV_POWER_UNDEF_4                    0x10000000 // future attribute
#define NV_POWER_UNDEF_5                    0x20000000 // future attribute
#define NV_POWER_UNDEF_6                    0x40000000 // future attribute
#define NV_POWER_UNDEF_7                    0x80000000 // future attribute


LONG RMVideoResetDevice(U032 deviceReference);
BOOL RmSetPowerState
(
	U032 deviceReference,
    U032 head,
    U032 state
)
{
    U008      reg3B;
	RM_STATUS rmStatus  = RM_OK;
	PHWINFO   pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        switch (state)
        {
            // ADAPTER POWER STATES
            
            //  Level 0 - full on
            case NV_POWER_ADAPTER_STATE_0:
                mcPowerState(pDev, MC_POWER_LEVEL_0, head);
                break;
                
            //  Level 1 - slowed clocks
            case NV_POWER_ADAPTER_STATE_1:
                mcPowerState(pDev, MC_POWER_LEVEL_1, head);
                break;
                
            //  Level 2 - slowed clocks, mobile style (not all devices support)
            case NV_POWER_ADAPTER_STATE_2:
                mcPowerState(pDev, MC_POWER_LEVEL_2, head);
                break;
                
            //  Level 3 - very slow clocks, state saved (regs & instance memory)
            case NV_POWER_ADAPTER_STATE_3:
                mcPowerState(pDev, MC_POWER_LEVEL_3, head);
                break;

            //  Level 7 - state saved (regs & instance memory)
            case NV_POWER_ADAPTER_STATE_HIBERNATE:
                RMVideoResetDevice(deviceReference);
                mcPowerState(pDev, MC_POWER_LEVEL_7, head);
                break;
                
                
            // DISPLAY POWER STATES
            
            // display on
            case NV_POWER_MONITOR_STATE_0:
                mcPowerDisplayState(pDev, MC_POWER_LEVEL_5, head);

                // set the current monitor power state for this head
                pDev->Dac.CrtcInfo[head].CurrentPowerState = NV_POWER_MONITOR_STATE_0;
                pDev->Dac.DevicesEnabled &= ~DAC_MONITOR_POWER_STATE_OFF;
                break;
            
            // display off
            case NV_POWER_MONITOR_STATE_1:
                mcPowerDisplayState(pDev, MC_POWER_LEVEL_6, head);

                // set the current monitor power state for this head
                pDev->Dac.CrtcInfo[head].CurrentPowerState = NV_POWER_MONITOR_STATE_1;
                pDev->Dac.DevicesEnabled |= DAC_MONITOR_POWER_STATE_OFF;
                break;

            // display hibernate -- msoft wants monitor left *on*
            case NV_POWER_MONITOR_STATE_HIBERNATE:
                if (!pDev->Dac.CrtcInfo[head].PrimaryDevice)
                {
                    //
                    // Disable broadcast mode on the secondary head.
                    // This only applies to mobile systems, so we are essentially
                    // disabling the external display and leaving the internal flat
                    // panel active.
                    //
                    // dacDisableBroadcast will tell us if the other head is active.
                    // If it is, the current head should be turned off instead of left on.
                    //
                    if (dacDisableBroadcast(pDev, head, &reg3B))
                    {
                        mcPowerDisplayState(pDev, MC_POWER_LEVEL_6, head);
                        //
                        // On everything except Toshiba (of course) restore the scratch
                        // register immediately so that scratch registers reflect the correct
                        // state upon returning from hibernation.  When the vga modeset occurs,
                        // the scratch bits will be tweaked again before doing the modeset so
                        // that the secondary head does not display garbage going into hibernation.
                        // Unfortunately, on Toshiba, restoring the scratch bits at any point going
                        // into hibernation, including right before exiting for the last time during
                        // adaptor hibernate, will result in garbage being displayed on the secondary
                        // head.  There is apparently yet another vga bios modeset call that is being
                        // honored somehow by the Toshiba bios after the last call to the RM, and if
                        // the scratch bits show both heads active, the secondary head will display
                        // garbage.
                        //
                        if(pDev->Power.MobileOperation != 2)
                            dacRestoreBroadcast(pDev, head, reg3B);
                    }
                    else
                        mcPowerDisplayState(pDev, MC_POWER_LEVEL_5, head);
                }
                else
                    mcPowerDisplayState(pDev, MC_POWER_LEVEL_5, head);

                // set the current monitor power state for this head
                pDev->Dac.CrtcInfo[head].CurrentPowerState = NV_POWER_MONITOR_STATE_HIBERNATE;
                pDev->Dac.DevicesEnabled &= ~DAC_MONITOR_POWER_STATE_OFF;
                break;
                
            default:
                rmStatus = RM_ERROR;
                break;
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

	return (rmStatus == RM_OK);
    
} // end of RmSetPowerState()

BOOL RmGetCurrentPowerState
(
	U032 deviceReference,
    U032 head, 
    U032* pState
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        // load the return state with the current adapter state
        switch (pDev->Power.State)
        {
            case MC_POWER_LEVEL_0:
                *pState = NV_POWER_ADAPTER_STATE_0;
                break;
                
            case MC_POWER_LEVEL_1:
                *pState = NV_POWER_ADAPTER_STATE_1;
                break;
                
            case MC_POWER_LEVEL_2:
                *pState = NV_POWER_ADAPTER_STATE_2;
                break;
                
            case MC_POWER_LEVEL_3:
                *pState = NV_POWER_ADAPTER_STATE_3;
                break;

            case MC_POWER_LEVEL_7:
                *pState = NV_POWER_ADAPTER_STATE_HIBERNATE;
                break;
        }
        
        // OR in the current monitor state
        if (head < pDev->Dac.HalInfo.NumCrtcs)
        {
            *pState |= pDev->Dac.CrtcInfo[head].CurrentPowerState;
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

	return (rmStatus == RM_OK);
    
} // end of RmGetCurrentPowerState()

BOOL RmGetPowerCaps
(
	U032 deviceReference,
    U032 head, 
    U032* pCaps
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        // TO DO: do we need some kind of HAL call for this?
        if (pDev->Power.MobileOperation)
        {
            *pCaps = 
                NV_POWER_ADAPTER_STATE_0            |
                NV_POWER_ADAPTER_STATE_2            |
                NV_POWER_ADAPTER_STATE_3            |
                NV_POWER_ADAPTER_FEATURE_CTXSAVED   |
                NV_POWER_ADAPTER_STATE_HIBERNATE    |
                NV_POWER_MONITOR_STATE_0            |
                NV_POWER_MONITOR_STATE_1            |
                NV_POWER_MONITOR_STATE_HIBERNATE;
        }
        else
        {
            *pCaps = 
                NV_POWER_ADAPTER_STATE_0            |
                NV_POWER_ADAPTER_STATE_1            |
                NV_POWER_ADAPTER_STATE_3            |
                NV_POWER_ADAPTER_FEATURE_CTXSAVED   |
                NV_POWER_ADAPTER_STATE_HIBERNATE    |
                NV_POWER_MONITOR_STATE_0            |
                NV_POWER_MONITOR_STATE_1            |
                NV_POWER_MONITOR_STATE_HIBERNATE;

        }    
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

	return (rmStatus == RM_OK);
    
} // end of RmGetPowerCaps()

BOOL RmSetDriverHotkeyHandling
(
	U032 deviceReference,
    BOOL enabled
)
{
	RM_STATUS rmStatus = RM_OK;
	PHWINFO pDev = NvDBPtr_Table[deviceReference];

    if (pDev)
    {
        if (enabled)
        {
            EnableMobileHotkeyHandling(pDev);
        }
        else
        {
            //Placing this here because it will get called when going to FS-DOS.
//            pDev->Dac.DeviceProperties.InferAuxDev = TRUE;
            pDev->Dac.DeviceProperties.LastSwitchEvent = SWITCH_FROM_FS_DOS;

            DisableMobileHotkeyHandling(pDev);
        }
    }
    else
    {
        rmStatus = RM_ERROR;
    }    

	return (rmStatus == RM_OK);

} // end of RmSetDriverHotkeyHandling()
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\AHal.cpp ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  NVIDIA, Corp. of Sunnyvale,  California owns     *|
|*     copyrights, patents, and has design patents pending on the design     *|
|*     and  interface  of the NV chips.   Users and  possessors  of this     *|
|*     source code are hereby granted a nonexclusive, royalty-free copy-     *|
|*     right  and design patent license  to use this code  in individual     *|
|*     and commercial software.                                              *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright  1993-1998  NVIDIA,  Corporation.   NVIDIA  has  design     *|
|*     patents and patents pending in the U.S. and foreign countries.        *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF THIS SOURCE CODE FOR ANY PURPOSE. IT IS PROVIDED "AS IS" WITH-     *|
|*     OUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPORATION     *|
|*     DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOURCE CODE, INCLUD-     *|
|*     ING ALL IMPLIED WARRANTIES  OF MERCHANTABILITY  AND FITNESS FOR A     *|
|*     PARTICULAR  PURPOSE.  IN NO EVENT  SHALL NVIDIA,  CORPORATION  BE     *|
|*     LIABLE FOR ANY SPECIAL,  INDIRECT,  INCIDENTAL,  OR CONSEQUENTIAL     *|
|*     DAMAGES, OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,     *|
|*     DATA OR PROFITS,  WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR     *|
|*     OTHER TORTIOUS ACTION,  ARISING OUT OF OR IN CONNECTION  WITH THE     *|
|*     USE OR PERFORMANCE OF THIS SOURCE CODE.                               *|
|*                                                                           *|
|*     RESTRICTED RIGHTS LEGEND:  Use, duplication, or disclosure by the     *|
|*     Government is subject  to restrictions  as set forth  in subpara-     *|
|*     graph (c) (1) (ii) of the Rights  in Technical Data  and Computer     *|
|*     Software  clause  at DFARS  52.227-7013 and in similar clauses in     *|
|*     the FAR and NASA FAR Supplement.                                      *|
|*                                                                           *|
\***************************************************************************/

/*
* AHal.cpp
*
* Chip-independent functions exported by the RM kernel
*
*/

extern "C" 
{
#include <nvarm.h>
#include <aos.h>
#include <nv32.h>
#include <AHal.h>
#include <AudioHw.h>
}
#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"
#include "CHalMCP1.h"

RM_STATUS InitAudioHal(U008 uRevID, HWINFO_COMMON_FIELDS *pDev)
{
	switch(uRevID)
	{
	case REV_MCP1:
		pDev->pHalContext = (VOID *) new CHalMCP1(uRevID, pDev);
		break;

	default:
		pDev->pHalContext = NULL;
		break;
	}

	return (pDev->pHalContext)?RM_OK:RM_ERROR;
}

VOID DestroyAudioHal(HWINFO_COMMON_FIELDS *pDev)
{
	delete ((CHalBase *)pDev->pHalContext);
}

RM_STATUS AllocDevice(HWINFO_COMMON_FIELDS *pDev)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->Allocate();
}

RM_STATUS FreeDevice(HWINFO_COMMON_FIELDS *pDev)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->Free();
}

RM_STATUS DeviceAddClient(HWINFO_COMMON_FIELDS *pDev, VOID *pParam, U008 *pClientRef)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    return pBase->AddClient(pParam, pClientRef);
}

RM_STATUS DeviceRemoveClient(HWINFO_COMMON_FIELDS *pDev, U008 uClientRef)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    return pBase->DeleteClient(uClientRef);
}

RM_STATUS AllocObject(HWINFO_COMMON_FIELDS *pDev, VOID *pParam)
{
	APU_OBJECT	*pObjAllocParams = (APU_OBJECT *)pParam;
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    return pBase->AllocateObject(pObjAllocParams->uObjectCode, (VOID *)pObjAllocParams->pParam);
}

RM_STATUS FreeObject(HWINFO_COMMON_FIELDS *pDev, VOID *pParam)
{
	APU_OBJECT	*pObjFreeParams = (APU_OBJECT *)pParam;
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    return pBase->FreeObject(pObjFreeParams->uObjectCode, (VOID *)pObjFreeParams->pParam);
}

RM_STATUS AllocContextDma(HWINFO_COMMON_FIELDS *pDev, VOID *pParam)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->AllocateContextDma(pParam);
}

RM_STATUS FreeContextDma(HWINFO_COMMON_FIELDS *pDev, VOID *pParam)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
	return pBase->FreeContextDma(pParam);
}

RM_STATUS InterruptService(HWINFO_COMMON_FIELDS *pDev)
{
	CHalBase *pBase = (CHalBase *)pDev->pHalContext;
    if (pBase)
	    return pBase->InterruptService();

    return RM_ERROR;
}

// the following code is to make the driver compile in C++ 
void* _cdecl operator new(unsigned int n)
{
	void *p;
    aosAllocateMem((U032) n, ALIGN_DONT_CARE, &p, NULL);
    return p;
}

void _cdecl operator delete(void* p)
{
	if (p) 
		aosFreeMem(p);
}

extern "C" int _cdecl _purecall();

int _cdecl _purecall()
{
    // this better get printed!!
    aosDbgPrintString(DEBUGLEVEL_ERRORS + 5, "NVARM: _purecall - RUNTIME ERROR!  calling pure virtual function!!!\n");
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\smp.c ===
/******************************************************************************
*
*   Module: smp.c
*
*   Description:
*       This module contains SMP-safe versions of calls to functions that
*   contain critical code.
*
*       Each SMP-safe wrapper has the same name as the function it replaces
*   prepended with "smp".  Each requires a macro, to be included in those files
*   that call the "wrapped" functions, that replaces the call to the original
*   function with a call to the wrapper.  Currently, the header file that
*   contains these macros is called "smp.h".  The wrapper function packages
*   up the args into a single, custom arg struct, then calls
*   VideoPortSynchronizeExecution(), specifying a pointer to the arg struct
*   and a callback function.  The callback has the same name as the original
*   function prepended with "smpCallback".  The callback calls the original
*   function with the correct members of the arg struct.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

#include <miniport.h>
#include <ntddvdeo.h>
#include <video.h>
#include <nvrm.h>
#include <os.h>

// external prototypes
RM_STATUS fifoUpdateObjectInstance(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID,
    U032    Instance
);
RM_STATUS fifoDeleteObjectInstance(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID
);
RM_STATUS fifoResetChannelState(
    PHWINFO pDev,
    U032 ChID
);
RM_STATUS fifoDeleteSubchannelContextEntry(
    PHWINFO pDev,
    POBJECT Object
);
RM_STATUS nvHalFbSetAllocParameters(
    PHWINFO pDev,
    PFBALLOCINFO pFbAllocInfo
);
RM_STATUS nvHalFbFree(
    PHWINFO pDev,
    U032 hwResId
);
VOID VBlankDeleteCallback(
    PHWINFO pDev,
    U032 Head,
    PVBLANKCALLBACK Callback
);
RM_STATUS classDirectSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032    Offset,
    V032    Data
);
RM_STATUS nvagp_AllocAGPBitmap
(
    PHWINFO pDev,
    U032 Size,
    U032 *Offset
);
VOID nvagp_FreeAGPBitmap
(
    PHWINFO pDev,
    U032 Offset,
    U032 PageCount
);
RM_STATUS nvagp_InsertGARTEntries
(
    PHWINFO pDev,
    U032 Index,
    U032 PageCount,
    U032 Data
);
RM_STATUS nvagp_FlushGARTEntries
(
    PHWINFO pDev
);
RM_STATUS fbAllocInstMemAlign
(
    PHWINFO pDev,
    U032   *Instance,
    U032    Size,
    U032    Align		
);
RM_STATUS fbAllocInstMem
(
    PHWINFO pDev,
    U032   *Instance,
    U032    Size
);
RM_STATUS fbFreeInstMem
(
    PHWINFO pDev,
    U032    Instance,
    U032    Size
);

// local prototypes
BOOLEAN smpCallbackFifoUpdateObjectInstance(PVOID object);
BOOLEAN smpCallbackFifoDeleteObjectInstance(PVOID object);
BOOLEAN smpCallbackFifoResetChannelState(PVOID object);
BOOLEAN smpCallbackFifoDeleteSubchannelContextEntry(PVOID object);
BOOLEAN smpCallbackMcService(PVOID object);
BOOLEAN smpCallbackNvHalFbSetAllocParameters(PVOID object);
BOOLEAN smpCallbackNvHalFbFree(PVOID object);
BOOLEAN smpCallbackVBlankDeleteCallback(PVOID object);
BOOLEAN smpCallbackClassDirectSoftwareMethod(PVOID object);
BOOLEAN smpCallbackNvagpAllocAGPBitmap(PVOID object);
BOOLEAN smpCallbackNvagpFreeAGPBitmap(PVOID object);
BOOLEAN smpCallbackNvagpInsertGARTEntries(PVOID object);
BOOLEAN smpCallbackNvagpFlushGARTEntries(PVOID object);
BOOLEAN smpCallbackFbAllocInstMemAlign(PVOID object);
BOOLEAN smpCallbackFbAllocInstMem(PVOID object);
BOOLEAN smpCallbackFbFreeInstMem(PVOID object);

// arg strucs
typedef struct
{
    PHWINFO pDev;
    POBJECT Object;
    U032    ChID;
    U032    Instance;
} ARGS_FifoUpdateObjectInstance, *PARGS_FifoUpdateObjectInstance;
typedef struct
{
    PHWINFO pDev;
    POBJECT Object;
    U032    ChID;
} ARGS_FifoDeleteObjectInstance, *PARGS_FifoDeleteObjectInstance;
typedef struct
{
    PHWINFO pDev;
    U032    ChID;
} ARGS_FifoResetChannelState, *PARGS_FifoResetChannelState;
typedef struct
{
    PHWINFO pDev;
    POBJECT Object;
} ARGS_FifoDeleteSubchannelContextEntry, *PARGS_FifoDeleteSubchannelContextEntry;
typedef struct
{
    PHWINFO pDev;
} ARGS_McService, *PARGS_McService;
typedef struct
{
    PHWINFO pDev;
    PFBALLOCINFO pFbAllocInfo;
} ARGS_NvHalFbSetAllocParameters, *PARGS_NvHalFbSetAllocParameters;
typedef struct
{
    PHWINFO pDev;
    U032    hwResId;
} ARGS_NvHalFbFree, *PARGS_NvHalFbFree;
typedef struct
{
    PHWINFO pDev;
    U032 Head;
    PVBLANKCALLBACK Callback;
} ARGS_VBlankDeleteCallback, *PARGS_VBlankDeleteCallback;
typedef struct
{
    PHWINFO pDev;
    POBJECT Object;
    U032    Offset;
    V032    Data;
} ARGS_ClassDirectSoftwareMethod, *PARGS_ClassDirectSoftwareMethod;
typedef struct
{
    PHWINFO pDev;
    U032 Size;
    U032 *Offset;
} ARGS_NvagpAllocAGPBitmap,  *PARGS_NvagpAllocAGPBitmap;
typedef struct
{
    PHWINFO pDev;
    U032 Offset;
    U032 PageCount;
} ARGS_NvagpFreeAGPBitmap,  *PARGS_NvagpFreeAGPBitmap;
typedef struct
{
    PHWINFO pDev;
    U032 Index;
    U032 PageCount;
    U032 Data;
} ARGS_NvagpInsertGARTEntries, *PARGS_NvagpInsertGARTEntries;
typedef struct
{
    PHWINFO pDev;
} ARGS_NvagpFlushGARTEntries, *PARGS_NvagpFlushGARTEntries;
typedef struct
{
    PHWINFO pDev;
    U032   *Instance;
    U032    Size;
    U032    Align;
} ARGS_FbAllocInstMemAlign, *PARGS_FbAllocInstMemAlign;
typedef struct
{
    PHWINFO pDev;
    U032   *Instance;
    U032    Size;
} ARGS_FbAllocInstMem, *PARGS_FbAllocInstMem;
typedef struct
{
    PHWINFO pDev;
    U032    Instance;
    U032    Size;
} ARGS_FbFreeInstMem, *PARGS_FbFreeInstMem;

// critical code wrappers

// critical code wrapper for fifoUpdateObjectInstance()
RM_STATUS smpFifoUpdateObjectInstance
(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID,
    U032    Instance
)
{
    BOOLEAN bStatus;
    ARGS_FifoUpdateObjectInstance args;

    // load the arg struct
    args.pDev = pDev;
    args.Object = Object;
    args.ChID = ChID;
    args.Instance = Instance;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFifoUpdateObjectInstance...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFifoUpdateObjectInstance,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFifoUpdateObjectInstance unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFifoUpdateObjectInstance()

RM_STATUS smpFifoDeleteObjectInstance
(
    PHWINFO pDev,
    POBJECT Object,
    U032    ChID
)
{
    BOOLEAN bStatus;
    ARGS_FifoDeleteObjectInstance args;

    // load the arg struct
    args.pDev = pDev;
    args.Object = Object;
    args.ChID = ChID;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFifoDeleteObjectInstance...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFifoDeleteObjectInstance,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFifoDeleteObjectInstance unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFifoDeleteObjectInstance()

// critical code wrapper for fifoResetChannelState()
RM_STATUS smpFifoResetChannelState
(
    PHWINFO pDev,
    U032    ChID
)
{
    BOOLEAN bStatus;
    ARGS_FifoResetChannelState args;

    // load the arg struct
    args.pDev = pDev;
    args.ChID = ChID;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFifoResetChannelState...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFifoResetChannelState,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFifoResetChannelState unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFifoResetChannelState()

// critical code wrapper for fifoDeleteSubchannelContextEntry()
RM_STATUS smpFifoDeleteSubchannelContextEntry
(
    PHWINFO pDev,
    POBJECT Object
)
{
    BOOLEAN bStatus;
    ARGS_FifoDeleteSubchannelContextEntry args;

    // load the arg struct
    args.pDev = pDev;
    args.Object = Object;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFifoDeleteSubchannelContextEntry...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFifoDeleteSubchannelContextEntry,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFifoDeleteSubchannelContextEntry unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFifoDeleteSubchannelContextEntry()

// critical code wrapper for nvHalFbSetAllocParameters()
RM_STATUS smpNvHalFbSetAllocParameters
(
    PHWINFO pDev,
    PFBALLOCINFO pFbAllocInfo
)
{
    RM_STATUS rmStatus;
    BOOLEAN bStatus;    
    ARGS_NvHalFbSetAllocParameters args;

    //
    // This wrapper only deploys if we have hardware resources
    // associated with the specified block of local memory.
    //
    if (pFbAllocInfo->hwResId)
    {
        // load the arg struct
        args.pDev = pDev;
        args.pFbAllocInfo = pFbAllocInfo;

        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvHalFbSetAllocParameters...\n");

        bStatus = VideoPortSynchronizeExecution(
            pDev->DBmpDeviceExtension,
            VpMediumPriority,
            smpCallbackNvHalFbSetAllocParameters,
            (PVOID)&args
            );

        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvHalFbSetAllocParameters unsynchronized\n");

        rmStatus = (bStatus) ? RM_OK : RM_ERROR;
    }
    else
    {
        //
        // No MP issues in this case...
        //
        rmStatus = nvHalFbSetAllocParameters(pDev, pFbAllocInfo);
    }

    return (rmStatus);

} // end of smpNvHalFbSetAllocParameters()

// critical code wrapper for nvHalFbFree()
RM_STATUS smpNvHalFbFree
(
    PHWINFO pDev,
    U032 hwResId
)
{
    RM_STATUS rmStatus;
    BOOLEAN bStatus;    
    ARGS_NvHalFbFree args;

    //
    // This wrapper only deploys if we have hardware resources
    // associated with the specified block of local memory.
    //
    if (hwResId)
    {
        // load the arg struct
        args.pDev = pDev;
        args.hwResId = hwResId;

        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvHalFbFree...\n");

        bStatus = VideoPortSynchronizeExecution(
            pDev->DBmpDeviceExtension,
            VpMediumPriority,
            smpCallbackNvHalFbFree,
            (PVOID)&args
            );

        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvHalFbFree unsynchronized\n");
        rmStatus = (bStatus) ? RM_OK : RM_ERROR;
    }
    else
    {
        //
        // No MP issues in this case...
        //
        rmStatus = nvHalFbFree(pDev, hwResId);
    }

    return (rmStatus);

} // end of smpNvHalFbFree()

// critical code wrapper for VBlankDeleteCallback()
RM_STATUS smpVBlankDeleteCallback
(
    PHWINFO pDev,
    U032 Head,
    PVBLANKCALLBACK Callback
)
{
    BOOLEAN bStatus;    
    ARGS_VBlankDeleteCallback args;

    // load the arg struct
    args.pDev = pDev;
    args.Head = Head;
    args.Callback = Callback;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpVBlankDeleteCallback...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackVBlankDeleteCallback,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpVBlankDeleteCallback unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpVBlankDeleteCallback()

// critical code wrapper for ClassDirectSoftwareMethod()
RM_STATUS smpClassDirectSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032 Offset,
    U032 Data
)
{
    BOOLEAN bStatus;    
    ARGS_ClassDirectSoftwareMethod args;

    // load the arg struct
    args.pDev = pDev;
    args.Object = Object;
    args.Offset = Offset;
    args.Data = Data;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpClassDirectSoftwareMethod...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackClassDirectSoftwareMethod,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpClassDirectSoftwareMethod unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpClassDirectSoftwareMethod()

// critical code wrapper for nvagp_AllocAGPBitmap
RM_STATUS smpNvagpAllocAGPBitmap
(
    PHWINFO pDev,
    U032 Size,
    U032 *Offset
)
{
    BOOLEAN bStatus;    
    ARGS_NvagpAllocAGPBitmap args;

    // load the arg struct
    args.pDev = pDev;
    args.Size = Size;
    args.Offset = Offset;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvagpAllocAGPBitmap...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackNvagpAllocAGPBitmap,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvagpAllocAGPBitmap unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpNvagpAllocAGPBitmap

// critical code wrapper for nvagp_FreeAGPBitmap
RM_STATUS smpNvagpFreeAGPBitmap
(
    PHWINFO pDev,
    U032 Offset,
    U032 PageCount
)
{
    BOOLEAN bStatus;    
    ARGS_NvagpFreeAGPBitmap args;

    // load the arg struct
    args.pDev = pDev;
    args.Offset = Offset;
    args.PageCount = PageCount;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvagpFreeAGPBitmap...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackNvagpFreeAGPBitmap,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvagpFreeAGPBitmap unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpNvagpFreeAGPBitmap

// critical code wrapper for nvagp_InsertGARTEntries
RM_STATUS smpNvagpInsertGARTEntries
(
    PHWINFO pDev,
    U032 Index,
    U032 PageCount,
    U032 Data
)
{
    BOOLEAN bStatus;    
    ARGS_NvagpInsertGARTEntries args;

    // load the arg struct
    args.pDev = pDev;
    args.Index = Index;
    args.PageCount = PageCount;
    args.Data = Data;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvagpInsertGARTEntries...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackNvagpInsertGARTEntries,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvagpInsertGARTEntries unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpNvagpInsertGARTEntries

// critical code wrapper for nvagp_FlushGARTEntries
RM_STATUS smpNvagpFlushGARTEntries
(
    PHWINFO pDev
)
{
    BOOLEAN bStatus;    
    ARGS_NvagpFlushGARTEntries args;

    // load the arg struct
    args.pDev = pDev;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpNvagpFlushGARTEntries...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackNvagpFlushGARTEntries,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpNvagpFlushGARTEntries unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpNvagpFlushGARTEntries

// critical code wrapper for fbAllocInstMemAlign()
RM_STATUS smpFbAllocInstMemAlign
(
    PHWINFO pDev,
    U032 *Instance,
    U032 Size,
    U032 Align
)
{
    BOOLEAN bStatus;    
    ARGS_FbAllocInstMemAlign args;

    // load the arg struct
    args.pDev = pDev;
    args.Instance = Instance;
    args.Size = Size;
    args.Align = Align;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFbAllocInstMemAlign...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFbAllocInstMemAlign,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFbAllocInstMemAlign unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFbAllocInstMemAlign()

// critical code wrapper for fbAllocInstMem()
RM_STATUS smpFbAllocInstMem
(
    PHWINFO pDev,
    U032 *Instance,
    U032 Size
)
{
    BOOLEAN bStatus;    
    ARGS_FbAllocInstMem args;

    // load the arg struct
    args.pDev = pDev;
    args.Instance = Instance;
    args.Size = Size;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFbAllocInstMem...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFbAllocInstMem,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFbAllocInstMem unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFbAllocInstMemAlign()

// critical code wrapper for fbFreeInstMem()
RM_STATUS smpFbFreeInstMem
(
    PHWINFO pDev,
    U032 Instance,
    U032 Size
)
{
    BOOLEAN bStatus;    
    ARGS_FbFreeInstMem args;

    // load the arg struct
    args.pDev = pDev;
    args.Instance = Instance;
    args.Size = Size;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: Synchronizing smpFbFreeInstMem...\n");

    bStatus = VideoPortSynchronizeExecution(
        pDev->DBmpDeviceExtension,
        VpMediumPriority,
        smpCallbackFbFreeInstMem,
        (PVOID)&args
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...smpFbFreeInstMem unsynchronized\n");

    return (bStatus) ? RM_OK : RM_ERROR;

} // end of smpFbFreeInstMemAlign()

// critical code callbacks

// critical code callback for fifoUpdateObjectInstance()
BOOLEAN smpCallbackFifoUpdateObjectInstance(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_FifoUpdateObjectInstance pArgs = (PARGS_FifoUpdateObjectInstance)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fifoUpdateObjectInstance...\n");

    rmStatus = fifoUpdateObjectInstance(
        pArgs->pDev,
        pArgs->Object,
        pArgs->ChID,
        pArgs->Instance
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fifoUpdateObjectInstance\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;
    
} // end of smpCallbackFifoUpdateObjectInstance()

BOOLEAN smpCallbackFifoDeleteObjectInstance(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_FifoDeleteObjectInstance pArgs = (PARGS_FifoDeleteObjectInstance)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fifoDeleteObjectInstance...\n");

    rmStatus = fifoDeleteObjectInstance(
        pArgs->pDev,
        pArgs->Object,
        pArgs->ChID
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fifoDeleteObjectInstance\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;
    
} // end of smpCallbackFifoDeleteObjectInstance()

BOOLEAN smpCallbackFifoResetChannelState(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_FifoResetChannelState pArgs = (PARGS_FifoResetChannelState)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fifoResetChannelState...\n");

    rmStatus = fifoResetChannelState(
        pArgs->pDev,
        pArgs->ChID
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fifoResetChannelState\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackFifoResetChannelState()

BOOLEAN smpCallbackFifoDeleteSubchannelContextEntry(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_FifoDeleteSubchannelContextEntry pArgs = (PARGS_FifoDeleteSubchannelContextEntry)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fifoDeleteSubchannelContextEntry...\n");

    rmStatus = fifoDeleteSubchannelContextEntry(
        pArgs->pDev,
        pArgs->Object
    );

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fifoDeleteSubchannelContextEntry\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackFifoDeleteSubchannelContextEntry()

BOOLEAN smpCallbackNvHalFbSetAllocParameters(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_NvHalFbSetAllocParameters pArgs = (PARGS_NvHalFbSetAllocParameters)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvHalFbSetAllocParameters...\n");

    rmStatus = nvHalFbSetAllocParameters(pArgs->pDev, pArgs->pFbAllocInfo);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvHalFbSetAllocParameters\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackNvHalFbSetAllocParameters

BOOLEAN smpCallbackNvHalFbFree(PVOID pvArgs)
{
    RM_STATUS rmStatus;
    PARGS_NvHalFbFree pArgs = (PARGS_NvHalFbFree)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvHalFbFree...\n");

    rmStatus = nvHalFbFree(pArgs->pDev, pArgs->hwResId);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvHalFbFree\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackNvHalFbFree

BOOLEAN smpCallbackVBlankDeleteCallback(PVOID pvArgs)
{
    PARGS_VBlankDeleteCallback pArgs = (PARGS_VBlankDeleteCallback)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized VBlankDeleteCallback...\n");

    VBlankDeleteCallback(pArgs->pDev, pArgs->Head, pArgs->Callback);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized VBlankDeleteCallback\n");

    return RM_OK;

} // end of smpCallbackVBlankDeleteCallback

BOOLEAN smpCallbackClassDirectSoftwareMethod(PVOID pvArgs)
{
    PARGS_ClassDirectSoftwareMethod pArgs = (PARGS_ClassDirectSoftwareMethod)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized classDirectSoftwareMethod...\n");

    rmStatus = classDirectSoftwareMethod(pArgs->pDev, pArgs->Object, pArgs->Offset, pArgs->Data);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized classDirectSoftwareMethod\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackClassDirectSoftwareMethod

BOOLEAN smpCallbackNvagpAllocAGPBitmap(PVOID pvArgs)
{
    PARGS_NvagpAllocAGPBitmap pArgs = (PARGS_NvagpAllocAGPBitmap)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvagp_AllocAGPBitmap...\n");

    rmStatus = nvagp_AllocAGPBitmap(pArgs->pDev, pArgs->Size, pArgs->Offset);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvagp_AllocAGPBitmap\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpNvagpAllocAGPBitmap

BOOLEAN smpCallbackNvagpFreeAGPBitmap(PVOID pvArgs)
{
    PARGS_NvagpFreeAGPBitmap pArgs = (PARGS_NvagpFreeAGPBitmap)pvArgs;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvagp_FreeAGPBitmap...\n");

    nvagp_FreeAGPBitmap(pArgs->pDev, pArgs->Offset, pArgs->PageCount);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvagp_FreeAGPBitmap\n");

    return RM_OK;

} // end of smpNvagpFreeAGPBitmap

BOOLEAN smpCallbackNvagpInsertGARTEntries(PVOID pvArgs)
{
    PARGS_NvagpInsertGARTEntries pArgs = (PARGS_NvagpInsertGARTEntries)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvagp_InsertGARTEntries...\n");

    rmStatus = nvagp_InsertGARTEntries(pArgs->pDev, pArgs->Index, pArgs->PageCount, pArgs->Data);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvagp_InsertGARTEntries\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpNvagpInsertGARTEntries

BOOLEAN smpCallbackNvagpFlushGARTEntries(PVOID pvArgs)
{
    PARGS_NvagpFlushGARTEntries pArgs = (PARGS_NvagpFlushGARTEntries)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized nvagp_FlushGARTEntries...\n");

    rmStatus = nvagp_FlushGARTEntries(pArgs->pDev);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized nvagp_FlushGARTEntries\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpNvagpFlushGARTEntries

BOOLEAN smpCallbackFbAllocInstMemAlign(PVOID pvArgs)
{
    PARGS_FbAllocInstMemAlign pArgs = (PARGS_FbAllocInstMemAlign)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fbAllocInstMemAlign...\n");

    rmStatus = fbAllocInstMemAlign(pArgs->pDev, pArgs->Instance, pArgs->Size, pArgs->Align);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fbAllocInstMemAlign\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackFbAllocInstMemAlign

BOOLEAN smpCallbackFbAllocInstMem(PVOID pvArgs)
{
    PARGS_FbAllocInstMem pArgs = (PARGS_FbAllocInstMem)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fbAllocInstMem...\n");

    rmStatus = fbAllocInstMem(pArgs->pDev, pArgs->Instance, pArgs->Size);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fbAllocInstMem\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackFbAllocInstMem

BOOLEAN smpCallbackFbFreeInstMem(PVOID pvArgs)
{
    PARGS_FbFreeInstMem pArgs = (PARGS_FbFreeInstMem)pvArgs;
    RM_STATUS rmStatus;

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: calling synchronized fbFreeInstMem...\n");

    rmStatus = fbFreeInstMem(pArgs->pDev, pArgs->Instance, pArgs->Size);

    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "SMP: ...returned from synchronized fbFreeInstMem\n");

    return (rmStatus == RM_OK) ? TRUE : FALSE;

} // end of smpCallbackFbFreeInstMem

// end of smp.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\osvp.c ===
/******************************************************************************
*
*   Module: osvp.c
*
*   Description:
*       This module contains OS services provided to the RM kernel.  These
*       versions are implemented using the Video Port services.
*
*
*   THE INFORMATION CONTAINED HEREIN IS PROPRIETARY AND CONFIDENTIAL TO
*   NVIDIA, CORPORATION.  USE, REPRODUCTION OR DISCLOSURE TO ANY THIRD PARTY
*   IS SUBJECT TO WRITTEN PRE-APPROVAL BY NVIDIA, CORPORATION.
*
******************************************************************************/

#include <miniport.h>
#include <ntddvdeo.h>
#include <video.h>
#include <dderror.h>
#include <nvrm.h>
#include <os.h>
#include <nvos.h>

#define USE_CURRENT_CONTEXT -1

#ifdef VIDEO_PORT_IMPLEMENTATION
//#if (_WIN32_WINNT >= 0x0500)

// video port service implementation

#if (_WIN32_WINNT >= 0x0500)

RM_STATUS osAllocMem
(
    VOID **pAddress,
    U032   Size
)
{
    VP_STATUS vpStatus = NO_ERROR;
    U008* pMem;
    VOID* hwDeviceExtension = (VOID*)1;

#ifndef DBG

    vpStatus = VideoPortAllocateBuffer
    (
        hwDeviceExtension,
        Size + 4,
        pAddress
    );
    if (vpStatus == NO_ERROR)
    {
        //pDev.Statistics.MemAlloced += Size;
        **(U032 **)pAddress           = Size;
        *(U032 *)pAddress            += 4;
    }
        
#else

    Size += 12;
    vpStatus = VideoPortAllocateBuffer
    (
        hwDeviceExtension,
        Size,
        pAddress
    );
    if (vpStatus == NO_ERROR)
    {
        // memory allocation tracking
        osLogMemAlloc(*pAddress, Size);

        //pDev.Statistics.MemAlloced           += Size - 12;
        **(U032 **)pAddress                     = Size;
        *(U032 *)(*(U032 *)pAddress + 4)        = NV_MARKER1;
        *(U032 *)(*(U032 *)pAddress + Size - 4) = NV_MARKER2;
        *(U032 *)pAddress += 8;
        pMem = (U008 *)*pAddress;
        Size -= 12;
        while (Size--)
            *pMem++ = 0x69;
    }
            
#endif // DBG

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERR_NO_FREE_MEM;
    
}

RM_STATUS osFreeMem
(
    VOID *pAddress
)
{
    RM_STATUS status = RM_OK;
    U032      Size;
    VOID* hwDeviceExtension = (VOID*)1;
    
#ifndef DBG

    pAddress = (VOID *)((U032)pAddress - 4);
    Size     = *(U032 *)pAddress;
    
#else

    pAddress = (VOID *)((U032)pAddress - 8);
    Size     = *(U032 *)pAddress;
    if (*(U032 *)((U032)pAddress + 4) != NV_MARKER1)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Invalid address to osFreeMem\n");
        DBG_BREAKPOINT();
    }
    if (*(U032 *)((U032)pAddress + Size - 4) != NV_MARKER2)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Memory overrun in structure to osFreeMem\n");
        DBG_BREAKPOINT();
        return (RM_ERR_MEM_NOT_FREED);
    }
    *(U032 *)((U032)pAddress + 4)        = 'DAED';
    *(U032 *)((U032)pAddress + Size - 4) = 'DEAD';
    Size -= 12;

    // memory allocation tracking
    osUnlogMemAlloc(pAddress);

#endif // DBG  
  
    VideoPortReleaseBuffer(
        hwDeviceExtension,
        pAddress
    );

    //pDev.Statistics.MemAlloced -= Size;

    return status;
    
}

#endif // Win2K

typedef struct _MDL {
    struct _MDL *Next;
    CSHORT Size;
    CSHORT MdlFlags;
    struct _EPROCESS *Process;
    PVOID MappedSystemVa;
    PVOID StartVa;
    ULONG ByteCount;
    ULONG ByteOffset;
} MDL, *PMDL;

#define MDL_MAPPED_TO_SYSTEM_VA     0x0001
#define MDL_PAGES_LOCKED            0x0002
#define MDL_SOURCE_IS_NONPAGED_POOL 0x0004
#define MDL_ALLOCATED_FIXED_SIZE    0x0008
#define MDL_PARTIAL                 0x0010
#define MDL_PARTIAL_HAS_BEEN_MAPPED 0x0020
#define MDL_IO_PAGE_READ            0x0040
#define MDL_WRITE_OPERATION         0x0080
#define MDL_PARENT_MAPPED_SYSTEM_VA 0x0100
#define MDL_LOCK_HELD               0x0200
#define MDL_SCATTER_GATHER_VA       0x0400
#define MDL_IO_SPACE                0x0800
#define MDL_NETWORK_HEADER          0x1000
#define MDL_MAPPING_CAN_FAIL        0x2000
#define MDL_ALLOCATED_MUST_SUCCEED  0x4000
#define MDL_64_BIT_VA               0x8000

RM_STATUS osLockUserMem
(
    PHWINFO             pDev,
    U032                ChID,
    U032                Selector,
    U032                Offset,
    U032                DmaAddress,
    NV_ADDRESS_SPACE*   DmaAddressSpace,
    U032                DmaLength,
    U032                PageCount,
    U032*               PageArray,
    U032*               pLinAddr,
    U032*               pLockHandle
)
{
    RM_STATUS rmStatus;
    PMDL pMdl = 0;
    ULONG i;
    STATUS_BLOCK vrpStatus;
    VIDEO_REQUEST_PACKET vrp;
    PULONG mdlPageArray;

    // map the buffer
    *pLinAddr = DmaAddress;

    //
    // If we're asking to lock video memory, let's just build up the PTE's and assume
    // that the caller has real control over video memory (such as DirectDraw or the
    // display driver).
    //
    if (*DmaAddressSpace == ADDR_FBMEM)
    {
        //
        // This is hardcoded assuming zero = start of fb
        //
        for (i = 0; i < PageCount; i++)
        {
            PageArray[i] = (*pLinAddr + (i * RM_PAGE_SIZE)) | 3;
        }
    }
    else
    {
        // fill a VRP with the buffer information
        vrpStatus.Status = 0;    
        vrpStatus.Information = 0;    
        vrp.IoControlCode = 0;
        vrp.StatusBlock = &vrpStatus;    
        vrp.InputBuffer = (PVOID)DmaAddress;    
        vrp.InputBufferLength = DmaLength;
        vrp.OutputBuffer = NULL;    
        vrp.OutputBufferLength = 0;

        // lock the buffer's pages
        if (
            VideoPortLockPages(
                pDev->DBmpDeviceExtension,
                &vrp,
                NULL,
                NULL,
                VideoPortDmaInitOnly
            )
        )
        {
            // save the MDL pointer
            *pLockHandle = (U032)vrp.OutputBuffer;

            // load the PTE array with physical addresses of the page-aligned buffer
            pMdl = (PMDL)VideoPortGetMdl(
                pDev->DBmpDeviceExtension, 
                (PDMA)pLockHandle
            );
            if (pMdl != NULL)
            {
                // extract the physical address from the MDL into the PTE array
                mdlPageArray = (PULONG)(pMdl + 1);
                for (i = 0; i < PageCount; i++)
                {
                    PageArray[i] = mdlPageArray[i] | 3;
                }
            }
            else 
            {
                VideoPortUnlockPages(pDev->DBmpDeviceExtension, (PDMA)pLockHandle);
                rmStatus = RM_ERROR;
            }
        }
        else 
        {
            rmStatus = RM_ERROR;
        }
    }

    return rmStatus;    
}

RM_STATUS osUnlockUserMem
(
    PHWINFO          pDev,
    U032             ChID,
    VOID*            LinAddr,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    U032             LockHandle,
    U032             DirtyFlag
)
{
    BOOLEAN status = TRUE;

    //
    // If we're asking to unlock video memory, we're assuming the caller (probably
    // direct draw)  has complete control of video memory, and therefore knows what
    // is locked/unlocked.  No need to do anything.
    //
    if (DmaAddressSpace != ADDR_FBMEM)
    {
        // otherwise, unmap locked pages, unlock pages, and free the MDL
        status = VideoPortUnlockPages(
            pDev->DBmpDeviceExtension,
            (PDMA)&LockHandle
        );
    }

    return (status) ? RM_OK : RM_ERROR;
}

//#endif // (_WIN32_WINNT >= 0x0500)
#endif // VIDEO_PORT_IMPLEMENTATION

RM_STATUS osMapPciMemoryUser( 
    PHWINFO pDev,
    U032 busAddress, 
    U032 length,
    VOID** pVirtualAddress
) 
{
    VP_STATUS vpStatus = NO_ERROR;
    U032 mapFlags;
    PHYSICAL_ADDRESS busPhysicalAddress; 

#if (_WIN32_WINNT >= 0x0500)
    mapFlags = VIDEO_MEMORY_SPACE_P6CACHE;
#else
    mapFlags = VIDEO_MEMORY_SPACE_USER_MODE;
#endif

    // construct an NT physical address from the requested bus-relative address
    busPhysicalAddress.HighPart = 0x00000000;
    busPhysicalAddress.LowPart = busAddress;

    // flag the video port to map into the current context
    *pVirtualAddress = (VOID*)USE_CURRENT_CONTEXT;

    // map the PCI memory into user mode
    vpStatus = VideoPortMapMemory(
        pDev->DBmpDeviceExtension,
        busPhysicalAddress,
        &length,
        &mapFlags,
        pVirtualAddress
    );
    
    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;

}

RM_STATUS osUnmapPciMemoryUser(
    PHWINFO pDev,
    VOID* virtualAddress
)
{
    VP_STATUS vpStatus = NO_ERROR;

    VideoPortUnmapMemory(
        pDev->DBmpDeviceExtension,
        virtualAddress,
        (VOID*)USE_CURRENT_CONTEXT
    );

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;

}

#if defined(_WIN64)

#define MAX_DMA_LENGTH   (2*1024*1024)

RM_STATUS osInitDmaAdapter
(
    PHWINFO pDev
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    RM_STATUS rmStatus = RM_OK;
    VP_DEVICE_DESCRIPTION deviceDescription = {
        TRUE,          // ScatterGather;
        TRUE,          // Dma32BitAddresses
        FALSE,         // Dma64BitAddresses
        MAX_DMA_LENGTH // MaximumLength
    };

    pOsHwInfo->dmaAdapter = VideoPortGetDmaAdapter(pDev->DBmpDeviceExtension,
                                                   &deviceDescription);
    if(pOsHwInfo->dmaAdapter == NULL)
        return RM_ERROR;
    else
        return RM_OK;
}

RM_STATUS osAllocSystemPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   pageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    PWINNTHWINFO     pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    PSYS_MEM_INFO    pMemInfo;
    PHYSICAL_ADDRESS logicalAddr;
    RM_STATUS        rmStatus;
    VOID             *pageAddr, *userAddr;

    // Since there will be some cleanup needed on the free side
    // create a struct that hooks into VOID * in CLI_MEMORY_INFO

    rmStatus = osAllocMem((VOID **)&pMemInfo, sizeof(SYS_MEM_INFO));
    if (rmStatus != RM_OK)
        return rmStatus;

    pMemInfo->sysAddr = VideoPortAllocateCommonBuffer(pDev->DBmpDeviceExtension,
                                                      pOsHwInfo->dmaAdapter,
                                                      (pageCount + 1) << RM_PAGE_SHIFT,
                                                      &logicalAddr,
                                                      TRUE,
                                                      &pMemInfo->length);
    if (pMemInfo->sysAddr == NULL) {
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }
    pMemInfo->logicalAddr = logicalAddr.QuadPart;
    pageAddr = (VOID *)(((NV_UINTPTR_T)pMemInfo->sysAddr + RM_PAGE_MASK) & ~RM_PAGE_MASK);
    pMemInfo->physAddr = (pMemInfo->logicalAddr + RM_PAGE_MASK) & ~RM_PAGE_MASK;

    if ((pMemInfo->clientClass = ClientClass) == NV01_ROOT_USER) {
        userAddr = osMapUserSpace(pageAddr, &pMemInfo->pMdl,
                                  pageCount << RM_PAGE_SHIFT, MAP_CACHED);
        if (userAddr == NULL) {
            VideoPortReleaseCommonBuffer(pDev->DBmpDeviceExtension,
                                         pOsHwInfo->dmaAdapter,
                                         pMemInfo->length,
                                         logicalAddr,
                                         pMemInfo->sysAddr,
                                         TRUE);
            osFreeMem(pMemInfo);
            return RM_ERR_NO_FREE_MEM;
        } else {
           *pAddress = userAddr;
        }
    } else {
       *pAddress = pageAddr;
    }
    *pMemData = (VOID *)pMemInfo;
    return RM_OK;
}

RM_STATUS osFreeSystemPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID *pMemData
)
{
    PWINNTHWINFO     pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    PSYS_MEM_INFO    pMemInfo = (PSYS_MEM_INFO)pMemData;
    PHYSICAL_ADDRESS logicalAddr;

    // unmap the memory from user space, if necessary
    if (pMemInfo->clientClass == NV01_ROOT_USER) {
        osUnmapUserSpace(*pAddress, pMemInfo->pMdl);
    }

    // free the memory using the original pointer and actual allocated length
    logicalAddr.QuadPart = pMemInfo->logicalAddr;
    VideoPortReleaseCommonBuffer(pDev->DBmpDeviceExtension,
                                 pOsHwInfo->dmaAdapter, pMemInfo->length,
                                 logicalAddr, pMemInfo->sysAddr,
                                 TRUE);

    // free our data struct that kept track of this mapping
    osFreeMem(pMemInfo);

    return RM_OK;
}

#endif // _WIN64

VOID osWriteReg008(volatile U008* address, U008 data)
{
    VideoPortWriteRegisterUchar((PUCHAR)address, (UCHAR)data);
}

VOID osWriteReg016(volatile U016* address, U016 data)
{
    VideoPortWriteRegisterUshort((PUSHORT)address, (USHORT)data);
}

VOID osWriteReg032(volatile U032* address, U032 data)
{
    VideoPortWriteRegisterUlong((PULONG)address, (ULONG)data);
}

U008 osReadReg008(volatile U008* address)
{
    return VideoPortReadRegisterUchar((PUCHAR)address);
}

U016 osReadReg016(volatile U016* address)
{
    return VideoPortReadRegisterUshort((PUSHORT)address);
}

U032 osReadReg032(volatile U032* address)
{
    return VideoPortReadRegisterUlong((PULONG)address);
}

VP_STATUS osReadRegistryCallback
(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
)
{
    // return the extracted reg value
    *(U032*)Context = *(U032*)ValueData;
    
    return NO_ERROR;

} // end of osReadRegistryCallback()

VP_STATUS osReadRegistryBinaryCallback
(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
)
{
    ULONG i;

    // Grab the avil length from the contexts first element and make
    // sure that the value provided will fit in the buffer
    if (ValueLength > ((U032 *)Context)[0])
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    // Let the VP do the value copy
    VideoPortMoveMemory(Context,ValueData,ValueLength);

    return NO_ERROR;

} // end of osReadRegistryBinaryCallback()

RM_STATUS osReadRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 *cbLen
)
{
    RM_STATUS rmStatus = RM_OK;
    VP_STATUS vpStatus;
    WCHAR parameterName[80];
    U032 i;
    // long word allign the following so we can stuff
    // a buffer length in the first element.  We need
    // to do this as the callback does not provide for
    // a buffer size to be passed in
    U032 localvaluebuffer[64];
 
    // Make sure that we have enough space for the callback data copy
    if (*cbLen > sizeof(localvaluebuffer))
    {
        return RM_ERROR;
    }

     // convert the parameter into a unicode string
    for (i = 0; regParmStr[i]; i++)
    {
        parameterName[i] = regParmStr[i];
    }
    parameterName[i] = (WCHAR)NULL;

    // Stuff the size in the first element
    localvaluebuffer[0] = *cbLen;

    // call the video port to get the parameter value -- calls back to osReadRegistryCallback()
    vpStatus = VideoPortGetRegistryParameters
    (
        pDev->DBmpDeviceExtension,
        parameterName,
        FALSE,
        osReadRegistryBinaryCallback,
        &localvaluebuffer
    );

    // If all is well, fetch the value data and copy it 
    if(vpStatus == NO_ERROR) {

      // Let the VP do the copy and set the size to
      // what the caller suggested
      VideoPortMoveMemory(Data,localvaluebuffer,*cbLen);
    }

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
}

RM_STATUS osWriteRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 cbLen
)
{
    VP_STATUS vpStatus;
    WCHAR parameterName[80];
    U032 i;

     // convert the parameter into a unicode string
    for (i = 0; regParmStr[i]; i++)
    {
        parameterName[i] = regParmStr[i];
    }
    parameterName[i] = (WCHAR)NULL;

    // call the video port to set the parameter value
    vpStatus = VideoPortSetRegistryParameters(
                  pDev->DBmpDeviceExtension,
                  parameterName,
                  Data,
                  cbLen
                  );

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
}

RM_STATUS osWriteRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 Data
)
{
    VP_STATUS vpStatus;
    WCHAR parameterName[80];
    U032 i;

     // convert the parameter into a unicode string
    for (i = 0; regParmStr[i]; i++)
    {
        parameterName[i] = regParmStr[i];
    }
    parameterName[i] = (WCHAR)NULL;

    // call the video port to set the parameter value
    vpStatus = VideoPortSetRegistryParameters(
                  pDev->DBmpDeviceExtension,
                  parameterName,
                  &Data,
                  sizeof(ULONG)
                  );

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
}

RM_STATUS osReadRegistryDword
(
    PHWINFO pDev,
    char* regDevNode,
    char* regParmStr,
    U032* pData
)
{
    RM_STATUS rmStatus = RM_OK;
    VP_STATUS vpStatus;
    WCHAR parameterName[80];
    U032 i;
    
    // convert the parameter into a unicode string
    for (i = 0; regParmStr[i]; i++)
    {
        parameterName[i] = regParmStr[i];
    }
    parameterName[i] = (WCHAR)NULL;

    // call the video port to get the parameter value -- calls back to osReadRegistryCallback()
    vpStatus = VideoPortGetRegistryParameters
    (
        pDev->DBmpDeviceExtension,
        parameterName,
        FALSE,
        osReadRegistryCallback,
        pData
    );

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
    
} // end of osReadRegistryDword()

RM_STATUS osCallVideoBIOS
(
    PHWINFO pDev, 
    U032 *pEAX, 
    U032 *pEBX, 
    U032 *pECX, 
    U032 *pEDX, 
    VOID *pBuffer
)
{
    VP_STATUS vpStatus = NO_ERROR;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;

    // load the register values and call int10 thru the Video Port
    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    biosArguments.Eax = *pEAX;
    biosArguments.Ebx = *pEBX;
    biosArguments.Ecx = *pECX;
    biosArguments.Edx = *pEDX;
    vpStatus = VideoPortInt10(pDev->DBmpDeviceExtension, &biosArguments);
    *pEAX = biosArguments.Eax;
    *pEBX = biosArguments.Ebx;
    *pECX = biosArguments.Ecx;
    *pEDX = biosArguments.Edx;
    
    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
    
} // end of osCallVideoBIOS()

#if (_WIN32_WINNT >= 0x0500)
RM_STATUS osDelayUs
(
    U032 MicroSeconds
)
{
    VP_STATUS vpStatus = NO_ERROR;

    VideoPortStallExecution(MicroSeconds);

    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
    
}
#endif

//
// The purpose of this routine is to reset to base VGA display mode
// in preparation for full-screen DOS box, standby, or hibernation.
// 
VP_STATUS RMVideoResetDevice(
    U032 deviceReference
)
{
    U008 cr3B;
    BOOL scratchRestore = FALSE;
    U032 headDisable;
    VP_STATUS vpStatus = NO_ERROR;
    VIDEO_X86_BIOS_ARGUMENTS biosArguments;
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    /* 
     * Disable the secondary head (dacDisableBroadcast) if currently running in 
     * clone mode before calling the bios to do the mode set.  This will insure
     * that on chips where this feature is broken (nv11) that the secondary
     * head isn't left displaying garbage.  i.e. in a full screen dos box
     * on mobile the crt will display a red bar at the top while the internal
     * flat panel is displaying the dos screen.
     */
    if (pDev->Dac.CrtcInfo[0].PrimaryDevice)
        headDisable = 1;
    else
        headDisable = 0;

    scratchRestore = dacDisableBroadcast(pDev, headDisable, &cr3B);

    // load the register values and call int10 thru the Video Port
    VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
    biosArguments.Eax = 0x0003;
    
    vpStatus = VideoPortInt10(pDev->DBmpDeviceExtension, &biosArguments);


    // Need to check to see if certain devices are enabled
    if(pDev->Power.MobileOperation)
    {
      // Call the BIOS to find out which displays were enabled
      VideoPortZeroMemory(&biosArguments, sizeof(VIDEO_X86_BIOS_ARGUMENTS));
      biosArguments.Eax = 0x4f14;
      biosArguments.Ebx = 0x0085;
      vpStatus = VideoPortInt10(pDev->DBmpDeviceExtension, &biosArguments);

      if(biosArguments.Ebx & 0x1)
      {
          // if the monitor was turned off by power management, make sure it is
          // turned back on.  Usually this happens via the call to do the int 10
          // modeset, but on toshiba, the bios doesn't do it.  So we'll do it here
          // just to make sure it's on.
          // Note:  This is the expected result if a modeset happens at a time when
          // just the monitor has been turned off via power management.
          if (pDev->Dac.DevicesEnabled & DAC_MONITOR_POWER_STATE_OFF)
          {
              mcPowerDisplayState(pDev, MC_POWER_LEVEL_5, 1);
              // delay needed because if it's not here, toshiba will not go completely
              // into standby.  everyone else doesn't care if the delay is here or not.
              // also, 200ms seemed to be the amount of delay needed.  200ms was close, but wasn't enough.
              tmrDelay(pDev, 1000000*300);	// 1ms*300

              pDev->Dac.DevicesEnabled &= ~DAC_MONITOR_POWER_STATE_OFF;
          }
          else
              pDev->Dac.DevicesEnabled |= DAC_PANEL_ENABLED;
      }
      // CRT is not currently used
//      if(biosArguments.Ebx & 0x2)
//          pDev->Dac.DevicesEnabled |= DAC_CRT_ENABLED;
      if(biosArguments.Ebx & 0x4)
          pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
    }

    //
    // When just going into a dos box (i.e. display power state is on) we don't
    // want to restore the scratch bits because otherwise the secondary display will
    // get turned back on when win2k does a vga modeset behind our back.
    // However, when this reset is a result of a power management event (specifically standby)
    // and the display power state is off, then we need to restore the register before leaving
    // otherwise when we come out of standby, we won't always resume to the correct display
    // configuration.
    // Can this get any uglier??
    if ((scratchRestore)
     && (pDev->Power.DisplayState[headDisable] == MC_POWER_LEVEL_6))
        dacRestoreBroadcast(pDev, headDisable, cr3B);


    return (vpStatus);

} // end of RMVideoResetDevice()


RM_STATUS osDelay
(
    U032 MilliSeconds
)
{
    VP_STATUS vpStatus = NO_ERROR;

    VideoPortStallExecution(MilliSeconds * 1000);
    
    return (vpStatus == NO_ERROR) ? RM_OK : RM_ERROR;
    
}

#if (_WIN32_WINNT >= 0x0500)
RM_STATUS osIsr
(
    PHWINFO pDev
)
{
    BOOL serviced = FALSE;
    
    if (RmInterruptPending(pDev, &serviced))
    {
        // queue up a DPC for a normal priority interrupt
        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Queueing interrupt on DPC queue...\n");
        serviced |= VideoPortQueueDpc(pDev->DBmpDeviceExtension, RmDpcForIsr, pDev);
    }
    
    return (serviced) ? RM_OK : RM_ERROR;

} // end of osIsr()

VOID RmDpcForIsr
(
    PVOID HwDeviceExtension,
    PVOID Context
)
{
    PHWINFO pDev = (PHWINFO)Context;
    
    // service queued up interrupts and reenable interrupts
    //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Servicing interrupt at DPC level...\n");
    mcService(pDev);
    RmEnableInterrupts(pDev);

} // end of RmDpcForIsr()

#endif // (_WIN32_WINNT >= 0x0500)

#ifdef WIN2K_DDK_THAT_CONTAINS_APIS

RM_STATUS osNotifyEvent
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Notifier,
    U032      Method,
    U032      Data,
    RM_STATUS Status,
    U032      Action
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 i, j;
    PEVENTNOTIFICATION NotifyEvent;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: osNotifyEvent()\n");
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVGFX:   Object =", Object);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Method =", Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Data   =", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Status =", Status);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Action =", Action);

    // perform the type of action
    switch (Action)
    {
        case NV_OS_WRITE_THEN_AWAKEN:

            // walk this object's event list and find any matches for this specific notify
            for (NotifyEvent = Object->NotifyEvent; NotifyEvent; NotifyEvent = NotifyEvent->Next)
            {
                if (NotifyEvent->NotifyIndex == Notifier)
                {
                    // found a match -- notify the event
                    switch (NotifyEvent->NotifyType)
                    {
                        case NV01_EVENT_WIN32_EVENT:
                        {
                            // attempt to trigger the event
                            if (!VideoPortSetEvent(pDev->DBmpDeviceExtension, (PEVENT)NotifyEvent->Data.low))
                            {
                                // failed, so invalidate this event so we don't try again
                                NotifyEvent->NotifyType = 0;
                            }
                            break;
                        }

                        case NV01_EVENT_KERNEL_CALLBACK:
                        {
                            MINIPORT_CALLBACK callBackToMiniport = (MINIPORT_CALLBACK)(NotifyEvent->Data.low);

                            // perform a direct callback to the miniport
                            if (callBackToMiniport)
                                callBackToMiniport(pDev->DBmpDeviceExtension);
                            break;
                        }
                    
                        default:
                            break;    
                    }
                }
            }
            break;

        default:

            // any other actions are legacy channel-based notifies
            rmStatus = NVOS10_STATUS_ERROR_BAD_EVENT;
            break;
    }

    return rmStatus;

} // end of osNotifyEvent()

#endif // WIN2K_DDK_THAT_CONTAINS_APIS


// end of smp.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\ccommandq.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch Qs*************************\
*                                                                           *
* Module: CCommandQ.cpp														*
*   Object to command Q reads												*
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <aos.h>
#include <nv_papu.h>
#include <AudioHw.h>
};

#include "CHalBase.h"
#include "CCommandQ.h"

CCommandQ::~CCommandQ()
{
    if (m_CommandQ.pLinAddr)
        delete m_CommandQ.pLinAddr;
}

RM_STATUS
CCommandQ::Initialize(Q_TYPE eType)
{
    if (Q_TYPE_EP)
    {
        m_uPut = NV_PAPU_EPPUT;
        m_uGet = NV_PAPU_EPGET;
        m_uQ = NV_PAPU_EPCADDR;
    }
    else if (Q_TYPE_GP)
    {
        m_uPut = NV_PAPU_GPPUT;
        m_uGet = NV_PAPU_GPGET;
        m_uQ = NV_PAPU_GPCADDR;
    }
    else
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CCommandQ::CCommandQ - bad argument!");
        aosDbgBreakPoint();
        return RM_ERROR;
    }

    // allocate memory for the command Q
    RM_STATUS rmStatus =  aosAllocateMem(m_CommandQ.Size,
						                ALIGN_16K,
						                &m_CommandQ.pLinAddr,
						                &m_CommandQ.pPhysAddr);
    if (rmStatus == RM_OK)
    {
        m_pHal->RegWrite(m_uQ, (U032)m_CommandQ.pPhysAddr);
        m_pHal->RegWrite(m_uPut, (U032)0);
        m_pHal->RegWrite(m_uGet, (U032)0);
    }

    return rmStatus;
}


BOOL
CCommandQ::Read(U032 *puData)
{
    U032 uOffset;
    U032 uPut;

    // read the offset to be read from
    m_pHal->RegRead(m_uGet, &uOffset);
    *puData = *(U032*)((U008*)m_CommandQ.pLinAddr + uOffset);

    // update the GET pointer
    COMMAND_Q_INCREMENT(uOffset);
    m_pHal->RegWrite(m_uGet, uOffset);
    m_pHal->RegRead(m_uPut, &uPut);
    return (uPut == uOffset) ? TRUE:FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\osdload.c ===
/*****************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2001 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2001  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
|*****************************************************************************|
|*                                                                           *|
|* Module: osdload.c                                                         *|
|*    These are the OS-specific bits of implementing dynamic loading of      *|
|* driver code.  Be that from file, ROM/BIOS, etc.                           *|
|*                                                                           *|
|*****************************************************************************|
|*                                                                           *|
|* History:                                                                  *|
|*       Ken Adams (kadams)     02/2001 - wrote it based upon investigatory  *|
|*                                        code from Todd Poynter.            *|
|*                                                                           *|
\*****************************************************************************/

#include <ntddk.h>
#include <nvrm.h>
#include <os.h>
#include <nvos.h>
#include <nvhw.h>
#include <Nvcm.h>
#include <dload.h>    


// At the moment, only supported for Win2k+
#if (_WIN32_WINNT >= 0x0500)


#define BAIL(r,s,p)  {     \
   ret = (r);              \
   DBG_PRINT_STRING(p ,s); \
   DBG_BREAKPOINT();       \
   goto cleanup;           \
}

static RM_STATUS setupMemOffsets(PDLD_MODULE pImg);
static RM_STATUS setupRelocations(PDLD_MODULE pImg);

//------------------------------------------------------------------
// osDldLinkImg
//
//    As we come into this routine, pImg is pointing into the raw
// image as given to the DldLoadImg interface.  We need to copy
// everything we need out of that struct (and what it points to) 
// and replace it memory malloc'd for what we need, here.  
// Oh yeah, we also have to do any relocations, get the memory 
// offsets setup and the like.  This is the real meat of the
// linking process.  For WindowsNT anyway this is pretty easy.
// We can just simply assign memory offsets in serial fashion
// to the various sections.  Addresses have to be assigned to 
// all the symbols.  Then any relocations have to be patched in.
//
//------------------------------------------------------------------
RM_STATUS osDldLinkImg ( VOID *_pMod )
{

	PDLD_MODULE             pMod = (PDLD_MODULE) _pMod;
	PNV_ImageHeader         pHeader;
	PSectionInfoEntry	pSections;
	PRelocationInfoEntry	pRelocs;
	PSymbolTableEntry	pSymbols;
	NvU8		       *pCode;
	NvU8                   *pData;
	NvU8                   *pBss;
	int                     ret = 0;
	unsigned int            checkSize;

	pMod->footer = 0;  // we no longer care about the footer

	// pMod->header should ALWAYS be valid.  ??? The rest may or may not 
	// be needed later ???  For kicks fuse data,code,bss because we know
	// we won't ever need to remove them individually.  We can probably
	// remove the sections,relocs,symbols at some point though...

	ret |= osAllocMem(&pHeader,   sizeof(NV_ImageHeader)      * 1);
	ret |= osAllocMem(&pSections, sizeof(SectionInfoEntry)    * pMod->header->nSections);
	ret |= osAllocMem(&pRelocs,   sizeof(RelocationInfoEntry) * pMod->header->nRelocs);
	ret |= osAllocMem(&pSymbols,  sizeof(SymbolTableEntry)    * pMod->header->nSymbols);
	ret |= osAllocMem(&pData,     sizeof(char) * (  pMod->header->dataSize 
						      + pMod->header->codeSize 
						      + pMod->header->bssSize  ) );
	pCode = pData + pMod->header->dataSize;
	pBss  = pCode + pMod->header->codeSize;
			  
	if ( ret != RM_OK ) 
		BAIL(RM_ERROR,"NVRM: oom section headers",DEBUGLEVEL_ERRORS);

	osMemCopy((NvU8*)pHeader,  (NvU8*)pMod->header,     sizeof(NV_ImageHeader)      * 1);
	osMemCopy((NvU8*)pSections,(NvU8*)pMod->secTable,   sizeof(SectionInfoEntry)    * pMod->header->nSections);
	osMemCopy((NvU8*)pRelocs,  (NvU8*)pMod->relocTable, sizeof(RelocationInfoEntry) * pMod->header->nRelocs);
	osMemCopy((NvU8*)pSymbols, (NvU8*)pMod->symTable,   sizeof(SymbolTableEntry)    * pMod->header->nSymbols);
	osMemCopy((NvU8*)pData,    (NvU8*)pMod->dataBuffer, sizeof(NvU8)                * pMod->header->dataSize);
	osMemCopy((NvU8*)pCode,    (NvU8*)pMod->codeBuffer, sizeof(NvU8)                * pMod->header->codeSize);


	pMod->header     = pHeader;    	pHeader   = 0;
	pMod->secTable   = pSections;   pSections = 0;
	pMod->relocTable = pRelocs;     pRelocs   = 0;
	pMod->symTable   = pSymbols;    pSymbols  = 0;
	pMod->dataBuffer = pData;       pData     = 0;
	pMod->codeBuffer = pCode;       pCode     = 0;
	pMod->bssBuffer  = pBss;        pBss      = 0;


	if ( RM_OK != (ret = setupMemOffsets(pMod) ) ) {
		goto cleanup;
	}

	// This step performs the actual "linking".  
	ret = setupRelocations(pMod);
		

 cleanup:
	if ( ret != RM_OK ) {
		if ( pHeader )   osFreeMem(pHeader); 
		if ( pSections ) osFreeMem(pSections);
		if ( pRelocs )   osFreeMem(pRelocs);
		if ( pSymbols )  osFreeMem(pSymbols);
		if ( pData )     osFreeMem(pData);
	}

	return ret;
}


//------------------------------------------------------------------
// osDldUnlinkImg
//
// Jettison the image.
//
//------------------------------------------------------------------
RM_STATUS osDldUnlinkImg ( VOID *_pMod )
{
	PDLD_MODULE pMod = (PDLD_MODULE)_pMod;
	int ret = RM_OK;

	if ( pMod->header )     { osFreeMem(pMod->header);     pMod->header     = 0; }
	if ( pMod->secTable )   { osFreeMem(pMod->secTable);   pMod->secTable   = 0; }
	if ( pMod->relocTable ) { osFreeMem(pMod->relocTable); pMod->relocTable = 0; }
	if ( pMod->symTable )   { osFreeMem(pMod->symTable);   pMod->symTable   = 0; }
	if ( pMod->dataBuffer ) { 
		osFreeMem(pMod->dataBuffer); 
		pMod->dataBuffer = pMod->codeBuffer = pMod->bssBuffer = 0; 
	}

	return ret;
}


#ifndef _WIN64

//------------------------------------------------------------------
//  setupMemOffsets
//
//  Cruise through the sections, assigning an offset within the
//  proper buffer for each.  In otherwords, place the sections
//  in memory...
//------------------------------------------------------------------
RM_STATUS setupMemOffsets(PDLD_MODULE pMod)
{
	unsigned int i = 0;
	NvU16       nSections = pMod->header->nSections;
	NvU8        *dataPtr  = pMod->dataBuffer;
	NvU8        *codePtr  = pMod->codeBuffer;
        NvU8        *bssPtr   = pMod->bssBuffer;
	int          ret = RM_OK;
	
	for (i = 0; i < nSections; i++)
	{
		switch ( pMod->secTable[i].type ) {

			case NV_DLOAD_SECTION_TYPE_DATA:
				pMod->secTable[i].memOffset = (NvU32)(NV_UINTPTR_T)dataPtr; // XXX - ain't right 32 vs 64b
				dataPtr += pMod->secTable[i].dataSize;
				break;
			case NV_DLOAD_SECTION_TYPE_CODE:
				pMod->secTable[i].memOffset = (NvU32)(NV_UINTPTR_T)codePtr; // XXX - ain't right 32 vs 64b
				codePtr += pMod->secTable[i].dataSize;
				break;
			case NV_DLOAD_SECTION_TYPE_BSS:
				pMod->secTable[i].memOffset = (NvU32)(NV_UINTPTR_T)bssPtr;  // XXX - ain't right 32 vs 64b
				bssPtr += pMod->secTable[i].dataSize;
				break;
			default:
				BAIL(RM_ERROR,"NVRM:  setupMemOffsets(...) unknown type",DEBUGLEVEL_ERRORS);
		}
	}

 cleanup:

	return ret;
}



// Defined in winnt.h.  But we don't need that whole mess.  These aren't likely to change, ever.
#ifndef IMAGE_REL_I386_ABSOLUTE

#define IMAGE_REL_I386_ABSOLUTE         0x0000  // Reference is absolute, no relocation is necessary
#define IMAGE_REL_I386_DIR16            0x0001  // Direct 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_REL16            0x0002  // PC-relative 16-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32            0x0006  // Direct 32-bit reference to the symbols virtual address
#define IMAGE_REL_I386_DIR32NB          0x0007  // Direct 32-bit reference to the symbols virtual address, base not included
#define IMAGE_REL_I386_SEG12            0x0009  // Direct 16-bit reference to the segment-selector bits of a 32-bit virtual address
#define IMAGE_REL_I386_SECTION          0x000A
#define IMAGE_REL_I386_SECREL           0x000B
#define IMAGE_REL_I386_REL32            0x0014  // PC-relative 32-bit reference to the symbols virtual address

#endif


//------------------------------------------------------------------
//  setupRelocations
//
//  This routine walks all of the registered relocations in the
//  NVImage and fixes them up as necessary.  Note that it calls
//  back into the image-format-independent code (Dld*) to get
//  symbol offsets and the like.
//------------------------------------------------------------------
RM_STATUS setupRelocations( PDLD_MODULE pMod )
{
	int         ret = RM_OK;
	unsigned int i, j, relocIndex;
	NV_UINTPTR_T relocAddr;
	NvU16        nSections  = pMod->header->nSections;
	NvU32        nRelocs    = pMod->header->nRelocs;


	for (i = 0; i < nSections; i++)	{

		if ( !pMod->secTable[i].numRelocs ) continue;

		// find the first relocation table index with the same sec number 
		// as the section we are currently working on.

		for ( relocIndex = 0; 
		      ( relocIndex < pMod->header->nRelocs )
			      && (pMod->relocTable[relocIndex].secNumber != pMod->secTable[i].secNumber ) ; 
		      relocIndex++ ) {;;;;}

		if ( relocIndex == pMod->header->nRelocs ) 
			BAIL(RM_ERROR,"NVRM: invalid relocIndex",DEBUGLEVEL_ERRORS);

		for ( j = 0; j < pMod->secTable[i].numRelocs; j++ ) {

			unsigned symIndex;

			// get the target address
			relocAddr = (unsigned) (pMod->secTable[i].memOffset + pMod->relocTable[relocIndex+j].address);
				
			symIndex = pMod->relocTable[relocIndex + j].symIndex;

			switch ( pMod->relocTable[relocIndex + j].type ) {
				// XXX Note: the (NvU32) casts after *Get*Offset aren't necessary
				// for x86.  I've added them for ia64 compilation checking, even though
				// we won't be running throught this code on that platform.
				case IMAGE_REL_I386_DIR32:
					*((NvU32*)relocAddr) = DldGetMemOffset(pMod,symIndex);
					break;

				case IMAGE_REL_I386_DIR32NB:
					*((NvU32*)relocAddr) = DldGetImageOffset(pMod,symIndex);
					break;

				case IMAGE_REL_I386_SECTION:
					*((NvU16*)relocAddr) = DldGetSymbolSection(pMod,symIndex);
					break;

				case IMAGE_REL_I386_SECREL:
					*((NvU32*)relocAddr) = 
						(NvU32) (DldGetMemOffset(pMod,symIndex) 
							 - DldGetSectionMemOffset(pMod, DldGetSymbolSection(pMod,symIndex)));
					break;

				case IMAGE_REL_I386_REL32:
					if ( pMod->secTable[i].type == NV_DLOAD_SECTION_TYPE_DATA ) 
						BAIL(RM_ERROR,"NVRM: unsupported relative data section reloc",DEBUGLEVEL_ERRORS);

					*((NvU32*)relocAddr) = (NvU32) ( DldGetMemOffset(pMod,symIndex) 
								 - (relocAddr + 4) ); // +4 since rel is from _next_ instr.
					break;

				    case IMAGE_REL_I386_ABSOLUTE:
				    case IMAGE_REL_I386_DIR16:
				    case IMAGE_REL_I386_REL16:
				    case IMAGE_REL_I386_SEG12:
				    default:
					    BAIL(RM_ERROR,"NVRM: unsupported reloc",DEBUGLEVEL_ERRORS);
			}
#ifdef NV_DBG_RELOC
			DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO," f ",(unsigned*)relocAddr);
			DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO,"  a",(unsigned*)*(unsigned*)relocAddr);
#endif
			
		}
	}

 cleanup:
	
	return ret;
	
}


#else
// Win64 
RM_STATUS setupMemOffsets(PDLD_MODULE pImg)
{
	return RM_ERROR;
}

RM_STATUS setupRelocations(PDLD_MODULE pImg)
{
	return RM_ERROR;
}


#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\os.c ===
//
// (C) Copyright NVIDIA Corporation Inc., 1996-2000. All rights reserved.
// (C) Copyright SGS-THOMSON Microelectronics Inc., 1996. All rights reserved.
//
/******************* Operating System Interface Routines *******************\
*                                                                           *
* Module: OS.C                                                              *
*   This is the OS interface module.  All operating system transactions     *
*   pass through these routines.  No other operating system specific code   *
*   or data should exist in the source.                                     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    09/07/93 - wrote it.                    *
*       Jeff Westerinen (jsw)       04/97 - modified for WinNT.             *
*                                                                           *
\***************************************************************************/

#include <ntddk.h>
#include <nvrm.h>
#include <os.h>
#include <nvos.h>
#include <nvhw.h>
#include <Nvcm.h>


// OS names
char nameVideoSink[]  = "CON:";
char nameImageVideo[] = "WND";
char nameSysMem[]     = "SYSMEM:";
char nameLVidMem[]    = "LOCALVIDMEM:";
char nameSVidMem[]    = "SYSVIDMEM:";

// registry names
char strDevNodeRM[]             = "\\Registry\\Machine\\SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\System";
char strTilingOverride[]        = "TilingOverride";
char strMemoryOverride[]        = "MemoryOverride";
char strRTLOverride[]           = "RTLOverride";
char strPBUSOverride[]          = "PBUSOverride";
char strUnderscanXOverride[]    = "UnderscanX";
char strUnderscanYOverride[]    = "UnderscanY";
//char strDevNodeDisplayNumber[]  = "\\Registry\\Machine\\SOFTWARE\\NVIDIA Corporation\\RIVA TNT\\Display\\DeviceX";
char strDevNodeDisplayNumber[]  = "\\Registry\\Machine\\SYSTEM\\CurrentControlSet\\Services\\nv4\\Device0";
char strNTSrvPackVersion[]      = "\\Registry\\Machine\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\";

// evil globals
KSEMAPHORE rmSemaphore, osSemaphore;
DISPLAYINFO osDisplayInfo;

// memory pools required so no memory is allocated during ISR
PDMALISTELEMENT_POOL_ELEMENT dmaListElementPool;

#if DBG

// memory allocation tracking data structs and globals
typedef struct _MEM_ALLOC_LOG_ENTRY
{
    U032 handle;
    VOID *address;
    U032 size;
    struct _MEM_ALLOC_LOG_ENTRY *next;
    struct _MEM_ALLOC_LOG_ENTRY *last;

} MEM_ALLOC_LOG_ENTRY;
MEM_ALLOC_LOG_ENTRY *memAllocLog = NULL;
MEM_ALLOC_LOG_ENTRY *memAllocLogTail = NULL;
U032 memAllocEntries = 0;
U032 memAllocTotal = 0;
U032 fourByteAllocs = 0;

// instance memory allocation tracking data structs and globals
typedef struct _INST_MEM_ALLOC_LOG_ENTRY
{
    U032 handle;
    U032 instance;
    U032 size;
    U032 alignment;
    struct _INST_MEM_ALLOC_LOG_ENTRY *next;
    struct _INST_MEM_ALLOC_LOG_ENTRY *last;

} INST_MEM_ALLOC_LOG_ENTRY;
INST_MEM_ALLOC_LOG_ENTRY *instMemAllocLog = NULL;
INST_MEM_ALLOC_LOG_ENTRY *instMemAllocLogTail = NULL;
U032 instMemAllocEntries = 0;
U032 instMemAllocTotal = 0;

U032 nvddHeapAllocationCount = 0;
U032 nvddHeapFreeCount = 0;

#endif // DBG    

//
// Some quick and dirty library functions.
// This is an OS function because some operating systems supply their
// own version of this function that they require you to use instead
// of the C library function.  And some OS code developers may decide to
// use the actual C library function instead of this code.  In this case,
// just replace the code within osStringCopy with a call to the C library
// function strcpy.
//
char *osStringCopy
(
    char *dst,
    const char *src
)
{
    char *dstptr = dst;

    while (*dstptr++ = *src++);
    return (dst);
}

S032 osStringCompare
(
    const char *s1,
    const char *s2
)
{
    return strcmp(s1, s2);
}

U032 osStringLength(const char * str)
{
    U032 i = 0;
    while (str[i++] != '\0');
    return i - 1;
}

unsigned char * osMemCopy(unsigned char * dst, const unsigned char * src, U032 length)
{
    U032 i;
    for (i = 0; i < length; i++)
    {
        dst[i] = src[i];
    }
    return dst;
}

//---------------------------------------------------------------------------
//
//  Operating System Memory functions.
//
//---------------------------------------------------------------------------

#ifndef VIDEO_PORT_IMPLEMENTATION
//#if (_WIN32_WINNT < 0x0500)

RM_STATUS  osCopyIn
(
	U008 *src, 
	U008 *target,
	U032 count
)
{
	osMemCopy(target, src, count);

	return(RM_OK);
}

RM_STATUS  osCopyOut
(
	U008 *src,
	U008 *target,
	U032 count
)
{
	osMemCopy(target, src, count);

	return(RM_OK);
}

RM_STATUS osAllocMem
(
    VOID **pAddress,
    U032   Size
)
{
    RM_STATUS status;
    U008     *pMem;
    U032      PageCount;

    status = RM_OK;
    
#if !DBG
    *pAddress = ExAllocatePoolWithTag(NonPagedPool, Size, NV_MEMORY_TAG);
    if (*pAddress != NULL)
    {
#else
    // allocate three extra dwords to hold the size and some debug tags
    Size += 3 * sizeof(U032);

    // round to the nearest dword size to prevent alignment fault on IA64
    Size = (Size + sizeof(U032) - 1) & ~(sizeof(U032) - 1);

    *pAddress = ExAllocatePoolWithTag(NonPagedPool, Size, NV_MEMORY_TAG);
    if (*pAddress != NULL)
    {
        // memory allocation tracking
        osLogMemAlloc(*pAddress, Size);

        // load the size into the first dword, the first tag into the second dword, 
        // and the second tag into the last, then adjust the address
        **(U032**)pAddress                                = Size;
        *(*(U032**)pAddress + 1)                          = NV_MARKER1;
        *(U032*)(*(U008**)pAddress + Size - sizeof(U032)) = NV_MARKER2;
        *(U032**)pAddress += 2;
        pMem = *(U008**)pAddress;
        Size -= 3 * sizeof(U032);
        while (Size--)
            *pMem++ = 0x69;
#endif // DBG
    }
    else
    {
        status = RM_ERR_NO_FREE_MEM;
    }
    return (status);
}
RM_STATUS osFreeMem
(
    VOID *pAddress
)
{
    RM_STATUS status;
    U032      Size;
    U032      PageCount;

#if DBG
    (U032*)pAddress -= 2;
    Size = *(U032*)pAddress;
    if (*((U032*)pAddress + 1) != NV_MARKER1)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Invalid address to osFreeMem\n");
        DBG_BREAKPOINT();
    }
    if (*(U032*)((U008*)pAddress + Size - sizeof(U032)) != NV_MARKER2)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Memory overrun in structure to osFreeMem\n");
        DBG_BREAKPOINT();
        return (RM_ERR_MEM_NOT_FREED);
    }
    *((U032*)pAddress + 1) = 'DAED';
    *(U032*)((U008*)pAddress + Size - sizeof(U032)) = 'DEAD';
    Size -= 3 * sizeof(U032);

    // memory allocation tracking
    osUnlogMemAlloc(pAddress);

#endif // DBG    
    ExFreePool(pAddress);

    status = RM_OK;
    return (status);
}

#endif // not Win2K

#if DBG

// add a memory allocation log entry
VOID osLogMemAlloc(VOID *address, U032 size)
{
    static U032 memAllocAttempts = 0;
    static U032 memAllocId = 0;

    MEM_ALLOC_LOG_ENTRY *newElement = ExAllocatePoolWithTag(NonPagedPool, sizeof(MEM_ALLOC_LOG_ENTRY), NV_MEMORY_TAG);
    if (newElement)
    {
        // stats
        memAllocEntries++;
        memAllocTotal += size;

        // find the magic 4-byte alloc
        if (size == 0x10)
        {
            fourByteAllocs++;
        }

        // add the new element to the head of the list
        newElement->handle = memAllocId++;
        newElement->address = address;
        newElement->size = size;
        newElement->next = memAllocLog;
        newElement->last = NULL;
        memAllocLog = newElement;

        // set the tail
        if (memAllocLogTail == NULL)
        {
            memAllocLogTail = newElement;
        }

        // fixup the back link of the next element
        if (newElement->next)
        {
            newElement->next->last = newElement;
        }
    }

    // more stats
    memAllocAttempts++;
}

// remove a memory allocation log entry
VOID osUnlogMemAlloc(VOID *address)
{
    static U032 memFreeAttempts = 0;
    MEM_ALLOC_LOG_ENTRY *element;

    for (element = memAllocLog; element; element = element->next)
    {
        if (element->address == address)
        {
            // stats
            memAllocEntries--;
            memAllocTotal -= element->size;

            // unlink the element from the list
            if (element->last)
            {
                element->last->next = element->next;
            }
            else
            {
                memAllocLog = element->next;
            }
            if (element->next)
            {
                element->next->last = element->last;
            }

            // adjust the tail
            if (element == memAllocLogTail)
            {
                memAllocLogTail = element->last;
            }

            // free the element
            ExFreePool(element);
            break;
        }
    }

    // more stats
    memFreeAttempts++;
}

// add a memory allocation log entry
VOID osLogInstMemAlloc(U032 instance, U032 size, U032 alignment)
{
    static U032 instMemAllocAttempts = 0;
    static U032 instMemAllocId = 0;

    INST_MEM_ALLOC_LOG_ENTRY *newElement = ExAllocatePoolWithTag(NonPagedPool, sizeof(INST_MEM_ALLOC_LOG_ENTRY), NV_MEMORY_TAG);
    if (newElement)
    {
        // stats
        instMemAllocEntries++;
        instMemAllocTotal += size;

        // add the new element to the head of the list
        newElement->handle = instMemAllocId++;
        newElement->instance = instance;
        newElement->size = size;
        newElement->alignment = alignment;
        newElement->next = instMemAllocLog;
        newElement->last = NULL;
        instMemAllocLog = newElement;

        // set the tail
        if (instMemAllocLogTail == NULL)
        {
            instMemAllocLogTail = newElement;
        }

        // fixup the back link of the next element
        if (newElement->next)
        {
            newElement->next->last = newElement;
        }
    }

    // more stats
    instMemAllocAttempts++;
}

// remove a memory allocation log entry
VOID osUnlogInstMemAlloc(U032 instance, U032 size)
{
    static U032 instMemFreeAttempts = 0;
    INST_MEM_ALLOC_LOG_ENTRY *element;

    for (element = instMemAllocLog; element; element = element->next)
    {
        if (element->instance == instance)
        {
            // stats
            instMemAllocEntries--;
            instMemAllocTotal -= size;

            // unlink the element from the list
            if (element->last)
            {
                element->last->next = element->next;
            }
            else
            {
                instMemAllocLog = element->next;
            }
            if (element->next)
            {
                element->next->last = element->last;
            }

            // adjust the tail
            if (element == instMemAllocLogTail)
            {
                instMemAllocLogTail = element->last;
            }

            // free the element
            ExFreePool(element);
            break;
        }
    }

    // more stats
    instMemFreeAttempts++;
}

#endif // DBG    

//
// osAllocPages - Allocate a number of aligned memory pages
//
//  **pAddress - handle to the linear address
//  PageCount  - number of pages to allocate
//  MemoryType - memory pool
//  Contiguous - contiguous pages?
//  Cache      - cacheing request
//
RM_STATUS osAllocPages
(
    PHWINFO pDev,
    VOID    **pAddress,
    U032    PageCount,
    U032    MemoryType,
    U032    Contiguous,
    U032    Cache,
    U032    ClientClass,
    VOID    **pMemData
)
{
    *pMemData = NULL;

    switch (MemoryType)
    {
        case NV_MEMORY_TYPE_AGP:
            return(osAllocAGPPages(pDev, pAddress, PageCount, ClientClass, pMemData));
            break;
        case NV_MEMORY_TYPE_SYSTEM:
            return(osAllocSystemPages(pDev, pAddress, PageCount, ClientClass, pMemData));
            break;
        default:
            return RM_ERROR;
    }
}

//
// osFreePages - Free a number of aligned memory pages
//
//  **pAddress - handle to the linear address
//  MemoryType - memory pool
//
RM_STATUS osFreePages
(
    PHWINFO pDev,
    VOID    **pAddress,
    U032    MemoryType,
    U032    PageCount,
    VOID    *pMemData,
    BOOL    IsWriteCombined          // all NT4 AGP allocs are write combined
)
{
    switch (MemoryType)
    {
        case NV_MEMORY_TYPE_AGP:
            return(osFreeAGPPages(pDev, pAddress, pMemData));
            break;
        case NV_MEMORY_TYPE_SYSTEM:
            return(osFreeSystemPages(pDev, pAddress, pMemData));
            break;
        default:
            return RM_ERROR;
    }
}

RM_STATUS osAllocDmaListElement
(
    PDMAUSEROBJECT *ppDmaListElement
)
{
    U032 i;

    // get the next available DMA list elementt
    for (i = 0; i < DMALISTELEMENT_POOL_SIZE; i++)
    {
        if (!dmaListElementPool[i].inUse)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Allocating DMA list element", i);
            dmaListElementPool[i].inUse = TRUE;
            *ppDmaListElement = &dmaListElementPool[i].dmaListElement;
            return RM_OK;
        }
    }

    return RM_ERROR;

} // end of osAllocDmaListElement()

RM_STATUS osFreeDmaListElement
(
    PDMAUSEROBJECT pDmaListElement
)
{
    U032 i;

    // return the DMA list element to the pool
    for (i = 0; i < DMALISTELEMENT_POOL_SIZE; i++)
    {
        if (pDmaListElement == &dmaListElementPool[i].dmaListElement)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Freeing DMA list element", i);
            dmaListElementPool[i].inUse = FALSE;
            return RM_OK;
        }
    }

    return RM_ERROR;

} // end of osFreeDmaListElement()

// video port service implementation
#ifndef VIDEO_PORT_IMPLEMENTATION
//#if (_WIN32_WINNT < 0x0500)

RM_STATUS osLockUserMem
(
    PHWINFO          pDev,
    U032             ChID,
    U032             Selector,
    VOID*            Offset,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE *DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    U032            *PageArray,
    VOID**           pLinAddr,
    VOID**           LockHandle
)
{
    NTSTATUS ntStatus;
    PMDL pMdl = 0;
    ULONG i;

    //
    // If we're asking to lock video memory, let's just build up the PTE's and assume
    // that the caller has real control over video memory (such as DirectDraw or the
    // display driver).
    //
    if (*DmaAddressSpace == ADDR_FBMEM)
    {

        *pLinAddr = Offset;   // 0-based selector!!

        //
        // For FB, the offset into the framebuffer has already been calculated by
        // osGetAddressInfo; don't assume 0, but use Offset as the first physaddr.
        //
        for (i = 0; i < PageCount; i++)
        {
            PageArray[i] = (U032)((NV_UINTPTR_T)Offset + (i * RM_PAGE_SIZE)) | 3;
        }
    }
    else if (*DmaAddressSpace == ADDR_AGPMEM)
    {
        // For AGP, load in the aperture address (we'll only need 1 pte loaded),
        // but since we've allocated PageCount worth, I guess we'll load it all

        for (i = 0; i < PageCount; i++)
        {
            PageArray[i] = (U032)((NV_UINTPTR_T)DmaAddress + (i * RM_PAGE_SIZE)) | 3;
        }
    }
    else
    {
        PHYSICAL_ADDRESS pagePhysicalAddr;
        U008* pageVirtualAddr;

        // lock the pages using an MDL created from the DMA buffer specs
        pMdl = IoAllocateMdl(
            DmaAddress,
            DmaLength,
            FALSE,
            FALSE,
            NULL
        );
        if (pMdl == NULL)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Cannot allocate MDL\n");
            return RM_ERR_NO_FREE_MEM;
        }
        try
        {
            // the only way to know if locking fails is via an exception
            MmProbeAndLockPages(
                pMdl,
                KernelMode,
                IoModifyAccess
            );
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            ntStatus = GetExceptionCode();
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: MmProbeAndLockPages FAILED!\n");
            IoFreeMdl(pMdl);
            return RM_ERR_PAGE_TABLE_NOT_AVAIL;
        }

        // save the MDL pointer
        *LockHandle = pMdl;

        // map the buffer
#if (_WIN32_WINNT < 0x0500)
        *pLinAddr = MmGetSystemAddressForMdl(pMdl);
#else
        *pLinAddr = MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);
#endif // (_WIN32_WINNT < 0x0500)
        if (*pLinAddr == NULL)
        {
            MmUnlockPages(pMdl);
            IoFreeMdl(pMdl);
            return RM_ERROR;
        }


        // load the PTE array with physical addresses of the page-aligned buffer
        // note: if memory refered by DmaAddress was paged out (therefore being
        //       invalid) at the time of the lock down call, it might be still
        //       invalid. Therefore MmGetPhysicalAddress(DmaAddress) returns NULL.
        //       (seen on a SMP system / low memory condition)
        //       The recently mapped pLinAddr alias is accessible though.
        pageVirtualAddr = (U008*)((NV_UINTPTR_T)(*pLinAddr) & ~RM_PAGE_MASK);

        for (i = 0; i < PageCount; i++)
        {
            pagePhysicalAddr = MmGetPhysicalAddress(pageVirtualAddr);
            if (pagePhysicalAddr.LowPart == 0)
            {
                MmUnmapLockedPages(*pLinAddr, pMdl);
                MmUnlockPages(pMdl);
                IoFreeMdl(pMdl);
                return RM_ERR_NO_FREE_MEM;
            }
            PageArray[i] = pagePhysicalAddr.LowPart | 3;
            pageVirtualAddr += RM_PAGE_SIZE;
        }
    }

    return (RM_OK);
}
RM_STATUS osUnlockUserMem
(
    PHWINFO          pDev,
    U032             ChID,
    VOID*            LinAddr,
    VOID*            DmaAddress,
    NV_ADDRESS_SPACE DmaAddressSpace,
    U032             DmaLength,
    U032             PageCount,
    VOID*            LockHandle,
    U032             DirtyFlag
)
{
    RM_STATUS status = RM_OK;
    PMDL pMdl = (PMDL)LockHandle;

    //
    // If we're asking to unlock video memory, we're assuming the caller (probably
    // direct draw)  has complete control of video memory, and therefore knows what
    // is locked/unlocked.  No need to do anything.
    //
    if ((DmaAddressSpace != ADDR_FBMEM) && (DmaAddressSpace != ADDR_AGPMEM))
    {
        // otherwise, unmap locked pages, unlock pages, and free the MDL
        MmUnmapLockedPages((VOID*)LinAddr, pMdl);
        MmUnlockPages(pMdl);
        IoFreeMdl(pMdl);
    }
    return (status);
}

//#endif // (_WIN32_WINNT < 0x0500)
#endif // VIDEO_PORT_IMPLEMENTATION

RM_STATUS osMapFifo
(
    PHWINFO pDev,
    U032 clientClass,
    U032 ChannelID,
    VOID** pAddress
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            *pAddress = (VOID*)((U008*)nvAddr + FIFO_USER_BASE(pDev) + (ChannelID << 16));
            break;

        case NV01_ROOT_USER:
            rmStatus = osMapPciMemoryUser(
                pDev,
                pDev->Mapping.PhysAddr + FIFO_USER_BASE(pDev) + (ChannelID << 16),
                CHANNEL_LENGTH,
                pAddress
            );
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    return rmStatus;
}

RM_STATUS osMapInstanceMemory
(
    PHWINFO pDev,
    U032 clientClass,
    U032 instanceOffset,
    U032 length,
    VOID** pAddress
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            *pAddress = INSTANCE_MEMORY_LOGICAL_BASE(pDev) + instanceOffset;
            break;

        case NV01_ROOT_USER:
            rmStatus = osMapPciMemoryUser(
                pDev,
                INSTANCE_MEMORY_PHYSICAL_BASE(pDev) + instanceOffset,
                length,
                pAddress
            );
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    return rmStatus;
}

RM_STATUS osMapFrameBuffer
(
    PHWINFO pDev,
    U032 clientClass,
    U032 fbOffset,
    U032 length,
    VOID** pAddress
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            *pAddress = (U008*)fbAddr + fbOffset;
            break;

        case NV01_ROOT_USER:
            rmStatus = osMapPciMemoryUser(
                pDev,
                pDev->Mapping.PhysFbAddr + fbOffset,
                length,
                pAddress
            );
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    return rmStatus;
}

// This procedure undoes the work of osMapFifo, osMapFrameBuffer and osMapInstanceMemory
RM_STATUS osUnmapMemory
(
    PHWINFO pDev,
    U032    clientClass,
    VOID*   address,
    U032    length
)
{
    RM_STATUS rmStatus = RM_OK;

    switch (clientClass)
    {
        case NV01_ROOT:
            break;

        case NV01_ROOT_USER:
            rmStatus = osUnmapPciMemoryUser(pDev, address);
            break;

        default:
            rmStatus = RM_ERR_OPERATING_SYSTEM;
    }

    return rmStatus;
}

RM_STATUS osSetFifoDmaParams
(
    PHWINFO pDev,
    U032   *pFetchTrigger,
    U032   *pFetchSize,
    U032   *pFetchRequests
)
{

    //
    // Default NT DMA channel fetch parameters
    // (optimized for NT display driver).
    //
    *pFetchTrigger = 128;           // 128 bytes
    *pFetchSize = 128;              // 128 bytes
    *pFetchRequests = 8;            // 8 outstanding read requests

    return RM_OK;
}

RM_STATUS osDeviceNameToDeviceClass(char *osName, U032 *pDevClass)
{
    // TO DO: add a validate pointer OS service
    // validate OS name parameter
    try
    {
        U008 testData = *(U008*)osName;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        NTSTATUS ntStatus = GetExceptionCode();
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: invalid OS name\n");
        return RM_ERROR;
    }

    switch (*pDevClass)
    {
        // explicit device classes need no processing
        case NV01_DEVICE_0:
        case NV01_DEVICE_1:
        case NV01_DEVICE_2:
        case NV01_DEVICE_3:
        case NV01_DEVICE_4:
        case NV01_DEVICE_5:
        case NV01_DEVICE_6:
        case NV01_DEVICE_7:
            break;

        // derive the device class from the OS name, for NT, the device reference
        case NV03_DEVICE_XX:
            switch (*(U032*)osName)
            {
                case 0:
                    *pDevClass = NV01_DEVICE_0;
                    break;

                case 1:
                    *pDevClass = NV01_DEVICE_1;
                    break;

                case 2:
                    *pDevClass = NV01_DEVICE_2;
                    break;

                case 3:
                    *pDevClass = NV01_DEVICE_3;
                    break;

                case 4:
                    *pDevClass = NV01_DEVICE_4;
                    break;

                case 5:
                    *pDevClass = NV01_DEVICE_5;
                    break;

                case 6:
                    *pDevClass = NV01_DEVICE_6;
                    break;

                case 7:
                    *pDevClass = NV01_DEVICE_7;
                    break;

                // invalid escape value
                default:
                    return RM_ERROR;
            }
            break;

        // invalid class
        default:
            return RM_ERROR;

    }

    return RM_OK;

}

//---------------------------------------------------------------------------
//
//  OS specific time of day.
//
//---------------------------------------------------------------------------

/*****************************************************************************
*
*   Name: osGetCurrentTime
*
*   Description:
*       This functions returns the number of nano seconds that have ellapsed
*   since January 1 at midnight, GMT, of the given base year.  The base year
*   is passed in year, and the elapsed time is returned in nSecElapsed.  The
*   rest of the parameters are filled with the current date and time.
*
*****************************************************************************/

RM_STATUS osGetCurrentTime
(
    U032 *year,
    U032 *month,
    U032 *day,
    U032 *hour,
    U032 *min,
    U032 *sec,
    U032 *msec
)
{
    TIME_FIELDS currentTime;
    LARGE_INTEGER timeIn100ns;

    // get the current elapsed time
    KeQuerySystemTime(&timeIn100ns);

    // set the current time fields
    RtlTimeToTimeFields(&timeIn100ns, &currentTime);
    *year   = currentTime.Year;
    *month  = currentTime.Month;
    *day    = currentTime.Day;
    *hour   = currentTime.Hour;
    *min    = currentTime.Minute;
    *sec    = currentTime.Second;
    *msec   = currentTime.Milliseconds;

    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Misc services.
//
//---------------------------------------------------------------------------


// Pre and Post modeset stuff, from the 9x stuff
// Os Specifix pre mode set actions.
VOID osPreModeSetEx(PHWINFO pDev, U032 Head)
{

    // Nothing to do here any more...all TV stuff is in the main
    // modeset path in dac/dacmode.c:dacSetModeMulti().

} // end of osPreModeSetEx()

// Os Specific post mode set actions.
VOID osPostModeSetEx(PHWINFO pDev, U032 Head)
{
    RM_STATUS status;
    U032      data32;

    // See if there are any registry overrides for the desktop positioning.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR) {
        U032 cbLen;
        NV_CFGEX_SET_DESKTOP_POSITION_MONITOR_PARAMS position;

        cbLen = 4 * sizeof(U032);
        status = dacReadDesktopPositionFromRegistry(pDev, Head,
                                                    TRUE,  // isMonitor
                                                    (U008 *) &(position.HRetraceStart),
                                                    &cbLen);
        if (status == RM_OK) {
            // Program the new values.
            dacSetMonitorPosition(pDev, Head,
                                  position.HRetraceStart, position.HRetraceEnd,
                                  position.VRetraceStart, position.VRetraceEnd);
        }
    }

    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
        dacSetBiosDefaultTVType(pDev, pDev->Dac.TVStandard);

    // See if there are any registry overrides for the monitor timing.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR)
    {
        NV_CFGEX_CRTC_TIMING_PARAMS timings;

        //
        // First check if there are timings available in the registry for this mode
        //
        timings.Head = Head;
        timings.Reg = NV_CFGEX_CRTC_TIMING_REGISTRY;
        status = dacGetCRTCTiming(pDev, Head, &timings);

        if (status == RM_OK)
        {
            //
            // Program the new values
            //
            timings.Reg = NV_CFGEX_CRTC_TIMING_REGISTER;
            status = dacSetCRTCTiming(pDev, Head, &timings);
        }

    }

    // See if there are any registry overrides for the TV desktop positioning.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV) {

       U032 cbLen;
       NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS Params;
 
       // Read the registry to get any updates to the default setting.
       // This should be done after dacAdjustCRTCForTV because it involves changes to CRTC.
       cbLen = sizeof(NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS);
       status = dacReadTVDesktopPositionFromRegistry(pDev, Head, (U008 *) &Params, &cbLen);
   
       // Make sure data is valid for the current encoder.
       if((status == RM_OK) && (Params.Encoder_ID == pDev->Dac.EncoderType)) {
           // Write the saved settings
           dacSetTVPosition(pDev, Head, (U032 *) &Params);
       }
       if (!pDev->Power.MobileOperation)
       {
           dacWriteTVStandardToRegistry(pDev, pDev->Dac.TVStandard);   // save TV standard in registry
       }
    }
    
    // Check/Set any PFB overrides
    if (osReadRegistryDword(pDev, strDevNodeRM, strMemoryOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_MEMORY, data32);
    }
    if (osReadRegistryDword(pDev, strDevNodeRM, strRTLOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_RTL, data32);
    }
    
} // end of osPostModeSetEx()





//
// First pass at implementing registry string read.
// Converts the UNICODE string from registry into a POS (plain old string)
// of max length '*cbLen' and returns it in buffer pointed to by '*Data'
//
// Currently just used by RM_FAILURE mechanism in rmfailure.c
//
// Note:
//    has a lot in common w/ osReadRegistryDword
//       could be commoned once it works :-)
//    missing pDev arg of osReadRegistryDword()
//    can not be called from RmInitRm(); it is apparently too early
//        if you do, will just return STATUS_NOT_FOUND
//
RM_STATUS osReadRegistryString
(
    char *regDevNode,
    char *regParmStr,
    char *Data,
    U032 *cbLen
)
{
    NTSTATUS ntStatus;
    RM_STATUS rmStatus;
    RTL_QUERY_REGISTRY_TABLE query[2];
    STRING sRegDevNode, sRegParmStr;
    UNICODE_STRING usRegDevNode, usRegParmStr;
    WCHAR buffer1[] = L"                                                                                ";
    WCHAR buffer2[] = L"                                                                                ";
    UNICODE_STRING dest_unicode_string;
    ANSI_STRING dest_ansi_string;

    // convert the parameters into unicode strings
    RtlInitAnsiString(&sRegDevNode, regDevNode);
    RtlInitUnicodeString(&usRegDevNode, buffer1);
    RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
    RtlInitAnsiString(&sRegParmStr, regParmStr);
    RtlInitUnicodeString(&usRegParmStr, buffer2);
    RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

    // create a trivial registry-query table (1 query + NULL terminator query)
    RtlZeroMemory(query, sizeof(query));
    query[0].Name = usRegParmStr.Buffer;
    query[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    query[0].DefaultType = REG_SZ;

    dest_unicode_string.Length = 0;
    dest_unicode_string.MaximumLength = (short) *cbLen;
    dest_unicode_string.Buffer = ExAllocatePoolWithTag(
                                        PagedPool,
                                        dest_unicode_string.MaximumLength, 
                                        NV_MEMORY_TAG
                                        );
    
    if (!dest_unicode_string.Buffer) 
    {
        return RM_ERROR;
    }

    query[0].DefaultData = dest_unicode_string.Buffer;
    query[0].DefaultLength = 0;
    query[0].EntryContext = &dest_unicode_string;

    // query the registry
    ntStatus = RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE,
        usRegDevNode.Buffer,
        query,
        NULL,
        NULL	// environment unused
    );

    if((NT_SUCCESS(ntStatus)) && (dest_unicode_string.Length != 0))
    {
        dest_ansi_string.Length = 0;
        dest_ansi_string.MaximumLength = (unsigned short) *cbLen;
        // convert it into caller's buffer
        dest_ansi_string.Buffer = Data;
        RtlUnicodeStringToAnsiString(&dest_ansi_string,
                                 &dest_unicode_string,
                                 0 /* don't allocate dest */);
        ExFreePool(dest_unicode_string.Buffer);

        *cbLen = dest_ansi_string.Length;

        return RM_OK;
    }
    else
    {
        ExFreePool(dest_unicode_string.Buffer);
        return RM_ERROR;
    }

}


#if (_WIN32_WINNT < 0x0500)

RM_STATUS osDelayUs
(
    U032 MicroSeconds
    )
{
    // convert uSec to a relative (negative) interval of 100's of nSecs
    LARGE_INTEGER hundredsOfNanoSeconds = RtlConvertLongToLargeInteger(MicroSeconds * -10);

    // suspend for given relative time interval
    NTSTATUS ntStatus = KeDelayExecutionThread(
        KernelMode,
        FALSE,
        &hundredsOfNanoSeconds
    );

    return (NT_SUCCESS(ntStatus)) ? RM_OK : RM_ERROR;
}


#ifdef NOT_USING_VIDEOPORT_REGISTRY_CALLS

RM_STATUS osWriteRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 cbLen
)
{

	NTSTATUS ntStatus;
	RM_STATUS rmStatus;
	STRING sRegDevNode, sRegParmStr;
	UNICODE_STRING usRegDevNode, usRegParmStr;
	WCHAR buffer1[] = L"                                                                                ";
	WCHAR buffer2[] = L"                                                                                ";


	// convert the parameters into unicode strings
	RtlInitAnsiString(&sRegDevNode, regDevNode);
	RtlInitUnicodeString(&usRegDevNode, buffer1);
	RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
	RtlInitAnsiString(&sRegParmStr, regParmStr);
	RtlInitUnicodeString(&usRegParmStr, buffer2);
	RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

	// Write the registry value 
	ntStatus = RtlWriteRegistryValue(
		RTL_REGISTRY_ABSOLUTE,
		usRegDevNode.Buffer,
		usRegParmStr.Buffer,
		REG_BINARY,
		Data,
		cbLen
	);
    if (!NT_SUCCESS(ntStatus))
    	return RM_ERROR;

	return RM_OK;

}

//
// First pass at implementing registry binary read.
// Returns binary data
// of max length '*cbLen' and returns it in buffer pointed to by '*Data'
//
// 'Data' buffer must be 8 bytes longer than your real data as it is coerced
//     into a data structure used by registry.
//
// The union of a binary registry data record, that contains the size and type
// along with the data, and a pure UCHAR buffer is used here.
//
// Note:
//    has a lot in common w/ osReadRegistryDword
//       could be commoned once it works :-)
//    missing pDev arg of osReadRegistryDword()
//    can not be called from RmInitRm(); it is apparently too early
//        if you do, will just return STATUS_NOT_FOUND
//

RM_STATUS osReadRegistryBinary
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U008 *Data,
    U032 *cbLen
)
{

    NTSTATUS ntStatus;
    RM_STATUS rmStatus;
    RTL_QUERY_REGISTRY_TABLE query[2];
    STRING sRegDevNode, sRegParmStr;
    UNICODE_STRING usRegDevNode, usRegParmStr;
    WCHAR buffer1[] = L"                                                                                ";
    WCHAR buffer2[] = L"                                                                                ";
    RM_REG_BINARY_BUFFER localbuf;

    // is the buffer big enough to hold the data and the length/type fields?
    // TO DO: Is there a way so send a more helpful error code?
    if (*cbLen + 8 > sizeof(RM_REG_BINARY_BUFFER))
    {
        return RM_ERROR;
    }

    // convert the parameters into unicode strings
    RtlInitAnsiString(&sRegDevNode, regDevNode);
    RtlInitUnicodeString(&usRegDevNode, buffer1);
    RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
    RtlInitAnsiString(&sRegParmStr, regParmStr);
    RtlInitUnicodeString(&usRegParmStr, buffer2);
    RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

    // create a trivial, no callback, registry-query table (1 query + NULL terminator query)
    RtlZeroMemory(query, sizeof(query));
    query[0].Name = usRegParmStr.Buffer;
    query[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    query[0].EntryContext = localbuf.buffer;
    query[0].DefaultType = REG_NONE;
    query[0].DefaultData = localbuf.buffer;
    query[0].DefaultLength = sizeof(localbuf.buffer) - 8;   // Minus the size of the header that is prepended
    
    
    // - Prep the query
    // Zero the local buffer in case the return size is less than the expected size, as someone might get back
    // less than they expected, and at this point, we return them the size that they expected
    RtlZeroMemory(localbuf.buffer, sizeof(localbuf.buffer));
    localbuf.record.Length = sizeof(localbuf.buffer) - 8;   // Minus the size of the header that is prepended
    localbuf.record.type = REG_NONE;

    // query the registry
    ntStatus = RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE,
        usRegDevNode.Buffer,
        query,
        NULL,
        NULL
    );
    if (!NT_SUCCESS(ntStatus)) {

        return RM_ERROR;
    }

    // Make sure that NT got the value type right...
    if( localbuf.record.type != REG_BINARY) {

       return RM_ERROR;
    }

	 // shift data out to Data using a copy that works on overlapping buffers
    // For some reason, the length value handed back from Win2K is incorrect, but correct under WinNT4, so use the users size
    RtlMoveMemory(Data, localbuf.record.buffer, *cbLen);

    return RM_OK;

}

RM_STATUS osWriteRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 Data
)
{

	NTSTATUS ntStatus;
	RM_STATUS rmStatus;
	STRING sRegDevNode, sRegParmStr;
	UNICODE_STRING usRegDevNode, usRegParmStr;
	WCHAR buffer1[] = L"                                                                                ";
	WCHAR buffer2[] = L"                                                                                ";


	// convert the parameters into unicode strings
	RtlInitAnsiString(&sRegDevNode, regDevNode);
	RtlInitUnicodeString(&usRegDevNode, buffer1);
	RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
	RtlInitAnsiString(&sRegParmStr, regParmStr);
	RtlInitUnicodeString(&usRegParmStr, buffer2);
	RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

	// Write the registry value 
	ntStatus = RtlWriteRegistryValue(
		RTL_REGISTRY_ABSOLUTE,
		usRegDevNode.Buffer,
		usRegParmStr.Buffer,
		REG_DWORD,
		&Data,
		sizeof(U032)
	);
    if (!NT_SUCCESS(ntStatus))
    	return RM_ERROR;

	return RM_OK;

}

RM_STATUS osReadRegistryDword
(
    PHWINFO pDev,
    char *regDevNode,
    char *regParmStr,
    U032 *Data
)
{

    NTSTATUS ntStatus;
    RM_STATUS rmStatus;
    RTL_QUERY_REGISTRY_TABLE query[2];
    STRING sRegDevNode, sRegParmStr;
    UNICODE_STRING usRegDevNode, usRegParmStr;
    WCHAR buffer1[] = L"                                                                                ";
    WCHAR buffer2[] = L"                                                                                ";
    U032 errorData = 0x69696969;

    // init Data to a known-bad value
    *Data = errorData;

    // convert the parameters into unicode strings
    RtlInitAnsiString(&sRegDevNode, regDevNode);
    RtlInitUnicodeString(&usRegDevNode, buffer1);
    RtlAnsiStringToUnicodeString(&usRegDevNode, &sRegDevNode, FALSE);
    RtlInitAnsiString(&sRegParmStr, regParmStr);
    RtlInitUnicodeString(&usRegParmStr, buffer2);
    RtlAnsiStringToUnicodeString(&usRegParmStr, &sRegParmStr, FALSE);

    // create a trivial registry-query table (1 query + NULL terminator query)
    RtlZeroMemory(query, sizeof(query));
    query[0].Name = usRegParmStr.Buffer;
    query[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    query[0].DefaultType = REG_DWORD;
    query[0].EntryContext = Data;

    // query the registry
    ntStatus = RtlQueryRegistryValues(
        RTL_REGISTRY_ABSOLUTE,
        usRegDevNode.Buffer,
        query,
        NULL,
        NULL
    );
    if (!NT_SUCCESS(ntStatus))
        return RM_ERROR;

    return (*Data != errorData) ? RM_OK : RM_ERROR;

}

#endif // NOT_USING_VIDEOPORT_REGISTRY_CALLS

RM_STATUS osIsr
(
    PHWINFO pDev
)
{
    BOOL serviced = FALSE;
    
    if (RmInterruptPending(pDev, &serviced))
    {
        // service any remaining interrupt and reenable ints
        //DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: Servicing non-VBLANK interrupt...\n");
        mcService(pDev);
        RmEnableInterrupts(pDev);
        serviced = TRUE;
    }
    
    return (serviced) ? RM_OK : RM_ERROR;

} // end of osIsr()

#endif // (_WIN32_WINNT < 0x0500)


RM_STATUS
osMemSet(VOID *addr, U032 fill, U032 bytes)
{
    memset(addr, fill, bytes);
    return RM_OK;
}

// Win2K processor synchronization
#if (_WIN32_WINNT >= 0x0500)

RM_STATUS osInitSpinLock
(
    PHWINFO pDev
)
{
	PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    RM_STATUS rmStatus = RM_OK;
    
    rmStatus = osAllocMem(&pOsHwInfo->pRmSpinLock, sizeof(KSPIN_LOCK));
    if (rmStatus == RM_OK)
    {
        KeInitializeSpinLock((PKSPIN_LOCK)(pOsHwInfo->pRmSpinLock));
    }
    
    return rmStatus;
    
} // end of osInitSpinLock()
    
RM_STATUS osEnterCriticalCode
(
    PHWINFO pDev 
)
{
	PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    KeAcquireSpinLock
    (
        (PKSPIN_LOCK)(pOsHwInfo->pRmSpinLock),
        (PKIRQL)&pOsHwInfo->oldIrql
    );
    return RM_OK;
    
} // end of osAcquireSpinLock()

RM_STATUS osExitCriticalCode
(
    PHWINFO pDev
)
{
	PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    KeReleaseSpinLock
    (
        (PKSPIN_LOCK)(pOsHwInfo->pRmSpinLock),
        (KIRQL)pOsHwInfo->oldIrql
    );
    return RM_OK;
    
} // end of osReleaseSpinLock()

#endif // (_WIN32_WINNT >= 0x0500)

#define rdtsc __asm _emit 0x0f __asm _emit 0x31 

// Return frequency value in MHz
U032 osGetCpuFrequency()
{
    U032 t1, t2;
    U032 tsc1, tsc2;

// TO DO: what to do about inline asm for IA-64?       
#ifndef IA64
    // read the tsc
    _asm {
        push    eax
        push    edx
        rdtsc
        mov     DWORD PTR [tsc1], eax
        pop     edx
        pop     eax
    }

    osDelay(100);

    // read the tsc again
    _asm {
        push    eax
        push    edx
        rdtsc
        mov     DWORD PTR [tsc2], eax
        pop     edx
        push    eax
    }
#else     
tsc1 = 0;
tsc2 = 0;
#endif // IA-64 cannot tolerate inline asm

    // multiply returned value by 10 since we timed 1/10th second
    // and divide the result to convert from Hz to MHz
    return (U032) ((tsc2-tsc1) * 10) / (1000000);
}

#define NT_HANDLE_PCI_DEVICE_SHIFT     8
#define NT_HANDLE_PCI_FUNC_SHIFT      16

//
//  PCI config space read/write routines.
//
U032
osPciReadDword(VOID *handle, U032 offset)
{
    U032 bus;
    U032 retval;
    U032 ihandle;
    PCI_SLOT_NUMBER slot;

    ihandle = (U032)((NV_UINTPTR_T)handle);

    bus  = ihandle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (ihandle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (ihandle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &retval,              // buffer
                          offset,               // config space offset
                          sizeof(retval));
    return retval;
}

U016
osPciReadWord(VOID *handle, U032 offset)
{
    U032 bus;
    U016 retval;
    U032 ihandle;
    PCI_SLOT_NUMBER slot;

    ihandle = (U032)((NV_UINTPTR_T)handle);

    bus  = ihandle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (ihandle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (ihandle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &retval,              // buffer
                          offset,               // config space offset
                          sizeof(retval));
    return retval;
}

U008
osPciReadByte(VOID *handle, U032 offset)
{
    U032 bus;
    U008 retval;
    U032 ihandle;
    PCI_SLOT_NUMBER slot;

    ihandle = (U032)((NV_UINTPTR_T)handle);

    bus  = ihandle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (ihandle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (ihandle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &retval,              // buffer
                          offset,               // config space offset
                          sizeof(retval));
    return retval;
}

VOID
osPciWriteDword(VOID *handle, U032 offset, U032 value)
{
    U032 bus;
    U032 ihandle;
    PCI_SLOT_NUMBER slot;

    ihandle = (U032)((NV_UINTPTR_T)handle);

    bus  = ihandle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (ihandle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (ihandle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalSetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &value,               // buffer
                          offset,               // config space offset
                          sizeof(value));
}

VOID
osPciWriteWord(VOID *handle, U032 offset, U016 value)
{
    U032 bus;
    U032 ihandle;
    PCI_SLOT_NUMBER slot;

    ihandle = (U032)((NV_UINTPTR_T)handle);

    bus  = ihandle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (ihandle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (ihandle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalSetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &value,               // buffer
                          offset,               // config space offset
                          sizeof(value));
}

VOID
osPciWriteByte(VOID *handle, U032 offset, U008 value)
{
    U032 bus;
    U032 ihandle;
    PCI_SLOT_NUMBER slot;

    ihandle = (U032)((NV_UINTPTR_T)handle);

    bus  = ihandle & 0xFF;
    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = (ihandle >> NT_HANDLE_PCI_DEVICE_SHIFT) & 0xFF;
    slot.u.bits.FunctionNumber = (ihandle >> NT_HANDLE_PCI_FUNC_SHIFT) & 0xFF;

    HalSetBusDataByOffset(PCIConfiguration,     // bus data type
                          bus,                  // bus number
                          slot.u.AsULONG,       // slot number
                          &value,               // buffer
                          offset,               // config space offset
                          sizeof(value));
}

VOID *
osPciInitHandle(U008 bus, U008 device, U008 func, U016 *pVendorId, U016 *pDeviceId)
{
    U032 ihandle, vendevID, status;
    PCI_SLOT_NUMBER slot;

    slot.u.AsULONG = 0x0;    // make sure all fields are initialized
    slot.u.bits.DeviceNumber   = device;
    slot.u.bits.FunctionNumber = func;

    // get vendor/device id at offset 0
    status = HalGetBusDataByOffset(PCIConfiguration,     // bus data type
                                   bus,                  // bus number
                                   slot.u.AsULONG,       // slot number
                                   &vendevID,            // buffer
                                   0x0,                  // config space offset
                                   sizeof(vendevID));
    if (status == 0 || status == 2)
        return 0;

    // return these to the caller
    if (pVendorId)
        *pVendorId = (U016)(vendevID & 0xFFFF);
    if (pDeviceId)
        *pDeviceId = (U016)(vendevID >> 16);

    // return a non-zero handle out of bus/device/func
    ihandle = 0xFF000000 |
             (func << NT_HANDLE_PCI_FUNC_SHIFT) |
             (device << NT_HANDLE_PCI_DEVICE_SHIFT) | bus;
    return (VOID *)((NV_UINTPTR_T)ihandle);
}

RM_STATUS
osUpdateAGPLimit(PHWINFO pDev)
{
    // In winnt4/win2k, the AGP limit is always known
    return RM_OK;
}

RM_STATUS osBeginWatchCanvas
(
    U032 hwnd
)
{
    return RM_OK;
}

RM_STATUS osEndWatchCanvas
(
    U032 hwnd
)
{
    return RM_OK;
}

RM_STATUS osGetCurrentProcess(
    U032 *pPid
)
{
    // TO DO:  what are the semantics of this??
    *pPid = 0;
    return RM_OK;
}

// Validate the DMA address space name from the app
// A DMA object with no name is treated as System Memory space
// The DMA direction does not matter for system memory space
RM_STATUS osValidateDMAObject(
    char *OsName,
    U032 DmaObjectName,
    NV_ADDRESS_SPACE *AddressSpace
)
{
    U032 i;
    RM_STATUS status;

    if (OsName[0] == '\0')
    {
        *AddressSpace = ADDR_SYSMEM;
        return(RM_OK);
    }

    if (strcmp(OsName, nameSysMem) == 0)
    {
       *AddressSpace = ADDR_SYSMEM;
       return(RM_OK);
    }

    if (strcmp(OsName, nameLVidMem) == 0)
    {
       *AddressSpace = ADDR_FBMEM;
       return(RM_OK);
    }

    if (strcmp(OsName, nameSVidMem) == 0)
    {
       *AddressSpace = ADDR_AGPMEM;
       return(RM_OK);
    }

    *AddressSpace = ADDR_SYSMEM;

    return(RM_ERR_INVALID_OS_NAME);

}

RM_STATUS osValidateVideoSink
(
    char *OsName
)
{
    U032 i;

    for (i = 0; i < 4; i++)
        if (OsName[i] != nameVideoSink[i])
            return (RM_ERR_INVALID_OS_NAME);
    return (RM_OK);
}

RM_STATUS osValidateImageVideo
(
    char *OsName,
    U032 *CanvasID
)
{
    U032 i;

    *CanvasID = 0;
    for (i = 0; i < 3; i++)
        if (*OsName++ != nameImageVideo[i])
            return (RM_ERR_INVALID_OS_NAME);
    while (*OsName >= '0' && *OsName <= '9')
        *CanvasID = *CanvasID * 10 + *OsName++ - '0';
    return (*OsName == ':' ? RM_OK : RM_ERROR);
}

// these must be shared by the miniport and RM

RM_STATUS osNotifyAction
(
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Status,
    U032      Action
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: osNotifyAction() stub\n");
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVGFX:   Object =", Object);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Method =", Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Data   =", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Status =", Status);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Action =", Action);

    return RM_OK;
}

RM_STATUS osError
(
    POBJECT   Object,
    U032      Method,
    V032      Data,
    RM_STATUS Error
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: osError()\n");
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVGFX:   Object =", Object);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Method =", Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Data   =", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Error  =", Error);

    return (RM_OK);
}

VOID osStateFbEx
(
    PHWINFO pDev
)
{
    U032    filterLevel;

    // check for an override value -- legal values are 0 (off), 1, or 2
    if (osReadRegistryDword(pDev, strDevNodeRM, "FilterOverride", &filterLevel) == RM_OK)
    {
        //if (pDev->Framebuffer.MonitorType != NV_MONITOR_VGA)
        {
            //pDev->Framebuffer.FilterEnable = 2;
            pDev->Framebuffer.FilterEnable = filterLevel;
        }
    }
    else
    {
        // only enable flicker filter for TV w/bit depth > 8BPP
        if (GETMONITORTYPE(pDev, 0) != NV_MONITOR_VGA)
        {
            if (pDev->Dac.HalInfo.Depth > 8)
            {
                pDev->Framebuffer.FilterEnable = 2;
            }
            else
            {
                pDev->Framebuffer.FilterEnable = 0;
            }
        }
        else
        {
            pDev->Framebuffer.FilterEnable = 0;
        }
    }

} // end of osStateFbEx()

RM_STATUS osSetVideoMode
(
    PHWINFO pDev
)
{
    U032 data32;

    if (osReadRegistryDword(pDev, strDevNodeRM, strMemoryOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_MEMORY, data32);
    }
    if (osReadRegistryDword(pDev, strDevNodeRM, strRTLOverride, &data32) == RM_OK)
    {
        nvHalFbLoadOverride(pDev, FB_LOAD_OVERRIDE_MEMORY, data32);
    }

    return RM_OK;

} // end of osSetVideoMode()

#ifndef WIN2K_DDK_THAT_CONTAINS_APIS
//#if (_WIN32_WINNT < 0x0500)

RM_STATUS osNotifyEvent
(
    PHWINFO   pDev,
    POBJECT   Object,
    U032      Notifier,
    U032      Method,
    U032      Data,
    RM_STATUS Status,
    U032      Action
)
{
    RM_STATUS rmStatus = RM_OK;
    U032 i, j;
    PEVENTNOTIFICATION NotifyEvent;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVGFX: osNotifyEvent()\n");
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVGFX:   Object =", Object);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Method =", Method);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Data   =", Data);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Status =", Status);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVGFX:   Action =", Action);

    // perform the type of action
    switch (Action)
    {
        case NV_OS_WRITE_THEN_AWAKEN:

            // walk this object's event list and find any matches for this specific notify
            for (NotifyEvent = Object->NotifyEvent; NotifyEvent; NotifyEvent = NotifyEvent->Next)
            {
                if (NotifyEvent->NotifyIndex == Notifier)
                {
                    // found a match -- notify the event
                    switch (NotifyEvent->NotifyType)
                    {
                        case NV01_EVENT_WIN32_EVENT:
                        {
                            // attempt to trigger the event
                            KeSetEvent((PRKEVENT)NotifyEvent->Data, 0, FALSE);
                            break;
                        }

                        case NV01_EVENT_KERNEL_CALLBACK:
                        {
                            MINIPORT_CALLBACK callBackToMiniport = (MINIPORT_CALLBACK)NotifyEvent->Data;

                            // perform a direct callback to the miniport
                            if (callBackToMiniport)
                                callBackToMiniport(pDev->DBmpDeviceExtension);
                            break;
                        }
                    }
                }
            }
            break;

        default:

            // any other actions are legacy channel-based notifies
            rmStatus = NVOS10_STATUS_ERROR_BAD_EVENT;
            break;
    }

    return rmStatus;

} // end of osNotifyEvent()

#endif // (_WIN32_WINNT < 0x0500)


//---------------------------------------------------------------------------
//
//  AGP support
//
//---------------------------------------------------------------------------

#if (_WIN32_WINNT >= 0x0500)

// AGP memory allocation tracking
typedef struct _AGP_MEM_INFO
{
    NvU64   aperAddr;
    VOID*   virtAddr;
    VOID*   physContext;
    VOID*   virtContext;
    U032    sysPageCount;
} AGP_MEM_INFO, *PAGP_MEM_INFO;

#if defined(IA64)

//
// All of the routines below are to make osGetAddressInfo to work
// with the 82460GX chipset.  Unlike other chipsets, the physical
// memory mapped on by the CPU are not the AGP aperture addresses.
// Thus a call to MmGetPhysicalAddress cannot be used to determine
// whether an virtual address is mapped to AGP memory.  The following
// routines maintain a simple mapping table to map the system physical
// address to the AGP aperture address to program the adapter with.

#define AGP_MAPPING_INCR	1    // keep it small at first to exercise code

typedef struct _AGP_MAPPING {
    PHYSICAL_ADDRESS sysAddr;
    PHYSICAL_ADDRESS aperAddr;
} AGP_MAPPING, *PAGP_MAPPING;

static PAGP_MAPPING osAGPMappingTab;
static U032 osAGPMappingSize = 0;
static U032 osAGPMappingUsed = 0;

static RM_STATUS
osAllocAGPMapping(PHYSICAL_ADDRESS sysAddr, PHYSICAL_ADDRESS aperAddr)
{
    RM_STATUS status;
    PAGP_MAPPING pTab;
    U032 newSize;

    if (osAGPMappingSize == osAGPMappingUsed) {
        newSize = sizeof(AGP_MAPPING) * (osAGPMappingSize + AGP_MAPPING_INCR);
        status = osAllocMem((VOID **)&pTab, newSize);
        if (status != RM_OK)
            return status;
        if (osAGPMappingSize) {
            osMemCopy((unsigned char *)pTab, (unsigned char *)osAGPMappingTab, newSize);
            osFreeMem(osAGPMappingTab);
        }
        osAGPMappingTab = pTab;
        osAGPMappingSize += AGP_MAPPING_INCR;
    }
#ifdef DEBUG
    for (pTab = osAGPMappingTab; pTab < &osAGPMappingTab[osAGPMappingUsed]; pTab++)    {
        RM_ASSERT(pTab->sysAddr.QuadPart != sysAddr.QuadPart);
        RM_ASSERT(pTab->aperAddr.QuadPart != aperAddr.QuadPart);
    }
#endif
    pTab = &osAGPMappingTab[osAGPMappingUsed++];
    pTab->sysAddr = sysAddr;
    pTab->aperAddr = aperAddr;
    return RM_OK;
}

static VOID
osFreeAGPMapping(PHYSICAL_ADDRESS aperAddr)
{
    PAGP_MAPPING pTab;

    for (pTab = osAGPMappingTab; pTab < &osAGPMappingTab[osAGPMappingUsed]; pTab++)    {
        if (pTab->aperAddr.QuadPart == aperAddr.QuadPart) {
            osAGPMappingUsed--;
            osMemCopy((unsigned char *)pTab, (unsigned char *)(pTab+1),
                      (U032)((char *)&osAGPMappingTab[osAGPMappingUsed] -
                             (char *)pTab));
            return;
        }
    }
    
}

static U032
osLookupAGPMapping(PHYSICAL_ADDRESS sysAddr)
{
    PAGP_MAPPING pTab;

    for (pTab = osAGPMappingTab; pTab < &osAGPMappingTab[osAGPMappingUsed]; pTab++)    {
        if (pTab->sysAddr.QuadPart == sysAddr.QuadPart) {
            return (pTab->aperAddr.LowPart);
        }
    }
    return sysAddr.LowPart;
}

#else

#define WIN2K_VIRT_OFFSET_PAGES    16

#define CPUID   __asm _emit 0x0F __asm _emit 0xA2
#define RDMSR   __asm _emit 0x0F __asm _emit 0x32

//
// win2k currently doesn't set up the correct page attribute table (PAT)
// index for write-combined user space mappings to AGP. The user mapping
// gets a WB index into the PAT and because of there are no non-system MTRR's,
// this defaults to uncached mapping.
//
// To work around this, we'll first READ the PAT and determine which index
// should be used for write-combining. Then, we'll read the PTE's for the
// length of the mapping and set the correct index.
//
// I don't believe (hopefully) MP will be an issue as I expect each CPU
// points to the same page table we're about to modify. At worst, this means
// we may be slow if we ran mostly on the wrong (uncached) processor.
//
static RM_STATUS
RmChangePageAttributeTable(PAGP_MEM_INFO pMemInfo)
{
    U032 modPass, PATvalue, PDTbase, WCindex;
    U032 PDEoffset, PTEoffset, physPage, lastPage;
    U032 *basepdb, *basepte, *pdbptr, *pteptr;
    U032 virtOffset, found_first_page = 0;
    PHYSICAL_ADDRESS pagePhysicalAddr;
    
    PATvalue = PDTbase = 0x0;

    __asm {
        ; save state
        push    eax
        push    ebx
        push    ecx
        push    edx

        mov     eax, 1
        CPUID

        // check for PAT support
        shr     edx, 16
        and     edx, 1  
        jz      Exit

        // get the (low 0:3 PAT) indices
        mov     ecx, 0x277
        RDMSR
        mov     PATvalue,eax

        // get the page descriptor base
        mov     ecx, cr3
        mov     PDTbase,ecx

        // flush caches making things consistent
        wbinvd
Exit:
        ; restore state
        pop     edx
        pop     ecx
        pop     ebx
        pop     eax
    }

    if (!PATvalue || !PDTbase)
        return RM_ERROR;

    // look for the WC type within the PAT indices
    for (WCindex = 0; WCindex < 4; WCindex++)
    {
        if ((PATvalue & 0xF) == 0x1)
            break;
        PATvalue >>= 8;
    }
    if (WCindex == 4)
        return RM_ERROR;    // didn't find a WC index

    // Map in the PDE page (assuming 4K ptes)
    pagePhysicalAddr.HighPart = 0;
    pagePhysicalAddr.LowPart  = (PDTbase & ~0xFFF);
    basepdb = MmMapIoSpace(pagePhysicalAddr, RM_PAGE_SIZE, FALSE);
    if (basepdb == NULL)
        return RM_ERROR;

    //
    // First, we need to find if there's a virtOffset that needs to be setup.
    // In win2k, it seems user mappings, in addition to not being write-combined,
    // don't start at the address returned from AgpCommitVirtual after the DX
    // AGP heap has been setup.
    //
    // This might be caused by a non-zero fpGARTLin from the GUID_UpdateNonLocalHeap
    // callback DDraw gets, where the driver is supposed to offset everything by this
    // amount. But, each user alloc seems to not be just fpGARTLin bytes, it's almost
    // fpGARTlin * number of outstanding user allocs.
    // 
    // Rather than guess, for now, just scan WIN2K_VIRT_OFFSET_PAGES pages for the
    // first page and then verify the rest of the mapping from there. This virtOffset
    // will then be added to the user mapping passed back.
    //
    physPage = (U032)pMemInfo->aperAddr;

    virtOffset = 0;
    while (!found_first_page && (virtOffset < WIN2K_VIRT_OFFSET_PAGES))
    {
        // 10bits of PDE offset, 10bits of PTE offset
        PDEoffset = (U032)((NV_UINTPTR_T)pMemInfo->virtAddr >> (RM_PAGE_SHIFT + 10));
        PTEoffset = (U032)(((NV_UINTPTR_T)pMemInfo->virtAddr >> RM_PAGE_SHIFT) & 0x003FF);

        pdbptr = basepdb + PDEoffset;
        if (*pdbptr & 0x80)
        {
            MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
            return RM_ERROR;    // this isn't a 4K PDE
        }

        // Map in a set of PTEs (assuming 4K ptes)
        pagePhysicalAddr.HighPart = 0;
        pagePhysicalAddr.LowPart  = (*pdbptr & ~0xFFF);
        basepte = MmMapIoSpace(pagePhysicalAddr, RM_PAGE_SIZE, FALSE);
        if (basepte == NULL)
        {
            MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
            return RM_ERROR;
        }

        pteptr = basepte + PTEoffset;

        // Look for the beginning of the mapping on this PTE page
        while ((PTEoffset <= 0x3FF) && (virtOffset < WIN2K_VIRT_OFFSET_PAGES))
        {
            if ((*pteptr & ~0xFFF) == physPage)
            {
                found_first_page = 1;
                break;
            }
            PTEoffset++; pteptr++; virtOffset++;
            (U008 *)pMemInfo->virtAddr += RM_PAGE_SIZE;
        }

        MmUnmapIoSpace(basepte, RM_PAGE_SIZE);
    }

    if (!found_first_page)
    {
        MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
        return RM_ERROR;    // can't find first page of our mapping
    }

    lastPage = (U032)pMemInfo->aperAddr + (pMemInfo->sysPageCount << RM_PAGE_SHIFT);

    //
    // Before updating any PTEs, make sure they have the expected physPage.
    // The second pass is the modifying pass where we update the PAT index.
    //
    for (modPass = 0; modPass < 2; modPass++)
    {
        // sets the beginning and ending phys page
        physPage = (U032)pMemInfo->aperAddr;

        // 10bits of PDE offset, 10bits of PTE offset
        PDEoffset = (U032)((NV_UINTPTR_T)pMemInfo->virtAddr >> (RM_PAGE_SHIFT + 10));
        PTEoffset = (U032)(((NV_UINTPTR_T)pMemInfo->virtAddr >> RM_PAGE_SHIFT) & 0x003FF);

        pdbptr = basepdb + PDEoffset;

        while (physPage < lastPage)
        {
            if (*pdbptr & 0x80)
            {
                MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
                return RM_ERROR;    // this isn't a 4K PDE
            }

            // Map in a set of PTEs (assuming 4K ptes)
            pagePhysicalAddr.HighPart = 0;
            pagePhysicalAddr.LowPart  = (*pdbptr & ~0xFFF);
            basepte = MmMapIoSpace(pagePhysicalAddr, RM_PAGE_SIZE, FALSE);
            if (basepte == NULL)
            {
                MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
                return RM_ERROR;
            }

            pteptr = basepte + PTEoffset;

            // Check (or modify) the PTEs on this page
            while ((PTEoffset <= 0x3FF) && (physPage < lastPage))
            {
                if ((*pteptr & ~0xFFF) != physPage)
                {
                    // mismatch on physical page in PTE
                    DBG_PRINT_STRING_PTR(DEBUGLEVEL_ERRORS, "NVRM: mismatch in AGP mapping ",
                                         pMemInfo->virtAddr);
                    MmUnmapIoSpace(basepte, RM_PAGE_SIZE);
                    MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);
                    return RM_ERROR;
                }
                if (modPass)
                {
                    // mask off bits 4:3 and set the index
                    *pteptr = (*pteptr & ~0x18) | (WCindex << 3);
                }
                PTEoffset++; pteptr++;
                physPage += RM_PAGE_SIZE;
            }

            // Free the old page of PTEs
            MmUnmapIoSpace(basepte, RM_PAGE_SIZE);

            PTEoffset = 0x0;
            pdbptr++;
        }
    }

    MmUnmapIoSpace(basepdb, RM_PAGE_SIZE);

    return RM_OK;
}
#endif // !IA64

#include <videoagp.h>

RM_STATUS osAllocAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   pageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    PAGP_MEM_INFO pMemInfo;
    HANDLE procHandle;
    RM_STATUS status;
    PHYSICAL_ADDRESS aperAddr;
#if defined(IA64)
    PHYSICAL_ADDRESS sysAddr;
#endif

    PVOID hwDeviceExtension = pDev->DBmpDeviceExtension;

    if (!hwDeviceExtension || !pOsHwInfo->AgpServices)
        return RM_ERR_NO_FREE_MEM;

    // we'll need to manage this allocation, a little
    status = osAllocMem((VOID **)&pMemInfo, sizeof(AGP_MEM_INFO));
    if (status != RM_OK)
        return RM_ERR_NO_FREE_MEM;

    // not all systems have PAGE_SIZE == RM_PAGE_SIZE;
    // round up to get an adequate number of system pages

    pMemInfo->sysPageCount = (pageCount + (PAGE_SIZE/RM_PAGE_SIZE) - 1) >> (PAGE_SHIFT - RM_PAGE_SHIFT);

    // reserve physical
    aperAddr = ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReservePhysical(hwDeviceExtension, pMemInfo->sysPageCount, TRUE, &pMemInfo->physContext);

    if ((aperAddr.LowPart == 0) && (aperAddr.HighPart == 0)) {
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

    pMemInfo->aperAddr = aperAddr.QuadPart;

    // commit physical
    if ( ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpCommitPhysical(hwDeviceExtension,
																			   pMemInfo->physContext,
																			   pMemInfo->sysPageCount,
																			   0)
																			   == FALSE )
	{

		((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleasePhysical(hwDeviceExtension, pMemInfo->physContext);
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

    // set processs handle (hopefully triggers the correct mapping)
    procHandle = (ClientClass == NV01_ROOT_USER) ? NtCurrentProcess() : 0x0;

    // reserve virtual
	pMemInfo->virtAddr = ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReserveVirtual(hwDeviceExtension,
																							   procHandle,
																							   pMemInfo->physContext,
																							   &pMemInfo->virtContext);
    if (pMemInfo->virtAddr == NULL)
	{
		((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpFreePhysical(hwDeviceExtension, pMemInfo->physContext, pMemInfo->sysPageCount, 0);
		((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleasePhysical(hwDeviceExtension, pMemInfo->physContext);

        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

    // commit virtual
    if ( ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpCommitVirtual(hwDeviceExtension,
																			  pMemInfo->virtContext,
																			  pMemInfo->sysPageCount,
																			  0)
																			  == NULL)
	{
		((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleaseVirtual(hwDeviceExtension, pMemInfo->virtContext);
		((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpFreePhysical(hwDeviceExtension, pMemInfo->physContext, pMemInfo->sysPageCount, 0);
		((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleasePhysical(hwDeviceExtension, pMemInfo->physContext);

        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }

#if defined(IA64)
    sysAddr = MmGetPhysicalAddress(pMemInfo->virtAddr);
    if (osAllocAGPMapping(sysAddr, aperAddr) != RM_OK) {
        osFreeAGPPages(pDev, pAddress, pMemInfo); 
        return RM_ERR_NO_FREE_MEM;
    }
#else
    // apply a win2k kernel workaround for write-combined user mappings 
    if (ClientClass == NV01_ROOT_USER)
    {
        // Dios Mio, forgive me for what I'm about to do ...
        if (RmChangePageAttributeTable(pMemInfo) != RM_OK)
        {
            osFreeAGPPages(pDev, pAddress, pMemInfo); 
            return RM_ERR_NO_FREE_MEM;
        }
    }
#endif

    // verify the buffer is writable (may not be due to a chipset driver bug).
    // This has been seen on a Via 694x when returning from hibernation.
    *(volatile U032 *)pMemInfo->virtAddr = 0xBEEFCAFE;
    if (*(volatile U032 *)pMemInfo->virtAddr != 0xBEEFCAFE)
    {
        DBG_PRINT_STRING_PTR(DEBUGLEVEL_ERRORS,
                            "NVRM: allocated unwritable AGP buffer ", pMemInfo->virtAddr);
        osFreeAGPPages(pDev, pAddress, pMemInfo); 
        return RM_ERR_NO_FREE_MEM;
    }

    // Set our AGP parameters, if they need to be.
    // We don't expect this to ever be needed, since RmSetAgpServices should've
    // handled it already.
    if (!pRmInfo->AGP.AGPLinearStart) {
        pRmInfo->AGP.AGPLinearStart = (VOID_PTR)pMemInfo->virtAddr;

        if (!pRmInfo->AGP.AGPPhysStart && !pRmInfo->AGP.AGPLimit) {
            // should've already been filled in by NvGetAGPBaseLimit()
            pRmInfo->AGP.AGPPhysStart   = aperAddr.LowPart;
            pRmInfo->AGP.AGPLimit       = 0x4000000;        // 64MB
        }

#ifdef DEBUG
        // first allocation should be at the aperture base
        if (aperAddr.LowPart != pRmInfo->AGP.AGPPhysStart) {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: first AGP alloc != AGP base\n");
            DBG_BREAKPOINT();        
        }
#endif
    }

    *pAddress = pMemInfo->virtAddr;
    *pMemData = (VOID *)pMemInfo;

    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: setup AGP addr    ", *pAddress);

    return RM_OK;
}

RM_STATUS osFreeAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID  *pMemData
)
{
    PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;
    PVOID hwDeviceExtension = pDev->DBmpDeviceExtension;
    PAGP_MEM_INFO pMemInfo = pMemData;
#if defined(IA64)
    PHYSICAL_ADDRESS aperAddr;
#endif

	((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpFreeVirtual(hwDeviceExtension, pMemInfo->virtContext, pMemInfo->sysPageCount, 0);
	((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleaseVirtual(hwDeviceExtension, pMemInfo->virtContext);
	((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpFreePhysical(hwDeviceExtension, pMemInfo->physContext, pMemInfo->sysPageCount, 0);
    ((PVIDEO_PORT_AGP_SERVICES)pOsHwInfo->AgpServices)->AgpReleasePhysical(hwDeviceExtension, pMemInfo->physContext);

#if defined(IA64)
    aperAddr.QuadPart = pMemInfo->aperAddr;
    osFreeAGPMapping(aperAddr);
#endif

    osFreeMem(pMemInfo);

    return RM_OK;
}

#else // WIN32_WINNT >= 0x0500

// NT4 versions just call into nvagp functions

#include <nvagp.h>

RM_STATUS osAllocAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   pageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    RM_STATUS rmStatus;

    rmStatus = NvAllocAGPPages(pDev, pAddress, pageCount, ClientClass, pMemData);
    if (rmStatus == RM_OK)
        rmStatus = NvMapAGPPages(pDev, pAddress, ClientClass, *pMemData);

    return rmStatus;
}

RM_STATUS osFreeAGPPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID  *pMemData
)
{
    return NvFreeAGPPages(pDev, pAddress, pMemData);
}

#endif // WIN32_WINNT >= 0x0500

// Translate a Virtual to Physical addr (used to provide the AGP aperture offset)
RM_STATUS osVirtualToPhysicalAddr
(
    VOID* virtaddr,
    VOID** physaddr
)
{
    PHYSICAL_ADDRESS physAddress = MmGetPhysicalAddress(virtaddr);

    *physaddr = (VOID*)((NV_UINTPTR_T)(physAddress.LowPart));

    return RM_OK;
}

RM_STATUS osCalculatePteAdjust
(
    PHWINFO pDev,
    U032    AddressSpace,
    VOID*   Address,
    U032*   pPteAdjust
)
{
    *pPteAdjust = (U032)((SIZE_PTR)Address & RM_PAGE_MASK);

    return RM_OK;
}

// get address information from the linear address
RM_STATUS osGetAddressInfo
(
    PHWINFO pDev,
    U032    unusedParamChID,
    U032    unusedParamSelector,
    VOID**  pLinearAddress,
    U032    Limit,
    VOID**  pAddress,
    NV_ADDRESS_SPACE *pAddressSpace
)
{
	PRMINFO pRmInfo = (PRMINFO) pDev->pRmInfo;

    PHYSICAL_ADDRESS pa;
    U032 physFbAddr;
    U032 physicalAddress;
    U032 ramSize;

    // Check to see if we have an address space conflict
    if ((*pAddressSpace != ADDR_UNKNOWN) && (*pAddressSpace != ADDR_SYSMEM))
    {
       return (RM_ERR_BAD_ADDRESS);
    }

    // Convert virtual address into physical address

    pa = MmGetPhysicalAddress(*pLinearAddress);

#ifdef IA64
    //
    // The virtual address of AGP memory returned to the user is mapped
    // to PCI pages on the 82460GX chipset.  Substitute the AGP aperture
    // address for this physical address in this case.

    physicalAddress = osLookupAGPMapping(pa);
#else
    physicalAddress = pa.LowPart;
#endif

    physFbAddr = pDev->Mapping.PhysFbAddr;
    ramSize = pDev->Framebuffer.HalInfo.RamSize;

    // address space type is frame buffer if the physical address lies within the FB range
    if (physicalAddress >= physFbAddr && physicalAddress < physFbAddr + ramSize)
    {
        if (physicalAddress + Limit >= physFbAddr + ramSize)
        {
            //
            // We're straddling fb mem...bomb.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: osGetAddressInfo: buffer crosses fbmem boundary ", physicalAddress);
            DBG_BREAKPOINT();
            return (RM_ERR_MULTIPLE_MEMORY_TYPES);
        }

        //
        // Subtract off the start of the framebuffer
        //
        *pLinearAddress = (VOID*)((NV_UINTPTR_T)(physicalAddress - physFbAddr));
        //
        // Turn this into a PNVM dma structure
        //
        *pAddressSpace = ADDR_FBMEM;
    }
    else if (pRmInfo->AGP.AGPLinearStart &&
             physicalAddress >= pRmInfo->AGP.AGPPhysStart &&
             physicalAddress < pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit)
    {
        if (physicalAddress + Limit > pRmInfo->AGP.AGPPhysStart + pRmInfo->AGP.AGPLimit)
        {
            //
            // We're straddling agp mem...bomb.
            //
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: osGetAddressInfo: buffer crosses agp aperture boundary ", physicalAddress);
            DBG_BREAKPOINT();
            return (RM_ERR_MULTIPLE_MEMORY_TYPES);
        }

        // For AGP, just return the Aperture address as the DescAddr, which'll get
        // loaded into the instance memory PTEs
        *pAddressSpace = ADDR_AGPMEM;
        *pLinearAddress = (VOID *)((NV_UINTPTR_T)physicalAddress);
    }

    // otherwise address space type is system    
    else
    {
        // The address space is always system memory
        *pAddressSpace = ADDR_SYSMEM;
    }

    // the resulting address IS the linear address
    *pAddress = *pLinearAddress;

    return (RM_OK);
}

#if !defined(_WIN64)
RM_STATUS osAllocSystemPages
(
    PHWINFO pDev,
    VOID **pAddress,
    U032   pageCount,
    U032   ClientClass,
    VOID **pMemData
)
{
    PSYS_MEM_INFO    pMemInfo;
    RM_STATUS        rmStatus;
    VOID             *pageAddr, *userAddr;

    // Since there will be some cleanup needed on the free side
    // create a struct that hooks into VOID * in CLI_MEMORY_INFO

    rmStatus = osAllocMem((VOID **)&pMemInfo, sizeof(SYS_MEM_INFO));
    if (rmStatus != RM_OK)
        return rmStatus;

    pMemInfo->sysAddr = ExAllocatePoolWithTag(NonPagedPool,
                                              (pageCount + 1) << RM_PAGE_SHIFT,
                                              NV_MEMORY_TAG);

    if (pMemInfo->sysAddr == NULL) {
        osFreeMem(pMemInfo);
        return RM_ERR_NO_FREE_MEM;
    }
    pageAddr = (VOID *)(((NV_UINTPTR_T)pMemInfo->sysAddr + RM_PAGE_MASK) & ~RM_PAGE_MASK);

    if ((pMemInfo->clientClass = ClientClass) == NV01_ROOT_USER) {
        userAddr = osMapUserSpace(pageAddr, &pMemInfo->pMdl,
                                  pageCount << RM_PAGE_SHIFT, MAP_WRITECOMBINE);
        if (userAddr == NULL) {
            ExFreePool(pMemInfo->sysAddr);
            osFreeMem(pMemInfo);
            return RM_ERR_NO_FREE_MEM;
        } else {
           *pAddress = userAddr;
        }
    } else {
       *pAddress = pageAddr;
    }
    *pMemData = (VOID *)pMemInfo;
    return RM_OK;
}

RM_STATUS osFreeSystemPages
(
    PHWINFO pDev,
    VOID **pAddress,
    VOID *pMemData
)
{
    PSYS_MEM_INFO    pMemInfo = (PSYS_MEM_INFO)pMemData;

    // unmap the memory from user space, if necessary
    if (pMemInfo->clientClass == NV01_ROOT_USER) {
        osUnmapUserSpace(*pAddress, pMemInfo->pMdl);
    }

    // free the memory using the original pointer
    ExFreePool(pMemInfo->sysAddr);

    // free our data struct that kept track of this mapping
    osFreeMem(pMemInfo);

    return RM_OK;
}
#endif !defined(_WIN64)


#if (_WIN32_WINNT < 0x0500)

// WINNT4 handles MmWriteCombined caching type, but it isn't in the DDK!

MEMORY_CACHING_TYPE modeTab[4] = { MmNonCached, MmCached,
                                   0x2, 0x2 };
#else
MEMORY_CACHING_TYPE modeTab[4] = { MmNonCached, MmCached,
                                   MmWriteCombined, MmWriteCombined };
#endif
/* remap IO memory to kernel space */
VOID *osMapKernelSpace(unsigned int start, unsigned int size_bytes, U008 mode)
{
    if (mode & MAP_USER)
        return NULL;
    else
        return osMapIOSpace(start, size_bytes, NULL, (U008)(mode));
}

VOID osUnmapKernelSpace(void *addr, unsigned int size)
{
   osUnmapIOSpace(addr, size, NULL, MAP_KERNEL);
}

/* remap memory to user space */
VOID *osMapUserSpace(VOID *kaddr, VOID **priv, unsigned int size_bytes, U008 mode)
{
    PMDL pMdl;
    VOID *addr;

    // create a mdl that describes the kernel mapping
    pMdl = IoAllocateMdl(kaddr, 
                         size_bytes,  // now in bytes
                         FALSE,
                         FALSE,
                         NULL);
    if (pMdl == NULL)
	{
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVGFX: Cannot allocate MDL\n");
        return NULL;
    }
  
  
    // fill in the physical page array of the MDL
    MmBuildMdlForNonPagedPool(pMdl);

    // create the user mapping to these pages
#if (_WIN32_WINNT < 0x0500)
    addr = MmMapLockedPages(pMdl, UserMode);
#else // Win2k doesn't want us using MmMapLockedPages, use MmMapLockedPagesSpecifyCache instead
    addr = MmMapLockedPagesSpecifyCache(pMdl, UserMode, modeTab[mode & 0x3],
                                        NULL, FALSE, HighPagePriority);
#endif
    if (addr == NULL)
    {
       IoFreeMdl(pMdl);
       pMdl = NULL;
       return NULL;
    }

	*priv = (VOID *) pMdl;
    return addr;
}

VOID osUnmapUserSpace(VOID *uaddr, VOID *priv)
{
    PMDL pMdl = (PMDL) priv;

    MmUnmapLockedPages(uaddr, pMdl);
    IoFreeMdl(pMdl);
	priv = (VOID *) NULL;
}

/* map I/O space to user or kernel space */
VOID *osMapIOSpace(U032 start, U032 size_bytes, VOID **priv, U008 mode)
{
    PHYSICAL_ADDRESS physaddr;
    PMDL pMdl;
    VOID *kaddr, *uaddr;

    physaddr.HighPart = 0;
    physaddr.LowPart  = start;

    kaddr = MmMapIoSpace(physaddr, size_bytes, modeTab[mode & 0x3]);

    if (kaddr == NULL)
        return NULL;

    if (mode & MAP_USER)
    {
        uaddr = osMapUserSpace(kaddr, priv, size_bytes, mode);

        if (uaddr == NULL)
        {
            MmUnmapIoSpace(kaddr, size_bytes);
            return NULL;
        }
        return uaddr;
    }
    else
    {
        return kaddr;
    }
}

VOID osUnmapIOSpace(VOID *addr, U032 size_bytes, void *priv, U008 mode)
{
    PMDL pMdl;
    VOID *kaddr;

    if (mode & MAP_USER)
    {
        pMdl = (PMDL) priv;
        kaddr = (char *)pMdl->StartVa + pMdl->ByteOffset;
        osUnmapUserSpace(addr, priv);
    }
    else
    {
        kaddr = addr;
    }
    MmUnmapIoSpace(kaddr, size_bytes);

}

RM_STATUS osSetMemRange(U032 start, U032 size_bytes, U008 mode)
{
    PHYSICAL_ADDRESS physaddr;
    VOID *kaddr;

    if (mode != MEM_WRITECOMBINE)
        return RM_ERROR;

    // Rely on side effect of this routine for now

    physaddr.HighPart = 0;
    physaddr.LowPart  = start;

    kaddr = MmMapIoSpace(physaddr, size_bytes, 0x2);

    if (kaddr == NULL)
        return RM_ERROR;

    MmUnmapIoSpace(kaddr, size_bytes);

    return RM_OK;
}

VOID *osAllocContigPages(U032 size)
{
    PHYSICAL_ADDRESS physaddr;
    physaddr.HighPart = 0;
    physaddr.LowPart  = -1;
    return (VOID *) MmAllocateContiguousMemory(size, physaddr);
}

VOID osFreeContigPages(VOID *addr)
{
    MmFreeContiguousMemory(addr);
}


U032 osGetKernPhysAddr(VOID *kern_virt_addr)
{
    PHYSICAL_ADDRESS physaddr;
    physaddr = MmGetPhysicalAddress(kern_virt_addr);
    return (physaddr.LowPart);
}

RM_STATUS osGetAGPPhysAddr(PHWINFO pDev, VOID *base, U032 index, U032 *paddr)
{
    VOID *vaddr = (VOID *) ((U008 *) base + (index << RM_PAGE_SHIFT));
    *paddr = osGetKernPhysAddr(vaddr);
    if (*paddr == (U032) 0x0) return RM_ERROR;
    return RM_OK;
}

RM_STATUS osAllocPool(VOID **addr, unsigned int size_bytes)
{
    *addr = ExAllocatePoolWithTag(NonPagedPool, size_bytes, NV_MEMORY_TAG);
    if (*addr == NULL) return RM_ERROR;
    return RM_OK;
}

RM_STATUS osFreePool(VOID *addr)
{
    ExFreePool(addr);
    return RM_OK;
}

//---------------------------------------------------------------------------
//
//  Debugging support.
//
//---------------------------------------------------------------------------

#if DBG

// The current debug display level 
//
// Best to leave it above setup and trace messages, but below warnings and error messages
//
int cur_debuglevel = DBG_LEVEL_DEFAULTS;    // all modules set to warning level

VOID osDbgBreakPoint
(
    void
)
{
    DbgBreakPoint();
}

VOID osDbgPrintf_va(
    int     module,
    int     debuglevel,
    const char *printf_format,
    va_list arglist)
{
    int     moduleValue = cur_debuglevel;
    char    nv_error_string[MAX_ERROR_STRING];
    char    *p = nv_error_string;
    int     chars_written;

    // get the module
    // put the module we want in the first 2 bits
    moduleValue = moduleValue >> (module * 2);

    // get the value of those two bits
    // mask off the last 30 bits
    moduleValue = moduleValue & 0x00000003;

    if (debuglevel >= moduleValue)
    {
        chars_written = nvDbgSprintf(p, printf_format, arglist);

        DbgPrint(p);
   }
}

#endif // DBG

#if (_WIN32_WINNT < 0x500) && defined(NTRM)
//
// Signals the nVidia service (NVSVC) via the "NVModeSwitchEvent" that a device switch hotkey has been pressed.
//
VOID RmSignalHotKeyEvent()
{
    SignalModeSwitchEvent();
}
#endif

// end of os.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\arch\nvalloc\winnt4\nvgfx\nv\osinit.c ===
/**************************************************************************************************************
*
*   Module:  osinit.c
*
*   Description:
*       This is the NT-specific, device-independent initialization code for the resource manager.
*
*
**************************************************************************************************************/

#include <nvhw.h>
#include <nvrm.h>
#include <nvos.h>
#include <nvarch.h>
#include <devinit.h>
#include <rmfail.h>

//
// Globals
//
WINNTHWINFO	winNTHwInfo[MAX_INSTANCE];

// local prototypes
RM_STATUS   initDmaListElementPool();
VOID        initDisplayInfo(PDISPLAYINFO);


BOOL RmInitRm()
{
    // init client database
    if (initClientInfo() != RM_OK)
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize client database\n");
        return FALSE;
    }

    // init dma context-list element pool
    if (initDmaListElementPool() != RM_OK)
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize graphics patch pool\n");
        return FALSE;
    }

    // init state of display
    osDisplayInfo.HdrSize = sizeof(DISPLAYINFO);
    initDisplayInfo(&osDisplayInfo);

    return TRUE;
       
} // end of RmInitRm()


BOOL RmInitNvMapping
(
    VOID* deviceExtension,
    U032 PhysNvAddr,
    PHWREG nvRegisterBase,
    U032* pDeviceReference
)
{
    PHWINFO pDev;

	DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: RmInitNvMapping:\n");

    // get the next available device instance
    if (!RM_SUCCESS(RmAllocDeviceInstance(pDeviceReference)))
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize device database\n");
        return FALSE;
    }
    pDev = NvDBPtr_Table[*pDeviceReference];

	// setup the ptr to the OS Hw info
	pDev->pOsHwInfo = (VOID_PTR) &winNTHwInfo[*pDeviceReference];

    // set the device extension
    pDev->DBmpDeviceExtension = deviceExtension;

    // init configuration
    osStringCopy(pDev->Mapping.ID, "Device Mapping");
    pDev->Mapping.Size = sizeof(pDev->Mapping);

    // set physical and logical register base
    pDev->Mapping.PhysAddr = PhysNvAddr;
    nvAddr = nvRegisterBase;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: device instance          :", devInstance);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: NV using physical address:", pDev->Mapping.PhysAddr);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: NV using linear address  :", nvAddr);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: ROM using linear address :", romAddr);
    
    // default the crystal frequency to 0
    pDev->Chip.HalInfo.CrystalFreq = 0;

    return TRUE;

} // end of RmInitNvMapping()

BOOL RmInitNvHal
(
    U032 deviceReference
)
{
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    // hook up the HAL
    if (initHal(pDev) != RM_OK)
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize device-dependent (HAL) state\n");
        return FALSE;
    }

    // set the chip revision
    nvHalMcControl(pDev, MC_CONTROL_SETREVISION);

    // set the bios addr now, PraminOffset is set in MC_CONTROL_SETREVISION
    biosAddr = (PHWREG)((U008 *)nvAddr + pDev->Pram.HalInfo.PraminOffset);

    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: BIOS using linear address:", biosAddr);

    return (TRUE);
} // end of RmInitNvHal()

// the FB address is only provided on the first POST
BOOL RmPostNvDevice
(
    U032 deviceReference,
    PHWREG externalBiosImage,
    PHWREG frameBufferBase
)
{
    RM_STATUS rmStatus = RM_OK;
    BOOL biosUsedToInit;
    
    // set the device context
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: POSTing device instance  :", devInstance);

    // set the FB logical address, if given
    if (frameBufferBase)
    {
        fbAddr = frameBufferBase;
    }
    
    // POST the device
    rmStatus = DevinitInitializeDevice(pDev, externalBiosImage, &biosUsedToInit);

    if (RM_SUCCESS(rmStatus))
    {
		DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: ...POST completed sucessfully\n");
        
        // shadow the VGA BIOS image in upper inst mem
        if (externalBiosImage)
        {
            DevinitShadowBios(pDev, externalBiosImage);
        }
    }
    else
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot POST the device\n");
    }
    
    return (rmStatus == RM_OK);

} // end of RmPostNvDevice()

BOOL RmInitNvDevice
(
    U032 deviceReference,
    U032 PhysFbAddr,
    PHWREG frameBufferBase
)
{
    // set the device context
    PHWINFO pDev = NvDBPtr_Table[deviceReference];

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: RmInitNvDevice:\n");

    // init the RM FAILURE facility if enabled
    RM_FAILURE_ENABLE();
    
    // init processor synchronization
    if (!RM_SUCCESS(osInitSpinLock(pDev)))
    {
        return FALSE;
    }

    // init "DMA adapter" for use in memory management routines
    if (!RM_SUCCESS(osInitDmaAdapter(pDev)))
    {
        return FALSE;
    }
        
#ifdef RM_STATS
    // init all data structures
    pDev->Statistics.MemAlloced = 0;
    pDev->Statistics.MemLocked = 0;
#endif

    // set physical and logical frame buffer
    pDev->Mapping.PhysFbAddr = PhysFbAddr;
    fbAddr = frameBufferBase;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: device instance          :", devInstance);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: FB using physical address:", pDev->Mapping.PhysFbAddr);
    DBG_PRINT_STRING_PTR(DEBUGLEVEL_TRACEINFO, "NVRM: FB using linear address  :", fbAddr);

    // initialize all engines -- calls back initMapping()
    if (!RM_SUCCESS(stateNv(pDev, STATE_INIT)))
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize the device\n");
        return FALSE;
    }

    // come up as VGA until display driver disables it, thus enabling high-res
    pDev->Vga.Enabled = TRUE;
    if (!RM_SUCCESS(stateNv(pDev, STATE_LOAD)))
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot load state into the device\n");
        return FALSE;
    }

    return TRUE;

} // end of RmInitNvDevice()

// init the global pool of DMA context list elements
RM_STATUS initDmaListElementPool()
{
    RM_STATUS status = RM_OK;
    U032 i;

    // allocate the pool
    status = osAllocMem((VOID **)&dmaListElementPool, sizeof(DMALISTELEMENT_POOL_ELEMENT) * DMALISTELEMENT_POOL_SIZE);
    if (RM_SUCCESS(status))
    {
        // initialize the pool
        for (i = 0; i < DMALISTELEMENT_POOL_SIZE; i++)
        {
            dmaListElementPool[i].inUse = FALSE;
        }
    }

    return status;

} // end of initDmaCtxtListElemPool()

VOID initDisplayInfo(PDISPLAYINFO pDi)
{
    // these are hard coded not unreasonable values for the time being
    pDi->XRes                   = 1024;
    pDi->YRes                   = 768;
    pDi->Bpp                    = 16;
    pDi->HdrSize                = 0x32;
    pDi->InfoFlags              = 0;
    pDi->DevNodeHandle          = 0;
    pDi->DriverName[0]          = 0;
    pDi->DPI                    = 0x60;
    pDi->Planes                 = 0x1;
    pDi->RefreshRateMax         = 0x4F;
    pDi->RefreshRateMin         = 0x32;
    pDi->LowHorz                = 0x1E;
    pDi->HighHorz               = 0x40;
    pDi->LowVert                = 0x32;
    pDi->HighVert               = 0x64;
    pDi->MonitorDevNodeHandle   = 0;
    pDi->HorzSyncPolarity       = 0x2B;
    pDi->VertSyncPolarity       = 0x2B;

} // end of RmInitDisplayInfo()

// map the NV device into the RM memory space
RM_STATUS initMapping
(
    PHWINFO pDev
)
{
	PWINNTHWINFO pOsHwInfo = (PWINNTHWINFO) pDev->pOsHwInfo;

    RM_STATUS status;

	DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initMapping:\n");

    // attempt to determine the current CPU type
    RmInitCpuInfo(pDev);

    // attempt to determine the FSB and Memory speeds
    RmInitBusInfo(pDev);

    // reload mapped device addresses for HAL use
    if (initHalMappings(pDev) != RM_OK)
    {
		DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: *** Cannot initialize device mappings for HAL\n\r");
        return FALSE;
    }

    // satisfy MC init
    pDev->Mapping.IntPin = 0x0A;

    // Some PCI BIOSs leave the ROM mapped.  This causes problems if it overlays system RAM.  Just disable it.
    REG_WR32(NV_PBUS_PCI_NV_12, 0);
    
    // make sure our PCI latency timer is sufficient (max it out)
    REG_WR32(NV_PBUS_PCI_NV_3, DRF_NUM(_PBUS,_PCI_NV_3,_LATENCY_TIMER, NV_PBUS_PCI_NV_3_LATENCY_TIMER_248_CLOCKS));

#if (_WIN32_WINNT < 0x500)
    //
    // For NT4, we'll attempt to recognize the chipset and init AGP support
    // if this is an AGP card and there's no registry entry override set
    //
    {
        U032 data32;
        U032 stringlength=80;
        char string[80];
        extern char strDevNodeRM[];
        extern char strNTSrvPackVersion[];

        // For DELL's unattended install, they're running NT without *ANY* service packs!
        // In this case, do NOT implement AGP functionality, because NT without
        // service pack can't handle it.  We'll check and see if a service pack 
        // (greather than or equal to service pack 3) was installed.  Not sure
        // what C libraries we can include here, so to be safe, just compare the strings by hand.
    
        if (osReadRegistryString(strNTSrvPackVersion, "CSDVersion", &string[0], &stringlength) == RM_OK)
        {
            if ( ((string[0] == 'S') || (string[0] == 's'))  && 
                 ((string[1] == 'E') || (string[1] == 'e'))  &&                 
                 ((string[2] == 'R') || (string[2] == 'r'))  &&
                 ((string[3] == 'V') || (string[3] == 'v'))  && 
                 ((string[4] == 'I') || (string[4] == 'i'))  && 
                 ((string[5] == 'C') || (string[5] == 'c'))  && 
                 ((string[6] == 'E') || (string[6] == 'e'))  &&             
                 (string[13] >= '3') )             
            {

                if (osReadRegistryDword(pDev, strDevNodeRM, "NoNT4AGP", &data32) != RM_OK)
                {
                    // Allow an override to set the AGP rate
                    if (osReadRegistryDword(pDev, strDevNodeRM, "ReqAGPRate", &data32) == RM_OK)
                        pDev->Chip.ReqAGPRate = data32;

                    if (REG_RD_DRF(_PBUS, _PCI_NV_24, _NEXT_PTR) == NV_PBUS_PCI_NV_24_NEXT_PTR_AGP)
                        RmInitAGP(pDev);
                }

            }
        }
    }
#endif

    // Apply any AGP chipset workarounds or overrides
    NvUpdateAGPConfig(pDev);

    // flag RM to be initialized
    pOsHwInfo->rmInitialized = TRUE;

    // TO DO: add AGP support in NT 5.0

    return RM_OK;

} // end of initMapping()

// OS-specific initializations

RM_STATUS initFbEx
(
    PHWINFO pDev
)
{
    S032  fbCalcMemSize(VOID);
    U032 calc_max_bw (VOID);
    U032 size;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: initFramebufferEx\n");
    //
    // Get screen resolution and framebuffer configuration from registry.
    //
    pDev->Dac.HalInfo.Depth = (osDisplayInfo.InfoFlags & REGISTRY_BPP_NOT_VALID) ? 8 : osDisplayInfo.Bpp;
    if ((osDisplayInfo.InfoFlags & (MONITOR_INFO_NOT_VALID | MONITOR_INFO_DISABLED_BY_USER))
     || (osDisplayInfo.RefreshRateMax == 0xFFFFFFFF)
     || (osDisplayInfo.RefreshRateMax == 0))
    {
        pDev->Framebuffer.HalInfo.RefreshRate   = 60;
        pDev->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
        pDev->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;
    }
    else
    {
        pDev->Framebuffer.HalInfo.RefreshRate   = osDisplayInfo.RefreshRateMax;
        pDev->Framebuffer.HSyncPolarity = osDisplayInfo.HorzSyncPolarity;
        pDev->Framebuffer.VSyncPolarity = osDisplayInfo.VertSyncPolarity;
    }

    pDev->Framebuffer.HalInfo.HorizDisplayWidth = osDisplayInfo.XRes;
    pDev->Framebuffer.HalInfo.VertDisplayWidth  = osDisplayInfo.YRes;
    pDev->Framebuffer.HorizFrontPorch = 0;
    pDev->Framebuffer.HorizSyncWidth  = 0;
    pDev->Framebuffer.HorizBackPorch  = 0;
    pDev->Framebuffer.VertFrontPorch  = 0;
    pDev->Framebuffer.VertSyncWidth   = 0;
    pDev->Framebuffer.VertBackPorch   = 0;
    pDev->Framebuffer.CSync           = BUFFER_CSYNC_DISABLED;
    pDev->Dac.HalInfo.VClk            = 0;
    //
    // Calculate the framebuffer count based on the configuration with double buffering.
    //
    size = pDev->Dac.HalInfo.Depth / 8
         * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth
         * 2;
    if (size > pDev->Framebuffer.HalInfo.RamSize)
        size = 0;
    else
        size = pDev->Framebuffer.HalInfo.RamSize - size;
    pDev->Framebuffer.Count = 1;

    return (RM_OK);
}
RM_STATUS initGrEx
(
    PHWINFO pDev
)
{
    return (RM_OK);
}
RM_STATUS initDacEx
(
    PHWINFO pDev
)
{
    return (RM_OK);
}
RM_STATUS initFifoEx
(
    PHWINFO pDev
)
{
    pDev->Fifo.HalInfo.RetryCount = 1;

    return (RM_OK);
}
RM_STATUS initRModeEx
(
    PHWINFO pDev
)
{
    return(RM_OK);
}

// end of osinit.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CEPDspProgram.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CEPDspProgram.cpp                                                 *
*	interface for accessing DSP program information                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv_uep.h>
#include <AudioHw.h>
};

#include "CDspProgram.h"
#include "CEPDspProgram.h"

// the header files are generated at 
// build time... by the build batch file
static U032 AC3SuperExec[] = 
{
#include <AC3SuperExec.h>
};

static U032 AC3Loader[] =
{
#include <AC3Loader.h>
};

static U032 AC3Dolby1[] =
{
#include <AC3Dolby1.h>
};

static U032 AC3Dolby2[] =
{
#include <AC3Dolby2.h>
};

static U032 AC3Dolby3[] =
{
#include <AC3Dolby3.h>
};

static U032 AC3Dolby4[] =
{
#include <AC3Dolby4.h>
};

typedef struct
{
    U032 table_size;
    U032 do_surround_encode;
    U032 do_game_encode;
    U032 pcm_sample_rate_code;
    U032 input_ch_config;
    U032 lfe_present;
    U032 ac3_dialnorm;
    U032 ac3_bandwidth;
    U032 channel_lpf_enabled;
    U032 lfe_lpf_enabled;
    U032 dc_hpf_enabled;
    U032 dynrng_exists;
    U032 ac3_dynrng_code;
    U032 compr_exists;
    U032 ac3_compr_code;
    U032 surround_gain_enabled;
    U032 surround_gain;
    U032 surround_mode;
} DOLBY_CONFIG_TABLE;

static DOLBY_CONFIG_TABLE AC3ConfigTable =
  {
    18,        // table size
    1,         // perform dolby surround encode flag
    1,         // perform dolby game encode flag
    0,         // ac3 pcm sampling rate code
    7,         // ac3 dolby input channel config code (acmod)
    1,         // lfe channel present flag
    16,        // ac3 dialnorm value
    9,         // ac3 channel bandwidth code
    1,         // channel lpf enabled flag
    1,         // lfe channel lpf enabled flag
    1,         // dc hpf enabled flag
    0,         // dynrng exists flag
    0,         // ac3 dynrng code
    1,         // compr exists flag
    0xEF,      // ac3 compr code
    1,         // dolby surround gain enabled flag
    0x47FACD,  // dolby surround encoder gain value
    2          // dolby surround mode. Only used for 2/0 Mode
  };

U032
CEPDspProgram::AC3GetTotalScratchSize()
{
    // in bytes
    return (AC3_DOLBYBASE * sizeof(U032) + 
            sizeof(AC3Dolby1) + 
            sizeof(AC3Dolby2) + 
            sizeof(AC3Dolby3) + 
            sizeof(AC3Dolby4) +
            sizeof(DOLBY_CONFIG_TABLE) + 
            AC3_HEAPLENGTH * sizeof(U032));
}

VOID
CEPDspProgram::AC3GetSuperExec(VOID_PTR *ppData, U032 *pLength, U032 *pBase)
{
    *ppData  = (VOID_PTR)AC3SuperExec;
    *pLength = sizeof(AC3SuperExec)/sizeof(U032);
    *pBase   = AC3_SUPREXECBASE;
}

VOID
CEPDspProgram::AC3GetLoader(VOID_PTR *ppData, U032 *pLength, U032 *pBase)
{
    *ppData  = (VOID_PTR)AC3Loader;
    *pLength = sizeof(AC3Loader)/sizeof(U032);
    *pBase   = AC3_LOADERBASE;
}

VOID_PTR 
CEPDspProgram::AC3GetConfigTable()
{
    return (VOID_PTR)&AC3ConfigTable;
}

VOID
CEPDspProgram::AC3GetProgram(U032 uIndex, VOID_PTR *ppData, U032 *pLength)
{
    switch(uIndex)
    {
    case 0:
        *ppData  = (VOID_PTR)AC3Dolby1;
        *pLength = sizeof(AC3Dolby1)/sizeof(U032);
        break;
    case 1:
        *ppData  = (VOID_PTR)AC3Dolby2;
        *pLength = sizeof(AC3Dolby2)/sizeof(U032);
        break;
    case 2:
        *ppData  = (VOID_PTR)AC3Dolby3;
        *pLength = sizeof(AC3Dolby3)/sizeof(U032);
        break;
    case 3:
        *ppData  = (VOID_PTR)AC3Dolby4;
        *pLength = sizeof(AC3Dolby4)/sizeof(U032);
        break;

    default:
        *ppData  = NULL;
        *pLength = 0;
        break;
    }
}

VOID
CEPDspProgram::Initialize()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CContextDma.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: CContextDma.cpp                                                   *
*   The MCPX HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
extern "C"
{
#include <nv32.h>
#include <nvarm.h>
#include <aos.h>
};

#include <ClinkList.h>
#include "CContextDma.h"


RM_STATUS
CContextDma::Initialize(VOID *pAddress, U032 uSize, U032 uType)
{
    RM_STATUS rmStatus = RM_ERROR;

    m_uType = uType;
    m_uSize = uSize;
    m_pLinAddr = NULL;
    m_pAddress = NULL;

    switch(m_uType)
    {
    case AUDIO_CONTEXT_DMA_GPFXPARAM:
    case AUDIO_CONTEXT_DMA_GPFXDSPCODE:
        // no check for MCP1.. just store the virtual address
        m_pLinAddr = pAddress;
        m_pAddress = NULL;
        rmStatus = RM_OK;
        break;

    case AUDIO_CONTEXT_DMA_SESGE:
    case AUDIO_CONTEXT_DMA_SESSL:
    case AUDIO_CONTEXT_DMA_GPSGE:
    case AUDIO_CONTEXT_DMA_EPSGE:
        {
            // make sure the stuff is properly aligned
            if (!PAGEOFF(pAddress))
            {
                if (!PAGEOFF(uSize))
                {
                    m_pAddress = pAddress;
                    rmStatus = RM_OK;
                }
            }
        }
        break;
    
    case AUDIO_CONTEXT_DMA_GPNOTIFIER:
    case AUDIO_CONTEXT_DMA_EPNOTIFIER:
        {
            // just make sure the address is 4K aligned and the size
            // is max 4K
            if (m_uSize <= 4096)
            {
                rmStatus = aosGetPhysicalAddress(pAddress, m_uSize, &m_pAddress);
                if (rmStatus == RM_OK)
                {
                    m_pLinAddr = pAddress;
                    if (PAGEOFF(m_pAddress))
                        rmStatus = RM_ERROR;
                }
            }
        }
        break;

    case AUDIO_CONTEXT_DMA_FENOTIFIER:
        {
            // convert the address to physical
            rmStatus = aosGetPhysicalAddress(pAddress, m_uSize, &m_pAddress);
            if (rmStatus == RM_OK)
            {
                m_pLinAddr = pAddress;

                // has to be 256 byte aligned..
                if (((U032)m_pAddress) & 0xFF)
                    rmStatus = RM_ERROR;        // alignment fails
            }
        }
        break;

    default:
        break;
    }

    return rmStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CEPMethod.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CEPMethod.h                                                     *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CEPMETHODH_
#define _CEPMETHODH_

#define METHOD_MIN_OFFSET(x)       (x)
#define METHOD_MAX_OFFSET(x)       ((x) + 0x4)

class CHalBase;
class CHalExtendedProc;

class CEPMethod
{
public:
    CEPMethod(CHalBase *pHal, CHalExtendedProc *pProc) 
    { 
        m_pHal = pHal;
        m_pProc = pProc;
        m_uCurrSge = 0;
        m_uBaseAddr = 0;
        m_uMaxOffset = 0;
    }

    ~CEPMethod() { };

public:
    RM_STATUS Execute(U032 uOffset, U032 uData);

private:
    CHalBase            *m_pHal;
    CHalExtendedProc    *m_pProc;

    // SW methods
    RM_STATUS SetCurrentSge(U032 uData);
    RM_STATUS SetSgeBaseAddr(U032, U032);
    RM_STATUS SetSgeLength(U032, U032);
    RM_STATUS SetContextDMA(U032);
    RM_STATUS SetSgeOffset(U032);
    RM_STATUS SetState(U032);
    RM_STATUS SetAC3Fifo(U032);

    // utility
    VOID GetBaseAndEnd(U032 uIndex, U032 *pBase, U032 *pEnd);
    VOID GetBaseCurEnd(U032 uIndex, U032 *pBase, U032 *pCur, U032 *pEnd);
    BOOL CheckRange(U032 uOffset, U032 uMethodOffset)   
    { 
        return ((uOffset >= METHOD_MIN_OFFSET(uMethodOffset)) && 
                (uOffset < METHOD_MAX_OFFSET(uMethodOffset))?TRUE:FALSE);
    }

    // variables equiv of some GP regs
    U032    m_uCurrSge;
    U032    m_uBaseAddr;
    U032    m_uMaxOffset;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CEPDspProgram.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CEPDspProgram.h                                                   *
*	interface for accessing DSP program information  for GP                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CEPDSPPROGRAMH_
#define _CEPDSPPROGRAMH_

// reserve the last one for AC-3
#define AC3_EFFECT_INDEX        (MAX_EFFECTS - 1)

#define AC3_SUPREXECBASE        0x000
#define AC3_LOADERBASE          0x180
#define AC3_LOADERTABLEBASE     0x100 // xxxxx temp 0x2C0 until dolby modifies their code
#define AC3_DOLBYBASE           0x300

#define AC3_MAX_PROGRAMS        4

#define AC3_HEAPLENGTH          8192  // length in words

typedef struct
{
    // the entries in this table are actually all 24-bit DSP words, but when
    // we store DSP code in system memory, we extend each word to fill 32 bits,
    // so we can store them in U032S.  
    U032 tableSize;         // table size                  
    U032 maxProgs;          // number of programs

    struct
    {
        U032 ptr;
        U032 size;
    } prog[AC3_MAX_PROGRAMS];

    U032 pcm_ptr;              // pointer to input PCM buffer
    U032 pcm_size;             // size of input PCM buffer
    U032 ltrt_ptr;             // pointer to output Lt/Rt buffer  (Note: actually a FIFO index!!)
    U032 ltrt_size;            // size of output Lt/Rt buffer
    U032 ac3_ptr;              // pointer to output AC-3 buffer   (Note: actually a FIFO index!!)
    U032 ac3_size;             // size of output AC-3 buffer
    U032 config_ptr;           // pointer to config table
    U032 config_size;          // size of config table
    U032 pingpong_offset;      // current pingpong buffer offset
    U032 reserved1;
    U032 ac3_zero_fill;        // AC3 zero fill (Note: actually a FIFO index!!)
    U032 reserved2;
    U032 ac3_preamble;         // AC3 preamble (Note: actually a FIFO index!!)
    U032 reserved3;
    U032 heap_ptr;             // pointer to heap data buffer
    U032 heap_size;            // size of heap data buffer
} DOLBY_LOADER_TABLE;


#define DOLBY_LOADER_TABLE_OFFSET(x)    (U032)&(((DOLBY_LOADER_TABLE *)0)->x)

class CDspProgram;

class CEPDspProgram : public CDspProgram
{
public:
    VOID Initialize();

    // AC3 functions
    U032 AC3GetTotalScratchSize();
    VOID AC3GetSuperExec(VOID_PTR *ppData, U032 *pLength, U032 *pBase);
    VOID AC3GetLoader(VOID_PTR *ppData, U032 *pLength, U032 *pBase);
    VOID AC3GetProgram(U032 uIndex, VOID_PTR *ppData, U032 *pLength);
    
    VOID_PTR AC3GetConfigTable();
    
    U032 AC3GetLoaderTableBase() { return AC3_LOADERTABLEBASE; }
    U032 AC3GetProgramBase()     { return AC3_DOLBYBASE;       }
    U032 AC3GetMaxPrograms()     { return AC3_MAX_PROGRAMS;    }
    U032 AC3GetHeapLength()      { return AC3_HEAPLENGTH;      }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\ccommandq.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch Qs*************************\
*                                                                           *
* Module: CCommandQ.h														*
*   Object to command Q reads												*
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CCOMMANDQH_
#define _CCOMMANDQH_

#define COMMAND_Q_SIZE      0x1000
#define COMMAND_Q_INCR      0x4
#define COMMAND_Q_INCREMENT(x)   (x) = ((x) + COMMAND_Q_INCR) & (COMMAND_Q_SIZE -1)

class CHalBase;

class CCommandQ
{
public:
    enum Q_TYPE
    {
        Q_TYPE_EP,
        Q_TYPE_GP
    };

    CCommandQ(CHalBase *pHal)
    {
        m_uPut = 0;
        m_uGet = 0;
        m_CommandQ.pLinAddr = NULL;
        m_CommandQ.Size = COMMAND_Q_SIZE;
        m_pHal = pHal;
    }
    ~CCommandQ();

    RM_STATUS Initialize(Q_TYPE);
    BOOL Read(U032 *);

    VOID *GetLinAddr() { return m_CommandQ.pLinAddr; }
    
private:
    // register offsets
    U032        m_uPut;
    U032        m_uGet;
    U032        m_uQ;

    MEM_DESC    m_CommandQ;
    CHalBase    *m_pHal;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CContextDma.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: CContextDma.h                                                   *
*   The MCPX HAL DMA engine implementation is provided in this module.      *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CCONTEXTDMAH_
#define _CCONTEXTDMAH_

class CLinkList;

class CContextDma : public CLinkList
{
public:
    RM_STATUS Initialize(VOID *pAddress, U032 uSize, U032 uType);

    VOID *GetAddress() { return m_pAddress; }
    U032 GetSize()  { return m_uSize; }
    U032 GetType()  { return m_uType; }
    VOID *GetLinAddr()  { return m_pLinAddr; }

private:
    VOID *m_pAddress;
    U032 m_uSize;
    U032 m_uType;       // type of the dma - this is prob redundant
    VOID *m_pLinAddr;   // only used for GP/EP notifiers
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CDspProgram.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CDspProgram.h                                                     *
*	interface for accessing DSP program information                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CDSPPROGRAMH_
#define _CDSPPROGRAMH_

class CDspProgram
{
public:
    CDspProgram()
    {
        m_pLoader = NULL;
        m_uLoaderSize = 0;

        for (U032 uCnt = 0; uCnt < MAX_EFFECTS; uCnt++)
        {
            m_Effect[uCnt].pCode = NULL;
            m_Effect[uCnt].uCodeSize = 0;
            m_Effect[uCnt].uDelaySize = 0;
        }
    }
    
    virtual VOID Initialize() = 0;

    VOID_PTR    GetLoader() { return m_pLoader; }
    U032        GetLoaderSize() { return m_uLoaderSize; }
    
    VOID_PTR    GetCode(U032 uIndex) { return ((uIndex < MAX_EFFECTS)?(m_Effect[uIndex].pCode):NULL); }
    U032        GetDelayLineSize(U032 uIndex) { return ((uIndex < MAX_EFFECTS)?(m_Effect[uIndex].uDelaySize):0); }
    U032        GetCodeSize(U032 uIndex) { return ((uIndex < MAX_EFFECTS)?(m_Effect[uIndex].uCodeSize):0); }

protected:
    struct
    {
        VOID_PTR pCode;
        U032 uCodeSize;
        U032 uDelaySize;
    } m_Effect[MAX_EFFECTS];

    VOID_PTR    m_pLoader;
    U032        m_uLoaderSize;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CEPMethod.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CEPMethod.cpp                                                     *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv_uep.h>
#include <nv_papu.h>
#include <nv32.h>
#include <AudioHw.h>
};
#include <aos.h>
#include <ahal.h>

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalExtendedProc.h"
#include <CLinkList.h>
#include "CContextDma.h"
#include "CScratchManager.h"
#include "CEPScratchManager.h"
#include "CEPMethod.h"

RM_STATUS
CEPMethod::Execute(U032 uOffset, U032 uData)
{
    RM_STATUS rmStatus = RM_ERROR;

    do
    {
        if (CheckRange(uOffset, NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE))
        {
            rmStatus = SetCurrentSge(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BAE_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA))
        {
            rmStatus = SetContextDMA(uData);
            break;
        }
        
        if (CheckRange(uOffset, NV1BAE_PIO_SET_STATE))
        {
            rmStatus = SetState(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BAE_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET))
        {
            rmStatus = SetSgeOffset(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BAE_PIO_SET_AC3_FIFO))
        {
            rmStatus = SetAC3Fifo(uData);
            break;
        }

        U032 uCnt = 0;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if ( CheckRange(uOffset, (NV1BAE_PIO_SET_OUTBUF_BA(uCnt))) )
            {
                rmStatus = SetSgeBaseAddr(uData, uCnt);
                break;
            }
        }
        
        if (uCnt != 4)
            break;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if ( CheckRange(uOffset, (NV1BAE_PIO_SET_OUTBUF_LEN(uCnt))) )
            {
                rmStatus = SetSgeLength(uData, uCnt);
                break;
            }
        }

        if (uCnt != 4)
            break;

        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CEPMethod::Execute - SW method not yet implemented!\n");

#if defined WDM
        KdPrint(("Method offset = 0x%x Method Data = 0x%x\n", uOffset, uData));
#endif

    } while (FALSE);
    
    return rmStatus;
}

RM_STATUS
CEPMethod::SetCurrentSge(U032 uData)
{
    // todo vik - check against the max PRDs allocated on EP init

    // HW indexes are 0 based
    m_uCurrSge = uData;

    return RM_OK;
}


RM_STATUS
CEPMethod::SetContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CEPMethod::SetContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }
    
    m_uBaseAddr = (U032)pDma->GetAddress();
    m_uMaxOffset = (U032)pDma->GetSize();

    return RM_OK;
}

RM_STATUS
CEPMethod::SetSgeOffset(U032 uData)
{
    if (!m_uMaxOffset)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CEPMethod::SetSgeOffset - context DMA is not valid\n");
        // context DMA not valid
        return RM_ERROR;
    }

    if (uData > m_uMaxOffset)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CEPMethod::SetSgeOffset - exceeds max offset\n");
        // bad argument
        return RM_ERROR;
    }

    
    MCP1_PRD *pPrd = (MCP1_PRD *)(m_pProc->GetSgeOutLinAddr());

    pPrd[m_uCurrSge].uAddr = m_uBaseAddr + uData;
    pPrd[m_uCurrSge].Control.uValue = 0;
    pPrd[m_uCurrSge].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;

    return RM_OK;
}

RM_STATUS
CEPMethod::SetSgeBaseAddr(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffCur;
    U032 uOffEnd;
    
    GetBaseCurEnd(uIndex, &uOffBase, &uOffCur, &uOffEnd);

    m_pHal->RegWrite(uOffBase, uData);
    m_pHal->RegWrite(uOffCur, uData);
    m_pHal->RegWrite(uOffEnd, uData+256);

    return RM_OK;
}

RM_STATUS
CEPMethod::SetSgeLength(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffEnd;

    GetBaseAndEnd(uIndex, &uOffBase, &uOffEnd);
    
    U032 uBaseAddr;
    m_pHal->RegRead(uOffBase, &uBaseAddr);

    m_pHal->RegWrite(uOffEnd, uBaseAddr + uData);
    
    return RM_OK;
}

RM_STATUS 
CEPMethod::SetState(U032 uData)
{
    R_EP_RESET rReset;
    rReset.uValue = 0;
    R_GP_CONTROL rControl;
    rControl.uValue = 0;


    if (uData)
    {
        // take it out of reset...
        rReset.Global = NV_PAPU_EPRST_EPRST_DISABLED;
        rReset.DSP = NV_PAPU_EPRST_EPDSPRST_ENABLED;
        rReset.NMI = NV_PAPU_EPRST_EPNMI_DISABLED;
        rReset.Abort = NV_PAPU_EPRST_EPABORT_DISABLED;

        m_pHal->RegWrite(NV_PAPU_EPRST, rReset.uValue);


        // auto start and auto idle
        R_GPDMA_CONFIG rConfig;
        rConfig.uValue = 0;
        //rConfig.Start = NV_PAPU_EPDCFG_GPDASTRT_ENABLED;
        //rConfig.Ready = NV_PAPU_EPDCFG_GPDARDY_ENABLED;
        m_pHal->RegWrite(NV_PAPU_EPDCFG, rConfig.uValue);
        
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CEPMethod::SetEPState - the EP might just start...");
        // enable the EP

        rControl.Idle = NV_PAPU_EPIDRDY_EPSETIDLE_SET;
        rControl.IntrNotify = NV_PAPU_EPIDRDY_EPSETNINT_NOT_SET;
    }
    else
    {
        // stop the EP
        rReset.Global = NV_PAPU_EPRST_EPRST_DISABLED;
        rReset.DSP = NV_PAPU_EPRST_EPDSPRST_ENABLED;
        rReset.NMI = NV_PAPU_EPRST_EPNMI_DISABLED;
        rReset.Abort = NV_PAPU_EPRST_EPABORT_DISABLED;

        m_pHal->RegWrite(NV_PAPU_EPRST, rReset.uValue);
    }

    m_pHal->RegWrite(NV_PAPU_EPIDRDY, rControl.uValue);
    
    // clear the GPISTS bit
    m_pHal->RegWrite(NV_PAPU_EPISTS, (U032)0xff);

    // reset just the DSP core...
    /*
    R_GP_RESET rReset;
    rReset.uValue = 0;
    rReset.Global = NV_PAPU_EPRST_EPRST_DISABLED;
    rReset.DSP = NV_PAPU_EPRST_EPDSPRST_DISABLED;
    rReset.NMI = NV_PAPU_EPRST_EPNMI_DISABLED;
    rReset.Abort = NV_PAPU_EPRST_EPABORT_DISABLED;
    // u need to do this only when the program is in and all that
    m_pHal->RegWrite(NV_PAPU_EPRST, rReset.uValue);
    */

    m_pHal->RegWrite(NV_PAPU_EPRST, uData);


    aosDbgPrintString(DEBUGLEVEL_ERRORS, "done.  Congratulations!\n");
    return RM_OK;
}

RM_STATUS 
CEPMethod::SetAC3Fifo(U032 uData)
{
    RM_STATUS rmStatus = RM_ERROR;
    
    union
    {
        struct
        {
            U032 analog : 3;
            U032 digital : 3;
            U032 res : 26;
        } fields;

        U032 uVal;
    } Data;

    Data.uVal = uData;
    
    // some error checking
    if ( (Data.fields.analog > 3) || (Data.fields.digital > 3) )
    {
        // bad argumnet
        return RM_ERROR;
    }

    U032 uBaseAddr, uEndAddr;
    U032 uBaseVal, uEndVal;

    // get the analog fifo index
    GetBaseAndEnd(Data.fields.analog, &uBaseAddr, &uEndAddr);

    m_pHal->RegRead(uBaseAddr, &uBaseVal);
    m_pHal->RegRead(uEndAddr, &uEndVal);
    
    // update the loader table
    rmStatus = m_pProc->GetEPScratchManager()->AC3SetAnalogOutput(Data.fields.analog, (uEndVal - uBaseVal));
    //rmStatus = m_pProc->GetEPScratchManager()->AC3SetAnalogOutput(uBaseVal, (uEndVal - uBaseVal));
    if (rmStatus != RM_OK)
        return rmStatus;

    // get the digital fifo index
    GetBaseAndEnd(Data.fields.digital, &uBaseAddr, &uEndAddr);

    m_pHal->RegRead(uBaseAddr, &uBaseVal);
    m_pHal->RegRead(uEndAddr, &uEndVal);
    
    // update the loader table
    return m_pProc->GetEPScratchManager()->AC3SetDigitalOutput(Data.fields.digital, (uEndVal - uBaseVal));
    //return m_pProc->GetEPScratchManager()->AC3SetDigitalOutput(uBaseVal, (uEndVal - uBaseVal));
}


// utility functions
VOID
CEPMethod::GetBaseAndEnd(U032 uIndex, U032 *pBase, U032 *pEnd)
{
    switch(uIndex)
    {
    case 0:
        *pBase = NV_PAPU_EPOFBASE0;
        *pEnd = NV_PAPU_EPOFEND0;
        break;
    case 1:
        *pBase = NV_PAPU_EPOFBASE1;
        *pEnd = NV_PAPU_EPOFEND1;
        break;
    case 2:
        *pBase = NV_PAPU_EPOFBASE2;
        *pEnd = NV_PAPU_EPOFEND2;
        break;
    case 3:
        *pBase = NV_PAPU_EPOFBASE3;
        *pEnd = NV_PAPU_EPOFEND3;
        break;
    }
}


// utility functions
VOID
CEPMethod::GetBaseCurEnd(U032 uIndex, U032 *pBase, U032 *pCur, U032 *pEnd)
{
    switch(uIndex)
    {
    case 0:
        *pBase = NV_PAPU_EPOFBASE0;
        *pCur = NV_PAPU_EPOFCUR0;
        *pEnd = NV_PAPU_EPOFEND0;
        break;
    case 1:
        *pBase = NV_PAPU_EPOFBASE1;
        *pCur = NV_PAPU_EPOFCUR1;
        *pEnd = NV_PAPU_EPOFEND1;
        break;
    case 2:
        *pBase = NV_PAPU_EPOFBASE2;
        *pCur = NV_PAPU_EPOFCUR2;
        *pEnd = NV_PAPU_EPOFEND2;
        break;
    case 3:
        *pBase = NV_PAPU_EPOFBASE3;
        *pCur = NV_PAPU_EPOFCUR3;
        *pEnd = NV_PAPU_EPOFEND3;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CEPScratchManager.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch***************************\
*                                                                           *
* Module: CEPScratchManager.cpp                                              *
*   Object to handle all RM-GP conversations via the scracth memory         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv32.h>
#include <aos.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalGlobalProc.h"
#include "CScratchDma.h"
#include "CScratchManager.h"
#include "CEPScratchManager.h"
#include "CDspProgram.h"
#include "CEPDspProgram.h"

#define MAX_SIZE_SCRATCH_EP     65536

#define AC3_BUFFER_COUNT        2      // so we can ping-pong
#define AC3_FRAME_SIZE          256
#define AC3_CONTAINER_SIZE      4
#define AC3_NUM_CHANNELS        6
#define AC3_NUM_INPUT_PAGES     ((AC3_BUFFER_COUNT * AC3_FRAME_SIZE * AC3_CONTAINER_SIZE * AC3_NUM_CHANNELS) + PAGE_SIZE-1)  / PAGE_SIZE

CEPScratchManager::CEPScratchManager(CHalBase *pHal)
{
    m_pHal = pHal;
    m_pGlobalProc = NULL;
    m_pDspProgram = NULL;
}

CEPScratchManager::~CEPScratchManager()
{
    
    // if this was an AC-3 party, then stop it at the GP
    if (m_pGlobalProc)
        AC3StopGpInput();

    Shutdown();

    CScratchDma *pScratchDma = GetScratchDma();
    if (pScratchDma)
    {
        VOID *pScratchTable = pScratchDma->GetScratchTableLinAddr();
        aosFreeMem(pScratchTable);
        delete pScratchDma;
    }
}


RM_STATUS   
CEPScratchManager::Initialize(VOID_PTR pLoader, U032 uLoaderSize)
{
    // allocate the scratch Dma
    CScratchDma *pScratchDma = new CScratchDma(m_pHal, NV_PAPU_EPSMAXSGE);
    if (!pScratchDma)
        return RM_ERROR;

    // 	configure the HW
    VOLU32 vTemp = (MAX_SIZE_SCRATCH_EP/PAGE_SIZE);
	m_pHal->RegWrite(NV_PAPU_EPSMAXSGE, LOW16(vTemp));
	m_pHal->RegRead(NV_PAPU_EPSMAXSGE, &vTemp);

    MEM_DESC ScratchTable;

    ScratchTable.Size = (vTemp + 1)*NV_PSGE_SIZE;

    // allocate the scratch table - PRDs for the max size
    RM_STATUS rmStatus = aosAllocateMem(ScratchTable.Size,
						                ALIGN_16K,
						                &ScratchTable.pLinAddr,
						                &ScratchTable.pPhysAddr);

    if (rmStatus != RM_OK)
        return rmStatus;

    m_pHal->RegWrite(NV_PAPU_EPSADDR, (U032) ScratchTable.pPhysAddr);
    
    rmStatus = pScratchDma->Initialize(&ScratchTable);
    if (rmStatus != RM_OK)
        return rmStatus;
    
    // if everything is good till now.. initialize the base object
    CScratchManager::SetScratchDma(pScratchDma);
    //rmStatus = CScratchManager::Initialize(pLoader, uLoaderSize);

    return rmStatus;
}

// this initialize is for AC3 configuration
RM_STATUS   
CEPScratchManager::Initialize(CEPDspProgram *pProgram, CHalGlobalProc *pGlobalProc)
{
    // allocate the scratch Dma
    CScratchDma *pScratchDma = new CScratchDma(m_pHal, NV_PAPU_EPSMAXSGE);
    if (!pScratchDma)
        return RM_ERROR;
    
    m_pGlobalProc = pGlobalProc;
    m_pDspProgram = pProgram;

    // total pages required
    U032 uPagesRequired = (m_pDspProgram->AC3GetTotalScratchSize()+PAGE_SIZE-1) / PAGE_SIZE;

    // 256 frames 4 bytes per frame 6 channels = 1.5 pages so add 2 pages
    uPagesRequired += AC3_NUM_INPUT_PAGES;

    U032 uPagesAvail;

	// find out if HW supports the max indexes (index = pages - 1)
    m_pHal->RegWrite(NV_PAPU_EPSMAXSGE, LOW16(uPagesRequired - 1));
	m_pHal->RegRead(NV_PAPU_EPSMAXSGE, &uPagesAvail);

    if (uPagesAvail != LOW16(uPagesRequired - 1))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CEPScratchManager::Initialize - PRDs not available for fixed effect\n");
        return RM_ERROR;
    }


    MEM_DESC ScratchTable;

    ScratchTable.Size = uPagesRequired * NV_PSGE_SIZE;

    // allocate the scratch table - PRDs for the max size
    RM_STATUS rmStatus = aosAllocateMem(ScratchTable.Size,
						                ALIGN_16K,
						                &ScratchTable.pLinAddr,
						                &ScratchTable.pPhysAddr);

    if (rmStatus != RM_OK)
        return rmStatus;

    m_pHal->RegWrite(NV_PAPU_EPSADDR, (U032) ScratchTable.pPhysAddr);
    
    rmStatus = pScratchDma->Initialize(&ScratchTable);
    if (rmStatus != RM_OK)
        return rmStatus;
    
    CScratchManager::SetScratchDma(pScratchDma);
    
    U032 uOffset;
    // allocate space for AC3...
    rmStatus = pScratchDma->Allocate(uPagesRequired * PAGE_SIZE, &uOffset);
    if (rmStatus != RM_OK)
        return rmStatus;
    
    // sanity check!
    if (uOffset)
        aosDbgBreakPoint();

    // now that we have the memory allocated
    VOID_PTR pCode;
    U032 uLength; // in words
    U032 uBase;   // in words
    
    // superexec
    m_pDspProgram->AC3GetSuperExec(&pCode, &uLength, &uBase);
    pScratchDma->Write(uBase*sizeof(U032), (VOID *)pCode, uLength*sizeof(U032));

    // loader
    m_pDspProgram->AC3GetLoader(&pCode, &uLength, &uBase);
    pScratchDma->Write(uBase*sizeof(U032), (VOID *)pCode, uLength*sizeof(U032));

    // loader table
    DOLBY_LOADER_TABLE LoaderTable;


    LoaderTable.tableSize = sizeof(DOLBY_LOADER_TABLE) / sizeof(U032);
    LoaderTable.maxProgs = m_pDspProgram->AC3GetMaxPrograms();

    // now copy the four Dolby encoder programs into system memory so the DSP can
    // DMA them when it needs them.  Keep track of the current offset into the
    // buffer, and update the loader table with the addresses as we go along.
    uBase = m_pDspProgram->AC3GetProgramBase();
    
    U032 uCnt;
    for (uCnt = 0; uCnt < m_pDspProgram->AC3GetMaxPrograms(); uCnt++)
    {
        // get program
        m_pDspProgram->AC3GetProgram(uCnt, &pCode, &uLength);

        // copy into scratch 
        pScratchDma->Write(uBase*sizeof(U032), (VOID *)pCode, uLength*sizeof(U032));

        // update the loader table
        LoaderTable.prog[uCnt].ptr  = uBase;
        LoaderTable.prog[uCnt].size = uLength;

        // update the current scratch index
        uBase += uLength;
    }

    // now the config table
    U032 *pConfig = (U032 *)m_pDspProgram->AC3GetConfigTable();
     // Note: the AC3 config table is actually a DOLBY_CONFIG_TABLE,
     // not a U032...  The size is contained in the first word of the
     // table, so we will treat it here as a U032 array.
    uLength = pConfig[0];
    LoaderTable.config_ptr  = uBase;
    LoaderTable.config_size = uLength;
    pScratchDma->Write(uBase*sizeof(U032), (VOID *)pConfig, uLength*sizeof(U032));
    uBase += uLength;
    
    //Init pingpong buffer offset
    LoaderTable.pingpong_offset = 0;
    LoaderTable.reserved1 = 0;
    LoaderTable.reserved2 = 0;
    LoaderTable.reserved3 = 0;
    
    // now for the heap
    uLength = m_pDspProgram->AC3GetHeapLength();
    LoaderTable.heap_ptr  = uBase;
    LoaderTable.heap_size = uLength;
    uBase += uLength;
    
    // copy the table to the offset
    pScratchDma->Write(sizeof(U032)*m_pDspProgram->AC3GetLoaderTableBase(), (VOID *)&LoaderTable, sizeof(DOLBY_LOADER_TABLE));

    return AC3StartGpInput((uPagesRequired - AC3_NUM_INPUT_PAGES) * PAGE_SIZE);
}



RM_STATUS
CEPScratchManager::AC3StartGpInput(U032 uLinOffset)
{
    if (!m_pGlobalProc)
        return RM_ERROR;

    // use the last n pages for ac-3 input from the GP
    MEM_DESC mem[AC3_NUM_INPUT_PAGES];
    
    U032 uOffset = m_pDspProgram->AC3GetLoaderTableBase() * sizeof(U032);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(pcm_ptr), uLinOffset/sizeof(U032));  
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(pcm_size), AC3_FRAME_SIZE * AC3_NUM_CHANNELS);

    // program the same pages in the GP
    for (U032 uCnt = 0; uCnt < AC3_NUM_INPUT_PAGES; uCnt++)
    {
        mem[uCnt].pLinAddr = GetScratchDma()->GetLinAddr(uLinOffset);
        mem[uCnt].pPhysAddr = GetScratchDma()->GetPhysAddr(uLinOffset);
        mem[uCnt].Size = PAGE_SIZE;
        uLinOffset += mem[uCnt].Size;
    }
    
    return m_pGlobalProc->AC3SetOutputBuffer(mem, AC3_NUM_INPUT_PAGES);
}

VOID
CEPScratchManager::AC3StopGpInput()
{
    if (!m_pGlobalProc)
        return;

    MEM_DESC mem[AC3_NUM_INPUT_PAGES];

    // update the loader table
    U032 uOffset = GetScratchDma()->Get( (m_pDspProgram->AC3GetLoaderTableBase()* sizeof(U032)) + DOLBY_LOADER_TABLE_OFFSET(pcm_ptr));

    // program the same pages in the GP
    for (U032 uCnt = 0; uCnt < AC3_NUM_INPUT_PAGES; uCnt++)
    {
        mem[uCnt].pLinAddr = GetScratchDma()->GetLinAddr(uOffset*sizeof(U032));
        mem[uCnt].pPhysAddr = GetScratchDma()->GetPhysAddr(uOffset*sizeof(U032));
        mem[uCnt].Size = PAGE_SIZE;
        uOffset += mem[uCnt].Size;
    }    
    m_pGlobalProc->AC3RemoveOutputBuffer(mem, AC3_NUM_INPUT_PAGES);
}

RM_STATUS
CEPScratchManager::AC3SetAnalogOutput(U032 uAnalogFIFO, U032 uSize)
{
    if (!m_pGlobalProc)
        return RM_ERROR;

    U032 uOffset = m_pDspProgram->AC3GetLoaderTableBase() * sizeof(U032);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ltrt_ptr), uAnalogFIFO);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ltrt_size), uSize/sizeof(U032));

    return RM_OK;
}

RM_STATUS
CEPScratchManager::AC3SetDigitalOutput(U032 uDigitalFIFO, U032 uSize)
{
    if (!m_pGlobalProc)
        return RM_ERROR;

    U032 uOffset = m_pDspProgram->AC3GetLoaderTableBase() * sizeof(U032);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_ptr), uDigitalFIFO);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_zero_fill), uDigitalFIFO);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_preamble), uDigitalFIFO);
    GetScratchDma()->Put(uOffset + DOLBY_LOADER_TABLE_OFFSET(ac3_size), uSize/sizeof(U032));

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\cgpmethod.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CGpMethod.cpp                                                       *
*     SW functions for the GP                                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
#include <aos.h>
#include <nv_ugp.h>
#include <nv32.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CDspProgram.h"
#include "CGPDspProgram.h"
#include "CScratchManager.h"
#include "CScratchDma.h"
#include "CGpScratchManager.h"
#include "CHalGlobalProc.h"
#include <CLinkList.h>
#include "CCommandQ.h"
#include "CContextDma.h"
#include "CMixerBuffer.h"
#include "CGpMethod.h"
#include "AudioFx.h"

CGPMethod::CGPMethod(CHalGlobalProc *pProc, CGPScratchManager *pMgr, CGPDspProgram *pDsp, CHalBase *pHal)
{
    m_pScratchManager = pMgr;
    m_uActiveEffect = 0;
    m_pDspProgram = pDsp;
    m_pHal = pHal;
    m_pGlobalProc = pProc;
    m_pCommandQ = NULL;
    m_pAudioFx = NULL;
    m_pMixerBuffer = NULL;
    
    m_ExecutionList.uCount = 0;

    for (U032 uCnt = 0; uCnt < MAX_EFFECTS; uCnt++)
    {
        m_EffectInfo[uCnt].eState = FREE;
        m_EffectInfo[uCnt].pParamDma = NULL;

        // initialize the execution list
        m_ExecutionList.uEffects[uCnt] = kAudioFxModule_EmptyID;
    }

}


CGPMethod::~CGPMethod()
{
    if (m_pAudioFx)
        delete m_pAudioFx;

    if (m_pCommandQ)
        delete m_pCommandQ;

    if (m_pMixerBuffer)
        delete m_pMixerBuffer;

    m_pAudioFx = NULL;
    m_pCommandQ = NULL;
    m_pMixerBuffer = NULL;
}

RM_STATUS
CGPMethod::Initialize()
{
    RM_STATUS rmStatus = RM_ERROR;

    m_pCommandQ = new CCommandQ(m_pHal);
    if (m_pCommandQ)
        rmStatus = m_pCommandQ->Initialize(CCommandQ::Q_TYPE_GP);

    m_pAudioFx = new AUDIOFX(MAX_EFFECTS, m_pScratchManager->GetScratchDma());
    if (!m_pAudioFx)
        rmStatus = RM_ERROR;
    else
    {
        m_pMixerBuffer = new CMixerBuffer;
        if (!m_pMixerBuffer)
            rmStatus = RM_ERROR;
    }

    return rmStatus;
}

VOID *
CGPMethod::GetCommandQAddress() 
{ 
    return m_pCommandQ->GetLinAddr();
}

VOID
CGPMethod::Execute()
{
    RM_STATUS rmStatus;
    U032 uMethod;
    U032 uData;
    BOOL bWriteNotifier = FALSE;
    BOOL bQEmpty = FALSE;
    U032 uNotifierData;
    U032 uNotifierStatus;
    U032 uFifoNumber;
    U032 uSize;

    while (!bQEmpty)
    {
        m_pCommandQ->Read(&uMethod);

        bQEmpty = m_pCommandQ->Read(&uData);

        uNotifierStatus = 0;
        uFifoNumber = ~0;

        // execute the methods
        switch(uMethod)
        {
        case NV_AUDGP_REGISTER_EFFECT:
            uNotifierData = (U032)m_pAudioFx->RegisterModuleType((AUDIOFX_PLUGIN *)uData);
            bWriteNotifier = TRUE;
            break;

        case NV_AUDGP_ADD_EFFECT:
		// FIXXXX: this will temporarily get around the check-in.  Fix !!!!
            uNotifierData = (U032)m_pAudioFx->AddModule("IIR2");
            bWriteNotifier = TRUE;
            break;

        case NV_AUDGP_SET_CURRENT_EFFECT:
            rmStatus = SetCurrentEffect(uData);
            break;

        case NV_AUDGP_ROUTE_EFFECT:
            {
                STRUCT_ROUTE_EFFECT rRouteEffect;
                rRouteEffect.uValue = uData;
            
                U032 uBufID;
                if (rRouteEffect.connection == NV_AUDGP_ROUTE_EFFECT_CONNECTION_ENABLE)
                    uBufID = rRouteEffect.bufid;
                else
                {
                    // a null id means the connection from the pin is null... but can there be a case 
                    // of one pin pointing to multiple buffers???  probably not... it'll need to go through
                    // a mixer...
                    uBufID = kAudioFX_BufferID_Null; 
                }

            
                if (rRouteEffect.orientation == NV_AUDGP_ROUTE_EFFECT_ORIENTATION_SOURCE)
                    m_pAudioFx->SetModule_OutBuffer(rRouteEffect.effectID, rRouteEffect.pin, uBufID);
                else
                    m_pAudioFx->SetModule_InBuffer(rRouteEffect.effectID, rRouteEffect.pin, uBufID);
            }
            break;

        case NV_AUDGP_ROUTE_TO_FIFO:
            {
                STRUCT_ROUTE_TO_FIFO rRoutoFifo;
                rRoutoFifo.uValue = uData;
            
                U032 uBufferID;

                // find the buffer ID
                if (rRoutoFifo.fifoType == NV_AUDGP_ROUTE_TO_FIFO_TYPE_INPUT)
                {
                    if (rRoutoFifo.fifoNum == 0)
                        uBufferID = kAudioFX_BufferID_FIFO0_Input;
                    else
                        uBufferID = kAudioFX_BufferID_FIFO1_Input;

                }
                else
                {
                    switch(rRoutoFifo.fifoNum)
                    {
                    case 0:
                        uBufferID = kAudioFX_BufferID_FIFO0_Output;
                        break;
                    case 1:
                        uBufferID = kAudioFX_BufferID_FIFO1_Output;
                        break;
                    case 2:
                        uBufferID = kAudioFX_BufferID_FIFO2_Output;
                        break;
                    case 3:
                        uBufferID = kAudioFX_BufferID_FIFO3_Output;
                        break;
                    default:
                        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CGPMethod::NV_AUDGP_ROUTE_TO_FIFO - only 4 output FIFOs!\n");
                        aosDbgBreakPoint();
                    }
                }

                uBufferID += (rRoutoFifo.fifoPin + 1);

                if (rRoutoFifo.connection == NV_AUDGP_ROUTE_TO_FIFO_CONNECTION_DISABLE)
                    uBufferID = kAudioFX_BufferID_Null;

                // so if it's an input fifo.. then does it feed an effect.. liek an input buffer?
                // it seems to be so...

                // now... i hope audiofx ignores inIndex (effect pin..), if it's a buffer, and not an effect
                if (rRoutoFifo.fifoType == NV_AUDGP_ROUTE_TO_FIFO_TYPE_INPUT)
                    m_pAudioFx->SetModule_InBuffer(rRoutoFifo.sourceID, rRoutoFifo.sourcePin, uBufferID);
                else
                    m_pAudioFx->SetModule_OutBuffer(rRoutoFifo.sourceID, rRoutoFifo.sourcePin, uBufferID);
            }
            break;

        case NV_AUDGP_QUERY_EFFECT:
            {
                STRUCT_QUERY_EFFECT rQueryEffect;
                rQueryEffect.uValue = uData;
                uNotifierData = (U032) m_pAudioFx->QueryModule(rQueryEffect.effectID, rQueryEffect.typeID);
                bWriteNotifier = TRUE;
            }
            break;

        case NV_AUDGP_DEREGISTER_EFFECT:
            m_pAudioFx->UnregisterModuleType(uData);
            break;

        case NV_AUDGP_GET_MIX_BUFFER:
            rmStatus = GetMixBuffer(uData, &uNotifierData);
            bWriteNotifier = TRUE;
            break;

        case NV_AUDGP_FREE_MIX_BUFFER:
            m_pMixerBuffer->Free((U008)uData);
            break;

        case NV_AUDGP_SET_CONTEXT_DMA_NOTIFIER:
            rmStatus = SetContextDmaNotifier(uData);
            break;
    
        case NV_AUDGP_SET_CONTEXT_DMA_PARAMETER:
            rmStatus = SetContextDmaParameter(uData);
            break;

        case NV_AUDGP_SET_CONTEXT_DMA_DSP_CODE:
            rmStatus = SetContextDmaDspCode(uData);
            break;

        case NV_AUDGP_UPDATE_EFFECT_PARAMETERS:
            {
                rmStatus = RM_ERROR;
                VOID *pParamData;
                U032 uEffectId = uData;

                // check if the context DMA for the effect params has been allocated
                if (m_EffectInfo[uEffectId].pParamDma)
                {
                    pParamData = m_EffectInfo[uEffectId].pParamDma->GetLinAddr();
                    m_pAudioFx->SetModule(uEffectId, pParamData);
                    rmStatus = RM_OK;
                }
            }
            break;

        case NV_AUDGP_ENABLE_EFFECT:
        case NV_AUDGP_DISABLE_EFFECT:
            UpdateExecutionList(uData, (uMethod==NV_AUDGP_ENABLE_EFFECT)?TRUE:FALSE);
            m_pAudioFx->SetModuleExecutionList((long *)&m_ExecutionList.uEffects[0], m_ExecutionList.uCount);
            break;
        
        case NV_AUDGP_DELETE_EFFECT:
            m_pAudioFx->DeleteModule(uData);
            break;


        case NV_AUDGP_SET_EXECUTION_LIST:
            U032 id;
            m_ExecutionList.uCount = uData;
            for(id =0;id < uData;id++)
                bQEmpty = m_pCommandQ->Read(&m_ExecutionList.uEffects[id]);
            m_pAudioFx->SetModuleExecutionList((long *)&m_ExecutionList.uEffects[0], m_ExecutionList.uCount);
            break;


        case NV_AUDGP_CONFIGURE_OUTPUT_FIFO(0):
        case NV_AUDGP_CONFIGURE_OUTPUT_FIFO(1):
        case NV_AUDGP_CONFIGURE_OUTPUT_FIFO(2):
        case NV_AUDGP_CONFIGURE_OUTPUT_FIFO(3):
        case NV_AUDGP_CONFIGURE_INPUT_FIFO(0):
        case NV_AUDGP_CONFIGURE_INPUT_FIFO(1):
            bQEmpty = m_pCommandQ->Read(&uData);
            ConfigureFifo(uMethod, uData);
            break;

        case NV_AUDGP_ALLOC_SCRATCH_MEMORY:
            m_pScratchManager->GetScratchDma()->Allocate(uData,&uNotifierData);
            bWriteNotifier = TRUE;
            break;

        case NV_AUDGP_FREE_SCRATCH_MEMORY:
            bQEmpty = m_pCommandQ->Read(&uSize);
            m_pScratchManager->GetScratchDma()->Free(uData,uSize);

        case NV_AUDGP_SET_SCRATCH_MEMORY:
            U032 uValue;
            m_pCommandQ->Read(&uSize);
            bQEmpty = m_pCommandQ->Read(&uValue);
            m_pScratchManager->GetScratchDma()->Put(uData, uSize, uValue);
            break;

        default:
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "CGPMethod::Execute - unknown method\n");
            break;
        }

        // write the notifier...
        if (bWriteNotifier)
            m_pGlobalProc->WriteNotifier(uMethod, uNotifierData, (U008)rmStatus);

    }
}


// gp methods handled by this class
RM_STATUS
CGPMethod::SetCurrentEffect(U032 uData)
{
    if (uData < MAX_EFFECTS)
    {
        m_uActiveEffect = uData;
        return RM_OK;
    }
    
    return RM_ERROR;
}


RM_STATUS
CGPMethod::SetContextDmaNotifier(U032 uData)
{
    RM_STATUS rmStatus = RM_OK;
    CContextDma *pDma = (CContextDma *)uData;
    
    // in debug mode... do some checks... todo vik
    m_pHal->RegWrite( NV_PAPU_GPNADDR, (U032)(pDma->GetAddress()) );

    // set the notifier memory in the GP
    m_pGlobalProc->SetNotifierMemory(pDma->GetLinAddr(), pDma->GetSize());
    return RM_OK;
}

RM_STATUS
CGPMethod::SetContextDmaParameter(U032 uData)
{
    // i dunno if i wanna check if the effect is allocated
    m_EffectInfo[m_uActiveEffect].pParamDma = (CContextDma *)uData;
    return RM_OK;
}


RM_STATUS
CGPMethod::SetContextDmaDspCode(U032 uData)
{
    // i dunno if i wanna check if the effect is allocated
    m_EffectInfo[m_uActiveEffect].pDspCodeDma = (CContextDma *)uData;
    return RM_OK;
}


RM_STATUS
CGPMethod::GetMixBuffer(U032 uArg, U032 *pId)
{
    RM_STATUS rmStatus = RM_ERROR;

    *pId = 0;

    if ( (0x3 & uArg) != NV_AUDGP_GET_MIX_BUFFER_TYPE_SW )
        rmStatus = m_pMixerBuffer->Allocate(m_pMixerBuffer->MIXER_TYPE::HW, (U008 *)pId);

    if (rmStatus == RM_ERROR)
        rmStatus = m_pMixerBuffer->Allocate(m_pMixerBuffer->MIXER_TYPE::SW, (U008 *)pId);

    return rmStatus;
}

VOID
CGPMethod::UpdateExecutionList(U032 uEffectID, BOOL bOption)
{
    if (bOption == (BOOL)TRUE)
    {
        m_ExecutionList.uEffects[m_ExecutionList.uCount++] = uEffectID;
        return;
    }
    else
    {
        // remove it from the execution list
        for (U032 uCnt = 0; uCnt < m_ExecutionList.uCount; uCnt++)
        {
            if (m_ExecutionList.uEffects[uCnt] == uEffectID)
            {
                for (U032 uCnt1 = uCnt; uCnt1 < m_ExecutionList.uCount-1; uCnt1++)
                    m_ExecutionList.uEffects[uCnt1] = m_ExecutionList.uEffects[uCnt1+1];

                m_ExecutionList.uCount--;
                return;
            }
        }

        // some crap has happened... cant find effect!
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "CGPMethod::UpdateExecutionList - cannot find method!\n");
    }
}

VOID
CGPMethod::ConfigureFifo(U032 uMethod, U032 uData)
{
    R_GP_CTLOUT rCtlOut;
    R_GP_CTLIN rCtlIn;

    U032 uRegOffset;
    U032 uRegValue;

    STRUCT_CONFIGURE_FIFO sConfigFifo;

    m_pHal->RegRead(NV_PAPU_GPCTLOUT, &rCtlOut.uValue);
    sConfigFifo.uValue = uData;
    
    U032 uContainerSize;
    if (sConfigFifo.size == NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_8_8)
        uContainerSize = NV_PAPU_GPCTLOUT_GD0SIZ_8;
    else if (sConfigFifo.size == NV_AUDGP_CONFIGURE_OUTPUT_FIFO_SIZE_32_32)
        uContainerSize = NV_PAPU_GPCTLOUT_GD0SIZ_32;
    else
        uContainerSize = NV_PAPU_GPCTLOUT_GD0SIZ_16;

    if (uMethod == NV_AUDGP_CONFIGURE_OUTPUT_FIFO(0))
    {
        rCtlOut.format0 = sConfigFifo.format;
        rCtlOut.type0 = sConfigFifo.type;
        rCtlOut.size0 = uContainerSize;
        uRegOffset = NV_PAPU_GPCTLOUT;
        uRegValue = rCtlOut.uValue;
        m_pAudioFx->SetOutputFIFOFormat(0, sConfigFifo.format, sConfigFifo.size);
    }
    else if (uMethod == NV_AUDGP_CONFIGURE_OUTPUT_FIFO(1))
    {
        rCtlOut.format1 = sConfigFifo.format;
        rCtlOut.type1 = sConfigFifo.type;
        rCtlOut.size1 = uContainerSize;
        uRegOffset = NV_PAPU_GPCTLOUT;
        uRegValue = rCtlOut.uValue;
        m_pAudioFx->SetOutputFIFOFormat(1, sConfigFifo.format, sConfigFifo.size);
    }
    else if (uMethod == NV_AUDGP_CONFIGURE_OUTPUT_FIFO(2))
    {
        rCtlOut.format2 = sConfigFifo.format;
        rCtlOut.type2 = sConfigFifo.type;
        rCtlOut.size2 = uContainerSize;
        uRegOffset = NV_PAPU_GPCTLOUT;
        uRegValue = rCtlOut.uValue;
        m_pAudioFx->SetOutputFIFOFormat(2, sConfigFifo.format, sConfigFifo.size);
    }
    else if (uMethod == NV_AUDGP_CONFIGURE_OUTPUT_FIFO(3))
    {
        rCtlOut.format3 = sConfigFifo.format;
        rCtlOut.type3 = sConfigFifo.type;
        rCtlOut.size3 = uContainerSize;
        uRegOffset = NV_PAPU_GPCTLOUT;
        uRegValue = rCtlOut.uValue;
        m_pAudioFx->SetOutputFIFOFormat(3, sConfigFifo.format, sConfigFifo.size);
    }
    else if (uMethod == NV_AUDGP_CONFIGURE_INPUT_FIFO(0))
    {
        rCtlIn.format0 = sConfigFifo.format;
        rCtlIn.type0 = sConfigFifo.type;
        rCtlIn.size0 = uContainerSize;
        uRegOffset = NV_PAPU_GPCTLIN;
        uRegValue = rCtlIn.uValue;
        m_pAudioFx->SetInputFIFOFormat(0, sConfigFifo.format, sConfigFifo.size);
    }
    else
    {
        rCtlIn.format1 = sConfigFifo.format;
        rCtlIn.type1 = sConfigFifo.type;
        rCtlIn.size1 = uContainerSize;
        uRegOffset = NV_PAPU_GPCTLIN;
        uRegValue = rCtlIn.uValue;
        m_pAudioFx->SetInputFIFOFormat(1, sConfigFifo.format, sConfigFifo.size);
    }
    
    m_pHal->RegWrite(uRegOffset, uRegValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\cgpdspprogram.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CGPDspProgram.cpp                                                 *
*	interface for accessing DSP program information                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv_ugp.h>
#include <AudioHw.h>
};

#include "CDspProgram.h"
#include "CGPDspProgram.h"

// all effects that can be loaded to the GP follow...

// the header files are generated at 
// build time... by the build batch file

// digital wire
static U032 WireDelaySize = 0;
static U032 Wire[] = 
{
#include <Wire.h>
};



VOID
CGPDspProgram::Initialize()
{
    m_uLoaderSize = 0;
    m_pLoader = NULL;

    // assign all the effects here

    // digital wire
    /*
    m_Effect[NV_AUDGP_SET_EFFECT_TYPE_TYPE_GENERICFX].pCode = (VOID_PTR)Wire;
    m_Effect[NV_AUDGP_SET_EFFECT_TYPE_TYPE_GENERICFX].uCodeSize = sizeof(Wire);
    m_Effect[NV_AUDGP_SET_EFFECT_TYPE_TYPE_GENERICFX].uDelaySize = WireDelaySize * sizeof(U032);
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CGpMethod.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CGpMethod.h                                                       *
*     SW functions for the GP                                               *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CGPMETHODH_
#define _CGPMETHODH_

class CGPScratchManager;
class CGPDspProgram;
class CHalBase;
class CHalGlobalProc;
class CCommandQ;
class CContextDma;
class CMixerBuffer;
class AUDIOFX;


class CGPMethod
{
public:
    CGPMethod(CHalGlobalProc *pProc, CGPScratchManager *pMgr, CGPDspProgram *pDsp, CHalBase *pHal);
    ~CGPMethod();

public:
    RM_STATUS   Initialize();
    VOID        Execute();
    VOID        *GetCommandQAddress();

private:
    CGPScratchManager   *m_pScratchManager;
    CGPDspProgram       *m_pDspProgram;
    CHalBase            *m_pHal;
    CHalGlobalProc      *m_pGlobalProc;
    CCommandQ           *m_pCommandQ;
    CMixerBuffer        *m_pMixerBuffer;
    AUDIOFX             *m_pAudioFx;
    
    U032    m_uActiveEffect;
    
    enum EFFECT_STATE
    {
        FREE = 0,
        ALLOCATED,
    };

    struct
    {
        EFFECT_STATE eState;
        CContextDma *pParamDma;
        CContextDma *pDspCodeDma;
    } m_EffectInfo[MAX_EFFECTS];
    
    struct
    {
        U032 uCount;
        U032 uEffects[MAX_EFFECTS];
    } m_ExecutionList;

    RM_STATUS GetMixBuffer(U032 uArg, U032 *pId);
    VOID UpdateExecutionList(U032 uEffectID, BOOL bOption);
    VOID ConfigureFifo(U032 uMethod, U032 uData);

    // software methods
    RM_STATUS SetCurrentEffect(U032 uData);
    RM_STATUS SetContextDmaNotifier(U032 uData);
    RM_STATUS SetContextDmaParameter(U032 uData);
    RM_STATUS SetContextDmaDspCode(U032 uData);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CGPDspProgram.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CGpDspProgram.h                                                   *
*	interface for accessing DSP program information  for GP                 *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CGPDSPPROGRAMH_
#define _CGPDSPPROGRAMH_

class CDspProgram;

class CGPDspProgram : public CDspProgram
{
public:
    VOID        Initialize();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CEPScratchManager.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch***************************\
*                                                                           *
* Module: CEPScratchManager.h                                               *
*   Object to handle all RM-GP conversations via the scracth memory         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CEPSCRATCHMANAGER_
#define _CEPSCRATCHMANAGER_

class CScratchManager;
class CEPDspProgram;
class CHalGlobalProc;

class CEPScratchManager : public CScratchManager
{
public:
    CEPScratchManager(CHalBase *pHalBase);
    ~CEPScratchManager();

public:
    RM_STATUS   Initialize(VOID_PTR pLoader, U032 uLoaderSize);
	RM_STATUS	Initialize(CEPDspProgram *pDspProgram, CHalGlobalProc *pGlHal);
    
    RM_STATUS   AC3SetAnalogOutput(U032 uOffset, U032 uSize);   // actually a FIFO index
    RM_STATUS   AC3SetDigitalOutput(U032 uOffset, U032 uSize);  // actually a FIFO index

private:
    
    RM_STATUS   AC3StartGpInput(U032 uLinOffset);
    VOID        AC3StopGpInput();

    CHalBase        *m_pHal;
    // only used for AC3 stuff...
    CHalGlobalProc  *m_pGlobalProc;
    CEPDspProgram   *m_pDspProgram;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\cgpscratchmanager.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch***************************\
*                                                                           *
* Module: CGPScratchManager.cpp                                              *
*   Object to handle all RM-GP conversations via the scracth memory         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <aos.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include "CHalBase.h"
#include "CScratchDma.h"
#include "CScratchManager.h"
#include "CGPScratchManager.h"

#define MAX_SIZE_SCRATCH_GP     0x200000            //2 Meg

CGPScratchManager::CGPScratchManager(CHalBase *pHal)
{
    m_pHal = pHal;
}

CGPScratchManager::~CGPScratchManager()
{
    CScratchManager::Shutdown();
    
    CScratchDma *pScratchDma = GetScratchDma();
    
    if (pScratchDma)
    {
        VOID *pScratchTable = pScratchDma->GetScratchTableLinAddr();
        aosFreeMem(pScratchTable);
        delete pScratchDma;
    }
    
    SetScratchDma(NULL);
}


RM_STATUS   
CGPScratchManager::Initialize(VOID_PTR pLoader, U032 uLoaderSize)
{
    // allocate the scratch Dma
    CScratchDma *pScratchDma = new CScratchDma(m_pHal, NV_PAPU_GPSMAXSGE);
    if (!pScratchDma)
        return RM_ERROR;

    // 	configure the HW
    VOLU32 vTemp = (MAX_SIZE_SCRATCH_GP/PAGE_SIZE);
	m_pHal->RegWrite(NV_PAPU_GPSMAXSGE, LOW16(vTemp));
	m_pHal->RegRead(NV_PAPU_GPSMAXSGE, &vTemp);

    MEM_DESC ScratchTable;

    ScratchTable.Size = (vTemp + 1)*NV_PSGE_SIZE;

    // allocate the scratch table - PRDs for the max size
    RM_STATUS rmStatus = aosAllocateMem(ScratchTable.Size,
						                ALIGN_16K,
						                &ScratchTable.pLinAddr,
						                &ScratchTable.pPhysAddr);

    if (rmStatus != RM_OK)
        return rmStatus;

    m_pHal->RegWrite(NV_PAPU_GPSADDR, (U032) ScratchTable.pPhysAddr);
    
    rmStatus = pScratchDma->Initialize(&ScratchTable);
    if (rmStatus != RM_OK)
        return rmStatus;

    // if everything is good till now.. initialize the base object
    SetScratchDma(pScratchDma);
    //rmStatus = CScratchManager::Initialize(pLoader, uLoaderSize);

    //HACK allocate a bunch of Scratch for effects until we can allocate correctly
    if (rmStatus != RM_OK)
        return rmStatus;

    U032 Offset;
    rmStatus = pScratchDma->Allocate(0x100000,&Offset);

    return rmStatus;
}

VOID
CGPScratchManager::AC3RemoveOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages)
{
    // stop the GP from pumping data... TODO
    /*
    AC3_SET_BUFFER rSetBuffer;

    rSetBuffer.data1.uVal = 0;
    rSetBuffer.data1.fields.oper = NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER_DISABLE;
    rSetBuffer.data1.fields.size = uNumOfPages * PAGE_SIZE;
    rSetBuffer.offset = m_uAC3BufferOffset;

    // write to the output Q
    CScratchQ *pQ = GetOutputQ();
    pQ->Start();
    pQ->Write(NV_OGP_SET_AC3_OUTPUT_BUFFER, rSetBuffer.data1.uVal, rSetBuffer.offset);
    pQ->Stop();
    */

    CScratchDma *pDma = GetScratchDma();
    pDma->RemovePage(pMem, uNumOfPages);
}

RM_STATUS
CGPScratchManager::AC3SetOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages)
{
    // AC3_SET_BUFFER rSetBuffer;

    CScratchDma *pDma = GetScratchDma();

    // we need to add these pages to the GP scratch
    RM_STATUS rmStatus = pDma->AddPage(pMem, uNumOfPages, &m_uAC3BufferOffset);
    if (rmStatus == RM_OK)
    {
        // write a method to the DSP telling him the offset of the AC3 output buffer - TODO!
        /*
        rSetBuffer.data1.uVal = 0;
        rSetBuffer.data1.fields.oper = NV_OGP_SET_AC3_OUTPUT_BUFFER_OPER_ENABLE;
        rSetBuffer.data1.fields.size = uNumOfPages * PAGE_SIZE;
        rSetBuffer.offset = m_uAC3BufferOffset;

        // write to the output Q
        CScratchQ *pQ = GetOutputQ();
        pQ->Start();
        if (FALSE == pQ->Write(NV_OGP_SET_AC3_OUTPUT_BUFFER, rSetBuffer.data1.uVal, rSetBuffer.offset))
            rmStatus = RM_ERROR;
        pQ->Stop();
        */
    }

    return rmStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalExtendedProc.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalExtendedProc.h                                                   *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALEXTENDEDPROCH_
#define _CHALEXTENDEDPROCH_

class CHalBase;
class CObjBase;
class CEPScratchManager;
class CEPDspProgram;
class CScratchManager;
class CHalGlobalProc;
class CEPMethod;

class CHalExtendedProc : public CObjBase
{
public:
    CHalExtendedProc(CHalBase *pHal, CHalGlobalProc *pGlProc);
	~CHalExtendedProc() { };

public:

	// each derived object has to implement these functions
	RM_STATUS Allocate(VOID *pParam);
	RM_STATUS Free(VOID *pParam = NULL);
    
    VOID ExecuteMethod(U032 uMethod, U032 uParam);
    
    VOID *GetSgeOutLinAddr() { return m_SgeOut.pLinAddr; }
    
    CScratchManager *GetScratchManager() { return (CScratchManager *)m_pScratchManager; }
    CEPScratchManager *GetEPScratchManager() { return m_pScratchManager; }

private:
    RM_STATUS AllocateMemory(APU_EP_CREATE *);
    VOID FreeMemory();

    RM_STATUS GetCaps(APU_EP_CREATE *);
    VOID InitializeHardware();

    MEM_DESC    m_SgeOut;
    MEM_DESC    m_CommandQ;

    CEPScratchManager   *m_pScratchManager;
    CEPDspProgram       *m_pDspProgram;
    CHalGlobalProc      *m_pGlobalProc;
    CEPMethod           *m_pMethod;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CGPScratchManager.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch***************************\
*                                                                           *
* Module: CGPScratchManager.h                                               *
*   Object to handle all RM-GP conversations via the scracth memory         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CGPSCRATCHMANAGER_
#define _CGPSCRATCHMANAGER_

typedef struct
{
    union
    {
        struct
        {
            U032 oper : 1;
            U032 res  : 15;
            U032 size : 16;
        } fields;

        U032 uVal;
    } data1;

    U032 offset;

} AC3_SET_BUFFER;

class CScratchManager;

class CGPScratchManager : public CScratchManager
{
public:
    CGPScratchManager(CHalBase *pHalBase);
    ~CGPScratchManager();
    
    U032    AC3GetBufferOffset() { return m_uAC3BufferOffset; }

public:
    RM_STATUS   Initialize(VOID_PTR pLoader, U032 uLoaderSize);
    RM_STATUS   AC3SetOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages);
    VOID        AC3RemoveOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages);
    
private:
    CHalBase    *m_pHal;
    U032        m_uAC3BufferOffset;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalBase.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CHalBase.h                                                        *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALBASEH_
#define _CHALBASEH_

class CHalBase
{
public:
    CHalBase::CHalBase(U008 uRevID, HWINFO_COMMON_FIELDS *pDev, U032 uSafeReadOffset);
    virtual CHalBase::~CHalBase();

	virtual RM_STATUS Allocate() = 0;
	virtual RM_STATUS Free() = 0;

    virtual RM_STATUS AddClient(VOID *pParam, U008 *pClientRef) = 0;
    virtual RM_STATUS DeleteClient(U008 uClientRef) = 0;

    // context dma
    virtual RM_STATUS AllocateContextDma(VOID *pParam) = 0;
    virtual RM_STATUS FreeContextDma(VOID *pParam) = 0;
    
    // object (processor) allocation
    virtual RM_STATUS AllocateObject(U032 uObjectType, VOID *pParam) = 0;
    virtual RM_STATUS FreeObject(U032 uObjectType, VOID *pParam) = 0;

	// the ISR function called at interrupt time
	virtual RM_STATUS InterruptService() = 0;


	virtual VOID RegWrite(U032 uOffset, U032 uValue)
    {
        *(U032*)(m_uBase + uOffset) = uValue;
        // read back a safe location, to make sure the APU FE FIFO is flushed
        U032 uTemp = *(U032*)(m_uBase + m_uSafeReadOffset);
    }

    virtual VOID RegRead(U032 uOffset, U032 *pValue) { *pValue = *(U032*)(m_uBase + uOffset); }
	virtual VOID RegRead(U032 uOffset, U016 *pValue) { *pValue = *(U016*)(m_uBase + uOffset); }
	virtual VOID RegRead(U032 uOffset, U008 *pValue) { *pValue = *(U008*)(m_uBase + uOffset); }

	virtual VOID RegRead(U032 uOffset, volatile U032 *pValue) { *pValue = *(U032*)(m_uBase + uOffset); }
	virtual VOID RegRead(U032 uOffset, volatile U016 *pValue) { *pValue = *(U016*)(m_uBase + uOffset); }
	virtual VOID RegRead(U032 uOffset, volatile U008 *pValue) { *pValue = *(U008*)(m_uBase + uOffset); }
    
    virtual VOID MemWrite(U032 uAddr, U008 uData)    { 	*((U008 *)uAddr) = uData;   }
    virtual VOID MemWrite(U032 uAddr, U016 uData)    { 	*((U016 *)uAddr) = uData;   }
    virtual VOID MemWrite(U032 uAddr, U032 uData)    { 	*((U032 *)uAddr) = uData;   }

	U008                    GetRevID()	{ return m_uRevID; }
	HWINFO_COMMON_FIELDS *  GetpDev()   { return m_pDev; }
    U032                    GetDevBase() { return m_uBase; }

protected:
    VOID DumpChipToFile();

private:
    U008 m_uRevID;
	U032 m_uBase;
    U032 m_uSafeReadOffset;
	HWINFO_COMMON_FIELDS *m_pDev;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalMCP1.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CHalMCP1.h                                                        *
*   All HAL functions specific to MCP1 are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALMCP1H_
#define _CHALMCP1H_

class CHalVoiceProc;
class CHalGlobalProc;
class CHalExtendedProc;
class CContextDma;

#define MAX_CLIENTS		        8

class CHalMCP1 : public CHalBase
{
public:
	CHalMCP1(U008, HWINFO_COMMON_FIELDS *);
	~CHalMCP1();

public:
	RM_STATUS Allocate();
	RM_STATUS Free();

    RM_STATUS AddClient(VOID *pParam, U008 *pClientRef);
    RM_STATUS DeleteClient(U008 uClientRef);

    RM_STATUS AllocateContextDma(VOID *pParam);
    RM_STATUS FreeContextDma(VOID *pParam);

    RM_STATUS AllocateObject(U032 uObjectType, VOID *pParam);
    RM_STATUS FreeObject(U032 uObjectType, VOID *pParam);

	RM_STATUS InterruptService();
    
    enum E_STATE
    {
        // mode states
        FREE_RUN = 0,
        // SE modes
        OFF,
        AC_SYNC,
        SW,
        // interrupts enables for SE
        INT_PANIC,
        INT_RETRIGGER,
        INT_WARN,
        // FE modes
        HALT,
        // priv locks
        LOCK,
        UNLOCK
    };

    enum INTERRUPT_STATE
    {
        ENABLE,
        DISABLE
    };

    VOID SetFrontEnd(E_STATE);
    VOID SetSetupEngine(E_STATE);
   	VOID SetInterrupts(INTERRUPT_STATE);
    VOID SetPrivLock(E_STATE);

    CHalVoiceProc   *GetVoiceProc()     { return m_pVoiceProc; }
    CHalGlobalProc  *GetGlobalProc()    { return m_pGlobalProc; }
    CHalExtendedProc *GetExtendedProc() { return m_pExtendedProc; }

protected:
	// public objects
	CHalVoiceProc	    *m_pVoiceProc;
    CHalGlobalProc      *m_pGlobalProc;
    CHalExtendedProc    *m_pExtendedProc;

private:
	VOID OnIntrFETrap();
    VOID UpdateUserMethodQ(U032 uMethod, U032 uData);
	BOOL GetUserMethodInfo(U032 *pMethod, U032 *pData);
	VOID WriteError(U032 uIsCurrentVoice, U008	uErrorCode);
    
    VOID SetISO(APU_AP_FLAGS *pFlags);

    VOID SetSetupEngineGlobalCounts(U032 uExt, U032 uInt, U032 uDelta);
    VOID SetSetupEngineExtendedCounts(U032 uInt, U032 uDelta, U032 uStep);

    VOID CallbackClients(U032 uIntrMask);
    RM_STATUS StoreClientInfo(VOID *pFn, U032 uMask, U032 uContext);
    
    VOID GetDebugInfo();

	R_INTR	m_rInterruptMask;

    CContextDma *m_pCDma;

    MCP1_CLIENT_INFO m_ClientInfo[MAX_CLIENTS];

    MEM_DESC    m_MagicWrite;
    U032        m_uMagicWriteValue;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalGlobalProc.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************GP class for the HAL******************************\
*                                                                           *
* Module: CHalGlobalProc.cpp                                                *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
extern "C"
{
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
#include <nv_ugp.h>
#include <aos.h>
#include <nv32.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalGlobalProc.h"
#include "CScratchManager.h"
#include "CGPScratchManager.h"
#include "CDspProgram.h"
#include "CGPDspProgram.h"
#include "CGPMethod.h"

CHalGlobalProc::CHalGlobalProc(CHalBase *pHal) : CObjBase(pHal)
{
    m_pNotifier = NULL;
    m_uNotifierSize = 0;
    m_pScratchManager = NULL;
    m_pDspProgram = NULL;
    m_pMethod = NULL;
}

RM_STATUS
CHalGlobalProc::Allocate(VOID *pParam)
{
	APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;
	RM_STATUS rmStatus = RM_OK;
    
    do
    {
        // allocate all the objects required for GP

        m_pScratchManager = new CGPScratchManager(GetDevice());
        m_pDspProgram = new CGPDspProgram();
        m_pMethod = new CGPMethod(this, m_pScratchManager, m_pDspProgram, GetDevice());

        if (!m_pDspProgram || !m_pDspProgram || !m_pMethod)
            break;

        m_pDspProgram->Initialize();

        rmStatus = m_pScratchManager->Initialize( m_pDspProgram->GetLoader(),
                                                  m_pDspProgram->GetLoaderSize() );
        if (rmStatus != RM_OK)
            break;

        rmStatus = m_pMethod->Initialize();
        if (rmStatus != RM_OK)
            break;

        // get the device capabilities
        if (pArg->uSGEOutCount)
        {
	        VOLU32 vTemp = pArg->uSGEOutCount - 1;
	        RegWrite(NV_PAPU_FEMAXGPSGE, LOW16(vTemp));
	        RegRead(NV_PAPU_FEMAXGPSGE, &vTemp);
	        pArg->uSGEOutCount = vTemp + 1;
        }

        m_SgeOut.Size = pArg->uSGEOutCount * NV_PSGE_SIZE;

	    rmStatus =  aosAllocateMem(m_SgeOut.Size,
						                    ALIGN_16K,
						                    &m_SgeOut.pLinAddr,
						                    &m_SgeOut.pPhysAddr);
        if (rmStatus == RM_OK)
        {
            // clear any pending interrupts! - todo cleanup
            RegWrite(NV_PAPU_GPISTS, (U032)0xFFFFFFFF);
            // output buffer PRDs
            RegWrite(NV_PAPU_GPFADDR, (U032)m_SgeOut.pPhysAddr);
            // update the max fifo PRDs req
            RegWrite(NV_PAPU_GPFMAXSGE, (U016)(m_SgeOut.Size / NV_PSGE_SIZE) );

            // return the linear address of the command Q to the client
            pArg->pGPCommandQ = (VOID_PTR)m_pMethod->GetCommandQAddress();
        }

    } while (FALSE);

	return rmStatus;
}

RM_STATUS
CHalGlobalProc::Free(VOID *pParam)
{
    if (m_pMethod)
        delete m_pMethod;

    if (m_pDspProgram)
        delete m_pDspProgram;

    if (m_pScratchManager)
        delete m_pScratchManager;

	aosFreeMem(m_SgeOut.pLinAddr);
    m_SgeOut.pLinAddr = NULL;

    m_pMethod = NULL;
    m_pDspProgram = NULL;
    m_pScratchManager = NULL;

    return RM_OK;
}



VOID
CHalGlobalProc::WriteCommand(U032 uOffset, DSP_CONTROL *pDspWord, WORD4 *pW4, WORD5 *pW5, WORD6 *pW6)
{
    RegWrite(NV_PAPU_GPXMEM(uOffset++), pDspWord->w0.uValue);
    RegWrite(NV_PAPU_GPXMEM(uOffset++), pDspWord->w1.uValue);
    RegWrite(NV_PAPU_GPXMEM(uOffset++), pDspWord->w2.uValue);
    RegWrite(NV_PAPU_GPXMEM(uOffset++), pDspWord->w3.uValue);
    
    if (pW4)
        RegWrite(NV_PAPU_GPXMEM(uOffset++), pW4->uValue);

    if (pW5)
        RegWrite(NV_PAPU_GPXMEM(uOffset++), pW5->uValue);

    if (pW6)
        RegWrite(NV_PAPU_GPXMEM(uOffset++), pW6->uValue);
}

VOID
CHalGlobalProc::WriteNotifier(U032 uMethod, U032 uData, U008 uStatus)
{
    if (!m_pNotifier)
    {
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalGlobalProc::WriteNotifier - Memory not set\n");
        return;
    }
    
    // calculate the notifier memory address for the method
    U032 uOffset = sizeof(NVAUDGPNOTIFICATION) * uMethod;

    // check for boundary
    if (uOffset < m_uNotifierSize)
    {
        // great.. now write the notifier
        PNVAUDGPNOTIFICATION pNotify = (PNVAUDGPNOTIFICATION)(m_pNotifier + uOffset);
    
        pNotify->GSCNT = 0;     // todo vik
        pNotify->Method = uMethod;
        pNotify->Data = uData;
        pNotify->ReturnCode = uStatus;
        pNotify->Status = NV_AUDGP_NOTIFICATION_STATUS_DONE_SUCCESS;
    }
    else
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalGlobalProc::WriteNotifier - boundary check fails!\n");
}

VOID
CHalGlobalProc::ExecuteMethod() 
{ 
    if (m_pMethod)
        m_pMethod->Execute();
    else
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalGlobalProc::ExecuteMethod - no method class!\n");
}

RM_STATUS 
CHalGlobalProc::AC3SetOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages)
{
    RM_STATUS rmStatus = RM_ERROR;

    if (m_pScratchManager)
        rmStatus = m_pScratchManager->AC3SetOutputBuffer(pMem, uNumOfPages);

    return rmStatus;
}

VOID 
CHalGlobalProc::AC3RemoveOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages)
{
    if (m_pScratchManager)
       m_pScratchManager->AC3RemoveOutputBuffer(pMem, uNumOfPages);
}

U032
CHalGlobalProc::AC3GetBufferOffset()
{
    if (m_pScratchManager)
       return m_pScratchManager->AC3GetBufferOffset();

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalGlobalProc.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalGlobalProc.h                                                   *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALGLOBALPROCH_
#define _CHALGLOBALPROCH_

class CHalBase;
class CObjBase;
class CGPScratchManager;
class CGPDspProgram;
class CGPMethod;
class CScratchManager;

class CHalGlobalProc : public CObjBase
{
public:
    CHalGlobalProc(CHalBase *pHal);
	~CHalGlobalProc() { };

public:

	// each derived object has to implement these functions
	RM_STATUS Allocate(VOID *pParam);
	RM_STATUS Free(VOID *pParam = NULL);

    VOID    *GetSgeOutLinAddr() { return m_SgeOut.pLinAddr; }
    VOID    WriteCommand(U032, DSP_CONTROL *, WORD4 * = NULL, WORD5 * = NULL, WORD6 * = NULL);
    
    VOID    SetNotifierMemory(VOID *pLinAddr, U032 uSize)   { m_pNotifier = (U008 *)pLinAddr; m_uNotifierSize = uSize; }
    VOID    WriteNotifier(U032 uMethod, U032 uData, U008 uStatus);
    
    VOID    ExecuteMethod();
    
    // debug only
    CScratchManager *GetScratchManager() { return (CScratchManager *)m_pScratchManager; }
    
    RM_STATUS   AC3SetOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages);
    VOID        AC3RemoveOutputBuffer(PMEM_DESC pMem, U032 uNumOfPages);
    
    U032        AC3GetBufferOffset();

private:
    MEM_DESC    m_SgeOut;

    // notifier memory
    U008        *m_pNotifier;
    U032        m_uNotifierSize;

    // objects
    CGPScratchManager   *m_pScratchManager;
    CGPDspProgram       *m_pDspProgram;
    CGPMethod           *m_pMethod;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalBase.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CHalBase.h                                                        *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include <aos.h>
#include "CHalBase.h"

CHalBase::CHalBase(U008 uRevID, HWINFO_COMMON_FIELDS *pDev, U032 uSafeReadOffset) 
{ 
	m_uRevID = uRevID; 
	m_pDev = pDev;
	m_uBase = m_pDev->pDeviceBase;
    m_uSafeReadOffset = uSafeReadOffset;

#if defined VIKDBG
    // allocate some memory that will be the device PCI space
    if (RM_OK != aosAllocateMem(1?NV_PAPU, ALIGN_DONT_CARE, (VOID **)&m_uBase, NULL) )
    {
        // well.. too bad .. i tried
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalBase::CHalBase - no memory for the chip");
        return;
    }

    // zero the memory
    for (U032 uCnt = 0; uCnt < (1?NV_PAPU)/4; uCnt++)
        RegWrite(uCnt*4, (U032)0);
#endif
}

CHalBase::~CHalBase() 
{
    m_uRevID = 0; 

#if defined VIKDBG
    DumpChipToFile();
    aosFreeMem((VOID *)m_uBase);
#endif
}

VOID
CHalBase::DumpChipToFile()
{
    VOID *pHandle = aosCreateDiskFile();
    if (pHandle)
    {
        aosWriteDiskFile(pHandle, (VOID *)m_uBase, 1?NV_PAPU);
        aosCloseDiskFile(pHandle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalExtendedProc.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************GP class for the HAL******************************\
*                                                                           *
* Module: CHalExtendedProc.cpp                                                *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
extern "C"
{
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
#include <nv32.h>
#include <aos.h>
};

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalExtendedProc.h"
#include "CHalGlobalProc.h"
#include "CScratchManager.h"
#include "CEPScratchManager.h"
#include "CDspProgram.h"
#include "CEPDspProgram.h"
#include "CEPMethod.h"

CHalExtendedProc::CHalExtendedProc(CHalBase *pHal, CHalGlobalProc *pGlProc) : CObjBase(pHal)
{
    // keep the internal count ahead of the external count by this much
    m_CommandQ.Size = 4096;
    m_pDspProgram = NULL;
    m_pScratchManager = NULL;
    m_pGlobalProc = pGlProc;
    m_pMethod = NULL;
}

RM_STATUS
CHalExtendedProc::Allocate(VOID *pParam)
{
	APU_EP_CREATE *pArg = (APU_EP_CREATE *)pParam;
	RM_STATUS rmStatus = RM_ERROR;
    
    do
    {
        m_pDspProgram = new CEPDspProgram;
        m_pScratchManager = new CEPScratchManager(GetDevice());
        m_pMethod = new CEPMethod(GetDevice(), this);

        if (!m_pDspProgram || !m_pScratchManager || !m_pMethod)
            break;

        if (pArg->uUseForAC3)
        {
            rmStatus = m_pScratchManager->Initialize(m_pDspProgram, m_pGlobalProc);
            pArg->uAC3GpOutputOffset = m_pGlobalProc->AC3GetBufferOffset();
        }
        else
        {
            // tbd 
            rmStatus = RM_ERROR;
        }

        if (rmStatus != RM_OK)
            break;

        rmStatus = GetCaps(pArg);
        if (rmStatus != RM_OK)
            break;

        rmStatus = AllocateMemory(pArg);
        if (rmStatus != RM_OK)
            break;

        InitializeHardware();

    } while (FALSE);

	return rmStatus;
}


RM_STATUS
CHalExtendedProc::Free(VOID *pParam)
{
    if (m_pMethod)
        delete m_pMethod;

    if (m_pDspProgram)
        delete m_pDspProgram;

    if (m_pScratchManager)
        delete m_pScratchManager;

    FreeMemory();

    m_pMethod = NULL;
    m_pDspProgram = NULL;
    m_pScratchManager = NULL;

    return RM_OK;
}

RM_STATUS
CHalExtendedProc::GetCaps(APU_EP_CREATE *pArg)
{
    // have no idea what regs to check against

    return RM_OK;
}

VOID
CHalExtendedProc::ExecuteMethod(U032 uMethod, U032 uParam)
{
    if (m_pMethod)
        m_pMethod->Execute(uMethod, uParam);
    else
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalExtendedProc::ExecuteMethod - not method object!\n");
    }
}

RM_STATUS
CHalExtendedProc::AllocateMemory(APU_EP_CREATE *pArg)
{
    // vik - todo
    m_SgeOut.Size = pArg->uSGEOutCount * NV_PSGE_SIZE;

	RM_STATUS rmStatus =  aosAllocateMem(m_SgeOut.Size,
						                ALIGN_16K,
						                &m_SgeOut.pLinAddr,
						                &m_SgeOut.pPhysAddr);

    if (rmStatus == RM_OK)
    {
        // allocate memory for the command Q
        rmStatus =  aosAllocateMem(m_CommandQ.Size,
						        ALIGN_16K,
						        &m_CommandQ.pLinAddr,
						        &m_CommandQ.pPhysAddr);
    }

    return rmStatus;
}

VOID
CHalExtendedProc::FreeMemory()
{
	aosFreeMem(m_SgeOut.pLinAddr);
	aosFreeMem(m_CommandQ.pLinAddr);
}

VOID
CHalExtendedProc::InitializeHardware()
{
    // clear any pending interrupts! - todo cleanup
    RegWrite(NV_PAPU_EPISTS, (U032)0xFFFFFFFF);
    
    // output buffer PRDs
    RegWrite(NV_PAPU_EPFADDR, (U032)m_SgeOut.pPhysAddr);

    // PRDs for the FIFO
    RegWrite(NV_PAPU_EPCADDR, (U032)m_CommandQ.pPhysAddr);

    // update the max fifo PRDs req
    RegWrite(NV_PAPU_EPFMAXSGE, (U016)(m_SgeOut.Size / NV_PSGE_SIZE) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalMCP1.cpp ===
// cHalMCPI.cpp

extern "C"
{
#include <nv32.h>
#include <nvarm.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include <aos.h>
// ahal should not need to be included...
// todo - have to work on the client info stuff
#include "AHal.h"

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"
#include "CHalExtendedProc.h"
#include "CHalGlobalProc.h"
#include "CHalMCP1.h"
#include <CLinkList.h>
#include "CContextDma.h"
#include "CEPMethod.h"
#include "CScratchDma.h"
#include "CScratchManager.h"
#include "CGpMethod.h"

// constructor
CHalMCP1::CHalMCP1(U008 uRevID, HWINFO_COMMON_FIELDS *pDev) : CHalBase(uRevID, pDev, NV_PAPU_FESCRATCH) 
{ 
    m_pVoiceProc = NULL;
    m_pCDma = NULL;
    m_pGlobalProc = NULL;
    m_pExtendedProc = NULL;
    m_MagicWrite.pLinAddr = NULL;
    m_uMagicWriteValue = 1;

    // init the client callback info
    for (U032 uCnt = 0; uCnt < MAX_CLIENTS; uCnt++)
        m_ClientInfo[uCnt].pFn = NULL;
}

CHalMCP1::~CHalMCP1()
{ 
    if (m_pVoiceProc)   
        delete m_pVoiceProc;
    
    if (m_pGlobalProc)
        delete m_pGlobalProc;

    if (m_pExtendedProc)
        delete m_pExtendedProc;

    if (m_pCDma)
    {
        // clean the list - todo
    }

    m_pVoiceProc = NULL;
    m_pCDma = NULL;
    m_pGlobalProc = NULL;
    m_pExtendedProc = NULL;
}

RM_STATUS 
CHalMCP1::InterruptService()
{
    RM_STATUS rmStatus = RM_OK;
    
    R_INTR rInterruptStatus;
    U032 uServiced = 1;
    
    INTR_MASK ClientMask;
    ClientMask.uValue = 0;
    
    // read from hardware what interrupt is pending
    RegRead(NV_PAPU_ISTS, &rInterruptStatus.uValue);
    
    // take action depending on what is triggered
    if (NV_PAPU_ISTS_GINTSTS_INTR == rInterruptStatus.General)
    {
        // prepare the magic write stuff
        aosZeroMemory(m_MagicWrite.pLinAddr, m_MagicWrite.Size);

        SetPrivLock(E_STATE::LOCK);

        // fixed in rev B - but for now.. read and store  NV_PAPU_FEMEMADDR
        U032 uSavedMemAddr;
        RegRead(NV_PAPU_FEMEMADDR, &uSavedMemAddr);

        RegWrite(NV_PAPU_FEMEMADDR, (U032)m_MagicWrite.pPhysAddr);
        RegWrite(NV_PAPU_FEMEMDATA, m_uMagicWriteValue);

        // find out if it's a valid interrupt
        // check for individial interrupt bits
        // can multiple bits be set?? vik
        
        if (NV_PAPU_ISTS_DWINTSTS_INTR == rInterruptStatus.DeltaWarning)
        {
            aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalMCP1::InterruptService - Delta Warning interrupt triggered!\n");
            rInterruptStatus.DeltaWarning = NV_PAPU_ISTS_DWINTSTS_CLR;
            ClientMask.apu.DeltaWarning = 1;
        }

        if (NV_PAPU_ISTS_RTWSTS_INTR == rInterruptStatus.RetriggerEvent)
        {
            aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalMCP1::InterruptService - Retriggerd Delta Warning interrupt (??)\n");
            // read only value.. need not be cleared
            // rInterruptStatus.RetriggerEvent = NV_PAPU_ISTS_RTWSTS_CLR; 
        }

        if (NV_PAPU_ISTS_DPINTSTS_INTR == rInterruptStatus.DeltaPanic)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::InterruptService - Delta Panic (internal and external GSCNT is same!\n");
            rInterruptStatus.DeltaPanic = NV_PAPU_ISTS_DPINTSTS_CLR;
            ClientMask.apu.DeltaPanic = 1;
        }

        if (NV_PAPU_ISTS_FETINTSTS_INTR == rInterruptStatus.FETrap)
        {
            rInterruptStatus.FETrap = NV_PAPU_ISTS_FETINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_FENINTSTS_INTR == rInterruptStatus.FENotify)
        {
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::InterruptService - Notifier was written\n");
            rInterruptStatus.FENotify = NV_PAPU_ISTS_FENINTSTS_CLR;
            ClientMask.apu.FENotify = 1;
        }

        if (NV_PAPU_ISTS_FEVINTSTS_INTR == rInterruptStatus.FEVoice)
        {
            aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::InterruptService - End of voice received\n");
            rInterruptStatus.FEVoice = NV_PAPU_ISTS_FEVINTSTS_CLR;
            ClientMask.apu.FEVoice = 1;
        }

        if (NV_PAPU_ISTS_FEOINTSTS_INTR == rInterruptStatus.FEMethodOverFlow)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::InterruptService - User method fifo overflow.. some methods/data will be discarded\n");
            rInterruptStatus.FEMethodOverFlow = NV_PAPU_ISTS_FEOINTSTS_CLR;
            ClientMask.apu.FEMethodOverFlow = 1;
        }

        if (NV_PAPU_ISTS_GPMINTSTS_INTR == rInterruptStatus.GPMailbox)
        {
            rInterruptStatus.GPMailbox = NV_PAPU_ISTS_GPMINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_GPNINTSTS_INTR == rInterruptStatus.GPNotify)
        {
            rInterruptStatus.GPNotify = NV_PAPU_ISTS_GPNINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_EPMINTSTS_INTR == rInterruptStatus.EPMailbox)
        {
            rInterruptStatus.EPMailbox = NV_PAPU_ISTS_EPMINTSTS_CLR;
        }

        if (NV_PAPU_ISTS_EPNINTSTS_INTR == rInterruptStatus.EPNotify)
        {
            rInterruptStatus.EPNotify = NV_PAPU_ISTS_EPNINTSTS_CLR;
        }

        RegWrite(NV_PAPU_ISTS, rInterruptStatus.uValue);
        
        // restore the previosuly read NV_PAPU_FEMEMDATA - fixed in rev B
        RegWrite(NV_PAPU_FEMEMADDR, uSavedMemAddr);

        // unlock the FE
        SetPrivLock(E_STATE::UNLOCK);


        // complete the magic writes (??)
        U032 uCnt = 0;
        while (m_uMagicWriteValue != (*((U032 *)m_MagicWrite.pLinAddr)) )
        {
            if (uCnt++ > 1000)
            {
                aosDbgPrintString(DEBUGLEVEL_ERRORS, "CHalMCP1::InterruptService - magic write not completing\n");
#if defined WDM
                KdPrint(("magic write value = %d\n", m_uMagicWriteValue));
#endif
                //aosDbgBreakPoint();
                break;
            }
        }
        
        m_uMagicWriteValue ++;

        // it was our interrupt then complete the processing
        if (NV_PAPU_ISTS_GINTSTS_INTR == rInterruptStatus.General)
        {
            if (rInterruptStatus.FETrap == NV_PAPU_ISTS_FETINTSTS_CLR)
                OnIntrFETrap();
            
            if (rInterruptStatus.GPMailbox == NV_PAPU_ISTS_GPMINTSTS_CLR)
            {
                // When the client writes to the GP command Q, the GP gets an interrupt
                // on getting it, the GP should write to the mailbox register to trip this
                // interrupt - GP sw methods are handled here
                
                if (m_pGlobalProc)
                    m_pGlobalProc->ExecuteMethod();
                else
                {
                    aosDbgPrintString(DEBUGLEVEL_ERRORS, "CHalMCP1::InterruptService - m_pGlobalProc not allocated\n");
                }
            }

            // callback the clients
            CallbackClients(ClientMask.uValue);
        }

        // to make sure that the ISTS write gets thu' bfore we return from the
        // ISR - this will eliminate spurious interrupts
        RegRead(NV_PAPU_ISTS, &rInterruptStatus.uValue);
    
    }
    else
    {
        // not our interrupt
        rmStatus = RM_ERROR;
    }


    return rmStatus;
}

VOID
CHalMCP1::UpdateUserMethodQ(U032 uMethod, U032 uParam)
{
#if DEBUG
    // some error checking
    R_FE_CONTROL rFeControl;
    RegRead(NV_PAPU_FECTL, &rFeControl.uValue);
    if (rFeControl.Mode == NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: FE free running - cannot update user method Q\n");
        aosDbgBreakPoint();
    }
#endif

    R_METHODQ_CONTROL rQControl;
    RegRead(NV_PAPU_FEUFIFOCTL, &rQControl.uValue);
    if (rQControl.count == MCP1_METHODQ_SIZE)
    {
        // this should not happen, since the driver assumes there are only 31 entries in the Q
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: FE method Q - max reached!!!\n");
        return;   
    }

    // update the head pointer - is it "0" based?
    rQControl.head = (rQControl.head == (MCP1_METHODQ_SIZE-1))?(0):(rQControl.head++);

    // stuff the method and the param
    RegWrite(NV_PAPU_FEUFIFOMETH(rQControl.head), uMethod);
    RegWrite(NV_PAPU_FEUFIFOPARAM(rQControl.head), uParam);

    rQControl.count++;
    RegWrite(NV_PAPU_FEUFIFOCTL, rQControl.uValue);
}

// returns non-zero if it's an EP SW method.. FALSE for AP
BOOL
CHalMCP1::GetUserMethodInfo(U032 *pMethod, U032 *pParam)
{
    // to do - change this when the .ref is updated
    RegRead(NV_PAPU_FEDECPARAM, pParam);
    RegRead(NV_PAPU_FEDECMETH, pMethod);

    BOOL bEPMethod = (*pMethod) & PIO_EP_OFFSET;

    // return 16 LSB after turning off bit 16
    *pMethod = ((*pMethod) & (~PIO_EP_OFFSET));
    *pMethod = LOW16(*pMethod);

    return bEPMethod;
}

VOID
CHalMCP1::OnIntrFETrap()
{
    R_FE_CONTROL rFeControl;
    
    // first find out the reason for the trap
    U032 uParam;
    U032 uMethod;
    BOOL bEpMethod = GetUserMethodInfo(&uMethod, &uParam);
    
    RegRead(NV_PAPU_FECTL, &rFeControl.uValue);
    rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
    RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
    
    switch(rFeControl.TrapReason)
    {
    case NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN:
        aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_METHOD_UNKNOWN\n");
    case NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED:
        aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_NOT_IMPLEMENTED\n");

        if (bEpMethod)
        {
            if (m_pExtendedProc)
                m_pExtendedProc->ExecuteMethod(uMethod, uParam);
            else
            {
                aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - extended proc not allocated\n");
            }
        }
        else
        {
            if (m_pVoiceProc)
                m_pVoiceProc->ExecuteMethod(uMethod, uParam);
            else
            {
                aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - voice proc not allocated\n");
            }
        }

        break;
        
    case NV_PAPU_FECTL_FETRAPREASON_REQUESTED:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_REQUESTED\n");
        GetDebugInfo();
        break;
        
    case NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_BAD_ARGUMENT\n");
        GetDebugInfo();
        break;

    case NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_CURRENT_NOT_SET\n");
        GetDebugInfo();
        break;

    case NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_ANTECEDENT_NOT_SET\n");
        GetDebugInfo();
        break;

    case NV_PAPU_FECTL_FETRAPREASON_BAD_DATA_TYPE:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_BAD_DATA_TYPE\n");
        GetDebugInfo();
        break;

    case NV_PAPU_FECTL_FETRAPREASON_BAD_LIST_POINTER:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_BAD_LIST_POINTER\n");
        GetDebugInfo();
        break;

    case NV_PAPU_FECTL_FETRAPREASON_CURRENT_VOICE_NOT_3D:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_CURRENT_VOICE_NOT_3D\n");
        GetDebugInfo();
        break;

    case NV_PAPU_FECTL_FETRAPREASON_CTXPA_INVALID:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::OnIntrFETrap - NV_PAPU_FECTL_FETRAPREASON_CTXPA_INVALID\n");
        GetDebugInfo();
        break;
    }
        
    // turn the FE to free running
    SetFrontEnd(E_STATE::FREE_RUN);
}

VOID
CHalMCP1::GetDebugInfo()
{
#if defined DEBUG
    // absolute max voices
    U032 uAbsMaxVoice;
    RegRead(NV_PAPU_FEAMAXV, &uAbsMaxVoice);

    // max voices used
    U032 uMaxVoice;
    RegRead(NV_PAPU_FEAMAXV, &uMaxVoice);

    // max 3D voices
    U032 uMax3DVoice;
    RegRead(NV_PAPU_FEMAXTV, &uMax3DVoice);

    // current voice
    U032 uCurrVoice;
    RegRead(NV_PAPU_FECV, &uCurrVoice);

    // current voice's data type and container size
    U032 uCurrVoiceData;
    RegRead(NV_PAPU_FECVDT, &uCurrVoiceData);

    // current method
    U032 uCurrMethod;
    RegRead(NV_PAPU_FEDECMETH, &uCurrMethod);

    // current data
    U032 uCurrData;
    RegRead(NV_PAPU_FEDECPARAM, &uCurrData);

    aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: Check local variables for debug info!\n");
    aosDbgBreakPoint();
#endif
}

VOID 
CHalMCP1::CallbackClients(U032 uIntrMask)
{
    for (U032 uCnt = 0; uCnt < MAX_CLIENTS; uCnt++)
    {
        if ( (m_ClientInfo[uCnt].pFn) &&
            (m_ClientInfo[uCnt].Mask.uValue & uIntrMask) )
        {
            (*(m_ClientInfo[uCnt].pFn))((U032)m_ClientInfo[uCnt].pContext, uIntrMask, 0);
        }
    }
}

RM_STATUS
CHalMCP1::AddClient(VOID *pParam, U008 *pRef)
{
    PMCP1_CLIENT_INFO pClientInfo = (PMCP1_CLIENT_INFO)pParam;

    for (U032 uCnt = 0; uCnt < MAX_CLIENTS; uCnt++)
    {
        if (!m_ClientInfo[uCnt].pFn)
        {
            // store it here
            m_ClientInfo[uCnt].pFn = pClientInfo->pFn;
            m_ClientInfo[uCnt].Mask.uValue = pClientInfo->Mask.uValue;
            m_ClientInfo[uCnt].pContext = pClientInfo->pContext;
            *pRef = (U008)uCnt;

            return RM_OK;
        }
    }
    
    return RM_ERROR;
}

RM_STATUS
CHalMCP1::DeleteClient(U008 uRef)
{
    m_ClientInfo[uRef].pFn = NULL;
    return RM_OK;
}


RM_STATUS
CHalMCP1::Allocate()
{
    RM_STATUS rmStatus = RM_OK;
    
    // right now allocate just a page for magic write.. but later change it 
    // to allocate only 32 bits
    m_MagicWrite.Size = PAGE_SIZE;
    rmStatus = aosAllocateMem(m_MagicWrite.Size, 
                            ALIGN_4K, 
                            &(m_MagicWrite.pLinAddr),
                            &(m_MagicWrite.pPhysAddr));

    if (rmStatus == RM_OK)
    {
        // clear all the interrupts
        RegWrite(NV_PAPU_ISTS, (U032)0x00000FFF);

        m_rInterruptMask.uValue = 0;
        m_rInterruptMask.General = NV_PAPU_IEN_GINTEN_DISABLED;
        // m_rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_ENABLED;
        // m_rInterruptMask.DeltaPanic = NV_PAPU_IEN_DPINTEN_ENABLED;
        m_rInterruptMask.DeltaWarning = NV_PAPU_IEN_DWINTEN_DISABLED;
        m_rInterruptMask.DeltaPanic = NV_PAPU_IEN_DPINTEN_DISABLED;
        m_rInterruptMask.FETrap = NV_PAPU_IEN_FETINTEN_ENABLED;
        m_rInterruptMask.FENotify = NV_PAPU_IEN_FENINTEN_DISABLED;
        m_rInterruptMask.FEVoice = NV_PAPU_IEN_FEVINTEN_DISABLED;
        m_rInterruptMask.FEMethodOverFlow = NV_PAPU_IEN_FEOINTEN_ENABLED;
        m_rInterruptMask.GPMailbox = NV_PAPU_IEN_GPMINTEN_ENABLED;
        m_rInterruptMask.GPNotify = NV_PAPU_IEN_GPNINTEN_DISABLED;
        m_rInterruptMask.EPMailbox = NV_PAPU_IEN_EPMINTEN_ENABLED;
        m_rInterruptMask.EPNotify = NV_PAPU_IEN_EPNINTEN_DISABLED;

        R_FE_CONTROL rFeControl;
        rFeControl.uValue = 0;
	    rFeControl.TrapOnNotifier = NV_PAPU_FECTL_FENINT_ENABLED;
        rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
        rFeControl.EnableLock = NV_PAPU_FECTL_FEMETH_PRIVLOCK_NOT_DISABLED;

        R_SE_CONTROL rSeControl;
        rSeControl.uValue = 0;
        /*
	    rSeControl.DeltaPanic = NV_PAPU_SECTL_DPINT_DISABLED;
	    rSeControl.Retriggered = NV_PAPU_SECTL_RTWARN_DISABLED;
	    rSeControl.DeltaWarn = NV_PAPU_SECTL_DWINT_DISABLED;
        */
	    rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;

        RegWrite(NV_PAPU_IEN, m_rInterruptMask.uValue);
        RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
        RegWrite(NV_PAPU_SECTL, rSeControl.uValue);
    
        // i want all legal traps to come to me...
        RegWrite(NV_PAPU_FETFORCE0, (U032)0);
        RegWrite(NV_PAPU_FETFORCE1, (U032)0);
        RegWrite(NV_PAPU_FETIGNORE0, (U032)0);

		//For now disable the traps on SetSSLSegmentLength

		U032 FeIgnore1 = 1 << (0 ? NV_PAPU_FETIGNORE1_SET_SSL_SEGMENT_LENGTH);

        RegWrite(NV_PAPU_FETIGNORE1, (U032)FeIgnore1);
    
        // stop the GP - todo

        // stop the EP - todo
    }

    return rmStatus;
}

RM_STATUS
CHalMCP1::Free()
{
    RM_STATUS rmStatus = RM_OK;
    
    // disable the interrupts
    SetInterrupts(INTERRUPT_STATE::DISABLE);

    // stop the FE
    SetFrontEnd(E_STATE::HALT);

    // free the memory
    if (m_MagicWrite.pLinAddr)
        aosFreeMem(m_MagicWrite.pLinAddr);

    return rmStatus;
}

RM_STATUS 
CHalMCP1::AllocateObject(U032 uObjectType, VOID *pParam)
{
	RM_STATUS	rmStatus = RM_ERROR;

    switch (uObjectType)
    {
    case AUDIO_OBJECT_AP:

        do
        {
	        APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;

            if (m_pVoiceProc)
            {
                // not support for multiple object allocations...
                break;
            }

            // allocate the sw method class
            m_pGlobalProc = new CHalGlobalProc(this);
            m_pVoiceProc = new CHalVoiceProc(m_pGlobalProc, this);

            if (m_pVoiceProc && m_pGlobalProc)
            {
                SetInterrupts(INTERRUPT_STATE::DISABLE);
                SetPrivLock(E_STATE::LOCK);

                // now allocate the objects
                rmStatus = m_pVoiceProc->Allocate(pParam);

                if (rmStatus == RM_OK)
                    rmStatus = m_pGlobalProc->Allocate(pParam);
                
                SetISO(&pArg->flags);
                
                if (rmStatus == RM_OK)
                {
                    //Stop the Setup engine we will explicitly set it later
                    SetSetupEngine(E_STATE::OFF);

                        SetSetupEngineGlobalCounts( pArg->uExternalGSCNT,
                                                    pArg->uInternalGSCNT,
                                                    pArg->uDeltaGSCNT);

                    SetFrontEnd(E_STATE::FREE_RUN);
                }
                
                SetPrivLock(E_STATE::UNLOCK);
                SetInterrupts(INTERRUPT_STATE::ENABLE);

                pArg->pioBase = GetDevBase() + DEVICE_BASE(NV_PAPU_NV1BA0);

                // debug only!
                if (rmStatus == RM_OK)
                    pArg->pGPScratchLin = (VOID_PTR)m_pGlobalProc->GetScratchManager()->GetScratchPage(0);
            }

        } while (FALSE);

        break;

    case AUDIO_OBJECT_EP:
        do
        {
            APU_EP_CREATE *pArg = (APU_EP_CREATE *) pParam;
            
            // we need to make sure here, that the EP is not allocate more than once
            if (!m_pExtendedProc)
            {
                if (pArg->uUseForAC3)
                {
                    // chekc if GP has been allocated..
                    if (!m_pGlobalProc)
                        break; 
                }

                m_pExtendedProc = new CHalExtendedProc(this, m_pGlobalProc);

                if (m_pExtendedProc)
                    rmStatus = m_pExtendedProc->Allocate(pParam);

                if (rmStatus == RM_OK)
                {
                    // set up the sample counts
                    SetSetupEngineExtendedCounts(pArg->uInternalGSCNT,
                                                pArg->uDeltaGSCNT,
                                                pArg->uStepSize);

                    pArg->pioBase = GetDevBase() + DEVICE_BASE(NV_PAPU_NV1BA0) + PIO_EP_OFFSET;

                    pArg->pEPScratchLin = (VOID_PTR)m_pExtendedProc->GetScratchManager()->GetScratchPage(0);
                }
            }

        } while (FALSE);

        break;

    default:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::AllocateObject - Illegal object\n");
        rmStatus = RM_ERR_ILLEGAL_OBJECT;
        break;
    }
    
    if (rmStatus != RM_OK)
        FreeObject(uObjectType, NULL);

    return rmStatus;

}

RM_STATUS 
CHalMCP1::FreeObject(U032 uObjectType, VOID *pParam)
{
    RM_STATUS rmStatus = RM_OK;

    switch(uObjectType)
    {
    case AUDIO_OBJECT_AP:
        if (m_pGlobalProc)
        {
            m_pGlobalProc->Free();
            delete m_pGlobalProc;
            m_pGlobalProc = NULL;
        }

        if (m_pVoiceProc)
        {
            m_pVoiceProc->Free(pParam);
            delete m_pVoiceProc;
            m_pVoiceProc = NULL;
        }
        break;

    case AUDIO_OBJECT_EP:
        if (m_pExtendedProc)
        {
            m_pExtendedProc->Free();
            delete m_pExtendedProc;
            m_pExtendedProc = NULL;
        }
        break;

    default:
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::FreeObject - Illegal object\n");
        rmStatus = RM_ERR_ILLEGAL_OBJECT;
        break;
    }

    return rmStatus;
}


VOID 
CHalMCP1::SetInterrupts(INTERRUPT_STATE eIntrState)
{
    if (eIntrState == ENABLE)		// set the interrupts on
        m_rInterruptMask.General = NV_PAPU_IEN_GINTEN_ENABLED;
    else							// turn them off
        m_rInterruptMask.General = NV_PAPU_IEN_GINTEN_DISABLED;
    
    RegWrite(NV_PAPU_IEN, m_rInterruptMask.uValue);
}

VOID
CHalMCP1::SetPrivLock(E_STATE eState)
{
    /*
    make sure interrupts are disabled during
    accesses to FEPRIVLOCK, otherwise base-level
    code could set FEPRIVLOCK, then get
    an interrupt, and your ISR could set FEPRIVLOCK,
    do its thing, then clear FEPRIVLOCK -- oops.
    */

    if (eState == LOCK)
    {
        // lock
        SetInterrupts(INTERRUPT_STATE::DISABLE);
        RegWrite(NV_PAPU_FEPRIVLOCK, NV_PAPU_FEPRIVLOCK_VALUE_LOCKED);
    }
    else if (eState == UNLOCK)
    {
        RegWrite(NV_PAPU_FEPRIVLOCK, NV_PAPU_FEPRIVLOCK_VALUE_UNLOCKED);
        SetInterrupts(INTERRUPT_STATE::ENABLE);
    }
    else
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::SetPrivLock - Illegal option\n");
        aosDbgBreakPoint();
    }
    
}

VOID
CHalMCP1::SetISO(APU_AP_FLAGS *pFlags)
{
    R_FE_CONTROL rFeControl;
    R_SE_CONTROL rSeControl;

    RegRead(NV_PAPU_FECTL, &rFeControl.uValue);
    RegRead(NV_PAPU_SECTL, &rSeControl.uValue);
    
    rFeControl.WriteISO = (pFlags->fields.FEISOWrite)?NV_PAPU_FECTL_FEMWTYP_ISO:NV_PAPU_FECTL_FEMWTYP_NON_ISO;
    rFeControl.ReadISO = (pFlags->fields.FEISORead)?NV_PAPU_FECTL_FEMRTYP_ISO:NV_PAPU_FECTL_FEMRTYP_NON_ISO;
    rFeControl.NotifyISO = (pFlags->fields.FEISONotify)?NV_PAPU_FECTL_FENTYP_ISO:NV_PAPU_FECTL_FENTYP_NON_ISO;
    rFeControl.PIOClass = (pFlags->fields.FEISOPIO)?NV_PAPU_FECTL_FEPIOCLASS_ISO:NV_PAPU_FECTL_FEPIOCLASS_NON_ISO;
    
    rSeControl.SampleReadISO = (pFlags->fields.SEISOSampleRead)?NV_PAPU_SECTL_SESRTYP_ISO:NV_PAPU_SECTL_SESRTYP_NON_ISO;
    rSeControl.WriteISO = (pFlags->fields.SEISOWrite)?NV_PAPU_SECTL_SEPWTYP_ISO:NV_PAPU_SECTL_SEPWTYP_NON_ISO;
    rSeControl.ReadISO = (pFlags->fields.SEISORead)?NV_PAPU_SECTL_SEPRTYP_ISO:NV_PAPU_SECTL_SEPRTYP_NON_ISO;

    RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
    RegWrite(NV_PAPU_SECTL, rSeControl.uValue);
}

VOID 
CHalMCP1::SetFrontEnd(E_STATE eFeState)
{
    R_FE_CONTROL rFeControl;
    
    RegRead(NV_PAPU_FECTL, &rFeControl.uValue);

    switch(eFeState)
    {
    case HALT:
        rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_HALTED;
        break;
    case FREE_RUN:
        rFeControl.Mode = NV_PAPU_FECTL_FEMETHMODE_FREE_RUNNING;
        break;
    }

    RegWrite(NV_PAPU_FECTL, rFeControl.uValue);
}


VOID
CHalMCP1::SetSetupEngine(E_STATE eState)
{
    R_SE_CONTROL rSeControl;

    RegRead(NV_PAPU_SECTL, &rSeControl.uValue);

    switch(eState)
    {
    case OFF:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_OFF;
        break;
    case AC_SYNC:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_AC_SYNC;
        break;
    case SW:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_SW;
        break;
    case FREE_RUN:
        rSeControl.GSCUpdate = NV_PAPU_SECTL_XCNTMODE_FREE_RUNNING;
        break;
        /*
    case INT_PANIC:
        rSeControl.DeltaPanic = NV_PAPU_SECTL_DPINT_ENABLED;
        break;
    case INT_RETRIGGER:
        rSeControl.Retriggered = NV_PAPU_SECTL_RTWARN_ENABLED;
        break;
    case INT_WARN:
        rSeControl.DeltaWarn = NV_PAPU_SECTL_DWINT_ENABLED;
        break;
        */
    default:
        return;
    }

    RegWrite(NV_PAPU_SECTL, rSeControl.uValue);

}

VOID
CHalMCP1::SetSetupEngineGlobalCounts(U032 uExt, U032 uInt, U032 uDelta)
{
    U032 uWarn = ((uInt - uExt) - uDelta)/3;
    U032 uRetrigger = 0;        // not using it right now
    U032 uPanic = 0;            // for now.. panic if uExt catches up with uInt

    RegWrite(NV_PAPU_XGSCNT, uExt);
    RegWrite(NV_PAPU_IGSCNT, uInt);
    RegWrite(NV_PAPU_DGSCNT, uDelta);
    RegWrite(NV_PAPU_WGSCNT, uWarn);
    RegWrite(NV_PAPU_RGSCNT, uRetrigger);
    RegWrite(NV_PAPU_PGSCNT, uPanic);
    
    // make sure the SECTL is triggering panic and warn interrupts
    // and retrigger is off
    SetSetupEngine(E_STATE::INT_PANIC);
    SetSetupEngine(E_STATE::INT_WARN);
}

VOID
CHalMCP1::SetSetupEngineExtendedCounts(U032 uInt, U032 uDelta, U032 uStep)
{
    RegWrite(NV_PAPU_EGSCNT, uInt);
    RegWrite(NV_PAPU_DEGSCNT, uDelta);
    RegWrite(NV_PAPU_ECNTSTP, uStep);
}

RM_STATUS 
CHalMCP1::AllocateContextDma(VOID *pParam)
{
    APU_AP_ALLOC_CONTEXT_DMA *pIn = (APU_AP_ALLOC_CONTEXT_DMA *)pParam;
    RM_STATUS rmStatus = RM_ERROR;

    CContextDma *pDma = new CContextDma;

    if (pDma)
    {
        rmStatus = pDma->Initialize((VOID *)pIn->uBaseAddress,
                                    pIn->uMaxOffset,
                                    pIn->uType);
        if (rmStatus == RM_OK)
            pDma->Add((CLinkList **)&m_pCDma);
        else
        {
            delete pDma;
            pDma = NULL;
        }
    }
    
    pIn->uHandle = (U032)pDma;

    return rmStatus;
}

RM_STATUS 
CHalMCP1::FreeContextDma(VOID *pParam)
{
    APU_AP_FREE_CONTEXT_DMA *pIn = (APU_AP_FREE_CONTEXT_DMA *) pParam;

#if defined DEBUG

    // search the list for the context DMA
    if (!m_pCDma || FALSE == m_pCDma->Exists((CLinkList *)pIn->uHandle))
    {
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CHalMCP1::FreeContextDma - handle not found\n");
        return RM_ERROR;
        
    }

#endif 

    // assume it's the correct handle and free it
    CContextDma *pElement = (CContextDma *)pIn->uHandle;
    
    if (!pElement)
        return RM_ERROR;

    pElement->Remove((CLinkList **)&m_pCDma);
    
    delete pElement;

    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalVoiceProc.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalVoiceProc.cpp                                                 *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <AudioHw.h>
#include <nvarm.h>
#include <nv32.h>
#include <nv_papu.h>
#include <aos.h>
};

#include "CHalBase.h"
#include "CVPMethod.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"


RM_STATUS
CHalVoiceProc::Allocate(VOID *pParam)
{
	APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;
	RM_STATUS rmStatus = RM_ERROR;
	
    do
    {
        // create the method class
        m_pMethod = new CVPMethod(this, m_pGlobalProc, GetDevice());
        if (!m_pMethod)
            break;
        
        rmStatus = GetCaps(pArg);
        if (rmStatus != RM_OK)
            break;

        rmStatus = AllocateMemory(pArg);
        if (rmStatus != RM_OK)
            break;

	    // this is for debug only!
        pArg->pVoiceList = (VOID_PTR)m_Voice.pLinAddr;
       
        InitializeHardware(pArg);

    } while (FALSE);

	return rmStatus;
}

RM_STATUS
CHalVoiceProc::Free(VOID *pParam)
{
	RM_STATUS rmStatus = RM_OK;
	
    if (m_pMethod)
        delete m_pMethod;

    m_pMethod = NULL;

	FreeMemory();

	return rmStatus;
}

VOID
CHalVoiceProc::ExecuteMethod(U032 uMethod, U032 uParam)
{
    if (m_pMethod)
        m_pMethod->Execute(uMethod, uParam);
}

VOID
CHalVoiceProc::FreeMemory()
{
	aosFreeMem(m_Voice.pLinAddr);
	aosFreeMem(m_SgeIn.pLinAddr);
	aosFreeMem(m_SegIn.pLinAddr);
	aosFreeMem(m_HRTFTarg.pLinAddr);
	aosFreeMem(m_HRTFCurr.pLinAddr);
}

RM_STATUS
CHalVoiceProc::AllocateMemory(APU_AP_CREATE *pArg)
{
	RM_STATUS rmStatus;

    U032 uCnt;

	m_Voice.Size = pArg->uVoiceCount * NV_PAVS_SIZE;
    m_SgeIn.Size = pArg->uSGEInCount * NV_PSGE_SIZE;
    // the driver will pass the total number of PRDs to be allocated for streams
    m_SegIn.Size = pArg->uSegInCount * NV_PSGE_SIZE;
    m_HRTFTarg.Size = pArg->uHRTFCount * NV_PAHRTFT_SIZE;
    m_HRTFCurr.Size = pArg->uVoice3dCount * NV_PAHRTFC_SIZE;
	
	rmStatus = aosAllocateMem(m_Voice.Size,
							ALIGN_32K,
							&m_Voice.pLinAddr,
							&m_Voice.pPhysAddr);
	if (rmStatus == RM_OK)
	{
        rmStatus = aosAllocateMem(m_SgeIn.Size,
								ALIGN_16K,
								&m_SgeIn.pLinAddr,
								&m_SgeIn.pPhysAddr);

	}
	

	if (rmStatus == RM_OK)
	{

		rmStatus = aosAllocateMem(m_SegIn.Size,
								ALIGN_16K,
								&m_SegIn.pLinAddr,
								&m_SegIn.pPhysAddr);

	}


	if (rmStatus == RM_OK)
	{

		rmStatus = aosAllocateMem(m_HRTFTarg.Size,
								ALIGN_16K,
								&m_HRTFTarg.pLinAddr,
								&m_HRTFTarg.pPhysAddr);

	}

	if (rmStatus == RM_OK)
	{
		rmStatus = aosAllocateMem(m_HRTFCurr.Size,
								ALIGN_16K,
								&m_HRTFCurr.pLinAddr,
								&m_HRTFCurr.pPhysAddr);

	}

    // initialize the voice structures
    if (rmStatus == RM_OK)
    {
        U032 uAddr;
        U016 uNxtVoice;

        for (uCnt = 0; uCnt < pArg->uVoiceCount; uCnt++) 
        {
            uAddr = U032(m_Voice.pLinAddr) + (uCnt * NV_PAVS_SIZE);

            aosZeroMemory((VOID *)uAddr, NV_PAVS_SIZE);

            uNxtVoice = (U016)REF_NUM(NV_PAVS_VOICE_TAR_PITCH_LINK_NEXT_VOICE_HANDLE, uCnt);

            MemWrite(uAddr + NV_PAVS_VOICE_TAR_PITCH_LINK, uNxtVoice);
        }
        
        aosZeroMemory(m_SgeIn.pLinAddr, m_SgeIn.Size);
        aosZeroMemory(m_SegIn.pLinAddr, m_SegIn.Size);
        
    }

	return rmStatus;
}


RM_STATUS
CHalVoiceProc::GetCaps(VOID *pParam)
{
	APU_AP_CREATE *pArg = (APU_AP_CREATE *)pParam;
	VOLU32 vTemp;

    if (pArg->uVoiceCount)
    {
	    vTemp = pArg->uVoiceCount - 1;
	    RegWrite(NV_PAPU_FEMAXV, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXV, &vTemp);
	    pArg->uVoiceCount = vTemp + 1;
    }

    if (pArg->uVoice3dCount)
    {
	    vTemp = pArg->uVoice3dCount - 1;
	    RegWrite(NV_PAPU_FEMAXTV, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXTV, &vTemp);
	    pArg->uVoice3dCount = vTemp + 1;
    }

	if (pArg->uHRTFCount)
    {
        vTemp = pArg->uHRTFCount - 1;
	    RegWrite(NV_PAPU_FEMAXHT, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXHT, &vTemp);
	    pArg->uHRTFCount = vTemp + 1;
    }


	if (pArg->uSegInCount)
    {
        vTemp = pArg->uSegInCount - 1;
	    RegWrite(NV_PAPU_FEMAXSESSL, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXSESSL, &vTemp);
	    pArg->uSegInCount = vTemp + 1;
    }

	if (pArg->uSGEInCount)
    {
        vTemp = pArg->uSGEInCount - 1;
	    RegWrite(NV_PAPU_FEMAXSESGE, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXSESGE, &vTemp);
	    pArg->uSGEInCount = vTemp + 1;
    }
    
    if (pArg->uSubmixCount)
    {
	    // submixes
        vTemp = pArg->uSubmixCount - 1;
	    RegWrite(NV_PAPU_FEMAXMB, LOW16(vTemp));
	    RegRead(NV_PAPU_FEMAXMB, &vTemp);
	    pArg->uSubmixCount = vTemp + 1;
    }
    
    pArg->limitFifo = NV_PAPU_FEUFIFOMETH__SIZE_1;

	return RM_OK;
}

VOID
CHalVoiceProc::InitializeHardware(APU_AP_CREATE *pArg)
{
    // program the instance memory
    RegWrite(NV_PAPU_VPVADDR, (U032)m_Voice.pPhysAddr);
	RegWrite(NV_PAPU_VPHTADDR, (U032)m_HRTFTarg.pPhysAddr);
	RegWrite(NV_PAPU_VPHCADDR, (U032)m_HRTFCurr.pPhysAddr);
	RegWrite(NV_PAPU_VPSGEADDR, (U032)m_SgeIn.pPhysAddr);
	RegWrite(NV_PAPU_VPSSLADDR, (U032)m_SegIn.pPhysAddr);
}

VOID
CHalVoiceProc::WriteNotifier(U032 uMethod, U008	uErrorCode, BOOL uIsCurrentVoice)		
{
    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalVoiceProc::WriteNotifier - Writing to notification memory\n");

    if (m_pNotifier)
    {
        U032 uIndex = 0;

        // TRUE - pick up from FECV, else write to [0]
        if (uIsCurrentVoice)
        {
            // get index
            RegRead(NV_PAPU_FECV, &uIndex);
            uIndex = (2*uIndex) + 2;
        }
        
        m_pNotifier[uIndex]->GSCNT = 0xA1;             // just my signature
        m_pNotifier[uIndex]->CurrentOffset = uMethod; 
        m_pNotifier[uIndex]->Zero = 0;
        m_pNotifier[uIndex]->Res0 = 0;
        m_pNotifier[uIndex]->SamplesAvailable = 0;
        m_pNotifier[uIndex]->EnvelopeActive = 0;
        m_pNotifier[uIndex]->Status = uErrorCode;
    }
    else
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CHalMCP1::WriteError - Notification memory not available\n");
    }

    aosDbgPrintString(DEBUGLEVEL_TRACEINFO, "NVARM: CHalMCP1::WriteError - Done\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CScratchDma.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to do DSP memory management*****************\
*                                                                           *
* Module: CScratchDma.h		                                                *
*   Object to handle pages/offsets etc for the scratch memory		        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CSCRATCHDMA_
#define _CSCRATCHDMA_

typedef struct _pageArray
{
    VOID *  pLin;
    U032    uPhys;
    U032    uBytesAvailBeg;     // bytes available on the beginning of the page
    U032    uBytesAvailEnd;     // bytes availbale at the end of the page
} PAGE_ARRAY, *PPAGE_ARRAY;

class CHalBase;

class CScratchDma
{
public:
    CScratchDma(CHalBase *pHal, U032 uRegOffset);
    ~CScratchDma();

public:
    RM_STATUS Initialize(MEM_DESC *pScratchTable);
    
    RM_STATUS Allocate(U032 uBytesReguested, U032 *pLinOffset);
    VOID Free(U032 uLinOffset, U032 uSize);

    VOID Write(U032 uLinOffset, VOID *pSource, U032 uSize);
    VOID Read(VOID *pDest, U032 uLinOffset, U032 uSize);

    VOID Put(U032 uLinOffset, U032 uVal);
    VOID Put(U032 uLinOffset, U032 uSize, U032 uVal);
    U032 Get(U032 uLinOffset);

    VOID *GetScratchTableLinAddr() { return m_ScratchTable.pLinAddr; }

    // only used to for AC-3 buffer sharing between GP & EP - use allocate
    // for all other purposes
    RM_STATUS AddPage(PMEM_DESC pMem, U032 uNumOfPages, U032 *pOffset);
    VOID RemovePage(PMEM_DESC pMem, U032 uNumOfPages);

    // debug only!
    VOID *GetPage(U032 uIndex) { return m_pPageTable[uIndex].pLin; }

    // these functions are to be used very very carefully
    // the address returned from here are not contiguous 
    // across the next page
    VOID *GetLinAddr(U032 uLinOffset);
    VOID *GetPhysAddr(U032 uLinOffset);

private:

    VOID RemovePage(U032 uIndex);
    VOID RemoveFromPageTable(U032 uIndex);

    U032 AddPage(U032 *pIndex, U032 uNum = 1);
    VOID AddToPageTable(U032 uIndex, VOID *pLinAddr, U032 uPhysAddr);

    U032 GetContiguousFreeIndex(U032 uNum);
    U032 GetPageIndex(VOID *pLin);

    U032 GetPageNumber(U032 uLinOffset) { return PAGENUM(uLinOffset); }
    U032 GetPageOffset(U032 uLinOffset) { return (uLinOffset & 0xFFF); }

    PAGE_ARRAY  *m_pPageTable;
    
    U016        m_uMaxPages;
    U016        m_uValidPages;
    MEM_DESC    m_ScratchTable;
    MEM_DESC    m_DummyPage;

    CHalBase    *m_pHal;
    U032        m_uRegOffsetValidPages;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\cscratchmanager.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to manage scratch***************************\
*                                                                           *
* Module: CScratchManager.cpp                                              *
*   Object to handle all RM-GP conversations via the scracth memory         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <aos.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include "CHalBase.h"
#include "CScratchDma.h"
#include "CScratchManager.h"


RM_STATUS   
CScratchManager::Initialize(VOID_PTR pLoader, 
                            U032 uLoaderSize)
{
    
    if (!m_pScratchDma)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CScratchManager::Initialize - one of the objects could not be constructed\n");
        return RM_ERROR;
    }
    
    // WARNING!  WARNING!  WARNING!
    // vik todo = this line is to test out the EP dolby digital stuff without
    // GP effects actually working... remove in final version!!!!

    m_uSize = 512 * PAGE_SIZE;
    
    /*
    just need enough memory to copy the loader program and the command node the GP polls
    m_uSize = uLoaderSize + whatever the command node size is...
    */

    RM_STATUS rmStatus = m_pScratchDma->Allocate(m_uSize, &m_uOffset);

    if (rmStatus != RM_OK)
        return rmStatus;

    // sanity check!
    if (m_uOffset)
    {
        // internal error!  it's all screwed up!
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CScratchManager::Initialize - Internal Error!!!\n");
        aosDbgBreakPoint();
    }

    // make sure the loader size is good
    if (uLoaderSize < MAX_SIZE_LOADER)
        m_pScratchDma->Write(m_uOffset, (VOID *)pLoader, uLoaderSize*sizeof(U032));
    else
        return RM_ERROR;

    return RM_OK;
}

VOID
CScratchManager::Shutdown()
{
    if (m_pScratchDma && m_uSize)
        m_pScratchDma->Free(m_uOffset, m_uSize);

    m_uSize = 0;
}

// debug onlY!
VOID *
CScratchManager::GetScratchPage(U032 uPageNumber) 
{ 
    return m_pScratchDma->GetPage(uPageNumber); 
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\cscratchdma.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Object to do DSP memory management*****************\
*                                                                           *
* Module: CScratchMemory.cpp		                                            *
*   Object to handle pages/offsets etc for the scratch memory		        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
extern "C"
{
#include <nvarm.h>
#include <aos.h>
#include <AudioHw.h>
#include <nv_papu.h>
};

#include "CHalBase.h"
#include "CScratchDma.h"

#define INVALID_INDEX_VALUE         (~0)

CScratchDma::CScratchDma(CHalBase *pHal, U032 uRegValidPages)
{
    m_uValidPages = 0;
    m_uMaxPages = 0;
    m_pPageTable = NULL;
    m_pHal = pHal;
    m_uRegOffsetValidPages = uRegValidPages;
}

CScratchDma::~CScratchDma()
{
    if (m_pPageTable)
    {
        // free all the memory
        for (U032 uCnt = 0; uCnt < m_uValidPages; uCnt++)
            aosFreeMem(m_pPageTable[uCnt].pLin);

        aosFreeMem(m_pPageTable);
        aosFreeMem(m_DummyPage.pLinAddr);
        m_pPageTable = NULL;
    }
}

RM_STATUS
CScratchDma::Initialize(MEM_DESC *pScratchTable)
{
	m_uMaxPages = (U016) (pScratchTable->Size / NV_PSGE_SIZE);
    aosMemCopy((VOID *)&m_ScratchTable, (VOID *)pScratchTable, sizeof(MEM_DESC));

    // allocate memory for the page table
    RM_STATUS rmStatus = aosAllocateMem(m_uMaxPages * sizeof(PAGE_ARRAY),
                                        ALIGN_DONT_CARE,
                                        (VOID **)&m_pPageTable,
                                        NULL);
    
    // allocate a dummy page, and point all unused PRDs to it
    m_DummyPage.Size = PAGE_SIZE;
    rmStatus = aosAllocateMem(m_DummyPage.Size,
                            ALIGN_4K,
                            &m_DummyPage.pLinAddr,
                            &m_DummyPage.pPhysAddr);
    
    aosZeroMemory(m_DummyPage.pLinAddr, m_DummyPage.Size);

    // make all the PRDs point to the dummy page...
    MCP1_PRD *pPrd = (MCP1_PRD *)m_ScratchTable.pLinAddr;

    for (U032 uCnt = 0; uCnt < m_uMaxPages; uCnt++)
    {
        pPrd[uCnt].uAddr = (U032)m_DummyPage.pPhysAddr;
        pPrd[uCnt].Control.uValue = 0;
        pPrd[uCnt].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;
    }

    if (rmStatus == RM_OK)
        aosZeroMemory(m_pPageTable, m_uMaxPages * sizeof(PAGE_ARRAY));
    
    m_pHal->RegWrite(m_uRegOffsetValidPages, m_uValidPages);

    return rmStatus;
}

RM_STATUS 
CScratchDma::Allocate(U032 uBytesReguested, U032 *pLinOffset)
{
    
    U032 uBytesAvail;

    // can the requirement be satisfied by the exisiting pages?
    for (U016 uCnt = 0; uCnt < m_uValidPages - 1; uCnt++)
    {
        uBytesAvail = 0;

        if (m_pPageTable[uCnt].pLin)
            uBytesAvail += m_pPageTable[uCnt].uBytesAvailEnd;
            
        if (m_pPageTable[uCnt + 1].pLin)
            uBytesAvail += m_pPageTable[uCnt].uBytesAvailBeg;

        if (uBytesReguested <= uBytesAvail)
        {
            if (m_pPageTable[uCnt].uBytesAvailEnd)
            {
                *pLinOffset = (PAGE_SIZE * uCnt) + m_pPageTable[uCnt].uBytesAvailEnd;
                if (m_pPageTable[uCnt].uBytesAvailEnd < uBytesReguested)
                {
                    m_pPageTable[uCnt + 1].uBytesAvailBeg = uBytesReguested - m_pPageTable[uCnt].uBytesAvailEnd;
                    m_pPageTable[uCnt].uBytesAvailEnd = 0;
                }
                else
                    m_pPageTable[uCnt].uBytesAvailEnd -= uBytesReguested;
            }
            else
            {
                *pLinOffset = PAGE_SIZE * (uCnt+1);
                m_pPageTable[uCnt + 1].uBytesAvailBeg -= uBytesReguested;
            }

            break;
        }
    }

    // did we satisfy the requirement
    if (uCnt < m_uValidPages - 1)
        return RM_OK;

    // elaborate the logic later to include end avail on pages other
    // than the last.. etc etc etc

    U016 uPagesNeeded = (U016)(((uBytesReguested+PAGE_SIZE-1)/PAGE_SIZE));
    U032 uPageIndex;

    RM_STATUS rmStatus = AddPage(&uPageIndex, uPagesNeeded);
    if (rmStatus != RM_OK)
        return rmStatus;
    
    m_uValidPages = uPagesNeeded;

    if (uPageIndex)
    {
        // get the 411 on the previous page and update it's offset
        *pLinOffset = (PAGE_SIZE * (uPageIndex-1) ) + m_pPageTable[uPageIndex-1].uBytesAvailEnd;
        uBytesReguested -= m_pPageTable[uPageIndex-1].uBytesAvailEnd;
        m_pPageTable[uPageIndex-1].uBytesAvailEnd = 0;
    }
    else
        *pLinOffset = PAGE_SIZE * uPageIndex;

    // spin thru' the pages updating the offsets on each page
    while (uBytesReguested)
    {
        m_pPageTable[uPageIndex].uBytesAvailBeg = 0;
        m_pPageTable[uPageIndex].uBytesAvailEnd = (PAGE_SIZE < uBytesReguested)?0:(PAGE_SIZE - uBytesReguested);
        uBytesReguested -= (PAGE_SIZE - m_pPageTable[uPageIndex].uBytesAvailEnd);
        uPageIndex++;
    }

    return rmStatus;
}

VOID
CScratchDma::Free(U032 uOffset, U032 uSize)
{
    U032 uPageIndex = GetPageNumber(uOffset);
    U032 uPageOffset = GetPageOffset(uOffset);
    
    if (uPageOffset)
    {
        m_pPageTable[uPageIndex].uBytesAvailEnd = PAGE_SIZE - uPageOffset;
        uSize -= m_pPageTable[uPageIndex].uBytesAvailEnd;
        uPageIndex++;
    }

    // how many pages are spanned?
    while(uSize)
    {
        if (PAGE_SIZE <= m_pPageTable[uPageIndex].uBytesAvailEnd + uSize)
        {   
            uSize -= (PAGE_SIZE - m_pPageTable[uPageIndex].uBytesAvailEnd);
            RemovePage(uPageIndex);
        }
        else
        {
            // this is the last page
            m_pPageTable[uPageIndex].uBytesAvailBeg = uSize;
            uSize = 0;
            if ( (m_pPageTable[uPageIndex].uBytesAvailBeg + m_pPageTable[uPageIndex].uBytesAvailBeg) == PAGE_SIZE)
                RemovePage(uPageIndex);
        }
    }
}

VOID
CScratchDma::RemovePage(U032 uIndex)
{
    aosFreeMem(m_pPageTable[uIndex].pLin);
    RemoveFromPageTable(uIndex);
}

VOID
CScratchDma::RemoveFromPageTable(U032 uIndex)
{
    m_pPageTable[uIndex].pLin = NULL;
    m_pPageTable[uIndex].uPhys = 0;

    MCP1_PRD *pPrd = (MCP1_PRD *)m_ScratchTable.pLinAddr;
    pPrd[uIndex].uAddr = (U032)m_DummyPage.pPhysAddr;
    pPrd[uIndex].Control.uValue = 0;
    pPrd[uIndex].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_NOT_HW;

    // do we need to update max valid pages?
    if (uIndex == (U032)(m_uValidPages - 1) )
    {
        // last page
        m_uValidPages--;
        m_pHal->RegWrite(m_uRegOffsetValidPages, m_uValidPages);
    }

    return;
}

U032
CScratchDma::GetContiguousFreeIndex(U032 uNum)
{
    bool bFlag;

    for (U032 uCnt = 0; uCnt < m_uMaxPages; uCnt++)
    {
        if (!m_pPageTable[uCnt].pLin)
        {
            bFlag = TRUE;

            // make sure we have contiguous indices free
            for (U032 uCnt1 = uCnt + 1; uCnt1 < (uCnt + uNum); uCnt1++)
            {
                if (m_pPageTable[uCnt].pLin)
                {
                    bFlag = FALSE;
                    break;
                }
            }

            if (bFlag == TRUE)
                return uCnt;
        }
    }

    return INVALID_INDEX_VALUE;
}

VOID
CScratchDma::AddToPageTable(U032 uIndex, VOID *pLinAddr, U032 uPhysAddr)
{
    m_pPageTable[uIndex].pLin = pLinAddr;
    m_pPageTable[uIndex].uPhys = uPhysAddr;

    // assume the pages are fully utilized
    m_pPageTable[uIndex].uBytesAvailBeg = 0;
    m_pPageTable[uIndex].uBytesAvailEnd = 0;
    
    // update the PRDs
    MCP1_PRD *pPrd = (MCP1_PRD *)m_ScratchTable.pLinAddr;
    pPrd[uIndex].uAddr = uPhysAddr;
    pPrd[uIndex].Control.uValue = 0;
    pPrd[uIndex].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;
    
    if (uIndex > (U032)m_uValidPages)
    {
        m_uValidPages = (U016)uIndex;
        m_pHal->RegWrite(m_uRegOffsetValidPages, m_uValidPages);
    }
}

RM_STATUS
CScratchDma::AddPage(U032 *pIndex, U032 uNum)
{
    RM_STATUS rmStatus = RM_ERROR;
    U032 uPagesAdded = 0;
    
    VOID *pLin;
    U032 uPhys;
    
    U032 uIndex = GetContiguousFreeIndex(uNum);

    if (uIndex == INVALID_INDEX_VALUE)
        return RM_ERROR;
    
    *pIndex = uIndex;

    while (uPagesAdded < uNum)
    {
        rmStatus =  aosAllocateMem( PAGE_SIZE,
						            ALIGN_4K,
						            &pLin,
						            (VOID **)&uPhys);

        if (rmStatus != RM_OK)
            break;

        AddToPageTable(uIndex, pLin, uPhys);

        uPagesAdded++;
        uIndex++;
    }
    
    return rmStatus;
}

RM_STATUS
CScratchDma::AddPage(PMEM_DESC pMem, U032 uNumOfPages, U032 *pOffset)
{
    RM_STATUS rmStatus = RM_OK;

    U032 uIndex = GetContiguousFreeIndex(uNumOfPages);
    if (uIndex == INVALID_INDEX_VALUE)
        return RM_ERROR;
    
    *pOffset = PAGE_SIZE * uIndex;

    // memory already allocated...
    for (U032 uCnt = 0; uCnt < uNumOfPages; uCnt++)
    {
        AddToPageTable(uIndex, pMem[uCnt].pLinAddr, (U032)pMem[uCnt].pPhysAddr);
        uIndex++;
    }

    return RM_OK;
}

U032
CScratchDma::GetPageIndex(VOID *pLin)
{
    for (U032 uCnt = 0; uCnt < m_uValidPages; uCnt++)
    {
        if (m_pPageTable[uCnt].pLin == pLin)
            return uCnt;
    }

    return INVALID_INDEX_VALUE;
}

VOID
CScratchDma::RemovePage(PMEM_DESC pMem, U032 uNumOfPages)
{
    U032 uIndex;

    for (U032 uCnt = 0; uCnt < uNumOfPages; uCnt++)
    {
        uIndex = GetPageIndex(pMem[uCnt].pLinAddr);
        if (uIndex != INVALID_INDEX_VALUE)
            RemoveFromPageTable(uIndex);
    }
}


VOID
CScratchDma::Write(U032 uLinOffset, VOID *pSource, U032 uSize)
{
    while(uSize)
    {
        U032 uDestSize = PAGE_SIZE - GetPageOffset(uLinOffset);
        U032 uCopySize = MIN(uDestSize, uSize);

#if defined DEBUG
        if (GetPageNumber(uLinOffset) > m_uValidPages)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "CScratchDma::Write - incorrect offset\n");
            aosDbgBreakPoint();
        }
#endif
        // destination ptr
        VOID *pDest = GetLinAddr(uLinOffset);
        aosMemCopy(pDest, pSource, uCopySize);

        uSize -= uCopySize;
        pSource = (VOID *)((U032)pSource + uCopySize);
        uLinOffset += uCopySize;
    }
}

VOID
CScratchDma::Read(VOID *pDest, U032 uLinOffset, U032 uSize)
{
    while (uSize)
    {
        U032 uSrcSize = PAGE_SIZE - GetPageOffset(uLinOffset);
        U032 uCopySize = MIN(uSrcSize, uSize);

#if defined DEBUG
        if (GetPageNumber(uLinOffset) > m_uValidPages)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "CScratchDma::Read - incorrect offset\n");
            aosDbgBreakPoint();
        }
#endif

        VOID *pSrc = GetLinAddr(uLinOffset);
        aosMemCopy(pDest, pSrc, uCopySize);

        uSize -= uCopySize;
        pDest = (VOID *)((U032)pDest + uCopySize);
        uLinOffset += uCopySize;
    }
}

U032
CScratchDma::Get(U032 uLinOffset)
{
#if defined DEBUG
        if (GetPageNumber(uLinOffset) > m_uValidPages)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "CScratchDma::Get - incorrect offset\n");
            aosDbgBreakPoint();
        }
#endif
    return *( (U032 *) GetLinAddr(uLinOffset) );
}

VOID
CScratchDma::Put(U032 uLinOffset, U032 uSize, U032 uVal)
{
    for (U032 uCnt = 0; uCnt < uSize; uCnt++)
        Put(uLinOffset + uCnt, uVal);
}

VOID
CScratchDma::Put(U032 uLinOffset, U032 uData)
{
#if defined DEBUG
        if (GetPageNumber(uLinOffset) > m_uValidPages)
        {
            aosDbgPrintString(DEBUGLEVEL_ERRORS, "CScratchDma::Put - incorrect offset\n");
            aosDbgBreakPoint();
        }
#endif
    *( (U032 *) GetLinAddr(uLinOffset) ) = uData;
}

VOID *
CScratchDma::GetLinAddr(U032 uLinOffset)
{
    return (VOID *)((U032)m_pPageTable[GetPageNumber(uLinOffset)].pLin + GetPageOffset(uLinOffset));
}

VOID *
CScratchDma::GetPhysAddr(U032 uLinOffset)
{
    return (VOID *)(m_pPageTable[GetPageNumber(uLinOffset)].uPhys + GetPageOffset(uLinOffset));
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CScratchManager.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base Object to manage scratch**********************\
*                                                                           *
* Module: CScratchManager.h                                                 *
*   Object to handle all RM-GP conversations via the scracth memory         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CSCRATCHMANAGER_
#define _CSCRATCHMANAGER_

#define MAX_SIZE_LOADER         (2048 * sizeof(U032))   /* in BYTES */

class CHalBase;
class CScratchDma;

class CScratchManager
{
public:
   CScratchManager()
   {
        m_pScratchDma = NULL;
        m_uSize = 0;
        m_uOffset = 0;
   }

public:

    RM_STATUS   Initialize( VOID_PTR pLoader, 
                            U032 uLoaderSize);
    VOID        Shutdown();

    CScratchDma *GetScratchDma() { return m_pScratchDma; }
    VOID        SetScratchDma(CScratchDma *pDma) { m_pScratchDma = pDma; }

    // debug only
    VOID *GetScratchPage(U032 uPageNumber);

private:
    CScratchDma     *m_pScratchDma;
    U032            m_uSize;
    U032            m_uOffset;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CMixerBuffer.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/****************************** DMA Manager ********************************\
*                                                                           *
* Module: CMixerBuffer.h													*
*   Class to resource manage the mixer buffers							    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CMIXERBUFFERH_
#define _CMIXERBUFFERH_

// max 256
#define MIXER_BUFFERS_HW            32
#define MIXER_BUFFERS_SW            32


class CMixerBuffer
{
public:

    enum MIXER_TYPE
    {
        HW,
        SW
    };

    CMixerBuffer()
    {
        U008 uCnt;

        for (uCnt = 0; uCnt < MIXER_BUFFERS_HW; uCnt++)
            m_bMixHw[uCnt] = FALSE;

        for (uCnt = 0; uCnt < MIXER_BUFFERS_SW; uCnt++)
            m_bMixSw[uCnt] = FALSE;
    }

    RM_STATUS Allocate(MIXER_TYPE eType, U008 *pId)
    {
        U008 uCnt;

        if (eType == HW)
        {
            for (uCnt = 0; uCnt < MIXER_BUFFERS_HW; uCnt++)
            {
                if (m_bMixHw[uCnt] == FALSE)
                {
                    *pId = uCnt;
                    m_bMixHw[uCnt] = TRUE;
                    return RM_OK;

                }
            }
        }
        else
        {
            for (uCnt = 0; uCnt < MIXER_BUFFERS_SW; uCnt++)
            {
                if (m_bMixSw[uCnt] == FALSE)
                {
                    *pId = MIXER_BUFFERS_HW + uCnt;
                    m_bMixSw[uCnt] = TRUE;
                    return RM_OK;

                }
            }
        }

        return RM_ERROR;
    }
    
    VOID Free(U008 uId)
    {
        if (uId < MIXER_BUFFERS_HW)
            m_bMixHw[uId] = FALSE;
        else
            m_bMixSw[uId - MIXER_BUFFERS_HW] = FALSE;
    }
    
private:
    BOOL m_bMixHw[MIXER_BUFFERS_HW];
    BOOL m_bMixSw[MIXER_BUFFERS_SW];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CObjBase.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************Base class for the HAL******************************\
*                                                                           *
* Module: CObjBase.h                                                        *
*   All functions common to diff HALs are implemented here			        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _COBJBASEH_
#define _COBJBASEH_

class CHalBase;

class CObjBase
{
public:
	CObjBase(CHalBase *pHal)	{ m_pHal = pHal; }

public:
	// each derived object has to implement these functions
	virtual RM_STATUS Allocate(VOID *pParam) = 0;
	virtual RM_STATUS Free(VOID *pParam = NULL) = 0;
    
    // each derived object also has to make a method handler
    // for any software methods associated with the object

protected:
	
	virtual VOID RegWrite(U032 uOffset, U032 uValue) { m_pHal->RegWrite(uOffset, uValue); }
	virtual VOID RegWrite(U032 uOffset, U016 uValue) { m_pHal->RegWrite(uOffset, uValue); }
	virtual VOID RegWrite(U032 uOffset, U008 uValue) { m_pHal->RegWrite(uOffset, uValue); }

	virtual VOID RegRead(U032 uOffset, U032 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, U016 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, U008 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, volatile U032 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, volatile U016 *pValue) { m_pHal->RegRead(uOffset, pValue); }
	virtual VOID RegRead(U032 uOffset, volatile U008 *pValue) { m_pHal->RegRead(uOffset, pValue); }

    virtual void MemWrite(U032 uAddr, U008 uData)    { 	m_pHal->MemWrite(uAddr, uData);   }
    virtual void MemWrite(U032 uAddr, U016 uData)    { 	m_pHal->MemWrite(uAddr, uData);   }
    virtual void MemWrite(U032 uAddr, U032 uData)    { 	m_pHal->MemWrite(uAddr, uData);   }

    CHalBase *GetDevice()           { return m_pHal; }

private:
	CHalBase *m_pHal;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CHalVoiceProc.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/************************VP class for the HAL******************************\
*                                                                           *
* Module: CHalVoiceProc.h                                                   *
*   Functions for the voice processor in MCP1.. can be used for future      *
*   revs, if the HW processor object does not change                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CHALVOICEPROCH_
#define _CHALVOICEPROCH_

class CHalBase;
class CObjBase;
class CVPMethod;
class CHalGlobalProc;

class CHalVoiceProc : public CObjBase
{
public:
    CHalVoiceProc(CHalGlobalProc *pGlProc, CHalBase *pHal) : CObjBase(pHal) 
    { 
        m_pMethod = NULL;
        m_pNotifier = NULL;
        m_pGlobalProc = pGlProc;
    };

	~CHalVoiceProc() { };

public:

	// each derived object has to implement these functions
	RM_STATUS Allocate(VOID *pParam);
	RM_STATUS Free(VOID *pParam = NULL);
	RM_STATUS GetCaps(VOID *pParam);
    
    VOID    SetNotifierMemory(VOID *pLinAddr, U032 uSize)   
    { 
        m_pNotifier = (PNV1BA0NOTIFICATION *)pLinAddr; 
        m_uNotifierSize = uSize; 
    }

    VOID    WriteNotifier(U032 uMethod, U008 uStatus, BOOL bVoiceMethod = 0);

    // called from the interrupt handler
    VOID    ExecuteMethod(U032 uMethod, U032 uParam);

    void *  GetSgeInLinAddr()   { return m_SgeIn.pLinAddr; }
    U032    GetSgeInSize()      { return m_SgeIn.Size; }

    void *  GetSegInLinAddr()   { return m_SegIn.pLinAddr; }
    U032    GetSegInSize()      { return m_SegIn.Size; }

private:
	VOID InitializeHardware(APU_AP_CREATE *);

    RM_STATUS AllocateMemory(APU_AP_CREATE *);
    VOID FreeMemory();

    MEM_DESC    m_Voice;
    MEM_DESC    m_SgeIn;
    MEM_DESC    m_SegIn;
    MEM_DESC    m_HRTFTarg;
    MEM_DESC    m_HRTFCurr;

    CVPMethod           *m_pMethod;
    CHalGlobalProc      *m_pGlobalProc;

    PNV1BA0NOTIFICATION *m_pNotifier;
    U032                m_uNotifierSize;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CVPMethod.cpp ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CMCP1Method.cpp                                                     *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

extern "C"
{
#include <nvarm.h>
#include <nv_uap.h>
#include <nv_papu.h>
#include <AudioHw.h>
#include <nv32.h>
};
#include <aos.h>
#include <ahal.h>

#include "CHalBase.h"
#include "CObjBase.h"
#include "CHalVoiceProc.h"
#include "CHalGlobalProc.h"
#include <CLinkList.h>
#include "CContextDma.h"
#include "CVPMethod.h"

VOID
CVPMethod::Execute(U032 uOffset, U032 uData)
{
    RM_STATUS rmStatus = RM_ERROR;  // not implemented

    do
    {
        if (CheckRange(uOffset, NV1BA0_PIO_SET_CONTEXT_DMA_NOTIFY))
        {
            rmStatus = SetContextDMANotify(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BA0_PIO_SET_CURRENT_SSL_CONTEXT_DMA))
        {
            rmStatus = SetCurrentSSLContextDMA(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BA0_PIO_SET_CURRENT_INBUF_SGE_CONTEXT_DMA))
        {
            rmStatus = SetCurrentInBufSGEContextDMA(uData);
            break;
        }

        if (CheckRange(uOffset, NV1BA0_PIO_SET_CURRENT_BUFFER_SGE_CONTEXT_DMA))
        {
            rmStatus = SetCurrentOutBufSGEContextDMA(uData);
            break;
        }
        
        if (CheckRange(uOffset, 0x4000))        // to be moved to the .ref file.. todo vik
        {
            rmStatus = SetGPState(uData);
            break;
        }

        if (CheckRange(uOffset, 0x4004))        // debug...
        {
            rmStatus = SetCurrentOutBufSGEOffset(uData);
            break;
        }
        
        if (CheckRange(uOffset, 0x4008))        // debug...
        {
            rmStatus = SetCurrentInBufSGEOffset(uData);
            break;
        }

        if (CheckRange(uOffset, 0x422C))        // debug...
        {
            rmStatus = SetXCNTMode(uData);
            break;
        }
        
        U032 uCnt = 0;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if (CheckRange(uOffset, (0x420C + (uCnt*8))) )
            {
                rmStatus = SetOutBufBA(uData, uCnt);
                break;
            }
        }
        
        if (uCnt != 4)
            break;

        for (uCnt = 0; uCnt < 4; uCnt++)
        {
            if (CheckRange(uOffset, (0x4210 + (uCnt*8))) )
            {
                rmStatus = SetOutBufLen(uData, uCnt);
                break;
            }
        }

        if (uCnt != 4)
            break;

        // find out if NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET got triggered
        for (uCnt = 0; uCnt < 64; uCnt++)
        {
            if (CheckRange(uOffset, (0x400C + (uCnt*8))) )
            {
                rmStatus = SetSSLSegmentOffset(uData);
                break;
            }
        }
        
        if (uCnt != 64)
            break;

        for (uCnt = 0; uCnt < 64; uCnt++)
        {
            if (CheckRange(uOffset, (0x4010 + (uCnt*8))) )
            {
                rmStatus = SetSSLSegmentOffsetLength(uData, uCnt);
                break;
            }
        }

        if (uCnt != 64)
            break;
        
        aosDbgPrintString(DEBUGLEVEL_WARNINGS, "NVARM: CMCP1Method::Execute - SW method not yet implemented!\n");

#if defined WDM
        KdPrint(("Method offset = 0x%x Method Data = 0x%x\n", uOffset, uData));
#endif

    } while (FALSE);

    if (rmStatus != RM_OK)
    {
        // function failed.. write a notifier
        if (m_pVoiceProc)
            m_pVoiceProc->WriteNotifier(uOffset, (U008)rmStatus);
    }
 
}

// software methods
RM_STATUS
CVPMethod::SetContextDMANotify(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if ((U032)(pDma->GetAddress()) & 0xFF)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetContextDMANotify - Address not aligned on 256bytes boundary\n");
        return RM_ERROR;
    }
    
    if (m_pVoiceProc)
        m_pVoiceProc->SetNotifierMemory(pDma->GetLinAddr(), pDma->GetSize());

    m_pHal->RegWrite(NV_PAPU_FENADDR, (U032)pDma->GetAddress());
    return RM_OK;
}

RM_STATUS
CVPMethod::SetCurrentSSLContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetCurrentSSLContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FESESSLCTXPA, (U032)pDma->GetAddress());
    m_pHal->RegWrite(NV_PAPU_FESESSLMAXOFF, (U032)pDma->GetSize());

    return RM_OK;
}

RM_STATUS
CVPMethod::SetCurrentInBufSGEContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetCurrentInBufSGEContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FESESGECTXPA, (U032)pDma->GetAddress());
    m_pHal->RegWrite(NV_PAPU_FESESGEMAXOFF, (U032)pDma->GetSize());

    return RM_OK;
}

RM_STATUS
CVPMethod::SetCurrentOutBufSGEContextDMA(U032 uData)
{
    CContextDma *pDma = (CContextDma *)uData;

    if (((U032)(pDma->GetAddress()) & 0xFFF) ||
        (pDma->GetSize() & 0xFFF))
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: SetCurrentOutBufSGEContextDMA - Address not aligned on 4K boundary\n");
        return RM_ERROR;
    }

    m_pHal->RegWrite(NV_PAPU_FEGPSGECTXPA, (U032)pDma->GetAddress());
    m_pHal->RegWrite(NV_PAPU_FEGPSGEMAXOFF, (U032)pDma->GetSize());

    return RM_OK;
}






RM_STATUS
CVPMethod::SetGPState(U032 uData)
{
    R_GP_CONTROL rControl;
    rControl.uValue = 0;

    switch (uData)
    {
        case 0:
        {
            // stop the GP
            // take it out of reset...
            R_GP_RESET rReset;
            rReset.uValue = 0;
            rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;
            rReset.DSP = NV_PAPU_GPRST_GPDSPRST_ENABLED;
            rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;
            rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;

            m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);
            break;
        }
        case 1:
        {

            SetXCNTMode(GSCNT_OFF);
            //Take the GP Peripherals out of reset but leave DSP core reset
            R_GP_RESET rReset;
            rReset.uValue = 0;

            m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);

            // take it out of reset...

            rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;
            rReset.DSP = NV_PAPU_GPRST_GPDSPRST_ENABLED;
            rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;
            rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;
    
            m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);

            // clear the GPISTS bit
            m_pHal->RegWrite(NV_PAPU_GPISTS, (U032)0xff);

            // auto start and auto idle
            R_GPDMA_CONFIG rConfig;
            rConfig.uValue = 0;
            //rConfig.Start = NV_PAPU_GPDCFG_GPDASTRT_ENABLED;
            //rConfig.Ready = NV_PAPU_GPDCFG_GPDARDY_ENABLED;
            m_pHal->RegWrite(NV_PAPU_GPDCFG, rConfig.uValue);




            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CMCP1Method::SetGPState - the GP might just start...");
            // enable the GP
            rControl.Idle = NV_PAPU_GPIDRDY_GPSETIDLE_SET;
            rControl.IntrNotify = NV_PAPU_GPIDRDY_GPSETNINT_NOT_SET;

            m_pHal->RegWrite(NV_PAPU_GPIDRDY, rControl.uValue);
            break;
        }
        case 3:
        {
            SetXCNTMode(GSCNT_ACSYNC);
            //Take the GP Peripherals and DSP core out of reset
            R_GP_RESET rReset;
            rReset.uValue = 0;
            m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);

            // take it out of reset...

            rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;
            rReset.DSP = NV_PAPU_GPRST_GPDSPRST_ENABLED;
            rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;
            rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;
    
            m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);


            // auto start and auto idle
            R_GPDMA_CONFIG rConfig;
            rConfig.uValue = 0;
            m_pHal->RegWrite(NV_PAPU_GPDCFG, rConfig.uValue);

            // clear the GPISTS bit
            m_pHal->RegWrite(NV_PAPU_GPISTS, (U032)0xff);


            U032 uXgscnt;
            U032 uDgscnt;

            m_pHal->RegRead(NV_PAPU_XGSCNT, &uXgscnt);
            m_pHal->RegRead(NV_PAPU_DGSCNT, &uDgscnt);
            m_pHal->RegWrite(NV_PAPU_IGSCNT, uXgscnt+uDgscnt);

            rReset.Global = NV_PAPU_GPRST_GPRST_DISABLED;
            rReset.DSP = NV_PAPU_GPRST_GPDSPRST_DISABLED;
            rReset.NMI = NV_PAPU_GPRST_GPNMI_DISABLED;
            rReset.Abort = NV_PAPU_GPRST_GPABORT_DISABLED;
    
            m_pHal->RegWrite(NV_PAPU_GPRST, rReset.uValue);


            aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: CMCP1Method::SetGPState - the GP might just start...");

            break;
        }
    }

    aosDbgPrintString(DEBUGLEVEL_ERRORS, "done.  Congratulations!\n");
    return RM_OK;
}


//Set the NV_PAPU_SECTL_XCNTMODE register

RM_STATUS
CVPMethod::SetXCNTMode(U032 uData)
{

    U032  dwXcntMode;  
    switch(uData)
   {
       case GSCNT_OFF:
           dwXcntMode = NV_PAPU_SECTL_XCNTMODE_OFF;
            break;
       case GSCNT_ACSYNC:
            dwXcntMode = NV_PAPU_SECTL_XCNTMODE_AC_SYNC;
            break;
       case GSCNT_SW:
           dwXcntMode = NV_PAPU_SECTL_XCNTMODE_SW;
            break;
       case GSCNT_FREE_RUNNING:
           dwXcntMode = NV_PAPU_SECTL_XCNTMODE_FREE_RUNNING;
            break;
   }

    R_SE_CONTROL rSeControl;

    m_pHal->RegRead(NV_PAPU_SECTL, &rSeControl.uValue);

    rSeControl.GSCUpdate = uData;

    m_pHal->RegWrite(NV_PAPU_SECTL, rSeControl.uValue);

    return RM_OK;
}


// NV1BA0_PIO_SET_CURRENT_OUTBUF_SGE_OFFSET
RM_STATUS
CVPMethod::SetCurrentOutBufSGEOffset(U032 uData)
{
    MCP1_PRD *pLin = (MCP1_PRD *)(m_pGlobalProc->GetSgeOutLinAddr());

    pLin->uAddr = uData;
    pLin->Control.uValue = 0;
    pLin->Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;      // owned by HW

    return RM_OK;
}

// NV1BA0_PIO_SET_CURRENT_INBUF_SGE_OFFSET
RM_STATUS
CVPMethod::SetCurrentInBufSGEOffset(U032 uData)
{
    VOLU32 uTemp;

    // find out the max offset
    m_pHal->RegRead(NV_PAPU_FESESGEMAXOFF, &uTemp);
    if (uTemp < uData)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetCurrentInBufSGEOffset - max offset exceeded!\n");
        return RM_ERROR;
    }

    R_FE_CONTROL rFeCtl;

    m_pHal->RegRead(NV_PAPU_FECTL, &rFeCtl.uValue);
    if (rFeCtl.ValidSESGE == NV_PAPU_FECTL_FESESGECTXPA_VALID_NO)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetCurrentInBufSGEOffset - SGE context dma valid bit not set\n");
        return RM_ERROR;
    }

    // find the right PRD to write to
    MCP1_PRD *pPrd = (MCP1_PRD *)(m_pVoiceProc->GetSgeInLinAddr());
    U032 uNumOfPrds = (m_pVoiceProc->GetSgeInSize())/NV_PSGE_SIZE;

    // read the current index to write to...
    m_pHal->RegRead(NV_PAPU_FECSESGE, &uTemp);

    // a little error checking of my own..
    if (uNumOfPrds < uTemp)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetCurrentInBufSGEOffset - current index greater than total PRDs allocated\n");
        return RM_ERROR;
    }

    VOLU32 uBase;
    m_pHal->RegRead(NV_PAPU_FESESGECTXPA, &uBase);

    // make the PRD (not 0 based.. i think)
    pPrd[uTemp-1].uAddr = uBase + uData;
    pPrd[uTemp-1].Control.uValue = 0;
    pPrd[uTemp-1].Control.Owner = NV_PSSL_PRD_CONTROL_OWN_HW;

    return RM_OK;
}

// NV1BA0_PIO_SET_SSL_SEGMENT_OFFSET
RM_STATUS
CVPMethod::SetSSLSegmentOffset(U032 uData)
{
    // error checking .. to hell with it! (for now)
    // logic has changed in HW
    /*
    if (uData & 0xFFF)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetSSLSegmentOffset - alignment check fails!\n");
        return RM_ERROR;
    }
    
    // save it as pending
    uData = uData | NV_PAPU_FESESSLPENDOFF_VALID_YES;

    m_pHal->RegWrite(NV_PAPU_FESESSLPENDOFF, uData);
    */

    return RM_ERROR;
}

// NV1BA0_PIO_SET_SSL_SEGMENT_LENGTH
RM_STATUS
CVPMethod::SetSSLSegmentOffsetLength(U032 uData, U032 uIndex)
{
    /*
    Check that the offset has already been saved by the previous method.
    Check that container_size != 2. 
    Check that (offset & container_size) == 0.
    Check that samples_per_block > stereo.
    
    Then, check the offset and length as follows:
    
           offset+(length*container_size*samples_per_block) <= maxoff
    */
    
    /*
    MCP1_PRD *pPrd = (MCP1_PRD *)(m_pHal->GetVoiceProc()->GetSegInLinAddr());
    
    // calculate the index of the SSL
    VOLU16 uCurrSSL = 0;
    m_pHal->RegRead(NV_PAPU_FECSESSL, &uCurrSSL);
    
    uIndex += (uCurrSSL * 64);
    
    // read the offset previosuly set
    VOLU32 uPendOffset = 0;
    m_pHal->RegRead(NV_PAPU_FESESSLPENDOFF, &uPendOffset);
    
    // just for fun confirm that it's valid
    if ((uPendOffset & 0x1) != NV_PAPU_FESESSLPENDOFF_VALID_YES)
    {
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "CMCP1Method::SetSSLSegmentOffsetLength - u can only set length after setting the offset!\n");
        return RM_ERROR;
    }
    
    VOLU32 uBase;
    m_pHal->RegRead(NV_PAPU_FESESSLCTXPA, &uBase);
    
    // these don't look like being '0' based
    pPrd[uIndex-1].uAddr = uBase + (uPendOffset & 0xFFFFF000);
    pPrd[uIndex-1].Control.uValue = uData;
    */

    return RM_ERROR;
}

// NV1BA0_PIO_SET_OUTBUF_BA(i)
RM_STATUS
CVPMethod::SetOutBufBA(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffEnd;

    switch(uIndex)
    {
    case 0:
        uOffBase = NV_PAPU_GPOFBASE0;
        uOffEnd = NV_PAPU_GPOFEND0;
        break;
    case 1:
        uOffBase = NV_PAPU_GPOFBASE1;
        uOffEnd = NV_PAPU_GPOFEND1;
        break;
    case 2:
        uOffBase = NV_PAPU_GPOFBASE2;
        uOffEnd = NV_PAPU_GPOFEND2;
        break;
    case 3:
        uOffBase = NV_PAPU_GPOFBASE3;
        uOffEnd = NV_PAPU_GPOFEND3;
        break;
    }

    m_pHal->RegWrite(uOffBase, uData);
    m_pHal->RegWrite(uOffEnd, uData);

    return RM_OK;
}

// NV1BA0_PIO_SET_OUTBUF_LEN(i)
RM_STATUS
CVPMethod::SetOutBufLen(U032 uData, U032 uIndex)
{
    U032 uOffBase;
    U032 uOffEnd;

    switch(uIndex)
    {
    case 0:
        uOffBase = NV_PAPU_GPOFBASE0;
        uOffEnd = NV_PAPU_GPOFEND0;
        break;
    case 1:
        uOffBase = NV_PAPU_GPOFBASE1;
        uOffEnd = NV_PAPU_GPOFEND1;
        break;
    case 2:
        uOffBase = NV_PAPU_GPOFBASE2;
        uOffEnd = NV_PAPU_GPOFEND2;
        break;
    case 3:
        uOffBase = NV_PAPU_GPOFBASE3;
        uOffEnd = NV_PAPU_GPOFEND3;
        break;
    }
    
    U032 uBaseAddr;
    m_pHal->RegRead(uOffBase, &uBaseAddr);

    m_pHal->RegWrite(uOffEnd, uBaseAddr + uData);
    
    return RM_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\AudioFx\DSP_Util.cpp ===
// ****************************************************************
//
//	DSP_Util:		DSP Execution Support routines
//
//	Written by Gints Klimanis
//
// ****************************************************************
#include "DSP_Util.h"

// ****************************************************************
// DefaultCommandNode:		
// **************************************************************** 
	void
DefaultCommandNode(DSPCOMMANDNODE *d)
{
d->commandID     =  kDSPCommandID_IgnoreMe;		
d->stateID       = (kDSPStateID_ModuleListStopped | kDSPStateID_WaitingForCommand);			
d->moduleIndex = 0;	

d->moduleCount = 0;	

d->dspModuleBlock      = 0;
d->dspModuleStateBlock = 0;
d->dspModuleCodeBlock  = 0;

d->dspModuleBlockSize      = 0;
d->dspModuleStateBlockSize = 0;
d->dspModuleCodeBlockSize  = 0;
}	// ---- end DefaultCommandNode() ---- 

// ****************************************************************
// DefaultDSPModule:		
// **************************************************************** 
	void
DefaultDSPModule(DSPMODULE *d)
{
d->state   = 0;
d->compute = 0;
d->typeID  = 2; //kAudioFxModule_Null;

}	// ---- end DefaultDSPModule() ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\AudioFx\DSP_Util.h ===
// *************************************************************************
//
//	DSP_Util.h		Support functions for DSP System memory operations
//
//	Written by Gints Klimanis
//
// *************************************************************************
//
#ifndef __DSP_UTIL_H__
#define	__DSP_UTIL_H__

#include "util.h"

#define kAudioFX_SMAddress_CommandNode		 9000
#define kAudioFX_SMAddress_ModuleBlock		 9500
#define kAudioFX_SMAddress_StateBlock		10000
#define kAudioFX_SMAddress_CodeBlock		12000

// ****************************************************************
// Command/Status for driver <-> DSP messaging.   This is done
//							every few frames by DMAing the system 
//							memory command block
// ****************************************************************
typedef struct dspcommandnode {
	Int24	stateID;		// Values: kDSPState ID's
	Int24	commandID;		// Values: kDSPCommand ID's
	Int24	moduleIndex;	// {0..N-1}, used only for commands that operate on 
							// a single module

	Int24	moduleCount;	// {0 .. kMaxDSPModules-1}

	Int24	dspModuleBlock;
	Int24	dspModuleStateBlock;
	Int24	dspModuleCodeBlock;

	Int24	dspModuleBlockSize;
	Int24	dspModuleStateBlockSize;
	Int24	dspModuleCodeBlockSize;

	Int24	misc1;
	Int24	misc2;
	Int24	misc3;

} DSPCOMMANDNODE;

void DefaultCommandNode(DSPCOMMANDNODE *d);

// Bit 0
#define kDSPCommandID_IgnoreMe						0x00
#define kDSPCommandID_CheckForCommand				0x01
// Bit 1
#define kDSPCommandID_StopDSPList					0x00
#define kDSPCommandID_RunDSPList					0x02
// Bit 4:2
#define kDSPCommandID_LoadDSPBlock_ModuleList		0x04
#define kDSPCommandID_LoadDSPBlock_Code				0x08
#define kDSPCommandID_LoadDSPBlock_State			0x10


// The following commands access parts of the State block
// Reset and Prepare will be the same if the DSP relies on the
// driver to do all of the high->low level parameter conversions
#define kDSPCommandID_ResetAllDSPModuleStates		5
#define kDSPCommandID_UpdateAllDSPModuleParameters	6
#define kDSPCommandID_PrepareAllDSPModules			7	// Prepare = Update + Reset

// For "Single" commands, include module index in command node
#define kDSPCommandID_ResetOneDSPModuleState		8	
#define kDSPCommandID_UpdateOneDSPModuleParameters	9	
#define kDSPCommandID_PrepareOneDSPModule			10	

// Debug Stuff
// misc1= RAM Word Address (0-based, not mapped address)
// misc2= # words
// misc2= SM Byte Address
#define kDSPCommandID_DumpXRAM		10		
#define kDSPCommandID_DumpYRAM		11	
#define kDSPCommandID_DumpPRAM		12	

// dspStateWord Bit 0 is waiting processing bit
#define kDSPStateID_WaitingBitCommandMask		0x1	// 1=waiting, 0=processing
#define kDSPStateID_ProcessingCommand			0x0	// 1=waiting, 0=processing
#define kDSPStateID_WaitingForCommand			0x1	// 1=waiting, 0=processing

// dspStateWord Bit 1 is running bit
#define kDSPStateID_ModuleListRunningBitMask	0x2	// 1=running, 0=stopped
#define kDSPStateID_ModuleListRunning			0x2	// 1=running, 0=stopped
#define kDSPStateID_ModuleListStopped			0x0	// 1=running, 0=stopped


// ****************************************************************
//  DSP Module block:  concatenation of DSPModule structures
// ****************************************************************

// Size of low-level data structure used by DSP Code
#define kDSPState_DMATransfer_Size	3	// DATA_SIZE_DMATRANSFER
#define kDSPState_Mixer_Size		3	// DATA_SIZE_MIXER
#define kDSPState_NullModule_Size	3	// DATA_SIZE_
#define kDSPState_Limiter_Size		3	// DATA_SIZE_LIMITER

#define kDSPState_AmpMod_Size		3	// DATA_SIZE_AMPMOD
#define kDSPState_Chorus_Size		3	// DATA_SIZE_CHORUS
#define kDSPState_Compressor_Size	3	// DATA_SIZE_COMPRESSOR
#define kDSPState_Delay_Size		3	// DATA_SIZE_DELAY
#define kDSPState_Distortion_Size	3	// DATA_SIZE_DISTORTION
#define kDSPState_Echo_Size			3	// DATA_SIZE_ECHO
#define kDSPState_Equalizer_Size	3	// DATA_SIZE_EQUALIZER
#define kDSPState_Flange_Size		3	// DATA_SIZE_FLANGE
#define kDSPState_IIR1_Size			3	// DATA_SIZE_IIR1
#define kDSPState_IIR2_Size			3	// DATA_SIZE_IIR2
#define kDSPState_IIIR_Size			3	// DATA_SIZE_IIIR
#define kDSPState_Oscillator_Size	3	// DATA_SIZE_OSCILLATOR
#define kDSPState_Reverb_Size		3	// DATA_SIZE_REVERB

// Low level data accessed by DSP
typedef struct { Int24	d[kDSPState_DMATransfer_Size]; } DSP_DMATRANSFER_STATE;
typedef struct { Int24	d[kDSPState_Mixer_Size      ]; } DSP_MIXER_STATE;
typedef struct { Int24	d[kDSPState_NullModule_Size ]; } DSP_NULLMODULE_STATE;
typedef struct { Int24	d[kDSPState_Limiter_Size    ]; } DSP_LIMITER_STATE;

typedef struct { Int24	d[kDSPState_AmpMod_Size     ]; } DSP_AMPMOD_STATE;
typedef struct { Int24	d[kDSPState_Chorus_Size     ]; } DSP_CHORUS_STATE;
typedef struct { Int24	d[kDSPState_Compressor_Size ]; } DSP_COMPRESSOR_STATE;
typedef struct { Int24	d[kDSPState_Delay_Size      ]; } DSP_DELAY_STATE;
typedef struct { Int24	d[kDSPState_Distortion_Size ]; } DSP_DISTORTION_STATE;
typedef struct { Int24	d[kDSPState_Echo_Size       ]; } DSP_ECHO_STATE;
typedef struct { Int24	d[kDSPState_Equalizer_Size  ]; } DSP_EQUALIZER_STATE;
typedef struct { Int24	d[kDSPState_Flange_Size     ]; } DSP_FLANGE_STATE;
typedef struct { Int24	d[kDSPState_IIR1_Size       ]; } DSP_IIR1_STATE;
typedef struct { Int24	d[kDSPState_IIR2_Size       ]; } DSP_IIR2_STATE;
typedef struct { Int24	d[kDSPState_IIIR_Size       ]; } DSP_IIIR_STATE;
typedef struct { Int24	d[kDSPState_Oscillator_Size ]; } DSP_OSCILLATOR_STATE;
typedef struct { Int24	d[kDSPState_Reverb_Size     ]; } DSP_REVERB_STATE;


// The DSP execution list is contructed of these modules
typedef struct dspmodule {
// Note:  Don't reorder these fields because DSP execution kernel
// expects the values in specific places.
	Int24	state;		// Low-level data, I/O ptrs are stored in state, In1Out1, In2/Out2, etc.
	Int24	compute;	// Ptr to compute routine in PRAM
	Int24   typeID;		// Algorithm/I/O type
}  DSPMODULE;

#define kDSPMODULE_Words	(sizeof(DSPMODULE)/sizeof(Int24))
void DefaultDSPModule  (DSPMODULE      *d);

// ****************************************************************
//  DSP Module state block:  concatenation of state structures,
//							excluding delay lines.  Reset command will
//							DMA this stuff into DSP XRAM and zero out
//							delay line memory.
//
//			(initial state given latest parameter set)
// ****************************************************************
#define kState_MaxSize	20		// in Int24 words

// ****************************************************************
// DSP Module code block:		Linked DSP Module Compute subroutines
//							and library routines
//
//		160 MHz/48000 = 3333 cycles
// ****************************************************************
#define kSysMem_DSPModuleCodeBlockMaxLength		3000

// MixBuffers 0x1400 through 0x17ff  Two banks of 32 Mixbuffers of 32 words each
//	2 banks x 32 Buffers/bank x 32 words/buffer = 2048 ($1000) words
#define kMixBufferSize			kFrameLength
#define kMixBufferLength		kFrameLength

#define kGPMemory_MixBuffers		0x001400	
#define kGPMemory_MixBuffer00		(kGPMemory_MixBuffers)	
#define kGPMemory_MixBuffer01		(kGPMemory_MixBuffer00+kMixBufferLength)	
#define kGPMemory_MixBuffer02		(kGPMemory_MixBuffer01+kMixBufferLength)	
#define kGPMemory_MixBuffer03		(kGPMemory_MixBuffer02+kMixBufferLength)	
#define kGPMemory_MixBuffer04		(kGPMemory_MixBuffer03+kMixBufferLength)	
#define kGPMemory_MixBuffer05		(kGPMemory_MixBuffer04+kMixBufferLength)	
#define kGPMemory_MixBuffer06		(kGPMemory_MixBuffer05+kMixBufferLength)	
#define kGPMemory_MixBuffer07		(kGPMemory_MixBuffer06+kMixBufferLength)	
#define kGPMemory_MixBuffer08		(kGPMemory_MixBuffer07+kMixBufferLength)	
#define kGPMemory_MixBuffer09		(kGPMemory_MixBuffer08+kMixBufferLength)	
#define kGPMemory_MixBuffer10		(kGPMemory_MixBuffer09+kMixBufferLength)	
#define kGPMemory_MixBuffer11		(kGPMemory_MixBuffer10+kMixBufferLength)	
#define kGPMemory_MixBuffer12		(kGPMemory_MixBuffer11+kMixBufferLength)	
#define kGPMemory_MixBuffer13		(kGPMemory_MixBuffer12+kMixBufferLength)	
#define kGPMemory_MixBuffer14		(kGPMemory_MixBuffer13+kMixBufferLength)	
#define kGPMemory_MixBuffer15		(kGPMemory_MixBuffer14+kMixBufferLength)
	
#define kGPMemory_MixBuffer16		(kGPMemory_MixBuffer15+kMixBufferLength)	
#define kGPMemory_MixBuffer17		(kGPMemory_MixBuffer16+kMixBufferLength)	
#define kGPMemory_MixBuffer18		(kGPMemory_MixBuffer17+kMixBufferLength)	
#define kGPMemory_MixBuffer19		(kGPMemory_MixBuffer18+kMixBufferLength)	
#define kGPMemory_MixBuffer20		(kGPMemory_MixBuffer19+kMixBufferLength)	
#define kGPMemory_MixBuffer21		(kGPMemory_MixBuffer20+kMixBufferLength)	
#define kGPMemory_MixBuffer22		(kGPMemory_MixBuffer21+kMixBufferLength)	
#define kGPMemory_MixBuffer23		(kGPMemory_MixBuffer22+kMixBufferLength)	
#define kGPMemory_MixBuffer24		(kGPMemory_MixBuffer23+kMixBufferLength)	
#define kGPMemory_MixBuffer25		(kGPMemory_MixBuffer24+kMixBufferLength)	
#define kGPMemory_MixBuffer26		(kGPMemory_MixBuffer25+kMixBufferLength)	
#define kGPMemory_MixBuffer27		(kGPMemory_MixBuffer26+kMixBufferLength)	
#define kGPMemory_MixBuffer28		(kGPMemory_MixBuffer27+kMixBufferLength)	
#define kGPMemory_MixBuffer29		(kGPMemory_MixBuffer28+kMixBufferLength)	
#define kGPMemory_MixBuffer30		(kGPMemory_MixBuffer29+kMixBufferLength)	
#define kGPMemory_MixBuffer31		(kGPMemory_MixBuffer30+kMixBufferLength)	

#define kGPMemory_TmpBuffers		0x0	
#define kGPMemory_TmpBuffer00		(kGPMemory_TmpBuffers)	
#define kGPMemory_TmpBuffer01		(kGPMemory_TmpBuffer00+kMixBufferLength)	
#define kGPMemory_TmpBuffer02		(kGPMemory_TmpBuffer01+kMixBufferLength)	
#define kGPMemory_TmpBuffer03		(kGPMemory_TmpBuffer02+kMixBufferLength)	

#define kGPMemory_TmpBuffer0		kGPMemory_TmpBuffer00
#define kGPMemory_TmpBuffer1		kGPMemory_TmpBuffer01
#define kGPMemory_TmpBuffer2		kGPMemory_TmpBuffer02
#define kGPMemory_TmpBuffer3		kGPMemory_TmpBuffer03

#endif  //	__DSP_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\AudioFx\Util.cpp ===
// ****************************************************************
//
//	Util.cpp			Conversion functions, memory stuff, etc.
//
//	Written by Gints Klimanis
//
// ****************************************************************
#include "util.h"

#ifndef AUDIOFX_STANDALONE
#include <AudioHw.h>

#ifndef BUILD_DRIVER
#include <CScratchDma.h>

// This is a dummy variable referenced by the Visual C++ compiler when
// compiling floating point code.  Since we can't use the Visual C++ run-time
// library, we create an instance of it here.
extern "C" int _fltused = 0x9875;
#endif // BUILD_DRIVER

#endif	// AUDIOFX_STANDALONE

#ifdef AUDIOFX_STANDALONE
// ***************************************************************
// afxScratchMemZero:	Clear some scratch memory.
//					NOTE: this function will disappear !
// *************************************************************** 
	void  
afxScratchMemZero(Int24 memBlock, long size)
{
memset((void *) memBlock, 0, size );
}	// ---- end afxScratchMemZero() ---- 

// ***************************************************************
// afxScratchMemSet:	Set some scratch memory.
//					NOTE: this function will disappear !
// *************************************************************** 
	void  
afxScratchMemSet(Int24 memBlock, long size, long value)
// value	Well, it's just the 8 bits, I think !
{
memset((void *) memBlock, value, size );
}	// ---- end afxScratchMemSet() ---- 

// ***************************************************************
// afxScratchMemRealloc:	Reallocate scratch memory.
// *************************************************************** 
	void  
afxScratchMemRealloc(Int24 *memBlock, long size, int clear)
{
afxScratchMemFree((void *) *memBlock);
*memBlock = (long) afxScratchMemAlloc(size);
if (*memBlock && clear)
	afxScratchMemZero(*memBlock, size);
}	// ---- end afxScratchMemRealloc() ---- 

// ***************************************************************
// afxSystemMemZero:	Clear some system memory.
//					NOTE: this function will disappear !
// *************************************************************** 
	void  
afxSystemMemZero(void *memBlock, long size)
{
memset(memBlock, 0, size );
}	// ---- end afxSystemMemZero() ---- 

// **********************************************************************************
// ByteSwap32:		Swap bytes in one 32-bit word
// ********************************************************************************** 
	void
ByteSwap32(long *p)
{
unsigned char x, y, *d = (unsigned char *) p;

x    = d[0];
d[0] = d[3];
d[3] = x;
y    = d[1];
d[1] = d[2];
d[2] = y;
}	// ---- end ByteSwap32() ---- 

// **********************************************************************************
// ByteSwapBuf32:		Do Endian byte swap on each 32-bit word in buffer
// ********************************************************************************** 
	void
ByteSwapBuf32(long *p, long count)
{
for (long i = 0; i < count; i++)
	{
	unsigned char x, y;
	unsigned char *b = (unsigned char *) p++;
	x    = b[0];
	b[0] = b[3];
	b[3] = x;
	y    = b[1];
	b[1] = b[2];
	b[2] = y;
	}
}	// ---- end ByteSwapBuf32() ---- 

// **********************************************************************************
// ByteSwap24:		Swap bytes in one 24-bit word
// ********************************************************************************** 
	void
ByteSwap24(Int24 *p)
{
unsigned char *b = (unsigned char *) p;
unsigned char x;

x    = b[0];
b[0] = b[2];
b[2] = x;
}	// ---- end ByteSwap24() ---- 

// **********************************************************************************
// ByteSwapBuf24:		Do byte swap on each 24-bit word in buffer
// ********************************************************************************** 
	void
ByteSwapBuf24(Int24 *p, long count)
{
unsigned char *b = (unsigned char *) p;
unsigned char x;
for (long i = 0; i < count; i++, b += 3)
	{
	x    = b[0];
	b[0] = b[2];
	b[2] = x;
	}
}	// ---- end ByteSwapBuf24() ---- 

#else		// AUDIOFX_STANDALONE

// system memory functions
void *afxSystemMemAlloc(U032 uSize)
{
    void *pLinAddr = NULL;
    aosAllocateMem(uSize, ALIGN_DONT_CARE, &pLinAddr, NULL);
    return pLinAddr;
}

void afxSystemMemFree(void *pLinAddr)
{
    aosFreeMem(pLinAddr);
}

void afxSystemMemCopy(void *pDest, void *pSrc, U032 uSize)
{
    aosMemCopy(pDest, pSrc, uSize);
}

void afxScratchMemZero(void *ptr, U032 uSize)
{
    aosZeroMemory(ptr, uSize);
}

// scratch memory functions
#define MAX_ALLOCATIONS     256
#define INVALID_OFFSET      ~0

CScratchDma *gpDma = NULL;

struct
{
    U032 uLinOffset;
    U032 uSize;
} gAllocMap[MAX_ALLOCATIONS];

BOOL AllocMapStoreEntry(U032 uLinOffset, U032 uSize)
{
    for (U032 uCnt = 0; uCnt < MAX_ALLOCATIONS; uCnt++)
    {
        if (gAllocMap[uCnt].uLinOffset == INVALID_OFFSET)
        {
            gAllocMap[uCnt].uLinOffset = uLinOffset;
            gAllocMap[uCnt].uSize = uSize;
            return TRUE;
        }
    }
    
    aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: AllocMapStoreEntry - ERROR! increase MAX_ALLOCATIONS\n");
    return FALSE;
}

BOOL AllocMapGetSize(U032 uLinOffset, U032 *pSize)
{
    for (U032 uCnt = 0; uCnt < MAX_ALLOCATIONS; uCnt++)
    {
        if (gAllocMap[uCnt].uLinOffset == uLinOffset)
        {
            *pSize = gAllocMap[uCnt].uSize;
            return TRUE;
        }
    }
    
    aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: AllocMapGetSize - bad linear offset!\n");
    return FALSE;
}

BOOL AllocMapFreeEntry(U032 uLinOffset)
{
    for (U032 uCnt = 0; uCnt < MAX_ALLOCATIONS; uCnt++)
    {
        if (gAllocMap[uCnt].uLinOffset == uLinOffset)
        {
            gAllocMap[uCnt].uLinOffset = INVALID_OFFSET;
            gAllocMap[uCnt].uSize = 0;
            return TRUE;
        }
    }
    
    aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: AllocMapFreeEntry - bad linear offset!\n");
    return FALSE;
}

// called from audiofx object
void afxScratchMemInitialize(CScratchDma *pDma)
{
    gpDma = pDma;
    
    for (U032 uCnt = 0; uCnt < MAX_ALLOCATIONS; uCnt++)
    {
        gAllocMap[uCnt].uLinOffset = INVALID_OFFSET;
        gAllocMap[uCnt].uSize = 0;
    }
}

void afxScratchMemShutdown()
{
    // check for memory leaks here
    gpDma = NULL;
}


BOOL afxScratchMemAlloc(U032 uSize, U032 *pOffset)
{
    BOOL bStatus = FALSE;
    
    if ( (gpDma) && (RM_OK == gpDma->Allocate(uSize, pOffset)) )
        bStatus = TRUE;
    
    if (bStatus == (BOOL)TRUE)
        bStatus = AllocMapStoreEntry(*pOffset, uSize);
    
    return bStatus;
}

void afxScratchMemFree(U032 uOffset)
{
    U032 uSize;
    
    if ( AllocMapGetSize(uOffset, &uSize) == (BOOL)TRUE )
    {
        if (gpDma)
            gpDma->Free(uOffset, uSize);
        
        AllocMapFreeEntry(uOffset);
        
    }
}

void afxScratchMemWrite(U032 uOffset, void *pSource, U032 uSize)
{
    if (gpDma)
        gpDma->Write(uOffset, pSource, uSize);
    else
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: afxScratchMemCopy - scratch DMA not initialized!\n");
}

void afxScratchMemRead(void *pDest, U032 uOffset, U032 uSize)
{
    if (gpDma)
        gpDma->Read(pDest, uOffset, uSize);
    else
        aosDbgPrintString(DEBUGLEVEL_ERRORS, "NVARM: afxScratchMemCopy - scratch DMA not initialized!\n");
    
}

BOOL  afxScratchMemRealloc(U032 *pOffset, U032 uNewSize, BOOL bClear)
{
    U032 uOldSize;
    BOOL bStatus = FALSE;
    
    if ( AllocMapGetSize(*pOffset, &uOldSize) == (BOOL)TRUE )
    {
        if (uOldSize > uNewSize)
        {
            U032 uExtraOffset = *pOffset + uNewSize;
            if (gpDma)
            {
                gpDma->Free(uExtraOffset, uOldSize - uNewSize);
                // update the alloc map
                AllocMapFreeEntry(*pOffset);
                AllocMapStoreEntry(*pOffset, uNewSize);
                bStatus = TRUE;
            }
        }
        else
        {
            // free and allocate again
            afxScratchMemFree(*pOffset);
            bStatus = afxScratchMemAlloc(uNewSize, pOffset);
        }
    }
    
    if ( (bStatus == (BOOL)TRUE) && (bClear == (BOOL)TRUE) )
        afxScratchMemZero(*pOffset, uNewSize);
    
    return bStatus;
}
void afxScratchMemZero(U032 uOffset, U032 uSize)
{
    afxScratchMemSet(uOffset, uSize, 0);
}

void afxScratchMemSet(U032 uOffset, U032 uSize, U032 uValue)
{
    if (gpDma)
        gpDma->Put(uOffset, uSize, uValue);
}

#endif


// ***************************************************************
// FloatToInt24:	Convert float to 24-bit fractional int
// *************************************************************** 
	Int24 
FloatToInt24(float x)
{
#ifdef AUDIOFX_STANDALONE
return ((Int24)(k24Norm*x));
#else
long lTemp = DTOL(k24Norm*x);
return (Int24)lTemp;
#endif
}	// ---- end FloatToInt24() ---- 

// ***************************************************************
// DoubleToInt24:	Convert double to 24-bit fractional int
// *************************************************************** 
	Int24 
DoubleToInt24(double x)
{
#ifdef AUDIOFX_STANDALONE
return ((Int24)(k24Norm*x));
#else
long lTemp = DTOL(k24Norm*x);
return (Int24)lTemp;
#endif
}	// ---- end DoubleToInt24() ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\AudioFx\AudioFx.h ===
// *************************************************************************
//
//	AudioFx.h		Support functions for DSP System memory operations
//
//	Written by Gints Klimanis, 2000
//
// *************************************************************************
//
#ifndef __AUDIOFX_H__
#define	__AUDIOFX_H__

#include "DSP_Util.h"
#include "AudioFxDef.h"

#ifndef AUDIOFX_STANDALONE
#include "AudioHw.h"
#endif

// ==============================================================
// Global Processor DSP Address Map 
// ==============================================================
// Relative to GPBase (24 bit words (3 bytes) in 32-bit containers (4 bytes))
//     0x0000 - 0x1FFC   GP DSP X-Memory 4K Words (24 lsbits of Dword)     
//     0x4000 - 0x5FFC   GP DSP Y-Memory 2K Words (24 lsbits of Dword) 
//     0x8000 - 0x8FFC   GP DSP P-Memory 4K Words (24 lsbits of Dword) 
//     0xFE00 - 0xFFF0   GP DSP Peripheral Registers
//     0xFFFC            GP DSP Reset
//
// Peripheral registers (Control,Status) mapped to upper 128 words
// of X-memory (0xFFFF80 to 0xFFFFFF) so they can be accessed with movep 
//
// GP DSP memory addresses 24-bit words
// System memory address    8-bit words 

#define kGPMemory_Base		 0x000000
#define kGPMemory_Base_XRAM	(kGPMemory_Base+0x000000)
#define kGPMemory_Base_YRAM	(kGPMemory_Base+0x001800)
#define kGPMemory_Base_PRAM	(kGPMemory_Base+0x002000)

#define kGPMemory_Size_XRAM	3*1024
#define kGPMemory_Size_YRAM	2*1024
#define kGPMemory_Size_PRAM	4*1024

// MixBuffers 0x1400 through 0x17ff  Two banks of 32 Mixbuffers of 32 words each
//	2 banks x 32 Buffers/bank x 32 words/buffer = 2048 ($1000) words
#define kMixBufferSize		kFrameLength
#define kMixBufferLength	kFrameLength

#define kGPMemory_Base_MixBuffers	0x001400	
#define kGPMemory_Base_TempBuffers	0x0	

// Buffer IDs used to connect effects modules
#define kAudioFX_BufferID_2DFxInputLeft		100		// left  channel from two channel FX input
#define kAudioFX_BufferID_2DFxInputRight	101		// right channel from two channel FX input
#define kAudioFX_BufferID_2DFxOutputLeft	102		// to left  front channel output
#define kAudioFX_BufferID_2DFxOutputRight	103		// to right front channel output

#define kAudioFX_BufferID_3DFxInputLeft		110		// left  channel from two channel I3DL2 input
#define kAudioFX_BufferID_3DFxInputRight	111		// right channel from two channel I3DL2 input
#define kAudioFX_BufferID_3DFxOutputLeft	112		// two front channels to front X-talk box
#define kAudioFX_BufferID_3DFxOutputRight	113		// two rear channels  to rear  X-talk box

#define kAudioFX_BufferID_Null		150				// Used to indicate an idle connection

#define kAudioFX_BufferID_Temp00	200		
#define kAudioFX_BufferID_Temp01	201	
#define kAudioFX_BufferID_Temp02	202	
#define kAudioFX_BufferID_Temp03	203	
#define kAudioFX_BufferID_Temp04	204	
#define kAudioFX_BufferID_Temp05	205	
#define kAudioFX_BufferID_Temp06	206	
#define kAudioFX_BufferID_Temp07	207	

#define kAudioFX_BufferID_FinalMix_Input	300		// Future use:   connect to all pins
#define kAudioFX_BufferID_FinalMix_Pin0		301
#define kAudioFX_BufferID_FinalMix_Pin1		302
#define kAudioFX_BufferID_FinalMix_Pin2		303
#define kAudioFX_BufferID_FinalMix_Pin3		304
#define kAudioFX_BufferID_FinalMix_Pin4		305
#define kAudioFX_BufferID_FinalMix_Pin5		306

// DO NOT change the values!!  it'll break NV_AUDGP_ROUTE_TO_FIFO - (CGpMethod.cpp)
#define kAudioFX_BufferID_FIFO0_Input		300		// Future use:   connect to all pins
#define kAudioFX_BufferID_FIFO0_Input_Pin0	301
#define kAudioFX_BufferID_FIFO0_Input_Pin1	302
#define kAudioFX_BufferID_FIFO0_Input_Pin2	303
#define kAudioFX_BufferID_FIFO0_Input_Pin3	304
#define kAudioFX_BufferID_FIFO0_Input_Pin4	305
#define kAudioFX_BufferID_FIFO0_Input_Pin5	306

#define kAudioFX_BufferID_FIFO1_Input		310	// Future use:   connect to all pins
#define kAudioFX_BufferID_FIFO1_Input_Pin0	311
#define kAudioFX_BufferID_FIFO1_Input_Pin1	312
#define kAudioFX_BufferID_FIFO1_Input_Pin2	313
#define kAudioFX_BufferID_FIFO1_Input_Pin3	314
#define kAudioFX_BufferID_FIFO1_Input_Pin4	315
#define kAudioFX_BufferID_FIFO1_Input_Pin5	316

#define kAudioFX_BufferID_FIFO0_Output		320	// Future use:   connect to all pins
#define kAudioFX_BufferID_FIFO0_Output_Pin0	321
#define kAudioFX_BufferID_FIFO0_Output_Pin1	322
#define kAudioFX_BufferID_FIFO0_Output_Pin2	323
#define kAudioFX_BufferID_FIFO0_Output_Pin3	324
#define kAudioFX_BufferID_FIFO0_Output_Pin4	325
#define kAudioFX_BufferID_FIFO0_Output_Pin5	326

#define kAudioFX_BufferID_FIFO1_Output		330	// Future use:   connect to all pins
#define kAudioFX_BufferID_FIFO1_Output_Pin0	331
#define kAudioFX_BufferID_FIFO1_Output_Pin1	332
#define kAudioFX_BufferID_FIFO1_Output_Pin2	333
#define kAudioFX_BufferID_FIFO1_Output_Pin3	334
#define kAudioFX_BufferID_FIFO1_Output_Pin4	335
#define kAudioFX_BufferID_FIFO1_Output_Pin5	336

#define kAudioFX_BufferID_FIFO2_Output		340	// Future use:   connect to all pins
#define kAudioFX_BufferID_FIFO2_Output_Pin0	341
#define kAudioFX_BufferID_FIFO2_Output_Pin1	342
#define kAudioFX_BufferID_FIFO2_Output_Pin2	343
#define kAudioFX_BufferID_FIFO2_Output_Pin3	344
#define kAudioFX_BufferID_FIFO2_Output_Pin4	345
#define kAudioFX_BufferID_FIFO2_Output_Pin5	346

#define kAudioFX_BufferID_FIFO3_Output		350	// Future use:   connect to all pins
#define kAudioFX_BufferID_FIFO3_Output_Pin0	351
#define kAudioFX_BufferID_FIFO3_Output_Pin1	352
#define kAudioFX_BufferID_FIFO3_Output_Pin2	353
#define kAudioFX_BufferID_FIFO3_Output_Pin3	354
#define kAudioFX_BufferID_FIFO3_Output_Pin4	355
#define kAudioFX_BufferID_FIFO3_Output_Pin5	356

#define kAudioFX_BufferID_2DLoopBackTo3D_Input0		120		// FIXXX: not done:Will probably be dynamic.
//#define kAudioFX_BufferID_2DLoopBackTo3D_Output0	121		

#define kAudioFX_Pin0	0
#define kAudioFX_Pin1	1
#define kAudioFX_Pin2	2
#define kAudioFX_Pin3	3
#define kAudioFX_Pin4	4
#define kAudioFX_Pin5	5

#define kAudioFX_PinLeft	kAudioFX_Pin0
#define kAudioFX_PinRight	kAudioFX_Pin1

// ****************************************************************
//  AudioFX:  the master system that manages audio fx modules and
//				assembles the memory blocks downloaded to the DSP
// ****************************************************************
// The first three memory block sizes are known before CreateAudioFX()
// The large state block size is calculated from parameter sets
#define kAudioFX_Memory_DspCodeBlock		0
#define kAudioFX_Memory_DspModuleBlock		1
#define kAudioFX_Memory_DspStateBlock		2
#define kAudioFX_Memory_DspLargeStateBlock	3		

#define kAudioFX_AllModules	(-1)

class CScratchDma;

class AUDIOFX {
public:
	AUDIOFX(long maxModules, CScratchDma *pDma);		
	~AUDIOFX(); 

// NV_AUDGP_ENABLE_EFFECT
//	To to disable an effect without deleting it:
//	1) Exclude from execution list
//	2) Disconnect inputs and outputs
	int	SetModuleExecutionList(long *moduleIDs, int count);

// ---- Module Functions
// When moduleID=kAudioFX_AllModules, apply to all modules
    // NV_AUDGP_ADD_EFFECT
    // RegisterModuleType() will return a unique typeID
	int AddModule	  (long  typeID);
	int AddModule	  (char *typeName);

    // NV_AUDGP_DELETE_EFFECT
	int DeleteModule (long moduleID);
	
// NV_AUDGP_SET_EFFECT_PARAMETERS
// The module will know the size of parameterData
// Will delay memory be allocated here?
	int SetModule    (long moduleID, void *parameterData);
	int GetModule    (long moduleID, void *parameterData);
	void *GetModuleParameterPtr(long moduleID);
	AFX_PARAMETERS *GetModuleAFXParametersPtr(long moduleID);
    /*
    NV_AUDGP_ROUTE_EFFECT
    shouldn't there be a pin # - like an outindex from the effect?
		Developers will know an effect's input and output count beforehand.
    buffer ID?  we need to make the RM do the resource management.. also is there a diff
    between the SW buffers, and HW buffers?
GK>> What kind of difference?  Right now, there isn't a difference.  
    */
//	int	SetModule_IOBuffers(long moduleID, int  inIndex, int  inBufferID, int outIndex, int outBufferID);
	int	SetModule_InBuffer (long moduleID, int  inIndex, int  inBufferID);
	int	SetModule_OutBuffer(long moduleID, int outIndex, int outBufferID);

	int SetInputFIFOFormat (int index, int channelFormat, int classDataSize);
	int SetOutputFIFOFormat(int index, int channelFormat, int classDataSize);

    // NV_AUDGP_REGISTER_EFFECT
    //the AUDIOFX_PLUGIN structure has to be shared between the driver and the RM
	int RegisterModuleType  (AUDIOFX_PLUGIN *data);

    // NV_AUDGP_DEREGISTER_EFFECT  
	int UnregisterModuleType(long typeID);

    /* NV_AUDGP_QUERY_EFFECT define query ID for the driver.*/
	int Command		 (long moduleID, int commandID, void *data);
	int QueryModule  (long moduleID, int queryID);

// Debug for now
	int  Update();
	void SetTopologyName(char *s);

	int DefaultModule(long moduleID);
	int ResetModule  (long moduleID);
	int UpdateModule (long moduleID);
	int PrepareModule(long moduleID);

private:

	char *audioFxModuleTypeNames[kAudioFxModule_MaxTypes];
	DSPCOMMANDNODE dspCommandNode;

// System Memory block pointers (address offsets from GPSADDR)
//	Int24 *dspCommandNode;
	Int24 *dspCodeBlock;		// DSP PRAM Code block
	Int24 *dspModuleBlock;		// DSP XRAM Execution List
	Int24 *dspStateBlock;		// DSP X/YRAM, includes command node
//	Int24 dspLargeStateBlock;   // System Memory state: delay lines, etc.

// Scratch memory address offsets
	Int24 smDspCommandNode;
	Int24 smDspCodeBlock;		
	Int24 smDspModuleBlock;		
	Int24 smDspStateBlock;		

// Allocated size, in Int24 words
//	long dspCommandNodeSize;
	long dspCodeBlockSize;		
	long dspModuleSize;
	long dspStateBlockSize;
//	long dspLargeStateBlockSize;

#define kAudioFX_MaxInputFIFOs	2
#define kAudioFX_MaxOutputFIFOs	4
	FIFO_INFO	inputFIFOs [kAudioFX_MaxInputFIFOs ];
	FIFO_INFO	outputFIFOs[kAudioFX_MaxOutputFIFOs];

// FX registry 
	AUDIOFX_PLUGIN plugIns[kAudioFxModule_MaxTypes];	// [0.. kAudioFxModule_MaxTypes]
	long	plugInCount;
	long	typeIDCounter;	// Incremented every time a new module is added

// Module lists
	AUDIOFX_MODULE	modules[kAudioFx_MaxModules];
	long	moduleCount;
	long	maxModules;

	long	moduleIDCounter;	// Incremented every time a new module is added
	long	executionList[kAudioFx_MaxModules];	// Array of module IDs
	long	executionListLength;
	char	*topologyName;

// DSP code & state data info
	Int24 *dspComputeRoutines    [kAudioFxModule_MaxTypes];	
	long   dspComputeRoutineSizes[kAudioFxModule_MaxTypes];	// in Int24 words
	Int24 *dspCommonRoutines;
	long   dspCommonRoutinesSize;

	void InitModule(AUDIOFX_MODULE *d);
	void InitPlugIn(AUDIOFX_PLUGIN *d);

	int  AssembleDSPCodeBlock  (char *filePath);
	int  AssembleDSPStateBlock (char *filePath);
	void TranslateModule_IOBufferIDs(AUDIOFX_MODULE *d);
	Int24 BufferIDToDSPAddress(Int24 id);

	AUDIOFX_MODULE *FindAudioFXModule(long moduleID);
	AUDIOFX_PLUGIN *FindAudioFXPlugInByID  (long typeID);
	AUDIOFX_PLUGIN *FindAudioFXPlugInByName(char *name );

	long WriteWordsToFile(char *filePath, Int24 *data, long count);
	char *FxTypeIDToName (long id);
	long  FxParameterSize(long typeID);
} ;



#endif  //	__AUDIOFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\AudioFx\AudioFx.cpp ===
// *************************************************************************
//
//	AudioFx:		DSP Execution Support routines
//
//	Written by Gints Klimanis
//
// *************************************************************************
#include "util.h"
#include <string.h>

#include "DSP_Util.h"
#include "AudioFx.h"

#include "DSP_Binaries.h"

// Built-in FX modules
#include "NullModule_Util.h"

// The First 32 buffers reference the MixBuffers
#define kAudioFX_BufferID_MixBuf00	 0	
#define kAudioFX_BufferID_MixBuf01	 1	
#define kAudioFX_BufferID_MixBuf02	 2	
#define kAudioFX_BufferID_MixBuf03	 3	
#define kAudioFX_BufferID_MixBuf04	 4	
#define kAudioFX_BufferID_MixBuf05	 5	
#define kAudioFX_BufferID_MixBuf06	 6	
#define kAudioFX_BufferID_MixBuf07	 7	
#define kAudioFX_BufferID_MixBuf08	 8	
#define kAudioFX_BufferID_MixBuf09	 9	
#define kAudioFX_BufferID_MixBuf10	10	
#define kAudioFX_BufferID_MixBuf11	11	
#define kAudioFX_BufferID_MixBuf12	12	
#define kAudioFX_BufferID_MixBuf13	13	
#define kAudioFX_BufferID_MixBuf14	14	
#define kAudioFX_BufferID_MixBuf15	15	

#define kAudioFX_BufferID_MixBuf16	16	
#define kAudioFX_BufferID_MixBuf17	17	
#define kAudioFX_BufferID_MixBuf18	18	
#define kAudioFX_BufferID_MixBuf19	19	
#define kAudioFX_BufferID_MixBuf20	20	
#define kAudioFX_BufferID_MixBuf21	21	
#define kAudioFX_BufferID_MixBuf22	22	
#define kAudioFX_BufferID_MixBuf23	23	
#define kAudioFX_BufferID_MixBuf24	24	
#define kAudioFX_BufferID_MixBuf25	25	
#define kAudioFX_BufferID_MixBuf26	26	
#define kAudioFX_BufferID_MixBuf27	27	
#define kAudioFX_BufferID_MixBuf28	28	
#define kAudioFX_BufferID_MixBuf29	29	
#define kAudioFX_BufferID_MixBuf30	30	
#define kAudioFX_BufferID_MixBuf31	31	

// GK FIXXX: check-in rush kludge.  Ideally, I would like these
// to be #define,
//char *audioFxModuleTypeName_DMA  = kAudioFxModuleTypeName_DMA;
//char *audioFxModuleTypeName_Null = kAudioFxModuleTypeName_Null;

//char *audioFxModuleTypeName_AmpMod     = kAudioFxModuleTypeName_AmpMod;
//char *audioFxModuleTypeName_Chorus     = kAudioFxModuleTypeName_Chorus;
//char *audioFxModuleTypeName_Compressor = kAudioFxModuleTypeName_Compressor;
//char *audioFxModuleTypeName_Delay      = kAudioFxModuleTypeName_Delay;
//char *audioFxModuleTypeName_Distortion = kAudioFxModuleTypeName_Distortion;
//char *audioFxModuleTypeName_Echo       = kAudioFxModuleTypeName_Echo;
//char *audioFxModuleTypeName_Equalizer  = kAudioFxModuleTypeName_Equalizer;
//char *audioFxModuleTypeName_Flange     = kAudioFxModuleTypeName_Flange;
//char *audioFxModuleTypeName_IIIR       = kAudioFxModuleTypeName_IIIR;
//char *audioFxModuleTypeName_IIR1       = kAudioFxModuleTypeName_IIR1;
//char *audioFxModuleTypeName_IIR2       = kAudioFxModuleTypeName_IIR2;
//char *audioFxModuleTypeName_Limiter    = kAudioFxModuleTypeName_Limiter;
//char *audioFxModuleTypeName_Mixer      = kAudioFxModuleTypeName_Mixer;
//char *audioFxModuleTypeName_Oscillator = kAudioFxModuleTypeName_Oscillator;
//char *audioFxModuleTypeName_Reverb     = kAudioFxModuleTypeName_Reverb;

// **********************************************************************************
// AUDIOFX:		Set up audio effects objects except the data-dependent
//						delay line stuff.  This structure will house all of
//						the ptrs to the Command Nodes, DSP Execution Lists, 
//						DSP Code Blocks, DSP Small State Blocks, DSP Large State 
//						blocks in system memory.  
//						
//		Return ptr to AUDIOFX structure
// ********************************************************************************** 
AUDIOFX::AUDIOFX(long uMaxModules, CScratchDma *pDma)
{
int i;
  
#ifndef AUDIOFX_STANDALONE  
afxScratchMemInitialize(pDma);
#endif

// Scratch Memory block pointers
dspCodeBlock   = (Int24 *) kAudioFX_SMAddress_CodeBlock;		// DSP PRAM Code block
dspModuleBlock = (Int24 *) kAudioFX_SMAddress_ModuleBlock;	// DSP XRAM Execution List
dspStateBlock  = (Int24 *) kAudioFX_SMAddress_StateBlock;		// DSP X/YRAM
//dspLargeStateBlock = NULL;  // System Memory state: delay lines, etc.

dspCodeBlockSize   = 0;		
dspModuleSize      = 0;
dspStateBlockSize  = 0;
//dspLargeStateBlockSize = 0;

topologyName = NULL;

// Setup individual modules
#ifndef AUDIOFX_STANDALONE  
if (uMaxModules > kAudioFx_MaxModules)
    {
    aosDbgPrintString(DEBUGLEVEL_ERRORS, "AUDIOFX::AUDIOFX - so many modules not supported!!\n");
    aosDbgBreakPoint();
    }
#endif
maxModules = uMaxModules;
for (i = 0; i < kAudioFxModule_MaxTypes; i++)
	{
	InitPlugIn(&plugIns[i]);

//	dspComputeRoutines    [i] = NullCompute_In1Out1;
//	dspComputeRoutineSizes[i] = NullCompute_In1Out1Length;
	}
dspModuleBlock = (Int24 *) afxSystemMemAlloc(maxModules*sizeof(DSPMODULE));

// Add Plug-In routines

// Other stuff
moduleIDCounter     = 0;
typeIDCounter       = kAudioFxModuleTypeID_Null+1;
moduleCount         = 0;
executionListLength = 0;

AUDIOFX_MODULE *p = modules;
for (i = 0; i < maxModules; i++)
	{
	p[i].moduleID = kAudioFxModule_EmptyID;
	executionList[i] = kAudioFxModuleTypeID_Null;
	}

for (i = 0; i < kAudioFX_MaxInputFIFOs; i++)
	{
	inputFIFOs[i].channelFormat = kFIFO_ChannelFormat_Stereo;
	inputFIFOs[i].classDataSize = kFIFO_ClassDataSize_16_16;
	}
for (i = 0; i < kAudioFX_MaxOutputFIFOs; i++)
	{
	outputFIFOs[i].channelFormat = kFIFO_ChannelFormat_Stereo;
	outputFIFOs[i].classDataSize = kFIFO_ClassDataSize_16_16;
	}

// FIXXX:  record to avoid this sort of string table
for (i = 0; i < kAudioFxModule_MaxTypes; i++)
	audioFxModuleTypeNames[i] = NULL;

audioFxModuleTypeNames[kAudioFxModuleTypeID_DMA       ] = kAudioFxModuleTypeName_DMA;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Mixer     ] = kAudioFxModuleTypeName_Mixer;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Null      ] = kAudioFxModuleTypeName_Null;

audioFxModuleTypeNames[kAudioFxModuleTypeID_AmpMod    ] = kAudioFxModuleTypeName_AmpMod;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Chorus    ] = kAudioFxModuleTypeName_Chorus;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Compressor] = kAudioFxModuleTypeName_Compressor;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Delay     ] = kAudioFxModuleTypeName_Delay;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Distortion] = kAudioFxModuleTypeName_Distortion;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Echo      ] = kAudioFxModuleTypeName_Echo;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Equalizer ] = kAudioFxModuleTypeName_Equalizer;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Flange    ] = kAudioFxModuleTypeName_Flange;
audioFxModuleTypeNames[kAudioFxModuleTypeID_IIIR      ] = kAudioFxModuleTypeName_IIIR;
audioFxModuleTypeNames[kAudioFxModuleTypeID_IIR1      ] = kAudioFxModuleTypeName_IIR1;
audioFxModuleTypeNames[kAudioFxModuleTypeID_IIR2      ] = kAudioFxModuleTypeName_IIR2;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Limiter   ] = kAudioFxModuleTypeName_Limiter;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Mixer     ] = kAudioFxModuleTypeName_Mixer;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Oscillator] = kAudioFxModuleTypeName_Oscillator;
audioFxModuleTypeNames[kAudioFxModuleTypeID_Reverb    ] = kAudioFxModuleTypeName_Reverb;

}	// ---- end AUDIOFX() ---- 

// ******************************************************************
// ~AUDIOFX:		Deallocate internal Audio FX data blocks
//	
//					Return Boolean success
// ****************************************************************** 
AUDIOFX::~AUDIOFX()
{
int	i;

// Deallocate modules
for (i = 0; i < kAudioFx_MaxModules; i++)
	DeleteModule(modules[i].moduleID);
    
#ifndef AUDIOFX_STANDALONE  
    afxScratchMemShutdown();
#endif
}	// ---- end ~AUDIOFX() ---- 

#ifdef SAFE
// ****************************************************************
// ConnectAudioFX:	Connect one module output to input of another module
//
//		Note:  Modules may be connected to themselves, but there will
//				be one frame of latency in the recirculation path.
//				To Disconnect a module, connect both outputs or
//				both inputs to the NULL module.  
//
//						Return Boolean success
// **************************************************************** 
	int	
AUDIOFX::ConnectModules(long sourceID, int outIndex, long destID, int inIndex)
{
AUDIOFX_MODULE *inModule, *outModule;

inModule  = FindAudioFXModule(sourceID);
outModule = FindAudioFXModule(destID  );

if (!inModule || !outModule)
	return (False);

if (kAudioFxModule_DMA == inModule->typeID || kAudioFxModule_DMA == outModule->typeID)
	return (False);

outModule->outBufferIDs[outIndex] = inModule->inBufferIDs[ inIndex];

return (True);
}	// ---- end ConnectAudioFX() ---- 
#endif

#ifdef SAFE
// ****************************************************************
// SetModule_IOBuffers:	Specify buffer IDs for module inputs and outputs
//
//		Note:  If a module has no inputs or outputs, the bufferIDS for
//				for those connections will be ignored.
//
//						Return Boolean success
// **************************************************************** 
	int	
AUDIOFX::SetModule_IOBuffers(long moduleID, int  inIndex, int  inBufferIFD, 
								int outIndex, int outBufferID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m || kAudioFxModule_DMA == m->typeID)
	return (False);

m->inBufferIDs [ inIndex] =  inBufferID;
m->outBufferIDs[outIndex] = outBufferID;

return (True);
}	// ---- end SetModule_IOBuffers() ---- 
#endif

// ****************************************************************
// SetModule_InBuffer:	Specify buffer IDs for module inputs, only
//
//		Note:  If a module has no inputs, the bufferIDS for
//				for those connections will be ignored.
//
//						Return Boolean success
// **************************************************************** 
	int	
AUDIOFX::SetModule_InBuffer(long moduleID, int index, int bufferID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m ) //|| kAudioFxModule_DMA == m->typeID)
	return (False);

m->inBufferIDs[index] = bufferID;

return (True);
}	// ---- end SetModule_InBuffer() ---- 

// ****************************************************************
// SetModule_OutBuffer:	Specify buffer IDs for module outputs, only
//
//		Note:  If a module has no outputs, the bufferIDS for
//				for those connections will be ignored.
//
//						Return Boolean success
// **************************************************************** 
	int	
AUDIOFX::SetModule_OutBuffer(long moduleID, int index, int bufferID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m ) //|| kAudioFxModule_DMA == m->typeID)
	return (False);

m->outBufferIDs[index] = bufferID;

return (True);
}	// ---- end SetModule_OutBuffer() ---- 

// ****************************************************************
// TranslateModule_IOBufferIDs:	Convert input and output buffers IDs
//								to DSP addresses.
// **************************************************************** 
	void	
AUDIOFX::TranslateModule_IOBufferIDs(AUDIOFX_MODULE *d)
{
Int24 *ioAddresses = (Int24 *) d->data.smallState;

// Format {all inputs, all outputs}
for (int i = 0; i < d->ioCount; i++)
	{
	ioAddresses[i             ] = BufferIDToDSPAddress(d->inBufferIDs [i]);
	ioAddresses[i+d->ioCount/2] = BufferIDToDSPAddress(d->outBufferIDs[i]);
	}
}	// ---- end TranslateModule_IOBufferIDs() ----

// ****************************************************************
// BufferIDToDSPAddress:	Given buffers ID, return DSP addresses.
//		
//			In case of error, return (-1)
// **************************************************************** 
	Int24	
AUDIOFX::BufferIDToDSPAddress(Int24 id)
{
Int24 x = -1;

//  Deal with FX sources
// FIXXX: for now, using mix bins
switch (id)
	{
	case kAudioFX_BufferID_2DFxInputLeft:
		id = kGPMemory_MixBuffer00;
	break;
	case kAudioFX_BufferID_2DFxInputRight:
		id = kGPMemory_MixBuffer01;
	break;
	case kAudioFX_BufferID_2DFxOutputLeft:
		id = kGPMemory_MixBuffer00;
	break;
	case kAudioFX_BufferID_2DFxOutputRight:
		id = kGPMemory_MixBuffer01;
	break;

	case kAudioFX_BufferID_3DFxInputLeft:
		id = kGPMemory_MixBuffer02;
	break;
	case kAudioFX_BufferID_3DFxInputRight:
		id = kGPMemory_MixBuffer03;
	break;
	case kAudioFX_BufferID_3DFxOutputLeft:
	break;
	case kAudioFX_BufferID_3DFxOutputRight:
	break;

// FIXXXX: Only one global 2D->3D fx loopback 
	case kAudioFX_BufferID_2DLoopBackTo3D_Input0:
		id = kGPMemory_MixBuffer31;
	break;
	}

if (-1 != id)
	return (id);

// Next, temporary buffers
if (id >= kAudioFX_BufferID_Temp00 && id <= kAudioFX_BufferID_Temp07)
	x = kGPMemory_Base_TempBuffers + kFrameLength*(id-kAudioFX_BufferID_Temp00);

return (-1);
}	// ---- end BufferIDToDSPAddress() ---- 

// ****************************************************************
// SetModuleExecutionList:	Specify order of module execution.  If this
//						function is not called, the effects will be
//						executed in the order of their module IDs.
//
//			Return True if all modules were scheduled without error.
//
//						Return Boolean success (FIXXX: perhaps # of modules scheduled)
// **************************************************************** 
	int	
AUDIOFX::SetModuleExecutionList(long *moduleIDs, int count)
// moduleIDs		ptr to modules to be included in execution list
//					NULL value will construct an execution list of
//					all modules in increasing moduleID order.
{
if (!moduleIDs)
	{
// FIXXX: just add code.
	}

if (count > kAudioFx_MaxModules)
	return (False);

afxSystemMemCopy(executionList, moduleIDs, count*sizeof(long));
executionListLength = count;

return (True);
}	// ---- end SetModuleExecutionList() ---- 

// ****************************************************************
// AddModule:		Set up a new audio effect.  
//				Note: this function does not add this module to
//				the execution list.
//
//			Return module ID.  Return value of kAudioFxModule_EmptyID
//						indicates failure.
// **************************************************************** 
	int 
AUDIOFX::AddModule(char *typeName)
{
int		i;
AUDIOFX_MODULE *m      = NULL;
AUDIOFX_PLUGIN *plugIn = FindAudioFXPlugInByName(typeName);

// Search for plug-in as specified by typeID
if (!plugIn)
	{
	printf("AddModule: unable to find plug-in specified by '%s'.\n", typeName);
	return (-1);
	}

// Find an empty slot for the module.
for (i = 0; i < maxModules; i++)
	{
	m = &modules[i];
	if (kAudioFxModule_EmptyID == m->moduleID)
		break;
	}

// Uh oh . Unable to find a slot for the module.
if (i == maxModules)
	{
	printf("AddModule: out of module slots.\n");
	return (kAudioFxModule_EmptyID);
	}
InitModule(m);
m->parent = plugIn;

m->moduleID = moduleIDCounter++;
//printf("AddModule: added id=%d of type '%s'\n", m->moduleID, typeName);

return (m->moduleID);
}	// ---- end AddModule() ---- 

// ****************************************************************
// AddModule:		Set up a new audio effect.  
//				Note: this function does not add this module to
//				the execution list.
//
//			Return module ID.  Return value of kAudioFxModule_EmptyID
//						indicates failure.
// **************************************************************** 
	int 
AUDIOFX::AddModule(long typeID)
{
if (kAudioFxModuleTypeID_DMA <= typeID && typeID <= kAudioFxModuleTypeID_Reverb)
	return (AddModule(audioFxModuleTypeNames[typeID]));
else
	return (kAudioFxModuleTypeID_Invalid);
}	// ---- end AddModule() ---- 

#ifdef SAFE
// ****************************************************************
// Command:		Send command to one/all modules.
//
//			Return Boolean success.	
// **************************************************************** 
	int 
AUDIOFX::Command(long moduleID, int commandID, void *data)
{
switch (commandID)
	{
	case kDSPCommand_IgnoreMe:
	break;
	case kDSPCommand_StopDSPList:
	break;
	case kDSPCommand_StartDSPList:
	break;
	case kDSPCommand_LoadDSPModuleBlock:
	break;
	case kDSPCommand_LoadDSPCodeBlock:
	break;

	case kDSPCommand_ResetAllDSPModuleStates:
	break;
	case kDSPCommand_UpdateAllDSPModuleParameters:
	break;
	case kDSPCommand_PrepareAllDSPModules:
	break;

	case kDSPCommand_ResetOneDSPModuleState:
	break;
	case kDSPCommand_UpdateOneDSPModuleParameters:
	break;
	case kDSPCommand_PrepareOneDSPModule:
	break;
	default:
	return (False);
	}

return (True);
}	// ---- end Command() ---- 
#endif

// ****************************************************************
// QueryModule:		Inquire about module state
//
//						Return Boolean success
// **************************************************************** 
	int 
AUDIOFX::QueryModule(long moduleID, int queryID)
{
return (True);
}	// ---- end QueryModule() ---- 

// ****************************************************************
// SetInputFIFOFormat:	Use this call to register actual
//						FIFO settings set by driver.  This
//						call will not reconfigure the FIFO hardware
//
//						Return Boolean success
// **************************************************************** 
	int 
AUDIOFX::SetInputFIFOFormat(int index, int channelFormat, int classDataSize)
{
if (index >= kAudioFX_MaxInputFIFOs)
	return (False);

inputFIFOs[index].classDataSize = classDataSize;
inputFIFOs[index].channelFormat = channelFormat;

return (True);
}	// ---- end SetInputFIFOFormat() ---- 

// ****************************************************************
// SetOutputFIFOFormat:	Use this call to register actual
//						FIFO settings set by driver.  This
//						call will not reconfigure the FIFO hardware
//
//						Return Boolean success
// **************************************************************** 
	int 
AUDIOFX::SetOutputFIFOFormat(int index, int channelFormat, int classDataSize)
{
if (index >= kAudioFX_MaxOutputFIFOs)
	return (False);

outputFIFOs[index].classDataSize = classDataSize;
outputFIFOs[index].channelFormat = channelFormat;

return (True);
}	// ---- end SetOutputFIFOFormat() ---- 

// ****************************************************************
// SetTopologyName:	used to set file names for generated binary outputs
//
// **************************************************************** 
	void 
AUDIOFX::SetTopologyName(char *s)
{
topologyName = s;
}	// ---- end SetTopologyName() ---- 

// ****************************************************************
// RegisterModuleType:		Install audio fx plug-in from system.
//
//		Note:  An FX type may not be reregistered.  This
//				function does not instantiate a module.
//
//			Return type ID
// **************************************************************** 
	int 
AUDIOFX::RegisterModuleType(AUDIOFX_PLUGIN *d)
{
long i;

// Don't register if it already exists
if (FindAudioFXPlugInByName(d->name))
	{
	printf("RegisterModuleType: unable to find space for plugin '%s'\n", d->name);
	return (True);
	}

// Find an empty slot
for (i = 0; i < kAudioFxModule_MaxTypes; i++)
	{
	if (kAudioFxModuleTypeID_Null == plugIns[i].typeID)
		break;
	}
if (kAudioFxModule_MaxTypes == i)
	{
	printf("RegisterModuleType: unable to find space for plugin %d\n", d->typeID);
	return (False);
	}

// Copy plugin data
memcpy(&plugIns[i], d, sizeof(AUDIOFX_PLUGIN));
plugIns[i].typeID = typeIDCounter++;
//printf("RegisterModuleType: %d plugIn name='%s' typeID=%d\n", i, plugIns[i].name, plugIns[i].typeID);

return (plugIns[i].typeID);
}	// ---- end RegisterModuleType() ---- 

// ****************************************************************
// UnregisterModuleType:	Remove audio fx plug-in from system.
//
//			Return Boolean success.	
// **************************************************************** 
	int 
AUDIOFX::UnregisterModuleType(long typeID)
{
int	i;

// Don't unregister if it doesn't exist
AUDIOFX_PLUGIN *thisPlugin = FindAudioFXPlugInByID(typeID);
if (!thisPlugin)
	return (False);

// Remove all instances of this type from the module list
for (i = 0; i < maxModules; i++)
	{
	if (modules[i].parent == thisPlugin)
		InitModule(&modules[i]);
	}

// Clear plug-in entry
InitPlugIn(thisPlugin);

return (True);
}	// ---- end UnregisterModuleType() ---- 

// ****************************************************************
// DeleteModule:	Delete specified module instance
//
//			Return Boolean success.	
// **************************************************************** 
	int 
AUDIOFX::DeleteModule(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m)
	return (False);

m->moduleID = kAudioFxModule_EmptyID;

// Remove module from execution list before state memory is
// deallocated 


// Deallocate state block

// FIXXX: add signal to update DSP state and code blocks.

return (True);
}	// ---- end DeleteModule() ---- 

// ****************************************************************
// DefaultModule:		Set default parameters to specified effect
//
//			Return Boolean success.	
// **************************************************************** 
	int 
AUDIOFX::DefaultModule(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m)
	return (False);
(m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Default].function)(&m->data);

return (True);
}	// ---- end DefaultModule() ---- 

// ****************************************************************
// ResetModule:	Reset large and small parameter smallState
//
//			Return Boolean success.	
// **************************************************************** 
	int 
AUDIOFX::ResetModule(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m)
	return (False);
(m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Reset].function)(&m->data);

return (True);
}	// ---- end ResetModule() ---- 

// ****************************************************************
// UpdateModule:		Update parameter values
//					Note:  Update() does not reset the module
//								unless the parameters require 
//								a Reset.
//
//			Returns Boolean indication that a Reset() is needed.
// **************************************************************** 
	int 
AUDIOFX::UpdateModule(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);
int resetNeeded = False;
if (!m)
	return (False);

// Convert buffer IDs to DSP memory IDs
TranslateModule_IOBufferIDs(m);

(m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Update].function)(&m->data);

return (resetNeeded);
}	// ---- end UpdateModule() ---- 

// ****************************************************************
// PrepareModule:		Update + Reset
//
//					Return Boolean success
// **************************************************************** 
	int 
AUDIOFX::PrepareModule(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);

if (!m)
	return (False);

if (m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Prepare].function)
	(m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Prepare].function)(&m->data);
else
	{
	(m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Update].function)(&m->data);
	(m->parent->functionIDList[kAudioFX_PlugIn_FunctionID_Reset ].function)(&m->data);
	}

return (True);
}	// ---- end PrepareModule() ---- 

// ****************************************************************
// SetModule:		Set high level  (usually DirectX parameters), 
//					but do not process	parameters with Update() call.
//
//					Return Boolean success
// **************************************************************** 
	int 
AUDIOFX::SetModule(long moduleID, void *data)
// data		ptr to DX8 parameter structure
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);
if (!m)
	return (False);

// Copy parameter data
Int24 *localData = (Int24 *) m->data.moduleData;
afxSystemMemCopy(localData, data, m->parent->moduleStructSize);

return (True);
}	// ---- end SetModule() ---- 

// ****************************************************************
// GetModule:		Retrieve high level parameters
//
//					Return Boolean success
// **************************************************************** 
	int 
AUDIOFX::GetModule(long moduleID, void *data)
// parameterData		ptr to DX8 parameter structure
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);
if (!m)
	return (False);

// Copy parameter data
Int24 *localData = (Int24 *) m->data.moduleData;
afxSystemMemCopy(data, localData, m->parent->moduleStructSize);

return (True);
}	// ---- end GetModule() ---- 

// ****************************************************************
// GetModuleAFXParametersPtr:	Return ptr to AFX (high+low level) parameters
//
//					Return Boolean success
// **************************************************************** 
	AFX_PARAMETERS * 
AUDIOFX::GetModuleAFXParametersPtr(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);
if (!m)
	return (False);

return (&m->data);
}	// ---- end GetModuleAFXParametersPtr() ---- 

// ****************************************************************
// GetModuleParameterPtr:		Return ptr high level parameters
//
// **************************************************************** 
	void * 
AUDIOFX::GetModuleParameterPtr(long moduleID)
{
AUDIOFX_MODULE *m = FindAudioFXModule(moduleID);
if (!m)
	return (False);
return (m->data.moduleData);
}	// ---- end GetModuleParameterPtr() ---- 

// ****************************************************************
// InitModule:		
// **************************************************************** 
	void
AUDIOFX::InitModule(AUDIOFX_MODULE *d)
{
int i;

for (i = 0; i < kAudioFX_MaxInputs; i++)
	d->inBufferIDs [i] = kAudioFX_BufferID_MixBuf00;
for (i = 0; i < kAudioFX_MaxOutputs; i++)
	d->outBufferIDs[i] = kAudioFX_BufferID_MixBuf00;

d->ioCount = 1;
d->parent  = NULL;

//d->data.parameters     = d->parameters;
//d->data.smallState     = d->smallState;
d->data.largeState     = 0;
d->data.largeStateSize = 0;
}	// ---- end InitModule() ---- 

// ****************************************************************
// InitPlugIn:		
// **************************************************************** 
	void
AUDIOFX::InitPlugIn(AUDIOFX_PLUGIN *d)
{
int i;

d->maxInputs  = 1;
d->maxOutputs = 1;
d->name       = NULL;
d->typeID     = kAudioFxModuleTypeID_Null;

d->moduleStructSize = 0;
d->smallStateSize   = 0;

for (i = 0; i < kAudioFX_PlugIn_Function_BaseCount; i++)
	{
	d->functionIDList[i].id       = kAudioFX_PlugIn_FunctionID_Null;
	d->functionIDList[i].function = 0;
	}
}	// ---- end InitPlugIn() ---- 

// ****************************************************************
// Update:	Assemble and download DSP code and state blocks
//
//					Return Boolean success
// **************************************************************** 
	int
AUDIOFX::Update()
{
char s[500];
if (!topologyName)
	topologyName = "out";

DefaultCommandNode(&dspCommandNode);

//sprintf(s, "%s.code", topologyName);
//if (!AssembleDSPCodeBlock(s))
//	{
//	printf("Update:  AssembleDSPCodeBlock() failed\n");
//	return (False);
//	}
dspCommandNode.dspModuleCodeBlock     = (Int24) dspCodeBlock;
dspCommandNode.dspModuleCodeBlockSize = dspCodeBlockSize;
// dspCommandNode.commandID |= kDSPCommandID_LoadDSPBlock_Code;

if (topologyName)
	{
	// All of this to get past lack of sprintf() in Resman.
	strcpy(s, "ms_");
	strcat(s, topologyName);
	strcat(s, ".dat");
//	sprintf(s, "ms_%s.dat", topologyName);
	}
else
	strcpy(s, "ms.dat");
if (!AssembleDSPStateBlock(s))
	{
	printf("Update:  AssembleDSPStateBlock() failed\n");
	return (False);
	}
dspCommandNode.moduleCount         = executionListLength;
dspCommandNode.dspModuleBlock      = (Int24) dspModuleBlock;
dspCommandNode.dspModuleBlockSize  = executionListLength*kDSPMODULE_Words;
dspCommandNode.commandID          |= kDSPCommandID_LoadDSPBlock_ModuleList;

dspCommandNode.dspModuleStateBlock     = (Int24) dspStateBlock;
dspCommandNode.dspModuleStateBlockSize = dspStateBlockSize;
dspCommandNode.commandID              |= kDSPCommandID_LoadDSPBlock_State;

// FIXXXX: add code to transfer blocks to System Memory
{
}

// Create DSP command node
{
dspCommandNode.dspModuleBlock     = 2;
dspCommandNode.dspModuleBlockSize = 2;


#ifdef AUDIOFX_STANDALONE
WriteWordsToFile("CommandNode.dat", (Int24 *) &dspCommandNode, sizeof(DSPCOMMANDNODE)/sizeof(Int24));
#else
#endif
}

return (True);
}	// ---- end Update() ---- 

// ****************************************************************
// AssembleDSPCodeBlock:	Concatenate DSP code blocks for
//							all modules included in the execution list.
//							Beginning of block is the list of common
//							routines.  Be sure to link any DSP code
//							functions.
//
//							This function will also fill in the
//							'state' and 'typeID' fields in the
//							DSPModuleBlock.
//
//					Return Boolean success
// **************************************************************** 
	int
AUDIOFX::AssembleDSPCodeBlock(char *filePath)
{
int i, j;
DSPMODULE *modulePtr  = (DSPMODULE *) dspModuleBlock;
Int24      blockIndex = 0;
long	   blockSize  = 0;
long	   computeRoutineAddress[kAudioFxModule_MaxTypes];	
AUDIOFX_MODULE *moduleList[kAudioFx_MaxModules];
AUDIOFX_MODULE *m;

// Setup 
#define kAudioFx_InvalidComputeRoutineAddress	(-1)
for (i = 0; i < kAudioFxModule_MaxTypes; i++)
	computeRoutineAddress[i] = kAudioFx_InvalidComputeRoutineAddress;

// First, calculate size of block.
blockSize = dspCommonRoutinesSize;
for (i = 0; i < executionListLength; i++)
	{
	m = FindAudioFXModule(executionList[i]);
// Failure !  The execution list specifies an invalid module.
	if (!m)
		return (False);
	moduleList[i] = m;
	blockSize += m->parent->dspComputeRoutineSize;
	}

// Allocate new block
if (dspCodeBlock)
        afxSystemMemFree(dspCodeBlock);
dspCodeBlock     = (Int24 *) afxSystemMemAlloc(sizeof(Int24)*blockSize);
dspCodeBlockSize = blockSize;

// Copy module info to new block
#ifdef AUDIOFX_STANDALONE
afxSystemMemCopy(dspCodeBlock, (void *) dspCommonRoutines, sizeof(Int24)*dspCommonRoutinesSize);
#else
afxScratchMemWrite((U032)dspCodeBlock, (void *) dspCommonRoutines, sizeof(Int24)*dspCommonRoutinesSize);
#endif

blockIndex += dspCommonRoutinesSize;
for (i = 0; i < executionListLength; i++)
	{
	m = moduleList[i];

// Add code to block if it doesn't yet exist
	if (kAudioFx_InvalidComputeRoutineAddress == computeRoutineAddress[0])
		{
#ifdef AUDIOFX_STANDALONE
		afxScratchMemCopy(dspCodeBlock+blockIndex, (void *) m->parent->dspComputeRoutine, sizeof(Int24)*m->parent->dspComputeRoutineSize);
#else
		afxScratchMemWrite((U032)(dspCodeBlock+blockIndex), (void *) m->parent->dspComputeRoutine, sizeof(Int24)*m->parent->dspComputeRoutineSize);
#endif
//		computeRoutineAddress[m->typeID] = blockIndex;

//		blockIndex += dspComputeRoutineSizes[m->typeID];
		}

// Assign FX pins (bufferIDs) to DSP addresses.  Process IO pairs
//			because that is the format expected by the DSP.
// Output address in format {all inputs, all outputs}
	for (j = 0; j < m->ioCount/2; j++)
		m->data.smallState[j] = BufferIDToDSPAddress(m->inBufferIDs[j]);

	for (     ; j < m->ioCount; j++)
		m->data.smallState[j] = BufferIDToDSPAddress(m->outBufferIDs[j]);

// Fill in 'compute' and 'typeID' fields in DSPModuleBlock.  Don't touch 'state' field.
//	modulePtr->compute = m->parent->dspComputeRoutine;
	modulePtr->typeID  = m->parent->typeID;
	modulePtr         += sizeof(DSPMODULE);
	}

WriteWordsToFile("DspCode.bin", dspStateBlock, blockIndex+1);

return (True);
}	// ---- end AssembleDSPCodeBlock() ---- 

// ****************************************************************
// AssembleDSPStateBlock:	Concatenate small state blocks for
//							all modules included in the execution list.
//							This function will allocate the correct 
//							block size.
//
//							This function will also fill in the
//							'state' and 'typeID' fields in the
//							DSPModuleBlock.
//
//		The DSP state block will reside in DSP X/YRAM
//
//					Return # words in state block, 0 on failure
// **************************************************************** 
	int
AUDIOFX::AssembleDSPStateBlock(char *filePath)
{
int i, j;
DSPMODULE *modulePtr  = (DSPMODULE *) dspModuleBlock;
Int24      blockIndex = 0;
long	   blockSize  = 0;
AUDIOFX_MODULE *moduleList[kAudioFx_MaxModules];
AUDIOFX_MODULE *m;
int byteSwap = True;

//printf("AssembleDSPStateBlock to '%s'\n", filePath);

// First, calculate size of block.
for (i = 0; i < executionListLength; i++)
	{
	m = FindAudioFXModule(executionList[i]);
// Failure !  The execution list specifies an invalid module.
	if (!m)
		{
		printf("AssembleDSPStateBlock: module %d not found\n", executionList[i]);
		return (0);
		}
	AUDIOFX_PLUGIN *plugIn = m->parent;

	moduleList[i] = m;
	blockSize += plugIn->smallStateSize;
	}

// Allocate new block
if (dspStateBlock)
      afxSystemMemFree(dspStateBlock);
dspStateBlock = (Int24 *) afxSystemMemAlloc(blockSize*sizeof(Int24));
if (!dspStateBlock)
	{
	printf("AssembleDSPStateBlock: unable to allocate new state block\n");
	return (0);
	}
dspStateBlockSize = blockSize;

//printf("AssembleDSPStateBlock: dspStateBlock=%d size=%d\n", dspStateBlock, dspStateBlockSize);

// Copy module info to new block
for (i = 0; i < executionListLength; i++)
	{
	m = moduleList[i];
	AUDIOFX_PLUGIN *plugIn = m->parent;
	if (plugIn)
		{
		Int24 *bPtr = dspStateBlock+blockIndex;
#ifdef AUDIOFX_STANDALONE
	    afxScratchMemCopy(dspStateBlock+blockIndex, (void *) m->data.smallState, sizeof(Int24)*plugIn->smallStateSize);
#else
		afxScratchMemWrite((U032)(dspStateBlock+blockIndex), (void *) m->data.smallState, sizeof(Int24)*plugIn->smallStateSize);
#endif

	// Fill connection information  (All inputs, followed by outputs)
		for (j = 0; j < plugIn->maxInputs; j++)
			*bPtr++ = BufferIDToDSPAddress(m->inBufferIDs[j]);	
		for (j = 0; j < plugIn->maxOutputs; j++)
			*bPtr++ = BufferIDToDSPAddress(m->outBufferIDs[j]);	
		*bPtr++ = kFrameLength;

	// Update DSP Module in execution list
	   blockIndex += plugIn->smallStateSize;
//printf("AssembleDSPStateBlock %2d: moduleID=%2d, typeID=%2d (%s), stateSize=%2d\n",
//	   i, m->moduleID, plugIn->typeID, plugIn->name, plugIn->smallStateSize);
	// Fill in 'state' and 'typeID' fields in DSPModuleBlock. 
		modulePtr->state  = blockIndex;
		modulePtr->typeID = plugIn->typeID;
		modulePtr        += sizeof(DSPMODULE);
		}
	}

// Blast to file
#ifdef AUDIOFX_STANDALONE
{
FILE *h = fopen(filePath, "w+b");
if (NULL == h)
	{
    printf("AssembleDSPStateBlock: unable to open file '%s'\n", filePath);
    return (0);
	}

// Shuffle bytes to write packed 24 bit words
unsigned char *a = (unsigned char *) dspStateBlock;
unsigned char *b = (unsigned char *) dspStateBlock;
if (byteSwap)
	{
	ByteSwapBuf32((long *)dspStateBlock, dspStateBlockSize);
	for (int i = 0; i < dspStateBlockSize; i++, a += 3, b += 4)
		{
		a[0] = b[1];
		a[1] = b[2];
		a[2] = b[3];
		}
	}
else
	{
	for (int i = 0; i < dspStateBlockSize; i++, a += 3, b += 4)
		{
		a[0] = b[0];
		a[1] = b[1];
		a[2] = b[2];
		}
	}

long bytesToWrite = (3*sizeof(Int24)*dspStateBlockSize)/4;
long bytesWritten = fwrite(dspStateBlock, sizeof(char), bytesToWrite, h);
//printf("AssembleDSPStateBlock: wrote %d words (%d bytes) to '%s'\n", 
//	   dspStateBlockSize, bytesWritten, filePath);
fclose(h);
}
#endif

return (dspStateBlockSize);
}	// ---- end AssembleDSPStateBlock() ---- 

// ****************************************************************
// FindAudioFXModule:	 Return ptr to module with specified ID	
// **************************************************************** 
	AUDIOFX_MODULE *
AUDIOFX::FindAudioFXModule(long moduleID)
{
// Scan array for particular module
for (int i = 0; i < maxModules; i++)
	{
	if (moduleID == modules[i].moduleID)
		return (&modules[i]);
	}

return (NULL);
}	// ---- end FindAudioFXModule() ---- 

// ****************************************************************
// FindAudioFXPlugInByID:	 Return ptr to plug-in with specified ID	
// **************************************************************** 
	AUDIOFX_PLUGIN *
AUDIOFX::FindAudioFXPlugInByID(long typeID)
{
// Scan array for particular module
for (int i = 0; i < kAudioFxModule_MaxTypes; i++)
	{
	if (typeID == plugIns[i].typeID)
		return (&plugIns[i]);
	}

return (NULL);
}	// ---- end FindAudioFXPlugInByID() ---- 

// ****************************************************************
// FindAudioFXPlugInByName:	 Return ptr to plug-in with specified name	
// **************************************************************** 
	AUDIOFX_PLUGIN *
AUDIOFX::FindAudioFXPlugInByName(char *name)
{
// Scan array for particular module
for (long i = 0; i < kAudioFxModule_MaxTypes; i++)
	{
	if (plugIns[i].name)
		{
		if(!strcmp(name, plugIns[i].name))
			return (&plugIns[i]);
		}
	}

return (NULL);
}	// ---- end FindAudioFXPlugInByName() ---- 

// **************************************************************** 
// WriteWordsToFile:	 Write array of Int24's to specified file
//
//					Return words written	
// **************************************************************** 
	long
AUDIOFX::WriteWordsToFile(char *filePath, Int24 *data, long count)
{
#ifdef AUDIOFX_STANDALONE
FILE *h = fopen(filePath, "w+b");
if (!h)
	{
	printf("WriteWordsToFile: failed to create '%s'\n", filePath);
	return (False);
	}

// Blast data (swap bytes!) to specified file
long wordsWritten = fwrite( data, sizeof(Int24), count, h );
if (wordsWritten != count)
	{
	printf("WriteWordsToFile: short write of %d/%d to '%s'\n",
				wordsWritten, count, filePath);
	fclose(h);
	return (False);
	}

//printf("WriteWordsToFile: wrote %d words to '%s'\n", wordsWritten, filePath);

fclose(h);
return (wordsWritten);
#else
return (0);
#endif
}	// ---- end WriteWordsToFile() ---- 

// **************************************************************** 
// FxTypeIDToName:	 Return ptr to effect name string
//
// **************************************************************** 
	char *
AUDIOFX::FxTypeIDToName(long typeID)
{
AUDIOFX_PLUGIN *plugIn = FindAudioFXPlugInByID(typeID);
if (!plugIn)
	{
	printf("FxTypeIDToName: unable to find plugIn type=%d\n", typeID);
	return (0);
	}

return (plugIn->name);
}	// ---- end FxTypeIDToName() ---- 

// **************************************************************** 
// FxParameterSize:	 Return size of high-level (often DirectX8) structure
//
// **************************************************************** 
	long
AUDIOFX::FxParameterSize(long typeID)
{
AUDIOFX_PLUGIN *plugIn = FindAudioFXPlugInByID(typeID);
if (!plugIn)
	{
	printf("FxParameterSize: unable to find plugIn type=%d\n", typeID);
	return (0);
	}

return (plugIn->moduleStructSize);

return (0);
}	// ---- end FxParameterSize() ----
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\dspprogs\Wire.h ===
/* Section  7 Including Memory P $000000 (1st word= $300000 ) length=    44 */
    0x300000, 
    0x310C00, 
    0x62F400, 
    0x001420, 
    0x0BF080, 
    0x000062, 
    0x300600, 
    0x61F400, 
    0x001000, 
    0x62F000, 
    0x003024, 
    0x0BF080, 
    0x000082, 
    0x300C00, 
    0x0BF080, 
    0x0000C2, 
    0x300000, 
    0x0BF080, 
    0x0000C8, 
    0x56F400, 
    0x000006, 
    0x0BF080, 
    0x00002C, 
    0x46F400, 
    0x000012, 
    0x08C608, 
    0x000000, 
    0x08F484, 
    0x000001, 
    0x0BF080, 
    0x0000AC, 
    0x56F400, 
    0x000000, 
    0x0BF080, 
    0x0000A2, 
    0x300C00, 
    0x310000, 
    0x0BF080, 
    0x0000CE, 
    0x56F400, 
    0x000006, 
    0x0BF080, 
    0x0000A2, 
    0x0C001A, 

    /* Section  8 Including Memory P $00002C (1st word= $0BF080 ) length=   268 */
    0x0BF080, 
    0x000046, 
    0x08CE15, 
    0x0140C2, 
    0x004000, 
    0x08CE14, 
    0x08F497, 
    0x000000, 
    0x08F485, 
    0x000000, 
    0x00000C, 
    0x08F496, 
    0x000001, 
    0x0A9684, 
    0x000039, 
    0x00000C, 
    0x08F496, 
    0x000002, 
    0x0A96A4, 
    0x00003E, 
    0x00000C, 
    0x08F496, 
    0x000003, 
    0x0A96A3, 
    0x000043, 
    0x00000C, 
    0x08F496, 
    0x000002, 
    0x0A96A4, 
    0x000048, 
    0x08F496, 
    0x000003, 
    0x0A96A3, 
    0x00004C, 
    0x00000C, 
    0x08F496, 
    0x000004, 
    0x0A9683, 
    0x000051, 
    0x00000C, 
    0x08F496, 
    0x000004, 
    0x0A9683, 
    0x000056, 
    0x08F496, 
    0x000001, 
    0x0A9684, 
    0x00005A, 
    0x00000C, 
    0x0A9687, 
    0x00005D, 
    0x08F485, 
    0x000080, 
    0x00000C, 
    0x220E00, 
    0x0140C6, 
    0xFF8000, 
    0x0140C2, 
    0x004000, 
    0x02008E, 
    0x56F400, 
    0x0059E0, 
    0x0200CE, 
    0x56F400, 
    0x000020, 
    0x02088E, 
    0x0A7091, 
    0x000003, 
    0x0A7092, 
    0x000004, 
    0x00000C, 
    0x220E00, 
    0x0140C6, 
    0xFF8000, 
    0x02008E, 
    0x56F400, 
    0x0059E0, 
    0x0200CE, 
    0x56F400, 
    0x000020, 
    0x02088E, 
    0x0A7091, 
    0x000003, 
    0x0A7092, 
    0x000004, 
    0x00000C, 
    0x220E00, 
    0x0140C6, 
    0xFF8000, 
    0x0140C2, 
    0x004000, 
    0x02008E, 
    0x56F400, 
    0x0059E2, 
    0x0200CE, 
    0x56F400, 
    0x000020, 
    0x02088E, 
    0x0A7091, 
    0x000003, 
    0x0A7092, 
    0x000004, 
    0x00000C, 
    0x220E00, 
    0x0140C6, 
    0xFF8000, 
    0x02008E, 
    0x56F400, 
    0x0059E2, 
    0x0200CE, 
    0x56F400, 
    0x000020, 
    0x02088E, 
    0x0A7091, 
    0x000003, 
    0x0A7092, 
    0x000004, 
    0x00000C, 
    0x0D0046, 
    0x08CE15, 
    0x0D0054, 
    0x0D005D, 
    0x00000C, 
    0x0D0046, 
    0x09CE15, 
    0x0D0054, 
    0x0D005D, 
    0x00000C, 
    0x000000, 
    0x0A8581, 
    0x0000AD, 
    0x08F485, 
    0x000002, 
    0x00000C, 
    0x60F400, 
    0x000000, 
    0x44F400, 
    0x000800, 
    0x200013, 
    0x06C420, 
    0x565800, 
    0x00000C, 
    0x60F400, 
    0x001000, 
    0x44F400, 
    0x000800, 
    0x200013, 
    0x06C420, 
    0x565800, 
    0x00000C, 
    0x44F400, 
    0x000020, 
    0x200013, 
    0x06C420, 
    0x565800, 
    0x00000C, 
    0x44F400, 
    0x000020, 
    0x200013, 
    0x06C420, 
    0x5E5800, 
    0x00000C, 
    0x062080, 
    0x0000D1, 
    0x44D800, 
    0x4C5900, 
    0x00000C, 
    0x062080, 
    0x0000D6, 
    0x4CD800, 
    0x445900, 
    0x00000C, 
    0x062080, 
    0x0000DB, 
    0x44D800, 
    0x445900, 
    0x00000C, 
    0x062080, 
    0x0000E0, 
    0x44D800, 
    0x445900, 
    0x00000C, 
    0x062080, 
    0x0000E7, 
    0x44D800, 
    0x56D900, 
    0x200040, 
    0x565A00, 
    0x00000C, 
    0x062080, 
    0x0000EE, 
    0x4CD800, 
    0x5ED900, 
    0x200040, 
    0x5E5A00, 
    0x00000C, 
    0x062080, 
    0x0000F5, 
    0x44D800, 
    0x56E100, 
    0x200040, 
    0x565900, 
    0x00000C, 
    0x062080, 
    0x0000FC, 
    0x4CD800, 
    0x5EE100, 
    0x200040, 
    0x5E5900, 
    0x00000C, 
    0x062080, 
    0x000103, 
    0x4CD800, 
    0x56E100, 
    0x200040, 
    0x565900, 
    0x00000C, 
    0x062080, 
    0x000109, 
    0x46D800, 
    0x2000D0, 
    0x565900, 
    0x00000C, 
    0x062080, 
    0x00010F, 
    0x4ED800, 
    0x2000D0, 
    0x5E5900, 
    0x00000C, 
    0x062080, 
    0x000116, 
    0x46D800, 
    0x56E100, 
    0x2000D2, 
    0x565900, 
    0x00000C, 
    0x062080, 
    0x00011D, 
    0x46D800, 
    0x56E100, 
    0x2000D2, 
    0x565900, 
    0x00000C, 
    0x062080, 
    0x000124, 
    0x44D800, 
    0x56D900, 
    0x200044, 
    0x565A00, 
    0x00000C, 
    0x200013, 
    0x062080, 
    0x000129, 
    0x565800, 
    0x00000C, 
    0x200013, 
    0x062080, 
    0x00012E, 
    0x5E5800, 
    0x00000C, 
    0x062080, 
    0x000132, 
    0x445800, 
    0x00000C, 
    0x062080, 
    0x000136, 
    0x4C5800, 
    0x00000C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\audio\CVPMethod.h ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Functions for MCP1***************************\
*                                                                           *
* Module: CVPMethod.h                                                       *
*     SW functions for Voice Processor class (PIO based)                    *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#if !defined _CVPETHODH_
#define _CVPETHODH_

#define METHOD_MIN_OFFSET(x)       (x)
#define METHOD_MAX_OFFSET(x)       ((x) + 0x4)

class CHalBase;
class CHalVoiceProc;
class CHalGlobalProc;

class CVPMethod
{
public:
    CVPMethod(CHalVoiceProc *pProc, CHalGlobalProc *pGlProc, CHalBase *pHal) 
    { 
        m_pHal = pHal;
        m_pVoiceProc = pProc;
        m_pGlobalProc = pGlProc;
    };

    ~CVPMethod() { };

public:
    VOID Execute(U032 uOffset, U032 uData);

private:
    CHalBase        *m_pHal;
    CHalVoiceProc   *m_pVoiceProc;
    CHalGlobalProc  *m_pGlobalProc;

    // utility
    BOOL CheckRange(U032 uOffset, U032 uMethodOffset)   
    { 
        return ((uOffset >= METHOD_MIN_OFFSET(uMethodOffset)) && 
                (uOffset < METHOD_MAX_OFFSET(uMethodOffset))?TRUE:FALSE);
    }

    // software methods
    RM_STATUS SetContextDMANotify(U032);
    RM_STATUS SetCurrentSSLContextDMA(U032);
    RM_STATUS SetCurrentInBufSGEContextDMA(U032);
    RM_STATUS SetCurrentOutBufSGEContextDMA(U032);

    // damn hacks!
    RM_STATUS SetGPState(U032);
    RM_STATUS SetXCNTMode(U032 uData);
    RM_STATUS SetCurrentOutBufSGEOffset(U032);
    RM_STATUS SetCurrentInBufSGEOffset(U032);
    RM_STATUS SetSSLSegmentOffset(U032);
    RM_STATUS SetSSLSegmentOffsetLength(U032, U032);
    RM_STATUS SetOutBufBA(U032, U032);
    RM_STATUS SetOutBufLen(U032, U032);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\btree\nv\btree.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Balanced Tree *******************************\
*                                                                           *
* Module: BTREE.C                                                           *
*   A generic library to balanced tree management is provided.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nvrm.h>
#include <class.h>
#include <btree.h>
#include <os.h>
//
// Debugging support.
//
#ifdef DEBUG
//
// Validate node.
//
#define VALIDATE_NODE(pn)                   \
{                                           \
    if (btreeNodeValidate(pn) != RM_OK)     \
        return (RM_ERROR);                  \
}
#define VALIDATE_TREE(pt)                   \
{                                           \
    if (btreeTreeValidate(pt) != RM_OK)     \
        return (RM_ERROR);                  \
}
//
// Prototype validation routines.
//
RM_STATUS btreeNodeValidate(PNODE);
RM_STATUS btreeTreeValidate(PNODE);
RM_STATUS btreeDumpBranch(PNODE, U032);
RM_STATUS btreeDumpTree(PNODE);
//
// Validate a nodes branch and count values.
//
RM_STATUS btreeNodeValidate
(
    PNODE Node
)
{
    RM_STATUS status;
    
    status = RM_OK;
    if (Node == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR validating NULL NODE.\n\r");
        DBG_BREAKPOINT();
        return (RM_ERROR);
    }
    if (((Node->LeftCount != 0) && (Node->LeftBranch == NULL))
    ||  ((Node->LeftCount == 0) && (Node->LeftBranch != NULL)))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent left branch, Value = ", Node->Value);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                       Left count = ", Node->LeftCount);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                      Left branch = ", Node->LeftBranch);
        DBG_BREAKPOINT();
        status = RM_ERROR;
    }
    if (((Node->RightCount != 0) && (Node->RightBranch == NULL))
    ||  ((Node->RightCount == 0) && (Node->RightBranch != NULL)))
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent right branch, Value = ", Node->Value);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                       Right count = ", Node->RightCount);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                      Right branch = ", Node->RightBranch);
        DBG_BREAKPOINT();
        status = RM_ERROR;
    }
    return (status);
}
//
// Validate entire BTREE.
//
RM_STATUS btreeBranchValidate
(
    PNODE Node,
    U032 *NodeCount
)
{
    RM_STATUS status;
    U032 LeftCount;
    U032 RightCount;
    
    status = RM_OK;
    if (Node)
    {
        btreeNodeValidate(Node);
        if (Node->LeftBranch)
            status = btreeBranchValidate(Node->LeftBranch, &LeftCount);
        else
            LeftCount = 0;
        if (Node->RightBranch)
            status = btreeBranchValidate(Node->RightBranch, &RightCount);
        else
            RightCount = 0;
        if (Node->LeftCount != LeftCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent left count, Value = ", Node->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Left count = ", Node->LeftCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Left branch = ", Node->LeftBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
        if (Node->RightCount != RightCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent right count, Value = ", Node->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Right count = ", Node->RightCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Right branch = ", Node->RightBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
        *NodeCount = LeftCount + RightCount + 1;
    }
    return (status);
}
RM_STATUS btreeTreeValidate
(
    PNODE Trunk
)
{
    RM_STATUS status;
    U032      LeftCount;
    U032      RightCount;
    
    status = RM_OK;
    if (Trunk)
    {
        status = btreeNodeValidate(Trunk);
        if (Trunk->LeftBranch)
            status |= btreeBranchValidate(Trunk->LeftBranch, &LeftCount);
        else
            LeftCount = 0;
        if (Trunk->RightBranch)
            status |= btreeBranchValidate(Trunk->RightBranch, &RightCount);
        else
            RightCount = 0;
        if (Trunk->LeftCount != LeftCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent left count, Value = ", Trunk->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Left count = ", Trunk->LeftCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Left branch = ", Trunk->LeftBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
        if (Trunk->RightCount != RightCount)
        {
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM_BTREE: ERROR inconsistent right count, Value = ", Trunk->Value);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "                                      Right count = ", Trunk->RightCount);
            DBG_PRINT_STRING_PTR  (DEBUGLEVEL_ERRORS, "                                     Right branch = ", Trunk->RightBranch);
            DBG_BREAKPOINT();
            status = RM_ERROR;
        }
    }
    if (status)
        btreeDumpTree(Trunk);
    return (status);
}
//
// Dump current tree to debug port.
//
RM_STATUS btreeDumpBranch
(
    PNODE Node,
    U032  Level
)
{
    U032 i;

    if (Node)
    {
        VALIDATE_NODE(Node);
        btreeDumpBranch(Node->RightBranch, Level + 1);
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: ");
        for (i = 0; i < Level; i++)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, ".");
        }
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "Node         = ", Node);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Value        = ", Node->Value);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Left count   = ", Node->LeftCount);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Right count  = ", Node->RightCount);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "Left branch  = ", Node->LeftBranch);
        DBG_PRINT_STRING_PTR  (DEBUGLEVEL_TRACEINFO, "Right branch = ", Node->RightBranch);
        btreeDumpBranch(Node->LeftBranch, Level + 1);
    }
    return (RM_OK);
}
RM_STATUS btreeDumpTree
(
    PNODE Trunk
)
{
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: ======================== Tree Dump ==========================\n\r");
    if (Trunk == NULL)
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: NULL\n\r");
    else
        btreeDumpBranch(Trunk, 0);
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM_BTREE: =============================================================\n\r");
    return (RM_OK);
}
#else
//
// Validate nothing.
//
#define VALIDATE_NODE(pn)
#define VALIDATE_TREE(pt)
#endif // DEBUG
//
// Insert new node into tree.
//
RM_STATUS btreeInsertBranch
(
    PNODE Node, 
    PNODE BranchNode
)
{
    RM_STATUS status;
    
    //
    // Check for duplicate names.
    //
    VALIDATE_NODE(BranchNode);
    if (Node->Value == BranchNode->Value)
        return (RM_ERR_INSERT_DUPLICATE_NAME);
    status = RM_OK;    
    if (Node->Value < BranchNode->Value)
    {
        //
        // Insert into right branch.
        //
        if (BranchNode->RightBranch)
        {
            status = btreeInsertBranch(Node, BranchNode->RightBranch);
        }
        else
        {
            BranchNode->RightBranch = Node;
            Node->RightCount        = 0;
            Node->LeftCount         = 0;
            Node->RightBranch       = NULL;
            Node->LeftBranch        = NULL;
        }
        if (status == RM_OK)    
            BranchNode->RightCount++;
    }
    else
    {
        //
        // Insert into left branch.
        //
        if (BranchNode->LeftBranch)
        {
            status = btreeInsertBranch(Node, BranchNode->LeftBranch);
        }
        else
        {
            BranchNode->LeftBranch = Node;
            Node->RightCount       = 0;
            Node->LeftCount        = 0;
            Node->RightBranch      = NULL;
            Node->LeftBranch       = NULL;
        }
        if (status == RM_OK)    
            BranchNode->LeftCount++;
    }
    return (status);
}
RM_STATUS btreeInsert
(
    PNODE  Node,
    PNODE *Trunk
)
{
    RM_STATUS status;

#ifdef DEBUG
    if (Node == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM_BTREE: Inserting NULL into BTREE!\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG    
    status = RM_OK;
    if (*Trunk == NULL)
    {
        *Trunk            = Node;
        Node->RightCount  = 0;
        Node->LeftCount   = 0;
        Node->RightBranch = NULL;
        Node->LeftBranch  = NULL;
    }
    else
    {
        status = btreeInsertBranch(Node, *Trunk);
    }
    VALIDATE_TREE(*Trunk);
    return (status);
}
//
// Remove node from tree.
//
RM_STATUS btreeDelete
(
    U032   Value,
    PNODE *Trunk
)
{
    PNODE Node;
    PNODE ParentNode;
    PNODE PrevNode;
    PNODE SearchNode;

    if (*Trunk == NULL)
        return (RM_ERROR);
    Node       = *Trunk;
    SearchNode = NULL;
    ParentNode = NULL;
    VALIDATE_TREE(*Trunk);
    //
    // Search tree for node being deleted.
    //
    while (Value != Node->Value)
    {
        ParentNode = Node;
        if (Value > Node->Value)
            Node = Node->LeftBranch;
        else
            Node = Node->RightBranch;
        if (Node == NULL)
            //
            // Not found.
            //
            return (RM_ERROR);
    }
    //
    // Check for branches of node to be deleted.
    //
    if (Node->RightCount + Node->LeftCount > 0)
    {
        PrevNode = NULL;
        //
        // Find best candidate to fill in place of deleted node.
        //
        if (Node->RightCount > Node->LeftCount)
        {
            //
            // Get next higher node.
            //
            SearchNode = Node->RightBranch;
            Node->RightCount--;
            while (SearchNode->LeftBranch)
            {
                SearchNode->LeftCount--;
                PrevNode   = SearchNode;
                SearchNode = SearchNode->LeftBranch;
            }
            if (PrevNode)
                PrevNode->LeftBranch = SearchNode->RightBranch;
            else
                Node->RightBranch = SearchNode->RightBranch;
        }
        else
        {
            //
            // Get next lower node.
            //
            SearchNode = Node->LeftBranch;
            Node->LeftCount--;
            while (SearchNode->RightBranch)
            {
                SearchNode->RightCount--;
                PrevNode   = SearchNode;
                SearchNode = SearchNode->RightBranch;
            }
            if (PrevNode)
                PrevNode->RightBranch  = SearchNode->LeftBranch;
            else
                Node->LeftBranch = SearchNode->LeftBranch;
        }
        //
        // Replace deleted node with best candidate.
        //
        SearchNode->LeftBranch  = Node->LeftBranch;
        SearchNode->LeftCount   = Node->LeftCount;
        SearchNode->RightBranch = Node->RightBranch;
        SearchNode->RightCount  = Node->RightCount;
    }
    //
    // Update parent branch pointers.
    //
    if (ParentNode)
    {
        if (ParentNode->LeftBranch == Node)
            ParentNode->LeftBranch  = SearchNode;
        else
            ParentNode->RightBranch = SearchNode;
    }
    else
    {
       *Trunk = SearchNode;
    }
    //
    // Update branch counts up to the deleted node.
    //    
    PrevNode = *Trunk;
    while (PrevNode && (PrevNode != SearchNode))
    {
        if (Value > PrevNode->Value)
        {
            PrevNode->LeftCount--;
            PrevNode = PrevNode->LeftBranch;
        }
        else
        {
            PrevNode->RightCount--;
            PrevNode = PrevNode->RightBranch;
        }
    }
    Node->RightCount  = 0;
    Node->LeftCount   = 0;
    Node->RightBranch = NULL;
    Node->LeftBranch  = NULL;
    VALIDATE_TREE(*Trunk);
    return (RM_OK);
}
//
// Search for node in tree.
//
RM_STATUS btreeSearch
(
    U032   Value,
    PNODE *Node,
    PNODE  Trunk
)
{
    VALIDATE_TREE(Trunk);
    *Node = Trunk;
    //
    // Search for Node Value.
    //
    while (*Node)
    {
        if (Value == (*Node)->Value)
            return (RM_OK);
        if (Value > (*Node)->Value)
            *Node = (*Node)->LeftBranch;
        else
            *Node = (*Node)->RightBranch;
    }
    return (RM_ERR_OBJECT_NOT_FOUND);
}
//
// Enumerate tree.
//
RM_STATUS btreeEnumStart
(
    U032   Value,
    PNODE *Node,
    PNODE  Trunk
)
{
    PNODE EnumNode;
    
    *Node    = Trunk;
    EnumNode = NULL;
    //
    // Search for Node Value.
    //
    while (*Node)
    {
        VALIDATE_NODE(*Node);
        if (Value == (*Node)->Value)
            return (RM_OK);
        if (Value > (*Node)->Value)
            *Node = (*Node)->LeftBranch;
        else
        {
            //
            // Save next nearest node.
            //
            EnumNode = *Node;
            *Node    = (*Node)->RightBranch;
        }
    }
    *Node = EnumNode;
    return (RM_OK);
}
RM_STATUS btreeEnumNext
(
    PNODE *Node,
    PNODE  Trunk
)
{
    PNODE EnumNode;
    U032  Value;
    
    VALIDATE_NODE(*Node);
    if ((*Node)->LeftBranch)
    {
        //
        // Start where we left off.
        //
        Value     = (*Node)->Value + 1;
        *Node    = (*Node)->LeftBranch;
        EnumNode = *Node;
        while (*Node)
        {
            VALIDATE_NODE(*Node);
            if (Value == (*Node)->Value)
                return (RM_OK);
            if (Value > (*Node)->Value)
                *Node = (*Node)->LeftBranch;
            else
            {
                //
                // Save next nearest node.
                //
                EnumNode = *Node;
                *Node    = (*Node)->RightBranch;
            }
        }
        *Node = EnumNode;
        return (RM_OK);
    }
    else
        return (btreeEnumStart((*Node)->Value + 1, Node, Trunk));
}
//
// Balance branch.
//
RM_STATUS btreeBalanceBranch
(
    PNODE *Node
)
{
    PNODE SearchNode;
    PNODE ParentNode;

    VALIDATE_NODE(*Node);
    while ((((*Node)->RightCount > (*Node)->LeftCount)
          ? ((*Node)->RightCount - (*Node)->LeftCount)
          : ((*Node)->LeftCount  - (*Node)->RightCount)) > 1)
    {
        ParentNode = NULL;
        if ((*Node)->RightCount > (*Node)->LeftCount)
        {
            SearchNode = (*Node)->RightBranch;
            while (SearchNode->LeftBranch)
            {
                ParentNode = SearchNode;
                SearchNode->LeftCount--;
                SearchNode = SearchNode->LeftBranch;
            }
            if (ParentNode)
            {
                ParentNode->LeftBranch  = SearchNode->RightBranch;
                SearchNode->RightBranch = (*Node)->RightBranch;
                SearchNode->RightCount  = (*Node)->RightCount - 1;
            }
            else
            {
                (*Node)->RightBranch = NULL;
                (*Node)->RightCount  = 0;
            }
            SearchNode->LeftBranch     = *Node;
            SearchNode->LeftCount      = (*Node)->LeftCount + 1;
            (*Node)->RightBranch = NULL;
            (*Node)->RightCount  = 0;
        }
        else
        {
            SearchNode = (*Node)->LeftBranch;
            while (SearchNode->RightBranch)
            {
                ParentNode = SearchNode;
                SearchNode->RightCount--;
                SearchNode = SearchNode->RightBranch;
            }
            if (ParentNode)
            {
                ParentNode->RightBranch = SearchNode->LeftBranch;
                SearchNode->LeftBranch  = (*Node)->LeftBranch;
                SearchNode->LeftCount   = (*Node)->LeftCount - 1;
            }
            else
            {
                (*Node)->LeftBranch = NULL;
                (*Node)->LeftCount  = 0;
            }
            SearchNode->RightBranch   = *Node;
            SearchNode->RightCount    = (*Node)->RightCount + 1;
            (*Node)->LeftBranch = NULL;
            (*Node)->LeftCount  = 0;
        }
        *Node = SearchNode;
    }
    if ((*Node)->RightBranch)
        btreeBalanceBranch(&((*Node)->RightBranch));
    if ((*Node)->LeftBranch)
        btreeBalanceBranch(&((*Node)->LeftBranch));
    return (RM_OK);
}
//
// Balance tree.
//
RM_STATUS btreeBalance
(
    PNODE *Trunk
)
{
    RM_STATUS status;
    
    status = RM_OK;
    if (*Trunk)
    {
        VALIDATE_TREE(*Trunk);
        status = btreeBalanceBranch(Trunk);
        VALIDATE_TREE(*Trunk);
    }
    return (status);    
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\class\nv\classdel.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CLASSDEL.C                                                        *
*     Deleted user objects are destroyed here if not in use or placed       *
* into a 'zombie' state waiting to go idle before all state is removed.     *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>

//
// No zombie management yet
//
RM_STATUS classAddZombie
(
    POBJECT DeadObject
)
{
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\class\nv\classobj.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CLASSOBJ.C                                                        *
*     NV_CLASS objects are defined and managed in this module.              *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <fifo.h>
#include <os.h>
#include <modular.h>


//
// Class object table.
//
extern CLASS classTable[];


//---------------------------------------------------------------------------
//
//  Class object method functions.
//
//---------------------------------------------------------------------------

RM_STATUS mthdCreateLegacy
(
	PHWINFO pDev,
    POBJECT ClassObject,
    PMETHOD Method,
    U032    Offset,
    U032    NewName
)
{
    RM_STATUS status;
    POBJECT   NewObject;

    if (NewName < RESERVED_NAMES)
        return (RM_ERR_CREATE_BAD_CLASS);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Creating Object ", NewName);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               Class  ", ClassObject->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               ChID   ", ClassObject->ChID);
    
    //
    // Class specific creation routine.
    //
    status = classCreate((VOID*)pDev, (PCLASSOBJECT)ClassObject, NewName, &NewObject, NULL);
    if (status == RM_OK)
    {
        //
        // Init global state.
        //
        DBG_VAL_PTR(NewObject);

        //
        // Stick new object into FIFO database.
        //
        if ((status = fifoAddObject(pDev, NewObject)) != RM_OK)
            classDestroy((VOID*)pDev, NewObject);
    }
    return (status);
}
RM_STATUS mthdCreate
(
	PHWINFO pDev,
    POBJECT ClassObject,
    PMETHOD Method,
    U032    Offset,
    U032    NewName,
    VOID*   pCreateParms
)
{
    RM_STATUS status;
    POBJECT   NewObject;

    if (NewName < RESERVED_NAMES)
        return (RM_ERR_CREATE_BAD_CLASS);

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Creating Object ", NewName);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               Class  ", ClassObject->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "               ChID   ", ClassObject->ChID);
    
    //
    // Class specific creation routine.
    //
    status = classCreate((VOID*)pDev, (PCLASSOBJECT)ClassObject, NewName, &NewObject, pCreateParms);
    if (status == RM_OK)
    {
        //
        // Init global state.
        //
        DBG_VAL_PTR(NewObject);

        //
        // Stick new object into FIFO database.
        //
        if ((status = fifoAddObject(pDev, NewObject)) != RM_OK)
            classDestroy((VOID*)pDev, NewObject);
    }
    return (status);
}
RM_STATUS mthdDestroy
(
	PHWINFO pDev,
    POBJECT ClassObject,
    PMETHOD Method,
    U032    Offset,
    U032    DelName
)
{
    RM_STATUS status;
    POBJECT   DelObject;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Destroying Object ", DelName);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 Class  ", ClassObject->Name);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                 ChID   ", ClassObject->ChID);
    //
    // Retrieve and delete object from FIFO database.
    //    
    status = fifoSearchObject(pDev, DelName, ClassObject->ChID, &DelObject);
    if (status == RM_OK)
    {
        //
        // Make sure to free up any events in this object
        //
        if (DelObject->NotifyEvent)
        {
            PEVENTNOTIFICATION thisEvent = DelObject->NotifyEvent;
            PEVENTNOTIFICATION nextEvent = DelObject->NotifyEvent->Next;
            
            //
            // Walk the event chain and delete
            //
            osFreeMem((VOID *)thisEvent);
            while (nextEvent)
            {
                thisEvent = nextEvent;
                nextEvent = thisEvent->Next;
                osFreeMem((VOID *)thisEvent);
            }
        }
        
        //
        // Class specific delete procedure.
        //
        status  = fifoDelObject(pDev, DelObject);
        status |= classDestroy((VOID*)pDev, DelObject);
    }
    return (status);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\class\nv\control.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CONTROL.C                                                         *
*     Control methods are implemented in this module.                       *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <gr.h>
#include <os.h>
#include <nv32.h>
#include "control.h"
#include "nvhw.h"

//
// FIFO database.
//

//---------------------------------------------------------------------------
//
//  Control methods.
//
//---------------------------------------------------------------------------


CTRLMETHOD NvControlMethods[] =
{
    {mthdSetObject,                 0x0000, 0x0003}
#ifdef OBSOLETE_FUNCTIONS
    {mthdSetStallNotifier,          0x0050, 0x0053},
    {mthdStallChannel,              0x0054, 0x0057}
#endif // OBSOLETE_FUNCTIONS
};

// Class representing information for channel control operations
CTRLCLASS NvControlClass =
{
    NvControlMethods,
    sizeof(NvControlMethods) / sizeof(CTRLMETHOD)
};


// Implementation of the control "Set Object" method
RM_STATUS mthdSetObject
(
    PHWINFO     pDev, 
    U032        ChID,
    U032        SubChannel,
    PCTRLMETHOD Method, 
    U032        Offset, 
    V032        Data
)
{
    U032    Context;
    POBJECT Object;
#ifdef KJK
    U032    CacheChID;
#endif

    if (Data == NV1_NULL_OBJECT)
    {
        //
        // Set to the NULL object.
        //
        pDev->DBfifoTable[ChID].SubchannelContext[SubChannel] = NULL;
    }
    else if (fifoSearchObject(pDev, Data, ChID, &Object) == RM_OK)
    {
    
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: SetObject on subchannel: ", SubChannel);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "                      Object#: ", Object->Name);
    
        //
        // Set this as the current object for this ChID/SubChannel.
        //
        pDev->DBfifoTable[ChID].SubchannelContext[SubChannel] = Object;

        //
        // Set the current subchannel for this object, per this SetObject
        //
        Object->Subchannel = SubChannel;
        
        //
        // Update the fifo context for this subchannel back to a software object
        //
        Context = REG_RD32(NV_PFIFO_CACHE1_ENGINE);
        Context &= ~(0x03 << (SubChannel*4));
        REG_WR32(NV_PFIFO_CACHE1_ENGINE, Context);
    }
    else
    {
        //
        // Object not found.
        //
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetObject on invalid object: ", Data);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].SubchannelContext[SubChannel] = NULL;
    }
    
#ifdef KJK    
    //
    // Do the hash function.  Update the appropriate channel context.
    //
    fifoHashEntry(pDev->DBfifoTable[ChID].ObjectStack[SubChannel][0], ChID, &Context);
    CacheChID = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID);
    if (CacheChID == ChID)
    {
        REG_WR32(NV_PFIFO_CACHE1_CTX(SubChannel), Context);
        REG_WR32(NV_PFIFO_CACHE1_PULL1, DRF_DEF(_PFIFO, _CACHE1_PULL1, _CTX,       _DIRTY));
    }
    else
    {
        U032  *CtxtPtr = (U032 *)pDev->Pram.FifoContextAddr;
        MEM_WR32((U032)(CtxtPtr + (ChID * 8) + SubChannel), Context);
    }
#endif // KJK
    
    return(RM_OK);
}

#ifdef OBSOLETE_FUNCTIONS
// Implementation of the control "Set Stall Notifier" method
RM_STATUS mthdSetStallNotifier
(
    PHWINFO     pDev, 
    U032        ChID,
    U032        SubChannel,
    PCTRLMETHOD Method, 
    U032        Offset, 
    V032        Data
)
{
    RM_STATUS status;

    if (!(REG_RD32(NV_PFIFO_MODE) & (1 << ChID))) 
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: SetStallNotifier not valid for PIO channel: ", ChID);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].StallNotifier = NULL;
        return RM_ERR_ILLEGAL_ACTION;
    }

    status = dmaValidateObjectName(pDev, Data,
                                   ChID,
                                   &(pDev->DBfifoTable[ChID].StallNotifier));
    if (status) {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Invalid notifier for SetStallNotifier: ", Data);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].StallNotifier = NULL;
        return RM_ERR_BAD_OBJECT;
    }

    return RM_OK;
}


// Implementation of the control "Stall Channel" method
RM_STATUS mthdStallChannel
(
    PHWINFO     pDev, 
    U032        ChID,
    U032        SubChannel,
    PCTRLMETHOD Method, 
    U032        Offset, 
    V032        Data
)
{
    RM_STATUS status;
    U032      GetPtr;

    if (!(REG_RD32(NV_PFIFO_MODE) & (1 << ChID))) 
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: StallChannel not valid for PIO channel: ", ChID);
        DBG_BREAKPOINT();
        pDev->DBfifoTable[ChID].StallNotifier = NULL;
        return RM_ERR_ILLEGAL_ACTION;
    }

    // Remember the current position of the PutPtr.
    pDev->DBfifoTable[ChID].Put = REG_RD32(NV_PFIFO_CACHE1_PUT);

    // Make the Put the same as Get. The getptr will be incremented to skip 
    // over the stall channel method. Account for that when setting the putptr.
    GetPtr     = REG_RD32(NV_PFIFO_CACHE1_GET) >> 2;
    GetPtr++;
    REG_WR_DRF_NUM(_PFIFO, _CACHE1_PUT, _ADDRESS, GetPtr);

    // Mark this channel as stalled.
    pDev->DBfifoTable[ChID].IsStalledPendingVblank = TRUE;

    // Write the stall notifier.
    if (pDev->DBfifoTable[ChID].StallNotifier) 
    {
        status = notifyFillNotifierArray(pDev, pDev->DBfifoTable[ChID].StallNotifier, 
                                         0 /* info16 */, 0 /* info32 */, 
                                         Data,
                                         0 /* index */);
    }

    return RM_OK;
}

RM_STATUS mthdEnableStalledChannels
(
    PHWINFO   pDev,
    RM_STATUS status
)
{
    U032 i, currentCh, pushPending;
    BOOL isDma;
    // Check all DMA channels other than the current channel that are in use 
    // (The stalled channel cannot be the current one.)
    currentCh = REG_RD_DRF(_PFIFO, _CACHE1_PUSH1, _CHID); 
    for (i = 0; i < NUM_FIFOS; i++)
    {
        isDma = REG_RD32(NV_PFIFO_MODE) & (1 << i);
        if (pDev->DBfifoTable[i].InUse && isDma && i != currentCh && 
            pDev->DBfifoTable[i].IsStalledPendingVblank)
        {
            // This channel was stalled pending a vblank.
            // Update the put in instance memory and mark this channel as push pending.
            REG_WR32((0x714000 + i * 32), pDev->DBfifoTable[i].Put);
            pushPending = REG_RD32(NV_PFIFO_DMA);
            pushPending |= (1 << i);
            REG_WR32(NV_PFIFO_DMA, pushPending);
            // Write the stall notifier.
            if (pDev->DBfifoTable[i].StallNotifier) 
            {
                notifyFillNotifierArray(pDev, pDev->DBfifoTable[i].StallNotifier, 
                                        0 /* info16 */, 0 /* info32 */, 
                                        status,
                                        0 /* index */);
            }

            pDev->DBfifoTable[i].IsStalledPendingVblank = FALSE;
        }
    }

    return RM_OK;
}
#endif // OBSOLETE_FUNCTIONS
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dacedid.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* EDID Functions *****************************
*                                                                           *
* Module: EDID.C                                                            *
*   All EDID related fuctions are in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nvrm.h>
#include <i2c.h>
#include <tmr.h>
#include <edid.h>
#include "nvhw.h"
#include <dac.h>
#include <devinit.h>
#include <vga.h>


U032 getI2CPort(PHWINFO pDev, U032 Head, U032 dispType )
{
    // We have to know what the mappings of ports to display devices are.
    // Until we can get this from the BIOS, assume the following:
    switch (dispType)
    {
        case DISPLAY_TYPE_MONITOR:
        case DISPLAY_TYPE_DUALSURFACE:
            if (Head == 0) 
                return pDev->Dac.CRTPortID; // VGA Head 0 use port 0
            else
                return pDev->Dac.CRT2PortID; // DVI Head 1 use port 1
        case DISPLAY_TYPE_FLAT_PANEL:
            if (Head == 0) 
                return pDev->Dac.DFPPortID; // DVI Head 0
            else
                return pDev->Dac.DFP2PortID; // DVI Head 1
        case DISPLAY_TYPE_TV:
            return pDev->Dac.TVOutPortID;
        default:
            return NV_I2C_PORT_PRIMARY;
    }
}

static U032 edidTranslateDisplayType(U032 displayType)
{
    switch (displayType)
    {
        case DCB_DEV_REC_TYPE_CRT:
        {
            return DISPLAY_TYPE_MONITOR;
        }
        case DCB_DEV_REC_TYPE_TV:
        {
            return DISPLAY_TYPE_TV;
        }
        case DCB_DEV_REC_TYPE_DD_SLINK:
        case DCB_DEV_REC_TYPE_DD_DLINK:
        case DCB_DEV_REC_TYPE_DD:
        {
            return DISPLAY_TYPE_FLAT_PANEL;
        }
        default:
            return DISPLAY_TYPE_NONE;
    }
}

// Get the monitor to stop driving the DDC bus (DDC1)
// This may only stop the CRT momentarily; we must send a valid DDC2 address
// to be sure it stops permanently.
RM_STATUS StopDDC1(PHWINFO pDev, U032 Head, U032 dispType)
{
U032	i2cPortId = 0;	
U016	status = 1, i;
U008	Data;

    i2cPortId = getI2CPort(pDev, Head, dispType);
    i2cHardwareInit(pDev, Head, i2cPortId);
    tmrDelay(pDev, 15000);
    ResetSCLLine(pDev, Head, i2cPortId);     // drive clock low (data tristated)
    tmrDelay(pDev, 2000000);
    SetSCLLine(pDev, Head, i2cPortId);       // clock high
    SetSDALine(pDev, Head, i2cPortId);       // data high
    for (i=0; i<16; i++)	// give it 16 times
    {
        tmrDelay(pDev, 15000);
        ReadSDA(pDev, Head, i2cPortId, &Data);
        if(Data)        	// SDA = 1?
        {
            status=0;
            break;
        }
    }
    tmrDelay(pDev, 10000);
    i2cStop(pDev, Head, i2cPortId);
    
    // Leave it with clock low (problem with ViewSonic monitors)
    ResetSCLLine(pDev, Head, i2cPortId);     // drive clock low (data tristated)
    tmrDelay(pDev, 2000000);
	
    if (status)
        return (RM_ERROR);
    return (RM_OK);
}

//****************************************************************************************
/*	Determine if monitor is DDC, and in doing so, get it ready to read the EDID or VDIF
	This means get it in DDC2 mode and send the address. Try addresses A0 and A2.
*/
RM_STATUS IsMonitorDDC(PHWINFO pDev, U032 Head, U032 dispType, U008 *dispAddr)
{
    RM_STATUS status;
    U008	Adr, Data;
    U032    i2cPortId;

    i2cPortId = getI2CPort(pDev, Head, dispType);
    // NV11 can drive a CRT on either head; earlier devices only on port 0.
    if (IsNV11(pDev) || (i2cPortId == 0))  
    {
        StopDDC1(pDev, Head, dispType);	// stop the CRT from driving the bus
    }

    // now monitor is in DDC2 mode; we can talk to it
    // send address 0 (start of EDID), no other data
    Adr = 0;
    *dispAddr = DDC_CRT_ADR1;
    if (dispType == DISPLAY_TYPE_MONITOR) {
        status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data);   // if it fails, its not DDC
    }
    else if (dispType == DISPLAY_TYPE_FLAT_PANEL)
    {
        // if flat panel, device address can be A0, A2, or A6 (50/51/53 shifted left)
	    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data);   
        if (status)
        {
            *dispAddr = DDC_CRT_ADR2;
		    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR2, 1, &Adr, 0, &Data);  
            if (status)
            {
                *dispAddr = DDC_CRT_ADR3;
    		    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR3, 1, &Adr, 0, &Data);  
            }
        }
    }
    else
    {
        // not a DDC device
        status = RM_ERROR;
    }

    return status;
}

U032 edidGetVersion(PHWINFO pDev, U032 Head)
{
    U008 j, edidV1Head[] = {0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00};

    // check for version 1 edid header
    for (j = 0; j < 8; j++)
    {
        if (pDev->Dac.CrtcInfo[Head].EDID[j] != edidV1Head[j])
        {
            break;
        }
    }

    if (j == 8)
    {
        return 1;
    }

    if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_VERSION_NUMBER_INDEX] & 0xf0) == 0x20)
        return 2;

    return 0;	// Invalid or unknown EDID
}

//****************************************************************************************
/*	Checksum an EDID
 */
BOOL EDIDCheckSumOk(
    PHWINFO pDev, 
    U032    Head, 
    U008   *edid,
    U032    length,
    U008   *checksum
)
{
    U032 j;
    int  chksum;

    // This is version 1 header
    // checksum the block
    chksum = 0;

    for (j=0; j<length; j++)
        chksum += *edid++;
    *checksum = (U008) chksum; 
    return ((U008) chksum) == 0;
}

//****************************************************************************************
/*	Read EDID
    Read the EDID of the specified device into the caller's buffer
    The device is specified by the DWORD which is a bit map of up to 8 CRT's, 8 DFP's, and 8 TV's.
*/
RM_STATUS edidReadDevEDID(PHWINFO pDev, U032 device, U008 *pEdid)
{
    RM_STATUS    status = RM_ERROR;
#ifndef IKOS    // This is just too painfully slow
    int	    i,j;
    U008    block_ID;
    U032    i2cPortID, Head, dispType;
	U008 	dispAddr, chksum;



    status = dacGetDisplayInfo(pDev, device, &Head, &dispType, 0, 0);

    if (status != RM_OK)
    {
        return status;
    }

    dispType = edidTranslateDisplayType(dispType);

    if (dispType == DISPLAY_TYPE_NONE)
    {
        status = RM_ERROR;
        return status;
    }
    //
    // Look for EDID overrides for mobile operation
    //
    if (dispType == DISPLAY_TYPE_FLAT_PANEL && pDev->Power.MobileOperation)
    {
        status = edidConstructMobileInfo(pDev, Head, pEdid);
        if (status == RM_OK)
            return RM_OK;
    }

	// See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    if (status != RM_OK)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
        // Monitor is not DDC compliant.
        goto done;
    }

    if (IsNV15(pDev) && (device == 0x2))        // CRT on DVI-I connector
        i2cPortID = getI2CPort(pDev, 1, dispType);
    else
        i2cPortID = getI2CPort(pDev, Head, dispType);

    for (i=0; i<DDC_RETRIES; i++)
    {
        block_ID = 0;
        // send a write command and read back a block 
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortID, dispAddr, 1, &block_ID, 128, pEdid);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2, we need to read
            // another 128 bytes.
            if (pEdid[0] == 0 && pEdid[1] == 0xff &&
                pEdid[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
            	if (EDIDCheckSumOk(pDev, Head, pEdid, 128, &chksum))
            	    goto done;
            }
            else if ((pEdid[0] >> 4) == 2)
            {
                // This is a version 2 header. Read the next 128 byte block.
                block_ID = 128;
                // send a write command and read the next block 
                // NOTE: the device address is shifted up in our function (50->A0)
                status = i2cRead(pDev, Head, i2cPortID, dispAddr, 1, &block_ID, 128, 
                                 &(pEdid[128]));
                if (status == RM_OK)
	            	if (EDIDCheckSumOk(pDev, Head, pEdid, 256, &chksum))
	            	    goto done;
            }
    	}
        // if we failed, try to reset the slave
        for (j=0; j< 10; j++) 
        {
            i2cStart(pDev, Head, i2cPortID);
            tmrDelay(pDev, 10000);
            i2cStop(pDev, Head, i2cPortID);
            tmrDelay(pDev, 10000);
        }
    } // retry

    // if we fall out of the retry loop, then its an error
    status = RM_ERROR;
	
done:

#endif // defined IKOS

    return status;
}


//****************************************************************************************
/*	Read EDID
	dispType is the display we want to read, not necessarily the current device.
    This will alwasy return RM_OK, since we'll get the BIOS default EDID if none if found,
    UNLESS this if for mobile?
*/
RM_STATUS EDIDRead(PHWINFO pDev, U032 Head, U032 dispType)
{
    RM_STATUS    status = RM_ERROR;
#ifndef IKOS    // This is just too painfully slow
    int	    i,j;
    U008    block_ID;
    U032    i2cPortId;
    U008    dispAddr, chksum;
    U032    oldDDC;

    if (IsNV11(pDev)) 
    {
        oldDDC = CurrentHeadDDC(pDev);
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }
    
    //
    // Look for EDID overrides for mobile operation
    //
    if ((dispType == DISPLAY_TYPE_FLAT_PANEL) && pDev->Power.MobileOperation)
    {
        status = edidConstructMobileInfo(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID);
        if (status == RM_OK)
            goto done;
    }

	// See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }

    i2cPortId = getI2CPort(pDev, Head, dispType);

    for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block 
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 128, pDev->Dac.CrtcInfo[Head].EDID);
        if (status == RM_OK)
        {
            U008 j, Edid_V1_Header[] = {0x00,0xff,0xff,0xff,0xff,0xff,0xff,0x00};
            // Check which version of the header. If it was version 2, we need to read
            // another 128 bytes.
            for (j=0; j<8; j++) 
            {
                if (pDev->Dac.CrtcInfo[Head].EDID[j] != Edid_V1_Header[j])
                    break;
            }
            if (j==8) 
            {
// There are monitors with non-zero checksums which we do not want to fail.
//            	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 128))
            	    goto done;
            }
            else if ((pDev->Dac.CrtcInfo[Head].EDID[0] >> 4) == 2)
            {
                // This is a version 2 header. Read the next 128 byte block.
                block_ID = 128;
                // send a write command and read the next block 
                // NOTE: the device address is shifted up in our function (50->A0)
                status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 128, 
                                 &(pDev->Dac.CrtcInfo[Head].EDID[128]));
                if (status == RM_OK)
	            	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 256, &chksum))
	            	    goto done;
            }
    	}
        // if we failed, try to reset the slave (may be hung up and not responding)
        for (j=0; j< 20; j++) 
        {
            i2cStart(pDev, Head, i2cPortId);
            tmrDelay(pDev, 20000);      // 20 us
            i2cStop(pDev, Head, i2cPortId);
            tmrDelay(pDev, 20000);
            // one last desparate measure 
            StopDDC1(pDev, Head, dispType);	// stop the CRT from driving the bus
            tmrDelay(pDev, 2000000);    // 2 ms
        }


    } // retry

	// if we fall out of the retry loop, then its an error
	status = RM_ERROR;
	
done:
    if (IsNV11(pDev))
    {
        AssocDDC(pDev, oldDDC); //restore previous DDC owner
    }
#endif // defined IKOS

    return status;
}

//****************************************************************************************
/*	See if a device has an EDID 
	dispType is the display we want to read, not necessarily the current device.
*/
RM_STATUS EDIDDetect(PHWINFO pDev, U032 Head, U032 dispType)
{
#ifndef IKOS    // This is just too painfully slow
    int	    i;
    RM_STATUS    status;
    U008    block_ID, lock;
    U032    i2cPortId;
    U008    dispAddr;
    U008    EdidBuffer[128];
    U032    oldDDC;

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    
    if (IsNV11(pDev)) 
    {
        oldDDC = CurrentHeadDDC(pDev);
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }

    if (dispType == DISPLAY_TYPE_FLAT_PANEL && pDev->Power.MobileOperation)
    {
        //!!!We have to check here is it really flat panel???
        status = RM_OK;
        goto   done;
    }

	// See if device supports DDC and which address it uses
    if (IsMonitorDDC(pDev, Head, dispType, &dispAddr) != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        status = RM_ERROR;
        goto done;
    }

    i2cPortId = getI2CPort(pDev, Head, dispType);

    for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block (at least 0x50 bytes to get version 2 display technology byte).
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 0x50, EdidBuffer);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2,
            if (EdidBuffer[0] == 0 && EdidBuffer[1] == 0xff &&
                EdidBuffer[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
                // This is version 1 header, get video input definition
                if (EdidBuffer[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))     // digital device?
                {
                    if (dispType == DISPLAY_TYPE_FLAT_PANEL) 
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
                else
                {
                    if (dispType == DISPLAY_TYPE_MONITOR)                   // we're looking for analog
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
            }
            else if ((EdidBuffer[0] >> 4) == 2)
            {
                // This is a version 2 header.
                if ((EdidBuffer[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0) // analog device?
                {
                    if (dispType == DISPLAY_TYPE_MONITOR)                   // we're looking for analog
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
                else
                {
                    if (dispType == DISPLAY_TYPE_FLAT_PANEL) 
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
            }
            else
            {
                // Unknown edid header.
                status = RM_ERROR;
            }
    	} // Successfully read the first 128 byte block.
    } // retry

done:    
    if (IsNV11(pDev))
    {
        AssocDDC(pDev, oldDDC); //restore previous DDC owner
    }

    RestoreLock(pDev, Head, lock);

    return status;
#else   // defined IKOS
    return RM_ERROR;
#endif  // IKOS
}

//****************************************************************************************
/*	Read VDIF
	VDIF follows after last EDID block, so to read a VDIF block we need to get the
	number of EDID blocks (*128) and add the VDIF block (*64)
*/
RM_STATUS ReadVDIF(PHWINFO pDev, U032 Head, U032 dispType, U008 *buffer, U008 device, U008 address)
{
    int     i;
    RM_STATUS  status;
    U008    Adr;
    U032    i2cPortId;

// FILL IN THIS !!!

    // get number of EDID blocks

    // calc VDIF block address

    // read VDIF
    i2cPortId = getI2CPort(pDev, Head, dispType);
    status = RM_OK;       /* macosX's version of gcc thinks 'status' may not be init before use */
    for (i=0; i<DDC_RETRIES; i++)
    {
        // send a write command and read back a block (NOTE: the device address is shifted up in our function, so 50->A0)
        status = i2cRead(pDev, Head, i2cPortId, 0x50, 0, &Adr, 128, buffer);
        if (status == RM_OK)
            break;		
    }

    return (status);
}

RM_STATUS ReadAnyEdidBlock(PHWINFO pDev, U032 Head, U032 dispType, U016 ByteAddress, U008 *VesaDataBuffer)
{
    U008 dispAddr;
    RM_STATUS status;
    U032 i2cPortId;
    U032 retry_count;
    U008 RealByteAddress;
    U008 RealSegmentAddress;
    U008 LockStat;
    U032 oldDDC;

    LockStat=UnlockCRTC(pDev, Head);

    //Connect the head to the I2C pins
    if (IsNV11(pDev)) 
    {
        oldDDC = CurrentHeadDDC(pDev);
        AssocDDC(pDev, Head);
    }
    
    // See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }
    
    if(ByteAddress>128)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Byte Address greater than 128 specified ", Head);
        
        status=RM_ERROR;
        
        goto done;
    }
    
    //the true byte address cannot exceed 255, in the future I will implement the segment access code
    RealByteAddress=(U008)(ByteAddress%256);
    
    //calculate the segment address
    RealSegmentAddress=(U008)(ByteAddress/256);
    
    //be sure the segment does not exceed 0x7f (EDDCv1.pdf Version 1 of the Enhanced DDC spec for retrieving > 256 EDIDs)
    RealSegmentAddress=(U008)((RealSegmentAddress>0x7f)?0:RealSegmentAddress);
    
    i2cPortId = getI2CPort(pDev, Head, dispType);
   
    retry_count=0;
    
    //do read
    do
    {
        //if segment is not zero, set the segment here (segment set is not currently implemented)
        
        /*
        //note, at this rev, we can't actually get the next chunk. Most of the infrastructure is here though
        status=i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &RealByteAddress, 128,VesaDataBuffer);
        */
        
        status=i2cRead_EDDC(pDev, Head, i2cPortId, RealSegmentAddress, dispAddr, RealByteAddress, 128, VesaDataBuffer);

        
    }while((++retry_count!=DDC_RETRIES)&&(status!=RM_OK));
    
    //we do not verify checksum here, as if the user is retrieving a V2 or V3 EDID, the checksum may not fall at 127
    
done:
    if (IsNV11(pDev))
    {
        AssocDDC(pDev, oldDDC); //restore previous DDC owner
    }

    RestoreLock(pDev,Head,LockStat);

    return status;
}

// Checks to see if the EDID is present in the pDev and if it matches a valid version.
// The version and revision is returned, as well as a pointer to the requested EDID buffer.
static BOOL EDIDIsValid
(
    PHWINFO pDev,
    U008    **edidPtr,
    U032    *version,
    U032    *revision,
    U032    Head
)
{
    U008 *edid;


    edid = pDev->Dac.CrtcInfo[Head].EDID;
    // Check the version of the edid header.
	if (!(edid[0] == 0 && edid[1] == 0xff))
	{
		// this is not version 1 edid header
		// check if it is version 2 header.
        // Bits 7-4 of byte 0 is the version and bits 3-0 of byte 0 is the revision
		if (((edid[0] & 0xf0) >> 4) == 2)
		{
            *version = 2;
            *revision = edid[0] & 0x0f;
            *edidPtr = edid;
            return TRUE;
		}

		// Unknown edid header.
        return FALSE;
	}

    // Check for version 1 edid header.
    if (edid[EDID_V1_VERSION_NUMBER_INDEX] == 1)
    {
        *version = 1;
        *revision = edid[EDID_V1_REVISION_NUMBER_INDEX];
        *edidPtr = edid;
        return TRUE;
    }

    // Unknown edid header.
    return FALSE;

}

// Checks to see if the EDID is present in the pDev and if it matches a valid version.
// The version and revision is returned, as well as a pointer to the requested EDID buffer.
BOOL edidLogicalEDIDIsValid
(
    U008    **edidPtr,
    U032    *version,
    U032    *revision
)
{
    U008 *edid;


    edid = *edidPtr;
    // Check the version of the edid header.
	if (!(edid[0] == 0 && edid[1] == 0xff))
	{
		// this is not version 1 edid header
		// check if it is version 2 header.
        // Bits 7-4 of byte 0 is the version and bits 3-0 of byte 0 is the revision
		if (((edid[0] & 0xf0) >> 4) == 2)
		{
            *version = 2;
            *revision = edid[0] & 0x0f;
            *edidPtr = edid;
            return TRUE;
		}

		// Unknown edid header.
        return FALSE;
	}

    // Check for version 1 edid header.
    if (edid[EDID_V1_VERSION_NUMBER_INDEX] == 1)
    {
        *version = 1;
        *revision = edid[EDID_V1_REVISION_NUMBER_INDEX];
        *edidPtr = edid;
        return TRUE;
    }

    // Unknown edid header.
    return FALSE;

}

static RM_STATUS EDIDV1Copy
(
    PHWINFO pDev,
    U008    *edid,
    U008    *buffer,
    U032    *bufLen
)
{
    // version 1
    if (*bufLen < EDID_V1_SIZE)
    {
        // There is not enough space in the buffer.
        *bufLen = 0;
        return RM_ERROR;
    }

    // There is enough space in the buffer.
    *bufLen = EDID_V1_SIZE;

	osMemCopy((U008*) buffer, (U008*) edid, *bufLen);
    return RM_OK;
}

static RM_STATUS EDIDV2Copy
(
    PHWINFO pDev,
    U008    *edid,
    U008    *buffer,
    U032    *bufLen
)
{
    // Version 2
    if (*bufLen < EDID_V2_SIZE)
    {
        // There is not enough space in the buffer.
        *bufLen = 0;
        return RM_ERROR;
    }

    // There is enough space in the buffer.
    *bufLen = EDID_V2_SIZE;
    
    osMemCopy((U008*) buffer, (U008*) edid, *bufLen);
    return RM_OK;
}

// This function copies the edid from the pDev into the buffer passed.
// Currently only version 1 edid header is supported.
RM_STATUS EDIDCopy
(
    PHWINFO pDev,
    U008    *buffer,
    U032    *bufLen,
    U032    Head
)
{
    U032 edidVersion, edidRevision;
    U008 *edid;

    if (!EDIDIsValid(pDev, &edid, &edidVersion, &edidRevision, Head)) // verify EDID and get a pointer to it
    {
        // edid not valid
        *bufLen = 0;
        return RM_ERROR;
    }

    if (edidVersion == 1)
    {
        return EDIDV1Copy (pDev, edid, buffer, bufLen);
    }
    else if (edidVersion == 2)
    {
        return EDIDV2Copy (pDev, edid, buffer, bufLen);
    }

    // Unknown edid header.
    *bufLen = 0;
    return RM_ERROR;
} // end of EDIDCopy

#if 0 // no one calling this, so turn it off 
static RM_STATUS EDIDV1GetMaxRefreshRate
(
    PHWINFO pDev,
    U008   *edid,
    U032    hRes,
    U032    vRes,
    U032   *maxRefreshRate
)
{
    U032      i, j, tmpHRes, tmpVRes = ~0, tmpRefresh;

    *maxRefreshRate = 0;
    // Get the max from the established timing section
    switch (hRes)
    {
        case 720:
            if (vRes == 400)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x40)
                {
                    // Supports 720x400 @ 88Hz.
                    *maxRefreshRate = 88;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x80)
                {
                    // supports 720x400 @ 70Hz
                    *maxRefreshRate = 70;
                }

            }
            break;
        case 640:
            if (vRes == 480)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x04)
                {
                    // Supports 640x480 @ 75Hz.
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x08)
                {
                    // supports 640x480 @ 72Hz
                    *maxRefreshRate = 72;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x10)
                {
                    // supports 640x480 @ 67Hz
                    *maxRefreshRate = 67;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x20)
                {
                    // supports 640x480 @ 60Hz
                    *maxRefreshRate = 60;
                }
            }
            break;
        case 800:
            if (vRes == 600)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x40)
                {
                    // Supports 800x600 @ 75Hz.
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x80)
                {
                    // supports 800x600 @ 72Hz
                    *maxRefreshRate = 72;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x01)
                {
                    // supports 800x600 @ 60Hz
                    *maxRefreshRate = 60;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x02)
                {
                    // supports 800x600 @ 56Hz
                    *maxRefreshRate = 56;
                }
            }
            break;
        case 832:
            if (vRes == 624)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x20)
                {
                    // Supports 832x624 @ 75Hz.
                    *maxRefreshRate = 75;
                }
            }
            break;
        case 1024:
            if (vRes == 768)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x10)
                {
                    // Supports 1024x768 @ 87Hz
                    *maxRefreshRate = 87;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x02)
                {
                    // supports 1024x768 @ 75Hz
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x04)
                {
                    // supports 1024x768 @ 70Hz
                    *maxRefreshRate = 70;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x08)
                {
                    // supports 1024x768 @ 60Hz
                    *maxRefreshRate = 60;
                }
            }
            break;
        case 1280:
            if (vRes == 1024)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x01)
                {
                    // Supports 1280x1024 @ 75Hz
                    *maxRefreshRate = 75;
                }
            }
            break;
        case 1152:
            if (vRes == 870)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_3_INDEX] & 0x80)
                {
                    // Supports 1152x870 @ 75Hz 
                    *maxRefreshRate = 75;
                }
            }
            break;
        default:
            break;
    } // switch on hRes


    // Now check the standard timings to see if there is a higher refresh rate specified.
   	for (i = 0; i < 8; i++)
	{
		if (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i * 2)] != 0x01)
		{
			// there is a standard timing specification.
			tmpHRes = (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2)] + 31) * 8;
			tmpRefresh = (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2) + 1] & 0x3f) + 60;
			switch ((edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2) + 1] & 0xc0) >> 6)
			{
			case 0x0:
				// aspect ratio 1:1
				tmpVRes = tmpHRes;
				break;
			case 0x1:
				// aspect ratio 4:3
				tmpVRes = (tmpHRes * 3) / 4;
				break;
			case 0x2:
				// aspect ratio 5:4
				tmpVRes = (tmpHRes * 4) / 5;
				break;
			case 0x3:
				// aspect ratio 16:9
				tmpVRes = (tmpHRes * 9) / 16;
				break;
			}

            // Check if this standard timing matches the resolution we want.
            if (tmpHRes == hRes && tmpVRes == vRes)
            {
                // Resolution matches. 
                // If this refresh rate is > than the one found in established timings, use it.
                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            }
		} // A valid standard timing spec
	} // iterate over all 8 standard timings

    // Now check the detailed timing specification for a macting resolution.
	for (i = 0; i < 4; i++)
	{
		int startIndex = EDID_V1_DETAILED_TIMINGS_START_INDEX + (i * EDID_V1_DETAILED_TIMINGS_SIZE);
		if (edid[startIndex] == 0 && edid[startIndex + 1] == 0)
		{
			// This is a Monitor descriptor instead of a detailed timing descriptor.
			switch (edid[startIndex + 3])
			{
                case 0xFA:
                    // Descriptor contains 6 additional standard timing identifications
                    for (j = 0; j < 6; j++)
                    {
                        if (edid[startIndex + 5 + (j * 2)] != 0x01)
                        {
                            // there is a standard timing specification.
                            tmpHRes = (edid[startIndex + 5 + (j*2)] + 31) * 8;
                            tmpRefresh = (edid[startIndex + 5 + (j*2) + 1] & 0x3f) + 60;
                            switch ((edid[startIndex + 5 + (j*2) + 1] & 0xc0) >> 6)
                            {
                            case 0x0:
                                // aspect ratio 1:1
                                tmpVRes = tmpHRes;
                                break;
                            case 0x1:
                                // aspect ratio 4:3
                                tmpVRes = (tmpHRes * 3) / 4;
                                break;
                            case 0x2:
                                // aspect ratio 5:4
                                tmpVRes = (tmpHRes * 4) / 5;
                                break;
                            case 0x3:
                                // aspect ratio 16:9
                                tmpVRes = (tmpHRes * 9) / 16;
                                break;
                            } // switch on aspect ratio

                            // Check if this standard timing matches the resolution we want.
                            if (tmpHRes == hRes && tmpVRes == vRes)
                            {
                                // Resolution matches. 
                                // If this refresh rate is > than the one found in established timings, use it.
                                if (tmpRefresh > *maxRefreshRate)
                                {
                                    *maxRefreshRate = tmpRefresh;
                                }
                            }
                        } // a valid standard timing spec
                    } // iterate over the 6 additional standard timings
                    break;
                default:
                    break;
			}
		} // monitor descriptor.
		else
		{
			// This is a detailed timing descriptor.
            // The detailed timing specification does not include the refresh rate.
			U032 pixelClock;
			U032 hActive, vActive, hBlank, vBlank;
			U032 hTotal, vTotal;


			hActive = edid[startIndex + 2] | ((edid[startIndex + 4] & 0xf0) << 4);
			vActive = edid[startIndex + 5] | ((edid[startIndex + 7] & 0xf0) << 4);
            if (hActive == hRes && vActive == vRes)
            {
                // Resolution matches the detailed spec.
                // Get the rest of the detailed timing info needed to calculate the refresh rate.
                pixelClock = edid[startIndex] | (edid[startIndex + 1] << 8);
                hBlank  = edid[startIndex + 3] | ((edid[startIndex + 4] & 0x0f) << 8);
                vBlank  = edid[startIndex + 6] | ((edid[startIndex + 7] & 0x0f) << 8);

                // Horizontal Total (hActive + hBlank) gives # of pixels / line
                // Vertical total (vActive + vBlank) gives # of lines / frame
                // so HT * VT = total # pixels per frame.
                // Pixel clock is # pixels drawn / sec
                // so pixelClock / (HT * VT) gives the refresh rate (frames / sec).
                hTotal = hActive + hBlank;
                vTotal = vActive + vBlank;
                pixelClock = pixelClock * 10000;
                tmpRefresh = pixelClock / (hTotal * vTotal);

                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            } // resolution matches the detailed spec
		} // This is a detailed timing spec
	} // parse detailed section

    return RM_OK;
}

static RM_STATUS EDIDV2GetMaxRefreshRate
(
    PHWINFO pDev,
    U008   *edid,
    U032    hRes,
    U032    vRes,
    U032   *maxRefreshRate
)
{
    U032 lumTabSize, numLumTables;
    U032 numFreqRanges, numDetailedRanges, numTimingCodes, numDetailedTimings;
    U032 detailedTimingIndex, timingCodesIndex;
    U008 timingMap1, timingMap2;
    U032 index, i;

    // We need to look in the 4-byte timing codes section and the detailed timing section for
    // the given resolution.

    // The way the 127 byte detailed information is used is given by reading bytes 0x7e and 0x7f.
    // The size and the order of the 127 byte timing section that start at byte 0x80 is:
    // x*A + 8*B + 27*c + 4*D + 18*E where
    // A = number of luminance tables (0 or 1), (given by byte 0x7e bit 5)
    // x = size of the luminance table (given by the first byte of the table itself)
    // B = number of frequency rages listed (0-7), (given by bits 4-2 of byte 0x7e)
    // C = number of detailed rage limits (0-3), (given by (bits 1-0 of byte 0x7e)
    // D = number of timing codes (0-31), (given by bits 7-3 of byte 0x7f)
    // E = number of detailed timing descriptions (0-7) (given by bits 2-0 of byte 0x7f)
    timingMap1 = edid[EDID_V2_TIMING_MAP1_INDEX];
    timingMap2 = edid[EDID_V2_TIMING_MAP2_INDEX];
    numLumTables       = (timingMap1 & 0x20) >> 5; // Bit 5
    numFreqRanges      = (timingMap1 & 0x1C) >> 2; // Bits 4-2
    numDetailedRanges  = (timingMap1 & 0x03);      // Bits 1-0
    numTimingCodes     = (timingMap2 & 0xf8) >> 3; // Bits 7-3
    numDetailedTimings = (timingMap2 & 0x07);      // Bits 2-0
    if (numLumTables != 0)
    {
        // Calculate the size of the lum table by reading byte 0x80
        U032 numLumValues;

        numLumValues = edid[EDID_V2_TIMING_SECTION_START_INDEX] & 0x1f; // bits 4-0
        if (edid[EDID_V2_TIMING_SECTION_START_INDEX] & 0x80)
        {
            // size of lum table is ((3 * numLumValues) + 1) bytes
            lumTabSize = 3 * numLumValues + 1;
        }
        else
        {
            // size of lum table is (numLumValues + 1) bytes
            lumTabSize = numLumValues + 1;
        }
    }
    else
        lumTabSize = 0;

    timingCodesIndex = EDID_V2_TIMING_SECTION_START_INDEX 
                       + lumTabSize 
                       + (8 * numFreqRanges)
                       + (27 * numDetailedRanges);
    detailedTimingIndex = timingCodesIndex + (8 * numTimingCodes);

    *maxRefreshRate = 0;

    {
        // Look in the timing codes section.
        U032 hActive;
        U032 aspectRatio;
        U032 vActive;
        for (i = 0; i < numTimingCodes; i++)
        {
            index = timingCodesIndex + (4 * i);
            hActive = (edid[index] * 16) + 256;
            aspectRatio = edid[index + 2];
            // Aspect ratio is stored in terms of N:100.
			// This is not very useful because we don't get the standard vertical values.
			// So we will use the standard aspect ratios whenever we can.
			switch (aspectRatio)
			{
			case 133:
				// 4:3
				vActive = (hActive * 3) / 4;
				break;
			case 125:
				// 5:4
				vActive = (hActive * 4) / 5;
				break;
			case 177:
				// 16:9
				vActive = (hActive * 9) / 16;
				break;
			default:
                vActive = (hActive * 100) / aspectRatio;
				break;
			}
            if (hActive == hRes && vActive == vRes)
            {
                // This is the needed resolution.
                if (edid[index + 3] > *maxRefreshRate)
                {
                    *maxRefreshRate = edid[index + 3];
                }
            } // resolution matches
        } // loop over all the timing codes
    } // look in timing codes

    {
        // look in the detailed timing section
        // The detailed timing specification does not include the refresh rate.
        U032 pixelClock;
        U032 hActive, vActive, hBlank, vBlank;
        U032 hTotal, vTotal;
        U032 tmpRefresh;

        for (i = 0; i < numDetailedTimings; i++)
        {
            index = detailedTimingIndex + (18 * i);
            hActive = edid[index + 2] | ((edid[index + 4] & 0xf0) << 4);
            vActive = edid[index + 5] | ((edid[index + 7] & 0xf0) << 4);
            if (hActive == hRes && vActive == vRes)
            {
                // Resolution matches the detailed spec.
                // Get the rest of the detailed timing info needed to calculate the refresh rate.
                pixelClock = edid[index] | (edid[index + 1] << 8);
                hBlank  = edid[index + 3] | ((edid[index + 4] & 0x0f) << 8);
                vBlank  = edid[index + 6] | ((edid[index + 7] & 0x0f) << 8);

                // Horizontal Total (hActive + hBlank) gives # of pixels / line
                // Vertical total (vActive + vBlank) gives # of lines / frame
                // so HT * VT = total # pixels per frame.
                // Pixel clock is # pixels drawn / sec
                // so pixelClock / (HT * VT) gives the refresh rate (frames / sec).
                hTotal = hActive + hBlank;
                vTotal = vActive + vBlank;
                pixelClock = pixelClock * 10000;
                tmpRefresh = pixelClock / (hTotal * vTotal);

                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            } // resolution matches the detailed spec
        } // loop over all the detailed timing specs
    } // look in detailed timing section

    return RM_OK;
}
#endif  // #if 0; no one calling this puppy


// EDID Version 1.3
// Super set of 1.2, allows range limits descriptor to define coeficients for secondary GTF curve,
// and mandates a certain set of monitor descriptors.
RM_STATUS ParseEDID13(PHWINFO pDev, U032 Head)
{
	return ParseEDID11(pDev, Head);	// we can probably treat it the same as rev 1.1
}

// EDID Version 1.2
RM_STATUS ParseEDID12(PHWINFO pDev, U032 Head)
{
	return ParseEDID11(pDev, Head);	// we can probably treat it the same as rev 1.1
}

//	Parse a detailed timing block in the current EDID
//	The EDID has been saved in the global device data structure (nvInfo).
//	When native mode is requested, it is necessary to find the correct detailed timing;
//  otherwise fpParseEDID will be used to get timing info.
U032 edidParseDetailedTimingBlock(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
	switch (pDev->Dac.CrtcInfo[Head].EdidVersion)
	{
		case EDID_VERSION_10:
		case EDID_VERSION_11:
		case EDID_VERSION_12:
		case EDID_VERSION_13:
			return edidParseDetailed1(pDev, block, fpTim, Head);
		case EDID_VERSION_20:
			return edidParseDetailed2(pDev, block, fpTim, Head);
	}

	return(0);
}

//	Parse a specific detailed timing block for EDID version 1.x
//  Detailed timings are at a fixed offset from the start of the buffer.
U032 edidParseDetailed1(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;

		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block);
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0xf) | (SyncOvf & 0x30)<<4;

			// Return this resolution
			fpTim->PixClk = pClk;
			fpTim->HActive = HRes;
 			fpTim->HDispEnd = HRes - 1;
			fpTim->HValidEnd = HRes - 1;
	 		fpTim->HSyncStart = HSyncOffset + fpTim->HDispEnd;
 			fpTim->HSyncEnd = HSyncPulse + fpTim->HSyncStart;
 			fpTim->HValidStart = 0;
	 		fpTim->HTotal = HTotal;
				
	 		fpTim->VActive = VRes;
 			fpTim->VDispEnd = VRes - 1;
 			fpTim->VValidEnd = VRes - 1;
	 		fpTim->VSyncStart =  VSyncOffset + fpTim->VDispEnd;
	 		fpTim->VSyncEnd = VSyncPulse + fpTim->VSyncStart;
 			fpTim->VValidStart = 0;
 			fpTim->VTotal = VTotal;
			fpTim->Flags = Flags;	// includes sync polarities
			return TRUE;
		}
		return FALSE;
} // edidParseDetailedTimingBlock

// Parse detailed timings for EDID Version 2.x
// This gets a specific timing block.
// For version 2, we have to parse from the start to find the location of the block.
U032 edidParseDetailed2(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
U008	map1, map2, index, lum, rangeLimits, detailedRangeLimits;
U008	detailedTimings, timingCodes, timingCode[4];
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags, i;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;

	map1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX];
	map2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX+1];
	index =  EDID_V2_TIMING_SECTION_START_INDEX;
	// if there is a lum table, bump index beyond
	if (map1 & EDID_V2_LUM_TABLE_EXIST)
	{
		// 1st byte in timing section gives # of bytes in lum table
		lum = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_SECTION_START_INDEX];
		if (lum & TRIPLE_LUM_ENTRIES)
			index += (lum & NUM_LUM_ENTRIES*3) + 1;
		else
			index += (lum & NUM_LUM_ENTRIES) + 1;
	}
	// if there are timing range limits, bump index
	if ((rangeLimits = (map1 & EDID_V2_FREQ_RANGES)>>EDID_V2_FREQ_RANGE_SHIFT))
		index += rangeLimits * 8;
	// if there are detailed range limits, bump index
	if ((detailedRangeLimits = map1 & EDID_V2_DETAILED_RANGE_LIMITS))
		index += detailedRangeLimits * 27;
	// if there are timing codes, save them
	if ((timingCodes = (map2 & EDID_V2_TIMING_CODES)>>EDID_V2_TIMING_CODES_SHIFT))
		for (i=0; i!=timingCodes; i++)
		{
			timingCode[i] = pDev->Dac.CrtcInfo[Head].EDID[index];
			timingCode[i+1] = pDev->Dac.CrtcInfo[Head].EDID[index+1];
			timingCode[i+2] = pDev->Dac.CrtcInfo[Head].EDID[index+2];
			timingCode[i+3] = pDev->Dac.CrtcInfo[Head].EDID[index+3];
			index += 4;
		}
	// now index points to the detailed timings (if present)
	if ((detailedTimings = (map2 & EDID_V2_DETAILED_TIMINGS)))
	{
		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = index + 18 * block;
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;

			// Return this resolution
			fpTim->PixClk = pClk;
			fpTim->HActive = HRes;
	 		fpTim->HDispEnd = HRes - 1;
			fpTim->HValidEnd = HRes - 1;
	 		fpTim->HSyncStart = HSyncOffset + fpTim->HDispEnd;
	 		fpTim->HSyncEnd = HSyncPulse + fpTim->HSyncStart;
	 		fpTim->HValidStart = 0;
	 		fpTim->HTotal = HTotal;
				
	 		fpTim->VActive = VRes;
	 		fpTim->VDispEnd = VRes - 1;
	 		fpTim->VValidEnd = VRes - 1;
	 		fpTim->VSyncStart =  VSyncOffset + fpTim->VDispEnd;
	 		fpTim->VSyncEnd = VSyncPulse + fpTim->VSyncStart;
	 		fpTim->VValidStart = 0;
	 		fpTim->VTotal = VTotal;

			fpTim->Flags = Flags;
			return RM_OK;
		} // if 
	} // if detailed timings
	// check 4 byte timing codes

	return RM_ERROR;	// not supported yet
}

// EDID Version 2.0 
// Get flat panel timing from 4 byte timing code
// Use VESA GTF timing.
RM_STATUS GetTimingFromCode(U008 code, PDACFPTIMING fpTim)
{
U016	HorizCode;

	// We should be able to determine the mode from the first byte only, UNLESS
	// we start seeing panels with variable refresh rates.
	// byte 1: active pixels/line (pixels - 256)/16. Range = 256-4336.
	// byte 2: arcane info, don't know what it means. See EDID standard.
	// byte 3: aspect ration H:V.
	// byte 4: refresh rate.
	HorizCode = code * 16 + 256;
	fpTim->Flags = 0;	// sync polarities: neg, neg
	switch (HorizCode)
	{
		case 1280:
			// 1280x1024x75;
			fpTim->HActive = 1280;
			fpTim->HDispEnd = 1279;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 1279;
			fpTim->HSyncStart = 1280+15;
			fpTim->HSyncEnd = 1280+15+2;
			fpTim->HTotal = 1280+320;
			fpTim->VActive = 1024;
			fpTim->VDispEnd = 1023;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd = 1023;
			fpTim->VSyncStart = 1023+2;
			fpTim->VSyncEnd = 1023+2+24;
			fpTim->VTotal = 1024+40;
			fpTim->PixClk = 10800;	// 108 MHz
			fpTim->Flags = VSYNC_POS | HSYNC_POS;

			break;
		case 1024:
			fpTim->HActive = 1024;
			fpTim->HDispEnd = 1023;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 1023;
			fpTim->HSyncStart = 1040;
			fpTim->HSyncEnd = 1089;
			fpTim->HTotal = 1344;
			fpTim->VActive = 768;
			fpTim->VDispEnd = 767;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd = 767;
			fpTim->VSyncStart = 770;
			fpTim->VSyncEnd = 776;
			fpTim->VTotal = 805;
			fpTim->PixClk = 6500;	// 65 MHz
			fpTim->Flags = VSYNC_NEG | HSYNC_NEG;
			break;
		case 800:
			fpTim->HActive =  800;
			fpTim->HDispEnd = 799;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 799;
			fpTim->HSyncStart = 799+16;
			fpTim->HSyncEnd =  799+16+24;
			fpTim->HTotal = 800+320;
			fpTim->VActive = 600;
			fpTim->VDispEnd = 599;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd =  599;
			fpTim->VSyncStart = 599+2;
			fpTim->VSyncEnd = 599+2+24;
			fpTim->VTotal = 600+38;
			fpTim->PixClk = 4000;	// 40 MHz
			fpTim->Flags = VSYNC_POS | HSYNC_POS;
			break;
		default:
			return RM_ERROR;
	}
	return RM_OK;
}
							
// EDID Version 1.1
// Return error if no valid resolution found
RM_STATUS ParseEDID11(PHWINFO pDev, U032 Head)
{
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;
U008	est_tim1, est_tim2, block, offset, mode_count;
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags;
U032	est_tim_total, i;

	// Look for multiple resolutions in established timings to see if it supports native mode.
	// meaning the monitor can do the scaling.
 	est_tim1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_1_INDEX];
 	est_tim2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_2_INDEX];
	est_tim_total = est_tim1 | (est_tim2<<8);
	mode_count = 0;
	pDev->Dac.fpNative = 0;
	for (i=1; i<0x10000; i<<=1)
		if (est_tim_total & i)
			mode_count++;
	if (mode_count > 1)	// if more than 1 mode, monitor supports native mode.
		pDev->Dac.fpNative = 1;

	// We'll check detailed timings first. If none, look for established timings.
	// Search for largest resolution. 
	// NEED TO ADD: There could be extensions in next EDID block, too.
	pDev->Dac.fpHActive = 0;
	mode_count = 0; // check again--multiple detailed timing block also indicates native
	for (block = 0; block <4; block++)
	{
		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block);
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;
#if 0
			// Do some error checking
			if ((HRes + HSyncOffset + HSyncPulse) > (HTotal))
			{
				HSyncPulse &= 0x0f;		// pulse is too wide
				if (HSyncPulse == 0)
					HSyncPulse = 24;		// should work
			}
			if ((VRes + VSyncOffset + VSyncPulse) > (VTotal))
			{
				HSyncPulse &= 0x0f;		// pulse is too wide
				if (VSyncPulse == 0)
					VSyncPulse = 24;		// should work
			}
#endif
			if (HRes > pDev->Dac.fpHActive)	// largest yet?
			{
				// Does this fp support native mode?
				mode_count++;	
				if (mode_count > 1)
					pDev->Dac.fpNative = 1;	
				// Save this resolution as potential maximum.
				pDev->Dac.fpPixClk = pClk;
				pDev->Dac.fpHActive = HRes;
		 		pDev->Dac.fpHDispEnd = HRes - 1;
				pDev->Dac.fpHValidEnd = HRes - 1;
		 		pDev->Dac.fpHSyncStart = HSyncOffset + pDev->Dac.fpHDispEnd;
		 		pDev->Dac.fpHSyncEnd = HSyncPulse + pDev->Dac.fpHSyncStart;
		 		pDev->Dac.fpHValidStart = 0;
		 		pDev->Dac.fpHTotal = HTotal;
					
		 		pDev->Dac.fpVActive = VRes;
		 		pDev->Dac.fpVDispEnd = VRes - 1;
		 		pDev->Dac.fpVValidEnd = VRes - 1;
		 		pDev->Dac.fpVSyncStart =  VSyncOffset + pDev->Dac.fpVDispEnd;
		 		pDev->Dac.fpVSyncEnd = VSyncPulse + pDev->Dac.fpVSyncStart;
		 		pDev->Dac.fpVValidStart = 0;
		 		pDev->Dac.fpVTotal = VTotal;
				pDev->Dac.fpFlags = Flags;

			}
		}
	}
	// save the max resolution this fp supports 
	pDev->Dac.HalInfo.fpHMax = pDev->Dac.fpHActive;
	pDev->Dac.HalInfo.fpVMax = pDev->Dac.fpVActive;

	// If we found a valid detailed timing descriptor, use it.
	if (pDev->Dac.fpHActive)
		return RM_OK;

	// Check the "established timings" and if more than one, pick the highest.
	// There are currently no flat panels supporting refresh other than 60 Hz, so 
	// treat timings with different refresh but the same resolution as the same.
	if(est_tim1 & 0x3c)
 	{
		pDev->Dac.fpHActive = 0;	// no 640 panels. Return error unless we find higher res.
	}
	if(est_tim1 & 0x03)
	{
		// 800x600 60
		pDev->Dac.fpHActive =  800;
		pDev->Dac.fpHDispEnd = 799;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 799;
		pDev->Dac.fpHSyncStart = 799+16;
		pDev->Dac.fpHSyncEnd =  799+16+24;
		pDev->Dac.fpHTotal = 800+320;
		pDev->Dac.fpVActive = 600;
		pDev->Dac.fpVDispEnd = 599;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd =  599;
		pDev->Dac.fpVSyncStart = 599+2;
		pDev->Dac.fpVSyncEnd = 599+2+24;
		pDev->Dac.fpVTotal = 600+38;
		pDev->Dac.fpPixClk = 4000;	// 40 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}

	// established timing 2 should take precedence over 1, since it has higher resolutions
	if(est_tim2 & 0xc0)
 	{
		// 800x600 60
		pDev->Dac.fpHActive =  800;
		pDev->Dac.fpHDispEnd = 799;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 799;
		pDev->Dac.fpHSyncStart = 799+16;
		pDev->Dac.fpHSyncEnd =  799+16+24;
		pDev->Dac.fpHTotal = 800+320;
		pDev->Dac.fpVActive = 600;
		pDev->Dac.fpVDispEnd = 599;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd =  599;
		pDev->Dac.fpVSyncStart = 599+2;
		pDev->Dac.fpVSyncEnd = 599+2+24;
		pDev->Dac.fpVTotal = 600+38;
		pDev->Dac.fpPixClk = 4000;	// 40 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}
	if(est_tim2 & 0x1e)	// lumping together 60Hz, 70 Hz, 75 Hz, and 87 Hz under the assumption
						// that DFP's which support > 60 Hz (if any) will have detailed timings.
	{
		// 1024x768x60;
		pDev->Dac.fpHActive = 1024;
		pDev->Dac.fpHDispEnd = 1023;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 1023;
		pDev->Dac.fpHSyncStart = 1040;
		pDev->Dac.fpHSyncEnd = 1089;
		pDev->Dac.fpHTotal = 1344;
		pDev->Dac.fpVActive = 768;
		pDev->Dac.fpVDispEnd = 767;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd = 767;
		pDev->Dac.fpVSyncStart = 770;
		pDev->Dac.fpVSyncEnd = 776;
		pDev->Dac.fpVTotal = 805;
		pDev->Dac.fpPixClk = 6500;	// 65 MHz
		pDev->Dac.fpFlags = VSYNC_NEG | HSYNC_NEG;
	}
	if(est_tim2 & 0x01)
	{
		// 1280x1024x75;
		pDev->Dac.fpHActive = 1280;
		pDev->Dac.fpHDispEnd = 1279;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 1279;
		pDev->Dac.fpHSyncStart = 1280+15;
		pDev->Dac.fpHSyncEnd = 1280+15+2;
		pDev->Dac.fpHTotal = 1280+320;
		pDev->Dac.fpVActive = 1024;
		pDev->Dac.fpVDispEnd = 1023;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd = 1023;
		pDev->Dac.fpVSyncStart = 1023+2;
		pDev->Dac.fpVSyncEnd = 1023+2+24;
		pDev->Dac.fpVTotal = 1024+40;
		pDev->Dac.fpPixClk = 10800;	// 108 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}

	if (pDev->Dac.fpHActive)
	{
		// save the max resolution this fp supports 
		pDev->Dac.HalInfo.fpHMax = pDev->Dac.fpHActive;
		pDev->Dac.HalInfo.fpVMax = pDev->Dac.fpVActive;
		return RM_OK;
	}
	else
		return RM_ERROR;
 }

// EDID Version 2.x
// The first 128 bytes is not very interesting to us (I think), except the last 2 bytes,
// which are the map into second 128 bytes, which contain the luminance table and 
// timing descriptions.
// In order to get to the detailed timings, we have to parse thru the lum table, frequency
// ranges, detailed range limits, and timing codes. These are optional fields, so nothing is
// found at a fixed offset. The map bytes tell whether the fields are present.
RM_STATUS ParseEDID2(PHWINFO pDev, U032 Head)
{
RM_STATUS status;
U008	map1, map2, index, lum, rangeLimits, detailedRangeLimits;
U008	detailedTimings, block, timingCodes;
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags, i;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;
U008    mode_count = 0;
U008	timingCode[4*31];
DACFPTIMING fpTim;

	map1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX];
	map2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX+1];
	index =  EDID_V2_TIMING_SECTION_START_INDEX;
	// if there is a lum table, bump index beyond
	if (map1 & EDID_V2_LUM_TABLE_EXIST)
	{
		// 1st byte in timing section gives # of bytes in lum table
		lum = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_SECTION_START_INDEX];
		if (lum & TRIPLE_LUM_ENTRIES)
			index += ((lum & NUM_LUM_ENTRIES)*3) + 1;
		else
			index += (lum & NUM_LUM_ENTRIES) + 1;
	}
	// if there are timing range limits, bump index
	if ((rangeLimits = (map1 & EDID_V2_FREQ_RANGES)>>EDID_V2_FREQ_RANGE_SHIFT))
		index += rangeLimits * 8;
	// if there are detailed range limits, bump index
	if ((detailedRangeLimits = map1 & EDID_V2_DETAILED_RANGE_LIMITS))
		index += detailedRangeLimits * 27;
	// if there are timing codes, save them
	if ((timingCodes = (map2 & EDID_V2_TIMING_CODES)>>EDID_V2_TIMING_CODES_SHIFT))
		for (i=0; i!=timingCodes; i++)
		{
			timingCode[i] = pDev->Dac.CrtcInfo[Head].EDID[index];
			timingCode[i+1] = pDev->Dac.CrtcInfo[Head].EDID[index+1];
			timingCode[i+2] = pDev->Dac.CrtcInfo[Head].EDID[index+2];
			timingCode[i+3] = pDev->Dac.CrtcInfo[Head].EDID[index+3];
			index += 4;
		}
	// now index points to the detailed timings (if present)
	if ((detailedTimings = (map2 & EDID_V2_DETAILED_TIMINGS)))
	{
		for (block = 0; block < detailedTimings; block++)
		{
			// A detailed timing block is 27 bytes
			// There can be up to 7 detailed timing blocks, immediately following the timing codes
			pClk = pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block];
			pClk |= (pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block + 1])<<8;
			if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
			{
				// Does this fp support native mode?
				// Another way to check would be to see if detailedTimings > 1,
				// but what if we find multiple detailed timings for the same resolution?
				mode_count++;	
				if (mode_count > 1)
					pDev->Dac.fpNative = 1;	

				// Seems valid, get info
				offset = index + 18 * block;
				HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
				HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
				HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
				VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
				VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
				VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
				HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
				HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
				VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
				SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
				Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

				// Get timing into useful format
				HRes = HActive1 | (HActive2 & 0xf0)<<4;
				VRes = VActive1 | (VActive2 & 0xf0)<<4;
				HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
				VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
				HTotal = HRes + HBlank;
				VTotal = VRes + VBlank;
				HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
				HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
				VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
				VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;

				if (HRes > pDev->Dac.fpHActive)	// largest yet?
				{
					// Return this resolution
					pDev->Dac.fpPixClk = pClk;
					pDev->Dac.fpHActive = HRes;
	 				pDev->Dac.fpHDispEnd = HRes - 1;
					pDev->Dac.fpHValidEnd = HRes - 1;
			 		pDev->Dac.fpHSyncStart = HSyncOffset + pDev->Dac.fpHDispEnd;
			 		pDev->Dac.fpHSyncEnd = HSyncPulse + pDev->Dac.fpHSyncStart;
	 				pDev->Dac.fpHValidStart = 0;
	 				pDev->Dac.fpHTotal = HTotal;
				
		 			pDev->Dac.fpVActive = VRes;
			 		pDev->Dac.fpVDispEnd = VRes - 1;
		 			pDev->Dac.fpVValidEnd = VRes - 1;
	 				pDev->Dac.fpVSyncStart =  VSyncOffset + pDev->Dac.fpVDispEnd;
		 			pDev->Dac.fpVSyncEnd = VSyncPulse + pDev->Dac.fpVSyncStart;
		 			pDev->Dac.fpVValidStart = 0;
		 			pDev->Dac.fpVTotal = VTotal;
	
					// save the max resolution this fp supports 
					pDev->Dac.HalInfo.fpHMax = pDev->Dac.fpHActive;
					pDev->Dac.HalInfo.fpVMax = pDev->Dac.fpVActive;
					pDev->Dac.fpFlags = Flags;
				}
			} // if 
		} // for
		return RM_OK;
	} // if detailed timings

	// If no detailed timings, check 4 byte timing codes
	// byte 1: active pixels/line (pixels - 256)/16. Range = 256-4336.
	// byte 2: arcane info, don't know what it means. See EDID standard.
	// byte 3: aspect ration H:V.
	// byte 4: refresh rate.
	pDev->Dac.fpHActive = 0;
	mode_count = 0;
	for (i=0; i < timingCodes; i++)	// search all codes for max res
	{
            status =  GetTimingFromCode(timingCode[i*4], &fpTim);		
            if (status == RM_OK)
            {
                if (fpTim.HActive > pDev->Dac.fpHActive) // new max?
                {
                    mode_count++;
                    pDev->Dac.fpPixClk = fpTim.PixClk;
                    pDev->Dac.fpHActive = fpTim.HActive;
                    pDev->Dac.fpHDispEnd = fpTim.HDispEnd;
                    pDev->Dac.fpHValidEnd = fpTim.HValidEnd;
                    pDev->Dac.fpHSyncStart = fpTim.HSyncStart;
                    pDev->Dac.fpHSyncEnd = fpTim.HSyncEnd;
                    pDev->Dac.fpHValidStart = fpTim.HValidStart;
                    pDev->Dac.fpHTotal = fpTim.HTotal;
                    
                    pDev->Dac.fpVActive = fpTim.VActive;
                    pDev->Dac.fpVDispEnd = fpTim.VDispEnd;
                    pDev->Dac.fpVValidEnd = fpTim.VValidEnd;
                    pDev->Dac.fpVSyncStart = fpTim.VSyncStart;
                    pDev->Dac.fpVSyncEnd = fpTim.VSyncEnd;
                    pDev->Dac.fpVValidStart = fpTim.VValidStart;
                    pDev->Dac.fpVTotal = fpTim.VTotal;
                    pDev->Dac.fpFlags = fpTim.Flags;
                    pDev->Dac.HalInfo.fpHMax = pDev->Dac.fpHActive;
                    pDev->Dac.HalInfo.fpVMax = pDev->Dac.fpVActive;
                }
            }
	}
	if (pDev->Dac.fpHActive)	// if we found a mode
	{
            if (mode_count > 1)
                pDev->Dac.fpNative = 1;	
            return RM_OK;
	}
	return RM_ERROR;
}

// Parse the EDID buffer (read earlier) to determine if we have valid timings.
// 
RM_STATUS fpParseEDID(PHWINFO pDev, U032 Head)
{
U032 status = RM_ERROR;	
// The EDID may contain "established timings", a bit map of flags showing supported 
// resolutions, or "standard timings", a 2-byte description of horizontal res + aspect ratio,
// or "detailed timings", an 18-byte description.
// Version 1.x EDID starts with an 8-byte header: 00 FF FF FF FF FF FF 00.
    if (pDev->Dac.CrtcInfo[Head].EDID[0] == 0)
        if (pDev->Dac.CrtcInfo[Head].EDID[1] == 0xFF)
            if (pDev->Dac.CrtcInfo[Head].EDID[7] == 0)
            {
                // Version 1 header
                if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 1)
                {
                    switch (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_REVISION_NUMBER_INDEX]) 
                    {
                        case 0:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_10;
                            status = ParseEDID11(pDev, Head);	// Version 1.0 just like 1.1
                            break;
                        case 1:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_11;
                            status = ParseEDID11(pDev, Head);	// Version 1.1
                            break;
                        case 2:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_12;
                            status = ParseEDID12(pDev, Head);
                            break;
                        case 3:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_13;
                            status = ParseEDID13(pDev, Head);
                            break;
                        default:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_14; // This doesn't currently exist, but just in case
                            status = ParseEDID13(pDev, Head);
                            break;
                    }

                    // Is this is a digital device or analog?
                    if (!(pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7)))
                        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_MONITOR;    
                    else    
                        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;    
                    return status;	

                }
                else // Version 1 header, but not version 1 ID?
                {
                    return RM_ERROR;
                }
            }
	// Does not have version 1 header, check version 2
    if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0)
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_MONITOR;    
        return RM_ERROR; // its a CRT	
    }
    else    
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;    
    }
    pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_20;
    return	ParseEDID2(pDev, Head);
}

BOOL edidIsAnalogDisplay(PHWINFO pDev, U032 Head) 
{
U032 version;

 	version = edidGetVersion(pDev, Head);
	if (version == 1)
	{
		// Verify this is an analog device
		if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))
			return FALSE; // 1=digital
		else
			return TRUE;
	}
	if (version == 2)
		if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0)
			return TRUE;
	return FALSE;
}

BOOL edidIsDigitalDisplay(PHWINFO pDev, U032 Head) 
{
U032 version;

 	version = edidGetVersion(pDev, Head);
	if (version == 1)
	{
		// Verify this is an analog device
		if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))
			return TRUE;
		else
            return FALSE; // 1=digital
	}
	if (version == 2)
		if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) != 0)
			return TRUE;
	return FALSE;
}


//
// Generate an EDID appropriate for the current mobile panel in use
//
RM_STATUS edidConstructMobileInfo
(
    PHWINFO pDev,
    U032    Head,
    U008    *pEdid
)
{

    //
    // We now support generating EDID based on BIOS table information.
    // These tables are created at initialization time.  Note that
    // sometimes EDID requests come in _before_ initDac() has been
    // called (i.e., before the BIOS-based EDID is constructed).  In
    // this case we currently fall back to the hard-coded EDIDs below.
    // These EDIDs are also used for older VBIOSes that do not have
    // the necessary table information.
    //
    // WARNING: make sure each of the EDIDs below has a unique Monitor ID
    // (Locations 0x0A and 0x0B)!!!  Otherwise Windows will not notice that
    // the EDID has changed when panels are changed.  The generated EDID
    // code uses IDs EDID[0x0A] = x000, EDID[0x0B] = strap # (range 0x00-0x1F).
    //
    U032 i, panel_strap;

    // 1024x768
    U008 dfp_edid_XGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x07, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x02 0x07
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x64, 0x19, 0x00, 0x40, 0x41, 0x00,
         0x26, 0x30, 0x18, 0x88, 0x36, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x18, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x58, 0x47, 0x41, 0x0A, 0x20, 0x20, 0x00, 0x3C
    };

    // 1024x768
    U008 dfp_edid_XGA_POS[] = {
          0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
          0x02, 0x01, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x02 0x01
          0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
          0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
          0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
          0x01, 0x01, 0x01, 0x01, 0x64, 0x19, 0x00, 0x40, 0x41, 0x00,
          0x26, 0x30, 0x18, 0x88, 0x36, 0x00, 0x2C, 0xE4, 0x10, 0x00,
          0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
          0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
          0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
          0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
          0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
          0x58, 0x47, 0x41, 0x0A, 0x20, 0x20, 0x00, 0x3C
    };

    // 1280x1024
    U008 dfp_edid_SXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x02 0x02
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x30, 0x2A, 0x00, 0x98, 0x51, 0x00,
         0x2A, 0x40, 0x30, 0x70, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x18, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x53, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xD8
    };

    // 1400x1050
    U008 dfp_edid_SXGA_PLUS[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x03, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x02 0x03
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x30, 0x2A, 0x78, 0x20, 0x51, 0x1A,
         0x10, 0x40, 0x30, 0x70, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3c, 0x3c, 0x1E,
         0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x53, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xCC
    };

    // 1600x1200
    U008 dfp_edid_UXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x03 0x00
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x48, 0x3F, 0x40, 0x30, 0x62, 0xB0,
         0x32, 0x40, 0x40, 0xC0, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3c, 0x3c, 0x1E,
         0x64, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x55, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0x99
    };

    //
    // Alternate IBM UXGA timings
    //
    U008 dfp_edid_UXGA_IBM[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x04, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x02 0x04
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0xDB, 0x33, 0x40, 0xE0, 0x60, 0xB0,
         0x0E, 0x40, 0x60, 0x10, 0xC1, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x12, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x49, 0x42, 0x4D, 0x5F, 0x55, 0x58, 0x47,
         0x41, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x00, 0xEE
    };

    //
    // Alternate Toshiba UXGA timings
    //
    U008 dfp_edid_UXGA_Toshiba[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x05, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,    //Monitor ID 0x02 0x05
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x48, 0x3F, 0x40, 0x30, 0x62, 0xB0,
         0x32, 0x40, 0x40, 0xC0, 0x23, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x12, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x54, 0x4F, 0x53, 0x48, 0x42, 0x5F, 0x55,
         0x58, 0x47, 0x41, 0x0A, 0x20, 0x20, 0x00, 0xA4,
    };

    // 2048x1536
    U008 dfp_edid_QXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x06, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x0A, 0x01, 0x02,    //Monitor ID 0x02 0x06
         0x80, 0x2A, 0x20, 0x6C, 0xEA, 0x04, 0x85, 0xA0, 0x57, 0x4A,
         0x9B, 0x26, 0x12, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x10, 0x40, 0x00, 0x60, 0x80, 0x00,
         0x13, 0x60, 0x30, 0x10, 0x11, 0x04, 0xA7, 0x3D, 0x11, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x51, 0x26, 0x46, 0x28,
         0x64, 0x18, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x51, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0x76
    };

    U008 dfp_edid_Toshiba_10x7[] = {
        //EDID provided by Toshiba's system BIOS.
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x51, 0xf3, 0x82, 0x50, 0x00, 0x00, 0x00, 0x00,    //Monitor ID 0x82 0x50
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1d, 0x16, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x64, 0x19, 0x00, 0x40, 0x41, 0x00, 0x26, 0x30, 0x18, 0x88,
        0x36, 0x00, 0x1e, 0xd7, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x54, 0x4f, 0x53,
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x0a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x72,
        0x6e, 0x61, 0x6c, 0x20, 0x31, 0x30, 0x32, 0x34, 0x78, 0x37, 0x36, 0x0a, 0x00, 0x00, 0x00, 0xfc,
        0x00, 0x38, 0x20, 0x50, 0x61, 0x6e, 0x65, 0x6c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x00, 0xe3
    };

#if 1
    //LPL: must have been a checksum error in the older EDID below -- comparing the two,
    // in addition to two swapped bytes (checksum neutral) there is a 0x00 instead of 0x08
    // at loc. 0x24.  Yet both have a checksum byte of 0xC0.  Manually verified this one.
    U008 dfp_edid_Toshiba_14x10[] = {
        0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x51, 0xF3, 0x86, 0x50, 0x00, 0x00, 0x00, 0x00, //814    //Monitor ID 0x86 0x50
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1F, 0x17, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //184
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x40, 0x31, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //147//0D8
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x30, 0x2A, 0x78, 0x20, 0x51, 0x1A, 0x10, 0x40, 0x30, 0x70, //253
        0x13, 0x00, 0x31, 0xE5, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x54, 0x4F, 0x53, //343
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x0A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x72, //43C
        0x6E, 0x61, 0x6C, 0x20, 0x31, 0x34, 0x30, 0x30, 0x78, 0x31, 0x30, 0x0A, 0x00, 0x00, 0x00, 0xFC, //3FF
        0x00, 0x35, 0x30, 0x20, 0x50, 0x61, 0x6E, 0x65, 0x6C, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x00, 0x51  //2FF = AF + 51 = 0
    };
#else
    U008 dfp_edid_Toshiba_14x10[] = {
        0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x51, 0xF3, 0x86, 0x50, 0x00, 0x00, 0x00, 0x00,     //Monitor ID 0x86 0x50
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1F, 0x17, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x90, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x2A, 0x30, 0x78, 0x20, 0x51, 0x1A, 0x10, 0x40, 0x30, 0x70, 
        0x13, 0x00, 0x31, 0xE5, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x54, 0x4F, 0x53, 
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x0A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x72, 
        0x6E, 0x61, 0x6C, 0x20, 0x31, 0x34, 0x30, 0x30, 0x78, 0x31, 0x30, 0x0A, 0x00, 0x00, 0x00, 0xFC, 
        0x00, 0x35, 0x30, 0x20, 0x50, 0x61, 0x6E, 0x65, 0x6C, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x00, 0xC0, 
    };
#endif
    U008 dfp_edid_Toshiba_16x12[] = {
        0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x51, 0xF3, 0x88, 0x50, 0x00, 0x00, 0x00, 0x00,     //Monitor ID 0x88 0x50
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1F, 0x17, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x21, 0x09, 0x81, 0x80, 0xA9, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x48, 0x3F, 0x40, 0x30, 0x62, 0xB0, 0x32, 0x40, 0x40, 0xC0,
        0x13, 0x00, 0x31, 0xE5, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x54, 0x4F, 0x53,
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x0A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x72,
        0x6E, 0x61, 0x6C, 0x20, 0x31, 0x36, 0x30, 0x30, 0x78, 0x31, 0x32, 0x0A, 0x00, 0x00, 0x00, 0xFC,
        0x00, 0x30, 0x30, 0x20, 0x50, 0x61, 0x6E, 0x65, 0x6C, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x00, 0x4F,
    };

    U008 *pBaseEdid = NULL;

    // Make sure we've read the strap value.
    dacPreInitEDID(pDev);

    panel_strap = pDev->Dac.PanelStrap;

    if (!pDev->Dac.MobileEDID[0])   //If the constructed EDID is valid
    {
        //Use a calculated EDID based on the BIOS BMP table
        pBaseEdid = pDev->Dac.MobileEDID;
    }
    else // use OEM to decide the EDID 
    {
        switch(pDev->Power.MobileOperation)
        {
            case 2: // Toshiba
            {
                //Default - use a hardwired version (not needed in 9x version, unless
                // osCallVideoBIOS fails).
                if (panel_strap == 2) 
                {
                    pBaseEdid = dfp_edid_Toshiba_10x7;
                }
                else if (panel_strap == 6)
                {
                    pBaseEdid = dfp_edid_Toshiba_16x12;
                }
                else
                {
                    pBaseEdid = dfp_edid_Toshiba_14x10;
                }
//
// When the active device is the CRT, this call takes 30 seconds to complete
// and returns an error code.
//
// Until we get this straightened out with Toshiba, just go with the fallback
// info
//
#if !defined(MACOS) && !defined(NTRM)
                {
                    RM_STATUS status;
                    U032 eax, ebx, ecx, edx;
  
                    // 
                    // We need to recover the DFP EDID from the Toshiba BIOS by running through
                    // our VESA EDID call.  Only implemented in Win9x at this point.
                    //
                    eax = 0x4F15;       // VESA EDID function
                    ebx = 0x0001;
                    ecx = Head;            // controller number
                    edx = 0;            // EDID block number
                    status = osCallVideoBIOS(pDev, &eax, &ebx, &ecx, &edx, pEdid);
                    if (status == RM_OK) pBaseEdid = NULL;  //Don't use the fallback if this call succeeded.
                }
#endif
                break;
            }
            case 3: // Quanta/E46?
            {
                //
                //
                // Quanta/E46 Strapping assignments
                //
                //                          Panel ID     Timing        
                //- XGA panels
                //    Unknown supplier       0x0          XGA (normal neg syncs)
                //    Unknown supplier       0x1          XGA (positive syncs)
                //
                //- SXGA panel
                //    Unknown supplier       0x2          SXGA
                //
                //- SXGA+ panels
                //    Unknown supplier       0x3          SXGA+
                //    Sharp 15"              0x8          SXGA+       
                //    Unknown supplier       0x7          SXGA+      
                //  
                //- UXGA panels                
                //    Unknown supplier       0x4          UXGA
                //    Unknown supplier       0xA          UXGA
                //    Unknown supplier       0xB          UXGA
                //
                //- QXGA panels
                //    Unknown supplier       0x5          QXGA
                //
                // All other panel straps default to standard XGA (neg)
                //
  
                if ((panel_strap == 0x3) || (panel_strap == 0x7) || (panel_strap == 0x8))
                {
                    pBaseEdid = dfp_edid_SXGA_PLUS;
                }
                else if (panel_strap == 0x02)
                {
                    pBaseEdid = dfp_edid_SXGA;
                }
                else if ((panel_strap == 0x04) || (panel_strap == 0x0A) || (panel_strap == 0x0B))
                {
                    pBaseEdid = dfp_edid_UXGA;
                }
                else if (panel_strap == 0x05)
                {
                    pBaseEdid = dfp_edid_QXGA;
                }
                else if (panel_strap == 0x01)
                {
                    pBaseEdid = dfp_edid_XGA_POS;
                }
                else    // assume XGA if nothing else
                {
                    pBaseEdid = dfp_edid_XGA;
                }
                break;
            }
            case 4: // Compal?
            {
                //
                // Compal Strapping assignments
                //
                //                          Panel ID     Timing        
                //
                //- SXGA+ panels
                //    Sharp 15"              0x8          SXGA+       
                //    Unknown supplier       0x7          SXGA+  
                //                           0xB          SXGA+
                //  
                // All other panel straps default to standard XGA (neg)
                //
  
                if ((panel_strap == 0x7) || (panel_strap == 0x8) || (panel_strap == 0xB))
                {
                    pBaseEdid = dfp_edid_SXGA_PLUS;
                }
                else    // assume XGA if nothing else
                {
                    pBaseEdid = dfp_edid_XGA;
                }
                break;
            }
            case 5: // Quanta Gateway?
            {
                //
                // Quanta Gateway Strapping assignments
                //
                //                          Panel ID     Timing        
                //- SXGA panel
                //    Unknown supplier       0x5          SXGA
                //
                //- SXGA+ panels
                //    Unknown supplier       0x3          SXGA+
                //    Unknown supplier       0x4          SXGA+       
                //  
                // All other panel straps default to standard XGA (neg)
                //
  
                if ((panel_strap == 0x3) || (panel_strap == 0x4))
                {
                    pBaseEdid = dfp_edid_SXGA_PLUS;
                }
                else if (panel_strap == 0x05)
                {
                    pBaseEdid = dfp_edid_SXGA;
                }
                else    // assume XGA if nothing else
                {
                    pBaseEdid = dfp_edid_XGA;
                }
                break;
            }
            default: 
            {
                //
                // Dell Strapping assignments
                //
                //- SXGA+ panels            Panel ID     Timing        
                //    Hitachi  15"           0xE          SXGA+ (pclk = 108Mhz)      
                //    Sharp 15"              0x8          SXGA+       
                //    Unknown supplier       0x2          SXGA+       
                //    Unknown supplier       0x7          SXGA+      
                //  
                //- UXGA panels                
                //    Unknown supplier       0x3          UXGA  ( pclk =162Mhz )
                //    Unknown supplier       0x4          UXGA  ( pclk =162Mhz )
                //    Unknown supplier       0x5          UXGA  ( pclk =162Mhz )
                //    Unknown supplier       0xB          UXGA  ( pclk =162Mhz )
                //
                //- QXGA panels
                //    Unknown supplier       0xA          QXGA  ( pclk =164MHz )
                //
                //
                // Strapped for UXGA???
                //
  
                if ((panel_strap == 0x03) || (panel_strap == 0x04) || (panel_strap == 0x05))
                {
                    pBaseEdid = dfp_edid_UXGA;
                }
                //
                // Strapped for alternate IBM UXGA?
                //
                else if (panel_strap == 0x0B)
                {
                    pBaseEdid = dfp_edid_UXGA_IBM;
                }
                //
                // Strapped for QXGA?
                //
                else if (panel_strap == 0x0A)
                {
                    pBaseEdid = dfp_edid_UXGA_Toshiba;
                }
                //
                // Strapped for SXGA+???
                //
                else    // assume SXGA+ if nothing else
                {
                    //pDev->Dac.CrtcInfo[Head].EDID = dfp_edid_SXGA;
                    pBaseEdid = dfp_edid_SXGA_PLUS;
                }
                break;
            }
        } // End of switch(pDev->Power.MobileOperation)
    } // end of else side of if (!pDev->Dac.MobileEDID[0])

    // load the EDID
    if (pBaseEdid)  //check if we already loaded it via an SBIOS call, otherwise...
        for (i=0;i<128;i++) pEdid[i] = pBaseEdid[i];

    return RM_OK;
}


//  Get the VESA DDC Capabilites status word
//  The lower 5 bits is a bit map of addresses at which a display will respond (A0, A2, A6);
//  bit 7 is set if there is more than one controller;
//  the upper byte is the response latency in seconds.
U032 edidGetDDCCaps
(
    PHWINFO pDev
)
{
    U008 lock, Adr = 0, Data = 0;
    U032 Caps = 0x100;  // set 1 second response (minimum)
    U032 Head, i2cPortId;
    U032 oldDDC;

    if (IsNV5orBetter(pDev)) 
    {
        Caps |= 0x80;   // multiple DDC ports
    }

    if (pDev->Power.MobileOperation) {
        Caps |= 0x02;        // fake DDC to the always attached flatpanel
    }

    if (IsNV11(pDev))
    {
        oldDDC = CurrentHeadDDC(pDev);
    }

    // Currently we can access any device from Head 0, but in the future, who knows?
    //    for (Head = 0; Head < pDev->Dac.HalInfo.NumCrtcs; Head++)   // for all heads
    for (Head = 0; Head < 1; Head++) 
    {
        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        if (IsNV11(pDev)) 
        {
           AssocDDC(pDev, Head);  // Connect the head to the I2C pins
        }
        // Try all I2c ports
        // NOTE: we have to know how many I2C ports there are--there is no define.
        for (i2cPortId = 0; i2cPortId < 3; i2cPortId++) 
        {
            // Send a byte (any data) to subaddress 0 and see if the device acks it.
            // Try all three monitor addresses
            if (!(Caps & 0x02)) // if we already set this bit, no need to do it again, as there is a noticeable delay
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data))
                    Caps |= 0x02;
            if (!(Caps & 0x08))
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR2, 1, &Adr, 0, &Data))
                    Caps |= 0x08;
            if (!(Caps & 0x10))
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR3, 1, &Adr, 0, &Data))
                    Caps |= 0x10;
        }
        RestoreLock(pDev, Head, lock);
    }

    if (IsNV11(pDev))
    {
        AssocDDC(pDev, oldDDC); //restore previous DDC owner
    }

    return Caps;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\class\nv\class.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Object Manager *****************************\
*                                                                           *
* Module: CLASS.C                                                           *
*     Object Classes are defined in this module.                            *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <vblank.h>
#include <fifo.h>
#include <dma.h>
#include <mc.h>
#include <gr.h>
#include <dac.h>
#include <tmr.h>
#include <os.h>
#include <modular.h>
#include <nv32.h>


//---------------------------------------------------------------------------
//
//  Class methods.
//
//---------------------------------------------------------------------------

METHOD NvPatchcordMethods[] =
{
    {mthdSetNotifyCtxDma,           0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107}
    //{mthdValidate,                  0x0300, 0x0303}
};
METHOD NvClassMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdCreateLegacy,              0x0300, 0x0303},
    {mthdDestroy,                   0x0304, 0x0307},
};
METHOD NvDmaFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetDmaSpecifier,           0x0300, 0x030b}
};
METHOD NvDmaToMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetDmaSpecifier,           0x0300, 0x030b}
};
METHOD NvDmaInMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetDmaSpecifier,           0x0300, 0x030b}
};
METHOD NvVideoSinkMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetVideoInput,             0x0200, 0x02ff}
};
METHOD NvVideoColormapMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetColormapCtxDma,         0x0184, 0x0187},
    {mthdSetVideoOutput,            0x0200, 0x0203},
    {mthdSetVideoInput,             0x0204, 0x0207},
    {mthdSetColormapStart,          0x0308, 0x030b},
    {mthdSetColormapLength,         0x030c, 0x030f},
    {mthdColormapDirtyStart,        0x0310, 0x0313},
    {mthdColormapDirtyLength,       0x0314, 0x0317}
};
METHOD Nv04VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class046SetNotify,             0x0104, 0x0107},
    {class046StopImage,             0x0108, 0x010f},
    {class046StopLUT,               0x0110, 0x0117},
    {class046StopCursorImage,       0x0118, 0x011f},
    {class046StopDAC,               0x0120, 0x0128},
    {class046SetNotifyCtxDma,       0x0180, 0x0183},
    {class046SetImageCtxDma,        0x0184, 0x018b},
    {class046SetLUTCtxDma,          0x018c, 0x0193},
    {class046SetCursorCtxDma,       0x0194, 0x019b},
    {class046SetPanOffset,          0x0220, 0x0223},
    {class046GetOffset,             0x02fc, 0x02ff},
    {class046SetImageValues,        0x0300, 0x030f},
    {class046SetLUTValues,          0x0310, 0x031f},
    {class046SetCursorImageValues,  0x0320, 0x032f},
    {class046SetCursorPoint,        0x0330, 0x0333},
    {class046SetDACValues,          0x0340, 0x037c}
};

METHOD Nv04VideoOverlayMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class047SetNotify,             0x0104, 0x0107},
    {class047StopOverlay,           0x0120, 0x0127},
    {class047SetNotifyCtxDma,       0x0180, 0x0183},
    {class047SetOverlayCtxDma,      0x019c, 0x01a3},
    {class047GetOffset,             0x02fc, 0x02ff},
    {class047SetOverlayValues,      0x0400, 0x04ff},
    {class047SetOverlayPointOutNow, 0x0500, 0x0503}
};

METHOD Nv05VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class049SetNotify,             0x0104, 0x0107},
    {class049StopImage,             0x0108, 0x010f},
    {class049StopLUT,               0x0110, 0x0117},
    {class049StopCursorImage,       0x0118, 0x011f},
    {class049StopDAC,               0x0120, 0x0128},
    {class049SetNotifyCtxDma,       0x0180, 0x0183},
    {class049SetImageCtxDma,        0x0184, 0x018b},
    {class049SetLUTCtxDma,          0x018c, 0x0193},
    {class049SetCursorCtxDma,       0x0194, 0x019b},
    {class049SetPanOffset,          0x0220, 0x0223},
    {class049GetOffset,             0x02fc, 0x02ff},
    {class049SetImageValues,        0x0300, 0x030f},
    {class049SetLUTValues,          0x0310, 0x031f},
    {class049SetCursorImageValues,  0x0320, 0x032f},
    {class049SetCursorPoint,        0x0330, 0x0333},
    {class049SetDACValues,          0x0340, 0x037c}
};

METHOD NvVideoFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class63SetNotify,              0x0104, 0x0107},
    {class63StopTransfer,           0x0108, 0x010b},
    {class63SetNotifyCtxDma,        0x0180, 0x0183},
    {class63SetImageCtxDma,         0x0184, 0x018b},
    {class63SetVideoOutput,         0x0200, 0x0203},
    {class63ImageScan,              0x0300, 0x0327},
    {class63GetOffsetNotify,        0x0328, 0x032f}
};
METHOD NvVideoScalerMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class64SetNotify,              0x0104, 0x0107},
    {class64SetNotifyCtxDma,        0x0180, 0x0183},
    {class64SetVideoOutput,         0x0200, 0x0203},
    {class64SetVideoInput,          0x0204, 0x0207},
    {class64SetDeltaDuDx,           0x0300, 0x0303},
    {class64SetDeltaDvDy,           0x0304, 0x0307},
    {class64SetPoint,               0x0308, 0x030b}
};
METHOD NvVideoColorKeyMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class65SetNotify,              0x0104, 0x0107},
    {class65SetNotifyCtxDma,        0x0180, 0x0183},
    {class65SetVideoOutput,         0x0200, 0x0203},
    {class65SetVideoInput,          0x0204, 0x020f},
    {class65SetColorFormat,         0x0300, 0x0303},
    {class65SetColorKey,            0x0304, 0x0307},
    {class65SetPoint,               0x0308, 0x030b},
    {class65SetSize,                0x030c, 0x030f}
};

/*
METHOD NvVideoCaptureToMemoryMethods[] =
{
    {class66SetNotifyCtxDma,        0x0100, 0x0103},
    {class66SetNotify,              0x0104, 0x0107},
    {class66StopTransfer,           0x0108, 0x010b},
    {class66SetVideoInput,          0x0200, 0x0203},
    {class66SetImageCtxDma,         0x0300, 0x0307},
    {class66SetImageNotifyCtxDma,   0x0308, 0x030f},
    {class66ImageCapture,           0x0310, 0x0337},
    {class66SetVbiCtxDma,           0x0400, 0x0407},
    {class66SetVbiNotifyCtxDma,     0x0408, 0x040f},
    {class66VbiCapture,             0x0410, 0x0437}
};
*/

METHOD Nv10VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class067SetNotify,             0x0104, 0x0107},
    {class067StopImage,             0x0108, 0x010f},
    {class067StopLUT,               0x0110, 0x0117},
    {class067StopCursorImage,       0x0118, 0x011f},
    {class067StopDAC,               0x0120, 0x0128},
    {class067SetNotifyCtxDma,       0x0180, 0x0183},
    {class067SetImageCtxDma,        0x0184, 0x018b},
    {class067SetLUTCtxDma,          0x018c, 0x0193},
    {class067SetCursorCtxDma,       0x0194, 0x019b},
    {class067SetPanOffset,          0x0220, 0x0223},
    {class067GetOffset,             0x02fc, 0x02ff},
    {class067SetImageValues,        0x0300, 0x030f},
    {class067SetLUTValues,          0x0310, 0x031f},
    {class067SetCursorImageValues,  0x0320, 0x032f},
    {class067SetCursorPoint,        0x0330, 0x0333},
    {class067SetDACValues,          0x0340, 0x037c}
};

METHOD Nv10VideoOverlayMethods[] =
{
    {mthdNoOperation,                  0x0100, 0x0103},
    {class07ASetNotify,                0x0104, 0x0107},
    {class07AStopOverlay,              0x0120, 0x0127},
    {class07ASetNotifyCtxDma,          0x0180, 0x0183},
    {class07ASetOverlayCtxDma,         0x019c, 0x01a3},
    {class07AGetOffset,                0x02fc, 0x02ff},
    {class07ASetOverlayValues,         0x0400, 0x04ff},
    {class07ASetOverlayPointOutNow,    0x0500, 0x0503},
    {class07ASetOverlayLuminanceNow,   0x0504, 0x0507},
    {class07ASetOverlayChrominanceNow, 0x0508, 0x050b}
};

METHOD Nv15VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class07CSetNotify,             0x0104, 0x0107},
    {class07CStopImage,             0x0108, 0x010f},
    {class07CStopLUT,               0x0110, 0x0117},
    {class07CStopCursorImage,       0x0118, 0x011f},
    {class07CStopDAC,               0x0120, 0x0128},
    {class07CSetNotifyCtxDma,       0x0180, 0x0183},
    {class07CSetImageCtxDma,        0x0184, 0x018b},
    {class07CSetLUTCtxDma,          0x018c, 0x0193},
    {class07CSetCursorCtxDma,       0x0194, 0x019b},
    {class07CSetSemaphoreCtxDma,    0x019c, 0x019f},
    {class07CSetHotPlug,            0x01a0, 0x01a3},
    {class07CSetPanOffset,          0x0220, 0x0223},
    {class07CSetSemaphoreOffset,    0x02f0, 0x02f3},
    {class07CSetSemaphoreRelease,   0x02f4, 0x02f7},
    {class07CSetOffsetRange,        0x02f8, 0x02fb},
    {class07CGetOffset,             0x02fc, 0x02ff},
    {class07CSetImageValues,        0x0300, 0x030f},
    {class07CSetLUTValues,          0x0310, 0x031f},
    {class07CSetCursorImageValues,  0x0320, 0x032f},
    {class07CSetCursorPoint,        0x0330, 0x0333},
    {class07CSetDACValues,          0x0340, 0x037c},
};

METHOD Nv20VideoLUTCursorDACMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class07CSetNotify,             0x0104, 0x0107},
    {class07CStopImage,             0x0108, 0x010f},
    {class07CStopLUT,               0x0110, 0x0117},
    {class07CStopCursorImage,       0x0118, 0x011f},
    {class07CStopDAC,               0x0120, 0x0128},
    {class07CSetNotifyCtxDma,       0x0180, 0x0183},
    {class07CSetImageCtxDma,        0x0184, 0x018b},
    {class07CSetLUTCtxDma,          0x018c, 0x0193},
    {class07CSetCursorCtxDma,       0x0194, 0x019b},
    {class07CSetSemaphoreCtxDma,    0x019c, 0x019f},
    {class07CSetHotPlug,            0x01a0, 0x01a3},
    {class07CSetPanOffset,          0x0220, 0x0223},
    {class07CSetSemaphoreOffset,    0x02f0, 0x02f3},
    {class07CSetSemaphoreRelease,   0x02f4, 0x02f7},
    {class07CSetOffsetRange,        0x02f8, 0x02fb},
    {class07CGetOffset,             0x02fc, 0x02ff},
    {class07CSetImageValues,        0x0300, 0x030f},
    {class07CSetLUTValues,          0x0310, 0x031f},
    {class07CSetCursorImageValues,  0x0320, 0x032f},
    {class07CSetCursorPoint,        0x0330, 0x0333},
    {class07CSetDACValues,          0x0340, 0x037c},
};

/*
METHOD NvVideoSourceMethods[] =
{
    {class74SetNotifyCtxDma,        0x0100, 0x0103},
    {class74SetNotify,              0x0104, 0x0107},
    {class74SetVideoOutput,         0x0200, 0x0203},
};
*/

METHOD Nv1TimerMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {mthdSetNotify,                 0x0104, 0x0107},
    {tmrStopTransfer,               0x0108, 0x010b},
    {mthdSetNotifyCtxDma,           0x0180, 0x0183},
    {mthdSetAlarmTime,              0x0300, 0x0307},
    {mthdSetAlarmTimeRelative,      0x0308, 0x030f},
    {mthdSetAlarmNotify,            0x0320, 0x0323}
};
METHOD Nv1BetaSolidMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class012Notify,                0x0104, 0x0107},
    {class012SetContextDmaNotifies, 0x0180, 0x0183},
    {class012SetBeta,               0x0300, 0x0303}
};
METHOD Nv1ImageSolidMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class017Notify,                0x0104, 0x0107},
    {class017SetContextDmaNotifies, 0x0180, 0x0183},
    {class017SetColorFormat,        0x0300, 0x0303},
    {class017SetColor,              0x0304, 0x0307}
};
METHOD Nv1ImagePatternMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class018Notify,                0x0104, 0x0107},
    {class018SetContextDmaNotifies, 0x0180, 0x0183},
    {class018SetColorFormat,        0x0300, 0x0303},
    {class018SetMonochromeFormat,   0x0304, 0x0307},
    {class018SetPatternShape,       0x0308, 0x030b},
    {class018SetColor0,             0x0310, 0x0313},
    {class018SetColor1,             0x0314, 0x0317},
    {class018SetPattern,            0x0318, 0x031f}
};
METHOD Nv1ImageRectangleBlackMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class019Notify,                0x0104, 0x0107},
    {class019SetContextDmaNotifies, 0x0180, 0x0183},
    {class019SetRectangle,          0x0300, 0x0307}
};
METHOD Nv1RenderSolidLinMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01CNotify,                0x0104, 0x0107},
    {class01CSetContextDmaNotifies, 0x0180, 0x0183},
    {class01CSetContextClip,        0x0184, 0x0187},
    {class01CSetContextPattern,     0x0188, 0x018b},
    {class01CSetContextRop,         0x018c, 0x018f},
    {class01CSetContextBeta1,       0x0190, 0x0193},
    {class01CSetContextSurface,     0x0194, 0x0197},
    {class01CSetOperation,          0x02fc, 0x02ff},
    {class01CSetColorFormat,        0x0300, 0x0303},
    {class01CColor,                 0x0304, 0x0307},
    {class01CLin,                   0x0400, 0x047f},
    {class01CLin32,                 0x0480, 0x04ff},
    {class01CPolyLin,               0x0500, 0x057f},
    {class01CPolyLin32,             0x0580, 0x05ff},
    {class01CColorPolyLin,          0x0600, 0x067f}
};
METHOD Nv1RenderSolidTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01DNotify,                0x0104, 0x0107},
    {class01DSetContextDmaNotifies, 0x0180, 0x0183},
    {class01DSetContextClip,        0x0184, 0x0187},
    {class01DSetContextPattern,     0x0188, 0x018b},
    {class01DSetContextRop,         0x018c, 0x018f},
    {class01DSetContextBeta1,       0x0190, 0x0193},
    {class01DSetContextSurface,     0x0194, 0x0197},
    {class01DSetOperation,          0x02fc, 0x02ff},
    {class01DSetColorFormat,        0x0300, 0x0303},
    {class01DColor,                 0x0304, 0x0307},
    {class01DTriangle,              0x0310, 0x031b},
    {class01DTriangle32,            0x0320, 0x0337},
    {class01DTrimesh,               0x0400, 0x047f},
    {class01DTrimesh32,             0x0480, 0x04ff},
    {class01DColorTriangle,         0x0500, 0x057f},
    {class01DColorTrimesh,          0x0580, 0x05ff}
};
METHOD Nv1RenderSolidRectangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01ENotify,                0x0104, 0x0107},
    {class01ESetContextDmaNotifies, 0x0180, 0x0183},
    {class01ESetContextClip,        0x0184, 0x0187},
    {class01ESetContextPattern,     0x0188, 0x018b},
    {class01ESetContextRop,         0x018c, 0x018f},
    {class01ESetContextBeta1,       0x0190, 0x0193},
    {class01ESetContextSurface,     0x0194, 0x0197},
    {class01ESetOperation,          0x02fc, 0x02ff},
    {class01ESetColorFormat,        0x0300, 0x0303},
    {class01EColor,                 0x0304, 0x0307},
    {class01ERectangle,             0x0400, 0x047f}
};
METHOD Nv1ImageBlitMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class01FNotify,                0x0104, 0x0107},
    {class01FSetContextDmaNotifies, 0x0180, 0x0183},
    {class01FSetContextColorKey,    0x0184, 0x0187},
    {class01FSetContextClip,        0x0188, 0x018b},
    {class01FSetContextPattern,     0x018c, 0x018f},
    {class01FSetContextRop,         0x0190, 0x0193},
    {class01FSetContextBeta1,       0x0194, 0x0197},
    {class01FSetContextSurfaceSource, 0x0198, 0x019b},
    {class01FSetContextSurface,     0x019c, 0x019f},
    {class01FSetOperation,          0x02fc, 0x02ff},
    {class01FPointIn,               0x0300, 0x0303},
    {class01FPointOut,              0x0304, 0x0307},
    {class01FSize,                  0x0308, 0x030b}
};
METHOD Nv1ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class021Notify,                0x0104, 0x0107},
    {class021SetContextDmaNotifies, 0x0180, 0x0183},
    {class021SetContextColorKey,    0x0184, 0x0187},
    {class021SetContextClip,        0x0188, 0x018b},
    {class021SetContextPattern,     0x018c, 0x018f},
    {class021SetContextRop,         0x0190, 0x0193},
    {class021SetContextBeta1,       0x0194, 0x0197},
    {class021SetContextSurface,     0x0198, 0x019b},
    {class021SetOperation,          0x02fc, 0x02ff},
    {class021SetColorFormat,        0x0300, 0x0303},
    {class021Point,                 0x0304, 0x0307},
    {class021Size,                  0x0308, 0x030b},
    {class021SizeIn,                0x030c, 0x030f},
    {class021Color,                 0x0400, 0x047f}
};
METHOD Nv3StretchedImageFromCPUMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class036Notify,                0x0104, 0x0107},
    {class036SetContextDmaNotifies, 0x0180, 0x0183},
    {class036SetContextColorKey,    0x0184, 0x0187},
    {class036SetContextPattern,     0x0188, 0x018b},
    {class036SetContextRop,         0x018c, 0x018f},
    {class036SetContextBeta1,       0x0190, 0x0193},
    {class036SetContextSurface,     0x0194, 0x0197},
    {class036SetOperation,          0x02fc, 0x02ff},
    {class036SetColorFormat,        0x0300, 0x0303},
    {class036SizeIn,                0x0304, 0x0307},
    {class036DeltaDxDu,             0x0308, 0x030b},
    {class036DeltaDyDv,             0x030c, 0x030f},
    {class036Clip,                  0x0310, 0x0317},
    {class036Point12d4,             0x0318, 0x031b},
    {class036Color,                 0x0400, 0x1fff}
};
METHOD Nv3ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class037Notify,                0x0104, 0x0107},
    {class037SetContextDmaNotifies, 0x0180, 0x0183},
    {class037SetContextDmaImage,    0x0184, 0x0187},
    {class037SetContextPattern,     0x0188, 0x018b},
    {class037SetContextRop,         0x018c, 0x018f},
    {class037SetContextBeta1,       0x0190, 0x0193},
    {class037SetContextSurface,     0x0194, 0x0197},
    {class037SetColorFormat,        0x0300, 0x0303},
    {class037SetOperation,          0x0304, 0x0307},
    {class037Clip,                  0x0308, 0x030f},
    {class037RectangleOut,          0x0310, 0x0317},
    {class037DeltaDuDx,             0x0318, 0x031b},
    {class037DeltaDvDy,             0x031c, 0x031f},
    {class037ImageIn,               0x0400, 0x040f}
};
METHOD Nv3MemoryToMemoryFormatMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class039Notify,                0x0104, 0x0107},
    {class039SetContextDmaNotifies, 0x0180, 0x0183},
    {class039SetContextDmaBufferIn, 0x0184, 0x0187},
    {class039SetContextDmaBufferOut, 0x0188, 0x018b},
    {class039BufferTransfer,        0x030c, 0x032b}
};
METHOD Nv3DX3TexturedTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class048Notify,                0x0104, 0x0107},
    {class048SetContextDmaNotifies, 0x0180, 0x0183},
    {class048SetTextureCtxDma,      0x0184, 0x0187},
    {class048SetContextClip,        0x0188, 0x018b},
    {class048SetContextSurfaceColor, 0x018c, 0x018f},
    {class048SetContextSurfaceZeta, 0x0190, 0x0193},
    {class048TextureOffset,         0x0304, 0x0307},
    {class048TextureFormat,         0x0308, 0x030b},
    {class048Filter,                0x030c, 0x030f},
    {class048FogColor,              0x0310, 0x0313},
    {class048ControlOut0,           0x0314, 0x0317},
    {class048ControlOut1,           0x0318, 0x031b},
    {class048ControlPoint,          0x1000, 0x1fff}
};
METHOD Nv3GDIRectangleTextMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04BNotify,                0x0104, 0x0107},
    {class04BSetContextDmaNotifies, 0x0180, 0x0183},
    {class04BSetContextPattern,     0x0184, 0x0187},
    {class04BSetContextRop,         0x0188, 0x018b},
    {class04BSetContextBeta1,       0x018c, 0x018f},
    {class04BSetContextSurface,     0x0190, 0x0193},
    {class04BSetOperation,          0x02fc, 0x02ff},
    {class04BSetColorFormat,        0x0300, 0x0303},
    {class04BSetMonochromeFormat,   0x0304, 0x0307},
    {class04BColor1A,               0x03fc, 0x03ff},
    {class04BUnclippedRectangle,    0x0400, 0x05ff},
    {class04BClipB,                 0x07f4, 0x07fb},
    {class04BColor1B,               0x07fc, 0x07ff},
    {class04BClippedRectangle,      0x0800, 0x09ff},
    {class04BClipC,                 0x0bec, 0x0bf3},
    {class04BColor1C,               0x0bf4, 0x0bf7},
    {class04BSizeC,                 0x0bf8, 0x0bfb},
    {class04BPointC,                0x0bfc, 0x0bff},
    {class04BMonochromeColor1C,     0x0c00, 0x0dff},
    {class04BClipD,                 0x0fe8, 0x0fef},
    {class04BColor1D,               0x0ff0, 0x0ff3},
    {class04BSizeInD,               0x0ff4, 0x0ff7},
    {class04BSizeOutD,              0x0ff8, 0x0ffb},
    {class04BPointD,                0x0ffc, 0x0fff},
    {class04BMonochromeColor1D,     0x1000, 0x11ff},
    {class04BClipE,                 0x13e4, 0x13eb},
    {class04BColor0E,               0x13ec, 0x13ef},
    {class04BColor1E,               0x13f0, 0x13f3},
    {class04BSizeInE,               0x13f4, 0x13f7},
    {class04BSizeOutE,              0x13f8, 0x13fb},
    {class04BPointE,                0x13fc, 0x13ff},
    {class04BMonochromeColor01E,    0x1400, 0x15ff}
};
METHOD Nv3ExternalVideoDecoderMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04DNotify,                0x0104, 0x0107},
    {class04DStopTransferVbi,       0x0108, 0x010b},
    {class04DStopTransferImage,     0x010c, 0x010f},
    {class04DSetContextDmaNotifies, 0x0180, 0x0183},
    {class04DSetContextDmaVbi,      0x0184, 0x018b},
    {class04DSetContextDmaImage,    0x018c, 0x0193},
    {class04DSetImageConfig,        0x02f8, 0x02fb},
    {class04DSetImageStartLine,     0x02fc, 0x02ff},
    {class04DSetVbi,                0x0300, 0x0317},
    {class04DGetVbiOffsetNotify,    0x0318, 0x031f},
    {class04DSetImage,              0x0320, 0x033f},
    {class04DGetImageOffsetNotify,  0x0340, 0x0347}
};
METHOD Nv3ExternalVideoDecompressorMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04ENotify,                0x0104, 0x0107},
    {class04EStopTransfer,          0x0108, 0x010b},
    {class04ESetContextDmaNotifies, 0x0180, 0x0183},
    {class04ESetContextDmaData,     0x0184, 0x018b},
    {class04ESetContextDmaImage,    0x018c, 0x0193},
    {class04EReadData,              0x0300, 0x0317},
    {class04EWriteImage,            0x0318, 0x033f}
};
METHOD Nv1ExternalParallelBusMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04FNotify,                0x0104, 0x0107},
    {class04FStopTransfer,          0x0108, 0x010b},
    {class04FSetContextDmaNotifies, 0x0180, 0x0183},
    {class04FWrite,                 0x0300, 0x030b},
    {class04FRead,                  0x030c, 0x0317},
    {class04FSetInterruptNotify,    0x0318, 0x031b}
};
METHOD Nv3ExternalMonitorBusMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class050Notify,                0x0104, 0x0107},
    {class050StopTransfer,          0x0108, 0x010b},
    {class050SetContextDmaNotifies, 0x0180, 0x0183},
    {class050Write,                 0x0300, 0x030b},
    {class050Read,                  0x030c, 0x0317},
    {class050SetInterruptNotify,    0x0318, 0x031b}
};
METHOD Nv4ExternalSerialBusMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class051Notify,                0x0104, 0x0107},
    {class051StopTransfer,          0x0108, 0x010b},
    {class051SetContextDmaNotifies, 0x0180, 0x0183},
    {class051Write,                 0x0300, 0x030b},
    {class051Read,                  0x030c, 0x0317},
    {class051SetInterruptNotify,    0x0318, 0x031b}
};
METHOD Nv3ContextSurface0Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class058Notify,                0x0104, 0x0107},
    {class058SetContextDmaNotifies, 0x0180, 0x0183},
    {class058SetContextDmaImage,    0x0184, 0x0187},
    {class058SetColorFormat,        0x0300, 0x0303},
    {class058SetImagePitch,         0x0308, 0x030b},
    {class058SetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextSurface1Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class059Notify,                0x0104, 0x0107},
    {class059SetContextDmaNotifies, 0x0180, 0x0183},
    {class059SetContextDmaImage,    0x0184, 0x0187},
    {class059SetColorFormat,        0x0300, 0x0303},
    {class059SetImagePitch,         0x0308, 0x030b},
    {class059SetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextSurface2Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05ANotify,                0x0104, 0x0107},
    {class05ASetContextDmaNotifies, 0x0180, 0x0183},
    {class05ASetContextDmaImage,    0x0184, 0x0187},
    {class05ASetColorFormat,        0x0300, 0x0303},
    {class05ASetImagePitch,         0x0308, 0x030b},
    {class05ASetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextSurface3Methods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05BNotify,                0x0104, 0x0107},
    {class05BSetContextDmaNotifies, 0x0180, 0x0183},
    {class05BSetContextDmaImage,    0x0184, 0x0187},
    {class05BSetColorFormat,        0x0300, 0x0303},
    {class05BSetImagePitch,         0x0308, 0x030b},
    {class05BSetImageOffset,        0x030c, 0x030f}
};
METHOD Nv3ContextRopMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class043Notify,                0x0104, 0x0107},
    {class043SetContextDmaNotifies, 0x0180, 0x0183},
    {class043SetRop5,               0x0300, 0x0303}
};
METHOD Nv4DvdSubpictureMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class038Notify,                0x0104, 0x0107},
    {class038SetContextDmaNotifies, 0x0180, 0x0183},
    {class038SetContextDmaOverlay,  0x0184, 0x0187},
    {class038SetContextDmaImageIn,  0x0188, 0x018b},
    {class038SetContextDmaImageOut, 0x018c, 0x018f},
    {class038ImageOutPoint,         0x0300, 0x0303},
    {class038ImageOutSize,          0x0304, 0x0307},
    {class038ImageOutFormat,        0x0308, 0x030b},
    {class038ImageOutOffset,        0x030c, 0x030f},
    {class038ImageInDeltaDuDx,      0x0310, 0x0313},
    {class038ImageInDeltaDvDy,      0x0314, 0x0317},
    {class038ImageInSize,           0x0318, 0x031b},
    {class038ImageInFormat,         0x031c, 0x031f},
    {class038ImageInOffset,         0x0320, 0x0323},
    {class038ImageInPoint,          0x0324, 0x0317},
    {class038OverlayDeltaDuDx,      0x0328, 0x032b},
    {class038OverlayDeltaDvDy,      0x032c, 0x032f},
    {class038OverlaySize,           0x0330, 0x0333},
    {class038OverlayFormat,         0x0334, 0x0337},
    {class038OverlayOffset,         0x0338, 0x033b},
    {class038OverlayPoint,          0x033c, 0x033f}
};
METHOD Nv4ContextSurfaces2DMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class042Notify,                0x0104, 0x0107},
    {class042SetContextDmaNotifies, 0x0180, 0x0183},
    {class042SetContextDmaSource,   0x0184, 0x0187},
    {class042SetContextDmaDestin,   0x0188, 0x018b},
    {class042SetColorFormat,        0x0300, 0x0303},
    {class042SetPitch,              0x0304, 0x0307},
    {class042SetOffsetSource,       0x0308, 0x030b},
    {class042SetOffsetDestin,       0x030c, 0x030f}
};
METHOD Nv4ContextPatternMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class044Notify,                0x0104, 0x0107},
    {class044SetContextDmaNotifies, 0x0180, 0x0183},
    {class044SetColorFormat,        0x0300, 0x0303},
    {class044SetMonochromeFormat,   0x0304, 0x0307},
    {class044SetMonochromeShape,    0x0308, 0x030b},
    {class044SetPatternSelect,      0x030c, 0x030f},
    {class044SetMonochromeColor,    0x0310, 0x0317},
    {class044SetMonochromePattern,  0x0318, 0x031f},
    {class044SetPatternY8,          0x0400, 0x043f},
    {class044SetPatternR5G6B5,      0x0500, 0x057f},
    {class044SetPatternX8R8G8B8,    0x0700, 0x07ff}
};
METHOD Nv4GDIRectangleTextMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class04ANotify,                0x0104, 0x0107},
    {class04ASetContextDmaNotifies, 0x0180, 0x0183},
    {class04ASetContextFonts,       0x0184, 0x0187},
    {class04ASetContextPattern,     0x0188, 0x018b},
    {class04ASetContextRop,         0x018c, 0x018f},
    {class04ASetContextBeta1,       0x0190, 0x0193},
    {class04ASetContextBeta4,       0x0194, 0x0197},
    {class04ASetContextSurface,     0x0198, 0x019b},
    {class04ASetOperation,          0x02fc, 0x02ff},
    {class04ASetColorFormat,        0x0300, 0x0303},
    {class04ASetMonochromeFormat,   0x0304, 0x0307},
    {class04AColor1A,               0x03fc, 0x03ff},
    {class04AUnclippedRectangle,    0x0400, 0x04ff},
    {class04AClipB,                 0x05f4, 0x05fb},
    {class04AColor1B,               0x05fc, 0x05ff},
    {class04AClippedRectangle,      0x0600, 0x06ff},
    {class04AClipC,                 0x07ec, 0x07f3},
    {class04AColor1C,               0x07f4, 0x07f7},
    {class04ASizeC,                 0x07f8, 0x07fb},
    {class04APointC,                0x07fc, 0x07ff},
    {class04AMonochromeColor1C,     0x0800, 0x09ff},
    {class04AClipE,                 0x0be4, 0x0beb},
    {class04AColor0E,               0x0bec, 0x0bef},
    {class04AColor1E,               0x0bf0, 0x0bf3},
    {class04ASizeInE,               0x0bf4, 0x0bf7},
    {class04ASizeOutE,              0x0bf8, 0x0bfb},
    {class04APointE,                0x0bfc, 0x0bff},
    {class04AMonochromeColor01E,    0x0c00, 0x0dff},
    {class04AFontF,                 0x0ff0, 0x0ff3},
    {class04AClipF,                 0x0ff4, 0x0ffb},
    {class04AColor1F,               0x0ffc, 0x0fff},
    {class04ACharacterColor1F,      0x1000, 0x13ff},
    {class04AFontG,                 0x17f0, 0x17f3},
    {class04AClipG,                 0x17f4, 0x17fb},
    {class04AColor1G,               0x17fc, 0x17ff},
    {class04ACharacterColor1G,      0x1800, 0x1fff}
};
METHOD Nv4ContextSurfaceSwizzledMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class052Notify,                0x0104, 0x0107},
    {class052SetContextDmaNotifies, 0x0180, 0x0183},
    {class052SetContextDmaImage,    0x0184, 0x0187},
    {class052SetFormat,             0x0300, 0x0303},
    {class052SetOffset,             0x0304, 0x0307}
};
METHOD Nv4ContextSurfacesArgbZsMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class053Notify,                0x0104, 0x0107},
    {class053SetContextDmaNotifies, 0x0180, 0x0183},
    {class053SetContextDmaColor,    0x0184, 0x0187},
    {class053SetContextDmaZeta,     0x0188, 0x018b},
    {class053SetClipHorizontal,     0x02f8, 0x02fb},
    {class053SetClipVertical,       0x02fc, 0x02ff},
    {class053SetFormat,             0x0300, 0x0303},
    {class053SetClipSize,           0x0304, 0x0307},
    {class053SetPitch,              0x0308, 0x030b},
    {class053SetOffsetColor,        0x030c, 0x030f},
    {class053SetOffsetZeta,         0x0310, 0x0313}
};
METHOD Nv4DX5TexturedTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class054Notify,                0x0104, 0x0107},
    {class054SetContextDmaNotifies, 0x0180, 0x0183},
    {class054SetContextDmaA,        0x0184, 0x0187},
    {class054SetContextDmaB,        0x0188, 0x018b},
    {class054SetContextSurface,     0x018c, 0x018f},
    {class054ColorKey,              0x0300, 0x0303},
    {class054Offset,                0x0304, 0x0307},
    {class054Format,                0x0308, 0x030b},
    {class054Filter,                0x030c, 0x030f},
    {class054Blend,                 0x0310, 0x0313},
    {class054Control,               0x0314, 0x0317},
    {class054FogColor,              0x0318, 0x031b},
    {class054Tlvertex,              0x0400, 0x05ff},
    {class054DrawPrimitive,         0x0600, 0x06ff}
};
METHOD Nv4DX6MultiTextureTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class055Notify,                0x0104, 0x0107},
    {class055SetContextDmaNotifies, 0x0180, 0x0183},
    {class055SetContextDmaA,        0x0184, 0x0187},
    {class055SetContextDmaB,        0x0188, 0x018b},
    {class055SetContextSurface,     0x018c, 0x018f},
    {class055Offset,                0x0308, 0x030f},
    {class055Format,                0x0310, 0x0317},
    {class055Filter,                0x0318, 0x031f},
    {class055Combine0Alpha,         0x0320, 0x0323},
    {class055Combine0Color,         0x0324, 0x0327},
    {class055Combine1Alpha,         0x032c, 0x032f},
    {class055Combine1Color,         0x0330, 0x0333},
    {class055CombineFactor,         0x0334, 0x0337},
    {class055Blend,                 0x0338, 0x033b},
    {class055Control,               0x033c, 0x0347},
    {class055FogColor,              0x0348, 0x034b},
    {class055Tlmtvertex,            0x0400, 0x053f},
    {class055DrawPrimitive,         0x0540, 0x05ff}
};
METHOD Nv10CelsiusPrimitiveMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class056Notify,                0x0104, 0x0107},
    {class056SetWarningEnable,      0x0108, 0x010b},
    //{class056GetState,              0x010c, 0x010f},
    {class056WaitForIdle,           0x0110, 0x0113},
    {class056PMTrigger,             0x0140, 0x0143},
    {class056SetContextDmaNotifies, 0x0180, 0x0183},
    {class056SetContextDmaA,        0x0184, 0x0187},
    {class056SetContextDmaB,        0x0188, 0x018b},
    {class056SetContextDmaVertex,   0x018c, 0x018f},
    {class056SetContextDmaState,    0x0190, 0x0193},
    {class056SetContextDmaColor,    0x0194, 0x0197},
    {class056SetContextDmaZeta,     0x0198, 0x019b},
    {class056MethodCatcher,         0x019c, 0x17ff},    // catch any in between methods
    //{class056SetMaterialEmission,   0x1628, 0x1633},    // HW workaround for NV10
    //{class056MethodCatcher,         0x1634, 0x17ff},    // catch any in between methods
    {class056InlineArray,           0x1800, 0x1fff},
};
METHOD Nv4ContextColorKeyMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class057Notify,                0x0104, 0x0107},
    {class057SetContextDmaNotifies, 0x0180, 0x0183},
    {class057SetColorFormat,        0x0300, 0x0303},
    {class057SetColor,              0x0304, 0x0307}
};
METHOD Nv4RenderSolidLinMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05CNotify,                0x0104, 0x0107},
    {class05CSetContextDmaNotifies, 0x0180, 0x0183},
    {class05CSetContextClip,        0x0184, 0x0187},
    {class05CSetContextPattern,     0x0188, 0x018b},
    {class05CSetContextRop,         0x018c, 0x018f},
    {class05CSetContextBeta1,       0x0190, 0x0193},
    {class05CSetContextBeta4,       0x0194, 0x0197},
    {class05CSetContextSurface,     0x0198, 0x019b},
    {class05CSetOperation,          0x02fc, 0x02ff},
    {class05CSetColorFormat,        0x0300, 0x0303},
    {class05CColor,                 0x0304, 0x0307},
    {class05CLin,                   0x0400, 0x047f},
    {class05CLin32,                 0x0480, 0x04ff},
    {class05CPolyLin,               0x0500, 0x057f},
    {class05CPolyLin32,             0x0580, 0x05ff},
    {class05CColorPolyLin,          0x0600, 0x067f}
};
METHOD Nv4RenderSolidTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05DNotify,                0x0104, 0x0107},
    {class05DSetContextDmaNotifies, 0x0180, 0x0183},
    {class05DSetContextClip,        0x0184, 0x0187},
    {class05DSetContextPattern,     0x0188, 0x018b},
    {class05DSetContextRop,         0x018c, 0x018f},
    {class05DSetContextBeta1,       0x0190, 0x0193},
    {class05DSetContextBeta4,       0x0194, 0x0197},
    {class05DSetContextSurface,     0x0198, 0x019b},
    {class05DSetOperation,          0x02fc, 0x02ff},
    {class05DSetColorFormat,        0x0300, 0x0303},
    {class05DColor,                 0x0304, 0x0307},
    {class05DTriangle,              0x0310, 0x031b},
    {class05DTriangle32,            0x0320, 0x0337},
    {class05DTrimesh,               0x0400, 0x047f},
    {class05DTrimesh32,             0x0480, 0x04ff},
    {class05DColorTriangle,         0x0500, 0x057f},
    {class05DColorTrimesh,          0x0580, 0x05ff}
};
METHOD Nv4RenderSolidRectangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05ENotify,                0x0104, 0x0107},
    {class05ESetContextDmaNotifies, 0x0180, 0x0183},
    {class05ESetContextClip,        0x0184, 0x0187},
    {class05ESetContextPattern,     0x0188, 0x018b},
    {class05ESetContextRop,         0x018c, 0x018f},
    {class05ESetContextBeta1,       0x0190, 0x0193},
    {class05ESetContextBeta4,       0x0194, 0x0197},
    {class05ESetContextSurface,     0x0198, 0x019b},
    {class05ESetOperation,          0x02fc, 0x02ff},
    {class05ESetColorFormat,        0x0300, 0x0303},
    {class05EColor,                 0x0304, 0x0307},
    {class05ERectangle,             0x0400, 0x047f}
};
METHOD Nv4ImageBlitMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class05FNotify,                0x0104, 0x0107},
    {class05FSetContextDmaNotifies, 0x0180, 0x0183},
    {class05FSetContextColorKey,    0x0184, 0x0187},
    {class05FSetContextClip,        0x0188, 0x018b},
    {class05FSetContextPattern,     0x018c, 0x018f},
    {class05FSetContextRop,         0x0190, 0x0193},
    {class05FSetContextBeta1,       0x0194, 0x0197},
    {class05FSetContextBeta4,       0x0198, 0x019b},
    {class05FSetContextSurfaces2d,  0x019c, 0x019f},
    {class05FSetOperation,          0x02fc, 0x02ff},
    {class05FControlPointIn,        0x0300, 0x0303},
    {class05FControlPointOut,       0x0304, 0x0307},
    {class05FSize,                  0x0308, 0x030b}
};
METHOD Nv4IndexedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class060Notify,                0x0104, 0x0107},
    {class060SetContextDmaNotifies, 0x0180, 0x0183},
    {class060SetContextDmaLut,      0x0184, 0x0187},
    {class060SetContextColorKey,    0x0188, 0x018b},
    {class060SetContextClip,        0x018c, 0x018f},
    {class060SetContextPattern,     0x0190, 0x0193},
    {class060SetContextRop,         0x0194, 0x0197},
    {class060SetContextBeta1,       0x0198, 0x019b},
    {class060SetContextBeta4,       0x019c, 0x019f},
    {class060SetContextSurface,     0x01a0, 0x01a3},
    {class060SetColorConversion,    0x03e0, 0x03e3},
    {class060SetOperation,          0x03e4, 0x03e7},
    {class060SetColorFormat,        0x03e8, 0x03eb},
    {class060IndexFormat,           0x03ec, 0x03ef},
    {class060LutOffset,             0x03f0, 0x03f3},
    {class060Point,                 0x03f4, 0x03f7},
    {class060SizeOut,               0x03f8, 0x03fb},
    {class060SizeIn,                0x03fc, 0x03ff},
    {class060Indices,               0x0400, 0x1fff}
};
METHOD Nv4ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class061Notify,                0x0104, 0x0107},
    {class061SetContextDmaNotifies, 0x0180, 0x0183},
    {class061SetContextColorKey,    0x0184, 0x0187},
    {class061SetContextClip,        0x0188, 0x018b},
    {class061SetContextPattern,     0x018c, 0x018f},
    {class061SetContextRop,         0x0190, 0x0193},
    {class061SetContextBeta1,       0x0194, 0x0197},
    {class061SetContextBeta4,       0x0198, 0x019b},
    {class061SetContextSurface,     0x019c, 0x019f},
    {class061SetOperation,          0x02fc, 0x02ff},
    {class061SetColorFormat,        0x0300, 0x0303},
    {class061Point,                 0x0304, 0x0307},
    {class061SizeOut,               0x0308, 0x030b},
    {class061SizeIn,                0x030c, 0x030f},
    {class061Color,                 0x0400, 0x1fff}
};

METHOD Nv5ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class063Notify,                0x0104, 0x0107},
    {class063SetContextDmaNotifies, 0x0180, 0x0183},
    {class063SetContextDmaImage,    0x0184, 0x0187},
    {class063SetContextPattern,     0x0188, 0x018b},
    {class063SetContextRop,         0x018c, 0x018f},
    {class063SetContextBeta1,       0x0190, 0x0193},
    {class063SetContextBeta4,       0x0194, 0x0197},
    {class063SetContextSurface,     0x0198, 0x019b},
    {class063SetColorConversion,    0x02fc, 0x02ff},
    {class063SetColorFormat,        0x0300, 0x0303},
    {class063SetOperation,          0x0304, 0x0307},
    {class063Clip,                  0x0308, 0x030f},
    {class063RectangleOut,          0x0310, 0x0317},
    {class063DeltaDuDx,             0x0318, 0x031b},
    {class063DeltaDvDy,             0x031c, 0x031f},
    {class063ImageIn,               0x0400, 0x040f}
};

METHOD Nv5IndexedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class064Notify,                0x0104, 0x0107},
    {class064SetContextDmaNotifies, 0x0180, 0x0183},
    {class064SetContextDmaLut,      0x0184, 0x0187},
    {class064SetContextColorKey,    0x0188, 0x018b},
    {class064SetContextClip,        0x018c, 0x018f},
    {class064SetContextPattern,     0x0190, 0x0193},
    {class064SetContextRop,         0x0194, 0x0197},
    {class064SetContextBeta1,       0x0198, 0x019b},
    {class064SetContextBeta4,       0x019c, 0x019f},
    {class064SetContextSurface,     0x01a0, 0x01a3},
    {class064SetColorConversion,    0x03e0, 0x03e3},
    {class064SetOperation,          0x03e4, 0x03e7},
    {class064SetColorFormat,        0x03e8, 0x03eb},
    {class064IndexFormat,           0x03ec, 0x03ef},
    {class064LutOffset,             0x03f0, 0x03f3},
    {class064Point,                 0x03f4, 0x03f7},
    {class064SizeOut,               0x03f8, 0x03fb},
    {class064SizeIn,                0x03fc, 0x03ff},
    {class064Indices,               0x0400, 0x1fff}
};

METHOD Nv5ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class065Notify,                0x0104, 0x0107},
    {class065SetContextDmaNotifies, 0x0180, 0x0183},
    {class065SetContextColorKey,    0x0184, 0x0187},
    {class065SetContextClip,        0x0188, 0x018b},
    {class065SetContextPattern,     0x018c, 0x018f},
    {class065SetContextRop,         0x0190, 0x0193},
    {class065SetContextBeta1,       0x0194, 0x0197},
    {class065SetContextBeta4,       0x0198, 0x019b},
    {class065SetContextSurface,     0x019c, 0x019f},
    {class065SetColorConversion,    0x02f8, 0x02fb},
    {class065SetOperation,          0x02fc, 0x02ff},
    {class065SetColorFormat,        0x0300, 0x0303},
    {class065Point,                 0x0304, 0x0307},
    {class065SizeOut,               0x0308, 0x030b},
    {class065SizeIn,                0x030c, 0x030f},
    {class065Color,                 0x0400, 0x1fff}
};
METHOD Nv5StretchedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class066Notify,                0x0104, 0x0107},
    {class066SetContextDmaNotifies, 0x0180, 0x0183},
    {class066SetContextColorKey,    0x0184, 0x0187},
    {class066SetContextPattern,     0x0188, 0x018b},
    {class066SetContextRop,         0x018c, 0x018f},
    {class066SetContextBeta1,       0x0190, 0x0193},
    {class066SetContextBeta4,       0x0194, 0x0197},
    {class066SetContextSurface,     0x0198, 0x019b},
    {class066SetColorConversion,    0x02f8, 0x02fb},
    {class066SetOperation,          0x02fc, 0x02ff},
    {class066SetColorFormat,        0x0300, 0x0303},
    {class066SizeIn,                0x0304, 0x0307},
    {class066DeltaDxDu,             0x0308, 0x030b},
    {class066DeltaDyDv,             0x030c, 0x030f},
    {class066Clip,                  0x0310, 0x0317},
    {class066Point12d4,             0x0318, 0x031b},
    {class066Color,                 0x0400, 0x1fff}
};
METHOD Nv4ContextBetaMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class072Notify,                0x0104, 0x0107},
    {class072SetContextDmaNotifies, 0x0180, 0x0183},
    {class072SetBetaFactor,         0x0300, 0x0303}
};
METHOD Nv4StretchedImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class076Notify,                0x0104, 0x0107},
    {class076SetContextDmaNotifies, 0x0180, 0x0183},
    {class076SetContextColorKey,    0x0184, 0x0187},
    {class076SetContextPattern,     0x0188, 0x018b},
    {class076SetContextRop,         0x018c, 0x018f},
    {class076SetContextBeta1,       0x0190, 0x0193},
    {class076SetContextBeta4,       0x0194, 0x0197},
    {class076SetContextSurface,     0x0198, 0x019b},
    {class076SetOperation,          0x02fc, 0x02ff},
    {class076SetColorFormat,        0x0300, 0x0303},
    {class076SizeIn,                0x0304, 0x0307},
    {class076DeltaDxDu,             0x0308, 0x030b},
    {class076DeltaDyDv,             0x030c, 0x030f},
    {class076Clip,                  0x0310, 0x0317},
    {class076Point12d4,             0x0318, 0x031b},
    {class076Color,                 0x0400, 0x1fff}
};
METHOD Nv4ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class077Notify,                0x0104, 0x0107},
    {class077SetContextDmaNotifies, 0x0180, 0x0183},
    {class077SetContextDmaImage,    0x0184, 0x0187},
    {class077SetContextPattern,     0x0188, 0x018b},
    {class077SetContextRop,         0x018c, 0x018f},
    {class077SetContextBeta1,       0x0190, 0x0193},
    {class077SetContextBeta4,       0x0194, 0x0197},
    {class077SetContextSurface,     0x0198, 0x019b},
    {class077SetColorFormat,        0x0300, 0x0303},
    {class077SetOperation,          0x0304, 0x0307},
    {class077Clip,                  0x0308, 0x030f},
    {class077RectangleOut,          0x0310, 0x0317},
    {class077DeltaDuDx,             0x0318, 0x031b},
    {class077DeltaDvDy,             0x031c, 0x031f},
    {class077ImageIn,               0x0400, 0x040f}
};
METHOD Nv10ContextSurfaces2DMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class062Notify,                0x0104, 0x0107},
    {class062SetContextDmaNotifies, 0x0180, 0x0183},
    {class062SetContextDmaSource,   0x0184, 0x0187},
    {class062SetContextDmaDestin,   0x0188, 0x018b},
    {class062SetColorFormat,        0x0300, 0x0303},
    {class062SetPitch,              0x0304, 0x0307},
    {class062SetOffsetSource,       0x0308, 0x030b},
    {class062SetOffsetDestin,       0x030c, 0x030f}
};
METHOD Nv10TextureFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class07BNotify,                0x0104, 0x0107},
    {class07BSetContextDmaNotifies, 0x0180, 0x0183},
    {class07BSetContextSurface,     0x0184, 0x0187},
    {class07BSetColorFormat,        0x0300, 0x0303},
    {class07BPoint,                 0x0304, 0x0307},
    {class07BSize,                  0x0308, 0x030b},
    {class07BClipHorizontal,        0x030c, 0x030f},
    {class07BClipVertical,          0x0310, 0x0313},
    {class07BColor,                 0x0400, 0x1fff}
};
METHOD Nv10DvdSubpictureMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class088Notify,                0x0104, 0x0107},
    {class088SetContextDmaNotifies, 0x0180, 0x0183},
    {class088SetContextDmaOverlay,  0x0184, 0x0187},
    {class088SetContextDmaImageIn,  0x0188, 0x018b},
    {class088SetContextDmaImageOut, 0x018c, 0x018f},
    {class088ImageOutPoint,         0x0300, 0x0303},
    {class088ImageOutSize,          0x0304, 0x0307},
    {class088ImageOutFormat,        0x0308, 0x030b},
    {class088ImageOutOffset,        0x030c, 0x030f},
    {class088ImageInDeltaDuDx,      0x0310, 0x0313},
    {class088ImageInDeltaDvDy,      0x0314, 0x0317},
    {class088ImageInSize,           0x0318, 0x031b},
    {class088ImageInFormat,         0x031c, 0x031f},
    {class088ImageInOffset,         0x0320, 0x0323},
    {class088ImageInPoint,          0x0324, 0x0317},
    {class088OverlayDeltaDuDx,      0x0328, 0x032b},
    {class088OverlayDeltaDvDy,      0x032c, 0x032f},
    {class088OverlaySize,           0x0330, 0x0333},
    {class088OverlayFormat,         0x0334, 0x0337},
    {class088OverlayOffset,         0x0338, 0x033b},
    {class088OverlayPoint,          0x033c, 0x033f}
};
METHOD Nv10ScaledImageFromMemoryMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class089Notify,                0x0104, 0x0107},
    {class089SetContextDmaNotifies, 0x0180, 0x0183},
    {class089SetContextDmaImage,    0x0184, 0x0187},
    {class089SetContextPattern,     0x0188, 0x018b},
    {class089SetContextRop,         0x018c, 0x018f},
    {class089SetContextBeta1,       0x0190, 0x0193},
    {class089SetContextBeta4,       0x0194, 0x0197},
    {class089SetContextSurface,     0x0198, 0x019b},
    {class089SetColorConversion,    0x02fc, 0x02ff},
    {class089SetColorFormat,        0x0300, 0x0303},
    {class089SetOperation,          0x0304, 0x0307},
    {class089Clip,                  0x0308, 0x030f},
    {class089RectangleOut,          0x0310, 0x0317},
    {class089DeltaDuDx,             0x0318, 0x031b},
    {class089DeltaDvDy,             0x031c, 0x031f},
    {class089ImageIn,               0x0400, 0x040f}
};
METHOD Nv10ImageFromCpuMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class08ANotify,                0x0104, 0x0107},
    {class08ASetContextDmaNotifies, 0x0180, 0x0183},
    {class08ASetContextColorKey,    0x0184, 0x0187},
    {class08ASetContextClip,        0x0188, 0x018b},
    {class08ASetContextPattern,     0x018c, 0x018f},
    {class08ASetContextRop,         0x0190, 0x0193},
    {class08ASetContextBeta1,       0x0194, 0x0197},
    {class08ASetContextBeta4,       0x0198, 0x019b},
    {class08ASetContextSurface,     0x019c, 0x019f},
    {class08ASetColorConversion,    0x02f8, 0x02fb},
    {class08ASetOperation,          0x02fc, 0x02ff},
    {class08ASetColorFormat,        0x0300, 0x0303},
    {class08APoint,                 0x0304, 0x0307},
    {class08ASizeOut,               0x0308, 0x030b},
    {class08ASizeIn,                0x030c, 0x030f},
    {class08AColor,                 0x0400, 0x1fff}
};
METHOD Nv10ContextSurfaces3DMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class093Notify,                0x0104, 0x0107},
    {class093SetContextDmaNotifies, 0x0180, 0x0183},
    {class093SetContextDmaColor,    0x0184, 0x0187},
    {class093SetContextDmaZeta,     0x0188, 0x018b},
    {class093SetClipHorizontal,     0x02f8, 0x02fb},
    {class093SetClipVertical,       0x02fc, 0x02ff},
    {class093SetFormat,             0x0300, 0x0303},
    {class093SetClipSize,           0x0304, 0x0307},
    {class093SetPitch,              0x0308, 0x030b},
    {class093SetOffsetColor,        0x030c, 0x030f},
    {class093SetOffsetZeta,         0x0310, 0x0313}
};
METHOD Nv10DX5TexturedTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class094Notify,                0x0104, 0x0107},
    {class094SetContextDmaNotifies, 0x0180, 0x0183},
    {class094SetContextDmaA,        0x0184, 0x0187},
    {class094SetContextDmaB,        0x0188, 0x018b},
    {class094SetContextSurface,     0x018c, 0x018f},
    {class094ColorKey,              0x0300, 0x0303},
    {class094Offset,                0x0304, 0x0307},
    {class094Format,                0x0308, 0x030b},
    {class094Filter,                0x030c, 0x030f},
    {class094Blend,                 0x0310, 0x0313},
    {class094Control,               0x0314, 0x0317},
    {class094FogColor,              0x0318, 0x031b},
    {class094Tlvertex,              0x0400, 0x05ff},
    {class094DrawPrimitive,         0x0600, 0x06ff}
};
METHOD Nv10DX6MultiTextureTriangleMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class095Notify,                0x0104, 0x0107},
    {class095SetContextDmaNotifies, 0x0180, 0x0183},
    {class095SetContextDmaA,        0x0184, 0x0187},
    {class095SetContextDmaB,        0x0188, 0x018b},
    {class095SetContextSurface,     0x018c, 0x018f},
    {class095Offset,                0x0308, 0x030f},
    {class095Format,                0x0310, 0x0317},
    {class095Filter,                0x0318, 0x031f},
    {class095Combine0Alpha,         0x0320, 0x0323},
    {class095Combine0Color,         0x0324, 0x0327},
    {class095Combine1Alpha,         0x032c, 0x032f},
    {class095Combine1Color,         0x0330, 0x0333},
    {class095CombineFactor,         0x0334, 0x0337},
    {class095Blend,                 0x0338, 0x033b},
    {class095Control,               0x033c, 0x0347},
    {class095FogColor,              0x0348, 0x034b},
    {class095Tlmtvertex,            0x0400, 0x053f},
    {class095DrawPrimitive,         0x0540, 0x05ff}
};
METHOD Nv15CelsiusPrimitiveMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class096Notify,                0x0104, 0x0107},
    {class096SetWarningEnable,      0x0108, 0x010b},
    //{class096GetState,              0x010c, 0x010f},
    {class096WaitForIdle,           0x0110, 0x0113},
    {class096SyncSetRead,           0x0120, 0x0123},
    {class096SyncSetWrite,          0x0124, 0x0127},
    {class096SyncSetModulo,         0x0128, 0x012b},
    {class096SyncIncrementWrite,    0x012c, 0x012f},
    {class096SyncStall,             0x0130, 0x0133},
    {class096PMTrigger,             0x0140, 0x0143},
    {class096SetContextDmaNotifies, 0x0180, 0x0183},
    {class096SetContextDmaA,        0x0184, 0x0187},
    {class096SetContextDmaB,        0x0188, 0x018b},
    {class096SetContextDmaVertex,   0x018c, 0x018f},
    {class096SetContextDmaState,    0x0190, 0x0193},
    {class096SetContextDmaColor,    0x0194, 0x0197},
    {class096SetContextDmaZeta,     0x0198, 0x019b},
    //...
    // for now, catch anything in between
    {class096MethodCatcher,         0x0200, 0x17ff},
    //...
    {class096InlineArray,           0x1800, 0x1fff},
    {class096DebugInit,             0x2000, 0x2027}
};
METHOD Nv15ImageBlitMethods[] =
{
    {mthdNoOperation,               0x0100, 0x0103},
    {class09FNotify,                0x0104, 0x0107},
    {class09FSyncSetRead,           0x0120, 0x0123},
    {class09FSyncSetWrite,          0x0124, 0x0127},
    {class09FSyncSetModulo,         0x0128, 0x012b},
    {class09FSyncIncrementWrite,    0x012c, 0x012f},
    {class09FSyncStall,             0x0130, 0x0133},
    {class09FSyncIncrementReadRange,0x0134, 0x0137},
    {class09FSetContextDmaNotifies, 0x0180, 0x0183},
    {class09FSetContextColorKey,    0x0184, 0x0187},
    {class09FSetContextClip,        0x0188, 0x018b},
    {class09FSetContextPattern,     0x018c, 0x018f},
    {class09FSetContextRop,         0x0190, 0x0193},
    {class09FSetContextBeta1,       0x0194, 0x0197},
    {class09FSetContextBeta4,       0x0198, 0x019b},
    {class09FSetContextSurfaces2d,  0x019c, 0x019f},
    {class09FSetOperation,          0x02fc, 0x02ff},
    {class09FControlPointIn,        0x0300, 0x0303},
    {class09FControlPointOut,       0x0304, 0x0307},
    {class09FSize,                  0x0308, 0x030b}
};

//
// These classes are supported across all chips.
//
CLASSDESCRIPTOR Common_ClassDescriptors[] =
{
    MKCLASSDECL(TMR_ENGINE_TAG, 0, NV01_TIMER),

    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_COLOR_KEY),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_SCALER),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_FROM_MEMORY),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_COLORMAP),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_VIDEO_SINK),
    MKCLASSDECL(VIDEO_ENGINE_TAG, NO_LOCK, NV_PATCHCORD_VIDEO),

    MKCLASSDECL(DMA_ENGINE_TAG, 0, NV01_CONTEXT_DMA_FROM_MEMORY),
    MKCLASSDECL(DMA_ENGINE_TAG, 0, NV01_CONTEXT_DMA_TO_MEMORY),
    MKCLASSDECL(DMA_ENGINE_TAG, 0, NV01_CONTEXT_DMA_IN_MEMORY),

    MKCLASSDECL(NO_ENGINE, 0, NV01_MEMORY_SYSTEM),
    MKCLASSDECL(NO_ENGINE, 0, NV01_MEMORY_LOCAL_PRIVILEGED),
    MKCLASSDECL(NO_ENGINE, 0, NV01_MEMORY_LOCAL_USER),

    // MAKE THIS LAST !!!!
    MKCLASSDECL(CLASS_PSEUDO_ENGINE_TAG, 0, NV_CLASS),
};

#define NUM_COMMONCLASSDESCRIPTORS          (sizeof (Common_ClassDescriptors) / sizeof (CLASSDESCRIPTOR))

CLASSMETHODS classMethodsTable[] =
{
    {NV1_CLASS,                             NULL, 0},

    {NV1_CONTEXT_DMA_FROM_MEMORY,           NULL, 0},

    {NV1_CONTEXT_DMA_TO_MEMORY,             NULL, 0},

    {NV1_TIMER,                             Nv1TimerMethods,
                                            sizeof(Nv1TimerMethods)/sizeof(METHOD)},

    {NV1_BETA_SOLID,                        Nv1BetaSolidMethods,
                                            sizeof(Nv1BetaSolidMethods)/sizeof(METHOD)},

    {NV1_IMAGE_SOLID,                       Nv1ImageSolidMethods,
                                            sizeof(Nv1ImageSolidMethods)/sizeof(METHOD)},

    {NV1_IMAGE_PATTERN,                     Nv1ImagePatternMethods,
                                            sizeof(Nv1ImagePatternMethods)/sizeof(METHOD)},

    {NV1_IMAGE_BLACK_RECTANGLE,             Nv1ImageRectangleBlackMethods,
                                            sizeof(Nv1ImageRectangleBlackMethods)/sizeof(METHOD)},

    {NV1_RENDER_SOLID_LIN,                  Nv1RenderSolidLinMethods,
                                            sizeof(Nv1RenderSolidLinMethods)/sizeof(METHOD)},

    {NV1_RENDER_SOLID_TRIANGLE,             Nv1RenderSolidTriangleMethods,
                                            sizeof(Nv1RenderSolidTriangleMethods)/sizeof(METHOD)},

    {NV1_RENDER_SOLID_RECTANGLE,            Nv1RenderSolidRectangleMethods,
                                            sizeof(Nv1RenderSolidRectangleMethods)/sizeof(METHOD)},

    {NV1_IMAGE_BLIT,                        Nv1ImageBlitMethods,
                                            sizeof(Nv1ImageBlitMethods)/sizeof(METHOD)},

    {NV1_IMAGE_FROM_CPU,                    Nv1ImageFromCpuMethods,
                                            sizeof(Nv1ImageFromCpuMethods)/sizeof(METHOD)},

    {NV1_NULL,                              NULL, 0},

    {NV3_STRETCHED_IMAGE_FROM_CPU,          Nv3StretchedImageFromCPUMethods,
                                            sizeof(Nv3StretchedImageFromCPUMethods)/sizeof(METHOD)},


    {NV3_SCALED_IMAGE_FROM_MEMORY,          Nv3ScaledImageFromMemoryMethods,
                                            sizeof(Nv3ScaledImageFromMemoryMethods)/sizeof(METHOD)},

                                            
    {NV3_MEMORY_TO_MEMORY_FORMAT,           Nv3MemoryToMemoryFormatMethods,
                                            sizeof(Nv3MemoryToMemoryFormatMethods)/sizeof(METHOD)},
                                            
    {NV1_CONTEXT_DMA_IN_MEMORY,             NULL, 0},

    {NV_CONTEXT_ERROR_TO_MEMORY,            NULL, 0},

    {NV1_CONTEXT_ERROR_TO_MEMORY,           NULL, 0},

    {NV1_MEMORY_PRIVILEGED,                 NULL, 0},

    {NV1_MEMORY_USER,                       NULL, 0},

    {NV3_CONTEXT_ROP,                       Nv3ContextRopMethods,
                                            sizeof(Nv3ContextRopMethods)/sizeof(METHOD)},

    {NV04_VIDEO_LUT_CURSOR_DAC,             Nv04VideoLUTCursorDACMethods,
                                            sizeof(Nv04VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV04_VIDEO_OVERLAY,                    Nv04VideoOverlayMethods,
                                            sizeof(Nv04VideoOverlayMethods)/sizeof(METHOD)},

    {NV3_DX3_TEXTURED_TRIANGLE,             Nv3DX3TexturedTriangleMethods,
                                            sizeof(Nv3DX3TexturedTriangleMethods)/sizeof(METHOD)},

    {NV05_VIDEO_LUT_CURSOR_DAC,             Nv05VideoLUTCursorDACMethods,        
                                            sizeof(Nv05VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV3_GDI_RECTANGLE_TEXT,                Nv3GDIRectangleTextMethods,   
                                            sizeof(Nv3GDIRectangleTextMethods)/sizeof(METHOD)},

    {NV03_EXTERNAL_VIDEO_DECODER,           Nv3ExternalVideoDecoderMethods,
                                            sizeof(Nv3ExternalVideoDecoderMethods)/sizeof(METHOD)},

    {NV3_EXTERNAL_VIDEO_DECOMPRESSOR,       Nv3ExternalVideoDecompressorMethods,   
                                            sizeof(Nv3ExternalVideoDecompressorMethods)/sizeof(METHOD)},

    {NV1_EXTERNAL_PARALLEL_BUS,             Nv1ExternalParallelBusMethods,
                                            sizeof(Nv1ExternalParallelBusMethods)/sizeof(METHOD)},

    {NV3_EXTERNAL_MONITOR_BUS,              Nv3ExternalMonitorBusMethods,
                                            sizeof(Nv3ExternalMonitorBusMethods)/sizeof(METHOD)},

    {NV3_EXTERNAL_SERIAL_BUS,               Nv4ExternalSerialBusMethods,
                                            sizeof(Nv4ExternalSerialBusMethods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_0,                 Nv3ContextSurface0Methods,
                                            sizeof(Nv3ContextSurface0Methods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_1,                 Nv3ContextSurface1Methods,   
                                            sizeof(Nv3ContextSurface1Methods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_2,                 Nv3ContextSurface2Methods,   
                                            sizeof(Nv3ContextSurface2Methods)/sizeof(METHOD)},

    {NV3_CONTEXT_SURFACE_3,                 Nv3ContextSurface3Methods,   
                                            sizeof(Nv3ContextSurface3Methods)/sizeof(METHOD)},

    {NV4_DVD_SUBPICTURE,                    Nv4DvdSubpictureMethods,
                                            sizeof(Nv4DvdSubpictureMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_SURFACES_2D,               Nv4ContextSurfaces2DMethods,
                                            sizeof(Nv4ContextSurfaces2DMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_PATTERN,                   Nv4ContextPatternMethods,
                                            sizeof(Nv4ContextPatternMethods)/sizeof(METHOD)},

    {NV4_GDI_RECTANGLE_TEXT,                Nv4GDIRectangleTextMethods,
                                            sizeof(Nv4GDIRectangleTextMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_SURFACE_SWIZZLED,          Nv4ContextSurfaceSwizzledMethods,
                                            sizeof(Nv4ContextSurfaceSwizzledMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_SURFACES_ARGB_ZS,          Nv4ContextSurfacesArgbZsMethods,
                                            sizeof(Nv4ContextSurfacesArgbZsMethods)/sizeof(METHOD)},

    {NV4_DX5_TEXTURED_TRIANGLE,             Nv4DX5TexturedTriangleMethods,
                                            sizeof(Nv4DX5TexturedTriangleMethods)/sizeof(METHOD)},

    {NV4_DX6_MULTI_TEXTURE_TRIANGLE,        Nv4DX6MultiTextureTriangleMethods,
                                            sizeof(Nv4DX6MultiTextureTriangleMethods)/sizeof(METHOD)},

    {NV10_CELSIUS_PRIMITIVE,                Nv10CelsiusPrimitiveMethods,
                                            sizeof(Nv10CelsiusPrimitiveMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_COLOR_KEY,                 Nv4ContextColorKeyMethods,
                                            sizeof(Nv4ContextColorKeyMethods)/sizeof(METHOD)},

    {NV4_RENDER_SOLID_LIN,                  Nv4RenderSolidLinMethods,
                                            sizeof(Nv4RenderSolidLinMethods)/sizeof(METHOD)},

    {NV4_RENDER_SOLID_TRIANGLE,             Nv4RenderSolidTriangleMethods,
                                            sizeof(Nv4RenderSolidTriangleMethods)/sizeof(METHOD)},

    {NV4_RENDER_SOLID_RECTANGLE,            Nv4RenderSolidRectangleMethods,
                                            sizeof(Nv4RenderSolidRectangleMethods)/sizeof(METHOD)},

    {NV4_IMAGE_BLIT,                        Nv4ImageBlitMethods,
                                            sizeof(Nv4ImageBlitMethods)/sizeof(METHOD)},

    {NV4_INDEXED_IMAGE_FROM_CPU,            Nv4IndexedImageFromCpuMethods,   
                                            sizeof(Nv4IndexedImageFromCpuMethods)/sizeof(METHOD)},

    {NV4_IMAGE_FROM_CPU,                    Nv4ImageFromCpuMethods,   
                                            sizeof(Nv4ImageFromCpuMethods)/sizeof(METHOD)},

    {NV05_SCALED_IMAGE_FROM_MEMORY,         Nv5ScaledImageFromMemoryMethods,   
                                            sizeof(Nv5ScaledImageFromMemoryMethods)/sizeof(METHOD)},

    {NV05_INDEXED_IMAGE_FROM_CPU,           Nv5IndexedImageFromCpuMethods,
                                            sizeof(Nv5IndexedImageFromCpuMethods)/sizeof(METHOD)},

    {NV05_IMAGE_FROM_CPU,                   Nv5ImageFromCpuMethods,
                                            sizeof(Nv5ImageFromCpuMethods)/sizeof(METHOD)},

    {NV05_STRETCHED_IMAGE_FROM_CPU,         Nv5StretchedImageFromCpuMethods,
                                            sizeof(Nv5StretchedImageFromCpuMethods)/sizeof(METHOD)},

    {NV10_VIDEO_LUT_CURSOR_DAC,             Nv10VideoLUTCursorDACMethods,
                                            sizeof(Nv10VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV4_CONTEXT_BETA,                      Nv4ContextBetaMethods,
                                            sizeof(Nv4ContextBetaMethods)/sizeof(METHOD)},

    {NV4_STRETCHED_IMAGE_FROM_CPU,          Nv4StretchedImageFromCpuMethods,
                                            sizeof(Nv4StretchedImageFromCpuMethods)/sizeof(METHOD)},

    {NV4_SCALED_IMAGE_FROM_MEMORY,          Nv4ScaledImageFromMemoryMethods,
                                            sizeof(Nv4ScaledImageFromMemoryMethods)/sizeof(METHOD)},

    {NV_VIDEO_COLOR_KEY,                    NvVideoColorKeyMethods,
                                            sizeof(NvVideoColorKeyMethods)/sizeof(METHOD)},

    {NV_VIDEO_SCALER,                       NvVideoScalerMethods,
                                            sizeof(NvVideoScalerMethods)/sizeof(METHOD)},

    {NV_VIDEO_FROM_MEMORY,                  NvVideoFromMemoryMethods,
                                            sizeof(NvVideoFromMemoryMethods)/sizeof(METHOD)},

    {NV_VIDEO_COLORMAP,                     NvVideoColormapMethods,   
                                            sizeof(NvVideoColormapMethods)/sizeof(METHOD)},

    {NV_VIDEO_SINK,                         NvVideoSinkMethods,   
                                            sizeof(NvVideoSinkMethods)/sizeof(METHOD)},

    {NV_PATCHCORD_VIDEO,                    NvPatchcordMethods,
                                            sizeof(NvPatchcordMethods)/sizeof(METHOD)},

    {NV_CONTEXT_DMA_IN_MEMORY,              NvDmaInMemoryMethods,
                                            sizeof(NvDmaInMemoryMethods)/sizeof(METHOD)},
                                            
    {NV_CONTEXT_DMA_TO_MEMORY,              NvDmaToMemoryMethods,
                                            sizeof(NvDmaToMemoryMethods)/sizeof(METHOD)},
                                            
    {NV_CONTEXT_DMA_FROM_MEMORY,            NvDmaFromMemoryMethods,
                                            sizeof(NvDmaFromMemoryMethods)/sizeof(METHOD)},
                                            
    {NV10_CONTEXT_SURFACES_2D,              Nv10ContextSurfaces2DMethods,
                                            sizeof(Nv10ContextSurfaces2DMethods)/sizeof(METHOD)},

    {NV10_VIDEO_OVERLAY,                    Nv10VideoOverlayMethods,
                                            sizeof(Nv10VideoOverlayMethods)/sizeof(METHOD)},

    {NV10_TEXTURE_FROM_CPU,                 Nv10TextureFromCpuMethods,
                                            sizeof(Nv10TextureFromCpuMethods)/sizeof(METHOD)},

    {NV15_VIDEO_LUT_CURSOR_DAC,             Nv15VideoLUTCursorDACMethods,
                                            sizeof(Nv15VideoLUTCursorDACMethods)/sizeof(METHOD)},

    {NV10_DVD_SUBPICTURE,                   Nv10DvdSubpictureMethods,
                                            sizeof(Nv10DvdSubpictureMethods)/sizeof(METHOD)},
                                            
    {NV10_SCALED_IMAGE_FROM_MEMORY,         Nv10ScaledImageFromMemoryMethods,
                                            sizeof(Nv10ScaledImageFromMemoryMethods)/sizeof(METHOD)},
                                            
    {NV10_IMAGE_FROM_CPU,                   Nv10ImageFromCpuMethods,
                                            sizeof(Nv10ImageFromCpuMethods)/sizeof(METHOD)},

    {NV10_CONTEXT_SURFACES_3D,              Nv10ContextSurfaces3DMethods,   
                                            sizeof(Nv10ContextSurfaces3DMethods)/sizeof(METHOD)},

    {NV10_DX5_TEXTURED_TRIANGLE,            Nv10DX5TexturedTriangleMethods,
                                            sizeof(Nv10DX5TexturedTriangleMethods)/sizeof(METHOD)},

    {NV10_DX6_MULTI_TEXTURE_TRIANGLE,       Nv10DX6MultiTextureTriangleMethods,
                                            sizeof(Nv10DX6MultiTextureTriangleMethods)/sizeof(METHOD)},

    {NV15_CELSIUS_PRIMITIVE,                Nv15CelsiusPrimitiveMethods,
                                            sizeof(Nv15CelsiusPrimitiveMethods)/sizeof(METHOD)},

    {NV15_IMAGE_BLIT,                       Nv15ImageBlitMethods,
                                            sizeof(Nv15ImageBlitMethods)/sizeof(METHOD)},

    // NV11 and NV15 Celsius share the same method struct.
    {NV11_CELSIUS_PRIMITIVE,                Nv15CelsiusPrimitiveMethods,
                                            sizeof(Nv15CelsiusPrimitiveMethods)/sizeof(METHOD)},

    {NV20_VIDEO_LUT_CURSOR_DAC,             Nv20VideoLUTCursorDACMethods,
                                            sizeof(Nv20VideoLUTCursorDACMethods)/sizeof(METHOD)},

    //
    // MAKE THIS LAST!!!
    //                                     
    {NV_CLASS,                              NvClassMethods,
                                            sizeof(NvClassMethods)/sizeof(METHOD)},
};

#define CLASSMETHODSTABLE_SIZE              (sizeof(classMethodsTable) / sizeof(CLASSMETHODS))

//---------------------------------------------------------------------------
//
//  Class table access.
//
//---------------------------------------------------------------------------

RM_STATUS classGetClass
(
    PCLASSDB pClassDB,
	U032 classNum, 
	PCLASS *ppClass
)
{
    U032 i;

	for (i = 0; i < pClassDB->numClasses; i++)
    {
		if (pClassDB->pClasses[i].Type == classNum)
        {
			*ppClass = &pClassDB->pClasses[i];
			return RM_OK;
        }
    }

	return RM_ERROR;
}

//
// classGetInfo
//
// This routine sets up method handling for the specified class
// It also binds the class to a a particular engine.
//
RM_STATUS classGetInfo
(
    PENGINEDB pEngineDB, 
    PCLASSDB pClassDB,
    PCLASS pClass
)
{
    U032 classNum;
    PENGINEINFO pEngineInfo;
    PENGINEDESCRIPTOR pEngineDecl;
    U032 engine;
	U032 i;

    //
    // Get class number and engine tag.
    //
    classNum = CLASSDECL_FIELD(*pClass->ClassDecl, _CLASS);
    engine = CLASSDECL_FIELD(*pClass->ClassDecl, _TAG);

    //
    // Wire up engine data first.
    //
    if (engineGetInfo(pEngineDB, engine, &pEngineInfo, &pEngineDecl) != RM_OK)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: classGetInfo: bad engine tag ", engine);
        return RM_ERROR;
    }

    pClass->EngineDecl = pEngineDecl;
    pClass->EngineInfo = pEngineInfo;

    //
    // Now wire up method routines.
    //
    for (i = 0; i < CLASSMETHODSTABLE_SIZE; i++)
    {
        if (classMethodsTable[i].Type == classNum)
        {
            pClass->Method = classMethodsTable[i].Method;
            pClass->MethodMax = classMethodsTable[i].MethodMax;
            break;
        }
    }

    //
    // If we don't have an entry in the resman method table for the
    // given class, then use the engine-specific default table
    // (usually just filled with a hardware method stub).
    //
    if (i == CLASSMETHODSTABLE_SIZE)
    {
        pClass->Method = pEngineInfo->Methods;
        pClass->MethodMax = pEngineInfo->MethodMax;
    }
    
	return RM_OK;
}

//
// classBuildDB
//
// This routine generates the class database for the
// specified device.
//
RM_STATUS classBuildDB
(
    PENGINEDB pEngineDB,
    PCLASSDB pClassDB
)
{
    PCLASS pClass;
    PCLASSDESCRIPTOR pClassDesc;
    U032 numClasses;
    U032 i, j;
    RM_STATUS status;

    //
    // Calculate number of classes supported by this device.
    //
    // For now, just add the size of the common class descriptor
    // table to the number of class descriptors in the pClassDB table (we
    // should probably allow for overlaps between the two).
    //
    j = 0;
    for (i = 0; i < pClassDB->numClassDescriptors; i++)
    {
        if (CLASSDECL_FIELD(pClassDB->pClassDescriptors[i], _OPCODE) == CLASSDECL_INSTR)
            j++;
            
    }

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: nvInfo class descriptors ",  j);

    numClasses = NUM_COMMONCLASSDESCRIPTORS + j;

    //
    // Allocate space for correct number of entries.
    //
    status = osAllocMem((VOID **)&pClass, sizeof (CLASS) * numClasses);
    if (status)
        return status;

    //
    // Load up the fixed (common) classes.
    //
    pClassDesc = &Common_ClassDescriptors[0];
    for (i = 0; i < NUM_COMMONCLASSDESCRIPTORS; i++)
    {
        pClass[i].Type = CLASSDECL_FIELD(pClassDesc[i], _CLASS);
        pClass[i].ClassDecl = &pClassDesc[i];
        status = classGetInfo(pEngineDB, pClassDB, &pClass[i]);
        if (status != RM_OK)
        {
            //
            // This shouldn't happen; treat as a fatal error.
            //
            osFreeMem((VOID *)pClass);
            return (RM_ERROR);
        }
    }

    //
    // Load up chip-dependent classes.
    //
    pClassDesc = &pClassDB->pClassDescriptors[0];
    for (i = NUM_COMMONCLASSDESCRIPTORS, j = 0; i < numClasses; i++)
    {
        //
        // Advance to next class descriptor header
        // (i.e. skip over any class extension descriptors).
        //
        while (CLASSDECL_FIELD(pClassDesc[j], _OPCODE) != CLASSDECL_INSTR)
            j++;
        pClass[i].Type = CLASSDECL_FIELD(pClassDesc[j], _CLASS);
        pClass[i].ClassDecl = &pClassDesc[j];
        if (CLASSDECL_FIELD(pClassDesc[++j], _OPCODE) == CLASSINSTMALLOC_INSTR)
            pClass[i].ClassInstMalloc = &pClassDesc[j];
        else
            pClass[i].ClassInstMalloc = NULL;
        
        status = classGetInfo(pEngineDB, pClassDB, &pClass[i]);
        if (status != RM_OK)
        {
            //
            // This shouldn't happen; treat as a fatal error.
            //
            osFreeMem((VOID *)pClass);
            return (RM_ERROR);
        }
    }

    pClassDB->pClasses = pClass;
    pClassDB->numClasses = numClasses;

    return (RM_OK);
}

RM_STATUS classDestroyDB
(
    PCLASSDB  pClassDB
)
{
    osFreeMem((VOID *)pClassDB->pClasses);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Class object initial creation.
//
//---------------------------------------------------------------------------

RM_STATUS classCreateWellKnownObjects
(
    PHWINFO pDev,
    U032    ChID
)
{
    RM_STATUS    status;
    U032         i;
    U032         j;
    PCLASSDB pClassDB;
    PCLASSOBJECT ClassObject;
    PCLASSOBJECT *ClassObjects;
    PRENDERCOMMONOBJECT nullObject;
    PCLASS classTable;
#ifdef LEGACY_ARCH
    PDMAOBJECT   ErrNotifier;
#endif

    pClassDB = &pDev->classDB;

    //
    // Create and initialize all CLASS objects.  These are the master
    // class instances for this particular channel.  All user objects
    // created in this channel will be children of these master class
    // objects.
    //
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: numClasses ", pClassDB->numClasses);

    //
    // Allocate ClassObjects[] table.
    //
    status = osAllocMem((VOID **)&ClassObjects, sizeof (PCLASSOBJECT) * pClassDB->numClasses);
    if (status)
        return (status);

    classTable = pClassDB->pClasses;
    for (i = 0; i < pClassDB->numClasses; i++)
    {
        status = osAllocMem((VOID **)&ClassObject, sizeof (CLASSOBJECT));
        if (status)
        {
            while (i)
                osFreeMem(ClassObjects[--i]);
            osFreeMem(ClassObjects);
            return status;
        }

        //
        // Init global state.
        //
        ClassObjects[i]                 = ClassObject;
        ClassObject->Base.Name          = classTable[i].Type;
        //ClassObject->Base.Class         = &(classTable[i]);
        ClassObject->Base.Class         = &(classTable[NUM_COMMONCLASSDESCRIPTORS-1]);
        ClassObject->Base.ThisClass     = &(classTable[i]);
        ClassObject->Base.ChID          = ChID;
        ClassObject->Base.NotifyXlate   = NULL;
        ClassObject->Base.NotifyAction  = 0;
        ClassObject->Base.NotifyTrigger = 0;
        ClassObject->Base.NotifyEvent   = NULL;

        //
        // Add object into FIFO object tree.
        //
        status = fifoAddObject(pDev, (POBJECT)ClassObject);
        if (status != RM_OK)
        {
            while (i)
                osFreeMem(ClassObjects[--i]);
            osFreeMem(ClassObjects);
            return (status);
        }
    }

    //
    // Create and initialize NV_ERROR_NOTIFIER.
    //
    // jsw: this is no longer necessary with the new architecture
    //      error notifiers are explicitly created.
#ifdef LEGACY_ARCH
    // Find the DMA_TO_MEM master class object first.
    //
    j = 0;
    while ((j < pClassDB->numClasses) && (ClassObjects[j]->Base.Name != NV_CONTEXT_DMA_TO_MEMORY))
        j++;
    if (j == pClassDB->numClasses)
    {
        // Kinda silly error, but just in case we can't find the class
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        return (status);
    }
    //
    // Now create our instance
    //
    status = dmaCreate(pDev, ClassObjects[j], NV_CONTEXT_ERROR_TO_MEMORY, (POBJECT *)&ErrNotifier, NULL);
    if (status)
    {
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        dmaDelete((VOID*)pDev, (POBJECT)ErrNotifier);
        return (status);
    }
    ErrNotifier->Base.Name          = NV_CONTEXT_ERROR_TO_MEMORY;
    ErrNotifier->Base.Class         = &(classTable[j]);
    ErrNotifier->Base.ThisClass     = &(classTable[j]);
    ErrNotifier->Base.ChID          = ChID;
    ErrNotifier->Base.NotifyXlate   = NULL;
    ErrNotifier->Base.NotifyAction  = 0;
    ErrNotifier->Base.NotifyTrigger = 0;
    ErrNotifier->Base.NotifyEvent   = NULL;
    if ((status = fifoAddObject(pDev, (POBJECT)ErrNotifier)) != RM_OK)
    {
        dmaDelete((VOID*)pDev, (POBJECT)ErrNotifier);
        //return (status);
    }
#endif

    //
    // Create and initialize NV1_NULL_OBJECT.
    //
    // Find the NV1_NULL master class object first.
    //
    j = 0;
    while ((j < pClassDB->numClasses) && (ClassObjects[j]->Base.Name != NV1_NULL))
        j++;

    if (j == pClassDB->numClasses)
    {
        // Kinda silly error, but just in case we can't find the class
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        return (status);
    }       

    //
    // Now create our instance
    // 
    status = grCreateObj(pDev, ClassObjects[j], 0, (POBJECT *)&nullObject, NULL);
    if (status)
    {
        while (i)
            osFreeMem(ClassObjects[--i]);
        osFreeMem(ClassObjects);
        grDestroyObj(pDev, (POBJECT)nullObject);
        return (status);
    }

    if ((status = fifoAddObject(pDev, (POBJECT)nullObject)) != RM_OK)
    {
        grDestroyObj(pDev, (POBJECT)nullObject);
        //return (status);
    }

    osFreeMem(ClassObjects);

    return (RM_OK);
}

RM_STATUS classDeleteWellKnownObjects
(
    VOID*   pDevHandle,
    POBJECT Object
)
{
    return (osFreeMem(Object));
}

RM_STATUS classInitCommonObject
(
    POBJECT pObject,
    PCLASSOBJECT pClassObject,
    U032 Name
)
{
    PCOMMONOBJECT pCommonObject;

    //
    // Initialize base object data.
    //
    pCommonObject = (PCOMMONOBJECT)pObject;

    pCommonObject->Base.Name = Name;
    pCommonObject->Base.ChID = pClassObject->Base.ChID;
    pCommonObject->Base.Class = pClassObject->Base.ThisClass;
    pCommonObject->Base.ThisClass = pClassObject->Base.ThisClass;
    pCommonObject->Base.NotifyXlate   = NULL;
    pCommonObject->Base.NotifyAction  = 0;
    pCommonObject->Base.NotifyTrigger = 0;
    pCommonObject->Base.NotifyEvent   = NULL;

    //
    // Initialize common object data.
    //
    pCommonObject->Valid            = FALSE;
    pCommonObject->NotifyPending    = FALSE;
    pCommonObject->Instance         = 0;
    pCommonObject->NotifyObject     = NULL;
    pCommonObject->Dma0Object       = NULL;
    pCommonObject->Dma1Object       = NULL;

    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  NOP methods.
//
//---------------------------------------------------------------------------

RM_STATUS nopCreate
(
    VOID*        pDevHandle,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *UserObject,
    VOID*        pCreateParms
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Class not implemented yet: ", ClassObject->Base.Class->Type);
    return (RM_ERR_CREATE_BAD_CLASS);
}
RM_STATUS nopDelete
(
    PHWINFO pDev,
    POBJECT Object
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Class not implemented yet: ", Object->Class->Type);
    return (RM_ERR_DELETE_BAD_CLASS);
}
RM_STATUS mthdNoOperation
(
    PHWINFO pDev,
    POBJECT Object,
    PMETHOD Method,
    U032    Offset,
    U032    Data
)
{
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: Method NoOperation", Object->Class->Type);
    return (RM_OK);
}

//---------------------------------------------------------------------------
//
//  Create object.
//
//---------------------------------------------------------------------------

RM_STATUS classCreate
(
    VOID*        pDev,
    PCLASSOBJECT ClassObject,
    U032         UserName,
    POBJECT     *UserObject,
    VOID*        pCreateParms
)
{
    //
    // Class specific create procedure.
    //

    DBG_VAL_PTR(ClassObject);
    return ((*(ClassObject->Base.ThisClass->EngineInfo->CreateObject))(pDev, ClassObject, UserName, UserObject, pCreateParms)); //KJK YUCK!!
}

//---------------------------------------------------------------------------
//
//  Destroy object.
//
//---------------------------------------------------------------------------

RM_STATUS classDestroy
(
    VOID*   pDev,
    POBJECT Object
)
{
    //
    // Class specific delete procedure.
    //
    DBG_VAL_PTR(Object);
    return ((*(Object->Class->EngineInfo->DestroyObject))(pDev, Object));    //KJK YUCK!!
}

//---------------------------------------------------------------------------
//
//  Software methods.
//  Emulate the device access in software.
//
//---------------------------------------------------------------------------

RM_STATUS classSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032    Offset,
    V032    Data
)
{
    RM_STATUS  status;
    U032       i;

    NVRM_TRACE3('SWMT',
                (Object->ChID << 24) | (Object->Subchannel << 16) | (*Object->Class->ClassDecl & 0xffff),
                Object->Name);
    NVRM_TRACE2(Offset, Data);

#if DEBUG
    //
    // Reject unaligned accesses.
    //
    if (Offset & 0x0003)
        return (RM_ERR_FIFO_BAD_ACCESS);
#endif // DEBUG
    if (Object != NULL)
    {
        //
        // Search for object method.
        //
        DBG_VAL_PTR(Object);
        for (i = 0; i < Object->Class->MethodMax; i++)
        {
            if ((Offset >= Object->Class->Method[i].Low)
            &&  (Offset <  Object->Class->Method[i].High))
            {

                status = Object->Class->Method[i].Proc(pDev,
                                                       Object,
                                                       &(Object->Class->Method[i]),
                                                       Offset,
                                                       Data);
                //
                // Send completion notification.
                //
                notifyMethodComplete(pDev, Object, Offset, Data, status);
                NVRM_TRACE2('swmt', status);
                return (status);
            }
        }
        //
        // Method not found, so report the error if notify pending.
        //
        NVRM_TRACE_ERROR('swmt', RM_ERR_FIFO_BAD_ACCESS);
        notifyMethodComplete(pDev, Object, Offset, Data, RM_ERR_FIFO_BAD_ACCESS);
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "NVRM: invalid access ", RM_ERROR);
    if (Object)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              object ", Object->Class->Type);
    }
    else
    {
        DBG_PRINT_STRING(DEBUGLEVEL_USERERRORS, "              object NULL");
    }
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "              offset ", Offset);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_USERERRORS, "                data ", Data);
    return (RM_ERR_FIFO_BAD_ACCESS);
}

//
// SMP wrapper for classSoftwareMethod
//
RM_STATUS classDirectSoftwareMethod
(
    PHWINFO pDev,
    POBJECT Object,
    U032    Offset,
    V032    Data
)
{
    RM_STATUS status;

    osEnterCriticalCode(pDev);
    status = classSoftwareMethod(pDev, Object, Offset, Data);
    osExitCriticalCode(pDev);

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\class\nv\nvde.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** NVDE ****************************************\
*                                                                           *
* Module: NVDE.C                                                            *
*     NVDE methods                                                          *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <class.h>
#include <modular.h>
#include <event.h>

RM_STATUS NvdeAlloc
(
    U032            Name,
    VOID*           pCreateParms
)
{
    PRMINFO pRmInfo = &NvRmInfo;
    RM_STATUS status;
    POBJECT pObject;
    PNVDEOBJECT pNvdeObject;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvdeAlloc\r\n");

    //
    // Make sure an NVDE object isn't already in use
    //
    if (pRmInfo->Debugger.object)
        return (NVDE_STATUS_ERROR_STATE_IN_USE);

    //
    // Allocate space for the object.
    //
    status = osAllocMem((VOID **)&pObject, sizeof(NVDEOBJECT));
    if (status)
        return (status);

    //
    // Set some default state.
    //
    pObject->Name = Name;
    pObject->ChID = 0;
    pObject->Class = NULL;
    pObject->ThisClass = NULL;
    pObject->Subchannel = NULL;
    pObject->Next = NULL;
    pObject->NotifyXlate = NULL;
    pObject->NotifyAction = 0;
    pObject->NotifyTrigger = 0;
    pObject->NotifyEvent = 0;

    //
    // Save off the event parameters.
    //
    pNvdeObject = (PNVDEOBJECT)pObject;
    pNvdeObject->EventHandle = ((NVDE_ALLOCATION_PARAMETERS*)pCreateParms)->EventHandle;
    pNvdeObject->EventClass = ((NVDE_ALLOCATION_PARAMETERS*)pCreateParms)->EventClass;
    pNvdeObject->EventBufferCount = 0;

    //
    // Queue up event...
    //
    status = eventSetObjectEventNotify(pObject, 0, 0, pNvdeObject->EventClass,  pNvdeObject->EventHandle);

    //
    // Set the pointer so we know a NVDE object is in use
    //
    if (status == RM_OK)
        pRmInfo->Debugger.object = (POBJECT) pObject;

    return status;
}


RM_STATUS NvdeFree
(
    U032 Client,
    U032 Object
)
{
    PRMINFO pRmInfo = &NvRmInfo;
    PNVDEOBJECT pNvdeObject = (PNVDEOBJECT)pRmInfo->Debugger.object;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: nvdeFree\r\n");

    if (pNvdeObject == NULL)
        return RM_OK;

    //
    // Assert that the handles match.
    //
    if (pNvdeObject->Common.Base.Name != Object)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: bad debugger object handle ", Object);
        return RM_ERROR;
    }

    //
    // Unplug event.  Handle is 0 for now since we only support
    // a single debugger event.
    //
    eventRemoveObjectEventNotify((POBJECT)pNvdeObject, 0);

    //
    // Clear out the NVDE object pointer so we know it's not in use
    //
    pRmInfo->Debugger.object = (POBJECT)NULL;

    return (osFreeMem(pNvdeObject));
}

V032 NvdeAppendEventForDebugger
(
    PNVDEOBJECT pDebugger,
    U032        code,
    U032        flags,
    U032        param1,
    U032        param2,
    U032        param3,
    U032        param4,
    U032        param5,
    U032        param6
)
{
    PNVDEEVENT event;

    if (pDebugger->EventBufferCount >= NVDE_MAX_EVENTS)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Too many NVDE events to buffer.\n\r");
        return 0;
    }
    
    event           = pDebugger->EventBuffer + pDebugger->EventBufferCount;
    event->code     = code;
    event->flags    = flags;
    event->param[0] = param1;
    event->param[1] = param2;
    event->param[2] = param3;
    event->param[3] = param4;
    event->param[4] = param5;
    event->param[5] = param6;

    pDebugger->EventBufferCount++;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dac.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Manager ******************************\
*                                                                           *
* Module: DAC.C                                                             *
*   The DAC control management is updated here.                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include <i2c.h>
#include "nvhw.h"
#include <vga.h>
#include <nvcm.h>
#include <edid.h>
#include <tv.h>
#include <devinit.h>
#include <smp.h>
#include <stddef.h>    // for size_t

/* This file simulates the NV arbitor */
#include <arb_fifo.h>


// Const strings for accessing the registry

extern U008    CH_Init[];
// The "leaf" subkeys are OS-independent

#ifdef NTRM    
char strDisplayType[] = "Display Type";
char strDisplay2Type[] = "Display2 Type";
char strTVtype[] = "TV Type";
char strTVOutType[] = "TV Out";
char    strFpMode[] = "FlatPanelMode";
#else
extern char strDisplayType[];
extern char strDisplay2Type[];
extern char strTVtype[];
extern char strTVOutType[];
extern char strFpMode[];
#endif // NTRM

extern char strDevNodeRM[];

#define RED_OUT_300MV	0x800001A0
#define MAXCRTRETRIES   5

// remove this after all drivers switch to the new devices based API.
static BOOL using_new_api = FALSE;

//
// Set Display Power Managememnt Level.
//
RM_STATUS dacSetDpmLevel
(
    PHWINFO      pDev
)
{
    switch (pDev->Dac.DpmLevel)
    {
        default:
            break;
    }
    return (RM_OK);
}

RM_STATUS dacLoadWidthDepth
(
   PHWINFO pDev,
   U032    Head
)
{
    U032 data;

    switch (pDev->Dac.HalInfo.Depth)
    {
        case 8:
            data = NV_CIO_CRE_PIXEL_FORMAT_8BPP;
            break;
        case 15:
        case 16:
            data = NV_CIO_CRE_PIXEL_FORMAT_16BPP;
            break;
        case 24:
        case 30:
        case 32:
        default:
            data = NV_CIO_CRE_PIXEL_FORMAT_32BPP;
            break;
    }
    //
    // Write the CRTC register
    //
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

    return (RM_OK);
}

//
// Find closest DAC PLL parameters for a given frequency.
//
RM_STATUS dacCalcPLL
(
    PHWINFO pDev 
)
{
    U032 DeltaNew;
    U032 DeltaOld;
    U032 VClk;
    U032 Freq;
    U032 M;
    U032 N;
    U032 P;

    //
    // Calc VPLL.
    //
    DeltaOld = 0xFFFFFFFF;
    VClk     = pDev->Dac.HalInfo.VClk / 1000;
    //
    // Calculate frequencies using KHz to keep the math precision inside 32 bits.
    //
    for (P = 1; P <= 8; P <<= 1)
    {
        Freq = VClk * P;
        //
        // Bound the parameters to the internal frequencies of the DAC.
        //
        if ((Freq >= 64000) && (Freq <= 170000))
        {
            for (M = 7; M <= 12; M++)
            {
                N    = VClk * P * M / 12096;
                Freq = N * 12096 / P / M;
                if (Freq > VClk)
                    DeltaNew = Freq - VClk;
                else
                    DeltaNew = VClk - Freq;
                if (DeltaNew < DeltaOld)
                {
                    //
                    // Closer match.
                    //
                    pDev->Dac.HalInfo.VPllM = M;
                    pDev->Dac.HalInfo.VPllN = N;
                    pDev->Dac.HalInfo.VPllO = 1;
                    if (P==8)
                        pDev->Dac.HalInfo.VPllP = 3;
                    else if (P==4)
                        pDev->Dac.HalInfo.VPllP = 2;
                    else if (P==2)
                        pDev->Dac.HalInfo.VPllP = 1;
                    else 
                        pDev->Dac.HalInfo.VPllP = 0;
                    DeltaOld = DeltaNew;
                }
            }
        }
    }
    return (RM_OK);
}


//
//       dacCalcMNP - Return the PLL values for a specified frequency
//
//          Clock frequency in MHz * 100
//
// The algorithm is constrained to keep within 0.5% error
// to remain inside the VBE spec.
// However, if you have a choice of what frequencies you
// request, try to avoid the following requested frequencies
// when you get above 300MHz, as they require M values > 3.
//
//  14.31818 MHz
// 29739 - 29918
// 30219 - 30393
// 31178 - 31343
// 31658 - 31818
// 32617 - 32767
// 33097 - 33243
// 34056 - 34193
// 34536 - 34668
//
//  13.5000 MHz
// 29397 - 29552
// 29849 - 30000
// 30754 - 30896
// 31206 - 31344
// 32110 - 32239
// 32563 - 32767
// 33467 - 33582
// 33919 - 34030
// 34824 - 34926
//
U032 dacCalcMNP(
    PHWINFO  pDev,
    U032     Head,
    U032     Clock,
    U032    *M,    
    U032    *N,    
    U032    *P    
)
{
    U016  crystalFreq;
    U032  vclk;
    U016  vclkClosest = 0;
    U016  deltaOld;
    U016  bestM = 0;
    U016  bestP = 0;
    U016  bestN = 0;
    U016  lowM;
    U016  highM;
    U016  lowP, highP;
    U032  hiVclk1, hiVclk2, hiVclk3;
    U032  FminVco, FmaxVco;
    
    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032  lwv, lwv2;
    
    U016  lwvs, vclks;
    U016  t;
    
    vclk = (U032)(Clock * 10);     // Make KHz
    
    deltaOld = 0xFFFF;

    //
    // NV11 needs four highM buckets due to
    // induced jitter into the PLL's
    //
    if (IsNV11(pDev))
    {
        hiVclk1 = 150000;
        hiVclk2 = 200000;
        hiVclk3 = 340000;
    }
    else
    {
        hiVclk1 = 250000;
        hiVclk2 = 340000;

    }

    lowP  = 0;
    highP = 4;

    // if initDac() has run then FminVco and FmaxVco will be set.
    // But we might be called during devinit processing prior to
    //    initDac(), so we need a fallback...
    // NOTE: these defaults duplicated in initDac()
    if ((pDev->Dac.FminVco == 0) || (pDev->Dac.FmaxVco == 0))
    {
        if (IsNV15orBetter(pDev)) {
            if (IsNV15MaskRevA01(pDev))
                pDev->Dac.FminVco = 200000;
            else
                pDev->Dac.FminVco = 250000;
            
            pDev->Dac.FmaxVco = pDev->Dac.FminVco * 2; 
        } else {
            pDev->Dac.FminVco = 128000;
            pDev->Dac.FmaxVco = 256000;
        }
    }
    
    FminVco = pDev->Dac.FminVco;
    FmaxVco = pDev->Dac.FmaxVco;

    //
    // NV11 requires a modified Vco range, and since the BIOS's are already 
    // out in the field, shortcircuit this nice feature to fix the noise issue.
    //
    // When we're sure all older BIOS's have been flushed out of the world
    // (need 3.11.01.25.00+), this code can be removed.  If we detect a newer
    // BIOS revision is in use, use those values.
    //
    // Mobile NV11 has always used these ranges, so this should not be a change
    // for them.
    //
    if (IsNV11(pDev) && (pDev->Chip.BiosRevision <= 0x03110125))
    {
        FminVco = 200000;
        FmaxVco = 400000;
    }

    // Apply any adjusts needed to FminVco/FmaxVco.
    //
    // 1). Make sure vclk is not so low that we'll miss the whole VCO range.
    //     Adjust FminVco to hit with the highest P (post divide).
    //
    if ((vclk << highP) < FminVco)
        FminVco = vclk << highP;

    //
    // 2). Also, check if two consecutive P values would cause us to miss
    //     the whole VCO range, where the first P is beneath FminVco and
    //     the next P is above FmaxVco.
    //
    for (powerP = lowP; powerP < highP; powerP++)
    {
        lwv = vclk << powerP;
        if ((lwv < FminVco) && ((lwv << 1) > FmaxVco))
        {
            // adjust FminVco or FmaxVco, whichever is closer
            if ((FminVco - lwv) < ((lwv << 1) - FmaxVco))
                FminVco = lwv;
            else
                FmaxVco = (lwv << 1);
        }
    }

    //
    // 3). Let a high vclk set the upper bound.
    //
    if (vclk > FmaxVco)
        FmaxVco = vclk;

    //
    // For NV15, we've got a bit in CR33 that indicates we're setting the
    // PLL in the "upper" VCO range.
    //
    if (IsNV15(pDev))
    {
        U008 lock, cr33;

        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        // put NV15 into NV15 VPLL VCO programming mode
        CRTC_RD(NV_CIO_CRE_LCD__INDEX, cr33, Head);
        cr33 |= (1 << DRF_SHIFT(NV_CIO_CRE_LCD_VPLL_VCO));
        CRTC_WR(NV_CIO_CRE_LCD__INDEX, cr33, Head);

        RestoreLock(pDev, Head, lock);
    }

    //
    // Determine the current crystal frequency
    //   
    if (pDev->Chip.HalInfo.CrystalFreq == 14318180)
    {
        // 14.3Khz
        crystalFreq = 14318;

        lowM = 1;
             
        if (IsNV11(pDev))
        {
            //
            // NV11 needs four highM buckets due to
            // induced jitter into the PLL's
            //
            if (vclk > hiVclk3)
                highM = 2;
            else if (vclk > hiVclk2)
                highM = 4;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 14;

        }
        else
        {
            //
            // All chips except for NV11 only need three
            // highM buckets
            //
            if (vclk > hiVclk2)
                highM = 2;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 14;
        }
    }
    else
    {
        // 13.5Khz
        crystalFreq = 13500;

        lowM = 1;

        //
        // NV11 needs four highM buckets due to
        // induced jitter into the PLL's
        //
        if (IsNV11(pDev))
        {
            if (vclk > hiVclk3)
                highM = 2;
            else if (vclk > hiVclk2)
                highM = 4;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 13;
        }
        else
        {
            //
            // All chips except for NV11 only need three
            // highM buckets
            //
            if (vclk > hiVclk2)
                highM = 2;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 13;
        }
    }                      
    
    //
    // P Loop
    //
    for (powerP = lowP; powerP <= highP; powerP++) // Init Power of P
    {                             
        // M Loop
        for (m = lowM; m <= highM; m++)
        {                          
            lwv = vclk << powerP;   // vclk * P
            
            // Compare with internal range of DAC
            if ((lwv >= FminVco) && (lwv <= FmaxVco))
            {
                lwv *= (U032)m;    // vclk * P * M
                
                // Add crystal Frequency /2 - will round better
                lwv += (crystalFreq >> 1);
                
                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);
                
                if (n > 0xFF)
                    break;
                    
                lwv *= crystalFreq; // N * crystal
                   
                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2
                
                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P
                
                i = m;
                j = m;
                
                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M
                                       
                lwv2 = lwv;          // Save a copy

                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta
                
                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);
                
                if (lwvs < vclks)
                {               
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }            
                    
                lwvs -= vclks;      // ABS(Freq-Vclk);
                
                //
                // If this is an NV5 or better, allow the higher PCLK settings to use a lower M
                // if the error is small enough.  Just looking for the lowest overall error
                // may result in an M that is too high, possibly introducing PLL jitter.
                //
                if (IsNV5orBetter(pDev))
                {                
                    //
                    // If VCLK > 250MHz and error is less than 0.2%, drop out
                    //
                    if (vclk > hiVclk1)
                    {
                        if (lwvs == 0) // zero error; rare, but would cause exception
                        {
                            *P = powerP;
                            *M = m;
                            *N = n;
                            lwv2 /= 10;
                            return ((U016)(lwv2 & 0xFFFF));
                        } 
                        else if ((vclk/lwvs) > 200) // ok, now safe to div by lwvs (it's not zero)
                        {
                            *P = powerP;
                            *M = m;
                            *N = n;
                            lwv2 /= 10;
                            return ((U016)(lwv2 & 0xFFFF));
                        } 
                    }
                    
                    if (lwvs < deltaOld) // go to closest match with M < highM
                    {
                        // Closer match
                        deltaOld = lwvs;
                        
                        bestP = powerP;
                        bestM = m;
                        bestN = n;
                        
                        lwv2 /= 10;
                        
                        vclkClosest = (U016)(lwv2 & 0xFFFF);
                    }
                                            
                }
                else // !NV5
                {
                    if (lwvs < deltaOld)
                    {
                        // Closer match
                        deltaOld = lwvs;
                        
                        bestP = powerP;
                        bestM = m;
                        bestN = n;
                        
                        lwv2 /= 10;
                        
                        vclkClosest = (U016)(lwv2 & 0xFFFF);
                    }
                }
            }
        }
    }                             
    
    // Verify we've established M, N, P values to use
    if (!bestM && !bestN && !bestP)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: dacCalcMNP didn't set any M, N, P values!!!\n");
        DBG_BREAKPOINT();
    }

    //
    // Return the results
    //
    *M = bestM;
    *N = bestN;
    *P = bestP;
    
    return (vclkClosest);
} 


//
//       dacCalcMNP_MaxM - Return the PLL values for a specified frequency while
//                          abiding by the given maximum M value
//
//          Clock frequency in MHz * 100
//
// The algorithm is constrained to keep within 0.5% error
// to remain inside the VBE spec.
// However, if you have a choice of what frequencies you
// request, try to avoid the following requested frequencies
// when you get above 300MHz, as they require M values > 3.
//
//  14.31818 MHz
// 29739 - 29918
// 30219 - 30393
// 31178 - 31343
// 31658 - 31818
// 32617 - 32767
// 33097 - 33243
// 34056 - 34193
// 34536 - 34668
//
//  13.5000 MHz
// 29397 - 29552
// 29849 - 30000
// 30754 - 30896
// 31206 - 31344
// 32110 - 32239
// 32563 - 32767
// 33467 - 33582
// 33919 - 34030
// 34824 - 34926
//
U032 dacCalcMNP_MaxM(
    PHWINFO  pDev,
    U032     Head,
    U032     Clock,
    U032    *M,    
    U032    *N,    
    U032    *P,
    U032    maxM
)
{
    U016  crystalFreq;
    U032  vclk;
    U016  vclkClosest = 0;
    U016  deltaOld;
    U016  bestM = 0;
    U016  bestP = 0;
    U016  bestN = 0;
    U016  lowM;
    U016  highM;
    U016  lowP, highP;
    U032  hiVclk1, hiVclk2, hiVclk3;
    U032  FminVco, FmaxVco;

    U016  powerP;
    U016  m;
    U016  n;
    U016  i, j;
    U032  lwv, lwv2;
    
    U016  lwvs, vclks;
    U016  t;
    
    vclk = (U032)(Clock * 10);     // Make KHz
    
    deltaOld = 0xFFFF;
    
    //
    // NV11 needs four highM buckets due to
    // induced jitter into the PLL's
    //
    if (IsNV11(pDev))
    {
        hiVclk1 = 150000;
        hiVclk2 = 200000;
        hiVclk3 = 340000;
    }
    else
    {
        hiVclk1 = 250000;
        hiVclk2 = 340000;

    }
    
    lowP  = 0;
    highP = 4;

    // if initDac() has run then FminVco and FmaxVco will be set.
    // But we might be called during devinit processing prior to
    //    initDac(), so we need a fallback...
    // NOTE: these defaults duplicated in initDac()
    if ((pDev->Dac.FminVco == 0) || (pDev->Dac.FmaxVco == 0))
    {
        if (IsNV15orBetter(pDev)) {
            if (IsNV15MaskRevA01(pDev))
                pDev->Dac.FminVco = 200000;
            else
                pDev->Dac.FminVco = 250000;
            
            pDev->Dac.FmaxVco = pDev->Dac.FminVco * 2; 
        } else {
            pDev->Dac.FminVco = 128000;
            pDev->Dac.FmaxVco = 256000;
        }
    }
    
    FminVco = pDev->Dac.FminVco;
    FmaxVco = pDev->Dac.FmaxVco;

    //
    // NV11 requires a modified Vco range, and since the BIOS's are already 
    // out in the field, shortcircuit this nice feature to fix the noise issue.
    //
    // When we're sure all older BIOS's have been flushed out of the world
    // (need 3.11.01.25.00+), this code can be removed.  If we detect a newer
    // BIOS version is in use, go ahead and use those values
    //
    // Mobile NV11 has always used these ranges, so this should not be a change
    // for them.
    //
    if (IsNV11(pDev) && (pDev->Chip.BiosRevision <= 0x03110125))
    {
        FminVco = 200000;
        FmaxVco = 400000;
    }

    // Apply any adjusts needed to FminVco/FmaxVco.
    //
    // 1). Make sure vclk is not so low that we'll miss the whole VCO range.
    //     Adjust FminVco to hit with the highest P (post divide).
    //
    if ((vclk << highP) < FminVco)
        FminVco = vclk << highP;

    //
    // 2). Also, check if two consecutive P values would cause us to miss
    //     the whole VCO range, where the first P is beneath FminVco and
    //     the next P is above FmaxVco.
    //
    for (powerP = lowP; powerP < highP; powerP++)
    {
        lwv = vclk << powerP;
        if ((lwv < FminVco) && ((lwv << 1) > FmaxVco))
        {
            // adjust FminVco or FmaxVco, whichever is closer
            if ((FminVco - lwv) < ((lwv << 1) - FmaxVco))
                FminVco = lwv;
            else
                FmaxVco = (lwv << 1);
        }
    }

    //
    // 3). Let a high vclk set the upper bound.
    //
    if (vclk > FmaxVco)
        FmaxVco = vclk;

    //
    // For NV15, we've got a bit in CR33 that indicates we're setting the
    // PLL in the "upper" VCO range.
    //
    if (IsNV15(pDev))
    {
        U008 lock, cr33;

        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        // put NV15 into NV15 VPLL VCO programming mode
        CRTC_RD(NV_CIO_CRE_LCD__INDEX, cr33, Head);
        cr33 |= (1 << DRF_SHIFT(NV_CIO_CRE_LCD_VPLL_VCO));
        CRTC_WR(NV_CIO_CRE_LCD__INDEX, cr33, Head);

        RestoreLock(pDev, Head, lock);
    }

    //
    // Determine the current crystal frequency
    //   
    if (pDev->Chip.HalInfo.CrystalFreq == 14318180)
    {
        // 14.3Khz
        crystalFreq = 14318;

        lowM = 1;
             
        if (IsNV11(pDev))
        {
            //
            // NV11 needs four highM buckets due to
            // induced jitter into the PLL's
            //
            if (vclk > hiVclk3)
                highM = 2;
            else if (vclk > hiVclk2)
                highM = 4;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 14;

        }
        else
        {
            //
            // All chips except for NV11 only need three
            // highM buckets
            //
            if (vclk > hiVclk2)
                highM = 2;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 14;
          
        }
        
    }
    else
    {
        // 13.5Khz
        crystalFreq = 13500;

        lowM = 1;

        //
        // NV11 needs four highM buckets due to
        // induced jitter into the PLL's
        //
        if (IsNV11(pDev))
        {
            if (vclk > hiVclk3)
                highM = 2;
            else if (vclk > hiVclk2)
                highM = 4;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 13;
        }
        else
        {
            //
            // All chips except for NV11 only need three
            // highM buckets
            //
            if (vclk > hiVclk2)
                highM = 2;
            else if (vclk > hiVclk1)
                highM = 6;
            else
                highM = 13;
        }

    }                      
    

    // Make sure we haven't gone past the maximum M
    if (highM > (U016)maxM) {
      highM = (U016)maxM;
    }


    //
    // P Loop
    //
    for (powerP = lowP; powerP <= highP; powerP++) // Init Power of P
    {                             
        // M Loop
        for (m = lowM; m <= highM; m++)
        {                          
            lwv = vclk << powerP;   // vclk * P
            
            // Compare with internal range of DAC
            if ((lwv >= FminVco) && (lwv <= FmaxVco))
            {
                lwv *= (U032)m;    // vclk * P * M
                
                //
                // In case of normal incoming clock, 
                // want to select a clock that is close
                // but can be greater or less than the target
                // In case of SpreadSpectrum want to be 
                // EQUAL or LOWER than the target frequency
                //
                // !! always skip this when searching with a limited M value
                //
                // Add crystal Frequency /2 - will round better
                //  lwv += (crystalFreq >> 1);
                
                lwv /= crystalFreq; // N = vclk*P*M/crystal
                n = (U016)(lwv & 0xFFFF);
                
                if (n > 0xFF)
                    break;
                    
                lwv *= crystalFreq; // N * crystal
                   
                i = 1 << powerP;    // for rounding
                i >>= 1;            // /2
                
                lwv += i;           // Add 1/2 of P
                lwv >>= powerP;     // N*cyrstal/P
                
                i = m;
                j = m;
                
                j >>= 1;            // M/2
                lwv += j;           // For rounding
                lwv /= m;           // Freq = N*crystal/P/M
                                       
                lwv2 = lwv;          // Save a copy

                // Because the only divide in computing N is by the
                // crystal frequency, the remainder will always be
                // less than the crystal frequency which fits into
                // a word, so we can do the delta math on words
                //
                // Compute delta
                
                lwvs = (U016)(lwv & 0xFFFF);
                vclks = (U016)(vclk & 0xFFFF);
                
                if (lwvs < vclks)
                {               
                    // Exchange the values
                    t = lwvs;
                    lwvs = vclks;
                    vclks = t;
                }            
                    
                lwvs -= vclks;      // ABS(Freq-Vclk);
                
                //
                // If this is an NV5 or better, allow the higher PCLK settings to use a lower M
                // if the error is small enough.  Just looking for the lowest overall error
                // may result in an M that is too high, possibly introducing PLL jitter.
                //
                if (IsNV5orBetter(pDev))
                {                
                    //
                    // If VCLK > 250MHz and error is less than 0.2%, drop out
                    //
                    if (vclk > hiVclk1)
                    {
                        if (lwvs == 0) // zero error; rare, but would cause exception
                        {
                            *P = powerP;
                            *M = m;
                            *N = n;
                            lwv2 /= 10;
                            return ((U016)(lwv2 & 0xFFFF));
                        } 
                        else if ((vclk/lwvs) > 200) // ok, now safe to div by lwvs (it's not zero)
                        {
                            *P = powerP;
                            *M = m;
                            *N = n;
                            lwv2 /= 10;
                            return ((U016)(lwv2 & 0xFFFF));
                        } 
                    }
                    
                    if (lwvs < deltaOld) // go to closest match with M < highM
                    {
                        // Closer match
                        deltaOld = lwvs;
                        
                        bestP = powerP;
                        bestM = m;
                        bestN = n;
                        
                        lwv2 /= 10;
                        
                        vclkClosest = (U016)(lwv2 & 0xFFFF);
                    }
                                            
                }
                else // !NV5
                {
                    if (lwvs < deltaOld)
                    {
                        // Closer match
                        deltaOld = lwvs;
                        
                        bestP = powerP;
                        bestM = m;
                        bestN = n;
                        
                        lwv2 /= 10;
                        
                        vclkClosest = (U016)(lwv2 & 0xFFFF);
                    }
                }
            }
        }
    }                             
    
    // Verify we've established M, N, P values to use
    if (!bestM && !bestN && !bestP)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: dacCalcMNP didn't set any M, N, P values!!!\n");
        DBG_BREAKPOINT();
    }

    //
    // Return the results
    //
    *M = bestM;
    *N = bestN;
    *P = bestP;
    
    return (vclkClosest);
} 


static U032 CalculateClockFrequency
(
   PHWINFO pDev,
   U032 M,
   U032 N,
   U032 P
)
{
    U032 Fout;
    // Fout = Fin * (N/M) / 2**P.
    U032 Fin = pDev->Chip.HalInfo.CrystalFreq;

    if ((M * (1 << P)) == 0)
       return 0;

    Fout = (Fin * N) / (M * (1 << P));

    return Fout;
}

//
// Clock programming methods
//

//
// dacProgramMClk - Program MCLK based on the value in pDev->Dac.HalInfo.MClk
//
// This routine uses the value in pDev->Dac.HalInfo.MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
// If Ponly is TRUE, then we will only raise and lower P get as close to the desired
// clock speed as possible without going above or below it.
//
RM_STATUS dacProgramMClk
(
    PHWINFO pDev,
    U032    DisableDLLs
)
{
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 Head = 0;  // MPLL is on head 0
    RM_STATUS status;

    // Compute M, N, O, and P values
    dacCalcMNP( pDev, Head, pDev->Dac.HalInfo.MClk / 10000, &mNew, &nNew, &pNew );

    // Update Dac structure
    pDev->Dac.HalInfo.MPllM = mNew;
    pDev->Dac.HalInfo.MPllN = nNew;
    pDev->Dac.HalInfo.MPllO = 1;
    pDev->Dac.HalInfo.MPllP = pNew;

    status = nvHalDacProgramMClk(pDev, DisableDLLs);

    return status;
}

//
// dacProgramNVClk - Program NVCLK based on the value in
// pDev->Dac.HalInfo.NVClk
//
// This routine uses the value in pDev->Dac.HalInfo.NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS dacProgramNVClk
(
    PHWINFO pDev 
)
{
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 Head = 0; // NVPLL is on head 0

    // Compute M, N, O, and P values
    dacCalcMNP(pDev, Head, pDev->Dac.HalInfo.NVClk / 10000, &mNew, &nNew, &pNew);

    // Update Dac structure
    pDev->Dac.HalInfo.NVPllM = mNew;
    pDev->Dac.HalInfo.NVPllN = nNew;
    pDev->Dac.HalInfo.NVPllO = 1;
    pDev->Dac.HalInfo.NVPllP = pNew;

    return(nvHalDacProgramNVClk(pDev));
}

RM_STATUS dacGetDisplayInfo
(
    PHWINFO pDev,
    U032 DisplayMap,
    U032 *Head,
    U032 *DisplayType,
    U032 *I2CWritePort,
    U032 *I2CReadPort
)
{
    U032 flag = 0;
    PDACDCBDEVDESC pDevDesc;
    pDACDCBI2CRECORD pDCBI2c;

    pDevDesc = pDev->Dac.DCBDesc;
    pDCBI2c  = pDev->Dac.DCBI2c;

    while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL)
    {
        if (pDevDesc->DevTypeUnit == DisplayMap)
        {
            flag = 1;
            break;
        }
        pDevDesc++;
        pDCBI2c++;
    }

    if (!flag) return RM_ERROR;

    if (Head)         *Head = pDevDesc->DCBRecHead;
    if (DisplayType)  *DisplayType = pDevDesc->DCBRecType;
    if (I2CWritePort) *I2CWritePort = pDCBI2c->WritePort;
    if (I2CReadPort)  *I2CReadPort = pDCBI2c->ReadPort;

    return RM_OK;
}

//
// dacProgramPClk - Program PCLK based on the value in pDev->Dac.PClk
//
// This routine uses the value in pDev->Dac.PClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS dacProgramPClk
(
    PHWINFO pDev, 
    U032    Head,
    U032    PixelClock
)
{
    VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;
    U032 mNew;
    U032 nNew;
    U032 pNew;

    // Compute M, N, O, and P values
    dacCalcMNP( pDev, Head, PixelClock, &mNew, &nNew, &pNew );

    // Update Dac structure
    pDev->halHwInfo.pDacHalInfo->VPllM = mNew;
    pDev->halHwInfo.pDacHalInfo->VPllN = nNew;
    pDev->halHwInfo.pDacHalInfo->VPllO = 1;
    pDev->halHwInfo.pDacHalInfo->VPllP = pNew;

    vidLutCurDacHalObj.Head = Head;

    return(nvHalDacProgramPClk(pDev, PixelClock, (VOID*) &vidLutCurDacHalObj));
}

// This function just enables the cursor by setting bit 0 of config register 0x31 to 1.
// The cursor image is not changed in any way.
VOID dacEnableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    cr31;
    U008    lock;
    
    lock = UnlockCRTC(pDev, Head);
    
    CRTC_RD(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, Head);           
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, (cr31 | (1 << DRF_SHIFT(NV_CIO_CRE_HCUR_ADDR1_ENABLE))), Head);

    RestoreLock(pDev, Head, lock);
}

// This function just disables the cursor by setting bit 0 of config register 0x31 to 0.
// The cursor image is not changed in any way.
VOID dacDisableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    cr31;
    U008    lock;
    
    lock = UnlockCRTC(pDev, Head);
    
    CRTC_RD(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, Head);           
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, (cr31 & ~(1 << DRF_SHIFT(NV_CIO_CRE_HCUR_ADDR1_ENABLE))), Head);

    RestoreLock(pDev, Head, lock);
}

/*  This function is mis-named. It also loads the cursor image offset in addition to enabling the
    cursor. This is used by the old style of cursor manipulation. 
*/
VOID enableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    lock;
    
    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    
#ifdef NTRM    
    // Tell the DAC where to load the image from
    // The address is in pages, so shift 4 bits.
    if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x00000001)    // color or mono?
    {
        CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 12) & 0x7f, Head);
        CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, ((pDev->Dac.CursorImageInstance >> 4) & 0xf8), Head);
    }
    else
    {
        // call crtc_wrm: need to add this routine
        CRTC_WRM(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 12) & 0x7f);
        CRTC_WRM(NV_CIO_CRE_HCUR_ADDR1_INDEX, ((pDev->Dac.CursorImageInstance >> 4) & 0xf8) | 1);
    }
#else
    // Tell the DAC where to load the image from. The address is in pages, so shift 4 bits.
#ifdef WIN31
    // On NV4 and later HCUR_ADDR0 is 23:17, HCUR_ADDR1 is 16:11 (on NV3 its 22:16)
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 13) & 0x7f);
    CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, ((pDev->Dac.CursorImageInstance >> 5) & 0xfc) | 1);
//JohnH The Win9x code below is incorrect for NV4 and up, but the correct address
//JohnH gets set in dacProgramCursorImage.
//JohnH CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, (pDev->Dac.CursorImageInstance >> 12) & 0x7f);
//JohnH CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, (pDev->Dac.CursorImageInstance >> 4) & 0xf8);
#endif // WIN31
#endif // NTRM
    
    // JJV - I am removing this call. Vblank will call this later if needed.
    //       This will fix a multimonitor cursor problem.  
    // Enable the cursor.
    //dacEnableCursor(pDev);

    RestoreLock(pDev, Head, lock);
}

/*  Turn off the enable bit in CRTC reg
    This function unlocks the CRTC extended registers and calls dacDisableCursor.
    This is used by the old style cursor manipulation functions. */
VOID disableCursor
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 lock;

#ifndef NTRM
    pDev->Dac.CrtcInfo[Head].CursorType = DAC_CURSOR_DISABLED;    // disable updates in vblank
#endif

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

    dacDisableCursor(pDev, Head);

    RestoreLock(pDev, Head, lock);
}

RM_STATUS dacProgramCursorPosition
(
    PHWINFO pDev, 
    U032    Head,
    U032    cursorX, 
    U032    cursorY 
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // on modes below 400 lines, scanline doubling is used. we need to adjust cursor y postion
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    if (pVidLutCurDac && pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode)
        cursorY *= 2;

//    if (CRTCHALINFO(pDev, Head, DisplayType) == TV)
        cursorX += pDev->Framebuffer.CursorAdjust;  // HW bug in NV4, position is off a little on TV

    DAC_REG_WR32(NV_PRAMDAC_CU_START_POS, cursorX | (cursorY << 16), Head);

    return RM_OK;
}

VOID dacDisableImage
(
    PHWINFO pDev,
    U032 Head
)
{
    U016 data;
    U032 prevHead = (pDev->Dac.HalInfo.Head2RegOwner & 0x1);

    EnableHead(pDev, Head);        // sequencer updates require setting CR44 

    // turn on blank
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);
    data |= 0x2000;
    WriteIndexed(NV_PRMVIO_SRX, data);

    EnableHead(pDev, prevHead);    // restore previous CR44 value
}

VOID dacEnableImage
(
    PHWINFO pDev,
    U032 Head
)
{
    U016 data;
    U032 prevHead = (pDev->Dac.HalInfo.Head2RegOwner & 0x1);

    EnableHead(pDev, Head);        // sequencer updates require setting CR44 

    // turn off blank
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);
    data &= ~0x2000;
    WriteIndexed(NV_PRMVIO_SRX, data);

    EnableHead(pDev, prevHead);    // restore previous CR44 value
}


VOID dacEnableDac
(
    PHWINFO pDev,
    U032 Head
)
{
    U008 lock, data08;    
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    
    if (!IsNV11(pDev) && (Head == 1)) // if not dual-head
    {
        return;
    }
    
    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

    // enable vblank interrupt
    DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 1, Head);
    pDev->Dac.CrtcInfo[Head].StateFlags |= DAC_CRTCINFO_VBLANK_ENABLED;
    
    // device-specific disabling...
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    if (pVidLutCurDac)
    {
        switch (pVidLutCurDac->DisplayType)
        {
            case DISPLAY_TYPE_MONITOR:
        
                // TO DO: this decision must be made by the HAL
                // if normal VGA (internal DAC)
                if (Head == 0) 
                {
                    dacEnableImage(pDev, Head);
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON, Head);  // CRT on
                    //
                    // We need to be careful about powering down the TMDS
                    // transmitter on NV11 because we can lose a flat
                    // panel connected to the second crtc (head 1).
                    //
                    if (IsNV11(pDev))
                        dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_FPCLK);     // FPCLK off only;leave TMDS going for secondary crtc
                    else
                        dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_BOTH);      // FPCLK/TMDS both off
                    CRTC_RD(0x33, data08, Head);
                    CRTC_WR(0x33, (data08 & ~0x02), Head);  // clear CR33[1] (BIOS flag)
                    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & 0x3F, Head);
                    dacSetCursorBlink(pDev, Head, 0); // set cursor blink rate for DOS
                }
        
                // PRAMDAC_FP is driving analog
                else
                {
                    // restore sync states
                    DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, pDev->Dac.CrtcInfo[Head].CurrentVsyncState, Head);
                    DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, pDev->Dac.CrtcInfo[Head].CurrentHsyncState, Head);
                    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);
                }
            
                break;   
                                       
            case DISPLAY_TYPE_FLAT_PANEL:
        
                // restore sync states
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, pDev->Dac.CrtcInfo[Head].CurrentVsyncState, Head);
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, pDev->Dac.CrtcInfo[Head].CurrentHsyncState, Head);
                dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);

                // Turn Hsync off and Vsync on, or leave both on, depending on what we found in registry
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                data08 &= ~0xC0;
                if (pDev->Dac.HsyncOff) 
                {
                    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 |= 0x80, Head); // disable horiz sync to put CRT in suspend
                }
                else
                {
                    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08, Head);    // leave both syncs on
                }

                if (pDev->Power.MobileOperation)
                    dacPowerOnMobilePanel(pDev,Head);

                //
                // Slave the CRTC again off the FP (this complements what was done
                // in dacDisableDac for the FP).
                //
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data08, Head);
                data08 |= 0x80;        // set bit 7
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data08, Head);    
                break;                              
            
            case DISPLAY_TYPE_TV:
                // Turn Hsync off and Vsync on, or leave both on, depending on what we found in registry
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                data08 &= ~0xC0;
                if (pDev->Dac.HsyncOff) 
                {
                    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 |= 0x80, Head); // disable horiz sync to put CRT in suspend
                }
                else
                {
                    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08, Head);    // leave both syncs on
                }
                dacEnableTV(pDev, Head);
                break;
            
            default:
                break;
        }
    }

    RestoreLock(pDev, Head, lock);

} // end of dacEnableDac()

VOID dacDisableDac
(
    PHWINFO pDev,
    U032 Head
)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    if (!IsNV11(pDev) && (Head == 1)) // if not dual-head
    {
        return;
    }

    if (MC_POWER_LEVEL_0 != pDev->Power.State) {
        return;
        }

    // disable vblank interrupt, if there are no callbacks pending
    if (pDev->Dac.CrtcInfo[Head].VBlankCallbackList == NULL)
    {
        DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, Head);
        DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 0, Head);
        pDev->Dac.CrtcInfo[Head].StateFlags &= ~DAC_CRTCINFO_VBLANK_ENABLED;
    }

    // device-specific disabling...
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    if (pVidLutCurDac)
    {
        pDev->Dac.CrtcInfo[Head].MonitorPowerSetMode = FALSE;
        switch (pVidLutCurDac->DisplayType)
        {
            case DISPLAY_TYPE_MONITOR:
        
                // TO DO: this decision must be made by the HAL
                // head 0 -- treat as CRT
                if (Head == 0)
                {
                    // disable hsync
                    if (pDev->Dac.HsyncOff) 
                        dacSetSyncState(pDev, Head, 0, 1); // H off, V on
                    else
                        dacSetSyncState(pDev, Head, 0, 0); // H off, V off
                    dacDisableImage(pDev, Head);
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head);
                }

                // head 1 -- treat as DFP
                else
                {    
                    // disable hsync
                    if (pDev->Dac.HsyncOff) 
                        dacSetSyncState(pDev, Head, 0, 1); // H off, V on
                    else
                        dacSetSyncState(pDev, Head, 0, 0); // H off, V off
                    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_BOTH);
                }
                break;
            
            case DISPLAY_TYPE_FLAT_PANEL:
            {
                U008 lock, data;

                //Don't mess with the clocks on a Toshiba system unless we know that the
                //SBIOS has been informed of the switch.  They will turn off the panel
                //power for us, an event that should occur within a not-too-large time
                //window of turning off the clocks to spare the display.
                if ((pDev->Power.MobileOperation == 2) && !pDev->Dac.DisplayChangeInProgress)
                    break;

                // if we're mobile, turn the power off as well
                if (pDev->Power.MobileOperation)
                    dacPowerOffMobilePanel(pDev, Head);

                //
                // Unslave the CRTC from the FP (the BIOS uses the state of CR28
                // and CR33 to determine if a FP is active on this head). 
                //
                lock = UnlockCRTC(pDev, Head);

                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);
                data &= ~0x80;        // clear bit 7
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);    
           
                RestoreLock(pDev, Head, lock);
                
                // NOTE: do not turn off FPCLK before unslaving CRTC
                dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_BOTH);
                break;
            }            

            case DISPLAY_TYPE_TV:
            {
                dacSetSyncState(pDev, Head, 0, 0); // H off, V off (TV is disabled, CRT is powered down)
                // this has to be encoder dependent
                dacDisableTV(pDev, Head);
                break;
            }
            
            default:
                break;
        }
    }
    else
    {
        U008 lock, data;

        // Since pVidLutCurDac is NULL, pDev->Dac.DevicesEnabled will tell us if the flat panel is on.
        // If we're in a mobile environment on Head 1 and the flat panel is on,
        // go ahead and turn it off. This fixes the stand-by problem with 32095.
        if((Head == 1) && (pDev->Power.MobileOperation) && (pDev->Dac.DevicesEnabled & DAC_PANEL_POWER_ENABLED))
            dacPowerOffMobilePanel(pDev, Head);

        //
        // Disable in a display device independent way (i.e. drop the monitor
        // syncs, powerdown the DAC and turnoff sequencer memory fetches).
        //
        dacSetSyncState(pDev, Head, 0, 0); // H off, V off (no device is being driven off this head)
        dacDisableImage(pDev, Head);
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head);
        //
        // Unslave the CRTC from the FP (the BIOS uses the state of CR28
        // and CR33 to determine if a FP is active on this head). 
        // This catches cases where we declined to disable the hardware
        // when we originally deallocated the object.  Solves problems
        // with Toshiba mobile.
        lock = UnlockCRTC(pDev, Head);

        CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);
        data &= ~0x80;        // clear bit 7
        CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);    

        RestoreLock(pDev, Head, lock);
    }

} // end of dacDisableDac()

RM_STATUS dacProgramVideoStart
(
    PHWINFO pDev, 
    U032    Head,
    U032    StartAddr, 
    U032    Pitch 
)
{
    if (pDev->pStereoParams && (pDev->pStereoParams->Flags & (STEREOCFG_STEREOACTIVATED|STEREOCFG_INTERLACED)) 
        == (STEREOCFG_STEREOACTIVATED|STEREOCFG_INTERLACED))
    {
        // Asus stereo uses interlaced video modes.
        Pitch >>= 1;
    }
    if (!pDev->Vga.Enabled)
    {
        VIDEO_LUT_CURSOR_DAC_HAL_OBJECT vidLutCurDacHalObj;

        vidLutCurDacHalObj.Head = Head;

        //
        // If the pitch of the RGB surface does not match the current display width, we
        // need to tweak the CRTC to a different pitch adjust.
        //
        // Compare Pitch against pDev->Framebuffer.DisplayPitch rather than trying to
        // calculate it, since DisplayPitch has been aligned for the HW already (e.g. NV10).
        //
        // Checking against DisplayPitch actually doesn't save us in the case where the 2
        // surfaces have different pitch values. This really needs to be checking against
        // the last loaded pitch ... but then we'd be programming more than just the start
        // addr 1/2 the time.
        //
        // For now, print out a message, so the driver can be changed to flip between
        // surfaces of the same pitch making our job easier and giving us the best perf.
        //        
//#if 0 // This was used for video class63, but later classes take care of this case
//        if (Pitch != pDev->Framebuffer.DisplayPitch)
        {

            U008      i, lock, crtc_index;
            U032      val32;

//            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Flipping between different pitched surfaces!!!\n\r");

            //
            // Save the current CRTC index
            //
            if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)    // color or mono?
                crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
            else
                crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO); // save crtc index

            // unlock the extended regs
            lock = UnlockCRTC(pDev, Head);

            // Write the alternative pitch to the CRTC Offset Register
            // The value written to CR13/CR19 is the number of 8-byte chunks
            CRTC_WR(NV_CIO_CR_OFFSET_INDEX, (Pitch >> 3) & 0xFF, Head);

            // Modify the bits in the extended register as well
            CRTC_RD(NV_CIO_CRE_RPC0_INDEX, i, Head);
            i &= 0x1F;
            val32 = ((Pitch >> 3) & 0x700) >> 3;
            i |= (U008)val32; 
            CRTC_WR(NV_CIO_CRE_RPC0_INDEX, i, Head);

            RestoreLock(pDev, Head, lock);

            // Restore index
            if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
                REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index); // restore crtc index
            else
                REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);	// restore crtc index
        }
//#endif

        // Program the new start address; this will latch at the end of blank
        if (pDev->pStereoParams)
        {
            pDev->pStereoParams->FlipOffsets[3][0] = StartAddr;
            if ((pDev->pStereoParams->Flags & (STEREOCFG_STEREOACTIVATED|STEREOCFG_INTERLACED)) == STEREOCFG_STEREOACTIVATED)
            {
                return RM_OK;
            }
        }
        nvHalDacSetStartAddr(pDev, StartAddr, &vidLutCurDacHalObj);
    }
    return RM_OK;
}

RM_STATUS dacProgramLUT
(
    PHWINFO pDev, 
    U032    Head,
    U032*   Palette, 
    U032    numEntries 
)
{
    U032    i, rgb;

    // start at palette 0 and autoincrement
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0, Head);
    for (i = 0; i < numEntries; i++)
    {
        rgb = Palette[i];
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)(rgb >> 16), Head);    // b
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)(rgb >> 8), Head);     // g
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)rgb, Head);            // r
    }
    return RM_OK;
}

RM_STATUS dacProgramScanRegion
(
    PHWINFO pDev,
    U032    Head,
    U032    startLine,
    U032    stopLine,
    U032    polarity
)
{
    if (IsNV15(pDev) || IsNV11(pDev) || IsNV1A(pDev) || IsNV20(pDev))
    {
        DAC_REG_WR32(NV_PCRTC_RASTER_START, startLine | DRF_NUM(_PCRTC, _RASTER_START, _POL, polarity), Head);
        DAC_REG_WR32(NV_PCRTC_RASTER_STOP,  stopLine, Head);
        return (RM_OK);    
    }
    else
        return (RM_ERROR);
}

/************************************************************
* Here is how the H & V blank and retrace values map to the config registers:
    Hbs<0:7> = CR02<0:7>
    Hbe<0:4> = CR03<0:4>
    Hbe<5>   = CR05<7>
    Hbe<6>   = CR25<4>
    Vbs<0:7> = CR15<0:7>
    Vbs<8>   = CR07<3>
    Vbs<9>   = CR09<5>
    Vbs<10>  = CR25<3>
    Vbe<0:7> = CR16<0:7>
    
    Hrs<0:7> = CR04<0:7>
    Hre<0:4> = CR05<0:4>
    Vrs<0:7> = CR10<0:7>
    Vrs<8>   = CR07<2>
    Vrs<9>   = CR07<7>
    Vrs<10>  = CR25<2>
    Vre<0:3> = CR11<0:3>
***********************************************************/

// Position the screen on the display device (CRT or TV).
// DeviceMap: bit 0..7 = CRT0-7, bit 8..15 = TV 8-15
// Position:  bit 0..3 = position, bit 4 = default, bit 5 = last committed positon, bit 6 = commit
RM_STATUS dacSetDesktopPosition
(
    PHWINFO pDev, 
    U032    DeviceMap, 
    U032    Position
)
{

    // Add CRT positioning here

    // Position TV
    return dacPositionTV(pDev, 0, Position);
}
    
//  Position TV display in a device-independent way (via CRTC).
RM_STATUS dacPositionTV
(
    PHWINFO pDev, 
    U032    Head, 
    U032    Position
)
{
    RM_STATUS status = RM_OK;
    U008 lock;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032 VTotal, Vbs, Vt, Vrs = 0;
    U008 Skew, Cr01, Cr04, Cr05, Cr07, Cr21, Cr28;
    
#if 0
    // If no positioning info is given, then return whether this is the default position
    if (Position == 0) 
    {
        if (Vt == pDev->Dac.CrtcInfo[Head].MonitorPosition.Vt) // need to add Vt to MonitorPosition
            if (Hrs == pDev->Dac.CrtcInfo[Head].MonitorPosition.Hrs) 
                return TV_DEFAULT_POSITION;
        return TV_CUSTOM_POSITION;
    }
    if (Position & POS_DEFAULT) 
    {
        // Set default position
    }
    if (Position & POS_COMMIT) 
    {
        // Commit the current position to the registry
    }
    if (Position & POS_CANCEL) 
    {
        // Set the last committed position (saved in registry)
    }
#endif    
    
    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    // save the shadow lock
    CRTC_RD(0x21, Cr21, Head);
    CRTC_WR(0x21, Cr21 | 0x10, Head); // enable loading VT

    // The only adjustment we can do is the position, and that is done thru CRTC adjustment,
    // so this is actually generic TV positioning code. Should work on any encoder.

    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    VTotal = pVidLutCurDac->HalObject.Dac[0].TotalHeight;    
    Vbs = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
        
    // Horizontal position is controlled at pixel granularity by Cr28, 
    // and at character granularity by Cr4 (HRS)
    // Vertical position is controlled by Vertical Total.
    // Increasing the H retrace start value shortens the time between the sync and the start of display,
    // moving the screen to the left; decreasing retrace starts moves right.
    // Increasing vertical total increases time between sync and start of the display, moving the screen
    // down; decreasing VT moves the screen up.
    if (Position & POS_RIGHT) // right
    {
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
            CRTC_RD(NV_CIO_CR_HRS_INDEX, Cr04, Head);
            CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr01, Head);
            Skew = Cr28 & 0x38;
            if (Skew == 0x38) // at max?
            {
                if ((Cr04) > Cr01) // HRS must be > display end
                {
                    Cr04--;            // move right one char
                    Cr28 &= ~0x38;     // and set skew back to 0
                }
                else
                    status = RM_ERROR;
            }
            else
            {
                Skew >>= 3;
                Skew++;   // increment one pixel
                Skew <<=3;
            }
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, Cr04, Head);
        
     }
     if (Position & POS_LEFT) // left
     {
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
            CRTC_RD(NV_CIO_CR_HRS_INDEX, Cr04, Head);
            CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
            Skew = Cr28 & 0x38;
            if (Skew == 0x00) 
            {
                if (((Cr04 + 1) & BITS0_4) < Cr05) // start must be < end
                {
                    Cr04++;            // move left one char
                    Cr28 |= 0x38;     // and set skew to max
                }
                else
                    status = RM_ERROR;
            }
            else
            {
                Skew >>= 3;
                Skew--;   // decrement one pixel
                Skew <<= 3;
            }
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, Cr04, Head);
    }
    if (Position & POS_DOWN) // down
    {
            // get current VT
            CRTC_RD(NV_CIO_CR_VDT_INDEX, Vt, Head);
            CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
            if (Cr07 & BIT0)
                Vt |= BIT8;
            if (Cr07 & BIT5)
                Vt |= BIT9;
            if (Vt < VTotal + 10) // put some limit on how far we increment
            {
                Vt++;
                Cr07 &= ~(BIT5 | BIT0);
                if (Vt & BIT8) Cr07 |= BIT0;
                if (Vt & BIT9) Cr07 |= BIT5;
                CRTC_WR(NV_CIO_CR_VDT_INDEX, Vt & 0xff, Head);
                CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
            }
            else
                status = RM_ERROR;
    }
    if (Position & POS_UP)  // up
    {
            // get current VT
            CRTC_RD(NV_CIO_CR_VDT_INDEX, Vt, Head);
            CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
            if (Cr07 & BIT0)
                Vt |= BIT8;
            if (Cr07 & BIT5)
                Vt |= BIT9;
            // get VRS too
            CRTC_RD(NV_CIO_CR_VRS_INDEX, Vrs, Head);
            if (Cr07 & BIT2) 
                Vrs |= BIT8;
            if (Cr07 & BIT7)
                Vrs |= BIT9;
            if (Vt > Vrs) // total must be > sync start
            {
                Vt--;
                Cr07 &= ~(BIT5 | BIT0);
                if (Vt & BIT8) Cr07 |= BIT0;
                if (Vt & BIT9) Cr07 |= BIT5;
                CRTC_WR(NV_CIO_CR_VDT_INDEX, Vt & 0xff, Head);
                CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
            }
            else
                status = RM_ERROR;
    }
    CRTC_WR(0x21, Cr21, Head); // restore shadow locks
    RestoreLock(pDev, Head, lock);
    
    return status;
}

//  After every mode set, we save the H & V retrace in nvinfo, so we can restore the default screen position
VOID dacSaveMonitorDefaultPosition
(
    PHWINFO pDev,
    U032    Head
)
{
    PDACMONITORPOSITION pDacMonPos;
    U016    Hrs, Hre, Vrs, Vre;
    U016    Hbs, Hbe, Vbs, Vbe;
    U008    Cr03, Cr05, Cr07, Cr09, Cr25;
    short   temp;

// debug 
    CRTC_RD(NV_CIO_CR_HBE_INDEX, Cr03, Head);

    // read all the necessary config registers.
    CRTC_RD(NV_CIO_CR_HBE_INDEX, Cr03, Head);
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_RD(NV_CIO_CR_CELL_HT_INDEX, Cr09, Head);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);

    // Construct Hbs
    CRTC_RD(NV_CIO_CR_HBS_INDEX, Hbs, Head);
    // Construct Hbe
    Hbe = Cr03 & BITS0_4;
    if (Cr05 & BIT7)
        Hbe |= BIT5;
    if (Cr25 & BIT4)
        Hbe |= BIT6;
    // Construct Vbs
    CRTC_RD(NV_CIO_CR_VBS_INDEX, Vbs, Head);
    if (Cr07 & BIT3)
        Vbs |= BIT8;
    if (Cr09 & BIT5)
        Vbs |= BIT9;
    if (Cr25 & BIT3)
        Vbs |= BIT10;
    // Construct Vbe
    CRTC_RD(NV_CIO_CR_VBE_INDEX, Vbe, Head);

    // Construct Hrs
    CRTC_RD(NV_CIO_CR_HRS_INDEX, Hrs, Head);
    // Construct Hre
    Hre = Cr05 & BITS0_4;
    // Construct Vrs
    CRTC_RD(NV_CIO_CR_VRS_INDEX, Vrs, Head);
    if (Cr25 & BIT2)
        Vrs |= BIT10;
    if (Cr07 & BIT7)
        Vrs |= BIT9;
    if (Cr07 & BIT2)
        Vrs |= BIT8;
    // Construct Vre
    CRTC_RD(NV_CIO_CR_VRE_INDEX, Vre, Head);
    Vre &= BITS0_3;

    // The horizontal/vertical, blank/retrace end values are really the width of the respective signal.
    // Calculate the absolute end values. It is a bit cumbursome because the number of bits of information
    // is not uniform.
    // The formula is: <Absolute end value> = <start-value> + ((<width> - <start-value>) & (# of bits))
    temp = (short)Hbe - (short)Hbs; 
    temp &= 0x7f; // just take the low 7 bits
    Hbe = Hbs + temp;
    
    temp = (short)Hre - (short)Hrs; 
    temp &= 0x1f; // just take the lower 5 bits
    Hre = Hrs + temp;

    temp = (short)Vbe - (short)Vbs; 
    temp &= 0x7f; // just take the low 7 bits
    Vbe = Vbs + temp;
    
    temp = (short)Vre - (short)Vrs; 
    temp &= 0xf; // just take the lower 4 bits
    Vre = Vrs + temp;

    // save it off in nvinfo
    pDacMonPos = &pDev->Dac.CrtcInfo[Head].MonitorPosition;
    pDacMonPos->Hbs = Hbs;
    pDacMonPos->Hbe = Hbe;
    pDacMonPos->Vbs = Vbs;
    pDacMonPos->Vbe = Vbe;
    pDacMonPos->Hrs = Hrs;
    pDacMonPos->Hre = Hre;
    pDacMonPos->Vrs = Vrs;
    pDacMonPos->Vre = Vre;
}

//****************************************************************************************
/*  Adjust monitor horizontal position
    This is accomplished by increasing/decreasing the retrace start/end values
    The adjustment is character granularity
*/
static VOID SetRetraceH
(   PHWINFO pDev, 
    U032    Head,
    U032    Hrs, 
    U032    Hre
)
{
    U008    Cr05;

    // Get HRE
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
    Cr05 &= ~BITS0_4;        // Clear bits 0:4
    Cr05 |= (Hre & BITS0_4); // Combine new HRE bits 0:4 with other bits

    // Write out adjustment
    CRTC_WR(NV_CIO_CR_HRS_INDEX, Hrs, Head);
    CRTC_WR(NV_CIO_CR_HRE_INDEX, Cr05, Head);
}

//****************************************************************************************
/*  Adjust monitor vertical position
    This is accomplished by increasing/decreasing the retrace start/end values
    The adjustment is scanline granularity
*/
static VOID SetRetraceV
(   PHWINFO pDev, 
    U032    Head,
    U032    Vrs, 
    U032    Vre
)
{
    U008    Cr10, Cr11, Cr07, Cr25;

    // Get CR25, CR7, CR11, mask VR bits
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    Cr07 &= ~(BIT7 | BIT2);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    Cr25 &= ~BIT2;
    CRTC_RD(NV_CIO_CR_VRE_INDEX, Cr11, Head);
    Cr11 &= ~BITS0_3;
        
    Cr10 = (U008)(Vrs & BITS0_7);
    // Combine new VRS value with other bits in CR07, CR25.
    if (Vrs & BIT10)
        Cr25 |= BIT2;
    if (Vrs & BIT9)
        Cr07 |= BIT7;
    if (Vrs & BIT8)
        Cr07 |= BIT2;

    // Combine VRE with other bits in CR11
    Cr11 |= (Vre & BITS0_3);
    
    // Write out adjustment
    CRTC_WR(NV_CIO_CR_VRS_INDEX, Cr10, Head);  
    CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, Cr11, Head);
}

//****************************************************************************************
/*  Adjust monitor postion
    A CRT is positioned by moving the sync pulses relative to the display data.
*/
RM_STATUS dacSetMonitorPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    Hrs,
    U032    Hre,
    U032    Vrs,
    U032    Vre
)
{
    U032      Vde, Vt;
    U008      Cr01, Cr07, Cr11, Cr21, Cr25, val;
    U008      lock;
    U008      UpdatedCr11;
    RM_STATUS rmStatus = RM_OK;

    // A CRT driven by a DAC is positioned by CRTC timing;
    // a CRT driven by FP timing is positioned by FP timing
    if (Head == 0) // TODO: don't assume Head B = FP; use DCB
    {
        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        CRTC_RD(NV_CIO_CR_VRE_INDEX, Cr11, Head);
        val = Cr11 & 0x7f;                          // clear write protection bit
        CRTC_WR(NV_CIO_CR_VRE_INDEX, val, Head);

        CRTC_RD(0x21, Cr21, Head);
        CRTC_WR(0x21, 0xf8, Head);       // disable shadowing for TV

        CRTC_RD(NV_CIO_CR_HDE_INDEX, Cr01, Head);     // read H display end

        // Check that the sync width doesn't go to 0 and that the sync pulse is beyond display end
        if ((Hre <= (Hrs & 0x1f)) || (Hrs <= Cr01))
        {
            rmStatus = RM_ERROR;
            goto done;
        }

        // Get overflow bits
        CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
        CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);    

        // Check that the sync width doesn't go to 0 and that the sync pulse is beyond display end
        CRTC_RD(NV_CIO_CR_VDE_INDEX, Vde, Head);    // read V display end (CR12)
        if (Cr07 & BIT(1)) Vde |= 0x100;
        if (Cr07 & BIT(6)) Vde |= 0x200;
        if (Cr25 & BIT(1)) Vde |= 0x400;

        // Check also that the sync pulse doesn't enter the display start (vertical total)
        CRTC_RD(NV_CIO_CR_VDT_INDEX, Vt, Head);
        if (Cr07 & BIT(0)) Vt |= 0x100;
        if (Cr07 & BIT(5)) Vt |= 0x200;    
        if (Cr25 & BIT(0)) Vt |= 0x400; 

        // Check for error conditions
        if ((Vre <= Vrs) || (Vrs < Vde) || (Vre > Vt))
        {
            rmStatus = RM_ERROR;
            goto done;
        }

        /*
        // Make sure we don't change these values during the vblank interval.
        while (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK) != NV_PCRTC_RASTER_VERT_BLANK_ACTIVE)
            ;
        while (REG_RD_DRF(_PCRTC, _RASTER, _VERT_BLANK) != NV_PCRTC_RASTER_VERT_BLANK_INACTIVE)
            ;
        */

        SetRetraceH(pDev, Head, Hrs, Hre);
        SetRetraceV(pDev, Head, Vrs, Vre);

        CRTC_WR(0x21, Cr21, Head);

        // the lower 4 bits in CR11 were updated by SetRetraceV(), don't mess it up
        CRTC_RD(NV_CIO_CR_VRE_INDEX, UpdatedCr11, Head);
        Cr11 = (Cr11 & ~BITS0_3) | (UpdatedCr11 & BITS0_3);
        CRTC_WR(NV_CIO_CR_VRE_INDEX, Cr11, Head);

     done:
        RestoreLock(pDev, Head, lock);
    }
    else // FP timing
    {
        PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
        // The default timing is in the dac object. Only the sync timings change.
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        
        // Check that the sync pulse is between display end and total
        if ((Hrs <= pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth) || (Hre >= pVidLutCurDac->HalObject.Dac[0].TotalWidth))
        {
            rmStatus = RM_ERROR;
        }
        // 
        if ((Vrs <= pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight) || (Vre >= pVidLutCurDac->HalObject.Dac[0].TotalHeight))
        {
            rmStatus = RM_ERROR;
        }
        if (rmStatus == RM_OK) 
        {
            // The timings are reasonable, write them to HW        
            DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_START, Hrs, Head);
            DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_END, Hre, Head);
            DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_START, Vrs, Head);
            DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_END, Vre, Head);
        }
    }

    return rmStatus;
}
 
//  Get the H & V Blank and retrace values from nvinfo.
VOID dacGetMonitorDefaultPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    *pHbs,
    U032    *pHbe,
    U032    *pVbs,
    U032    *pVbe,
    U032    *pHrs,
    U032    *pHre,
    U032    *pVrs,
    U032    *pVre
)
{
    PDACMONITORPOSITION pDacMonPos;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;


    if (Head == 0) // TODO: don't assume Head B = FP; use DCB
    {
        // We saved the timings when did the modeset (NOTE: they are also in the DAC object, 
        // so it is no longer necessary to have this structure)
        pDacMonPos = &pDev->Dac.CrtcInfo[Head].MonitorPosition;

        *pHbs = pDacMonPos->Hbs;
        *pHbe = pDacMonPos->Hbe;
        *pVbs = pDacMonPos->Vbs;
        *pVbe = pDacMonPos->Vbe;
        *pHrs = pDacMonPos->Hrs;
        *pHre = pDacMonPos->Hre;
        *pVrs = pDacMonPos->Vrs;
        *pVre = pDacMonPos->Vre;
    }
    else
    {
        // The timings are in the DAC object
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        
        *pHbs = pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart;
        *pHbe = *pHbs + pVidLutCurDac->HalObject.Dac[0].HorizontalBlankWidth;
        *pVbs = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
        *pVbe = *pVbs + pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight;
        *pHrs = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart;
        *pHre = *pHrs + pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth;
        *pVrs = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart;
        *pVre = *pVrs + pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight;

    }
}

//  Get a string pointing to a key in the Display section
//  The string is of the type hresxyres, e.g. "1024x768"
//  Return 0 if its not a desktop mode
void dacFindRegistryKeyDisplayPosition
(
    PHWINFO pDev,
    U032    Head,
    BOOL    isMonitor,
    char    *strDisplayMode
)
{
    U032    hres, vres;
    U032    strIndex;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hres = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vres = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    //
    // For non-TV modes, convert the resolution into a string
    //
    // Oh, to have a sscanf() handy...
    //
    strIndex = 0;   // start at the beginning

    //
    // Prepend the TV format if necessary
    //
    if (!isMonitor)
    {
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
                strDisplayMode = osStringCopy(strDisplayMode, "NTSC");
                strIndex = 4;
                break;
            case PAL_M: // unique case; does not use normal PAL timing
                strDisplayMode = osStringCopy(strDisplayMode, "PALM");
                strIndex = 4;
                break;
            default:    // rest are PAL modes
                strDisplayMode = osStringCopy(strDisplayMode, "PAL");
                strIndex = 3;
                break;     
        }
    }

    //
    // Assume the resolution is always below 9999x9999 and above 99x99
    // (this makes it a bit easier, especially with floating 0's)
    //
    // Start with the horizontal resolution first
    //
    if (hres / 1000)
    {
        strDisplayMode[strIndex++] = (U008)(hres/1000)+'0';
        hres -= (hres/1000)*1000;
    }

    if (hres / 100)
    {
        strDisplayMode[strIndex++] = (U008)(hres/100)+'0';
        hres -= (hres/100)*100;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    if (hres / 10)
    {
        strDisplayMode[strIndex++] = (U008)(hres/10)+'0';
        hres -= (hres/10)*10;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    strDisplayMode[strIndex++] = (U008)hres + '0';

    //
    // Append a lower case 'x'
    //
    strDisplayMode[strIndex++] = 'x';

    // 
    // Now generate the vertical value
    //
    if (vres / 1000)
    {
        strDisplayMode[strIndex++] = (U008)(vres/1000)+'0';
        vres -= (vres/1000)*1000;
    }
    
    if (vres / 100)
    {
        strDisplayMode[strIndex++] = (U008)(vres/100)+'0';
        vres -= (vres/100)*100;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    if (vres / 10)
    {
        strDisplayMode[strIndex++] = (U008)(vres/10)+'0';
        vres -= (vres/10)*10;
    }
    else
        strDisplayMode[strIndex++] = '0';
    
    strDisplayMode[strIndex++] = (U008)vres + '0';

    //
    // Zero append to the end
    //
    strDisplayMode[strIndex] = 0;

    return;

}

//  Save the screen position for the current mode in the registry
//  Find the registry key for this device and this mode
RM_STATUS dacWriteDesktopPositionToRegistry
(
    PHWINFO pDev,
    U032    Head,
    BOOL    isMonitor,
    U008 *  position, 
    U032    numBytes
)
{
    U032    i;
    char    strDisplayMode[] = "12345678901234567890";
    //
    // Generate the path to the registry key--last character is the display number
    //
    dacFindRegistryKeyDisplayPosition(pDev, Head, isMonitor, strDisplayMode);
    i = osStringLength(strDisplayMode);
    strDisplayMode[i++] = '_';
    strDisplayMode[i++] = ((U008)Head + '0');
    strDisplayMode[i] = 0;

    return osWriteRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, position, numBytes);
}

//  Read the screen position for the current mode from the registry
RM_STATUS dacReadDesktopPositionFromRegistry
(
    PHWINFO pDev,
    U032    Head,
    BOOL    isMonitor,
    U008 *  position, 
    U032 *  numBytes
)
{
    U032    i;
    char    strDisplayMode[] = "12345678901234567890";

    //
    // Generate the path to the registry key--last character is the display number
    //
    dacFindRegistryKeyDisplayPosition(pDev, Head, isMonitor, strDisplayMode);
    i = osStringLength(strDisplayMode);
    strDisplayMode[i++] = '_';
    strDisplayMode[i++] = ((U008)Head + '0');
    strDisplayMode[i] = 0;

    return osReadRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, position, numBytes);
}

//  Return the registry values for TV position, brightness, contrast and flicker filter.
RM_STATUS dacReadTVDesktopPositionFromRegistry
(
    PHWINFO pDev,
    U032 Head,
    U008 *Params,
    U032 *numBytes
)
{
    U032    i;
    char    strDisplayMode[] = "12345678901234567890";

    //
    // Generate the path to the registry key--last character is the display number
    //
    dacFindRegistryKeyDisplayPosition(pDev, Head, 0, strDisplayMode);
    i = osStringLength(strDisplayMode);
    strDisplayMode[i++] = '_';
    strDisplayMode[i++] = ((U008)Head + '0');
    strDisplayMode[i] = 0;

    return osReadRegistryBinary(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, Params, numBytes);
}

//  Read the TV type (NTSC_, PAL_) from the registry
//  The registry key is DeviceX, X= 0,1,2,... under the Display key.
RM_STATUS dacReadTVStandardFromRegistry
(
    PHWINFO pDev,
	U032 *	type
)
{

    return OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strTVtype, type);
}

//  Write the TV type (NTSC_, PAL_) from the registry
//  The registry key is DeviceX, X= 0,1,2,... under the Display key.
RM_STATUS dacWriteTVStandardToRegistry
(
    PHWINFO pDev,
	U032 	type
)
{

    return osWriteRegistryDword(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strTVtype, type);
}

//  Read the TV Out format (Composite on S-video, S-Video, Auto select)
//  The registry key is DeviceX, X= 0,1,2,... under the Display key.
RM_STATUS dacReadTVOutFromRegistry
(
    PHWINFO pDev,
    U032    Head,
    U032   *type
)
{
    return OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strTVOutType, type);
}

//  Check Registry for Philips 7108B special setting
RM_STATUS dacReadTVPhilipsBFromRegistry
(
    PHWINFO pDev,
    U032    Head,
    U032   *type
)
{
char strTVPhilipsB[] = "Philips7108B";

    return OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strTVPhilipsB, type);
}

//  Write the TV Out format (Composite on S-video, S-Video, Auto select)
//  The registry key is DeviceX, X= 0,1,2,... under the Display key.
RM_STATUS dacWriteTVOutToRegistry
(
    PHWINFO pDev,
    U032    Head,
    U032    type
)
{
    pDev->Dac.TVoutput = type;  // save in pDev, because NT cannot read registry at modeset time.
    return osWriteRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strTVOutType, type);
}

//  Look for registry entry telling us how to treat monitor syncs when monitor is not in use.
//  If we find "PowerSaverHsyncOn", we'll turn on Hsync & leave Vsync on when we want to blank the CRT
//  but driver DFP or TV on the same head. Otherwise, we'll turn off HSync, which is the legacy
//  method for communicating power mgmt requests to displays.
RM_STATUS dacReadMonitorSyncsFromRegistry
(
    PHWINFO pDev,
    U032   *type
)
{
    char strMonitorSyncs[] = "PowerSaverHsyncOn";

    return OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strMonitorSyncs, type);
}


RM_STATUS dacGetMonitorInfo
(
    PHWINFO pDev,
    U032    Head,
    U032    *MonitorConnected
)
{
    *MonitorConnected = 0;

    if (dacMonitorConnectStatus(pDev, Head))
        *MonitorConnected = 1;
    return RM_OK;
}
// Write a CRTC timing parameter into the CRTC registers
VOID dacSetCRTC
(
    PHWINFO pDev, 
    U032 Head, 
    U032 Param, 
    U032 Val
)
{
    U008 Crtc;
    U032 Val2;

    switch (Param) 
    {
    case H_TOTAL:
        Val2 = (Val >> 3) - 5;
        Crtc = (U008)(Val2 & 0xff);
        CRTC_WR(0, Crtc, Head);
        CRTC_RD(0x2D, Crtc, Head);
        Crtc &= ~BIT(0);
        if (Val2 & 0x100)               
            Crtc |= BIT(0);
        CRTC_WR(0x2D, Crtc, Head);
        break;
    case H_DISPLAY_END:
        Crtc = (U008) ((Val >> 3) - 1);
        CRTC_WR(1, Crtc, Head);
        break;
    case H_BLANK_START:
        Val2 = (Val >> 3) - 1;
        Crtc = (U008)(Val2 & 0xff);
        CRTC_WR(2, Crtc, Head);
        CRTC_RD(0x2D, Crtc, Head);
        Crtc &= ~BIT(2);
        if (Val2 & 0x100)               
            Crtc |= BIT(2);
        CRTC_WR(0x2D, Crtc, Head);
        break;
    case H_BLANK_END:
        Val2 = (Val >> 3) - 1;
        CRTC_RD(3, Crtc, Head);     // HBE bits 4:0
        Crtc &= 0xe0;
        Crtc |= (U008)(Val2 & 0x1f);
        CRTC_WR(3, Crtc, Head);
        CRTC_RD(5, Crtc, Head);
        Crtc &= ~BIT(7);
        if (Val2 & 0x20)               // HBE bit 5
            Crtc |= BIT(7);
        CRTC_WR(5, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(4);
        if (Val2 & 0x40)
            Crtc |= BIT(4);             // HBE bit 6
        CRTC_WR(0x25, Crtc, Head);
        break;
    case H_RETRACE_START:
        Val2 = (Val >> 3) + 1;
        Crtc = (U008) (Val2 & 0xFF);
        CRTC_WR(4, Crtc, Head);
        CRTC_RD(0x2D, Crtc, Head);
        Crtc &= ~BIT(3);
        if (Val2 & 0x100)
            Crtc |= BIT(3);
        CRTC_WR(0x2D, Crtc, Head);
        break;
    case H_RETRACE_END:
        Val2 = (Val >> 3) + 1;
        CRTC_RD(5, Crtc, Head);     // HRE bits 4:0
        Crtc &= 0xe0;
        Crtc |= (U008)(Val2 & 0x1f);
        CRTC_WR(5, Crtc, Head);
        break;
    case V_TOTAL:
        Val2 = Val - 2;
        Crtc = (U008) Val2;
        CRTC_WR(6, Crtc, Head);
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~(0x21);
        if (Val2 & 0x100) Crtc |= BIT(0);
        if (Val2 & 0x200) Crtc |= BIT(5);
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(0);
        if (Val2 & 0x400) Crtc |= BIT(0);
        CRTC_WR(0x25, Crtc, Head);
        CRTC_RD(0x41, Crtc, Head);
        Crtc &= ~BIT(0);
        if (Val2 & 0x800) Crtc |= BIT(0);
        CRTC_WR(0x41, Crtc, Head);
        break;
    case V_DISPLAY_END:
        Val2 = Val - 1;
        Crtc = (U008) Val2;
        CRTC_WR(0x12, Crtc, Head);    // VDE 7:0
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~(0x42);
        if (Val2 & 0x100) Crtc |= BIT(1);  // VDE 8
        if (Val2 & 0x200) Crtc |= BIT(6);  // VDE 9
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(1);
        if (Val2 & 0x400) Crtc |= BIT(1);  // VDE 10
        CRTC_WR(0x25, Crtc, Head);
        break;
    case V_RETRACE_START:
        Val2 = Val - 1;
        Crtc = (U008) Val2;
        CRTC_WR(0x10, Crtc, Head);
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~(BIT(2) | BIT(7));
        if (Val2 & 0x100) Crtc |= BIT(2);  // VRS 8
        if (Val2 & 0x200) Crtc |= BIT(7);  // VRS 9
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(2);
        if (Val2 & 0x400) Crtc |= BIT(2);  // VRS 10
        CRTC_WR(0x25, Crtc, Head);
        CRTC_RD(0x41, Crtc, Head);
        Crtc &= ~BIT(4);
        if (Val2 & 0x800) Crtc |= BIT(4);  // VRS 11
        CRTC_WR(0x41, Crtc, Head);
        break;
    case V_RETRACE_END:
        Val2 = Val - 1;
        CRTC_RD(0x11, Crtc, Head);
        Crtc &= 0xF0;
        Crtc |= (U008) (Val2 & 0x0F);
        CRTC_WR(0x11, Crtc, Head);
        break;
    case V_BLANK_START:
        Val2 = Val - 1;
        Crtc = (U008) Val2;
        CRTC_WR(0x15, Crtc, Head);
        CRTC_RD(7, Crtc, Head);
        Crtc &= ~BIT(3);
        if (Val2 & 0x100) Crtc |= BIT(3);  // VBS 8
        CRTC_WR(7, Crtc, Head);
        CRTC_RD(9, Crtc, Head);
        Crtc &= ~BIT(5);
        if (Val2 & 0x200) Crtc |= BIT(5);  // VBS 9
        CRTC_WR(9, Crtc, Head);
        CRTC_RD(0x25, Crtc, Head);
        Crtc &= ~BIT(3);
        if (Val2 & 0x400) Crtc |= BIT(3);  // VBS 10
        CRTC_WR(0x25, Crtc, Head);
        CRTC_RD(0x41, Crtc, Head);
        Crtc &= ~BIT(6);
        if (Val2 & 0x800) Crtc |= BIT(6);  // VBS 11
        CRTC_WR(0x41, Crtc, Head);
        break;
    case V_BLANK_END:
        Crtc = (U008) Val - 1;
        CRTC_WR(0x16, Crtc, Head);
        break;
    }
}

// Write a CRTC timing parameter into the CRTC registers
U032 dacGetCRTC
(
    PHWINFO pDev, 
    U032 Head, 
    U032 Param
)
{
    U008 Crtc;
    U032 Val=0, Val2;

    switch (Param) 
    {
    case H_TOTAL:
        CRTC_RD(0, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(0x2D, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x100;
        Val = (Val + 5) * 8;
        break;
    case H_DISPLAY_END:
        CRTC_RD(1, Crtc, Head);
        Val = (U032)(Crtc + 1) * 8;
        break;
    case H_BLANK_START:
        CRTC_RD(2, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(0x2D, Crtc, Head);
        if (Crtc & BIT(2)) Val |= 0x100;
        Val = (Val + 1) * 8;
        break;
    case H_BLANK_END:
        CRTC_RD(3, Crtc, Head);     // HBE bits 4:0
        Val = (U032)(Crtc & 0x1f);
        CRTC_RD(5, Crtc, Head);
        if (Crtc & 0x80) Val |= 0x20;
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(4)) Val |= 0x40;
        Val++;
        Val2 = dacGetCRTC(pDev, Head, H_BLANK_START);
        Val2 >>= 3;                     // convert HRS back to real chars
        Val2++;
        if (Val >= (Val2 & 0x7f))       // if end > start, just add upper bits of start 
        {
            Val |= (Val2 & 0x180);
        }
        else
        {
            Val |= ((Val2 + 0x80) & 0x180);    // add Start + carry
        }
        Val *= 8;
        break;
    case H_RETRACE_START:
        CRTC_RD(4, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(0x2D, Crtc, Head);
        if (Crtc & BIT(3)) Val |= 0x100;
        Val--;
        Val *= 8;
        break;
    case H_RETRACE_END:
        CRTC_RD(5, Crtc, Head);     // HRE bits 4:0
        Val = (U032)(Crtc & 0x1f);
        Val--;
        Val2 = dacGetCRTC(pDev, Head, H_RETRACE_START);
        Val2 >>= 3;                     // convert HRS back to real chars
        Val2--;
        if (Val >= (Val2 & 0x1f))       // if end > start, just add upper bits of start 
        {
            Val |= (Val2 & 0x1E0);
        }
        else
        {
            Val |= ((Val2 + 0x20) & 0x1E0);    // add Start + carry
        }
        Val *= 8;
        break;
    case V_TOTAL:
        CRTC_RD(6, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x100;
        if (Crtc & BIT(5)) Val |= 0x200;
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x400;
        CRTC_RD(0x41, Crtc, Head);
        if (Crtc & BIT(0)) Val |= 0x800;
        Val += 2;
        break;
    case V_DISPLAY_END:
        CRTC_RD(0x12, Crtc, Head);    // VDE 7:0
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(1)) Val |= 0x100;  // VDE 8
        if (Crtc & BIT(6)) Val |= 0x200;  // VDE 9
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(1)) Val |= 0x400;  // VDE 10
        Val++;
        break;
    case V_RETRACE_START:
        CRTC_RD(0x10, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(2)) Val |= 0x100;  // VRS 8
        if (Crtc & BIT(7)) Val |= 0x200;  // VRS 9
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(2)) Val |= 0x400;  // VRS 10
        CRTC_RD(0x41, Crtc, Head);
        if (Crtc & BIT(4)) Val |= 0x800;  // VRS 11
        Val++;
        break;
    case V_RETRACE_END:
        CRTC_RD(0x11, Crtc, Head);
        Val = (U032)(Crtc & 0x0f);
        Val2 = dacGetCRTC(pDev, Head, V_RETRACE_START);
        if (Val >= (Val2 & 0x0f))       // if end > start, just add upper bits of start 
        {
            Val |= (Val2 & 0xFF0);
        }
        else
        {
            Val |= ((Val2 + 0x10) & 0xFF0);    // add Start + carry
        }
        Val++;
        break;
    case V_BLANK_START:
        CRTC_RD(0x15, Crtc, Head);
        Val = (U032)Crtc;
        CRTC_RD(7, Crtc, Head);
        if (Crtc & BIT(3)) Val |= 0x100;  // VBS 8
        CRTC_RD(9, Crtc, Head);
        if (Crtc & BIT(5)) Val |= 0x200;  // VBS 9
        CRTC_RD(0x25, Crtc, Head);
        if (Crtc & BIT(3)) Val |= 0x400;  // VBS 10
        CRTC_RD(0x41, Crtc, Head);
        if (Crtc & BIT(6)) Val |= 0x800;  // VBS 11
        Val++;
        break;
    case V_BLANK_END:
        CRTC_RD(0x16, Crtc, Head);
        Val = (U032)Crtc + 1;
        Val2 = dacGetCRTC(pDev, Head, V_RETRACE_START); // End = Start + width of sync
        if (Val >= (Val2 & 0xff))    // if low byte of end > low byte of start 
        {
            Val |= (Val2 & 0xf00);  // combine with upper bits of V_BLANK_START
        }
        else
        {
            Val |= ((Val2 + 0x100) & 0xf00);    // combine with upper bits of V_BLANK_START plus carry
        }
        break;
    }
    return Val;
}
//  Get CRTC timing values from either CRTC registers or Windows registry
RM_STATUS dacGetCRTCTiming
(
    PHWINFO pDev,
    U032    Head,
    NV_CFGEX_CRTC_TIMING_PARAMS    *Params
)
{
    U008    lock;

    if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTER) // Get currect CRTC values
    {
        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);
        
        Params->HTotal = dacGetCRTC(pDev, Head, H_TOTAL);    
        Params->HDisplayEnd = dacGetCRTC(pDev, Head, H_DISPLAY_END);    
        Params->HBlankStart = dacGetCRTC(pDev, Head, H_BLANK_START);    
        Params->HBlankEnd = dacGetCRTC(pDev, Head, H_BLANK_END);    
        Params->HRetraceStart = dacGetCRTC(pDev, Head, H_RETRACE_START);    
        Params->HRetraceEnd = dacGetCRTC(pDev, Head, H_RETRACE_END);    
        Params->VTotal = dacGetCRTC(pDev, Head, V_TOTAL);    
        Params->VDisplayEnd = dacGetCRTC(pDev, Head, V_DISPLAY_END);    
        Params->VRetraceStart = dacGetCRTC(pDev, Head, V_RETRACE_START);    
        Params->VRetraceEnd = dacGetCRTC(pDev, Head, V_RETRACE_END);    
        Params->VBlankStart = dacGetCRTC(pDev, Head, V_BLANK_START);    
        Params->VBlankEnd = dacGetCRTC(pDev, Head, V_BLANK_END);    
        
        RestoreLock(pDev, Head, lock);
        return RM_OK;
    }
    else if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTRY)   // Get values from registry
    {

        char    *strptr;
        U032    numBytes;
        char    strDisplayMode[] = "12345678901234567890";

        // fill in the path to the registry key--last character is the display number
        //JJV-New registry Process size = osStringLength(strDevNodeDisplayNumber);
        //JJV-New registry Process strDevNodeDisplayNumber[size - 1] = ('0' | (U008)devInstance);    // fill in ascii device #
        // now get the specific entry we need
        dacFindRegistryKeyDisplayPosition(pDev, Head, TRUE, strDisplayMode);
        // Copy the string and append the head number
        
        for (strptr = strDisplayMode; *strptr != 0; strptr++) 
            ;
        *strptr++ = '_';
        *strptr++ = (char)(Head | 0x30);
        *strptr++ = 'T';                    // make sure to use different key than desktop position
        *strptr   = 0;
        return osReadRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, (U008 *)&Params->HTotal, &numBytes);
    }
    else // return default values for current mode
    {

        PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

        //
        // Grab the current dac settings (last modeset to come through on this head)
        //
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;


        Params->HTotal = pVidLutCurDac->HalObject.Dac[0].TotalWidth;    
        Params->HDisplayEnd = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
        Params->HBlankStart = pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart;
        Params->HBlankEnd = (pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart +
                                            pVidLutCurDac->HalObject.Dac[0].HorizontalBlankWidth);
        Params->HRetraceStart = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart;
        Params->HRetraceEnd = (pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart +
                                            pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth);
        Params->VTotal = pVidLutCurDac->HalObject.Dac[0].TotalHeight;
        Params->VDisplayEnd = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
        Params->VRetraceStart = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart;
        Params->VRetraceEnd = (pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight);
        Params->VBlankStart = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
        Params->VBlankEnd = (pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart +
                                            pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight);

        //
        // There is a bug in NV hardware where the hardware cursor will not clip correctly
        // if a border is defined in the display timings (blank start != visible end).
        //
        // Borders are only defined in two specific DMT modes, so generally this is
        // not a problem.
        //
        // To fix this, set the blank starts to match the visible totals and remove the 
        // implicit borders.
        //
        // Remove this code when the hardware gets fixed.  Since this bug has been in the 
        // hardware since 1994, don't expect a fix soon.
        //
        //HorizontalBlankStart = HorizontalVisible;
        //HorizontalBlankEnd   = HorizontalTotal;
        //VerticalBlankStart   = VerticalVisible;
        //VerticalBlankEnd     = VerticalTotal;
        //
        // We want to return "default" values that match what the hardware really wants
        // us to program, not the true borders that exist in the DMT.  Otherwise a
        // client that uses this call to get hardware defaults, and then turns around
        // and programs the hardware with them, will get incorrect timings.
        //
        Params->HBlankStart = Params->HDisplayEnd;
        Params->HBlankEnd = Params->HTotal;
        Params->VBlankStart = Params->VDisplayEnd;
        Params->VBlankEnd = Params->VTotal;

        return RM_OK;
    }
}

//  Write caller's CRTC timing values into CRTC register and/or Windows Registry
RM_STATUS dacSetCRTCTiming
(
    PHWINFO pDev,
    U032    Head,
    NV_CFGEX_CRTC_TIMING_PARAMS    *Params
)
{

    U008    lock, data08;

    if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTER) // Set CRTC values
    {
        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
        CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 & ~0x80, Head);    // unlock CR0-7


        // Write the CRTC's        
        dacSetCRTC(pDev, Head, H_TOTAL, Params->HTotal);
        dacSetCRTC(pDev, Head, H_DISPLAY_END, Params->HDisplayEnd);
        dacSetCRTC(pDev, Head, H_BLANK_START, Params->HBlankStart);
        dacSetCRTC(pDev, Head, H_BLANK_END, Params->HBlankEnd);       
        dacSetCRTC(pDev, Head, H_RETRACE_START, Params->HRetraceStart);
        dacSetCRTC(pDev, Head, H_RETRACE_END, Params->HRetraceEnd);     
        dacSetCRTC(pDev, Head, V_TOTAL, Params->VTotal);
        dacSetCRTC(pDev, Head, V_DISPLAY_END, Params->VDisplayEnd);
        dacSetCRTC(pDev, Head, V_BLANK_START, Params->VBlankStart);
        dacSetCRTC(pDev, Head, V_BLANK_END, Params->VBlankEnd);
        dacSetCRTC(pDev, Head, V_RETRACE_START, Params->VRetraceStart);
        dacSetCRTC(pDev, Head, V_RETRACE_END, Params->VRetraceEnd);

        //
        // Lock everything back up again
        //
        CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
        CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 | 0x80, Head);    // lock CR0-7
        RestoreLock(pDev, Head, lock);
    }
    if (Params->Reg & NV_CFGEX_CRTC_TIMING_REGISTRY) // Set Register values
    {
        char    *strptr;
        U032    numBytes = (NV_CFGEX_CRTC_PARAMS * 4) - 8;  // HTotal is 8 bytes in
        char    strDisplayMode[] = "12345678901234567890";

        // fill in the path to the registry key--last character is the display number
        //JJV-New registry Process size = osStringLength(strDevNodeDisplayNumber);
        //JJV-New registry Process strDevNodeDisplayNumber[size - 1] = ('0' | (U008)devInstance);    // fill in ascii device #
        // now get the specific entry we need
        dacFindRegistryKeyDisplayPosition(pDev, Head, TRUE, strDisplayMode);
        // append the head number
        for (strptr = strDisplayMode; *strptr != 0; strptr++) 
            ;
        *strptr++ = '_';
        *strptr++ = (char)(Head | 0x30);
        *strptr++ = 'T';                    // make sure to use different key than desktop position
        *strptr   = 0;
        return osWriteRegistryBinary(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strDisplayMode, (U008 *)&Params->HTotal, numBytes);
    }
    return RM_OK;
}

//	See what is currently being used as a display
U032 dacGetBiosDisplayType
(
    PHWINFO pDev,
    U032    Head
)
{
    U008  	rc;
    U032 	displayType;
    U008	lock;               

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, rc, Head);
    if (rc & 0x80)    // is VGA slaved to something?
    {
        CRTC_RD(NV_CIO_CRE_LCD__INDEX, rc, Head);
        if (rc & 0x01)
            displayType = DISPLAY_TYPE_FLAT_PANEL;   
        else
            displayType = DISPLAY_TYPE_TV;      
    }
    else
    {
        displayType = DISPLAY_TYPE_MONITOR;
    }

    RestoreLock(pDev, Head, lock);

    return displayType;
}

//
// Determine which is the boot head by checking which head has an active
// display set (this mechanism breaks with simul-mode). This should only
// be called from initDac.
//
U032 dacGetBiosDisplayHead
(
    PHWINFO pDev
)
{
    U008 lock, cr4b_A, cr3b_A, cr3b_B;

    // headA for non-NV11
    if (IsNV11(pDev) == FALSE)
        return 0;

    lock = UnlockCRTC(pDev, 0);
    CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, cr4b_A, 0);
    RestoreLock(pDev, 0, lock);

    // headA if this is not a Mobile BIOS
    if ((cr4b_A & NV_IS_MOBILE_BIOS) == 0) 
        return 0;

    // read out the current display (7:4 of CR3B) for both heads
    lock = UnlockCRTC(pDev, 0);
    CRTC_RD(NV_CIO_CRE_SCRATCH3__INDEX, cr3b_A, 0);
    RestoreLock(pDev, 0, lock);

    lock = UnlockCRTC(pDev, 1);
    CRTC_RD(NV_CIO_CRE_SCRATCH3__INDEX, cr3b_B, 1);
    RestoreLock(pDev, 1, lock);

    // error check if both heads have non-zero current displays
    if ((cr3b_A & 0xF0) && (cr3b_B & 0xF0))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "dacGetBiosDisplayHead - both heads have current displays\n");
        return 0;
    }

    if (cr3b_B & 0xF0)
        return 1;
    else
        return 0;
}

//
// This routine is ugly!
// It is used to clear the bits in the bios scratch register CR3B on the non-primary
// head when more than one head is active.
// One instance where this is needed is on portables when going into hibernation
// under win2k.  Normally, the monitors are supposed to be left on and a hibernation
// progress screen is displayed in vga mode.  But since broadcast mode is broken,
// if we don't clear the bits in the scratch register on the non-primary head, then
// one screen will display the hibernation progress screen and the other will display
// garbage.
// This routine will return TRUE if the other head is active.
//
BOOL dacDisableBroadcast
(
    PHWINFO pDev,
    U032    headSecondary,
    U008   *reg3B
)
{
    BOOL otherHeadActive;
    U008 lock[2];
    U008 cr3B[2];
    U032 headPrimary;

    //
    // Only need to execute on NV11's that don't support broadcast.
    //
    otherHeadActive = FALSE;
    if (IsNV11(pDev))
    {
        headPrimary = 1 - headSecondary;
        if (pDev->Power.MobileOperation)
        {
            //
            // MOBILE
            //
            // Unlock the registers.
            //
            lock[0] = UnlockCRTC(pDev, 0);
            lock[1] = UnlockCRTC(pDev, 1);
            //
            // Get current register values.
            //
            CRTC_RD(0x3B, cr3B[0], 0);
            CRTC_RD(0x3B, cr3B[1], 1);
            //
            // Return the original value of reg cr3B for the head being disabled.
            //
            if (reg3B)
                *reg3B = cr3B[headSecondary];
            //
            // Check if the other head is active.
            //
            if (cr3B[headPrimary] & 0xF0)
            {
                //
                // Mark the specified head as disabled.
                //
                cr3B[headSecondary] &= 0x0F;
                CRTC_WR(0x3B, cr3B[headSecondary], headSecondary);
                otherHeadActive = TRUE;
                //
                // Enable the primary head so any subsequent vga modesets will be be done on the
                // correct head by the bios.
                //
                EnableHead(pDev, headPrimary);
            }
            //
            // Restore the register locks.
            //
            RestoreLock(pDev, 0, lock[0]);
            RestoreLock(pDev, 1, lock[1]);
        }
        else
        {
            //
            // DESKTOP
            //
            // If the display on head 1 is on, turn it off to avoid
            // seeing garbage on it while in vga mode.
            if (pDev->Power.DisplayState[1] != MC_POWER_LEVEL_6)
            {
                //
                // Use the power management routines to turn the display on head 1 off.
                //
                mcPowerDisplayState(pDev, MC_POWER_LEVEL_6, 1);
                //
                // not really in MC_POWER_LEVEL_6 power management state, so leave
                // the power level state set to MC_POWER_LEVEL_5.
                //
                pDev->Power.DisplayState[1] = MC_POWER_LEVEL_5;
            }
            //
            // Whatever is the the active display on head a is the display that we
            // want to enable.  That's what the bios expects to be programming when
            // doing a modeset.
            // One negative side effect of this is that in clone mode with the DFP as the
            // primary display, opening a full screen dos box will not display on the DFP.
            // it will display on whatever display is on head a.
            //
            EnableHead(pDev, 0);
        }
    }
    return (otherHeadActive);
}
BOOL dacRestoreBroadcast
(
    PHWINFO pDev,
    U032    head,
    U008    reg3B
)
{
    BOOL regRestored = FALSE;
    U008 lock;

    if (IsNV11(pDev) && pDev->Power.MobileOperation)
    {
        lock = UnlockCRTC(pDev, head);
        CRTC_WR(0x3B, reg3B, head);
        RestoreLock(pDev, head, lock);
        regRestored = TRUE;
    }
    return (regRestored);
}

//  Read analog out comparator 
//  If the output is loaded, it will be below threshold
//  If no CRT is attached, it will trip
U032 dacDetectTrigger(
    PHWINFO pDev
)
{
    U008 blank, data8;
    U032 retry;
    U032 LastFunc;

//define maxretries in 100us increments
#define MAXRETRIES 334
    
    // wait for active
    retry = 0;
    LastFunc=0;
    do {
        blank = REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x1;
        retry++; 
        tmrDelay(pDev,100000); //delay 100us
    } while((retry<MAXRETRIES)&&(blank));
    if (retry >= MAXRETRIES)
        goto timedout;

    
    // wait for blank
    retry = 0;
    LastFunc=1;
    do {
        blank = REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x1;
        retry++;
        tmrDelay(pDev,100000); //delay 100us
    } while ((retry < MAXRETRIES) && !blank);
    if (retry >= MAXRETRIES)
        goto timedout;

    // wait for active
    retry = 0;
    LastFunc=2;
    do {
        blank = REG_RD08(NV_PRMCIO_INP0__COLOR) & 0x1;
        retry++;
        tmrDelay(pDev,100000); //delay 100us
    } while ((retry < MAXRETRIES) && blank);
    if (retry >= MAXRETRIES)
        goto timedout;

    // get 2 samples which are the same to debounce
    retry = 0;
    LastFunc=3;
    do {
        data8 = (REG_RD08(NV_PRMCIO_INP0) & 0x10);
        retry++;
        tmrDelay(pDev,100000); //delay 100us
    } while ((retry < MAXRETRIES) && ((REG_RD08(NV_PRMCIO_INP0) & 0x10) != data8));
    if (retry >= MAXRETRIES)
    {
 timedout:
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: trigger detect timed out: ",LastFunc);
        return 2;
    }

    // sense bit in NV_PRMCIO_INP0 is inverted (0x1 = no trigger).
    if (data8)
    {
        // DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: DacDetectTrigger: False\n");
        return 0;    // no trigger
    }
    else
    {
        // DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: DacDetectTrigger: True\n");
        return 1;     // trigger
    }
}



// Check whether monitor is currently connected
BOOL dacMonitorConnectStatus
(
    PHWINFO pDev,
    U032    Head
)
{
    RM_STATUS status = RM_OK;
    U008      lock;
    U032      Current;
    U032      data;
    U032      force_flag = 0;

    if (using_new_api == FALSE) {
        //
        // Make sure monitor is supported on this head.
        //
        if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR)) == 0)
            return FALSE;

        //
        // For NV11 TwinView, make sure head isn't in use by another display device
        //
        if (!pDev->Power.MobileOperation)
            if (IsNV11(pDev))
            {
                if (GETDISPLAYTYPE(pDev, Head ^ 1) != 0xFFFFFFFF) // if both heads in use
                {
                    Current = GETDISPLAYTYPE(pDev, Head);
                    if (Current == DISPLAY_TYPE_FLAT_PANEL) // then only the current type is allowed (except TV)
                        return FALSE;
                }
            }

        // Mobile devices should never have CRT on Head 1
        if (pDev->Power.MobileOperation && (Head == 1)) 
            return FALSE;
    }

//#ifdef USE_EDID_TO_TEST_CRT_CONNECT
    if ((IsNV11(pDev)) && (Head == 1))
    {
        U032 prevHead = (pDev->Dac.HalInfo.Head2RegOwner & 0x1);
        PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
        U032 M,N,P;
        U032 CoeffSelect = 0;
        U032 Vpll2 = 0;
        U008 Cr28  = 0;
        U008 Cr33  = 0;
        // Attempt to read EDID and check for analog display. On head 1 there is no way to do the analog out test below.

        if (IsNV11(pDev))
           EnableHead(pDev, Head);

        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        
        // There are monitors which do not perform DDC unless they see valid sync timing. If we are on the DVI connector
        // (and on Head 1 we are), we must toggle syncs long enough to wake the monitor up so we can do DDC.
        if (pVidLutCurDac == NULL) // Currently in use?
        {
            if (pDev->Dac.HalInfo.InitialBootHead != 1) // And if not the boot device (this may be called before VidLutCurDac is created)
            {
                VIDEO_LUT_CURSOR_DAC_OBJECT VidLutCurDac;

                // Write 800x600 timing in the FP registers.
                DAC_REG_WR32(NV_PRAMDAC_FP_HCRTC, 800, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HDISPLAY_END, 799, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_START, 800, Head);    // START = END + 1 so no data goes out
                DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_END, 799, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_START, 799+16, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_END, 839, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HTOTAL, 1120, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VCRTC, 600, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VDISPLAY_END, 599, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_START, 600, Head);    // START = END + 1 so no data goes out
                DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_END, 599, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_START, 601, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_END, 625, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VTOTAL, 638, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _POS, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _POS, Head);
                // Give it a 40 MHz clock
                dacCalcMNP(pDev, Head, 4000, &M, &N, &P);   // 40 MHz
                FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG); 
                REG_WR32(NV_PRAMDAC_VPLL2_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                                DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                                DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);     // FPCLK ON

                // dacProgramCRTC need a couple of values set in addition to the arguments passed.
                pDev->Framebuffer.HalInfo.Start[Head] = 0;
                // need one field in a lut object, not other fields used
                VidLutCurDac.Image[0].Pitch = 0;
                // Set 800x600 60 timing to make sure CRT is alive
                dacProgramCRTC(pDev, Head, &VidLutCurDac, 800, 800, 840, 840+128, 800+256, 1056,
                                     600, 600, 601, 605, 628, 628, 8, 4000, 1, 1, 0);

                // Slave the CRTC to timing generator
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
                Cr28 |= BIT(7);
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head); 
                CRTC_RD(0x33, Cr33, Head);   // NV_CIO_CRE_LCD__INDEX
                CRTC_WR(0x33, Cr33 | 0x11, Head); // bits 0 & 4 are HW
                tmrDelay(pDev, 200000000); // delay 200 ms for monitor to see syncs
                
                // read EDID 
                status = EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);		// Try to read EDID
                
                // restore 
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28 & 0x7f, Head); // unslave CRTC
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);     // FPCLK OFF
                CRTC_WR(0x33, Cr33, Head);
            }
        }
        else
        {

            // In use, if used by TV, we must preserve timings.
            // On NV11, it can only be TV.
            if (pVidLutCurDac->DisplayType == DISPLAY_TYPE_TV)
            {
                // Write 800x600 timing in the FP registers.
                // CRTC timing may not match FP timing. This is OK; we only need valid sync timing.
                DAC_REG_WR32(NV_PRAMDAC_FP_HCRTC, 800, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HDISPLAY_END, 799, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_START, 800, Head);    // START = END + 1 so no data goes out
                DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_END, 799, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_START, 799+16, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_END, 839, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HTOTAL, 1120, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VCRTC, 600, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VDISPLAY_END, 599, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_START, 600, Head);    // START = END + 1 so no data goes out
                DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_END, 599, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_START, 601, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_END, 625, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VTOTAL, 638, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _POS, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _POS, Head);
                // Give it a 40 MHz clock
                Vpll2 = REG_RD32(NV_PRAMDAC_VPLL2_COEFF);
                dacCalcMNP(pDev, Head, 4000, &M, &N, &P);   // 40 MHz
                FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG); 
                REG_WR32(NV_PRAMDAC_VPLL2_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                                DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                                DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);     // FPCLK ON
                
                CoeffSelect = REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT);
                FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _NONE);   // clock source is not TV
                
                // Slave the CRTC to timing generator
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
                Cr28 |= BIT(7);
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head); 
                CRTC_RD(0x33, Cr33, Head);   // NV_CIO_CRE_LCD__INDEX
                CRTC_WR(0x33, Cr33 | 0x11, Head); // bits 0 & 4 are HW
                tmrDelay(pDev, 200000000); // delay 200 ms for monitor to see syncs
                
                // read EDID 
                status = EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);		// Try to read EDID
                
                // restore
                REG_WR32(NV_PRAMDAC_VPLL2_COEFF, Vpll2); 
                REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, CoeffSelect);
                CRTC_WR(0x33, Cr33, Head);
            }
        }
        
        RestoreLock(pDev, Head, lock);
        if (IsNV11(pDev))
           EnableHead(pDev, prevHead);


        if (OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, "ForceCRTDetect", &data) == RM_OK)
        {
            if (data == 1)
            {
                force_flag = 1;
            }
        }

        if (status == RM_OK)		
    	{
            if (edidIsAnalogDisplay(pDev, Head))
                return TRUE;
            else    
            {
                if (force_flag == 1)
                {
                    return TRUE;
                }
                return FALSE;
            }
    	}
        else
        {
            if (force_flag == 1)
            {
                return TRUE;
            }
            return FALSE;   // the analog test (below) will not work on head 1--it always returns TRUE.
        }
    }
//#endif

    // NOTE: for cards with 1 head (NV15/20/...) that can have a CRT plugged into the DVI-I port
    // EDIDDetect will always fail, relying on the call to dacVGAConnectStatus below to properly
    // detect the CRT.  This works because on NV15/20 and other cards with 1 head, the RGB/sync lines
    // are physically connected, so a dacVGAConnectStatus(pDev,0) on head 0 will detect a CRT regardless
    // of which I2C it is actually on.
    status = EDIDDetect(pDev, Head, DISPLAY_TYPE_MONITOR);      // Try to read EDID
    if (status) 
    {
        if (Head != 1) // Head 1 does not have an internal DAC, so we cannot do the analog check.
        {
            // EDID did not confirm that a CRT is connected, but it may be an older non-DDC CRT,
            // so procede with analog out test.
            return (dacVGAConnectStatus(pDev, Head));
        }
        return FALSE;       // EDID read failed on head1, so not CRT
    }

    return TRUE;
}

BOOL dacVGAConnectStatus
(
    PHWINFO pDev, 
    U032    Head
)
{
    U032    dacPowerDown;
    U016    Sr1;
    U032    retries;
    U032    result = 0;
    U032    prevHead = (pDev->Dac.HalInfo.Head2RegOwner & 0x1);
    U032    rgb, trigger, testColor, dacControl;
    U032    PramdacCoeffSelect, CurrentVClk;
    U008    Cr28, Cr1A, PixMask, lock;
    U032    done = 0;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: VGA connection detection on head ", Head);

    // This test drives a selected amount of current out the DAC output.
    // This currect causes a voltage drop over the terminating
    // resistor (no CRT connected) or the terminating resistor in parallel
    // with the CRT load.  There is a voltage comparator which is sampled at
    // port 3C2. (Actually 3, one for each color.)  This indicates whether the
    // voltage at the output resistor has crossed a reference level.  If a CRT
    // is connected, the amount of current required to reach this level will
    // be twice (this can vary depending on the board) that required if there
    // is not a CRT.  (e.g. 75 ohms on the board, in parallel with 75 ohms at
    // the monitor = 37.5 ohms).  At the selected current level, we check to
    // see whether the comparator has flipped.  If so, there must be no CRT
    // connected (75 ohm load). If not, there is additional loading, i.e.  a
    // CRT is connected.
    // NOTE: we could possibly improve this in terms of speed by using the palette mask register and only changing
    // one byte of framebuffer and one palette location. But then again, since there's RC delay to ramp up voltage, there may 
    // be no advantage.
    lock = UnlockCRTC(pDev, Head);

    // Sequencer updates require pointing at the appropriate head
    EnableHead(pDev, Head);

    Sr1 = ReadIndexed(NV_PRMVIO_SRX, 0x01);
    if (Sr1 & 0x2000)
        WriteIndexed(NV_PRMVIO_SRX, (U016)(Sr1 & ~0x2000));	// turn off blank

    // make sure the DAC is driving RGB out
    dacPowerDown = DAC_REG_RD32(NV_PRAMDAC_TEST_CONTROL, Head);
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON, Head);

    tmrDelay(pDev, 10000000);	// delay 10 ms to allow DAC to power up

    CurrentVClk = REG_RD32(NV_PRAMDAC_VPLL_COEFF);
    
    // We need to make sure that a mode is set up.  If there's no object and this is not the head the BIOS is using,
    // we should just go ahead and set up a dummy mode for the test.
    if((pDev->Dac.CrtcInfo[Head].pVidLutCurDac == NULL) && (Head != pDev->Dac.HalInfo.InitialBootHead))

    {
        VIDEO_LUT_CURSOR_DAC_OBJECT VidLutCurDac;
        U032 M,N,P;
        
        // Give it a 40 MHz clock
        dacCalcMNP(pDev, Head, 4000, &M, &N, &P);   // 40 MHz
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG); 
        REG_WR32(NV_PRAMDAC_VPLL_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);     // FPCLK ON

        // dacProgramCRTC need a couple of values set in addition to the arguments passed.
        pDev->Framebuffer.HalInfo.Start[Head] = 0;
        // need one field in a lut object, not other fields used
        VidLutCurDac.Image[0].Pitch = 0;
        // Set 800x600 60 timing to make sure CRT is alive
        dacProgramCRTC(pDev, Head, &VidLutCurDac, 800, 800, 840, 840+128, 800+256, 1056,
                             600, 600, 601, 605, 628, 628, 8, 4000, 1, 1, 0);

    }
    else
    {
        // If FP is output, it may be scaling, and so pixel clock is wrong for this mode. Get native clock.
        // NOTE for debugging: it's good to verify the output is changing color as we go thru the loop, but the
        // monitor may not be synced when the flat panel is the output device, because of the CRTC adjustments (esp. CR4).
        // NOTE 2: It is possible that pVidLutCurDac is NULL at this point.  This happens on Win2k when drivers are being
        // installed on the system for the very first time. In this case, the system will be running in vga mode.
        //
        if ((pDev->Dac.CrtcInfo[Head].pVidLutCurDac)
         && (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL))
        {
            VIDEO_LUT_CURSOR_DAC_OBJECT * pVidLutCurDac;
            U032 M,N,P;

            pVidLutCurDac = (VIDEO_LUT_CURSOR_DAC_OBJECT *)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
            dacCalcMNP(pDev, Head, pVidLutCurDac->HalObject.Dac[0].PixelClock, &M, &N, &P);   // get native VCLK
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG); 
            REG_WR32(NV_PRAMDAC_VPLL_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                            DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                            DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
        }
        // If TV, should be OK as is, if CRT, definitely OK
    }
    // Here's the "ramping up the palette" method for detecting if a CRT is
    // present, reimplemented from what the BIOS had. The USE_TESTPOINT_DATA
    // version seemed not very reliable and frequently gave false CRT
    // detections. 
    // 
    // The palette version in testing gave no false detections for many test
    // loops and did correctly detect the monitor when it was present. The
    // trigger value used was tested on NV5/NV10/NV15 and NV11.
    //
    
    // Make sure we have a PCLK before accessing the palette
    PramdacCoeffSelect = REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT);
    // Make PLL the source
    if (Head == 0) 
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK_TV, _NONE);
    }
    else
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _NONE);
    }
    // Not slaved, 8 bpp
    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28 & ~0x83, Head);    

    // Enable syncs
    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, Cr1A, Head);
    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, Cr1A & ~0xC0, Head);    

    // save the current palette (we only need one entry)
    DAC_REG_WR08(NV_USER_DAC_READ_MODE_ADDRESS, 0, Head);
    rgb = DAC_REG_RD08(NV_USER_DAC_PALETTE_DATA, Head);     // b
    rgb <<= 8;
    rgb |= DAC_REG_RD08(NV_USER_DAC_PALETTE_DATA, Head);    // g
    rgb <<= 8;
    rgb |= DAC_REG_RD08(NV_USER_DAC_PALETTE_DATA, Head);    // r
    
    // use the mask register to limit DAC lookup to the first entry
    PixMask = DAC_REG_RD08(NV_USER_DAC_PIXEL_MASK, Head);
    DAC_REG_WR08(NV_USER_DAC_PIXEL_MASK, 0, Head);
    
    // these values rely on being interpreted as 6 bits per color
    dacControl = DAC_REG_RD32(NV_PRAMDAC_GENERAL_CONTROL, Head);
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC, _6BITS, Head);
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIXMIX, _ON, Head); // set PIXMIX so that LUT is used

    // Ramp up the color until the comparator flips or we hit the top of our range
    for (trigger = 0x8; (trigger < 0x18) && ! done; trigger++)
    {
        testColor = trigger; // one color should do it. The BIOS uses all three. 
        // testColor |= trigger << 8;
        // testcolor |= trigger << 16;

        // write RGB of the first entry in the palette
        DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0, Head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, testColor >> 16, Head); // R
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, testColor >> 8, Head);  // G
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, testColor, Head);       // B
        
        retries = 0;
        
        do
        {
            result = dacDetectTrigger(pDev);
            if (result==2)
            {
                done = 1;    // exit the test now
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: vga connect timeout\n");
            }
        } while((result != dacDetectTrigger(pDev)) && (retries++ < 5));
        
        if (result == 1)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Trigger Detected\n");
            done = 1;
        }
    }
    // restore the mask register 
    DAC_REG_WR08(NV_USER_DAC_PIXEL_MASK, PixMask, Head);
    
    // restore the previous dac control
    DAC_REG_WR32(NV_PRAMDAC_GENERAL_CONTROL, dacControl, Head);

    // restore the previous palette value
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0, Head);
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, rgb >> 16, Head); // b
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, rgb >> 8, Head);  // g
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, rgb, Head);       // r

    // restore VCLK
    REG_WR32(NV_PRAMDAC_VPLL_COEFF, CurrentVClk);

    // restore the previous dac powerdown
    DAC_REG_WR32(NV_PRAMDAC_TEST_CONTROL, dacPowerDown, Head);

    // restore the previous SR1 value
    // sequencer updates require pointing at the appropriate head
    EnableHead(pDev, Head);
    WriteIndexed(NV_PRMVIO_SRX, (U016)Sr1);

    // restore previous CR44 value
    EnableHead(pDev, prevHead);
    // restore Cr28
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);    
    // restore syncs
    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, Cr1A, Head);    
    // restore clock source
    REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, PramdacCoeffSelect);

    RestoreLock(pDev, Head, lock);

    if (trigger < 0x18) // If trigger, there is less DC load, therefore no monitor
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: Monitor detect: FALSE\n");
        
        return FALSE;
    }
    else
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: Monitor detect: TRUE -- red trigger is: ", trigger);
        
        return TRUE;
    }
}


// Check whether flat panel is currently connected
BOOL dacFlatPanelConnectStatus
(
    PHWINFO pDev,
    U032    Head
)
{
    RM_STATUS status;
    U008 lock;

    if (using_new_api == FALSE) {
        //
        // Make sure flatpanel allowed on this head.
        //
        if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL)) == 0)
            return FALSE;

        //
        // If the other head is TV, we can't do it (P38 with external TMDS, P41 with internal is OK)
        // TODO: Need to change this to a dynamic check based on feedback from the BIOS topology table
        // If we're using the 12bit wide FP interface, then FP/TV can share and are allowed.
        //
        if ((GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_TV) && !pDev->Power.MobileOperation &&
            (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT))
            return FALSE;
    }

    lock = UnlockCRTC(pDev, Head);

    // read EDID 
    status = EDIDRead(pDev, Head, DISPLAY_TYPE_FLAT_PANEL);	// Try to read EDID

    RestoreLock(pDev, Head, lock);

    if (status != RM_OK)
        return FALSE;

    if (edidIsDigitalDisplay(pDev, Head)) 		// Check the display technology byte
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;
        return TRUE;
    }
    return FALSE;
}

U032 dacGetFlatPanelConfig
(
    PHWINFO pDev,
    U032    Head
)
{
    U032 mode;
    
    mode = DAC_REG_RD32(NV_PRAMDAC_FP_TG_CONTROL, Head); 
    return(DRF_VAL(_PRAMDAC, _FP_TG_CONTROL, _MODE, mode)); 
}
    
RM_STATUS dacGetFlatPanelInfo
(
    PHWINFO pDev,
    U032    Head,
    U032    *FpMode,
    U032    *FpMaxX,
    U032    *FpMaxY,
    BOOL    *FpConnected,
    BOOL    *FlatPanelNativeSupported,
    BOOL    fromRegistry
)
{
    U032      mode;
    RM_STATUS status;
    U008    i, chksum2 = 0xff, chksum = 0xff;
    BOOL    EdidOk = FALSE;

    // Not getting an EDID for the flat panel is catasrophic, so we'll do some retries if we fail.
    for (i=0; i<3; i++) 
    {
        // Get info from EDID
        if (!dacFlatPanelConnectStatus(pDev, Head))	// FP connected? (we got a header)
        {
            *FpConnected = NV_CFGEX_GET_FLATPANEL_INFO_NOT_CONNECTED;
            return RM_OK;						// then no more to do
        }
        // If we got an EDID, make sure it's a good one
        if (fpParseEDID(pDev, Head) == RM_OK) // parse EDID to get timing info (fail if bad header, or (?) bad timing)
        {
            // Checksum to verify this is a valid EDID
            if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 128, &chksum)) // expect checksum = 0
            {
                EdidOk = TRUE;
                break; // stop iteration if checksum is good
            }
            else
            {
                // some "good" panels have bad checksums, so if we get the same checksum twice, accept it
                if (chksum == chksum2) 
                {
                    EdidOk = TRUE;
                    break; // stop iteration if we get same checksum twice
                }
                chksum2 = chksum;
            }
            // If we fail, print checksum
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Flat Panel EDID checksum =  ", chksum);
        }
    } // if we still fail, we have no choice but to go with it

    *FpConnected = NV_CFGEX_GET_FLATPANEL_INFO_CONNECTED;
    *FpMaxX = pDev->Dac.HalInfo.fpHMax;
    *FpMaxY = pDev->Dac.HalInfo.fpVMax;
    *FlatPanelNativeSupported = FALSE;
    if (pDev->Dac.fpNative)
        *FlatPanelNativeSupported = TRUE;

    if (fromRegistry)
    {
        //JJV-New registry Process   char * strDisplayMode;
        //JJV-New registry Process   U032   size;
        // read it from the registry
        // fill in the path to the registry key--last character is the display number
        //JJV-New registry Process size = osStringLength(pDev->Registry.DBstrDevNodeDisplayNumber);
        //JJV-New registry Process pDev->Registry.DBstrDevNodeDisplayNumber[size - 1] = ('0' | (U008)devInstance);    // fill in ascii device #
        status = OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strFpMode, &mode);
    	if (status == RM_OK)
	        *FpMode = mode;
    	else
	    	*FpMode = NV_CFGEX_GET_FLATPANEL_INFO_NATIVE;
    }
    else
    {
        mode = dacGetFlatPanelConfig(pDev, Head); // This just reads the HW to find the current scaling mode
        *FpMode = mode;
        status = RM_OK;
    }
    if (!EdidOk) 
        return RM_ERROR; // failed to get a good EDID
    else
        return status;   // error if requested registry, but none found
}

// Check whether TV is currently connected
// This only works for the Brooktree encoder
BOOL dacTVConnectStatus
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    read, ack, lock, encoderPower, reg0e, reg10, reg3d, i;
    BOOL    connect;
    U032    retry;

    if (using_new_api == FALSE) {
        //
        // Make sure TV allowed on this head.
        //
        if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(DISPLAY_TYPE_TV)) == 0)
            return FALSE;
    }

    //
    // For NV11, make sure TV isn't in use by other head.
    // For P38 boards (external TMDS), we cannot run both TV and flat panel. This will change if we use internal TMDS,
    // but we'll have to get that info from the BIOS. Until then, TV + DFP is not allowed.
    //
    if (IsNV11(pDev))
    {
        if (using_new_api == FALSE) {
            // If the other head already has the TV, we can't use it.
            if (GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_TV)  
                return FALSE;

            //
            // If the other head is flat panel, we can't do it (only if this board is using external TMDS)
            // or if we're using the 12bit wide FP interface, then FP/TV can share and are allowed.
            //
            if ((GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_FLAT_PANEL) && !pDev->Power.MobileOperation &&
                (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT))
                return FALSE;

            // If the other head is CRT on head 1, we can't do it (only if this board is using external TMDS)
            if ((GETDISPLAYTYPE(pDev, Head^1) == DISPLAY_TYPE_MONITOR) && (Head == 0))
                return FALSE;
        }
        
        //
        // Make sure that i2c/tv ownership is setup properly.
        //
        AssocDDC(pDev, Head);
        AssocTV(pDev, Head);
    }

    lock = UnlockCRTC(pDev, Head);
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            // Set power to "normal"
            // Chrontel 7007 wants bit 7 set on register address
            
            // Read Power Management Register to preserve contents
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E); // 0x0e = PM register
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &reg0e,1);
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            
            // Powered up? No, then do so
            if ((reg0e & 3) != 3) {
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E); // 0e = power register
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x0b); // ON + RESET HIGH
                }
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);


            // Some initialization is necessary on the 7007 to make the detection work.
            // Exactly what needs to be set, I don't know, but the following 2 register initializations do it.

            // Set data format
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // 04 = input data format reg
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x05);      // set to NTSC for now
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            
            // Set clocking
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // 06 = clock mode
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x40);      // 
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            
            // In the 7008, reg 3D bits 2:0 must be cleared for detection to work
            // Don't know what effect it has on others, so we'll special case it.
            if (pDev->Dac.EncoderType == NV_ENCODER_CHRONTEL_7008) {

                // Read Reg 3D to preserve contents
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_3D); // 3D = ?
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &reg3d,1);
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

                if (ack == 0) {
                    // clear mystery bits 2:0 so TV connect detection will work
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                        ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    }
                    if (ack == 0) {
                        ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_3D); // 
                        ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(reg3d & 0xf8)); 
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                }
            } // 7008

            // Read Connection Detect Register to preserve contents
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &reg10,1);
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

            if (ack == 0) {
                // Set Sense bit to tell encoder to check for TV connected
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                    reg10 &= 0x0f;  // clear bits 7:4
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(reg10 | 1)); // sense bit <= 1
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }

            if (ack == 0) {
                // Reset Sense bit 
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); // sense bit <= 0
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }

            if (ack == 0) {
                // Read Connect reg - restart read
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_10); // 10 = connect detect register
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
            {
              // Say that the device is enabled just to disable it
              pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
              dacDisableTV(pDev, Head);
            }

            if  ((ack == 0 ) &&     // If we failed some how, we fail this
                 ((read & 0x0e) ^ 0x0e))     // 0 indicates connection
                                    // bit 3: Y (luma), bit 2: C (chroma), bit 1: composite
                connect = TRUE;
            else
                connect =  FALSE;
            break;
   

        case TV_ENCODER_BROOKTREE:

            // Turn DAC on before checking status
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);   // subaddress
            ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_ON);    // DAC ON
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

            // Give it some time for the outputs to stabilize
            tmrDelay(pDev, 20000000);         // 20 ms delay    

            // Set Check Status bit to tell encoder to check for TV connected.
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                if (ack)
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after first address byte while detecting TV connection\n\r");
            }
            if (ack == 0) {
                ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL); // subaddress
                ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_STAT); // set check stat
            } else {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after first address byte while detecting TV connection\n\r");
            }
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            if (ack != 0) {
                DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK during first transaction while detecting TV connection\n\r");
            }

            //870/871 supports direct register reads.  The older chips require a more involved procedure.
            if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871) {
                
                // enable non-legacy readback mode for 870/871 by doing a reset - harmless for older parts
                // (this enables read of any register on 87x -- 868/869 has only one read subaddress)
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);     // subaddress
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x44);     // TIMING_RST low, set readback mode, EACTIVE
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
                tmrDelay(pDev, 10000000);
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xC4);      // TIMING_RST high
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         

                if (ack == 0) {
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after third address byte while detecting TV connection\n\r");
                    }
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x06);
                }

                if (ack == 0) {
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID | 1));   // Add read bit
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after third address byte while detecting TV connection\n\r");
                    }
                    if (ack == 0) {
                        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
                    } else {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after third address byte while detecting TV connection\n\r");
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                }
            } else {
                if (ack == 0) {
                    // Set Estat to select status register 1
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after second address byte while detecting TV connection\n\r");
                    }
                    if (ack == 0) {
                        ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xC4);   // subaddress
                        ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x41);   // set estat (estat 01 + en_out)
                    } else {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after second address byte while detecting TV connection\n\r");
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                    if (ack != 0) {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK during second transaction while detecting TV connection\n\r");
                    }
                }

                if (ack == 0) {
                    // Read Monitor Status bits
                    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID | 1));   // Add read bit
                        if (ack)
                            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after third address byte while detecting TV connection\n\r");
                    }
                    if (ack == 0) {
                        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
                    } else {
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after third address byte while detecting TV connection\n\r");
                    }
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                } 
            }

            if (ack == 0) {
                // Reset Check Status -- not documented, but very important (can't program encoder if not done).
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    if (ack)
                        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Missed one ACK after last address byte while detecting TV connection\n\r");
                }
                if (ack == 0) {
                    ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL); // subaddress
                    ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF); // set check stat
                } else {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK after last address byte while detecting TV connection\n\r");
                }
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                if (ack != 0) {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Swell, no ACK during last transaction while detecting TV connection\n\r");
                }
            }

            if (ack) // if any error occurred, go to monitor
                return (FALSE);

            if (read & BT_MONSTAT)  // any connection deteced?
                connect = TRUE;
            else
                connect =  FALSE;

            // If not TV, disable DAC
            if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_TV)
            {
                // If no head is using TV, blank image.
                for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                    if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                        break;
                if (i == pDev->Dac.HalInfo.NumCrtcs)
                {
                  // Say that the device is enabled just to disable it
                  pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
                  dacDisableTV(pDev, Head);
                }
            }
            break;
        
       case TV_ENCODER_PHILIPS:
           // Turn Power On -- Read/Modify/Write
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
           }
           if (ack == 0) {
              ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x61); // 
              i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
              ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
              i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           encoderPower = read;
           read &= 0x3f;   // power on
           // Write Power bits
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x61);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) read);   // 
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           
           // Set Monitor Sense Threshold
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1a);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x46);   // MSM threshold
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

           // Set Monitor Sense Threshold
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1a);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x46);   // MSM threshold
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

           // Set Monitor Sense Mode
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1b);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x80);   // MSM
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

           // Read sense bits
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
           }
           if (ack == 0) {
              ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x1b); // 
              i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
              ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
              i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           if ((read & 0x07) == 0x07)    // check C and Y inputs
               connect = FALSE;
           else
               connect = TRUE;                                    
           // Reset Monitor Sense Mode
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1b);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x00);   // MSM
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           // Restore power state
           for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
               i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
               ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
               if (ack)
                   DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           if (ack == 0) {
               ack  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x61);   // subaddress
               ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) encoderPower);   // power
           } else {
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No ACK from TV encoder\n\r");
           }
           i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
           break;
        default:
                connect =  FALSE;
    }
    RestoreLock(pDev, Head, lock);

    // restore TV connection if TV is connected on the other head
    if (GETDISPLAYTYPE(pDev, Head ^ 0x1) == DISPLAY_TYPE_TV) {
        AssocDDC(pDev, Head ^ 0x1);
        AssocTV(pDev, Head ^ 0x1);
    }

    // restore macrovision mode if appropriate
    if (pDev->Dac.TVLastMacrovision.mode & 0x3)
        SetMacrovisionMode(pDev, Head, (RM_MACROVISION_CONTROL *)&(pDev->Dac.TVLastMacrovision));

    return connect;
}

//  Set the text cursor blink rate depending on the display type
//  The BIOS won't do this, so we have to.
VOID dacSetCursorBlink
(
    PHWINFO pDev,
    U032    Head,
    U008    Rate
)
{
U008    data;

    if (IsNV5(pDev)) // This is a problem in NV5 only
    {
        // another undocumented register
        CRTC_RD(NV_CIO_CRE_TREG__INDEX, data, Head);
        data &= ~0x80;
        if (Rate)   // CRT set bit 7 to 0, FP & TV set to 1
            data |= 0x80;
        CRTC_WR(NV_CIO_CRE_TREG__INDEX, data, Head);
    }
}

// Unlock extended CRTC and return former state of lock
U008 UnlockCRTC
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 lock;
    
    lock = ReadCRTCLock(pDev, Head);
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, Head);
    return lock;
}
VOID RestoreLock
(
    PHWINFO pDev, 
    U032    Head, 
    U008    lock
)
{
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, Head);
}
//  Read extended CRTC lock register and return corresponding write value
U008 ReadCRTCLock
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 data;

    CRTC_RD(NV_CIO_SR_LOCK_INDEX, data, Head);
    switch (data)
    {
        case 0x03:
            data = 0x57;
            break;
        case 0x01:
            data = 0x75;
            break;
        case 0x00:
        default:
            data = 0x99;
            break;
    }
    return data;
}

VOID dacSetFan
(
    PHWINFO pDev,
    U008    state
)
{
    U008 data, lock;
    U032 Head = 0;

    if (IsNV10orBetter(pDev))
    {
        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);
        
        CRTC_RD(0x35, data, Head);
        data &= ~0x02;		// bit 1 = output enable (active low) 
        if (state == 0)
        {
            // OFF
            CRTC_WR(0x35, data & ~0x01, Head);	// bit 0 = fan control (active high)
        }
        else
        {
            // ON
            CRTC_WR(0x35, data | 0x01, Head);		// bit 0 = fan control (active high)
        }

        RestoreLock(pDev, Head, lock);
    }
}

RM_STATUS dacGetColorSaturationBoost
(
    PHWINFO pDev,
    U032    Head,
    U008    *boostValue
)
{
    U008 lock;

    if (IsNV11orBetter(pDev) == FALSE)
        return CONFIG_GETEX_BAD_READ;    // not supported pre-NV11

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

    // get the color boost value
    CRTC_RD(NV_CIO_CRE_CSB, *boostValue, Head);

    RestoreLock(pDev, Head, lock);

    return RM_OK;
}

RM_STATUS dacSetColorSaturationBoost
(
    PHWINFO pDev,
    U032    Head,
    U008    boostValue
)
{
    U008 lock;

    if (IsNV11orBetter(pDev) == FALSE)
        return CONFIG_GETEX_BAD_READ;    // not support pre-NV11

    if (boostValue > NV_CFGEX_PREDAC_COLOR_SATURATION_BOOST_750)
        return CONFIG_SETEX_BAD_PARAM;    // 75% is the largest value

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

    // set the color saturation boost value
    CRTC_WR(NV_CIO_CRE_CSB, boostValue, Head);

    RestoreLock(pDev, Head, lock);
    return RM_OK;
}

#ifdef MACOS
/*
 * The fcode on the mac implements Apple's monitor selection policy
 *  (what device to boot on, etc).  The fcode then publishes this information
 *  in the registry.
 *
 * Here we read that information.
 *
 * "displayA"      --  HHIILLTT
 * "displayB"      --  HHIILLTT
 * "display-type"  -- "CRT" or "LCD"  preferred boot device
 *
 * Decoder ring:
 *             HH -- head
 *             II -- i2c status port base
 *             LL -- TMDS link info
 *             TT -- display type (0 = crt, 3 = digital flat panel)
 *
 * If a display is not present, then the value will be 0x??FFFFFF.
 *
 * On the iMac / P11, displayA would be 00FFFF00 (Head A, no I2C port, no TMDS
 * link, CRT) and displayB would be 013E0103 (Head B, I2C 3E/3F, Link 2, DFP).
 *
 */

RM_STATUS dacMacReadBIOSDisplaySettings(
    PHWINFO pDev
)
{
    U032 displayA, displayB;
    U032 head, i2cportA=0, i2cportB=0, tmdslink;
    U032 displaytype = 0;
    char primary_displaytype_string[16];
    U032 reglen;

    displayA = ~0;
    displayB = ~0;
    osReadRegistryDword(pDev, (char *) 0, "displayA", &displayA);
    osReadRegistryDword(pDev, (char *) 0, "displayB", &displayB);
    if ((displayA == ~0) && (displayB == ~0))
        return RM_ERROR;

    // what is the display type that the fcode depended on?
    // We don't really use this right now...

    reglen = sizeof(primary_displaytype_string);
    osMemSet(primary_displaytype_string, 0, reglen);
    osReadRegistryBinary(pDev,
                         (char *) 0,
                         "display-type",
                         (U008 *) primary_displaytype_string,
                         &reglen);


    // parse out displayA settings

    if ((displayA & 0x00FFFFFF) != 0x00FFFFFF)
    {
        head =        (displayA >> 24) & 0xFF;
        i2cportA =    (displayA >> 16) & 0xFF;
        tmdslink =    (displayA >> 8)  & 0xFF;
        displaytype = (displayA >> 0)  & 0xFF;
    }
    
    if ((displayB & 0x00FFFFFF) != 0x00FFFFFF)
    {
        head =        (displayB >> 24) & 0xFF;
        i2cportB =    (displayB >> 16) & 0xFF;
        tmdslink =    (displayB >> 8)  & 0xFF;
        displaytype = (displayB >> 0)  & 0xFF;
    }
    
    //
    // NOTE: DFP2 means the DFP on head B!!
    //       DFP  means the DFP on head A.
    //
    // first mark them all unknown
    //
    pDev->Dac.DFPPortID  = NV_I2C_PORT_TERTIARY;
    pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;
    pDev->Dac.CRTPortID  = NV_I2C_PORT_TERTIARY;
    pDev->Dac.CRT2PortID = NV_I2C_PORT_TERTIARY;

    // If we have anything on headB, then that will be our primary.
    // If not, then A will be primary
    if ((displayB & 0x00FFFFFF) != 0x00FFFFFF)
    {
        pDev->Dac.I2CPrimaryStatusIndex = i2cportB;
        pDev->Dac.I2CPrimaryWriteIndex = i2cportB + 1;
        
        if (displaytype == 3)
            pDev->Dac.DFP2PortID = NV_I2C_PORT_PRIMARY;
        else
            pDev->Dac.CRT2PortID = NV_I2C_PORT_PRIMARY;

        if ((displayA & 0x00FFFFFF) != 0x00FFFFFF)
        {
            pDev->Dac.I2CSecondaryStatusIndex = i2cportA;
            pDev->Dac.I2CSecondaryWriteIndex = i2cportA + 1;
            
            if (displaytype == 3)
                pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
            else
                pDev->Dac.CRTPortID = NV_I2C_PORT_SECONDARY;
        }
    }
    else
    {
        pDev->Dac.I2CPrimaryStatusIndex = i2cportA;
        pDev->Dac.I2CPrimaryWriteIndex = i2cportA + 1;
        
        if (displaytype == 3)
            pDev->Dac.DFPPortID = NV_I2C_PORT_PRIMARY;
        else
            pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
    }
    
    return  RM_OK;
}

#endif // MACOS



//
// Extract the relevant I2C values from any arbitrary version of BMP structure
// Update the nvInfo structure with the location of the TV and FP ports.
RM_STATUS dacReadBIOSI2CSettings(
    PHWINFO pDev
)
{
    RM_STATUS rmStatus = RM_OK;

#ifdef IKOS
    pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
    pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
    pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
    pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
    pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
    pDev->Dac.TVOutPortID = NV_I2C_PORT_SECONDARY;
    pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
#else

    if ( !IsNV5orBetter(pDev) || IsNV0A(pDev) )
    {
        // This is a one DDC port device
        pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
        pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
        pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
        pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
        pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
        pDev->Dac.TVOutPortID = NV_I2C_PORT_PRIMARY;
        pDev->Dac.DFPPortID = NV_I2C_PORT_PRIMARY;
    }
    else
    {
        U032 offset;
        BMP_Control_Block bmpCtrlBlk;
        U032 RegistryData;

        // This device has two DDC ports, set defaults

        pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
        pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
        pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
        pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
        if (pDev->Power.MobileOperation)
        {
            // 
            // For mobile, CIO_CRE_DDC2 (CR50/CR51) is used to control the spread
            // spectrum chip (avoid using this pair for any DDC communication).
            //
            pDev->Dac.I2CTertiaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
            pDev->Dac.I2CTertiaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
        }
        else
        {
            pDev->Dac.I2CTertiaryWriteIndex = NV_CIO_CRE_DDC2_WR__INDEX;
            pDev->Dac.I2CTertiaryStatusIndex = NV_CIO_CRE_DDC2_STATUS__INDEX;
        }
        pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
        pDev->Dac.TVOutPortID = NV_I2C_PORT_SECONDARY;
        pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
        
        // NV11, NV20 have three DDC ports
        if (IsNV11(pDev))
        {
#if 0 // We can no longer assume that VGA is the boot device. We assume that we can talk to VGA over I2C 0 and DFP over I2C 1
      // unless we find a registry override.
            // determine if this is VGA + ? or DVI/DVI board
            if (dacVGAConnectStatus(pDev, 0))  // Is there VGA on I2C 0? (Uses analog comparator)
            {
                // VGA is mapped to I2C 0, so the secondary could be VGA or DFP on I2C 1
                pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;   // second CRT uses I2C 1
                pDev->Dac.DFPPortID = NV_I2C_PORT_TERTIARY;     // No primary DFP--set to unused port
                pDev->Dac.DFP2PortID = NV_I2C_PORT_SECONDARY;   // second DFP uses I2C 1
            }
            else // no CRT, assume dual DFP
            {
                if (dacFlatPanelConnectStatus(pDev, 0)) // this will try to find EDID on I2C 1
                {
                    // DVI on I2C 1 and 2                
                    pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;   // secondary DFP uses I2c 2
                }
                else // No DFP after all, assume CRT with no EDID
                {
                    pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;   // second CRT uses I2C 1
                    pDev->Dac.DFPPortID = NV_I2C_PORT_TERTIARY;    // set to unused port
                    pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;   // set to unused port
                }
            }
#else
            U032 val = 0;
            char strDualDVI[] = "Dual DVI";

            // VGA is mapped to I2C 0, so the secondary could be VGA or DFP on I2C 1
            pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;   // second CRT uses I2C 1
            pDev->Dac.DFPPortID = NV_I2C_PORT_TERTIARY;     // No primary DFP--set to unused port
            pDev->Dac.DFP2PortID = NV_I2C_PORT_SECONDARY;   // second DFP uses I2C 1
            
            // registry override for dual DVI board -- Flat Panels connected to I2C 1 and 2
            OS_READ_REGISTRY_DWORD(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, strDualDVI, &val);
            if (val) 
            {
                pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
                pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;   // secondary DFP uses I2c 2
            }
#endif        
        }

#ifdef MACOS
        // the Mac is *special*
        // The fcode sets registry properties to indicate i2c mappings
        //    If we find these registry settings, we'll use them,
        //    otherwise we'll look for the BMP bios table.
        if (RM_OK == dacMacReadBIOSDisplaySettings(pDev))
            return RM_OK;
#endif

        // Attempt to find the I2C info in the BIOS' BMP tables
        rmStatus = DevinitGetBMPControlBlock(pDev,
                                             &bmpCtrlBlk,
                                             &offset);
        if (rmStatus == RM_OK)
        {
            switch ( bmpCtrlBlk.CTL_Version )
            {
                // version 0 is for Nv3, no others exist
                case BMP_INIT_TABLE_VER_0:
                case BMP_INIT_TABLE_VER_1:
                {
                    // There is no I2C info in these BIOS's.
                    break;
                }
                    
                // BMP init table version 2 & 3
                case BMP_INIT_TABLE_VER_2:
                case BMP_INIT_TABLE_VER_3:
                {
                    //PBMP_Struc_Rev3 BMP_InitTableInfo = (PBMP_Struc_Rev3)pBmpCtrlBlk;
                    BIOSI2CTable biosI2CTable;
                    
                    rmStatus = BiosReadStructure(pDev,
                                                 (U008 *) &biosI2CTable,
                                                 0x40,
                                                 (U032 *) 0,
                                                 BMP_I2C_FMT);
                    if (rmStatus == RM_OK)
                    {
                        pDev->Dac.I2CPrimaryWriteIndex = biosI2CTable.I2CPort0IO & 0xFF;
                        pDev->Dac.I2CPrimaryStatusIndex = ( biosI2CTable.I2CPort0IO >> 8 ) & 0xFF;
                        pDev->Dac.I2CSecondaryWriteIndex = biosI2CTable.I2CPort1IO & 0xFF;;
                        pDev->Dac.I2CSecondaryStatusIndex = ( biosI2CTable.I2CPort1IO >> 8 ) & 0xFF;
                        pDev->Dac.CRTPortID = biosI2CTable.CRTI2CPort;
                        pDev->Dac.TVOutPortID = biosI2CTable.TVI2CPort;
                        pDev->Dac.DFPPortID = biosI2CTable.DFPI2CPort;
                    }
                    break;
                }
        
                // BMP init table version >= BMP_INIT_TABLE_VER_4 ( 4 )
                default:
                {
                    BMP_Struc_Rev4 bmp_InitTableInfo ;
                    
                    rmStatus = BiosReadStructure(pDev,
                                                 (U008 *) &bmp_InitTableInfo,
                                                 offset,
                                                 (U032 *) 0,
                                                 BMP_INIT4_FMT);

                    if (rmStatus == RM_OK)
                    {
                        pDev->Dac.I2CPrimaryWriteIndex = bmp_InitTableInfo.BMP_I2CPort0IO & 0xFF;
                        pDev->Dac.I2CPrimaryStatusIndex = ( bmp_InitTableInfo.BMP_I2CPort0IO >> 8 ) & 0xFF;
                        pDev->Dac.I2CSecondaryWriteIndex = bmp_InitTableInfo.BMP_I2CPort1IO & 0xFF;;
                        pDev->Dac.I2CSecondaryStatusIndex = ( bmp_InitTableInfo.BMP_I2CPort1IO >> 8 ) & 0xFF;
                        pDev->Dac.CRTPortID = bmp_InitTableInfo.BMP_CRTI2CPort;
                        pDev->Dac.TVOutPortID = bmp_InitTableInfo.BMP_TVI2CPort;
                        pDev->Dac.DFPPortID = bmp_InitTableInfo.BMP_DFPI2CPort;
                    }
                    break;
                }
            }
        }

        // Verify that there are no non-zero values in these reg indexes as these should never be 0       
        // This fixes a bug in which Diamond stuffs 0s into the bitmap
        if( (pDev->Dac.I2CPrimaryWriteIndex == 0x00)   ||
            (pDev->Dac.I2CPrimaryStatusIndex == 0x00)  ||
            (pDev->Dac.I2CSecondaryWriteIndex == 0x00) ||
            (pDev->Dac.I2CSecondaryStatusIndex == 0x00) ) {

            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Invalid I2C info in bios image\n");

            // Someone gave us bogus values, so set all of these to the defaults
            pDev->Dac.I2CPrimaryWriteIndex = NV_CIO_CRE_DDC_WR__INDEX;
            pDev->Dac.I2CPrimaryStatusIndex = NV_CIO_CRE_DDC_STATUS__INDEX;
            pDev->Dac.I2CSecondaryWriteIndex = NV_CIO_CRE_DDC0_WR__INDEX;
            pDev->Dac.I2CSecondaryStatusIndex = NV_CIO_CRE_DDC0_STATUS__INDEX;
            pDev->Dac.CRTPortID = NV_I2C_PORT_PRIMARY;
            pDev->Dac.TVOutPortID = NV_I2C_PORT_SECONDARY;
            pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;
        }

        if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "Nv11DVIConnectorOnly", &RegistryData) == RM_OK) {
            pDev->Dac.CRTPortID = NV_I2C_PORT_SECONDARY;
            pDev->Dac.DFPPortID = NV_I2C_PORT_SECONDARY;

            pDev->Dac.TVOutPortID = NV_I2C_PORT_TERTIARY;
            pDev->Dac.CRT2PortID = NV_I2C_PORT_TERTIARY;
            pDev->Dac.DFP2PortID = NV_I2C_PORT_TERTIARY;
        }

        if (IsNV15(pDev))
            pDev->Dac.CRT2PortID = NV_I2C_PORT_SECONDARY;
    }
#endif

    return rmStatus;
}

//
// Return head number specified in alloc request.
//
U032 dacGetHead
(
    PCLASS pClass,
    VOID *pCreateParms
)
{
    RM_STATUS   status = RM_OK;
    U032 Head = 0;

    if (pCreateParms == NULL)
        return Head;

    switch (pClass->Type)
    {
        case NV15_VIDEO_LUT_CURSOR_DAC:
        {
            NV07C_ALLOCATION_PARAMETERS Class07cParams;
            status = osCopyIn(pCreateParms, (U008*) &Class07cParams, sizeof (NV07C_ALLOCATION_PARAMETERS));
            if (status != RM_OK)
                return 0;
            Head = Class07cParams.logicalHeadId;
        }
        default:
            // for everything else, it's head 0
            break;
    }

    return Head;
}

RM_STATUS
dacCreateObj(VOID* pDevHandle, PCLASSOBJECT ClassObject, U032 Name, POBJECT *Object, VOID *pCreateParms)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS                    status = RM_OK;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    PCLASS                       pClass = ClassObject->Base.ThisClass;
    U008                         *bytePtr;
    U032                          i, head;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: dacCreateObj\r\n");
    
    //
    // Check allocation restrictions.
    //

    //
    // Check head assignment.
    //
    head = dacGetHead(pClass, pCreateParms);
    if (head >= pDev->Dac.HalInfo.NumCrtcs)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: dacCreateObj: invalid logical head number ", head);
        return RM_ERR_INSUFFICIENT_RESOURCES;
    }

    //
    // For synchronized multi-head flips, init the sync counter
    //
    pDev->Dac.MultiSyncCounter = pDev->Dac.HalInfo.NumCrtcs;

    //
    // Alloc memory for class dependent object state.
    // All DAC engine objects currently use the same structure.
    //
    status = osAllocMem((VOID **)Object, sizeof (VIDEO_LUT_CURSOR_DAC_OBJECT));
    if (status)
        return (status);

    //
    // Nice casts to make the code more readable.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)*Object;

    //
    // Initialize the new object structure.
    //
    bytePtr = (U008 *)pVidLutCurDac;
    for (i = 0; i < sizeof (VIDEO_LUT_CURSOR_DAC_OBJECT); i++)
       *bytePtr++ = 0;

    //
    // Init common (software) state.
    //
    classInitCommonObject(&pVidLutCurDac->CBase, ClassObject, Name);

    //
    // Let the HAL setup any chip-dependent resources.
    //
    pVidLutCurDac->HalObject.Head = head;
    status = nvHalDacAlloc(pDev, pVidLutCurDac->CBase.ChID, pVidLutCurDac->CInstance, pClass->Type, (VOID *)&pVidLutCurDac->HalObject);

    if (status == RM_OK)
    {
        //
        // Build a FIFO/Hash context for this object
        //
        status = fifoUpdateObjectInstance(pDev,
                                          &pVidLutCurDac->CBase, 
                                          pVidLutCurDac->CBase.ChID, 
                                          pVidLutCurDac->CInstance);
    }

    if (status)
    {
        osFreeMem(*Object);
        return (status); 
    }

    //
    // Bump up reference count on this.
    //
    pDev->Dac.CrtcInfo[head].RefCount++;

    return (RM_OK);
}

RM_STATUS
dacDestroyObj(VOID* pDevHandle, POBJECT Object)
{
    PHWINFO pDev = (PHWINFO) pDevHandle;
    RM_STATUS               status = RM_OK;
    PCLASS                  pClass;
    U032                    buffNum;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

#if !defined(NTRM) && !defined(__DJGPP__)
    U008    data08, lock;
#endif

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: dacDestroyObj\r\n");

    //
    // Just in case...
    //
    if (Object == NULL)
        return (RM_OK);

    //
    // Clear the subChannel ptrs for this object 
    //
	osEnterCriticalCode(pDev);
	fifoDeleteSubchannelContextEntry(pDev, Object);
	osExitCriticalCode(pDev);

    //
    // Nice cast to make the code more readable.
    //
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)Object;

    //
    // Let the HAL do it's cleanup thing.
    //
    pClass = Object->ThisClass;
    nvHalDacFree(pDev, pVidLutCurDac->CBase.ChID, pVidLutCurDac->CInstance, pClass->Type, (VOID *)&pVidLutCurDac->HalObject);

    //
    // Delete the FIFO/Hash context for this object
    //
    status = fifoDeleteObjectInstance(pDev, &pVidLutCurDac->CBase, pVidLutCurDac->CBase.ChID); 
    if (status)
        return (status);

    //
    // Cleanup any pending VBlank callbacks
    //
    VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->CursorPointCallback));

    for (buffNum = 0; buffNum < 2; buffNum++) {
        VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->Image[buffNum].ImageCallback));
        VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->LUT[buffNum].LUTCallback));
        VBlankDeleteCallback(pDev, pVidLutCurDac->HalObject.Head, &(pVidLutCurDac->CursorImage[buffNum].CursorImageCallback));
    }

    //
    // Decrement reference count.
    //
    // Turn off DAC if this is last object instance associated
    // with this (non-primary) head
    //
    if (--pDev->Dac.CrtcInfo[pVidLutCurDac->HalObject.Head].RefCount == 0)
    {
#ifndef __DJGPP__
        // Assumes last pVidLutCurDac is the modesetting object (which holds this flag)
        if (   pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].PrimaryDevice == FALSE
       //comment out following line to see multimon nv11-pci modeswitch problem
            && pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac != NULL 
           )
        {
            dacDisableDac(pDev, pVidLutCurDac->HalObject.Head);
        }
#endif
    }

    //Remove the pointer to this object -- whether this ptr is NULL is used
    // to determine whether this head is disabled.
    if (pVidLutCurDac == (PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac)) 
    {
#if !defined(NTRM) && !defined(__DJGPP__)
        //Runtime clone mode switch support -- turn off display when associated object it is destroyed.
        if (!pDev->Vga.Enabled) {
            dacDisableDac(pDev, pVidLutCurDac->HalObject.Head); 

            if (MC_POWER_LEVEL_0 == pDev->Power.State) {
              lock = UnlockCRTC(pDev, pVidLutCurDac->HalObject.Head);
                if (pDev->Power.MobileOperation &&  pDev->HotKeys.enabled) {
                    CRTC_RD(0x3B, data08, pVidLutCurDac->HalObject.Head);
                    CRTC_WR(0x3B, (data08 & 0x0F), pVidLutCurDac->HalObject.Head);
                }

                RestoreLock(pDev, pVidLutCurDac->HalObject.Head, lock);
            }
        }
#endif                                                          
        SETDISPLAYTYPE(pDev, DACGETHEAD(pVidLutCurDac), DISPLAY_TYPE_NONE);
        pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = NULL;
        pDev->Dac.HalInfo.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac = NULL;
    }

    //
    // And finally delete the object itself    
    //    
    return (osFreeMem(Object));
}

//
// EnableHead
//
// Set DAC address space mode in CR44 (H2OWNS)
// register so that CIO/VIO/PRMVIO addressing 
// goes to the specified head.
//
VOID EnableHead
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 data08;
    U008 crtc_index, lock;

    if (!IsNV11(pDev))
        return;

    if (pDev->Dac.HalInfo.Head2RegOwner == HEAD2_OWNER_UNKNOWN) {
        // Set the initial values, if this is the first call.
        if (Head == 1)
            data08 = 3;
        else
            data08 = 0;
    } else {
        // CR44 has a bug; memory mapped reads don't work, so we use a shadow copy.
        data08 = (U008)pDev->Dac.HalInfo.Head2RegOwner;
        if (Head == 1) 
        {
            // Did CR44 already point to head 1
            if ((data08 & 0x3) == 3)
                return;

            data08 |= 3;
        }
        else
        {
            // Did CR44 already point to head 0
            if ((data08 & 0x3) == 0)
                return;

            data08 &= ~3;
        }
    }

    // save/unlock head0 (new head is always programmed from head 0).
    crtc_index = DAC_REG_RD08(NV_PRMCIO_CRX__COLOR, 0);
    lock = UnlockCRTC(pDev, 0);

    CRTC_WR(NV_CIO_CRE_H2OWNS, data08, 0);

    RestoreLock(pDev, 0, lock);    // not pointing at CR44 anymore
    DAC_REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index, 0);

    pDev->Dac.HalInfo.Head2RegOwner = (U032)data08;
}


//returns the current owner of DDC (ENGINE_CTRL_I2C)
U032 CurrentHeadDDC(PHWINFO pDev)
{
    if (DAC_REG_RD_DRF(_PCRTC, _ENGINE_CTRL, _I2C, 0))
        return 0;   //head A wins a tie

    if (DAC_REG_RD_DRF(_PCRTC, _ENGINE_CTRL, _I2C, 1))
        return 1;

    return 0;   //head A wins by default
}


// Multi-head DDC switching (ENGINE_CTRL update routine).
VOID AssocDDC(PHWINFO pDev, U032 Head)
{
    if (Head == 0)
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _ENABLE, 0);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _DEFAULT, 1);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _ENABLE, 1);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _I2C, _DEFAULT, 0);
    }
}

// Multi-head TV switching (ENGINE_CTRL update routine).
VOID AssocTV(PHWINFO pDev, U032 Head)
{
    if (Head == 0)
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _ENABLE, 0);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _DEFAULT, 1);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _ENABLE, 1);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _TV, _DEFAULT, 0);
    }
}

// Multi-head VideoScalar switching (ENGINE_CTRL update routine).
VOID AssocVideoScalar(PHWINFO pDev, U032 Head)
{
    if (Head == 0)
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _ENABLE, 0);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _DEFAULT, 1);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _ENABLE, 1);
        DAC_FLD_WR_DRF_DEF(_PCRTC, _ENGINE_CTRL, _VS, _DEFAULT, 0);
    }
}


//Set a flag to let the BIOS know not to handle hotkey events itself.
//Set while in Windows, cleared in full-screen DOS.  Mobile only.
VOID EnableMobileHotkeyHandling(PHWINFO pDev)
{
    U008 lock, data;

    if (pDev->Power.MobileOperation) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Driver-based hotkey handling enabled\n\r");

        // unlock the extended regs
        lock = UnlockCRTC(pDev, 0);

        //Clear any pending events
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 0);
        data &= ~(NV_MOBILE_FLAG_SCALE_MASK | NV_MOBILE_FLAG_DISPLAY_MASK);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data, 0);

        //Notify BIOS we're enabling driver hotkey handling.
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 0);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data | NV_DRIVER_HANDLES_HOTKEYS, 0);
        //Temporary: Toshiba's system BIOS clears that bit accidentally.
        //So also use another bit.  Our VGA BIOS checks both.
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 0);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data | NV_DRIVER_HANDLES_HOTKEYS, 0);

        RestoreLock(pDev, 0, lock);

        //Workaround: head 1's bit, too.
        lock = UnlockCRTC(pDev, 1);

        //Clear any pending events
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 1);
        data &= ~(NV_MOBILE_FLAG_SCALE_MASK | NV_MOBILE_FLAG_DISPLAY_MASK);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data, 1);

        //Notify BIOS we're enabling driver hotkey handling.
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 1);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data | NV_DRIVER_HANDLES_HOTKEYS, 1);
        //Temporary: Toshiba's system BIOS clears that bit accidentally.
        //So also use another bit.  Our VGA BIOS checks both.
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 1);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data | NV_DRIVER_HANDLES_HOTKEYS, 1);

        RestoreLock(pDev, 1, lock);

        pDev->HotKeys.enabled = TRUE;
    }
}


//Clear flag so BIOS knows to handle hotkey events itself.
//Set while in Windows, cleared in full-screen DOS.  Mobile only.
VOID DisableMobileHotkeyHandling(PHWINFO pDev)
{
    U008 lock, data;

    if (pDev->Power.MobileOperation) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Driver-based hotkey handling disabled\n\r");

        // unlock the extended regs
        lock = UnlockCRTC(pDev, 0);

        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 0);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data & ~NV_DRIVER_HANDLES_HOTKEYS, 0);
        //Temporary: Toshiba's system BIOS clears that bit accidentally.
        //So also use another bit.  Our VGA BIOS checks both.
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 0);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data & ~NV_DRIVER_HANDLES_HOTKEYS, 0);

        RestoreLock(pDev, 0, lock);

        //Workaround: head 1's bit, too.
        // unlock the extended regs
        lock = UnlockCRTC(pDev, 1);

        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Driver-based hotkey handling disabled\n\r");
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, data, 1);
        CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, data & ~NV_DRIVER_HANDLES_HOTKEYS, 1);
        //Temporary: Toshiba's system BIOS clears that bit accidentally.
        //So also use another bit.  Our VGA BIOS checks both.
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, data, 1);
        CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, data & ~NV_DRIVER_HANDLES_HOTKEYS, 1);

        RestoreLock(pDev, 1, lock);

        pDev->HotKeys.enabled = FALSE;
    }
}

//---------------------------------------------------------------------------
//
//  VBlank service handler.
//
//---------------------------------------------------------------------------
V032 dacService
(
    PHWINFO pDev
)
{
    U032 head, pmc, pending;
    RM_STATUS status;

    pending = 0;

    pmc = REG_RD32(NV_PMC_INTR_0);
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC, _PENDING))
        pending |= 0x1;
    if (pmc & DRF_DEF(_PMC, _INTR_0, _PCRTC2, _PENDING))
        pending |= 0x2;

    //
    // Check for any VBlank actions. Service count was already updated in VBlank
    //
    status = RM_OK;
    if (pDev->Framebuffer.FinishFlags)
        status |= grVBlank(pDev);
#if DEBUG
    if (status)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Problems in dacService.\n\r");
        DBG_BREAKPOINT();
    }
#endif // DEBUG

    VBlank(pDev);

    // Clear 'em all...
    for (head = 0; head < MAX_CRTCS; head++)
    {
        if (pending & BIT(head))
            DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, head);
    }
    return (0x00000000);
}

// read/parse the Display Config Block (DCB) from the BIOS.  only revisions 1.4 and up support
// this feature
RM_STATUS dacParseDCBFromBIOS
(
    PHWINFO pDev
)
{
    U016        offset;             // offset from NV BIOS base
    U016        DCBBase;            // offset of DCB from BIOS base
    U032        CRTs = 0;           // # of CRT connectors
    U032        DDs = 0;            // # of DD connectors
    U032        TVs = 0;            // # of TV connectors
    U032        DevDescs = 0;       // # of valid DCB device descriptors
    U032        CRTCs = 0;          // # of CRTCs
    U032        I2cPorts;           // # of I2C ports
    U032        i;
    U032        j;
    U032        *pI2cPort;
    U032        RegistryData;
    U032        BMPOffset;
    BOOL        BMPVersionOK;
    RM_STATUS   status;
    BMP_Control_Block BMPCtrlBlk;
    
    // The BMP version must be greater than or equal to 0x05.0x12 for us to
    // use the DCB table
    
    status = DevinitGetBMPControlBlock(pDev, &BMPCtrlBlk, &BMPOffset);
   
    BMPVersionOK = ((status == RM_OK) &&
		    (( BMPCtrlBlk.CTL_Version >  BMP_INIT_TABLE_VER_5) ||
                     ((BMPCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5) &&
                      (BMPCtrlBlk.CTL_Flags   >= BMP_INIT_TABLE_SUBVER_0x12))));

    DCBBase = BIOS_RD16(DCB_PTR_OFFSET);
    
    if ((BMPVersionOK) &&
        (DCBBase != 0) &&
        (BIOS_RD08(DCBBase + DCB_REVISION_OFFSET) >= DCB_FIRST_REVISION))
    {   
        // This is Rev 1.4 or greater, so there exits a DCB; however, many Rev 1.4 BIOS' have  
        // one DEV_REC (device descriptor) in the DCB, making them not very useful. 
        // If Rev 1.4 and there is only one DEV_REC, then fall back to the RM default DCB above.

        // read DCB device descriptors. endianess ?
        offset = DCBBase + DCB_DEV_DESC_OFFSET;
        for (i = 0; i < DCB_MAX_NUM_DEVDESCS; i++) 
        {
            pDev->Dac.DCBDesc[i].DCBDevRec.DevRec_U032 = BIOS_RD32(offset);
            if (pDev->Dac.DCBDesc[i].DCBRecType == DCB_DEV_REC_TYPE_EOL)
                break;
            offset += sizeof(U032);
            pDev->Dac.DCBDesc[i].DataPtr = BIOS_RD16(offset);
            offset += sizeof(U016);

            pDev->Dac.DCBDesc[i].DCBDevData.DataDword = BIOS_RD32(offset);
            offset += sizeof(U032);

            // keep track of the highest head number
            if (pDev->Dac.DCBDesc[i].DCBRecHead > CRTCs)
                CRTCs = pDev->Dac.DCBDesc[i].DCBRecHead;
        }
        DevDescs = i;   // # of device descriptors, excluding EOL
        CRTCs++;        // head number is zero based

        // We parsed the DCB, but if it's Rev 1.4 with a single entry,
        if ((DevDescs == 1) && (BIOS_RD08(DCBBase + DCB_REVISION_OFFSET) == DCB_FIRST_REVISION))
        {
            goto RM_DCB;
        }
        else
        {
            // read the I2C Configuration Block (ICB). endianess ?
            offset = BIOS_RD16(DCBBase + DCB_ICB_OFFSET);
            pI2cPort = (U032 *)pDev->Dac.DCBI2c;
            for (i = 0; i < DCB_MAX_NUM_I2C_RECORDS; i++) 
            {
                *pI2cPort++ = BIOS_RD32(offset);

                if (pDev->Dac.DCBI2c[i].I2cAccess == I2C_PORT_ACCESS_UNUSED)
                    break;

                offset += sizeof(U032);
            }
            I2cPorts = i;
        }
    }
    else
    {
RM_DCB:        
        // fake DCB records for older board
#define SETUP_DCB_DESC(i,a,b,c,d,e,f,g)                                     \
        pDev->Dac.DCBDesc[i].DCBRecType = DCB_DEV_REC_TYPE_##a;             \
        pDev->Dac.DCBDesc[i].DCBRecSubtype = DCB_DEV_REC_SUBTYPE_##b;       \
        pDev->Dac.DCBDesc[i].DCBRecFmt = DCB_DEV_REC_FMT_##c;               \
        pDev->Dac.DCBDesc[i].DCBRecIdxToICB = DCB_DEV_REC_LOGICAL_PORT_##d; \
        pDev->Dac.DCBDesc[i].DCBRecHead = DCB_DEV_REC_HEAD_##e;             \
        pDev->Dac.DCBDesc[i].DCBRecLocation = DCB_DEV_REC_LOCATION_##f;     \
        pDev->Dac.DCBDesc[i].DCBRecBus = DCB_DEV_REC_BUS_##g;

        if (IsNV11(pDev)) 
        {
            pDev->Dac.DCBI2c[0].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[0].WritePort = I2C_PHYSICAL_PORT_A_DATA;
            pDev->Dac.DCBI2c[0].ReadPort = I2C_PHYSICAL_PORT_A_STATUS;

            pDev->Dac.DCBI2c[1].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[1].WritePort = I2C_PHYSICAL_PORT_B_DATA;
            pDev->Dac.DCBI2c[1].ReadPort = I2C_PHYSICAL_PORT_B_STATUS;

            pDev->Dac.DCBI2c[2].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[2].WritePort = I2C_PHYSICAL_PORT_C_DATA;
            pDev->Dac.DCBI2c[2].ReadPort = I2C_PHYSICAL_PORT_C_STATUS;

            pDev->Dac.DCBI2c[3].I2cAccess = I2C_PORT_ACCESS_UNUSED;
            I2cPorts = 3;

            if (pDev->Power.MobileOperation) 
            {
                //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
                SETUP_DCB_DESC(0, DD_SLINK, UNUSED, UNUSED, UNUSED, B,      UNUSED, 0); 
                SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, UNUSED, A,      UNUSED, 0); 
                SETUP_DCB_DESC(2, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 1); 
                SETUP_DCB_DESC(3, CRT,      UNUSED, UNUSED, 0,      B,      UNUSED, 1); 
                if ((1 == pDev->Power.MobileOperation) || (pDev->Power.MobileOperation == 2)) 
                {     // no CRT/TV combo on toshiba
                    SETUP_DCB_DESC(4, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 1); 
                    SETUP_DCB_DESC(5, TV,       UNUSED, UNUSED, 1,      B,      UNUSED, 1); 
                }
                else 
                {
                    SETUP_DCB_DESC(4, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 2); 
                    SETUP_DCB_DESC(5, TV,       UNUSED, UNUSED, 1,      B,      UNUSED, 2); 
                }
                SETUP_DCB_DESC(6, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 
                DevDescs = 6;
                CRTCs = 2;
            }
            else 
            {
                if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "Nv11DVIConnectorOnly", &RegistryData) == RM_OK) 
                {
                    //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
                    SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 1,      A,      UNUSED, 0); 
                    SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, 1,      A,      UNUSED, 0); 
                    SETUP_DCB_DESC(2, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 

                    DevDescs = 2;
                    CRTCs = 1;
                }
                else 
                {
                    //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
                    SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 0); 
                    SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, 1,      A,      UNUSED, 1); 
                    SETUP_DCB_DESC(2, DD_SLINK, UNUSED, UNUSED, 1,      B,      UNUSED, 1); 
                    SETUP_DCB_DESC(3, CRT,      UNUSED, UNUSED, 1,      B,      UNUSED, 2); 
                    // Originally this was set up as A, B for 24 bit, B, A for 12 bit.
                    // The problem with that is that we don't want to use B as the primary on a desktop system.
                    // The desktop BIOS is not head aware; it will always assume head A, so DOS boxes won't work on B.
                    if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT) 
                    {
                        SETUP_DCB_DESC(4, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 1); 
                        SETUP_DCB_DESC(5, TV,       UNUSED, UNUSED, 1,      B,      UNUSED, 1); 
                    }
                    else 
                    {
                        SETUP_DCB_DESC(4, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 3); 
                        SETUP_DCB_DESC(5, TV,       UNUSED, UNUSED, 1,      B,      UNUSED, 3); 
                    }
                    SETUP_DCB_DESC(6, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 

                    DevDescs = 6;
                    CRTCs = 2;
                }
            }
        }
        else 
        {  // non NV11 boards
            pDev->Dac.DCBI2c[0].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[0].WritePort = I2C_PHYSICAL_PORT_A_DATA;
            pDev->Dac.DCBI2c[0].ReadPort = I2C_PHYSICAL_PORT_A_STATUS;
            pDev->Dac.DCBI2c[1].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
            pDev->Dac.DCBI2c[1].WritePort = I2C_PHYSICAL_PORT_B_DATA;
            pDev->Dac.DCBI2c[1].ReadPort = I2C_PHYSICAL_PORT_B_STATUS;
            pDev->Dac.DCBI2c[2].I2cAccess = I2C_PORT_ACCESS_UNUSED;
            I2cPorts = 2;

            //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
            SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 0); 
            SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, 1,      A,      UNUSED, 0); 
            SETUP_DCB_DESC(2, TV,       UNUSED, UNUSED, 1,      A,      UNUSED, 0); 
            SETUP_DCB_DESC(3, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED); 
            DevDescs = 3;
            CRTCs = 1;
        }
    }


#ifdef MACOS
    //special failure case for NV11/NV20 on Mac - seeds are broken or not present
    //DDLLPP - remove when new seed properly describes hardware
    pDev->Dac.DCBI2c[0].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
    pDev->Dac.DCBI2c[0].WritePort = I2C_PHYSICAL_PORT_A_DATA;
    pDev->Dac.DCBI2c[0].ReadPort = I2C_PHYSICAL_PORT_A_STATUS;

    pDev->Dac.DCBI2c[1].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
    pDev->Dac.DCBI2c[1].WritePort = I2C_PHYSICAL_PORT_B_DATA;
    pDev->Dac.DCBI2c[1].ReadPort = I2C_PHYSICAL_PORT_B_STATUS;

    pDev->Dac.DCBI2c[2].I2cAccess = I2C_PORT_ACCESS_CRTC_INDEXED;
    pDev->Dac.DCBI2c[2].WritePort = I2C_PHYSICAL_PORT_C_DATA;
    pDev->Dac.DCBI2c[2].ReadPort = I2C_PHYSICAL_PORT_C_STATUS;

    pDev->Dac.DCBI2c[3].I2cAccess = I2C_PORT_ACCESS_UNUSED;
    I2cPorts = 3;
    
    if(IsNV20(pDev))
    {
        SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 0);
        SETUP_DCB_DESC(1, CRT,      UNUSED, UNUSED, 1,      A,      UNUSED, 0);
        SETUP_DCB_DESC(2, DD_SLINK, UNUSED, UNUSED, 1,      A,      UNUSED, 0);
        SETUP_DCB_DESC(3, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, 0);   
        
        DevDescs = 3;
        CRTCs = 1;
    }    
    if(IsNV11(pDev))
    {   
        if (osReadRegistryBoolean(pDev, NULL, "backlight-control"))
        {

            //                TYPE      SUBTYPE FMT     I2C_IDX HEAD    LOCATION BUS
            SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, UNUSED, A,      UNUSED, 0     ); 
            SETUP_DCB_DESC(1, DD_SLINK, UNUSED, UNUSED, 1,      B,      UNUSED, 0     );
            SETUP_DCB_DESC(2, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, UNUSED);
            
            DevDescs = 2;
            CRTCs = 2;
        }
        else
        {
            SETUP_DCB_DESC(0, CRT,      UNUSED, UNUSED, 0,      A,      UNUSED, 0);
            SETUP_DCB_DESC(1, CRT,      UNUSED, UNUSED, 1,      A,      UNUSED, 0);
            SETUP_DCB_DESC(2, DD_SLINK, UNUSED, UNUSED, 1,      B,      UNUSED, 0);
            SETUP_DCB_DESC(3, EOL,      UNUSED, UNUSED, UNUSED, UNUSED, UNUSED, 0);   
            
            DevDescs = 3;
            CRTCs = 2;
        }
    }
#endif    
    
    // override nvHalmcControl_nv10 setting
    DACHALINFO(pDev, NumCrtcs) = CRTCs;
    if (IsNV11(pDev) && OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "TwinViewDisabled", &RegistryData) == RM_OK)
        DACHALINFO(pDev, NumCrtcs) = 1;

    // find all devices with no I2C port.  these are the built in devices.
    // currently, only the flat panel on laptop doesn't have an I2C port
    // associate with it.  assume at most one device of each type.
    for (i = 0; i < DevDescs; i++) 
    {
        if (pDev->Dac.DCBDesc[i].DCBRecIdxToICB == DCB_DEV_REC_LOGICAL_PORT_UNUSED) 
        {
            switch (pDev->Dac.DCBDesc[i].DCBRecType) {
            case DCB_DEV_REC_TYPE_CRT:
                pDev->Dac.DCBDesc[i].DevTypeUnit = 0x1 << DAC_CRT_OFFSET_IN_MAP;
                CRTs = 1;
                break;

            case DCB_DEV_REC_TYPE_TV:
                pDev->Dac.DCBDesc[i].DevTypeUnit = 0x1 << DAC_TV_OFFSET_IN_MAP;
                TVs = 1;
                break;

            case DCB_DEV_REC_TYPE_DD_SLINK:
            case DCB_DEV_REC_TYPE_DD_DLINK:
            case DCB_DEV_REC_TYPE_DD:
                pDev->Dac.DCBDesc[i].DevTypeUnit = 0x1 << DAC_DD_OFFSET_IN_MAP;
                DDs = 1;
                break;
            }
        }
    }

    // assign device unit number according to the I2C port number.  devices
    // of the same type connected to the same I2C port have the same unit
    // number since they use the same connnector.
    for (i = 0; i < I2cPorts; i++) 
    {
        int     CRTFound;
        int     TVFound;
        int     DDFound;

        CRTFound = TVFound = DDFound = 0;
        for (j = 0; j < DevDescs; j++) 
        {
            if (pDev->Dac.DCBDesc[j].DCBRecIdxToICB != i)
                continue;

            switch (pDev->Dac.DCBDesc[j].DCBRecType) 
            {
            case DCB_DEV_REC_TYPE_CRT:
                pDev->Dac.DCBDesc[j].DevTypeUnit = 0x1 << (DAC_CRT_OFFSET_IN_MAP + CRTs);
                CRTFound = 1;
                break;

            case DCB_DEV_REC_TYPE_TV:
                pDev->Dac.DCBDesc[j].DevTypeUnit = 0x1 << (DAC_TV_OFFSET_IN_MAP + TVs);
                TVFound = 1;
                break;

            case DCB_DEV_REC_TYPE_DD_SLINK:
            case DCB_DEV_REC_TYPE_DD_DLINK:
            case DCB_DEV_REC_TYPE_DD:
                pDev->Dac.DCBDesc[j].DevTypeUnit = 0x1 << (DAC_DD_OFFSET_IN_MAP + DDs);
                DDFound = 1;
                break;

            }
        }

        CRTs += CRTFound;
        TVs += TVFound;
        DDs += DDFound;
    }

    // create devices bitmap
    pDev->Dac.DevicesBitMap = (((0x1 << CRTs) - 1) << DAC_CRT_OFFSET_IN_MAP) |
        (((0x1 << TVs) - 1) << DAC_TV_OFFSET_IN_MAP) |
        (((0x1 << DDs) - 1) << DAC_DD_OFFSET_IN_MAP);

    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "DevicesConnected", &RegistryData) == RM_OK)
        pDev->Dac.DevicesNoCheck = RegistryData;
    else
        pDev->Dac.DevicesNoCheck = 0;

    return RM_OK;
}

// Find the connect status of the specified devices.
// *pDevBitMap - on input, a map of devices to check the connect status of
//  at ouput, a map of the queried devices that are actually present
// DevForcePresentMap - a similarly formatted map that indicates devices
//  that should always be considered present, whether they are attached or not
VOID dacDevicesConnectStatus
(
    PHWINFO pDev,
    U032    *pDevBitMap,
    U032    DevForcePresentMap
)
{
    U032            dev = *pDevBitMap;
    PDACDCBDEVDESC  pDevDesc;
    U032            CurrDevTypeUnit = 0x1;
    BOOL            status;

    using_new_api = TRUE;
    while (dev) {
        if (dev & 0x1) {
            if (CurrDevTypeUnit & DevForcePresentMap)
                goto NextDev;

            // go through all entries in the DCB to find matching devices.
            pDevDesc = pDev->Dac.DCBDesc;
            while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL) {
                status = FALSE;
                if  (pDevDesc->DevTypeUnit == CurrDevTypeUnit) {
                    if (pDevDesc->DCBRecIdxToICB == DCB_DEV_REC_LOGICAL_PORT_UNUSED)
                        goto NextDev;

                    switch (pDevDesc->DCBRecType)  {
                    case DCB_DEV_REC_TYPE_CRT:
                        status = dacMonitorConnectStatus(pDev, pDevDesc->DCBRecHead);
                        break;

                    case DCB_DEV_REC_TYPE_TV:
                        status = dacTVConnectStatus(pDev, pDevDesc->DCBRecHead);
                        break;

                    case DCB_DEV_REC_TYPE_DD_SLINK:
                    case DCB_DEV_REC_TYPE_DD_DLINK:
                    case DCB_DEV_REC_TYPE_DD:
                        status = dacFlatPanelConnectStatus(pDev, pDevDesc->DCBRecHead);
                        break;
                    }

                    if (status == FALSE)
                        // clear the corresponding bit if no devices found.
                        *pDevBitMap &= ~CurrDevTypeUnit;

                    goto NextDev;
                }
                pDevDesc++;
            }
        }

NextDev:
        dev >>= 1;
        CurrDevTypeUnit <<= 1;
    }
    using_new_api = FALSE;
}

// this routine will try to find a configuration for the specified
// devices. return FALSE if a suitable configuration cannot be found.
// the configuration is returned in pAllocationMap with the first nibble
// corresponds to the first/rightmost device, second nibble corresponds
// to the second device, ... up to 8 devices can be specified. the nibble
// value is the head that should be connected to the device.
static BOOL dacMapDeviceToHead
(
    PHWINFO     pDev,
    U032        DevBitMap,          // devices in configuration
    U032        HeadsUsed,          // assigned heads
    U032        BusesUsed,          // assigned buses
    U032        CurrDev,            // current device
    U032        NibbleToUse,        // nibble to use for the next allocation
    U032        *pAllocationMap     // allocation map, result that will be passed
                                    // back to the calling routine
)
{
    PDACDCBDEVDESC  pDevDesc;

    // done, no more device
    if (!DevBitMap)
        return TRUE;

    // look for the rightmost set bit
    while (!(DevBitMap & 0x1)) {
        DevBitMap >>= 1;
        CurrDev++;
    }

    // use recursion to map device to head, one at a time.
    pDevDesc = pDev->Dac.DCBDesc;
    while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL) {
        if (pDevDesc->DevTypeUnit != ((U032)0x1 << CurrDev))
            goto NextDevDesc;

        // make sure we are not using resources assigned already.
        if (((0x1 << pDevDesc->DCBRecHead) & HeadsUsed) ||
            ((0x1 << pDevDesc->DCBRecBus) & BusesUsed))
            goto NextDevDesc;

        if (dacMapDeviceToHead(pDev,
                               DevBitMap >> 1,
                               HeadsUsed | (0x1 << pDevDesc->DCBRecHead),
                               BusesUsed | (0x1 << pDevDesc->DCBRecBus),
                               CurrDev + 1,
                               NibbleToUse + 1,
                               pAllocationMap) == TRUE) {
            *pAllocationMap |= pDevDesc->DCBRecHead << (NibbleToUse * 4);
            return TRUE;
        }

NextDevDesc:
        pDevDesc++;
    }

    return FALSE;
}

// find a suitable configuration for the specified devices.
RM_STATUS dacFindDevicesConfiguration
(
    PHWINFO pDev,
    U032    NewDevBitMap,
    U032    *pNewAllocationMap,
    U032    OldDevBitMap,
    U032    OldAllocationMap
)
{
    U032        DevBitMap;
    U032        CurrDev;
    U032        NibbleToUse;
    U032        HeadsUsed = 0x0;     // heads used
    U032        BusesUsed = 0x0;     // buses used
    U032        head;
    PDACDCBDEVDESC pDevDesc;
    U032        AdjustedOldAllocationMap = 0x0;
    U032        AdjustedNibbleToUse;
    U032        NewConfig;

    // find common devices between the old and new configurations. keep them
    // attaching to the same CRTCs if possible.
    DevBitMap = OldDevBitMap;
    CurrDev = NibbleToUse = AdjustedNibbleToUse = 0;
    while (DevBitMap) {
        if (!(DevBitMap & 0x1))
            goto NextDev_0;

        // device in the old but not in the new configuration ?
        if (!(OldDevBitMap & NewDevBitMap & (0x1 << CurrDev))) {
            NibbleToUse++;
            goto NextDev_0;
        }

        // device is in both the old and new configurations.
        // find CRTCs attached to the device and mark it as used.
        // adjust old allocation map such that we can merge it with the new
        // allocation map later.
        head = (OldAllocationMap >> (NibbleToUse++ * 4)) & 0xf;
        HeadsUsed |= 0x1 << head;
        AdjustedOldAllocationMap |= head << (AdjustedNibbleToUse++ * 4);

        // determine other non-shared resources used by this device.
        pDevDesc = pDev->Dac.DCBDesc;
        while (pDevDesc->DCBRecType != DCB_DEV_REC_TYPE_EOL) {
            if ((pDevDesc->DevTypeUnit != ((U032)0x1 << CurrDev)) ||
                (pDevDesc->DCBRecHead != head))
                pDevDesc++;
            else {
                BusesUsed |= 0x1 << pDevDesc->DCBRecBus;
                break;
            }
        }

NextDev_0:
        DevBitMap >>= 1;
        CurrDev++;
    }

    // find new allocation with common devices at fixed CRTCs.
    NewConfig = 0x0;
    if (dacMapDeviceToHead(pDev,
                           (NewDevBitMap ^ OldDevBitMap) & NewDevBitMap,
                           HeadsUsed,
                           BusesUsed,
                           0,
                           0,
                           &NewConfig) == TRUE) {

        // no merging necessary if there are no common devices.
        if (!(OldDevBitMap & NewDevBitMap)) {
            *pNewAllocationMap = NewConfig;
            return RM_OK;
        }

        // merge configuration.
        DevBitMap = NewDevBitMap;
        *pNewAllocationMap = 0x0;
        CurrDev = NibbleToUse = 0;
        while (DevBitMap) {
            if (!(DevBitMap & 0x1))
                goto NextDev_1;

            if ((0x1 << CurrDev) & OldDevBitMap) {
                *pNewAllocationMap |= (AdjustedOldAllocationMap & 0xf) << (NibbleToUse++ * 4);
                AdjustedOldAllocationMap >>= 4;
            }
            else {
                *pNewAllocationMap |= (NewConfig & 0xf) << (NibbleToUse++ * 4);
                NewConfig >>= 4;
            }

NextDev_1:
            DevBitMap >>= 1;
            CurrDev++;
        }

        return RM_OK;
    }

    // couldn't find allocation with common devices at fixed CRTCs.
    // try to get allocation with no CRTCs fixed.
    if (OldDevBitMap & NewDevBitMap) {
        *pNewAllocationMap = 0x0;
        if (dacMapDeviceToHead(pDev,
                               NewDevBitMap,
                               0x0,
                               0x0,
                               0,
                               0,
                               pNewAllocationMap) == TRUE)
            return RM_OK;
    }

    return RM_ERROR;
}

//
// This is a more complete way of implementating a modeset within the RM from
// VIDEO_LUT_CURSOR_DAC values. It's more than just calling dacSetModeMulti
// since other VIDEO_LUT_CURSOR_DAC methods also occur during a complete modeset.
//
RM_STATUS dacSetModeFromObjectInfo
(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac
)
{
    // Do the initial basic modeset (uses a default startAddr and palette)
    dacSetModeMulti(pDev, pVidLutCurDac);

    // Program the correct CRTC startAddr/pitch (with panning offset).
    if (pVidLutCurDac->Image[0].ImageCtxDma)
    {
        U032 startAddr;
        startAddr = (U032)
                    ((size_t)(pVidLutCurDac->Image[0].ImageCtxDma->DescAddr) +
                     pVidLutCurDac->Image[0].Offset);
        startAddr += pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].CurrentPanOffset;

        dacProgramVideoStart(pDev,
                             DACGETHEAD(pVidLutCurDac),
                             startAddr,
                             pVidLutCurDac->Image[0].Pitch);
    }

    // Program the user-defined LUT
    if (pVidLutCurDac->LUT[0].LUTCtxDma)
    {
        RM_STATUS status;
        U032 numEntries = 256;
        U032 *pPaletteAddr;
        
        status = dmaGetMappedAddress(pDev,
                                     pVidLutCurDac->LUT[0].LUTCtxDma,
                                     pVidLutCurDac->LUT[0].Offset,
                                     numEntries * 4,
                                     (void **)(&pPaletteAddr));
        if (status == RM_OK)
            dacProgramLUT(pDev, DACGETHEAD(pVidLutCurDac), pPaletteAddr, numEntries);
    }

    return RM_OK;
}

static RM_STATUS GetCrcValuesCallback
(
    PHWINFO   pDev,
    POBJECT   pObject,
    U032      Head,
    U032      Channel,
    RM_STATUS Status
)
{
    switch (GETDISPLAYTYPE(pDev, Head))
    {
        case DISPLAY_TYPE_MONITOR:
            DAC_REG_WR32
            (
                NV_PRAMDAC_TEST_CONTROL,
                  DRF_DEF(_PRAMDAC, _TEST_CONTROL, _CRC_RESET,   _DEASSERTED)
                | DRF_DEF(_PRAMDAC, _TEST_CONTROL, _CRC_ENABLE,  _ASSERTED)
                | DRF_NUM(_PRAMDAC, _TEST_CONTROL, _CRC_CHANNEL, Channel)
                | DRF_DEF(_PRAMDAC, _TEST_CONTROL, _CRC_CAPTURE, _ONE),
                Head
            );
            break;

        case DISPLAY_TYPE_FLAT_PANEL:
            DAC_REG_WR32
            (
                NV_PRAMDAC_FP_TEST_CONTROL,
                  DRF_DEF(_PRAMDAC, _FP_TEST_CONTROL, _CRC_RESET,   _DEASSERTED)
                | DRF_DEF(_PRAMDAC, _FP_TEST_CONTROL, _CRC_ENABLE,  _ASSERTED)
                | DRF_NUM(_PRAMDAC, _FP_TEST_CONTROL, _CRC_CHANNEL, Channel)
                | DRF_DEF(_PRAMDAC, _FP_TEST_CONTROL, _CRC_CAPTURE, _ONE),
                Head
            );
            break;

        case DISPLAY_TYPE_TV:
            DAC_REG_WR32
            (
                NV_PRAMDAC_TV_TEST_CONTROL,
                  DRF_DEF(_PRAMDAC, _TV_TEST_CONTROL, _CRC_RESET,   _DEASSERTED)
                | DRF_DEF(_PRAMDAC, _TV_TEST_CONTROL, _CRC_ENABLE,  _ASSERTED)
                | DRF_NUM(_PRAMDAC, _TV_TEST_CONTROL, _CRC_CHANNEL, Channel)
                | DRF_DEF(_PRAMDAC, _TV_TEST_CONTROL, _CRC_CAPTURE, _ONE),
                Head
            );
            break;

        default:
            RM_ASSERT(0);
            return RM_ERROR;
    }

    return RM_OK;
}

RM_STATUS  dacGetCrcValues
(
    PHWINFO pDev,
    U032    Head,
    U032 *  pRedCrc,
    U032 *  pGreenCrc,
    U032 *  pBlueCrc
)
{
    VBLANKCALLBACK VBlankCallback;
    U032 Channel;
    U032 Crcs[3];
    U032 i;
    U032 Try;
    U032 DisplayType  = GETDISPLAYTYPE(pDev, Head);
    U032 MaxPollLoops = 100;
    U032 Retries      =  10;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: dacGetCrcValues:\n");

    VBlankCallback.Proc        = GetCrcValuesCallback;
    VBlankCallback.Object      = 0;
    VBlankCallback.Param1      = Head;
    VBlankCallback.Param2      = 0;     // Used to pass Channel to callback.
    VBlankCallback.VBlankCount = 0;
    VBlankCallback.Flags       = 0;
    VBlankCallback.Status      = RM_OK;
    VBlankCallback.Next        = 0;

    *pRedCrc   = 0;
    *pGreenCrc = 0;
    *pBlueCrc  = 0;

    for (Channel = 0; Channel < 3; ++Channel)
    {
        switch (DisplayType)
        {
            case DISPLAY_TYPE_MONITOR:
                for (Try = 0; Try < Retries; ++Try)
                {
                    // Reset CRC.
                    DAC_REG_WR32(NV_PRAMDAC_TEST_CONTROL,
                          DRF_DEF(_PRAMDAC, _TEST_CONTROL, _CRC_RESET,   _ASSERTED)
                        | DRF_DEF(_PRAMDAC, _TEST_CONTROL, _CRC_ENABLE,  _ASSERTED)
                        | DRF_DEF(_PRAMDAC, _TEST_CONTROL, _CRC_CAPTURE, _ONE),
                        Head);

                    // Capture the CRC.
                    VBlankCallback.Param2 = Channel;
                    VBlankAddCallback(pDev, Head, &VBlankCallback);
                    for (i = 0; (DAC_REG_RD_DRF(_PRAMDAC, _CHECKSUM, _STATUS, Head)
                                    != NV_PRAMDAC_CHECKSUM_STATUS_CAPTURED)
                                &&  (i < MaxPollLoops); ++i)
                    {
                        osDelay(1);
                    }
                    if (i < MaxPollLoops)
                    {
                        Crcs[Channel] = DAC_REG_RD_DRF(_PRAMDAC, _CHECKSUM, _VALUE, Head); 
                        break;
                    }
                }
                if (Try == Retries)
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: failed to capture DAC CRC\n");
                    return FALSE;
                }

                break;
    
            case DISPLAY_TYPE_FLAT_PANEL:
                for (Try = 0; Try < Retries; ++Try)
                {
                    // Reset CRC.
                    DAC_REG_WR32(NV_PRAMDAC_FP_TEST_CONTROL,
                          DRF_DEF(_PRAMDAC, _FP_TEST_CONTROL, _CRC_RESET,   _ASSERTED)
                        | DRF_DEF(_PRAMDAC, _FP_TEST_CONTROL, _CRC_ENABLE,  _ASSERTED)
                        | DRF_DEF(_PRAMDAC, _FP_TEST_CONTROL, _CRC_CAPTURE, _ONE),
                        Head);

                    // Capture the CRC.
                    VBlankCallback.Param2 = Channel;
                    VBlankAddCallback(pDev, Head, &VBlankCallback);
                    for (i = 0; (DAC_REG_RD_DRF(_PRAMDAC, _FP_CHECKSUM, _STATUS, Head)
                                    != NV_PRAMDAC_FP_CHECKSUM_STATUS_CAPTURED)
                                &&  (i < MaxPollLoops); ++i)
                    {
                        osDelay(1);
                    }
                    if (i < MaxPollLoops)
                    {
                        Crcs[Channel] = DAC_REG_RD_DRF(_PRAMDAC, _FP_CHECKSUM, _VAL, Head); 
                        break;
                    }
                }
                if (Try == Retries)
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: failed to capture FP CRC\n");
                    return FALSE;
                }

                break;
    
            case DISPLAY_TYPE_TV:
                for (Try = 0; Try < Retries; ++Try)
                {
                    // Reset CRC.
                    DAC_REG_WR32(NV_PRAMDAC_TV_TEST_CONTROL,
                          DRF_DEF(_PRAMDAC, _TV_TEST_CONTROL, _CRC_RESET,   _ASSERTED)
                        | DRF_DEF(_PRAMDAC, _TV_TEST_CONTROL, _CRC_ENABLE,  _ASSERTED)
                        | DRF_DEF(_PRAMDAC, _TV_TEST_CONTROL, _CRC_CAPTURE, _ONE),
                        Head);

                    // Capture the CRC.
                    VBlankCallback.Param2 = Channel;
                    VBlankAddCallback(pDev, Head, &VBlankCallback);
                    for (i = 0; (DAC_REG_RD_DRF(_PRAMDAC, _TV_CHECKSUM, _STATUS, Head)
                                    != NV_PRAMDAC_TV_CHECKSUM_STATUS_CAPTURED)
                                &&  (i < MaxPollLoops); ++i)
                    {
                        osDelay(1);
                    }
                    if (i < MaxPollLoops)
                    {
                        Crcs[Channel] = DAC_REG_RD_DRF(_PRAMDAC, _TV_CHECKSUM, _VAL, Head); 
                        break;
                    }
                }
                if (Try == Retries)
                {
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: failed to capture TV CRC\n");
                    return FALSE;
                }

                break;
    
            default:
                RM_ASSERT(0);
                return RM_ERROR;
        }

    } // for each channel

    *pRedCrc   = Crcs[2];
    *pGreenCrc = Crcs[1];
    *pBlueCrc  = Crcs[0];

    return RM_OK;
}

RM_STATUS dacSetHotPlugInterrupts(PHWINFO pDev, U032 Head, U032 HotPlugEnable, U032 HotUnplugEnable)
{
    U032 HotPlugEnableProxy,HotUnplugEnableProxy;
    
    //do the transfer safely since technically we should be passing pointers to writeable memory
    HotPlugEnableProxy = HotPlugEnable;
    HotUnplugEnableProxy = HotUnplugEnable;

    //do the set    
    return nvHalDacHotPlugInterrupts(
        pDev,
        (VOID *)&(((PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[Head].pVidLutCurDac))->HalObject),
        &HotPlugEnableProxy,
        &HotUnplugEnableProxy,
        TRUE /* write mode */,
        TRUE /* reset */
    );
}

RM_STATUS dacGetHotPlugInterrupts(PHWINFO pDev, U032 Head, U032 * pHotPlugStatus, U032 * pHotUnplugStatus, BOOL Reset)
{
    return nvHalDacHotPlugInterrupts(
        pDev,
        (VOID *)&(((PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[Head].pVidLutCurDac))->HalObject),
        pHotPlugStatus,
        pHotUnplugStatus,
        FALSE /* read mode */,
        Reset
    );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dacfp.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* DAC Flat panel Control ********************\
*                                                                           *
* Module: DACFP.C                                                           *
*   Mode set for flat panel is done here.                                   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <dac.h>
#include <os.h>
#include <nvcm.h>
#include <edid.h>
#include <devinit.h>
#include "nvhw.h"


#if defined(NTRM) && !defined(WriteIndexed)
// For NT these are in modehw.h which is in the miniport.
VOID WriteIndexed(U032 addr, U016 datum);
U016 ReadIndexed(U032 addr, U008 reg);
#endif //NTRM

// Const strings for accessing the registry
extern char strFpMode[];

//*************************** Exported functions *****************************************

// turning on the clocks requires a delay that is easily forgotten,
//   so try to do it all in one place
RM_STATUS dacWriteLinkPLL(
    PHWINFO pDev,
    U032    Head,
    U032    which)
{
    DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, which, Head);     // FP on to access TMDS
    tmrDelay(pDev, 0x400000);
    
    return RM_OK;
}


RM_STATUS dacAdjustCRTCForFlatPanel
(
    PHWINFO pDev, 
    U032 Head,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac
)
{
    U032    Ht, Hre, Vt, Vrs, Vre, Vbs, data32;
    U016    Seq, Vendor;
    U008    lock, Cr03, Cr04, Cr05, Cr07, Cr09, Cr11, Cr25, Cr28, Cr2d, Cr33;
#if 0
    U032 cntl32;
#endif

    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);   // power on flat panel

#if 0 // If TMDS not powered up, it will hang
    //
    // First, check if the internal TMDS exists, by trying to read/write
    // the TMDS_CONTROL register. If it exists, only power up the internal
    // TMDS, if we're not using an external one.
    //
    cntl32 = DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | NV_PRAMDAC_INDIR_TMDS_PLL1;
    REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, cntl32);
    if (REG_RD32(NV_PRAMDAC_FP_TMDS_CONTROL) == cntl32)
    {
        // The internal TMDS exists, see if we're using the external TMDS
        if (REG_RD_DRF(_PRAMDAC, _FP_TEST_CONTROL, _TMDS) == NV_PRAMDAC_FP_TEST_CONTROL_TMDS_EXTERNAL)
        {
            dacWriteLinkPLL(pDev, 0, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_TMDS);
        }
    }
#endif
    // Toshiba SBIOS behaves badly: it may lock ext CRTC's on us during SMI.
    lock = UnlockCRTC(pDev, 0);
    if (lock != NV_CIO_SR_UNLOCK_RW_VALUE) 
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ext CRTC's are locked in dacAdjustCRTCForTV\r\n");
    }
    
    // check for pixel doubled modes
    if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_MONITOR) &&
        (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth < 640))
    {
        Seq = ReadIndexed(NV_PRMVIO_SRX, 1);
        Seq |= 0x800;   // divide pixel clock to double size
        WriteIndexed(NV_PRMVIO_SRX, Seq);
    }        
    // Make sure attr is set correctly
    Cr07 = REG_RD08(NV_PRMCIO_INP0__COLOR); // read 3DA to toggle (data = don't care)
    REG_WR08(NV_PRMCIO_ARX, 0x30);          // select reg 0x10, bit 5 set to access reg (not palette)
    REG_WR08(NV_PRMCIO_ARX, 0x01);          // clear bit 5

    // New rules
    // VRS = VT - 3
    // VRE = VT - 2
    // HRS = HT - 3
    // HRE = HT - 2
    // HBE = HT + 4  This is required for the overlay to sync (videos will be offset).
    CRTC_RD(NV_CIO_CRE_HEB__INDEX, Cr2d, Head);
    CRTC_RD(NV_CIO_CR_HDT_INDEX, Ht, Head);
    if (Cr2d & BIT(0))
        Ht |= BIT(8);
    Cr04 = (U008)Ht - 3; // everyone else except SGI
    // SGI is "special". We have to check for their panel and adjust HRS.
    if (pDev->Dac.CrtcInfo[Head].EDID != 0)
    {
    // EDID Version 1 version field should never be 1 on a version 2 (it's an ascii field in V2).
        if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 1)
        {
            Vendor = (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VENDOR_ID_INDEX+1])<<8 | pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VENDOR_ID_INDEX];
            if (Vendor == 0xf84c)  //SGI
            {
                Cr04 = (U008)Ht; // All modes
                if ( ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 640) &&
                      (pDev->Framebuffer.HalInfo.VertDisplayWidth  == 480))
                     ||
                     ((pDev->Framebuffer.HalInfo.HorizDisplayWidth == 800) &&
                      (pDev->Framebuffer.HalInfo.VertDisplayWidth  == 600))
                   )
                {   
                    Cr04 = (U008)Ht+1;
                }
            }                              
        }
    }
    CRTC_WR(NV_CIO_CR_HRS_INDEX, Cr04, Head);        // HRS
    if (Ht & BIT(8))
        Cr2d |= 8;
    CRTC_WR(NV_CIO_CRE_HEB__INDEX, Cr2d, Head);   // HRS msb
    
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Hre, Head);    // read CR05 and mask 4:0
    Hre &= 0xe0;
    CRTC_WR(NV_CIO_CR_HRE_INDEX, (Ht-2) | Hre, Head);   // HRE = Ht - 2, CR04[4:0]
    
    CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    CRTC_RD(NV_CIO_CR_HBE_INDEX, Cr03, Head);
    // HBE = HT + 4. HBE[6] = CR25[4], HBE[5] = CR5[7], HBE[4:0] = CR3[4:0]
    Cr03 &= 0xE0;   // lose 4:0, the HBE bits
    Cr03 |= (Ht + 4) & 0x1f;
    CRTC_WR(NV_CIO_CR_HBE_INDEX, Cr03, Head);     // HBE[4:0]
    CRTC_RD(NV_CIO_CR_HRE_INDEX, Cr05, Head);
    Cr05 &= 0x7f;
    if ((Ht + 4) & BIT(5))
        Cr05 |= BIT(7);
    CRTC_WR(NV_CIO_CR_HRE_INDEX, Cr05, Head);     // HBE[5]
    Cr25 &= 0xEF;
    if ((Ht + 4) & BIT(6))
        Cr25 |= BIT(4);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);    // HBE[6]

    // gather VT bits
    CRTC_RD(NV_CIO_CR_VDT_INDEX, Vt, Head);
    if (Cr07 & BIT(0))  // bit 8 of VT
        Vt |= BIT(8);
    if (Cr07 & BIT(5))  // bit 9 of VT
        Vt |= BIT(9);
    if (Cr25 & BIT(0))  // bit 10 of VT
        Vt |= BIT(10);

    // VRS: CR10,7,25
    Vrs = Vt - 3;
    CRTC_WR(NV_CIO_CR_VRS_INDEX, Vrs, Head);
    Cr07 &= ~(BIT(7) | BIT(2)); // clear bits 7 and 2
    if (Vrs & BIT(8)) Cr07 |= BIT(2);
    if (Vrs & BIT(9)) Cr07 |= BIT(7);
    CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    if (Vrs & BIT(10)) Cr25 |= BIT(2);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
    
    // VRE: CR11[3:0]
    Vre = (Vt - 2) & 0x0f;
    CRTC_RD(NV_CIO_CR_VRE_INDEX, Cr11, Head);
    Vre |= (Cr11 & 0xf0);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, Vre, Head);
    
    // VBS = VRS
    CRTC_RD(NV_CIO_CR_CELL_HT_INDEX, Cr09, Head);
    Vbs = Vrs;
                
    // write VBS            
    Cr07 &= ~BIT(3); // clear bit 3
    if (Vbs & BIT(8)) Cr07 |= BIT(3);
    Cr09 &= ~BIT(5); // clear bit 5
    if (Vbs & BIT(9)) Cr09 |= BIT(5);
    Cr25 &= ~BIT(3); // clear bit 3
    if (Vbs & BIT(10)) Cr25 |= BIT(3);
    CRTC_WR(NV_CIO_CR_VBS_INDEX, Vbs, Head);
    CRTC_WR(NV_CIO_CR_OVL_INDEX, Cr07, Head);
    CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, Cr09, Head);
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, Cr25, Head);
            
    data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);    // usual macro won't help us here
    data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16);    // clear VCNTR bits
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);

    // Also, ensure there's enough bandwidth for video.
    // 
    // With big panels in a scaled low res mode (e.g. 16x12 FP in 8x6), the
    // CRTC slaved off the FP can stall for 1/2 the time, which seems to cause
    // video underflow. To fix this, we lengthen HTOTAL to allow more clocks
    // (see bugid 20010130-110932).
    //
    if (pDev->Power.MobileOperation)
    {
        U032 Hrs, fpHSync, fpHTotal;
 
        // read the horizontal extra bits
        CRTC_RD(NV_CIO_CRE_HEB__INDEX, Cr2d, Head);

        // get the CRTC hsync start
        CRTC_RD(NV_CIO_CR_HRS_INDEX, Hrs, Head);
        if (Cr2d & BIT(3))
            Hrs |= BIT(8);    // add bit8

        // get the FP hsync values
        fpHTotal = DAC_REG_RD32(NV_PRAMDAC_FP_HTOTAL, Head);
        fpHSync = DAC_REG_RD32(NV_PRAMDAC_FP_HCRTC, Head);

        // set the CRTC HTOTAL closer to the FP horiz timings (take off 8
        // chars for the delay between FP_HCRTC and when the CRTC sees it).
        Ht  = (fpHTotal - fpHSync) / 8 + Hrs - 6;
        Ht -= 8;

        // set CR0 and the bit8 overflow, if necessary
        CRTC_WR(NV_CIO_CR_HDT_INDEX, Ht, Head);
        if (Ht & BIT(8))
        {
            Cr2d |= BIT(0);
            CRTC_WR(NV_CIO_CRE_HEB__INDEX, Cr2d, Head);
        }
    }

    // Toshiba SBIOS behaves badly: it may lock ext CRTC's on us during SMI.
    lock = UnlockCRTC(pDev, 0);
    if (lock != NV_CIO_SR_UNLOCK_RW_VALUE) 
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ext CRTC's are locked in dacAdjustCRTCForTV\r\n");
    }
    // Slave the CRTC to timing generator
    // Setup the crtc to work in slave mode (cr28).
    //
    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head);
    Cr28 |= BIT(7);
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, Cr28, Head); 
    CRTC_RD(0x33, Cr33, Head);   // NV_CIO_CRE_LCD__INDEX
    Cr33 |= BIT(0);     // bit 0 is HW
    Cr33 |= BIT(1);     // bit 1 is BIOS flag
    CRTC_WR(0x33, Cr33, Head);   //NV_CIO_CRE_LCD__INDEX
                          
    return RM_OK;
}

VOID dacTMDSWrite
(
    PHWINFO pDev,
    U032    Head,
    U008    Addr,
    U008    Data
)
{
    // Due to a bug in NV15, the procedure is more complicated than intended:
    // Write the index of the register with WRITE DISABLE set.
    // Write the data.
    // Write the index with WRITE DISABLED cleared.
    // Write the index with WRITE DISABLED set.
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | Addr, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_DATA, Data, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _ENABLE) | Addr, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | Addr, Head);
}


U008 dacTMDSRead
(
    PHWINFO pDev,
    U032    Head,
    U008    Addr
)
{
    U008 Data;

    // Write the index of the register with WRITE DISABLE set.
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | Addr, Head);
    // Read the data.
    Data = (U008) ( DAC_REG_RD32(NV_PRAMDAC_FP_TMDS_DATA, Head) & 0xFF );
    return Data;
}


RM_STATUS dacSetFlatPanelScaling
(
    PHWINFO pDev,
    U032    Head,
    U032    FpMode,
    BOOL    CommitChange
)
{
    RM_STATUS rmStatus = RM_OK;
    
    //store the fpMode, regardless
    pDev->Dac.HalInfo.CrtcInfo[Head].fpMode = FpMode;
    
    switch (FpMode)
    {
        case NV_CFGEX_GET_FLATPANEL_INFO_SCALED:
        case NV_CFGEX_GET_FLATPANEL_INFO_CENTERED:
        case NV_CFGEX_GET_FLATPANEL_INFO_NATIVE:
        {
            //
            // TEMPORARY WORKAROUND
            // 
            // The current control panel will lose track of what head it is really talking
            // to, so let's make sure this is the flat panel head.
            //
            if (pDev->Power.MobileOperation)
            {
                // Just hit them both in mobile as there is only one dfp
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, FpMode, 0);
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, FpMode, 1);
            }
            else
            {
                //
                // Change the DFP scaling mode.  For multisync panels, turn of fpclk
                // then delay after the change is being made, in order to ensure the correct
                // setup conditions.  Some multisync panels lose their sync otherwise.
                //

                    if (pDev->Dac.fpNative)
                {
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _BOTH, Head);
                    DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, FpMode, Head);
                    osDelay(10);
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _PWRDOWN, _NONE, Head);
                }
                else
                {
                    DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, FpMode, Head);
                }    

                //
                // WORKAROUND CONTROL PANEL BUG   (REMOVE REMOVE REMOVE when possible)
                //
                // The current control panel still asks us to set the wrong head.  We need
                // to fix the panel code, but until then, hit both heads.  This code needs 
                // to be removed when the real fix is made, as it will affect operation
                // of dual DVI systems
                //
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE, FpMode, Head ^ 1);
            }
            break;
        }

        case NV_CFGEX_GET_FLATPANEL_INFO_SCALED_8BIT:
        {
            // only implemented on headB
            if ( ! IsNV11(pDev))
                goto failed;
            // require B1 or later
            if ( ! (pDev->halHwInfo.pMcHalInfo->MaskRevision >= MC_MASK_REVISION_B1))
                goto failed;
            if (Head != 1)
                goto failed;
            if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL)
                goto failed;

            // turn on scaling mode
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _SCALE, Head);

            // disable dithering
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _6B_DITHER, _OFF, Head);
            
            // finally, turn on the scaling
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _YINTERP, _TRUNCATE, Head);
            break;
        }

        case NV_CFGEX_GET_FLATPANEL_INFO_CENTERED_DITHER:
        {
            U032 mode;
            
            // this only supported on NV11 B1 or better.
            if ( ! IsNV11(pDev))
                goto failed;
            // require B1 or later
            if ( ! (pDev->halHwInfo.pMcHalInfo->MaskRevision >= MC_MASK_REVISION_B1))
                goto failed;
            if (Head != 1)
                goto failed;
            if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL)
                goto failed;

            mode = DAC_REG_RD_DRF(_PRAMDAC, _FP_TG_CONTROL, _MODE, Head);
            if ((mode != NV_CFGEX_GET_FLATPANEL_INFO_CENTERED) && 
                (mode != NV_CFGEX_GET_FLATPANEL_INFO_NATIVE))
                goto failed;
                
            // turn on centered mode
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER, Head);
            
            //reset temporal dithering safety counter
            pDev->Dac.CrtcInfo[Head].VBlankTemporalDitherSafetyCounter=0;
            
            // dithering will be enabled in VBlankUpdateDither()

            break;
        }

        case NV_CFGEX_GET_FLATPANEL_INFO_SCALED_ASPECT_CORRECT:
        {
            U032 scaleX, scaleY;
            U032 scaleX1000, scaleY1000;
            U032 visible, unused;
            PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
            
            // this only supported on NV11 and newer (not NV15)
            if ( ! IsNV11orBetter(pDev))
                goto failed;
            if (GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL)
                goto failed;

            pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
            if ( ! pVidLutCurDac)
                goto failed;
                
            // turn on scaling mode
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _SCALE, Head);

            // disable dithering
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _6B_DITHER, _OFF, Head);

            // disable y truncate mode
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_0, _YINTERP, _BILINEAR, Head);

            // now do the work...
            scaleX = DAC_REG_RD_DRF(_PRAMDAC, _FP_DEBUG_3, _XSTEPSIZE, Head);
            scaleY = DAC_REG_RD_DRF(_PRAMDAC, _FP_DEBUG_3, _YSTEPSIZE, Head);
                
            if (scaleY > scaleX)
            {
                // lock the scaling as a forced value
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_1, _XSCALE_TESTMODE, _ENABLE, Head);
                // just use 12 bits of scale
                scaleY &= 0xFFF;
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_DEBUG_1, _XSCALE_VALUE, scaleY, Head);
                
                // now center it in X by setting HVALID start & end
                scaleX1000 = (pDev->Dac.HalInfo.fpVMax * 1000) / pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
                visible = (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth * scaleX1000) / 1000;
                unused = pDev->Dac.HalInfo.fpHMax - visible;
                
                // stock away values in the pDev
                pDev->Dac.fpHValidStart=unused / 2;
                pDev->Dac.fpHValidEnd=visible + (unused / 2);
                
                //do the hardware set
                DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_START, unused / 2, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_END, visible + (unused / 2), Head);
            }
            else
            {
                // lock the scaling as a force value
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_DEBUG_1, _YSCALE_TESTMODE, _ENABLE, Head);
                // just use 12 bits of scale
                scaleX &= 0xFFF;
                DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_DEBUG_1, _YSCALE_VALUE, scaleX, Head);
                
                // now center it in Y by setting VVALID start & end
                scaleY1000 = (pDev->Dac.HalInfo.fpHMax * 1000) / pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
                visible = (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight * scaleY1000) / 1000;
                unused = pDev->Dac.HalInfo.fpVMax - visible;
                
                //store these away in the pDev
                pDev->Dac.fpVValidStart=unused / 2;
                pDev->Dac.fpVValidEnd=visible + (unused / 2);
                
                //do the hardware set
                DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_START, unused / 2, Head);
                DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_END, visible + (unused / 2), Head);
            }

            break;
        }
        
        default:
             return RM_ERROR;
    }
        
    //
    // Do we want to save this setting?
    //
    if (CommitChange)
    {
        // write this mode to the registry
        // fill in the path to the registry key--last character is the display number
       rmStatus = osWriteRegistryDword(pDev,pDev->Registry.DBstrDevNodeDisplayNumber, strFpMode, FpMode);
    }

    return rmStatus;
 
failed:
    return RM_ERROR;
}


//Call dacSetFlatPanelScaling, and also commit the change to the system CMOS if
// the system supports that.  Can't be called while at a raised IRQL (e.g.,
// during modesets) because under NT we can't generate an int10h then.
RM_STATUS dacSetFlatPanelScalingCMOS
(
    PHWINFO pDev,
    U032    Head,
    U032    FpMode,
    BOOL    CommitChange
)
{

    RM_STATUS status;
    status = dacSetFlatPanelScaling(pDev, Head, FpMode, CommitChange);

#if !defined(MACOS)  
    if ((pDev->Power.MobileOperation) && (status == RM_OK)) {
        // Call through VGA BIOS to system BIOS to set center/scaling mode CMOS bit.
        // We do this here because under NT we can't make an int10h call during the modeset.
        // (while operating at a raised IRQ level).
//        RM_STATUS status;
        U032 eax, ebx, ecx, edx;
//        U032 FpMode = dacGetFlatPanelConfig(pDev, Head);

        eax = 0x4F14;       // VESA EDID function
//        ebx = (CommitChange?0x8000:0) | 0x0102;       // set center/scale mode
//        ecx = (FpMode == NV_CFGEX_GET_FLATPANEL_INFO_SCALED)?1:0;  // mode
        // XXX; may need to track other NV11 SCALED modes here...
        if (pDev->Power.MobileOperation == 2) {
            ebx = 0x8102;       // set center/scale mode
            ecx = (FpMode == NV_CFGEX_GET_FLATPANEL_INFO_SCALED)?1:0;  // mode
        } else {
            ebx = 0x0102;       // set center/scale mode
            ecx = (FpMode == NV_CFGEX_GET_FLATPANEL_INFO_SCALED)?0:1;  // mode
        }
        edx = 0;

        status = osCallVideoBIOS(pDev, &eax, &ebx, &ecx, &edx, NULL);
//        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: result from updating CMOS:", eax);
    }
#endif

    return status;
}


RM_STATUS dacSetFlatPanelMode
(
    PHWINFO pDev,
    U032    Head,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac,
    U032    FpMode,
    BOOL    commitChange
)
{
U032    data32, cntl32;
U008    est_tim1, est_tim2;
U032    fpHActive=0, fpHDispEnd=0, fpHValidStart=0, fpHValidEnd=0, fpHSyncStart=0, fpHSyncEnd=0, fpHTotal=0;
U032    fpVActive=0, fpVDispEnd=0, fpVValidStart=0, fpVValidEnd=0, fpVSyncStart=0, fpVSyncEnd=0, fpVTotal=0;
U032    fpPixClk, fpPolarity=0, M, N, P, pixels, refresh, dt_refresh;
BOOL    ModeValid, RefreshValid = FALSE;
U016    Vendor = 0x0;
U032    spreadEnabled;

    RM_STATUS rmStatus = RM_OK;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"In:dacSetFlatPanelMode\n");
    
    // check to make sure it's not null.  
    // This fixes bug 32021 "BSOD when switching between scaling/centering"
    if(pVidLutCurDac == NULL)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,
                         "NVRM: ERROR!!! dacSetFlatPanelMode() is called with pVidLutCurDac==NULL!\n");
        return RM_ERROR;
    }
    // check to make sure this is a DFP as well!
    // This fixes bug 32060: "LCD blooms when switching btw scaling/centering on LCD/TV extended"
    // There is a case on non-mobile platforms where Monitor is hooked up to Head 1
    // and the resman needs to setup as if it was a flat panel.
    if( (pVidLutCurDac->DisplayType != DISPLAY_TYPE_FLAT_PANEL) &&
        !( IsNV11(pDev) && (pVidLutCurDac->DisplayType == DISPLAY_TYPE_MONITOR) && 
            (Head==1) && !pDev->Power.MobileOperation) )
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,
                         "NVRM: ERROR!!! dacSetFlatPanelMode(): pVidLutCurDac != Flat Panel!\n");
        return RM_ERROR;
    }

    // Find requested refresh rate
    pixels = pVidLutCurDac->HalObject.Dac[0].TotalWidth * pVidLutCurDac->HalObject.Dac[0].TotalHeight;
    refresh = (pVidLutCurDac->HalObject.Dac[0].PixelClock*10000) / pixels;

    // if it didn't come out exactly, set to nearest choice
    // established timings are limited to 60, 70, 72, and 75
    if (refresh < 62)
        refresh = 60;
    else 
        if (refresh < 72)
            refresh = 70;
        else 
            if (refresh < 74)
                refresh = 72;
            else
                refresh = 75;


    // *********************************************************
    // Power On Flat Panel TMDS and FPCLK
    // Later in dacAdjustCRTCForFlatPanel() we will power
    // down the internal TMDS if we are using an external
    // one.  -paul
    // *********************************************************

    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);

    //stall now built into the action of turning the TMDS unit and FPCLK on
   

    // Set the scale factor in FP_DEBUG back to 0 in case the BIOS used this to get a special
    // mode, i.e. Japanese DOS. This is only done on NV10. 
    // In Windows modes, the scaling is always set by HW comparing the values in the FP timing
    // registers and the CRTC registers, so the DEBUG registers are always set to 0. 
    // For DOS 475 lines, this method doesn't work, because the scaling value is not in the HW 
    // tables on NV10, so the BIOS has to work around this by setting these DEBUG registers.
    
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_1, 0, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_2, 0, Head);
#ifdef IKOS
    FpMode = NV_CFGEX_GET_FLATPANEL_INFO_NATIVE;
#endif
    // read strapping bit to set proper control width
    if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE) == NV_PEXTDEV_BOOT_0_STRAP_FP_IFACE_24BIT)
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _WIDTH, _24, Head);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _WIDTH, _12, Head);
    }

    {
        //Special case for for SGI flat panel.  
        if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 1)
        {
            Vendor = (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VENDOR_ID_INDEX+1])<<8 | pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VENDOR_ID_INDEX];
            if (Vendor == 0xf84c)
            {

                if (pDev->Dac.fpNative)
                {
                     if ( 
                         pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 960
                         && FpMode ==  NV_CFGEX_GET_FLATPANEL_INFO_SCALED
                         && !IsNV11orBetter(pDev)
                         ) 
                     {
                         FpMode = NV_CFGEX_GET_FLATPANEL_INFO_NATIVE;
                     }
                }
                else
                {
                     if ( 
                         pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 960
                         && FpMode ==  NV_CFGEX_GET_FLATPANEL_INFO_SCALED
                         && !IsNV11orBetter(pDev)
                         ) 
                     {
                         FpMode = NV_CFGEX_GET_FLATPANEL_INFO_CENTERED;
                     }
                }
            }
        }
    }
    //
    // Set panel scaling mode
    //
    dacSetFlatPanelScaling(pDev, Head, FpMode, commitChange);

    // If we are going native, we must reprogram the dac with new timing
    // We saved the EDID in pDev->Dac.CrtcInfo[Head].EDID[].
    if ((FpMode == NV_CFGEX_GET_FLATPANEL_INFO_NATIVE) &&
        (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL))
    {
        // Check detailed timings first
        DACFPTIMING fpTim;
        U008 block;
        
        fpPixClk = 0;
        for (block=0; block<NUM_DET_TIM; block++)           
        {
            if (edidParseDetailedTimingBlock(pDev, block, &fpTim, Head))
            {
                // Check whether this timing block is for the mode requested
                //  or the doubled mode
                ModeValid = FALSE;
                switch  (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth)
                {
                    case 1600:
                        if (fpTim.HActive == 1600)
                        {
                            if ((fpTim.VActive == 1200) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1200)) 
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 1024) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1024))
                                ModeValid = TRUE;
                        }
                        break;
                    case 1280:
                        if (fpTim.HActive == 1280) 
                        {
                            if ((fpTim.VActive == 1024) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1024))
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 960) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 960))
                                ModeValid = TRUE;
                        }
                        break;
                    case 1024:
                    case 512:
                        if (fpTim.HActive == 1024)
                            if (fpTim.VActive == 768)
                                ModeValid = TRUE;
                        break;
                    case 800:
                    case 400:
                        if (fpTim.HActive == 800)
                            if (fpTim.VActive == 600)
                                ModeValid = TRUE;
                        break;
                    case 640:
                        if (fpTim.HActive == 640) // can be 640x480 or 640x400
                        {
                            if ((fpTim.VActive == 480) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 480))
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 400) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 400))
                                ModeValid = TRUE;
                        }
                        break;
                    case 320:
                        if (fpTim.HActive == 640) // can be 640x480 or 640x400
                        {
                            if ((fpTim.VActive == 480) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 240))
                                ModeValid = TRUE;
                            if ((fpTim.VActive == 400) && (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 200))
                                ModeValid = TRUE;
                        }
                        break;
                }
                if (ModeValid) // Use detailed timing
                {
                    fpPixClk = fpTim.PixClk;
                    fpHActive = fpTim.HActive;
                    fpHDispEnd = fpTim.HDispEnd;
                    fpHValidEnd = fpTim.HValidEnd;
                    fpHSyncStart = fpTim.HSyncStart;
                    fpHSyncEnd = fpTim.HSyncEnd;
                    fpHValidStart = fpTim.HValidStart;
                    fpHTotal = fpTim.HTotal - 1;
                    
                    fpVActive = fpTim.VActive;
                    fpVDispEnd = fpTim.VDispEnd;
                    fpVValidEnd = fpTim.VValidEnd;
                    fpVSyncStart = fpTim.VSyncStart;
                    fpVSyncEnd = fpTim.VSyncEnd;
                    fpVValidStart = fpTim.VValidStart;
                    fpVTotal = fpTim.VTotal - 1;
                    fpPolarity = (fpTim.Flags); // assume 4&3=1 (digital), then 2=vsync, 1=hsync
                
                    // Got a matching detailed timing, but is it the requested refresh rate?
                    // If not, we have a valid resolution we can use if we don't find right mode in established timing
                    pixels = fpHTotal * fpVTotal;
                    dt_refresh = (fpPixClk*10000) / pixels;
                    if (dt_refresh == refresh) 
                    {
                        RefreshValid = TRUE;
                    }
                }                       
            } // if parseDetailedTimings
        }
#if IKOS // no EDID
        RefreshValid = FALSE;
#endif
        if (!RefreshValid)  // not found in detailed, check established
        {
            est_tim1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_1_INDEX];
            est_tim2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_2_INDEX];
            fpPolarity = 0x3;   // estab timings use positive polarities on syncs

#if IKOS // give them whatever they ask for
            est_tim1 = 0xff;
            est_tim2 = 0xff;
#endif

            switch (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth)
            {
                case 320:
                case 640:   // 640x400 is not an established timing, but we can do 640x480 panel timing and send 640x400 data within this.
                    if ((pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==480) 
                        || (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==240)
                        || (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==400)
                        || (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight==200))
                    {
                        if ((refresh == 72) && (est_tim1 & EDID_ESTABLISHED_TIMING_640x480_72))
                        {
                            fpHActive =  640;
                            fpHDispEnd = 639;
                            fpHValidStart = 0;
                            fpHValidEnd = 639;
                            fpHSyncStart = 663;
                            fpHSyncEnd =  663+40;
                            fpHTotal = 831;
                            fpVActive = 480;
                            fpVDispEnd = 479;
                            fpVValidStart = 0;
                            fpVValidEnd =  479;
                            fpVSyncStart = 487;
                            fpVSyncEnd = 487+3;
                            fpVTotal = 519;
                            fpPixClk = 3150;    // 31.5 MHz
                            fpPolarity = VSYNC_NEG | HSYNC_NEG;
                            RefreshValid = TRUE;
                        }
                        else if ((refresh == 75) && (est_tim1 & EDID_ESTABLISHED_TIMING_640x480_75))
                        {
                            fpHActive =  640;
                            fpHDispEnd = 639;
                            fpHValidStart = 0;
                            fpHValidEnd = 639;
                            fpHSyncStart = 655;
                            fpHSyncEnd =  719;
                            fpHTotal = 839;
                            fpVActive = 480;
                            fpVDispEnd = 479;
                            fpVValidStart = 0;
                            fpVValidEnd =  479;
                            fpVSyncStart = 480;
                            fpVSyncEnd = 483;
                            fpVTotal = 499;
                            fpPixClk = 3150;    // 31.5 MHz
                            fpPolarity = VSYNC_NEG | HSYNC_NEG;
                            RefreshValid = TRUE;
                        }
                        // if none of the above, use 60 Hz
                        else if (est_tim1 & EDID_ESTABLISHED_TIMING_640x480_ANY)
                        {
                            fpHActive =  640;
                            fpHDispEnd = 639;
                            fpHValidStart = 0;
                            fpHValidEnd = 639;
                            fpHSyncStart = 655;
                            fpHSyncEnd =  655+96;
                            fpHTotal = 799;
                            fpVActive = 480;
                            fpVDispEnd = 479;
                            fpVValidStart = 0;
                            fpVValidEnd =  479;
                            fpVSyncStart = 489;
                            fpVSyncEnd = 489+2;
                            fpVTotal = 524;
                            fpPixClk = 2517;    // 25.17 MHz
                            fpPolarity = VSYNC_NEG | HSYNC_NEG;
                            RefreshValid = TRUE;    // this may not be correct, but we don't check refresh rate in standard timing,
                        }                           // so there is no point in looking further
                    }
                    break;
                case 400:
                case 800:
                    if ((refresh == 72) && (est_tim2 & EDID_ESTABLISHED_TIMING_800x600_72))
                    {
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 855;
                        fpHSyncEnd =  855+120;
                        fpHTotal = 1040;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 636;
                        fpVSyncEnd = 636+6;
                        fpVTotal = 666;
                        fpPixClk = 5000;    // 50 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        RefreshValid = TRUE;
                    }
                    else if ((refresh == 75) && (est_tim2 & EDID_ESTABLISHED_TIMING_800x600_75))
                    {
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 815;
                        fpHSyncEnd =  815+80;
                        fpHTotal = 1055;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 600;
                        fpVSyncEnd = 600+3;
                        fpVTotal = 624;
                        fpPixClk = 4950;    // 49.5 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        RefreshValid = TRUE;
                    }
                    // if none of the above, use 60 Hz
                    else if ((est_tim1 & EDID_ESTABLISHED_TIMING_800x600_60) 
                        || (est_tim2 & EDID_ESTABLISHED_TIMING_800x600_ANY))
                    {
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 839;
                        fpHSyncEnd =  839+128;
                        fpHTotal = 1055;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 600;
                        fpVSyncEnd = 600+4;
                        fpVTotal = 627;
                        fpPixClk = 4000;    // 40 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        RefreshValid = TRUE; // this may not be correct, but we don't check refresh rate in standard timing
                    }
                    break;
                case 512:
                case 1024:
                    if ((refresh == 70) && (est_tim2 & EDID_ESTABLISHED_TIMING_1024x768_70))
                    {
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1047;
                        fpHSyncEnd = 1047+136;
                        fpHTotal = 1327;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 770;
                        fpVSyncEnd = 770+6;
                        fpVTotal = 805;
                        fpPixClk = 7500;    // 75 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        RefreshValid = TRUE;
                    }
                    else if ((refresh == 75) && (est_tim2 & EDID_ESTABLISHED_TIMING_1024x768_75))
                    {
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1039;
                        fpHSyncEnd = 1039+96;
                        fpHTotal = 1311;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 769;
                        fpVSyncEnd = 769+3;
                        fpVTotal = 799;
                        fpPixClk = 7875;    // 78.75 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        RefreshValid = TRUE;
                    }
                    else if (est_tim2 & EDID_ESTABLISHED_TIMING_1024x768_ANY)
                    {
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1047;
                        fpHSyncEnd = 1047+136;
                        fpHTotal = 1343;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 770;
                        fpVSyncEnd = 770+6;
                        fpVTotal = 805;
                        fpPixClk = 6500;    // 65 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        RefreshValid = TRUE; // this may not be correct, but we don't check refresh rate in standard timing
                    }
                    break;
                case 1280:
                    if ((refresh == 75) && (est_tim2 & EDID_ESTABLISHED_TIMING_1280x1024_75))
                    {
                        fpHActive = 1280;
                        fpHDispEnd = 1279;
                        fpHValidStart = 0;
                        fpHValidEnd = 1279;
                        fpHSyncStart = 1295;
                        fpHSyncEnd = 1295+144;
                        fpHTotal = 1687;
                        fpVActive = 1024;
                        fpVDispEnd = 1023;
                        fpVValidStart = 0;
                        fpVValidEnd = 1024;
                        fpVSyncStart = 1024;
                        fpVSyncEnd = 1024+3;
                        fpVTotal = 1065;
                        fpPixClk = 13500;   // 135 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        RefreshValid = TRUE;
                    }
                    break;
                default:
                    break;
            } //switch
        } // if not PixClk

        if (!RefreshValid) // If not found in detailed or established, try standard timings
        {
            U008 stdTiming1, stdTiming2, i;
            U016 hRes, vRes;

            for (i=0; i<EDID_V1_NUM_STANDARD_TIMINGS; i++) 
            {
                // Translate coded value into H + V resolution
                stdTiming1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_STANDARD_TIMING_1_INDEX + i*2];
                stdTiming2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_STANDARD_TIMING_1_INDEX + i*2 +1];
                hRes = (stdTiming1 + 31) * 8;
                switch (stdTiming2>>6)
                {
                    case 0:
                        vRes = (hRes / 16) * 10;
                        break;
                    case 1:
                        vRes = (hRes / 4) * 3;
                        break;
                    case 2:
                        vRes = (hRes / 5) * 4;
                        break;
                    case 3:
                        vRes = (hRes / 16) * 9;
                        break;
                }
                // Standard timing could also specify any refresh rate from 60-123 Hz. This only handles 60 Hz.
                if (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth == hRes) 
                {
                    switch (hRes) 
                    {
                    case 640:
                        fpHActive =  640;
                        fpHDispEnd = 639;
                        fpHValidStart = 0;
                        fpHValidEnd = 639;
                        fpHSyncStart = 655;
                        fpHSyncEnd =  655+96;
                        fpHTotal = 799;
                        fpVActive = 480;
                        fpVDispEnd = 479;
                        fpVValidStart = 0;
                        fpVValidEnd =  479;
                        fpVSyncStart = 489;
                        fpVSyncEnd = 489+2;
                        fpVTotal = 524;
                        fpPixClk = 2517;    // 25.17 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        break;
                    case 800:
                        fpHActive =  800;
                        fpHDispEnd = 799;
                        fpHValidStart = 0;
                        fpHValidEnd = 799;
                        fpHSyncStart = 839;
                        fpHSyncEnd =  839+128;
                        fpHTotal = 1055;
                        fpVActive = 600;
                        fpVDispEnd = 599;
                        fpVValidStart = 0;
                        fpVValidEnd =  599;
                        fpVSyncStart = 600;
                        fpVSyncEnd = 600+4;
                        fpVTotal = 627;
                        fpPixClk = 4000;    // 40 MHz
                        fpPolarity = VSYNC_POS | HSYNC_POS;
                        break;
                    case 1024:
                        fpHActive = 1024;
                        fpHDispEnd = 1023;
                        fpHValidStart = 0;
                        fpHValidEnd = 1023;
                        fpHSyncStart = 1047;
                        fpHSyncEnd = 1047+136;
                        fpHTotal = 1343;
                        fpVActive = 768;
                        fpVDispEnd = 767;
                        fpVValidStart = 0;
                        fpVValidEnd = 767;
                        fpVSyncStart = 770;
                        fpVSyncEnd = 770+6;
                        fpVTotal = 805;
                        fpPixClk = 6500;    // 65 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        break;
                    case 1280:
                        if (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 960) 
                        {   // GTF
                            fpHActive = 1280;
                            fpHDispEnd = 1279;
                            fpHValidStart = 0;
                            fpHValidEnd = 1279;
                            fpHSyncStart = 1279+80;
                            fpHSyncEnd = 1279+80+136;
                            fpHTotal = 1711;
                            fpVActive = 960;
                            fpVDispEnd = 959;
                            fpVValidStart = 0;
                            fpVValidEnd = 959;
                            fpVSyncStart = 960;
                            fpVSyncEnd = 963;
                            fpVTotal = 993;
                            fpPixClk = 10200;    // 102 MHz
                            fpPolarity = VSYNC_POS | HSYNC_POS;
                        }
                        if (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 1024) 
                        {   // DMT
                            fpHActive = 1280;
                            fpHDispEnd = 1279;
                            fpHValidStart = 0;
                            fpHValidEnd = 1279;
                            fpHSyncStart = 1327;
                            fpHSyncEnd = 1327+112;
                            fpHTotal = 1687;
                            fpVActive = 1024;
                            fpVDispEnd = 1023;
                            fpVValidStart = 0;
                            fpVValidEnd = 1023;
                            fpVSyncStart = 1024;
                            fpVSyncEnd = 1024+3;
                            fpVTotal = 1065;
                            fpPixClk = 10800;    // 108 MHz
                            fpPolarity = VSYNC_POS | HSYNC_POS;
                        }
                        break;
                    case 1600:
                        fpHActive = 1600;
                        fpHDispEnd = 1599;
                        fpHValidStart = 0;
                        fpHValidEnd = 1599;
                        fpHSyncStart = 1599+104;
                        fpHSyncEnd = 1599+104+176;
                        fpHTotal = 2159;
                        fpVActive = 1024;
                        fpVDispEnd = 1023;
                        fpVValidStart = 0;
                        fpVValidEnd = 1023;
                        fpVSyncStart = 1024;
                        fpVSyncEnd = 1024+3;
                        fpVTotal = 1060;
                        fpPixClk = 16000;    // 160 MHz
                        fpPolarity = VSYNC_NEG | HSYNC_NEG;
                        break;
                    }
                }
                if (fpPixClk) // found? break for loop
                    break;
            } // for loop

        }
        if (!fpPixClk) // Did we find a detailed, established, or standard timings for the requested mode?
        {
            // No, did we find any valid timings in the EDID? Then fall back to adapter scaling.
            if (pDev->Dac.fpPixClk) 
            {
                // These values were gotten when we read the Edid. It should be the preferred mode.
                fpHActive = pDev->Dac.fpHActive;
                fpHDispEnd = pDev->Dac.fpHDispEnd;
                fpHValidStart = pDev->Dac.fpHValidStart;
                fpHValidEnd = pDev->Dac.fpHValidEnd;
                fpHSyncStart = pDev->Dac.fpHSyncStart;
                fpHSyncEnd = pDev->Dac.fpHSyncEnd;
                fpHTotal = pDev->Dac.fpHTotal - 1;
                fpVActive = pDev->Dac.fpVActive;
                fpVDispEnd = pDev->Dac.fpVDispEnd;
                fpVValidStart = pDev->Dac.fpVValidStart;
                fpVValidEnd = pDev->Dac.fpVValidEnd;
                fpVSyncStart = pDev->Dac.fpVSyncStart;
                fpVSyncEnd = pDev->Dac.fpVSyncEnd;
                fpVTotal = pDev->Dac.fpVTotal - 1;
                fpPixClk = pDev->Dac.fpPixClk;
                fpPolarity = (pDev->Dac.fpFlags); // assume 4&3=1 (digital), then 2=vsync, 1=hsync
                
                // Use scaling to get requested mode
                // NV10 & NV15 will not scale above 1024, so fall back to centered
                if ((IsNV10(pDev) || IsNV15(pDev)) && pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth > 1024) // line > 1024?
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER, Head);
                else
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _SCALE, Head);   // scaled mode
            }
            else
            {
                // No EDID info: set 640x480. We need valid timing, especially the clock, so we will generate interrupts
                // and notifiers which depend on vblank interrupt will get written.
                fpHActive =  640;
                fpHDispEnd = 639;
                fpHValidStart = 0;
                fpHValidEnd = 639;
                fpHSyncStart = 655;
                fpHSyncEnd =  655+96;
                fpHTotal = 799;
                fpVActive = 480;
                fpVDispEnd = 479;
                fpVValidStart = 0;
                fpVValidEnd =  479;
                fpVSyncStart = 489;
                fpVSyncEnd = 489+2;
                fpVTotal = 524;
                fpPixClk = 2517;    // 25.17 MHz
                fpPolarity = VSYNC_NEG | HSYNC_NEG;
                return RM_ERROR;
            }
        }
    }
    else if ((GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR))
    {
        fpHActive = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
        fpVActive = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

        // Use the FP scaler in the low resolution modes
        if (fpHActive <= 512 && fpVActive <= 384)
        {
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _SCALE, Head);
            // Use the line/clock doubled equivalent (or the nearest resolution)
            // I only have 60 Hz refresh rate.
            switch (fpHActive) 
            {
            case 320:
                fpHActive =  640;
                fpHDispEnd = 639;
                fpHValidStart = 0;
                fpHValidEnd = 639;
                fpHSyncStart = 655;
                fpHSyncEnd =  655+96;
                fpHTotal = 799;
                fpVActive = 480;    // We could add 400 line timing if 320x200 doesn't scale into 640x480 well
                fpVDispEnd = 479;
                fpVValidStart = 0;
                fpVValidEnd =  479;
                fpVSyncStart = 489;
                fpVSyncEnd = 489+2;
                fpVTotal = 524;
                fpPixClk = 2517;    // 25.17 MHz
                fpPolarity = VSYNC_NEG | HSYNC_NEG;
                break;
            case 400:
                fpHActive =  800;
                fpHDispEnd = 799;
                fpHValidStart = 0;
                fpHValidEnd = 799;
                fpHSyncStart = 839;
                fpHSyncEnd =  839+128;
                fpHTotal = 1055;
                fpVActive = 600;
                fpVDispEnd = 599;
                fpVValidStart = 0;
                fpVValidEnd =  599;
                fpVSyncStart = 600;
                fpVSyncEnd = 600+4;
                fpVTotal = 627;
                fpPixClk = 4000;    // 40 MHz
                fpPolarity = VSYNC_POS | HSYNC_POS;
                break;
            case 480:   // We could put 960x720 timing in here, but it should scale up into 512 (1024)
            case 512:
            default:    
                fpHActive = 1024;
                fpHDispEnd = 1023;
                fpHValidStart = 0;
                fpHValidEnd = 1023;
                fpHSyncStart = 1047;
                fpHSyncEnd = 1047+136;
                fpHTotal = 1343;
                fpVActive = 768;
                fpVDispEnd = 767;
                fpVValidStart = 0;
                fpVValidEnd = 767;
                fpVSyncStart = 770;
                fpVSyncEnd = 770+6;
                fpVTotal = 805;
                fpPixClk = 6500;    // 65 MHz
                fpPolarity = VSYNC_NEG | HSYNC_NEG;
                break;
            }
        }
        else
        {
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _NATIVE, Head);

            // These values are gotten from the LUT_CURSOR_DAC class
            fpHActive = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
            fpHDispEnd = fpHActive - 1;
            fpHValidStart = 0;
            fpHValidEnd = fpHDispEnd;
            fpHSyncStart = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart - 1;
            fpHSyncEnd = fpHSyncStart + pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth;
            fpHTotal = pVidLutCurDac->HalObject.Dac[0].TotalWidth - 1;

            fpVActive = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
            // check for scanline doubled modes
            if (pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode)
                fpVActive *= 2;

            fpVDispEnd = fpVActive - 1;
            fpVValidStart = 0;
            fpVValidEnd = fpVDispEnd;
            fpVSyncStart = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart - 1;
            fpVSyncEnd = fpVSyncStart + pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight;
            fpVTotal = pVidLutCurDac->HalObject.Dac[0].TotalHeight - 1;

            fpPixClk = pVidLutCurDac->HalObject.Dac[0].PixelClock;
            // make sure we're not exceeding our max pixclk for this head
            RM_ASSERT((fpPixClk * 10000) <= GETCRTCHALINFO(pDev, Head, PCLKLimit32bpp));

            fpPolarity = ((!pVidLutCurDac->HalObject.Dac[0].Format.VerticalSyncPolarity) << 2) | 
                         ((!pVidLutCurDac->HalObject.Dac[0].Format.HorizontalSyncPolarity) << 1);
        }
    }
    else    // FP not native mode, restore full resolution
    {
        // These values were gotten when we read the Edid.
        fpHActive = pDev->Dac.fpHActive;
        fpHDispEnd = pDev->Dac.fpHDispEnd;
        fpHValidStart = pDev->Dac.fpHValidStart;
        fpHValidEnd = pDev->Dac.fpHValidEnd;
        fpHSyncStart = pDev->Dac.fpHSyncStart;
        fpHSyncEnd = pDev->Dac.fpHSyncEnd;
        fpHTotal = pDev->Dac.fpHTotal - 1;
        fpVActive = pDev->Dac.fpVActive;
        fpVDispEnd = pDev->Dac.fpVDispEnd;
        fpVValidStart = pDev->Dac.fpVValidStart;
        fpVValidEnd = pDev->Dac.fpVValidEnd;
        fpVSyncStart = pDev->Dac.fpVSyncStart;
        fpVSyncEnd = pDev->Dac.fpVSyncEnd;
        fpVTotal = pDev->Dac.fpVTotal - 1;
        fpPixClk = pDev->Dac.fpPixClk;
        fpPolarity = (pDev->Dac.fpFlags); // assume 4&3=1 (digital), then 2=vsync, 1=hsync
        
        // NV10 & NV15 will not scale above 1024, so fall back to centered
        // except in the case of panels which have a max width of 1600, where we
        // can use scaling intended for other modes.
        if (IsNV10(pDev) || IsNV15(pDev)) 
        {
           if (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth > 1024      &&
               !((pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth == 1280 || pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth == 1600) && 
                 (pDev->Dac.HalInfo.fpHMax == 1600))
              )
           {
               DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER, Head);
           }
        }
    }

    // For mobile, see if dithering is needed on the flat panel
    if (pDev->Power.MobileOperation)
    {
        // If this is NV11 B1 or better, on Head 1
        if (IsNV11(pDev) &&
            (pDev->halHwInfo.pMcHalInfo->MaskRevision >= MC_MASK_REVISION_B1) &&
            (Head == 1))
        {
            // 
            // And, we're in a non-scaled (centered/native) FP mode or scaled,
            // but in the native resolution of the FP, and in 32bpp
            //
            if (((FpMode != NV_CFGEX_GET_FLATPANEL_INFO_SCALED) ||
                    ((fpHActive == pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth) &&
                     (fpVActive == pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight))) &&
                    (pVidLutCurDac->HalObject.Dac[0].PixelDepth == 32))
            {
                // enable dithering (kicked off in VBlankUpdateDither)
                pDev->Dac.HalInfo.CrtcInfo[Head].fpMode = NV_CFGEX_GET_FLATPANEL_INFO_CENTERED_DITHER;

                // reset temporal dithering safety counter
                pDev->Dac.CrtcInfo[Head].VBlankTemporalDitherSafetyCounter = 0;
            }
            else 
            {
                // disable dithering
                pDev->Dac.HalInfo.CrtcInfo[Head].fpMode = 0;
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _6B_DITHER, _OFF, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _DITHER_RB, _NORMAL, Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _DITHER_G, _NORMAL,  Head);
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COMPAT, _DITHER_Y, _NORMAL,  Head);
            }
        }
    }

    // Work-around for HW bug: can't set HT lsb's to 00 in 1280 mode.
    if (fpHActive == 1280)
        if (!(fpHTotal & 0x03))
            fpHTotal += 1;  // if x...x00, make it 01
    // We are switching modes, so program the DAC with new timings.
    // If switching between scaled and centered, this isn't necessary, but it won't hurt.
    if (fpPolarity & VSYNC_POS)
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _POS, Head);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _NEG, Head);
    }
    if (fpPolarity & HSYNC_POS)
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _POS, Head);
    }
    else
    {
        DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _NEG, Head);
    }
    // Pixel Clock
#ifdef NV11_PCLK_HACK
    if (fpHActive == 1024)
    {
        fpPixClk = 5000;    // lower pixclk on NV11 for demo. 
    }
#endif

    //
    // NV11 workaround for mobile panels when running low-res modes on hi-res panels.  
    // The panel scaler seems to be causing issues with the LVDS data.
    //
    // Drop the PCLK by 20MHz when running in these configurations.  Only deal with
    // 800 width modes and less on panels greater than 1400 native horizontal and
    // the scaler is enabled.
    //
    // Only happens on HSYNC mode panels (Toshiba does not use these!)
    if ( IsNV11(pDev) && pDev->Power.MobileOperation && (pDev->Power.MobileOperation != 2) )
    {
        if (FpMode == NV_CFGEX_GET_FLATPANEL_INFO_SCALED)
        {
            if ((pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth <= 800) && (fpHActive >= 1400))
            {
                fpPixClk -= 2000;  // drop it by 20MHz (10MHz per LVDS channel)

                // Turn on the flag that says we're dropping the PCLK
                pDev->Dac.DevicesEnabled |= (DAC_LOW_PCLK_ENABLED);
            }
            else
            {
                // Turn off the flag that says we're dropping the PCLK
                pDev->Dac.DevicesEnabled &= ~(DAC_LOW_PCLK_ENABLED);
            }
        }
    }

    spreadEnabled = REG_RD_DRF(_PRAMDAC, _SEL_CLK, _SPREAD_SPECTRUM_VPLL1) || REG_RD_DRF(_PRAMDAC, _SEL_CLK, _SPREAD_SPECTRUM_VPLL2);
    if (pDev->Power.MobileOperation && spreadEnabled)
    {
        //
        // Calculate taking spread into account, so cap M at 6
        //
        // This is currently only being done for mobile systems that use
        // spread spectrum of the fpclk.
        //
        dacCalcMNP_MaxM(pDev, Head, fpPixClk, &M, &N, &P, 6);
    }
    else if (IsNV11(pDev) && (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR) && (Head == 1) && pDev->Dac.ExtDacMaxM)
    {
        //
        // Calculate taking external dac noise into account, so cap M at the new value (received from registry)
        //
        dacCalcMNP_MaxM(pDev, Head, fpPixClk, &M, &N, &P, pDev->Dac.ExtDacMaxM);
    }
    else
        dacCalcMNP(pDev, Head, fpPixClk, &M, &N, &P);


    // VPLL doesn't follow the pattern of addressing by adding a fixed offset. 
    // VPLL2 has an address in the same range (680xxx) as the
    // primary head. This makes the DAC_REG_WR32 macros useless.
    if (Head == 0) 
    {
        REG_WR32(NV_PRAMDAC_VPLL_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
    }
    else
    {
        // Tell DAC to use programmed M,N,P values, then give it M,N,P.
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _MSOURCE, _PROG); 
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG); 
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _NVSOURCE, _PROG); 
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG); 
        REG_WR32(NV_PRAMDAC_VPLL2_COEFF, DRF_NUM(_PRAMDAC, _VPLL_COEFF, _MDIV, M) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _NDIV, N) |
                                        DRF_NUM(_PRAMDAC, _VPLL_COEFF, _PDIV, P));
    }

    //
    // Set Link depending on which head we want to drive fp.
    //
    if (IsNV11(pDev))
    {
        // Some boards have only one link, and that should be connected to the second head
        if (Head == 0)
            FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK1, _SEL_FPCLK1);
        else
            FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK2, _SEL_FPCLK2);

        // Mobile is dual link LVDS, so both links are used
        if (pDev->Power.MobileOperation)
        {
            if (Head == 0)
            {
                // If using Head==0, both links use primary clock
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK1, _SEL_FPCLK1);
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK2, _SEL_FPCLK1);
            }
            else
            {
                // If using Head==1, both links use secondary clock
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK1, _SEL_FPCLK2);
                FLD_WR_DRF_DEF(_PRAMDAC, _SEL_CLK, _IFPCLK2, _SEL_FPCLK2);
            }
        }
    }

    //
    // If an integrated TMDS exists (we can read/write TMDS_CONTROL),
    // set the PLL values there, as well.
    //
    // TMDS access is in the address range of the primary head. (680xxx)
    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);

    cntl32 = DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | NV_PRAMDAC_INDIR_TMDS_PLL1;
    DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, cntl32, Head);

    if (IsNV11(pDev) || DAC_REG_RD32(NV_PRAMDAC_FP_TMDS_CONTROL, Head) == cntl32) // IF TMDS present
    {
        U008 tmds_pll0, tmds_pll1, tmds_pll2;

        // make sure PLL is enabled, or we'll hang
        dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE); 

        if (IsNV15(pDev))
        {
            // TMDS settings

            // Run BIOS TMDS single, link A or link B table
            if ( Head == 0 )
            {
                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_A );
            }
            else
            {
                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_B );
            }

            if ( rmStatus != RM_OK )
            {
                BOOL isMode4 = FALSE;

                // clear error
                rmStatus = RM_OK;

                // Determine PLL values based on pixclk
                if (fpPixClk <= 6400)
                {         // pixclk <= 64MHz
                    tmds_pll0 = 0x31;
                    tmds_pll1 = 0x5F;
                }
                else if (fpPixClk == 6500)
                {  // pixclk == 65MHz
                    tmds_pll0 = 0x31;
                    tmds_pll1 = 0x49;
                }
                else if (fpPixClk <= 8000)
                {  // pixclk <= 80Mhz
                    tmds_pll0 = 0x29;
                    tmds_pll1 = 0x4E;
                }
                else if (fpPixClk <= 10000)
                {  // pixclk <= 100Mhz
                    tmds_pll0 = 0x29;
                    tmds_pll1 = 0x49;
                }
                else
                {                        // pixclk > 100MHz
                    tmds_pll0 = 0x30;
                    tmds_pll1 = 0x4F;
                    isMode4 = TRUE;
                }

                if (isMode4)
                {
                    //
                    // To set TMDS_PLL0 to 0x30, we need to transition through 0x31 first
                    // (setting TMDS_PLL1 both times), with a little delay in between.
                    //
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL0, 0x31);         // set PLL0
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL1, tmds_pll1);    // set PLL1
                    tmrDelay(pDev, 1 * 1000 * 1000);  // 1 ms
                }

                dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL0, tmds_pll0);    // set PLL0
                dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL1, tmds_pll1);    // set PLL1
            }
        }
        else
        {
            // First, check if we're in TMDS or LVDS mode
            // Currently looking at one of the registers
            // TODO: should look at the BIOS tables instead?
            //DAC_REG_WR32(NV_PRAMDAC_FP_TMDS_CONTROL, 
            //             DRF_DEF(_PRAMDAC, _FP_TMDS_CONTROL, _WRITE, _DISABLE) | NV_PRAMDAC_INDIR_TMDS_MODE,
            //             Head);
            //if ((DAC_REG_RD32(NV_PRAMDAC_FP_TMDS_DATA, Head) & 0x1) || pDev->Power.MobileOperation)
            //
            // From what I've found out, there are no LVDS panels that are not Mobile.
            if (pDev->Power.MobileOperation)
            {
                //
                // OK, we're in LVDS mode.
                //
                // Ideally we use the scripts embedded within the BIOS to perform the panel programming.
                // Let's see if the support is in the BIOS for this particular panel.
                //
                //
                // Note the Mac will use the legacy programming until its fcode is updated accordingly
                //

                // script programming only needs to be run if
                // A. We've changed the PCLK
                // B. Or we're powered off.
                // For mobile panels (which are currenly LVDS only), we never change the PCLK on head 1
                // So, only if we're in an off state, should we run the scripts
                // check if the panel is off
                //if((REG_RD32(NV_PCRTC_GPIO_EXT) & 0x33) == 0x00)
                // The old way was to use the GPIO pins to determine off/on status
                // The new way uses the SW variable, pDev->Dac.DevicesEnabled
                if((pDev->Dac.DevicesEnabled & DAC_PANEL_POWER_ENABLED) != DAC_PANEL_POWER_ENABLED)
                {
#ifndef MACOS
                    U008 panelFlags = 0;
                    U032 timeHI, timeLO;
    
                    // Try to run manufacturers script (i.e. BIOS revision >= 0x14)
                    if(DevinitGetManufacturerInfo(pDev) == RM_OK)
                    {
                      // Test if we need to reprogram the links
                      if(pDev->Dac.ManufacturerProperties.Flags & MANUFACTURER_RESET_REQUIRED)
                      {
                        rmStatus = DevinitRunManufacturerScript(pDev, MSCRIPT_LVDS_RESET_SCRIPT);
                      }
                    }
                    else // BIOS is < revision 0x14
                    {
                        rmStatus = DevinitGetFlatPanelFlags( pDev, pDev->Dac.PanelStrap, &panelFlags );
    
                        // We need to first power down if we're not already powered down.
                        // dacPowerOffMobilePanel(pDev, Head);
                        // We should never have to power down the panel since we can't get here unless we're powered down!
                        
                        
                        //  clear the screen: This is needed since the Old Non-Toshiba Mobile VBIOSes
                        // will turn on the screen with the Uber-script.  So we should make sure that
                        // the screen is clear before we turn on the panel.
                        if(pDev->Power.MobileOperation != 2)
                        {
                            U032 page, size, i;  // for clearing the screen

                            page = pDev->Framebuffer.HalInfo.Start[pDev->Framebuffer.Current] / 4;
                            size = (pDev->Dac.HalInfo.Depth / 8) * pDev->Framebuffer.HalInfo.HorizDisplayWidth * pDev->Framebuffer.HalInfo.VertDisplayWidth / 4;
                            for (i = 0; i < size; i++)
                            {
                                fbAddr->Reg032[page + i] = 0;
                            }
                        }
    
                        // We have to add the smart delay here since the old scripts didn't have the required delay
                        // Now incurr the penalty for stalling between power on and off
                        tmrGetCurrentTime(pDev, &timeHI, &timeLO);
                        if((pDev->Dac.PanelOffTimestampHI > timeHI) ||
                           ((pDev->Dac.PanelOffTimestampHI == timeHI) &&
                            (pDev->Dac.PanelOffTimestampLO > timeLO)) )
                        {
                            // Delay the difference of the times.  Unsigned math shouldn't matter if delay is under 2^31 nanoseconds.
                            tmrDelay(pDev, (pDev->Dac.PanelOffTimestampLO - timeLO));
                        }
        
                        //
                        // Attempt to process the scripts.  Note if this fails the code will fall through
                        // and use the legacy programming.
                        //
                        if ( rmStatus == RM_OK )
                        {
                            if ( ( panelFlags & 0x01 ) == 0 )
                            {
                                // Flag is 0
                                // Run BIOS LVDS single table
                                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_LVDS_SINGLE_B );
                            }
                            else
                            {
                                // Flag is 1
                                // Run BIOS LVDS dual table
                                rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_LVDS_DUAL );
                            }
                        }

                        // Toshiba's uberscript actually does not turn the power on to the panel and backlight
                        // But Dell and everyone else should.  This is only for Mobile platforms which is checked above.
                        if(pDev->Power.MobileOperation != 2)
                        {
                            pDev->Dac.DevicesEnabled |= DAC_PANEL_ENABLED;
  
                            // We also need to turn off the power pending flag.
                            // If we leave this flag on, then we'll end up not allowing the dacBacklightOff script
                            // to run in dacMobileDisplayNotifyBegin(), which will show corruption during the
                            // modeset - Bad driver, bad, bad driver!
                            pDev->Power.Flags &= ~(DAC_POWER_PENDING);
                        }

                    } // end of BIOS is < revision 0x14
        
                    if ( rmStatus == RM_OK )
                    {
                        // Head selection does not occur in BIOS, so we do this manually
                        // after the other stuff is done.
                        if (Head == 0)
                        {
                            U008 Data;
                            // read register NV_PRAMDAC_INDIR_TMDS_MODE in LINK B
                            Data = dacTMDSRead(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE );
                            // Or with 0x0C to say get from alternate source
                            // write register back to Link B
                            dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, (U008)( Data | 0x0C ));
                        }
                        else
                        {
                            U008 Data;
                            // read register NV_PRAMDAC_INDIR_TMDS_MODE in LINK A
                            Data = dacTMDSRead(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_MODE );
                            // Or with 0x0C to say get from alternate source
                            // write register back to Link A
                            dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_MODE, (U008)( Data | 0x0C ));
                        }
    
                        //
                        // Until the BIOS contains scripts for enabling/disabling the panel
                        // power and backlight, we will still be forced to use separate
                        // routines (dacPowerOnMobilePanel, dacPowerOffMobilePanel) seen
                        // below.  Since those routines don't know yet the chip revision
                        // or BIOS script they're programming, we need to track if we
                        // programmed up the panel using the BIOS script or by using
                        // our legacy code (below).
                        //
                        // As soon as all the BIOS's are updated and we don't have to worry
                        // about legacy programming (yeah right), then we can take out this
                        // flag.
                        //
                        // This flag will be checked in the PowerOn/PowerOff routines to know
                        // what programming to perform.
                        //
                        pDev->Dac.BIOSPanelProgramming = 1;
                    }
                    else  // Failing side of internal script processing, so go to legacy programming
#endif  // MACOS
                    {
                        //
                        // Legacy programming flag -- to be picked up by PowerOn/PowerOff routines.
                        //
                        // Note this will always be the case for mac until the above is turned back
                        // on again for macos.
                        //
                        pDev->Dac.BIOSPanelProgramming = 0;
    
                        // We failed to process the table, so do it the hardcoded way
    
                        if (!IsNV11(pDev))
                        {
                            // We only know how to do NV11
                            return RM_ERROR;
                        }
    
                        // Clear the error
                        rmStatus = RM_OK;
    
                        // Setup Link0
                        dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL0, 0x32);
                        dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0xD4);
                        //
                        //dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);
                        //dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);
                        //
                        dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_IDLY, 0x00);
                        if (Head == 0)
                            dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_MODE, 0x81);
                        else
                            dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_MODE, 0x8D);
                        dacTMDSWrite(pDev, 0x0, NV_PRAMDAC_INDIR_TMDS_LVDS, 0x6E);
    
                        // Setup Link1
                        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, 0x1101111, 0x1);
                        tmrDelay(pDev, 0x400000);
    
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL0, 0x32);
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0xD4);
                        //
                        //dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);
                        //dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);
                        //
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_IDLY, 0x00);
                        if (Head == 0)
                            dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, 0x8D);
                        else
                            dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_MODE, 0x81);
                        dacTMDSWrite(pDev, 0x1, NV_PRAMDAC_INDIR_TMDS_LVDS, 0x2E);
    
                        // Setup both Links to run at 1/2 the fpclk frequency
                        //
                        // Don't do this for Toshiba which is single link.  We need this info
                        // from either the BIOS (when it takes over the programming) or from
                        // the EDID.  For now, watch for Toshiba flags
                        //
                        if (pDev->Power.MobileOperation != 2)
                        {
                            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _FPCLK_RATIO, _DB2, 0);
                            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _FPCLK_RATIO, _DB2, 1);
                        }
                    } // end of legacy programming
                }  // end of if power is off (Don't run scripts if power is already on.)
            }
            else // failing side of if pDev->Power.MobileOperation
            {
                // TMDS settings

                // Run BIOS TMDS single, link A or link B table
                if ( Head == 0 )
                {
                    rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_A );
                }
                else
                {
                    rmStatus = DevinitProcessBip3InternalTMDS( pDev, fpPixClk, TMDSIT_TMDS_SINGLE_B );
                }

                if (rmStatus != RM_OK && IsNV11(pDev))
                {
                    // We failed to process the table, so do it the hardcoded way
                    // We only know how to do NV11.

                    // Determine PLL values based on pixclk
                    if (fpPixClk <= 6500) {         // pixclk <= 65MHz
#ifdef MACOS
                        // on the iMac we need to adjust PLL0 timing to reduce
                        //  emissions (Apple's request)
                        //  Test to detect iMac is a bit hokey, but will go away when we switch to
                        //  using the tables anyway...
                        //  NOTE we already know we are NV11 from above.
                        
                        if (pDev->halHwInfo.pMcHalInfo->MaskRevision < MC_MASK_REVISION_B1)
                            tmds_pll0 = 0xB2;
                        else
                        {
                            tmds_pll0 = 0x81;
                            if (REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_SUB_VENDOR) == NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS)
                                tmds_pll0 = 0x01;
                        }
#else
                        tmds_pll0 = 0xB2;
#endif
                        tmds_pll1 = 0xF7;
                        tmds_pll2 = 0x00;
                    } else {                        // pixclk > 65MHz
                        tmds_pll0 = 0x32;
                        tmds_pll1 = 0x6F;
                        tmds_pll2 = 0x20;
                    }

                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL0, tmds_pll0);    // set PLL0
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL1, tmds_pll1);    // set PLL1
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_PLL2, tmds_pll2);    // set PLL2

                    // Link0 gets data from CRTC0; Link1 gets data from CRTC1, so set "normal" for DINSEL
                    dacTMDSWrite(pDev, Head, NV_PRAMDAC_INDIR_TMDS_MODE, 0x80);    // get data from CRTCx
                }
            }
        }
    }


    if (IsNV11(pDev) && (FpMode == NV_CFGEX_GET_FLATPANEL_INFO_SCALED))
    {
        U032    HSyncOffset;
        
        // For NV11, there is a clock synchronization problem when scaling:
        // At H display end, the CRTC clock must be held off until sync start, but if the period between end of active display
        // and sync start is too small, there is not enough time to synchronize, so we will reduce HCRTC, which is the synchronization
        // point.
        HSyncOffset = fpHSyncStart - fpHActive;    // find period between display end and sync start
        if (HSyncOffset < 28) 
        {
            fpHActive = fpHActive - (28 - HSyncOffset); // reduce HCRTC by an appropriate amount
        }

        //
        // Workaround to get reduced blanking on Dell's QXGA panels
        // REMOVE REMOVE REMOVE as soon as we have a robust alternative worked
        // out.  The EDID is correct in showing a 2048 horizontal total, but we
        // need to drive 2000 (0x7D0).
        //
        // Let me quote the hw engineer:
        //    We could use 0x7D0 for all QXGA panels, so far
        //    there are no issues with this settings for all QXGA timings.
        //
        if ((fpHActive == 0x800) && pDev->Power.MobileOperation)
            fpHActive = 0x7D0;

    }

    data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, (data32 & 0xfff0ffff) | 0x00020000, Head);
    tmrDelay(pDev, 0x400000);
    
    DAC_REG_WR32(NV_PRAMDAC_FP_HCRTC, fpHActive, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HDISPLAY_END, fpHDispEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_START, fpHValidStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HVALID_END, fpHValidEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_START, fpHSyncStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HSYNC_END, fpHSyncEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_HTOTAL, fpHTotal, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VCRTC, fpVActive, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VDISPLAY_END, fpVDispEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_START, fpVValidStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_END, fpVValidEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_START, fpVSyncStart, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VSYNC_END, fpVSyncEnd, Head);
    DAC_REG_WR32(NV_PRAMDAC_FP_VTOTAL, fpVTotal, Head);
    
    DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);

    // Special case for flat panels with horizontal max 1600, 
    // overrides HW scaling for 1280->1600  in pre-nv11 boards
    if (  pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth == 1280
       && pDev->Dac.HalInfo.fpHMax == 1600
       && FpMode == NV_CFGEX_GET_FLATPANEL_INFO_SCALED
       && !IsNV11orBetter(pDev)
       ) 
    {   
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_1,  0x00001ccd, Head);
    }
    // NV10/15 seem to be missing table entries for scaling 720 modes
    // Write the scale factor 
    if (IsNV10(pDev) || IsNV15(pDev)) 
    {
        if (pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth == 720)
        {
            data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_1, Head);  // This should be 0
            switch (fpHActive) // res we are scaling into
            {
                case 1024:
                    data32 |= 0x1b3f;
                    break;
                case 1280:
                    data32 |= 0x18ff;
                    break;
                case 1600:
                    data32 |= 0x1732;
                    break;
            }
            // Check vertical 576 (480 will scale properly)
            // (These numbers were gotten by taking the factors in the manual for 512 and 600 and proportioning to 576)
            if (pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight == 576)
            {
                switch (fpVActive) 
                {
                case 768:
                    data32 |= 0x1bfe0000;
                    break;
                case 1024:
                    data32 |= 0x18fe0000;
                    break;
                case 1200:
                    data32 |= 0x17ac0000;
                    break;
                }
            }
            DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_1, data32, Head);
        }
    }

    tmrDelay(pDev, 0x400000);

    // since the flat panel is now setup, turn off the reset flag
    pDev->Dac.DevicesEnabled &=  ~(DAC_PANEL_CLK_RESET);

    return RM_OK;
}


// TODOMK: What is this for?  Can it be replaced with BIOS table usage?
RM_STATUS dacPowerOnMobilePanel
(
    PHWINFO pDev,
    U032    Head
)
{
    U008 lock;
    U032 gpio_ext45;
    U032 timeHI, timeLO;
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"dacPowerOnMobilePanel on Head");
    DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO,Head);
    
    //
    // If we're already on, don't wait around here with the delays
    //
    // also make sure that this is mobile operation before skipping the good bits
    if(pDev->Power.MobileOperation && (((pDev->Dac.DevicesEnabled & DAC_PANEL_ENABLED) == DAC_PANEL_ENABLED) || (pDev->Power.Flags & DAC_POWER_PENDING)))
        return (RM_OK);

    // Retain GPIO_EXT_4 and GPIO_EXT_5 settings
    gpio_ext45  = REG_RD32(NV_PCRTC_GPIO_EXT);
    gpio_ext45 &= 0xFF00;

    // This delay is for non-Toshiba mobiles.
    // Toshiba flat panels are unaffected from this entire function.
    // We do not have direct control over the panel or backlight power for Toshiba.
    // We can call DPMS Sleep/Wake to turn off the backlight.
    // DeviceControlBegin/End BIOS calls also affect the power to the panel.
    // So this delay is unnecessary for Toshiba.
    if(pDev->Power.MobileOperation != 2)
    {
        // Now incurr the penalty for stalling between power on and off
        tmrGetCurrentTime(pDev, &timeHI, &timeLO);
        if((pDev->Dac.PanelOffTimestampHI > timeHI) ||
           ((pDev->Dac.PanelOffTimestampHI == timeHI) &&
            (pDev->Dac.PanelOffTimestampLO > timeLO)) )
        {
            // Delay the difference of the times.  Unsigned math shouldn't matter.
            tmrDelay(pDev, (pDev->Dac.PanelOffTimestampLO - timeLO));
        }
    }

    // First check to see if we can run the manufacturer scripts
    if(DevinitGetManufacturerInfo(pDev) == RM_OK)
    {
      // Let's power up the Manufacturer way
      DevinitRunManufacturerScript(pDev, MSCRIPT_PANEL_ON);
      
      // 100ms delay? why? it fixes the problem when cycling the hotkeys around to LCD
      // then using TwinView to turn on Clone mode (LCD->LCD+TV).  Without the delay,
      // this switch takes 9-12 seconds, because i2c fails.  With the delay, i2c works!
      if(pDev->Power.MobileOperation == 2)
        tmrDelay(pDev, 100000000);
    }
    //
    // Second check to see if we used the BIOS scripts to program the panel.
    // If so, we should use the BIOS scripts to turn on the panel as well,
    // but until that is complete in the BIOS, just perform the simplest
    // GPIO programming
    //
    else if (pDev->Dac.BIOSPanelProgramming == 1)
    {
        //
        // TOSHIBA doesn't like this new programming.  Until I get a Toshiba to 
        // debug...
        //
        // Remember Toshiba really handles their own power sequencing, so skipping
        // this should not be an issue.
        //
        //LPL: removed due to problems caused during display switching
//        if (pDev->Power.MobileOperation == 2)
//            return (RM_OK);

        // Disable breaker, this turns on the panel PLL
        REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x10);

        // Toshiba does not use the GPIO_EXT to enable/disable bl or power.
        if(pDev->Power.MobileOperation != 2)
          pDev->Dac.DevicesEnabled |= (DAC_PANEL_POWER_ENABLED);

        // 220ms delay between power and bl enable
        tmrDelay(pDev, 220000000);

        // Power on the BL so we can see
        REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x11);
    }
    else
    {
        if(pDev->Power.MobileOperation)
        {
            //
            // LEGACY PROGRAMMING
            //
            // make sure PLL is enabled, or we'll hang
            dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);   // FP on to access TMDS

            // Enable Head2 GPIO
            lock = UnlockCRTC(pDev, 1);
            CRTC_WR(NV_CIO_GPIO23_INDEX, 0x00, 1);
            RestoreLock(pDev, 1, lock);

            // Disable panel I/O
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0

            // Wait a bit
            tmrDelay(pDev, 1000000);

            // Enable GPIO3 to a zero, set breaker
            //REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x00);
            FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_2_OUTPUT,_0);
            FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_3_OUTPUT,0);
            FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_2_ENABLE,_ENABLE);
            FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_3_ENABLE,_ENABLE);

            // Wait a bit
            tmrDelay(pDev, 1000000);

            // Disable breaker, this turns on the panel PLL
            //REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x10);
            FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_3_OUTPUT,1);

            // Wait a lot
            tmrDelay(pDev, 8000000);
        
            // Let DivBy7 go
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x38);    // set PLL2
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x38);    // set PLL2
        
            // Let DivBy10 go
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);    // set PLL1
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);    // set PLL1
        
            // Wait a bit
            tmrDelay(pDev, 1000000);
        
            // Reset DivBy10
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0xD4);    // set PLL1
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0xD4);    // set PLL1
        
            // Wait a bit
            tmrDelay(pDev, 1000000);
        
            // Reset DivBy7
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);    // set PLL2
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x3A);    // set PLL2
        
            // Wait a bit
            tmrDelay(pDev, 1000000);
        
            // Let DivBy7 go again -- this leaves us in LVDS
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);    // set PLL1
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL1, 0x94);    // set PLL1
        
            // Wait a moderate bit
            tmrDelay(pDev, 2000000);
            
            // Power on the BL so we can see
            //
            //REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x11);
            FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_2_ENABLE,_ENABLE);
            FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_2_OUTPUT,1);
        }
        else
        {   
            if(IsNV11(pDev))
            {
                if(osReadRegistryBoolean(pDev,NULL,"backlight-control"))
                {
                    //do P11 specifics
                    FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_2_OUTPUT,1);
                    FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_2_ENABLE,_ENABLE);
                }
                else
                {
                    //do NV11-P40 specifics
                    FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_3_OUTPUT,1);
                    FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_3_ENABLE,_ENABLE);
                }
            }

        
            //do NV20 specifics (on Mac, our flat panel enable is non standard)
            if(IsNV20(pDev))
            {
                REG_WR32(0x600818,REG_RD32(0x600818)|0x11);
            }
            
            //repair GPIO5 according to the inverter needs
            dacSetExternalInverterCurrentMode(pDev);
        }
    }

    // Toshiba does not use the GPIO_EXT to enable/disable bl or power.
    if(pDev->Power.MobileOperation != 2)
      pDev->Dac.DevicesEnabled |= DAC_PANEL_ENABLED;

        return (RM_OK);
}

RM_STATUS dacPowerOffMobilePanel
(
    PHWINFO pDev,
    U032    Head
)
{
 
    U008 lock;
    U032 gpio_ext45;
    U032 PanelOffOnDelay = 500;  // 500 ms is the default
    
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"dacPowerOffMobilePanel on Head");
    DBG_PRINT_VALUE(DEBUGLEVEL_TRACEINFO,Head);
    
    //
    // If we're already off, don't wait around here with the delays
    //
    //also make sure this is really mobile operation, not a Mac, not PowerEvent before skipping all the good bits
    // if ((REG_RD32(NV_PCRTC_GPIO_EXT) & 0x33) == 0x00)
    if(pDev->Power.MobileOperation && ((pDev->Dac.DevicesEnabled & DAC_PANEL_ENABLED) == DAC_NOT_ENABLED || (pDev->Power.Flags & DAC_POWER_PENDING)))
        return (RM_OK);


    if (MC_POWER_LEVEL_0 != pDev->Power.State) {
        return (RM_OK);
        }
               

    if(DevinitGetManufacturerInfo(pDev) == RM_OK)
    {
      // Let's power down the Manufacturer way
      DevinitRunManufacturerScript(pDev, MSCRIPT_PANEL_OFF);

      PanelOffOnDelay = pDev->Dac.ManufacturerProperties.PanelOffOnDelay;
    }
    //
    // Second, check to see if we used the BIOS scripts to program the panel.
    // If so, we should use the BIOS scripts to turn on the panel as well,
    // but until that is complete in the BIOS, just perform the simplest
    // GPIO programming
    //
    else if (pDev->Dac.BIOSPanelProgramming == 1)
    {
        //
        // TOSHIBA doesn't like this new programming.  Until I get a Toshiba to 
        // debug...
        //
        // Remember Toshiba really handles their own power sequencing, so skipping
        // this should not be an issue.
        //
        //LPL: removed due to problems caused during display switching
//        if (pDev->Power.MobileOperation == 2)
//            return (RM_OK);

        // Read the register for the panel backlight and power
        gpio_ext45  = REG_RD32(NV_PCRTC_GPIO_EXT);

        // Only disable the backlight if it's actually on!
        // Currently we're forcing the SW flag on in mcPowerState 
        // (Returning to 0 from level 2).  If the panel power is
        // actually off, then writing ((gpio_ext45 & 0xFF00) | 0x10)
        // will turn the panel on.
        REG_WR32(NV_PCRTC_GPIO_EXT, (gpio_ext45 & 0xFFF0));

        // Toshiba does not use the GPIO_EXT to enable/disable bl or power.
        if(pDev->Power.MobileOperation != 2)
          pDev->Dac.DevicesEnabled &= ~(DAC_PANEL_BACKLIGHT_ENABLED);
        
        // 20 ms delay between bl off and power off?
        // According to the Panel Timing Specs worksheet, 20 ms is the minimum
        tmrDelay(pDev, 20000000);
    
        // disable panel power    
        REG_WR32(NV_PCRTC_GPIO_EXT, (gpio_ext45 & 0xFF00));
    }
    else
    {
        //
        // LEGACY PROGRAMMING
        //
        if(pDev->Power.MobileOperation)
        {
            // Enable Head2 GPIO
            lock = UnlockCRTC(pDev, 1);
            CRTC_WR(NV_CIO_GPIO23_INDEX, 0x00, 1);
            RestoreLock(pDev, 1, lock);
        
            // make sure PLL is enabled, or we'll hang
            dacWriteLinkPLL(pDev, 0, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);     // FP on to access TMDS
            dacWriteLinkPLL(pDev, 1, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);
        
            // BL disable
            //REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x10);
            FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_2_ENABLE,_ENABLE);
            FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_2_OUTPUT,0);
        
            // Disable panel I/O
            dacTMDSWrite(pDev, 0, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0
            dacTMDSWrite(pDev, 1, NV_PRAMDAC_INDIR_TMDS_PLL2, 0x52);    // set PLL0
        
            tmrDelay(pDev, 1000000);
        
            // disable panel power
            //REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x00);
            FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_3_ENABLE,_ENABLE);
            FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_3_OUTPUT,0);
        }
        else
        {
            if(IsNV11(pDev))
            {
                if(osReadRegistryBoolean(pDev,NULL,"backlight-control"))
                {
                    //Disable panel backlight only on P11
                    FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_2_ENABLE,_ENABLE);
                    FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_2_OUTPUT,0);
                }
                else
                {
                    //disable GPIO3 which is wired to the panel power control on P40
                    FLD_WR_DRF_DEF(_PCRTC,_GPIO_EXT,_3_ENABLE,_ENABLE);
                    FLD_WR_DRF_NUM(_PCRTC,_GPIO_EXT,_3_OUTPUT,0);
                }
            }
            
            //if nv20 (arg!)
            //do NV20 specifics (on Mac, our flat panel enable is non standard)
            //will go away with virtualized GPIOs
            if(IsNV20(pDev))
            {
                REG_WR32(0x600818,REG_RD32(0x600818)&~0x11);
            }
        }
    }
        
        //satisfy GPIO5 reqs.
    dacSetExternalInverterCurrentMode(pDev);

    // Start smart time delay and turn off SW flag for non-Toshiba mobiles
    // Toshiba flat panels are unaffected from this entire function.
    // We do not have direct control over the panel or backlight power for Toshiba.
    // We can call DPMS Sleep/Wake to turn off the backlight.
    // DeviceControlBegin/End BIOS calls also affect the power to the panel.
    // So this delay is unnecessary for Toshiba.
    if(pDev->Power.MobileOperation != 2)
    {
        //
        // Need to abide by minimum 500ms between panel off and back on again, so
        // enforce it here while the panel is black
        // tmrDelay(pDev, 500000000);
        // 500 ms was the old minimum.  This is now changed by using the PanelOffOnDelay.

        // Store the current time, and then stall on the panel on call
        tmrGetCurrentTime(pDev, 
            &(pDev->Dac.PanelOffTimestampHI), &(pDev->Dac.PanelOffTimestampLO));
            
        // Change the PanelOffOnDelay from ms to ns
        PanelOffOnDelay *= 1000000;
        
        // Go ahead and add the delay to the timestamp
        // Check for carry condition
        if((pDev->Dac.PanelOffTimestampLO + PanelOffOnDelay) < pDev->Dac.PanelOffTimestampLO)
        {
            pDev->Dac.PanelOffTimestampHI++;
        }
        pDev->Dac.PanelOffTimestampLO += PanelOffOnDelay;
    
        // Toshiba does not use the GPIO_EXT to enable/disable bl or power.
        pDev->Dac.DevicesEnabled &= ~(DAC_PANEL_ENABLED);
    }

    return (RM_OK);
}

RM_STATUS dacBacklightOnMobilePanel(PHWINFO pDev)
{
    RM_STATUS status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"dacBacklightOnMobilePanel");

    // Only do this if Mobile and the backlight is off
    if ((pDev->Power.MobileOperation) && 
        (!(pDev->Dac.DevicesEnabled & DAC_PANEL_BACKLIGHT_ENABLED)))
    {
        // Toshiba doesn't turn off their backlight with Manufacturer scripts or GPIO pins
        if(pDev->Power.MobileOperation != 2)
        {
            // Try manufacturer scripts first
            // Currently the backlight on script is missing an INIT_DONE.
            // and it turns the backlight on then off.  So for now, just
            // do it the old fashioned way.
            if(0)//DevinitGetManufacturerInfo(pDev) == RM_OK)
            {
                // Let's turn the backlight on the Manufacturer way
                status = DevinitRunManufacturerScript(pDev, MSCRIPT_BACKLIGHT_ON);
            }
            else
            {
                U032 gpio_ext45;
    
                // Retain GPIO_EXT_4 and GPIO_EXT_5 settings
                gpio_ext45  = REG_RD32(NV_PCRTC_GPIO_EXT);
                gpio_ext45 &= 0xFFF0;
      
                // Power on the BL so we can see
                REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45 | 0x01);

                status = RM_OK;
            }
        }
        else
        {
            // Turn on the backlight after enabling the DACs
            U032    EAX, EBX, ECX, EDX;
            EAX = 0x4F10;
            EBX = 0x0001; //wake up
            EDX = 0x0000;
            ECX = 0x0000;
            status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
        }
        
        if(status != RM_OK)
        {
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: ERROR!!! dacBacklightOnMobilePanel failed.  SW State is invalid.\n");
        }

        pDev->Dac.DevicesEnabled |= (DAC_PANEL_BACKLIGHT_ENABLED);
    }
    return status;
}

RM_STATUS dacBacklightOffMobilePanel(PHWINFO pDev)
{
    RM_STATUS status = RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"dacBacklightOffMobilePanel");

    // Only do this if Mobile and the backlight is on
    if ((pDev->Power.MobileOperation) && 
        (pDev->Dac.DevicesEnabled & DAC_PANEL_BACKLIGHT_ENABLED))
    { 
      if(pDev->Power.MobileOperation != 2)
      {
          if(DevinitGetManufacturerInfo(pDev) == RM_OK)
          {
              // Let's turn the backlight off the Manufacturer way
              status = DevinitRunManufacturerScript(pDev, MSCRIPT_BACKLIGHT_OFF);
          }
          else
          {
              U032 gpio_ext45;
    
              // Retain GPIO_EXT_4 and GPIO_EXT_5 settings
              gpio_ext45  = REG_RD32(NV_PCRTC_GPIO_EXT);
              gpio_ext45 &= 0xFFF0;
    
              // Power off the Backlight
              REG_WR32(NV_PCRTC_GPIO_EXT, gpio_ext45);

              status = RM_OK;
          }
      }
      else  // Toshiba case
      {
          // Turn off the backlight
          U032    EAX, EBX, ECX, EDX;
          EAX = 0x4F10;
          EBX = 0x0401; //sleep
          EDX = 0x0000;
          ECX = 0x0000;
          status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
      }
        
      if(status != RM_OK)
      {
          DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: ERROR!!! dacBacklightOffMobilePanel failed.  SW State is invalid.\n");
      }
          
      pDev->Dac.DevicesEnabled &= ~(DAC_PANEL_BACKLIGHT_ENABLED);
    }
    return status;
}

void dacZeroPWMController(PHWINFO pDev)
{
        REG_WR32(NV_PBUS_PWM,0);
}

void dacSetPWMController(PHWINFO pDev)
{
        REG_WR32(NV_PBUS_PWM,pDev->Dac.fpPWMRegisterContents);
}

void dacSetExternalInverterCurrentMode(PHWINFO pDev)
{
    U032 nvPcrtcGpioExtVal;
    
    if (pDev->Power.MobileOperation)
        return;    // mobile uses GPIO_EXT_5 for controlling spread spectrum

    nvPcrtcGpioExtVal=REG_RD32(NV_PCRTC_GPIO_EXT);
    
    //uninit'd variable check
    switch(pDev->Dac.fpExternalInverterCurrentMode)
    {
        case 0:
        case 1:
            break;
        default:
            pDev->Dac.fpExternalInverterCurrentMode=0;
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"Possible uninitialized fpExternalInverterCurrentMode!.\n");
    }
    
    if(pDev->Dac.fpExternalInverterCurrentMode)
    {       
        //set the bit
        nvPcrtcGpioExtVal|=BIT(12);
        
        //clear the GPIO line disable bit
        nvPcrtcGpioExtVal&=~BIT(13);
    }
    else
    {
        //set the output line to zero
        nvPcrtcGpioExtVal&=~BIT(12);
        
        //clear the GPIO line disable bit
        nvPcrtcGpioExtVal&=~BIT(13);
    }
    
    REG_WR32(NV_PCRTC_GPIO_EXT,nvPcrtcGpioExtVal);
}

void dacGetExternalInverterCurrentMode(PHWINFO pDev)
{
    U032 nvPcrtcGpioExtVal;
    
    if (pDev->Power.MobileOperation)
        return;    // mobile uses GPIO_EXT_5 for controlling spread spectrum

    nvPcrtcGpioExtVal=REG_RD32(NV_PCRTC_GPIO_EXT);
    
    if(BIT(14)&nvPcrtcGpioExtVal)
    {
        pDev->Dac.fpExternalInverterCurrentMode=1;
    }
    else
    {
        pDev->Dac.fpExternalInverterCurrentMode=0;
    }
}

void dacGetPWMController(PHWINFO pDev)
{
        U032 NvPbusPwmHighValue,ControllerRegisterValue,FpDynamicRange;
    U032 NvPbusPwmPeriodValue;
    U032 MinPeriodValue,RelativePeriod;
        
        //we need to init the variable for the flat panel brightness
    if(!pDev->Dac.fpRelativeBrightness)
    {
        ControllerRegisterValue=REG_RD32(NV_PBUS_PWM);
        NvPbusPwmHighValue=(ControllerRegisterValue>>16)&0x7fff;
        NvPbusPwmPeriodValue=ControllerRegisterValue&0x7fff;
        
        //a kludge - 40% to 100%
        MinPeriodValue=((NvPbusPwmPeriodValue*40)+50)/100;
        
        FpDynamicRange=NvPbusPwmPeriodValue-MinPeriodValue;
        
        RelativePeriod=NvPbusPwmHighValue-MinPeriodValue;
        
        pDev->Dac.fpRelativeBrightness=(((RelativePeriod*10000)/(FpDynamicRange*10000/255))*10+5)/10;
        
        //store this raw PWM value also into the DAC.fpPWMRegisterContents save/restore var.
        pDev->Dac.fpPWMRegisterContents=ControllerRegisterValue;
    }
}

RM_STATUS  dacSetFlatPanelBrightness
(
    PHWINFO pDev,
    U032 Head,
    U032 Brightness,
    U032 Frequency,
    U032 MaxPercent,
    U032 MinPercent,
    BOOL ControllerIsOn,
    BOOL InverterCurrentMode
)
{
    U032 TicksNeededForClock;
    U032 TicksNeededForHigh;
    
    //clip if necessary
    if(Brightness>255)
    {
            Brightness=255;
    }
    
    //enable PWM output
    if(ControllerIsOn)
    {
            FLD_WR_DRF_DEF(_PBUS,_PWM,_EN,_ENABLED);
    }
    else
    {
            FLD_WR_DRF_DEF(_PBUS,_PWM,_EN,_DISABLED);
    }
    
    TicksNeededForClock = GetTicksForFrequency(Frequency);
    TicksNeededForHigh = GetRequiredTickCount(Frequency,MaxPercent,MinPercent,Brightness);

    //program the chip
    FLD_WR_DRF_NUM(_PBUS,_PWM,_HI,TicksNeededForHigh);
    FLD_WR_DRF_NUM(_PBUS,_PWM,_PERIOD,TicksNeededForClock);
    
    //store multiplier for get
    pDev->Dac.fpRelativeBrightness=Brightness;
    
    //set current mode
    pDev->Dac.fpExternalInverterCurrentMode=(U032)InverterCurrentMode;
    dacSetExternalInverterCurrentMode(pDev);
    
    TicksNeededForClock=GetTicksForFrequency(Frequency);
    TicksNeededForHigh=GetRequiredTickCount(Frequency,MaxPercent,MinPercent,Brightness);

    //store multiplier for get
    pDev->Dac.fpRelativeBrightness=Brightness;
        
    //store the raw PWM value in case someone triggers an on without an off
    pDev->Dac.fpPWMRegisterContents = REG_RD32(NV_PBUS_PWM);
                    
    return RM_OK;
}

RM_STATUS  dacGetFlatPanelBrightness(PHWINFO pDev, U032 Head, U032 * Brightness,BOOL * ControllerIsOn, BOOL * InverterCurrentMode)
{
        U032 NvPbusPwmEnable;
        
        //read register
        NvPbusPwmEnable=REG_RD_DRF(_PBUS,_PWM,_EN);
        
        //retrieve last brightness setting
        *Brightness=pDev->Dac.fpRelativeBrightness;
        
        //check the status of the control bit
        if(NvPbusPwmEnable)
        {
                *ControllerIsOn=TRUE;
        }
        else
        {
                *ControllerIsOn=FALSE;
        }
        
        dacGetExternalInverterCurrentMode(pDev);
        *InverterCurrentMode=(BOOL)pDev->Dac.fpExternalInverterCurrentMode;

        return RM_OK;
}

U032 GetTicksForFrequency(U032 Frequency)
{
        //this replaced alot of code - overcomplication on my part
        return 33333333/Frequency;
}

U032 GetPortionOfTotalSizeBasedOnPercentage(U032 TotalSize,U032 Percentage)
{

        //do calculation, round up
        return (((TotalSize*Percentage)+50)/100);
}

U032 DetermineFrequencyFromTickCount(U032 NumTicks)
{
        return ((333333330/NumTicks)+5)/10;
}

U032 GetRequiredTickCount(U032 Frequency,U032 MaxPercent,U032 MinPercent,U032 BaseMultiplier)
{
        U032 TicksInClockPeriod;
        U032 MaxTicks;
        U032 MinTicks;
        U032 DynamicRange;
        U032 PreliminaryTickCount;

        TicksInClockPeriod = GetTicksForFrequency(Frequency);
        MaxTicks=GetPortionOfTotalSizeBasedOnPercentage(TicksInClockPeriod,MaxPercent);
        MinTicks=GetPortionOfTotalSizeBasedOnPercentage(TicksInClockPeriod,MinPercent);

        DynamicRange=MaxTicks-MinTicks;

        PreliminaryTickCount=MinTicks+(((((DynamicRange*10)/255)+5)/10)*BaseMultiplier);
        
        if (PreliminaryTickCount>MaxTicks)
        {
                //if rounding produces a number too large, clip it
                PreliminaryTickCount=MaxTicks;
        }
        
        return PreliminaryTickCount;
}

BOOL dacIsFlatPanelOn(PHWINFO pDev,U032 Head)
{
    if((pDev->Dac.DevicesEnabled & DAC_PANEL_POWER_ENABLED)&&pDev->Power.MobileOperation)
      return TRUE;

    if(REG_RD_DRF(_PCRTC,_GPIO_EXT,_3_INPUT))
    {
        //technically, based on policy, this should be a check for GPIO4 up, but this is only the case on P11
        //this interface is insuffecient to determine that.
        return TRUE;
    }
    
    //this must suffice until the HAL function for GPIO arrives
    //reg 0x600818 is NV_PCRTC_GPIO, BIT(24) is GPIO1 input
    if((IsNV20(pDev))&&(REG_RD32(0x600818)&BIT(24)))
    {
        return TRUE;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dacstate.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Manager ******************************\
*                                                                           *
* Module: DACSTATE.C                                                        *
*   The DAC state is changed in this module.                                *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <dac.h>
#include <os.h>
#include <vga.h>
#include "nvhw.h"

VOID enableCursor(PHWINFO, U032);
VOID disableCursor(PHWINFO, U032);

//
// Change DAC hardware state.
//
RM_STATUS stateDac
(
    PHWINFO pDev,
    U032    msg
)
{
    U032 i;

    switch (msg)
    {
        case STATE_UPDATE:
            //
            // Only the Dpm Level and APLL are changed here.  All other
            // updates occur in the VBlank interrupt handler.
            //
            if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_VPLL)
            {
                dacCalcPLL(pDev);
                pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_VPLL;
            }

            // NOTE: MCLK and NVCLK updates are done in mcState.c:stateMc
            
            if (pDev->Framebuffer.UpdateFlags & UPDATE_HWINFO_DISPLAY_PARAMS)
            {

                //
                // Program the new DAC settings
                //    
                // NT NOW calls dacSetMode to do the modesets !!! (Miniport no longer sets the mode)
                // However, the NT driver does NOT use the class interface to do the modeset.
                // Instead it calls RmSetMode.

                dacSetMode(pDev, 0);

#ifdef NTRM
                osSetVideoMode(pDev);
#endif                
                //
                // Perform any necessary OS-specific function
                // after the change to the DAC
                //
                osStateDacEx(pDev, msg);

                pDev->Framebuffer.UpdateFlags &= ~UPDATE_HWINFO_DISPLAY_PARAMS;
            }
            
            if (!pDev->Vga.Enabled)
            {
                for (i = 0; i < MAX_CRTCS; i++)
                {
                    enableCursor(pDev, i);
                    pDev->Dac.CrtcInfo[i].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE;	// force an update from image in nvInfo
                }
            }
            else
            {
                for (i = 0; i < MAX_CRTCS; i++)
                    disableCursor(pDev, i);
            }
                
            break;
        case STATE_LOAD:
            //
            // Initialize DAC cursor emulation.
            //
#ifdef NTRM
            for (i = 0; i < MAX_CRTCS; i++)
                pDev->Dac.CrtcInfo[i].CursorType = DAC_CURSOR_TWO_COLOR_XOR;
#else
// Don't turn on cursor until asked to by Windows.
//            pDev->Dac.CursorType      = DAC_CURSOR_TWO_COLOR_XOR;
#endif

            //
            // Make sure we enable the backend video overlay, if req'd
            //
            // KJK: Move this to the new video engine code
            //
            /*
            //
            // New DDraw protocol will enable the overlay on its own
            //
            if ((pDev->Video.Enabled == 1) && !pDev->Vga.Enabled)
                FLD_WR_DRF_DEF(_PVIDEO, _OVERLAY, _VIDEO, _ON);
            */                

            if (!pDev->Vga.Enabled)
            {
#ifdef NTRM
                osSetVideoMode(pDev);
#endif            
                //
                // Perform any necessary OS-specific function
                // after the change to the DAC
                //
                osStateDacEx(pDev, msg);
            
                //
                // Load cursor on boot head only.
                //
                
                enableCursor(pDev, pDev->Dac.HalInfo.InitialBootHead);
                pDev->Dac.CrtcInfo[pDev->Dac.HalInfo.InitialBootHead].UpdateFlags |= UPDATE_HWINFO_DAC_CURSOR_IMAGE;	// force an update from image in nvInfo
                
                // enable vblank interrupt
                DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, 0);
                DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_EN_0, _VBLANK, _ENABLED, 0);
                pDev->Dac.CrtcInfo[0].StateFlags |= DAC_CRTCINFO_VBLANK_ENABLED;
            }
			else
            {
                for (i = 0; i < MAX_CRTCS; i++)
                    disableCursor(pDev, i);
            }
            break;
        case STATE_UNLOAD:
            //
            // Disable the cursor.
            //
            for (i = 0; i < MAX_CRTCS; i++)
            {
                disableCursor(pDev, i);
                
                DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, i);
                DAC_REG_WR32(NV_PCRTC_INTR_EN_0, 0, i);
                pDev->Dac.CrtcInfo[i].StateFlags &= ~DAC_CRTCINFO_VBLANK_ENABLED;
            }
            break;
        case STATE_INIT:
            initDac(pDev);
            break;
        case STATE_DESTROY:
            break;
    }
    return (RM_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dacmode.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* DAC Mode Control ***************************\
*                                                                           *
* Module: DACMODE.C                                                         *
*   The DAC mode control management is updated here.                        *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>
#include <nvcm.h>
#include <bios.h>   //For hotkey defs.  Can remove once those are put in nv_ref.h

extern char strDevNodeRM[];
extern char strLastExtDevice[];
extern char strCurWinDevices[];

//------------------------------------------------------------------------
// First 16 colors for mode 13h (compatible R'G'B'RGB)
//
U008 CompatColors[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
                        0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F};
                         
//------------------------------------------------------------------------
// Gray values for next 16 (6 bits of intensity)
//
U008 GrayColors[] = {0x00, 0x05, 0x08, 0x0B, 0x0E, 0x11, 0x14, 0x18,
                      0x1C, 0x20, 0x24, 0x28, 0x2D, 0x32, 0x38, 0x3F};
                                                                              
//------------------------------------------------------------------------
// Fixup values for DAC color registers after summing to gray shades
//
U008 FixupColors[] = {0x00, 0x05, 0x11, 0x1C, 0x08, 0x0B, 0x14, 0x28,
                       0x0E, 0x18, 0x2D, 0x32, 0x20, 0x24, 0x38, 0x3F};
                                                                       
//------------------------------------------------------------------------
// 9 groups of five intensities are used to generate the next 216 colors.
// Each group is used to generate 24 colors by walking around a "color
// triangle" with eight colors per side.
//
U008 IntenseTable[] =
{
    0x00, 0x10, 0x1F, 0x2F, 0x3F,
    0x1F, 0x27, 0x2F, 0x37, 0x3F,
    0x2D, 0x31, 0x36, 0x3A, 0x3F,
                                
    0x00, 0x07, 0x0E, 0x15, 0x1C,
    0x0E, 0x11, 0x15, 0x18, 0x1C,
    0x14, 0x16, 0x18, 0x1A, 0x1C,
                                
    0x00, 0x04, 0x08, 0x0C, 0x10,
    0x08, 0x0A, 0x0C, 0x0E, 0x10,
    0x0B, 0x0C, 0x0D, 0x0F, 0x10
};                              

//
// KJK I suspect this could be removed (or at least shortened) since we only used
//      one of the mode settings
//

//------------------------------------------------------------------------
//  Basic VGA mode default settings. This setup is used initially in all 
//  mode sets.
//
VGATBL   VGATable =
{
    // U008   columns;
    // U008   rows;
    // U008   char_height;
    // U016   RegenLenght;
    // SEQ    seq_regs;              // SR1-4
    // U008   PT_Misc;               // Misc Register
    // CRTC   crtc_regs;             // CR0-18
    // U008   PT_ATC[20];            // Attribute Controller
    // GR     gr_regs;               // GR0-8

    // Basic CRTC Table for Packed Pixel Graphics Modes.
     0x50, 0x1D, 0x10,
     0xFFFF,
    {0x01, 0x0F, 0x00, 0x0E},               // Seq
     0xEB,
    {0x5F, 0x4F, 0x4F, 0x83, 0x53, 0x9F,    // CR0-18
     0x0B, 0x3E, 0x00, 0x40, 0x00, 0x00,
     0x00, 0x00, 0x00, 0x00, 0xEA, 0x0C,
     0xDF, 0x50, 0x00, 0xDF, 0x0C, 0xE3,
     0xFF},
    {0x00, 0x01, 0x02, 0x03, 0x04, 0x05,    // Attr
     0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B,
     0x0C, 0x0D, 0x0E, 0x0F, 0x01, 0x00,
     0x0F, 0x00},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x40,    // GR
     0x05, 0x0F, 0xFF}
};    

/*************************** Helper functions *******************************/
//
//       dacWriteColor - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
static VOID dacWriteColor(PHWINFO pDev, U032 head, U008 colorval)
{
    U008   component;          // color component 4=red/2=green/1=blue
    U008   color;              // Color component to write
    
    for (component = 0x04; component; component >>= 1)
    {
        // Color?
        if (colorval & component)
            color = 0x2A;               // Add color
        else
            color = 0;                  // No color on this component
        
        // Intensity?
        if (colorval & (component << 3))
            color += 0x15;
    
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, color, head);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, color);
    }
}        
        
//
//       dacWriteColor2 - Writes one color value (three bytes) to the video DAC
//               R(analog) = R * 2Ah + R' * 15h
//               G(analog) = G * 2Ah + G' * 15h
//               B(analog) = B * 2Ah + B' * 15h
//
static VOID dacWriteColor2(PHWINFO pDev, U032 head, U016 red, U016 green, U016 blue, U016 tblidx)
{
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red], head);
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green], head);
    DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue], head);

    ////WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+red]);
    ////WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+green]);
    ////WritePriv08(NV_USER_DAC_PALETTE_DATA, IntenseTable[tblidx+blue]);
}

//
//       dacLoadColorDACTable - Load the DAC for the 16-color modes
//
static VOID dacLoadColorDACTable(PHWINFO pDev, U032 head)
{
    U008  i;
    
    // Select the DAC address
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00, head);
    ////WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
    
    // Do the first 64 locations
    for (i = 0; i < 64; i++)
        dacWriteColor(pDev, head, i);
        
}
    
//
//       dacLoadColor256DAC - Load the DAC for the 256-color modes
//
static VOID dacLoadColor256DAC(PHWINFO pDev, U032 head)
{
    U016  i;
    U016  red;
    U016  green;
    U016  blue;
    
    // Select the DAC address
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00, head);
    ////WritePriv08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00);
    
    //--------------------------------------------------------------------
    // The first 16 colors are the compatible colors (i.e. 0,1,2,3,4,5,14,
    // 7,38,39,3A,3B,3C,3D,3E,3F).
    //
    for (i = 0; i < 16; i++)
        dacWriteColor(pDev, head, CompatColors[i]);
    
    //--------------------------------------------------------------------
    // The next 16 give various intensities of gray (0,5,8,B,E,11,14,18,
    // 1C,20,24,28,2D,32,38,3F).
    //
    for (i = 0; i < 16; i++)
    {
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i], head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i], head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i], head);
        
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, (U008)GrayColors[i]);
    }                                                
        
    //--------------------------------------------------------------------
    // The next 216 registers give a variety of colors.
    //
    
    red = 0;
    green = 0;
    blue = 4;

    for (i = 0; i < 9; i++)
    {                       
    
        // I know these could probably be a function, but for now...
        // (this is getting tedious).
        
        // Traverse(blue, red);
        do
        {
            // To loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            red++;                                          
        } while (red < blue);
        
        do
        {
            // From loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            blue--;
        } while (blue);
        
        // Traverse(red, green);
        do
        {
            // To loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            green++;
        } while (green < red);
                         
        do
        {
            // From loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            red--;
        } while (red);
                 
            
        // Traverse(green, blue);
        do
        {
            // To loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            blue++;
        } while (blue < green);
                         
        do
        {
            // From loop
            dacWriteColor2(pDev, head, red, green, blue, (U016)(i * 5));
            green--;
        } while (green);
    }                
             
    //-----------------------------------------------------------------------
    // The last 8 colors are black.
    //
    //               +---+-- 8 blanks * 3 locations (r/g/b)
    for (i = 0; i < (8 * 3); i++)
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, 0x00, head);
        ////WritePriv08(NV_USER_DAC_PALETTE_DATA, 0x00);
}

//
//       dacLoadIdentityDAC - Load the DAC with a gamma ramp
//
static VOID dacLoadIdentityDAC(PHWINFO pDev, U032 head)
{
    U016  i;
    
    // Select the DAC address
    DAC_REG_WR08(NV_USER_DAC_WRITE_MODE_ADDRESS, 0x00, head);
                                                  
    for (i = 0; i < 256; i++)
    {           
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)i, head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)i, head);
        DAC_REG_WR08(NV_USER_DAC_PALETTE_DATA, (U008)i, head);
        
    }                                     
}

//
// Program the default video palette
//
static VOID dacLoadPalette
(
    PHWINFO pDev,
    U032    Head,
    U032    PixelDepth
)
{
    U008 i;
    U008 *pal = (U008 *)&(VGATable.PT_ATC); // default packed pixel palette
    volatile U008 scratch8;
    
    scratch8 = REG_RD08(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    
    for (i = 0; i < 20; i++)
    {
        ATR_WR(i, *pal++, Head);               
        
        ////WritePriv08(NV_PRMCIO_ARX, i);      // Select AR
        ////WritePriv08(NV_PRMCIO_ARX, *pal++); // Write color data
    }
                                                
    scratch8 = REG_RD08(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);        // Reset ATC FlipFlop
    
//    DAC_WR08(NV_PRMCIO_ARX, 0x14);   // Select AR14
//    DAC_WR08(NV_PRMCIO_ARX, 0x00);   // Zero it!
    ATR_WR(0x14, 0, Head);                 // Write 0 to AR14
    DAC_REG_WR08(NV_USER_DAC_PIXEL_MASK, 0xFF, Head);      // Write DAC Mask

    ////WritePriv08(NV_PRMCIO_ARX, 0x14);   // Select AR14
    ////WritePriv08(NV_PRMCIO_ARX, 0x00);   // Zero it!
    ////WritePriv08(NV_USER_DAC_PIXEL_MASK, 0xFF);      // Write DAC Mask

    switch(PixelDepth)
    {
        case    4:          // 4bpp - Planar -- CAN'T HAPPEN IN WINDOWS DRIVER
            dacLoadColorDACTable(pDev, Head);
            break;

        case    8:          // 8bpp - Packed
            dacLoadColor256DAC(pDev, Head);
            break;

        case    16:         // 16bpp - Packed
        case    15:         // 16bpp - Packed
        case    24:
        case    32:
        default:
            dacLoadIdentityDAC(pDev, Head);
            break;
    }
}

static VOID dacLoadIndexRange(PHWINFO pDev, U032 addr, U008 st_idx, U008 count, U008 *regs)
{
    U016  i;
    U016  wv;
    
    // Program <addr> register from <st_idx> to <st_idx + count>, using data from <regs>
    for (i = 0; i < count; i++)
    {               
        wv = *regs++;
        wv <<= 8;               // Put data in high half
        wv |= st_idx++;         // Get index and increment it
        WriteIndexed(addr, wv);
    }               
}                                  



//
// Program the default sequencer/graphics controller parameters
// PRMVIO for head 2 is accessed by setting CR44.
//
static VOID dacProgramSeq
(
    PHWINFO pDev,
    U032    Head
)
{
    U016  wv;
    
    // Load Sequencer and Misc. Output
    WriteIndexed(NV_PRMVIO_SRX, 0x0100);         // Sync Reset
    
    REG_WR08(NV_PRMVIO_MISC__WRITE, VGATable.PT_Misc);
                                                   
    // Load Sequencers, beginning at SR1, load 4 SR's (SR1-4), from the mode table
    dacLoadIndexRange(pDev, NV_PRMVIO_SRX, 1, sizeof(SEQ), (U008 *)&(VGATable.seq_regs));
                                            
    WriteIndexed(NV_PRMVIO_SRX, 0x0300);         // End Sync Reset
                                  
    // Load GDC's
    // Load GR, beginning at GR0, for all GR's (GR0-8), from the mode table
    dacLoadIndexRange(pDev, NV_PRMVIO_GRX, 0, sizeof(GR), (U008 *)&(VGATable.gr_regs));

    //
    // Common area of OEMSetRegs()
    //
    
    // User select MNP for VPLL, enable CPU access to FB, enable CGA I/O space.
    REG_WR08(NV_PRMVIO_MISC__WRITE, 0x2B);
                                                                  
    wv = 0x01;
    wv <<= 8;
    wv |= 0x01;
    WriteIndexed(NV_PRMVIO_SRX, wv); // Write SR01
    
}

//
// Program the CRTC timing (plus PRAMDAC_GENERAL_CONTROL and MISC OUTPUT sync polarities)
//
VOID dacProgramCRTC
(
    PHWINFO pDev,
    U032    Head,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac,
    U032    HorizontalVisible,        // in pixels
    U032    HorizontalBlankStart,     // in pixels
    U032    HorizontalRetraceStart,   // in pixels
    U032    HorizontalRetraceEnd,     // in pixels
    U032    HorizontalBlankEnd,       // in pixels
    U032    HorizontalTotal,          // in pixels
    U032    VerticalVisible,          // in lines
    U032    VerticalBlankStart,       // in lines
    U032    VerticalRetraceStart,     // in lines
    U032    VerticalRetraceEnd,       // in lines
    U032    VerticalBlankEnd,         // in lines
    U032    VerticalTotal,            // in lines
    U032    PixelDepth,
    U032    PixelClock,
    U032    HorizontalSyncPolarity,
    U032    VerticalSyncPolarity,
    U032    DoubleScannedMode
)
{
    U032 logicalwidth;
    U032 ramDacControl;
    U008 val08;
    U016 LC;

    // Here is how these timing values map to nv registers.
    // 
    // HorizontalTotal[8]           -> cr2D[0]  (# of characters - 5)
    // HorizontalTotal[7:0]         -> cr0[7:0] (# of characters - 5)
    // HorizontalVisible[8]         -> cr2D[1]  (in characters - 1)
    // HorizontalVisible[7:0]       -> cr1[7:0] (in characters - 1)
    // HorizontalBlankStart[8]      -> cr2D[2]  (in characters - 1)
    // HorizontalBlankStart[7:0]    -> cr2[7:0] (in characters - 1)
    // HorizontalBlankEnd[6]        -> cr25[4]
    // HorizontalBlankEnd[5]        -> cr5[7]
    // HorizontalBlankEnd[4:0]      -> cr3[4:0]
    // HorizontalRetraceStart[8]    -> cr2D[3]  (in characters + 1)
    // HorizontalRetraceStart[7:0]  -> cr4[7:0] (in characters + 1)
    // HorizontalRetraceEnd         -> cr5[4:0] (RetraceStart + pulseWidth = value programmed in this register)
    // VerticalVisible[10]          -> cr25[1]
    // VerticalVisible[9]           -> cr7[6]
    // VerticalVisible[8]           -> cr7[1]
    // VerticalVisible[7:0]         -> cr12[7:0]
    // VerticalBlankStart[10]       -> cr25[3]
    // VerticalBlankStart[9]        -> cr9[5]
    // VerticalBlankStart[8]        -> cr7[3]
    // VerticalBlankStart[7:0]      -> cr15[7:0]
    // VerticalRetraceStart[10]     -> cr25[2]
    // VerticalRetraceStart[9]      -> cr7[7]
    // VerticalRetraceStart[8]      -> cr7[2]
    // VerticalRetraceStart[7:0]    -> cr10[7:0]
    // VerticalRetraceEnd           -> cr11[3:0] (RetraceStart + pulseWidth = value programmed in this register)
    // VerticalBlankEnd             -> cr16
    // VerticalTotal[10]            -> cr25[0]
    // VerticalTotal[9]             -> cr7[5]
    // VerticalTotal[8]             -> cr7[0]
    // VerticalTotal[7:0]           -> cr6[7:0] (#of scanlines - 2)
    // PixelDepth                   -> cr13 (logical display width)
    //                              -> NV_PRAMDAC_GENERAL_CONTROL
    //                              -> cr28[1:0]
    // PixelClock                   -> NV_PRAMDAC_VPLL_COEFF
    // HorizontalSyncPolarity       -> NV_PRMVIO_MISC__WRITE[6]
    // VerticalSyncPolarity         -> NV_PRMVIO_MISC__WRITE[7]
    // DoubleScannedMode            -> cr9[7]
    //

    // Program up the basic registers first
    //
    
    //
    // Although the VGA spec is not clear on this, there is a single implicit line delay in the VRS and VRE
    // signals, so preadjust these values.
    //
    VerticalRetraceStart--;
    VerticalRetraceEnd--;
    
    // Line compare register is used to split the screen in half. We don't support this feature.
    // So the Line Compare register value is always 0x3ff.
    LC = 0x3ff;

    if (DoubleScannedMode)
    {
        // The verticalVisible and verticalBlankStart need to be doubled. 
        // The rest of the vertical timing modes are already doubled in the table.
        VerticalVisible *= 2;
        VerticalBlankStart *= 2;
    }

    //
    // CR0 (Horizontal Total) 
    //  Total number of horizontal characters in a scan line - 5
    //  Maximum horizontal resolution is 260 * 8 * (0.8), where (0.8) is visible %
    //
    CRTC_WR(NV_CIO_CR_HDT_INDEX, (U008)(HorizontalTotal >> 3) - 5, Head);
    
    //
    // CR1 (Horizontal Display End)
    //  Total number of displayed characters in a scan line - 1
    //
    CRTC_WR(NV_CIO_CR_HDE_INDEX, (U008)(HorizontalVisible >> 3) - 1, Head);
                   
    //
    // CR2 (Horizontal Blanking Start)
    //  Location where the horizontal blanking will start (in characters)
    //
    CRTC_WR(NV_CIO_CR_HBS_INDEX, (U008)((HorizontalBlankStart >> 3) - 1), Head);                   
        
    //
    // CR3 (Horizontal Blanking End)
    //  [7:7] CR (must be 1)
    //  [6:5] Display skew control (should be 0)
    //  [4:0] least significant 5 bits of Horizontal blanking end value (in characters).
    //
    CRTC_WR(NV_CIO_CR_HBE_INDEX, (U008)(((HorizontalBlankEnd >> 3) - 1) & 0x1F) | BIT(7), Head);
                   
    //
    // CR4 (Horizontal Retrace Start)
    //  Character position where the horizontal Retrace becomes active
    //
    CRTC_WR(NV_CIO_CR_HRS_INDEX, (U008)(HorizontalRetraceStart >> 3) + 1, Head);
                   
    //
    // CR5 (Horizontal Retrace End)
    //  [7:7] Bit6 of HBE (CR3)
    //  [6:5] Display skew control (should be 0)
    //  [4:0] Location of the end of the horizontal retrace period (in characters)
    //
    CRTC_WR(NV_CIO_CR_HRE_INDEX, ((U008)(((HorizontalRetraceEnd >> 3) + 1) & 0x1f))
                               | ((((HorizontalBlankEnd >> 3) - 1) & BIT(5)) ? BIT(7) : 0), Head);

    //
    // CR6 (Vertical Total)
    //  Total number of vertical scan lines on the monitor - 2
    //
    CRTC_WR(NV_CIO_CR_VDT_INDEX, (U008)((VerticalTotal - 2) & 0xFF), Head);
                   
    //
    // CR7 (Overflow Register)
    //  [7:7] Bit9 of VRS (CR10)
    //  [6:6] Bit9 of VDE (CR12)
    //  [5:5] Bit9 of VTR (CR6)
    //  [4:4] Bit8 of LC (CR18) 
    //  [3:3] Bit8 of VBS (CR15)
    //  [2:2] Bit8 of VRS (CR10)
    //  [1:1] Bit8 of VDE (CR12)
    //  [0:0] Bit8 of VTR (CR6)
    //
    CRTC_WR(NV_CIO_CR_OVL_INDEX, ((VerticalRetraceStart & BIT(9))     ? BIT(7) : 0x00)
                               | (((VerticalVisible - 1) & BIT(9))    ? BIT(6) : 0x00) 
                               | (((VerticalTotal - 2) & BIT(9))      ? BIT(5) : 0x00)
                               | ((LC & BIT(8))                       ? BIT(4) : 0x00)
                               | (((VerticalBlankStart - 1) & BIT(8)) ? BIT(3) : 0x00)
                               | ((VerticalRetraceStart & BIT(8))     ? BIT(2) : 0x00)
                               | (((VerticalVisible - 1) & BIT(8))    ? BIT(1) : 0x00)
                               | (((VerticalTotal - 2) & BIT(8))      ? BIT(0) : 0x00), Head);
                   
    //
    // CR8 (Screen A preset row scan)
    //  Should be set to 0 for us.
    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0, Head);

    //
    // CR9 (Character Cell Height register)
    //  [7:7] Scan double mode
    //  [6:6] Bit9 of LC (CR18) 
    //  [5:5] Bit9 of VBS (CR15)
    //  [4:0] Scan lines per character row - 1
    //
    CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, ((DoubleScannedMode)                 ? BIT(7) : 0x00)
                                   | ((LC & BIT(9))                       ? BIT(6) : 0x00)
                                   | (((VerticalBlankStart - 1) & BIT(9)) ? BIT(5) : 0x00), Head);
                 
    if (pDev->pStereoParams &&
       (pDev->pStereoParams->Flags & STEREOCFG_STEREOACTIVATED))
    {
        //The video start address is about to change. We want to turn off stereo as soon as possible
        pDev->pStereoParams->Flags &= ~STEREOCFG_STEREOACTIVATED;
    }            

    //
    // CR0C/CR0D (Start Address)
    //
    /*
    //this should be extracted from the HalInfo structure, not assumed to be zero
    CRTC_WR(NV_CIO_CR_SA_HI_INDEX, 0, Head);                 
    CRTC_WR(NV_CIO_CR_SA_LO_INDEX, 0, Head);
    */
    //program start address through HAL layer function
    dacProgramVideoStart(pDev,Head,pDev->Framebuffer.HalInfo.Start[Head],pVidLutCurDac->Image[0].Pitch);                
                 
    //
    // CR10 (Vertical Retrace Start)
    //  Line position of the vertical Retrace start
    //
    CRTC_WR(NV_CIO_CR_VRS_INDEX, (U008)(VerticalRetraceStart & 0xFF), Head);
                   
    //
    // CR11 (Vertical Retrace End)
    //  [7:7] WriteProtect for CR0-7
    //  [6:6] Reserved (Bandwidth)
    //  [5:5] Vertical Interrupts (0)
    //  [4:4] Clear Vertical Interrupt (0)
    //  [3:0] Vertical Retrace End Width
    //
    CRTC_WR(NV_CIO_CR_VRE_INDEX, (U008)(VerticalRetraceEnd & 0x0f), Head); 
                               
    //
    // CR12 (Vertical Display End)
    //  Total number of displayed lines - 1
    //
    CRTC_WR(NV_CIO_CR_VDE_INDEX, (U008)((VerticalVisible - 1) & 0xFF), Head);
    
    //
    // CR13 (Logical Display Width)
    //  Display Pitch
    //  The value written to CR13/CR19 is the number 8-byte chunks
    //
    logicalwidth = pVidLutCurDac->Image[0].Pitch >> 3;
    CRTC_WR(NV_CIO_CR_OFFSET_INDEX, logicalwidth & 0xFF, Head);
    
    //
    // CR14 (Underline Location)
    //  Double Word mode
    //  Bit 6 is set in some VGA modes to change CRTC addressing
    //
    CRTC_WR(NV_CIO_CR_ULINE_INDEX, 0, Head);
    
    //
    // CR14 (Underline Location)
    //  Double Word mode
    //  Bit 6 is set in some VGA modes to change CRTC addressing into framebuffer
    //
    CRTC_WR(NV_CIO_CR_ULINE_INDEX, 0, Head);
    
    //
    // CR15 (Vertical Blank Start)
    //  Scan line value where the vertical blanking begins
    //
    CRTC_WR(NV_CIO_CR_VBS_INDEX, (U008)((VerticalBlankStart - 1) & 0xFF), Head);
    
    //
    // CR16 (Vertical Blank End)
    //  Scan line value where the vertical blanking Ends
    //
    CRTC_WR(NV_CIO_CR_VBE_INDEX, (U008)((VerticalBlankEnd - 1) & 0xFF), Head);

    //
    // CR17 (Mode register)
    //  bit 7 - retrace enable, bits 1,0 - memory addressing
    //  bit 6 - byte/word addressing -- non-VGA modes always use byte addressing
    CRTC_RD(NV_CIO_CR_MODE_INDEX, val08, Head);
    CRTC_WR(NV_CIO_CR_MODE_INDEX, val08 | BIT(7) | BIT(6) | BIT(1) | BIT(0), Head);

    //
    // CR18 (Line Compare Register)
    //  Bits 7:0 of the line compare value
    //  This is useful only when we want to split the screen. We just program this to 0x3ff
    //
    CRTC_WR(NV_CIO_CR_LCOMP_INDEX, (U008)(LC & 0xFF), Head);

    //
    // CR19 (Repaint control register 0)
    //  [7:5] Bits 10:8 of CRTC Offset register (CR13)
    //
    CRTC_RD(NV_CIO_CRE_RPC0_INDEX, val08, Head);
    val08 = val08 & 0x1F;
    CRTC_WR(NV_CIO_CRE_RPC0_INDEX, (U008)(((logicalwidth & 0x700) >> 8) << 5) | val08, Head);

    //
    // CR1a (Repaint control register 1)
    //  [2] large screen bit. 
    //  NOTE: The manual says bit 2 should be set to 1 for modes < 1280x1024 and 
    //        0 for modes >= 1280x1024. However, that is not correct according to Peter Tong.
    //        It should be set to 0 for all non-vga modes (CR28).
    //          Safer to follow the original meaning of this bit.
    //  The rest of the bits are constant for all modes.
    //
    CRTC_RD(NV_CIO_CRE_RPC1_INDEX, val08, Head);        // grab the current sync status
    val08 = val08 & 0xC0;
    CRTC_WR(NV_CIO_CRE_RPC1_INDEX, ((VerticalVisible < 1024) && (HorizontalVisible < 1280)) ? (0x3c | val08) : (0x38 | val08), Head);

    //
    // CR1c (Enhancement Register)
    //  This is a constant 0x1c for us.
    if (IsNV11(pDev) || IsNV1A(pDev)) {
        CRTC_WR(NV_CIO_CRE_ENH_INDEX, 0x3c, Head);
    } else {
        CRTC_WR(NV_CIO_CRE_ENH_INDEX, 0x1c, Head);
    }

    // Cr25 (Overflow register)
    //  [5:5] Bit 11 of CRTC offset register (this is 0)
    //  [4:4] Bit 6 of Horizontal Blanking End 
    //  [3:3] Bit 10 of Vertical Blank Start
    //  [2:2] Bit 10 of Vertical Retrace Start
    //  [1:1] Bit 10 of Vertical Display End
    //  [0:0] Bit 10 of Vertical Total
    CRTC_WR(NV_CIO_CRE_LSR_INDEX, ((((HorizontalBlankEnd >> 3) - 1) & BIT(6)) ? BIT(4) : 0x00)
                                | (((VerticalBlankStart - 1) & BIT(10))       ? BIT(3) : 0x00)
                                | ((VerticalRetraceStart & BIT(10))           ? BIT(2) : 0x00)
                                | (((VerticalVisible - 1) & BIT(10))          ? BIT(1) : 0x00) 
                                | (((VerticalTotal - 2) & BIT(10))            ? BIT(0) : 0x00), Head);

    // 
    // CR28 (Pixel Format Register)
    //  [1:0] Pixel depth encoded as:
    //        0 - VGA
    //        1 - 8bpp
    //        2 - 16bpp
    //        3 - 32bpp

    // Also set PRAMDAC_GENERAL_CONTROL register. ALT_MODE field depends on the pixel depth. The rest
    // of the fields are the same for all pixel depths.
    
    ramDacControl = DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PIXMIX,      _ON) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _VGA_STATE,   _SEL) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BLK_PEDSTL,  _OFF) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _TERMINATION, _37OHM) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _BPC,         _8BITS) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _DAC_SLEEP,   _DIS) |
                    DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _PALETTE_CLK, _EN);
        
    switch (PixelDepth)
    {
        case 8:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _NOTSEL);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_8BPP, Head);    
            break;                
        
        case 15:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _15);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_16BPP, Head);    
            break;                
        
        case 16:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _16);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_16BPP, Head);    
            break;                
        
        case 24:
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _24);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_32BPP, Head);    
            break;                
        
        case 32:        
            ramDacControl |= DRF_DEF(_PRAMDAC, _GENERAL_CONTROL, _ALT_MODE, _30);
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, NV_CIO_CRE_PIXEL_FORMAT_32BPP, Head);    
            break;                
    } // switch on pixel depth       

    DAC_REG_WR32(NV_PRAMDAC_GENERAL_CONTROL, ramDacControl, Head);

    // 
    // cr2D (Horizontal Extra Bits Register)
    //  [5] Bit 23 of start address field (This is 0 for us)
    //  [4] Bit 8 of interlace half field start (This is 0 for us)
    //  [3] Bit 8 of Horizontal Retrace Start
    //  [2] Bit 8 of Horizontal Blank Start
    //  [1] Bit 8 of Horizontal Display End
    //  [0] Bit 8 of Horizontal Total
    CRTC_WR(NV_CIO_CRE_HEB__INDEX, ((((HorizontalRetraceStart >> 3) + 1) & BIT(8)) ? BIT(3) : 0x00)
                                 | ((((HorizontalBlankStart >> 3) - 1) & BIT(8))   ? BIT(2) : 0x00)
                                 | ((((HorizontalVisible >> 3) - 1) & BIT(8)) ? BIT(1) : 0x00) 
                                 | ((((HorizontalTotal >> 3) - 5) & BIT(8))  ? BIT(0) : 0x00), Head);

    // 0x3c2 (Misc output register)
    // Program the sync polarities.
    // [7] Vertical Sync Polarity:   0 - active High, 1 - active low 
    // [6] Horizontal Sync Polarity: 0 - active High, 1 - active low 
    val08 = (REG_RD08(NV_PRMVIO_MISC__READ) & 0x3f); // just take bits 5:0
    val08 |= (HorizontalSyncPolarity) ? BIT(6) : 0;
    val08 |= (VerticalSyncPolarity)   ? BIT(7) : 0;
    REG_WR08(NV_PRMVIO_MISC__WRITE, val08);

} // end of dacProgramCustomCRTC


// This is the entry point for non-multi-head-aware modeset methods.
RM_STATUS dacSetMode
(
    PHWINFO pDev,
    U032 head
)
{
    RM_STATUS rmStatus = RM_ERROR;

    if (pDev->Dac.CrtcInfo[head].pVidLutCurDac)
    {
        rmStatus = dacSetModeMulti(pDev, (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[head].pVidLutCurDac);
    }

    return rmStatus;
}

/***************************** exported functions **********************************/

// Dac HSYNC & VSYNC control
//
// The Mac needs to be able to individually control these for its power management
//

// XXX couldn't find a #define for these 2 bits...
#define HSYNCBIT   BIT(7)
#define VSYNCBIT   BIT(6)

RM_STATUS dacGetSyncState(
    PHWINFO pDev,
    U032    Head,
    U032   *pHsync,
    U032   *pVsync
)
{
    U008 data08;
    U008 lock;
    
    lock = UnlockCRTC(pDev, Head);
    
    if(GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        if(dacIsFlatPanelOn(pDev,Head))
        {
            //if there was a bit 4 present, it implies *enabled*
            *pHsync=1;
            *pVsync=1;
        }
        else
        {
            *pHsync=0;
            *pVsync=0;
        }
    }
    else
    {
        CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
        *pHsync = ! (data08 & HSYNCBIT);
        *pVsync = ! (data08 & VSYNCBIT);
    }
    
    RestoreLock(pDev, Head, lock);
        
    return RM_OK;
}

RM_STATUS dacSetSyncState(
    PHWINFO pDev,
    U032    Head,
    U032    Hsync,
    U032    Vsync
)
{
    U008 data08;
    U008 lock;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    int  isFp = 0;
    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: SetSyncState on Head", Head);
    
    if ( !Hsync || !Vsync)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: Shutoff of sync requested.");
    }
    
    lock = UnlockCRTC(pDev, Head);
    
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    if (pVidLutCurDac && (pVidLutCurDac->DisplayType == DISPLAY_TYPE_FLAT_PANEL))
        isFp = 1;

#ifdef MACOS
    // Dac.CrtcInfo[Head].pVidLutCurDac is not a safe lookup on the mac, because
    // no modeset has been done to place a valid pVidLutCurDac into the pDev structure.
    // Info in HAL is correct at this point.
    if ( ! pVidLutCurDac && (GETDISPLAYTYPE(pDev, Head)==DISPLAY_TYPE_FLAT_PANEL))
        isFp = 1;
#endif

    if (isFp)
    {
        if((!Hsync)||(!Vsync))
        {
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: Specifically the flatpanel\n");
            
            //power off flat panel
            dacPowerOffMobilePanel(pDev,Head);
            
            //kill PWM
            dacZeroPWMController(pDev);
        }
        else
        {            
            //power on the flat panel
            dacPowerOnMobilePanel(pDev,Head);
            
            //restore PWM
            dacSetPWMController(pDev);
        }
    }
    else
    {
        // read current value
        CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
        
        // clear both
        data08 &= ~(HSYNCBIT | VSYNCBIT);

        // set to 1 if no sync
        if ( ! Hsync)
            data08 |= HSYNCBIT;
        if ( ! Vsync)
            data08 |= VSYNCBIT;
        
        CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08, Head);
    }
    
    RestoreLock(pDev, Head, lock);
    
    return RM_OK;
}
#undef HSYNCBIT
#undef VSYNCBIT


RM_STATUS dacSetSpanning(
    PHWINFO pDev,
    U032    data
)
{
    U008 lock, crtcdata;
    //Update a local flag
    pDev->Dac.DeviceProperties.Spanning = data;

    //Also update a BIOS scratch bit
    lock = UnlockCRTC(pDev, 0);

    CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, crtcdata, 0);
    crtcdata &= ~(NV_SPANNING_MODE);
    if (data)
        crtcdata |= NV_SPANNING_MODE;
    CRTC_WR(NV_CIO_CRE_SCRATCH6__INDEX, crtcdata, 0);

    RestoreLock(pDev, 0, lock);

    return RM_OK;
}

//
// Perform any necessary system synchronization that is required at the start
// of a display change.
//
RM_STATUS dacSetModeStart(
    PHWINFO pDev,
    U032    data
)
{
#define TOSHIBA_FP          (0x1 << 0)
#define TOSHIBA_CRT         (0x1 << 1)
#define TOSHIBA_TV          (0x1 << 2)
    U032    DevToBIOSDev[] = {TOSHIBA_CRT, TOSHIBA_TV, 0, TOSHIBA_FP};
    U032    NewDevices;
    U032    OldDevices;

    U008 lock, crtcdata;
    U032 mscounter = 0;

    // check if this brackets a modeset (in the case of win9x, some don't).
    if ((data & NV_CFGEX_DISPLAY_CHANGE_BRACKETS_MODESET) == 0)
        return RM_OK;

    // If there is a change in process (someone called start a second time)
    // get out of here.  This is currently expected behavior -- more than
    // one start, but only one end.
    //
    if (pDev->Dac.DisplayChangeInProgress)
        return (RM_OK);

    //If we get here in a low power state jump out
    if (pDev->Power.State != 0)
    {
        return RM_OK;
    }

    // clear the DISPLAY_CHANGE_BRACKETS_MODESET flag
    data &= (DAC_DD_MASK_IN_MAP | DAC_TV_MASK_IN_MAP | DAC_CRT_MASK_IN_MAP);

    //
    // Determine the device(s) we're switching away from
    //
    OldDevices = 0x0;
    if (pDev->Dac.CrtcInfo[0].pVidLutCurDac && (GETDISPLAYTYPE(pDev, 0) != DISPLAY_TYPE_NONE))
        OldDevices |= DevToBIOSDev[GETDISPLAYTYPE(pDev, 0)];
    if (pDev->Dac.CrtcInfo[1].pVidLutCurDac && (GETDISPLAYTYPE(pDev, 1) != DISPLAY_TYPE_NONE))
        OldDevices |= DevToBIOSDev[GETDISPLAYTYPE(pDev, 1)];
    //
    // If we couldn't determine the device being switched away from, use the tracked value.
    // Win2K has this nasty habit of destroying all the Dac objects before calling the dispaly change start
    // so we never get the current device right so, to safeguard against this, if the OldDevices
    // is still set to none at this point, we'll just use the last device state that was tracked.
    //
    if(!OldDevices)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: dacSetModeStart - Determining OldDevices using fallback method.\n");
        if (pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType != DISPLAY_TYPE_NONE)
            OldDevices |= DevToBIOSDev[pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType];
        if (pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType != DISPLAY_TYPE_NONE)
            OldDevices |= DevToBIOSDev[pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType];
    }

    NewDevices = 0x0;
    if (data & DAC_CRT_MASK_IN_MAP)
        NewDevices |= TOSHIBA_CRT;
    if (data & DAC_TV_MASK_IN_MAP)
        NewDevices |= TOSHIBA_TV;
    if (data & DAC_DD_MASK_IN_MAP)
        NewDevices |= TOSHIBA_FP;

    //
    // ONLY DO THIS ON HEAD0
    //

    lock = ReadCRTCLock(pDev, 0);           //Back up lock state
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);    //Unlock CRTC extended regs

    // Notify BIOS we're starting a display driver change.
    CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, crtcdata, 0);
    CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, crtcdata | NV_MOBILE_FLAG_DISPLAY_CHANGING, 0);

    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, 0); // Restore lock state

    //
    // Save change data for use on the final notification
    //
    // This flag also acts as notification that we are in process of a display change
    //
//    pDev->Dac.DisplayChangeInProgress = data;
    pDev->Dac.DisplayChangeInProgress = (NewDevices << 8) | OldDevices;

    // 
    // Notify the system if required
    //
    dacMobileDisplayNotifyBegin(pDev, OldDevices, NewDevices);

    // This delay is here because the SBIOS does not seem to be setting the flag (checked below).
    // We exit the do/while in the first try. We expect that a fix in the SBIOS will make this delay unnecessary.
    osDelay(100); // wait 100 ms
    
    //Wait for SBIOS to finish.
    // Something in the system seems to relock them on us from time to time, so unlock every loop
    lock = UnlockCRTC(pDev, 0);
    do {
        UnlockCRTC(pDev, 0);
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, crtcdata, 0);
        tmrDelay(pDev, 1000000);    //delay 1ms
        mscounter++;
    } while ((crtcdata & NV_MOBILE_FLAG_SBIOS_CRIT_SEC) && (mscounter < 1000));
    RestoreLock(pDev, 0, lock);

    if (mscounter >= 1000) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: timeout while waiting for SBIOS (CR4A[1]).\r\n");
    }

    return RM_OK;
}

//
// Perform any necessary system synchronization that is required at the end
// of a display change.
//
RM_STATUS dacSetModeEnd(
    PHWINFO pDev,
    U032    data
)
{
    U008 lock, crtcdata;
    U032 mscounter = 0;

    // check if this brackets a modeset (in the case of win9x, some don't).
    if ((data & NV_CFGEX_DISPLAY_CHANGE_BRACKETS_MODESET) == 0)
        return RM_OK;    // if this doesn't bracked the modeset, return

    //
    // If there is not a change in process (someone called end without calling start)
    // get out of here.
    //
    if (!pDev->Dac.DisplayChangeInProgress)
        return (RM_OK);

    //If we get here in a low power state jump out
    if (pDev->Power.State != 0)
    {
        return RM_OK;
    }

    // clear the DISPLAY_CHANGE_BRACKETS_MODESET flag
    data &= (DAC_DD_MASK_IN_MAP | DAC_TV_MASK_IN_MAP | DAC_CRT_MASK_IN_MAP);

    // 
    // Notify the system if required
    //
    dacMobileDisplayNotifyEnd(pDev, pDev->Dac.DisplayChangeInProgress & 0xFF, (pDev->Dac.DisplayChangeInProgress >> 8) & 0xFF);

    //
    // ONLY DO THIS ON HEAD0
    //

    //Wait for SBIOS to finish.
    // Something in the system seems to relock them on us from time to time, so unlock every loop
    // Save current lock state for restore later
    lock = UnlockCRTC(pDev, 0);
    do {
        UnlockCRTC(pDev, 0);
        CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, crtcdata, 0);
        tmrDelay(pDev, 1000000);    //delay 1ms
        mscounter++;
    } while ((crtcdata & NV_MOBILE_FLAG_SBIOS_CRIT_SEC) && (mscounter < 1000));

    if (mscounter >= 1000) {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: timeout while waiting for SBIOS (CR4A[1]).\r\n");
    }

    // Make sure the CRTC registers are still unlocked
    UnlockCRTC(pDev, 0);

    // Notify BIOS we're done with the display driver change.
    CRTC_RD(NV_CIO_CRE_SCRATCH5__INDEX, crtcdata, 0);
    crtcdata &= ~(NV_MOBILE_FLAG_DISPLAY_CHANGING);
    CRTC_WR(NV_CIO_CRE_SCRATCH5__INDEX, crtcdata, 0);

    // Restore the original locking state that was saved off earlier.
    RestoreLock(pDev, 0, lock);

    //Mobile specific: keep around knowledge of that the secondary (non-LCD) display
    // was set to.  Used when returning to Windows to enable TwinView modes.
    // The logic may seem unnecessarily careful, but we've seen problems with
    // the CR registers before due to BIOS problems, so I'm trying to handle
    // possible cases like the same display being set as enabled on more than
    // one head, etc., gracefully.
    if (pDev->Power.MobileOperation) {
        U032 extDevice = DISPLAY_TYPE_NONE;
#if 1
        //We know that if there's more than one device, one is the LCD, and there
        // are no other flat panels.  But I'll code the general case on general principle.
        if (data & (data - 1)) {  //if more than one display is enabled
            if (data & DAC_DD_MASK_IN_MAP) extDevice = DISPLAY_TYPE_FLAT_PANEL; //should always be true in mobile -- lowest priority
            if (data & DAC_TV_MASK_IN_MAP) extDevice = DISPLAY_TYPE_TV;         //higher priority
            if (data & DAC_CRT_MASK_IN_MAP) extDevice = DISPLAY_TYPE_MONITOR;   //highest priority
        } else {
            U008 lock, data08;
        //In NT, we can't count on destruction of the LUT objects as an indicator
        // that displays have been turned off -- both LUT objects are always around.
        // So instead, we clear the CR3B registers here.
        //This would be an acceptable solution on 9x as well, except that at the
        // moment the call to this function occurs before the actual modesets...
        // 6/8/01 (LPL) : have now enabled this for 9x as well.  This call occurs
        // after the modesets now, and we need it in order to straighten out the
        // scratch registers at startup if the display driver opts for a display
        // other than what the VBIOS had picked (in this case we wouldn't otherwise
        // clear CR3B for the other display, since there is no LUT object to destroy).
        // Fixes bug 34209.
            if (data & DAC_DD_MASK_IN_MAP) {
                lock = UnlockCRTC(pDev, 0);
                CRTC_RD(0x3B, data08, 0);
                CRTC_WR(0x3B, (data08 & 0x0F), 0);
                RestoreLock(pDev, 0, lock);
            } else {
                lock = UnlockCRTC(pDev, 1);
                CRTC_RD(0x3B, data08, 1);
                CRTC_WR(0x3B, (data08 & 0x0F), 1);
                RestoreLock(pDev, 1, lock);
            }
            extDevice = DISPLAY_TYPE_NONE;         //don't set any secondary devices
        }
#else   //#if 1
        //Read directly from the CR registers.  Problem: displaychangeend occurs _before_ the modesets.
        extDevice = DISPLAY_TYPE_NONE;  //default, if only one display is enabled
        if ((cr3BhA & 0xF0) && (cr3BhB & 0xF0)) {   //If two displays are enabled.
            //Check for displays other than the internal LCD
            if (cr3BhB & 0xE0) extDevice = cr3BhB;
            if (cr3BhA & 0xE0) extDevice = cr3BhA;  //head A trumps B
        }

        //Now translate into a display type
        if (extDevice & 0x20) {
            extDevice = DISPLAY_TYPE_MONITOR;
        } else if (extDevice & 0x40) {
            extDevice = DISPLAY_TYPE_TV;
        } else if (extDevice & 0x80) {
            extDevice = DISPLAY_TYPE_FLAT_PANEL; //external DFP
        } else {
            extDevice = DISPLAY_TYPE_NONE;
        }
#endif  //#if 1... else...

        osWriteRegistryDword(pDev, strDevNodeRM, strLastExtDevice, extDevice);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: external dev:", extDevice);

        osWriteRegistryDword(pDev, strDevNodeRM, strCurWinDevices, data);
    }

    //
    // Complete the display change -- clear the flag
    //
    pDev->Dac.DisplayChangeInProgress = 0;

    return RM_OK;
}


RM_STATUS dacSetModeStartEx(
    PHWINFO pDev,
    U032    devices,
    U032    properties
)
{
    RM_STATUS status;
    //Note: even if we add other operations here, call dacSetModeStart _first_ --
    // it sets a flag that signals a display change in progress.
    status = dacSetModeStart(pDev, devices);

#ifdef NTRM
    //Currently, the WinNT implementation supports the 'properties' field,
    // and 9x does not.  Get display driver people to unite on a single approach
    // soon!  The 9x display driver doesn't easily have access to this info
    // at display change time, so there is now a separate ConfigSet (NV_CFG_DISPLAY_CHANGE_CONFIG)
    // which can be used.
    status = dacSetSpanning(pDev, (properties & NV_CFGEX_DISPLAY_CHANGE_SPANNING)?1:0);
#endif

    return status;
}

RM_STATUS dacSetModeEndEx(
    PHWINFO pDev,
    U032    devices,
    U032    properties
)
{
    //Note: even if we add other operations here, call dacSetModeEnd _last_ --
    // it clears a flag that signals a display change in progress.
    return dacSetModeEnd(pDev, devices);
}

//
// Program the dac video parameters
//
//  Note that the video parameters have already been deposited in pDev.  This allows us to go
//  through multiple load/unload pairs (like DOS boxes) while still maintaining the original
//  video mode parameters.  It also makes it easier for an applet (like the control panel)
//  to tweak one value, then force an unload/load to make it affective.
//
RM_STATUS dacSetModeMulti(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac
)
{
    RM_STATUS status = RM_OK;
    U016      data,save_sr1 = 0;
    U032      data32;
    U008      shadow,data08, i, cr3Bmod, savedCR3D;
    volatile U032 scratch;
    
    // Extract parameters from the VIDEO_LUT_CURSOR_DAC object.
    U032      HorizontalVisible         = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    U032      HorizontalBlankStart      = pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart;
    U032      HorizontalRetraceStart    = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart;
    U032      HorizontalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth);
    U032      HorizontalBlankEnd        = (pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart +
                                           pVidLutCurDac->HalObject.Dac[0].HorizontalBlankWidth);
    U032      HorizontalTotal           = pVidLutCurDac->HalObject.Dac[0].TotalWidth;
    U032      VerticalVisible           = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
    U032      VerticalBlankStart        = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
    U032      VerticalRetraceStart      = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart;
    U032      VerticalRetraceEnd        = (pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight);
    U032      VerticalBlankEnd          = (pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight);
    U032      VerticalTotal             = pVidLutCurDac->HalObject.Dac[0].TotalHeight;
    U032      PixelDepth                = pVidLutCurDac->HalObject.Dac[0].PixelDepth;
    U032      PixelClock                = pVidLutCurDac->HalObject.Dac[0].PixelClock;
    U032      HorizontalSyncPolarity    = pVidLutCurDac->HalObject.Dac[0].Format.HorizontalSyncPolarity;
    U032      VerticalSyncPolarity      = pVidLutCurDac->HalObject.Dac[0].Format.VerticalSyncPolarity;
    U032      DoubleScannedMode         = pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode;
    U032      Head                      = pVidLutCurDac->HalObject.Head;
    
    //If we get here in a low power state jump out
    if (pDev->Power.State != 0)
    {
        return RM_OK;
    }
    //
    // Validate this mode is valid for the amount of framebuffer present
    // in this specific device.
    // Watch out for pixel depth of 15; add 1 to ensure it divides by 8 and give correct #bytes
    if ((HorizontalVisible * VerticalVisible * ((PixelDepth+1) >> 3)) > 
        pDev->Framebuffer.HalInfo.RamSize)
            return RM_ERROR;
    DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"NVRM: dacSetModeMulti,Enter\r\n");

    //
    // There is a bug in NV hardware where the hardware cursor will not clip correctly
    // if a border is defined in the display timings (blank start != visible end).  
    // Borders are only defined in two specific DMT modes.
    //
    // To fix this, set the blank starts to match the visible totals and remove the 
    // implicit borders.
    //
    // Remove this code when the hardware gets fixed.  Since this bug has been in the 
    // hardware since 1994, don't expect a fix soon.
    //
    HorizontalBlankStart = HorizontalVisible;
    HorizontalBlankEnd   = HorizontalTotal;
    VerticalBlankStart   = VerticalVisible;
    VerticalBlankEnd     = VerticalTotal;

    //
    // Now set monitor type.
    //
    switch (pVidLutCurDac->DisplayType)
    {
        case DISPLAY_TYPE_MONITOR:
            SETMONITORTYPE(pDev, Head, MONITOR_TYPE_VGA);
            break;
        case DISPLAY_TYPE_TV:
            switch (pVidLutCurDac->TVStandard)
            {
                case NTSC_M:
                case NTSC_J:
                    SETMONITORTYPE(pDev, Head, MONITOR_TYPE_NTSC);
                    break;
                case PAL_A:
                case PAL_M:
                case PAL_N:
                case PAL_NC:
                    SETMONITORTYPE(pDev, Head, MONITOR_TYPE_PAL);
                    break;
            }
            //
            // Set TV standard.
            //
            pDev->Dac.TVStandard = pVidLutCurDac->TVStandard;

            // Also set it in the cached copy that's used to refresh Macrovision settings.
            pDev->Dac.TVLastMacrovision.tvStandard = pVidLutCurDac->TVStandard;

            break;
        case DISPLAY_TYPE_DUALSURFACE:
            break;
        case DISPLAY_TYPE_FLAT_PANEL:        
            SETMONITORTYPE(pDev, Head, MONITOR_TYPE_FLAT_PANEL);

            if ( IsNV11(pDev) && pDev->Power.MobileOperation && (pDev->Power.MobileOperation != 2) )
            {
                if (dacGetFlatPanelConfig(pDev, Head) == NV_CFGEX_GET_FLATPANEL_INFO_SCALED)
                {
                    if ((HorizontalVisible <= 800) && (DAC_REG_RD32(NV_PRAMDAC_FP_HCRTC, Head) >= 1400))
                    {
                        // PCLK will be lowered
                        // If the PCLK isn't lowered now, we need to turn off the panel to prevent blooming
                        // If we ever change the PCLK, we need to power down the panel and run the reset script.
                        // This fixes bug 32763.
                        if(!(pDev->Dac.DevicesEnabled & DAC_LOW_PCLK_ENABLED))
                            dacPowerOffMobilePanel(pDev, Head);
                    }
                    else
                    {
                        // PCLK will be normal.
                        // If the PCLK is currently lowered, the we need to turn off the panel to prevent blooming
                        // If we ever change the PCLK, we need to power down the panel and run the reset script.
                        // This fixes bug 32763.
                        if(pDev->Dac.DevicesEnabled & DAC_LOW_PCLK_ENABLED)
                            dacPowerOffMobilePanel(pDev, Head);
                    }
                }
            }

            break;
        default:
            break;
    }
    // Work-around for a NV11 HW bug:
    // Find out what the current display is (do this before osPreModeSet sets new display type).
    // If it is TV, and this is NV11, call dacDisableTV to be sure PCLK doesn't get stuck when we change the
    // clock source. dacDisableTV checks for a stalled PCLK and kick-starts it.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)    
    {
        if (IsNV11(pDev)) dacDisableTV(pDev, Head);
    }
    //
    // We are about to set the new mode. Do any os specific actions necessary at this point.
    // This includes any registry overrides that may affect the new mode.
    // Specifically, determine what type of display device (CRT, FP, or TV), and if TV,
    // what format, and if FP, parse EDID to get timings.
    // NOTE: at this point, the new DisplayType is in the VidLutCurDac object, the old DisplayType is in HalInfo.CrtcInfo
    // (which GETDISPLAYTYPE and SETDISPLAYTYPE access).
    osPreModeSet(pDev, Head);

    //
    // Set display type.  We can't rely on the caller to actually
    // have specified an allowable valid type.  As one last check,
    // consult the allowed mask.  Don't reset the DisplayType field,
    // but continue on with the modeset just to be safe...
    //
    if ((GETCRTCHALINFO(pDev, Head, DisplayTypesAllowed) & DISPLAYTYPEBIT(pVidLutCurDac->DisplayType)) != 0)
        SETDISPLAYTYPE(pDev, Head, pVidLutCurDac->DisplayType);

    // 
    // Update the other Head's PrimaryDevice state, so it's consistent with this
    // Head's PrimaryDevice state (opposite head = opposite PrimaryDevice value).
    // 
    pDev->Dac.CrtcInfo[Head^1].PrimaryDevice = pDev->Dac.CrtcInfo[Head].PrimaryDevice^1;
    
    DBG_PRINT_STRING (DEBUGLEVEL_TRACEINFO, "Setting mode \n");
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "    H Res:", pDev->Framebuffer.HalInfo.HorizDisplayWidth);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "    V Res:", pDev->Framebuffer.HalInfo.VertDisplayWidth);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "Bit Depth:", PixelDepth);
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "  Refresh:", pDev->Framebuffer.HalInfo.RefreshRate);

    // Set the requested refresh rate
    pVidLutCurDac->RefreshRate = (PixelClock * 10000) /
                                 (HorizontalTotal * VerticalTotal);

    //
    // Update tiling configuration.
    //
    nvHalFbControl(pDev, FB_CONTROL_TILING_CONFIGURE);

    //
    // Check for a change to nvclk/mclk values.
    //
    // Since we don't go through a STATE_LOAD as part of a mode switch, this is
    // where we'll program these clocks. The values are only interesting to the
    // arbitration code below, so anytime before that should be good.
    //
    // Since we also haven't done a STATE_UNLOAD, we're assuming this SW method
    // in the host FIFO has allowed enough of the chip to idle, so we can change
    // the clocks. In limited testing, this seems to work.
    //
    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_NVPLL)
    {
        // Program NVCLK
        status = dacProgramNVClk(pDev);
        pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_NVPLL;
    }

    // 
    // Transfer any update flags (i.e. mclk programming request) to pDev.
    //
    if (pDev->halHwInfo.pDacHalInfo->UpdateFlags & NV_HAL_DAC_UPDATE_MPLL)
    {
        pDev->Dac.UpdateFlags |= UPDATE_HWINFO_DAC_MPLL;
        pDev->halHwInfo.pDacHalInfo->UpdateFlags &= ~NV_HAL_DAC_UPDATE_MPLL;
    }

    if (pDev->Dac.UpdateFlags & UPDATE_HWINFO_DAC_MPLL)
    {
        // Program MCLK
        status = dacProgramMClk(pDev, 0);
        pDev->Dac.UpdateFlags &= ~UPDATE_HWINFO_DAC_MPLL;
    }



    //
    // Enable full CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x57, Head);

    //
    // If this is for CRTC2, set CRTC access bit and PRAMDAC address
    // This access bit controls accesses to Sequencer and Graphics Controller (C03xx).
    // CRTC and Attribute Controller must be accessed at different addresses for each head
    // (6103xx/6033xx), since there is only one bus.
    //
    if (IsNV11(pDev))
    {
        //
        // If there hasn't been a modeset on the other head, turn off the sequencer
        // there allowing more FB bandwidth for this head. When a modeset does occur,
        // dacProgramSeq will reset SR1 back. 
        //
        if (pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac == NULL)
        {
            EnableHead(pDev, Head^1);
            REG_WR08(NV_PRMVIO_VSE2, 1);                    // enable VGA subsystem
            data08 = REG_RD08(NV_PRMVIO_MISC__READ);
            REG_WR08(NV_PRMVIO_MISC__WRITE, data08 | 1);    // enable CGA I/O space
        }

        // point CR44 at this head, for the rest of the modeset
        EnableHead(pDev, Head);
        if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
        {
            AssocTV(pDev, Head);
            AssocDDC(pDev, Head);
        }

        REG_WR08(NV_PRMVIO_VSE2, 1);                    // enable VGA subsystem
        data08 = REG_RD08(NV_PRMVIO_MISC__READ);
        REG_WR08(NV_PRMVIO_MISC__WRITE, data08 | 1);    // enable CGA I/O space
    }
        
    // Switching from FP or TV to CRT (CRTC slave mode) can stall the scanline counter. 
    dacDisableCRTCSlave(pDev, Head);

    // Disable flat panel syncs
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _DISABLE, Head); // 
    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _DISABLE, Head); // 

    CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 & ~0x80, Head);    // unlock CR0-7
    
    // Before unlocking / reading CR21 we should write CR3D[0] to 1 to enable reading of
    // the shadow registers.  This will allow us to read the real CR register values from
    // the locked registers.
    CRTC_RD(0x3D, savedCR3D, Head);     // read CR3D
    savedCR3D |= 0x1;                   // set CR3D[0] to 1
    CRTC_WR(0x3D, savedCR3D, Head);     // write back CR3D[0] = 1

    CRTC_RD(0x21, shadow, Head);        // read shadow lock
    shadow |= 0xfa;                     // enable HDE, VDE, and 8/9 dot chars too, for NV5.

    // Before programming the shadow registers you must set CR3D[0] to 0
    savedCR3D &= ~0x1;                  // set CR3D[0] to 0
    CRTC_WR(0x3D, savedCR3D, Head);     // write back CR3D[0] = 0

    CRTC_WR(0x21, shadow, Head);        // write back shadow

    // Set H and V retrace start to a large value to prevent possible lock-up.
    // This is because if the CRTC is slaved to an external device (the TV encoder),
    // it will stall waiting for retrace start to sync up with the external clock. 
    // When we switch from TV to CRT, we may get stuck in this stall. Setting retrace 
    // start to a large value guarantees this won't happen.
    CRTC_WR(NV_CIO_CR_HRS_INDEX, 0xff, Head);
    CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xff, Head);

    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        U008 i;

        // bug workaround--disable scanline doubling and then shadow it. This allows writes to CR09 to affect the CRTC,
        //   but not the flat panel controller (else the flat panel controller may quadruple the scanline count).
        CRTC_RD(NV_CIO_CR_CELL_HT_INDEX, data, Head);         // read scanline double
        CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, (data &= ~0x80), Head);   // clear scanline double bit

        // Wait one vsync before shadowing the scanline double bit
        // Use a time-out in case the bit is stuck.
        for (i=0; i<17; i++)    // max time it can take is 16.7 ms (actually less)
        {
            if (DAC_REG_RD32(NV_PCRTC_RASTER, Head) & DRF_DEF(_PCRTC, _RASTER, _VERT_BLANK, _ACTIVE))
                break;      
            tmrDelay(pDev, 1000000);    // wait 1 ms
        }
        for (i=0; i<17; i++)    // max time it can take is 16.7 ms
        {
            if (!(DAC_REG_RD32(NV_PCRTC_RASTER, Head) & DRF_DEF(_PCRTC, _RASTER, _VERT_BLANK, _ACTIVE)))
                break;
            tmrDelay(pDev, 1000000);    // wait 1 ms
        }
    
        // shadow = CR21
        shadow &= ~0x40;                // shadow the scanline double bit
        CRTC_WR(0x21, shadow, Head);    // allow horiz & vert write-thru

        // de-couple vertical sync from flat panel while setting mode
        data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head); 
        data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);   // set VCLK bits
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);

        // power off the panel until the mode is all setup
        //if (pDev->Power.MobileOperation)
        //{
        //    dacPowerOffMobilePanel(pDev, Head);
        //}
        // There's no need to turn off the panel.  We disable the visible screen so the user
        // not see anything.  This gets rid of at least 0.8 seconds in mode transitions.
    }
    else
    {
        //
        // We aren't driving DFP on this head, so we need to make sure to flush the overlay
        // clocking in the chip so it's not accidently left pointing at the DFP clocks.
        //
        // If we're not careful, the fp_newline signal inside the chip may still be driven
        // from fpclk, even though we aren't actively using fpclk.  This will result in
        // the overlay video engine not sending output data
        //
        // Here's the HW description of the bug
        //
        // This is a hardware bug that exists in NV10 and subsequent designs: 
        //  *  the video scaler relies on an a signal from the flat panel timing logic, fp_newline
        //  *  when the CRTC is not slaved to the FP, fp_newline should remain 1, however, this is 
        //     not always true
        //  *  if the FP timing has been previously programmed, and the CRTC is un-slaved from the 
        //     FP timing, fp_newline will continue to toggle as if the CRTC were still slaved to the FP.
        //  * also,  if the FPCLK is powered down at a moment when fp_newline is 0, fp_newline will 
        //    remain 0 until FPCLK is powered back up
        //  * fp_newline can be made to remain 1 by doing these steps before unslaving the CRTC from 
        //    the FP timing
        //    1.) disable vertical FP scaling
        //    2.) wait until the next frame
        //    3.) FPCLK and FP syncs must be enabled during this time (steps 1 and 2), i.e., 
        //        NV_PRAMDAC_FP_TG_CONTROL bits 1 and 5 must both be 0.
        //    4.) un-slave CRTC to FP timing
        //    5.) FPCLK and FP H- and V- syncs may now be disabled if desired
        //
        // This is supposed to be fixed on NV17 and later...
        // 
        
        if (IsNV10(pDev) || IsNV11(pDev) || IsNV1A(pDev) || IsNV15(pDev) || IsNV20(pDev))
        {
            U032 savedPowerState;

            U032 regvalue;
            U032 savemode;
            U032 savecenter;
            
            //Get current state of register
            regvalue   = DAC_REG_RD32(NV_PRAMDAC_FP_TG_CONTROL, Head); 
            savemode   = DRF_VAL(_PRAMDAC, _FP_TG_CONTROL, _MODE,   regvalue);
            savecenter = DRF_VAL(_PRAMDAC, _FP_TG_CONTROL, _CENTER, regvalue);

            // Temporarily turn on the FPCLK
            savedPowerState = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);
            dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE);

            // Set the fp to centered with valid sync's 
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _VSYNC, _NEG, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _HSYNC, _NEG, Head);
            
            DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_START, 1, Head);
            DAC_REG_WR32(NV_PRAMDAC_FP_VVALID_END,   0, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _MODE, _CENTER, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _FP_TG_CONTROL, _CENTER, _VERT, Head);

            // need to wait for fp_vsync to be high twice.
            // this could take 4 vsync times if we start at 0.
            // Figure a vsync time is ~20ms.
            // Adding another vsync (now 5) to wait to fix bug 31102
            tmrDelay(pDev, 5 * 20 * (1000 * 1000));

            // Put it back to previous mode
            DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _MODE,   savemode,   Head);
            DAC_FLD_WR_DRF_NUM(_PRAMDAC, _FP_TG_CONTROL, _CENTER, savecenter, Head);

            // Turn FPCLK back off again
            DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, savedPowerState, Head);
            tmrDelay(pDev, 5 * 1000 * 1000);
        }
    }

    // Program the TV encoder if any.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
    {
        status = dacSetupTVEncoder(pDev, Head); 
        if (status)
        {
            switch (status)
            {
                case ERR_I2C_MODE:
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Can't program the TV encoder for this mode.\n");
                    break;
                case ERR_I2C_COMM:
                    DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: I2C error programming mode\n");
                    break;
                case ERR_I2C_UNKNOWN:
                    DBG_PRINT_STRING (DEBUGLEVEL_ERRORS, "NVRM: No TV Encoder detected\n");
                    break;
            }                
            if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)      // if flat panel, leave it that way.
                SETDISPLAYTYPE(pDev, Head, DISPLAY_TYPE_MONITOR);  // No encoder set up for monitor
        }
    }

    //
    // Disable the visible screen
    //
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);       // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x00);               // Turn off screen at AR
    ////WritePriv08(NV_PRMCIO_ARX, 0x00);        // Turn off screen at AR
        
    //
    // FullCPUOn()
    //
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    data |= 0x2000;                             // Full Bandwidth bit ON
    WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit

    //
    // Set the sequencer & graphics controller values that are common for all packed-pixel
    // graphics modes.
    //            
    dacProgramSeq(pDev, Head);
    //
    // Program the CRTC & SR values for this particular mode.
    //
    dacProgramCRTC(pDev, Head, pVidLutCurDac,
                         HorizontalVisible,
                         HorizontalBlankStart,
                         HorizontalRetraceStart,
                         HorizontalRetraceEnd,
                         HorizontalBlankEnd,
                         HorizontalTotal,
                         VerticalVisible,
                         VerticalBlankStart,
                         VerticalRetraceStart,
                         VerticalRetraceEnd,
                         VerticalBlankEnd,
                         VerticalTotal,
                         PixelDepth,
                         PixelClock,
                         HorizontalSyncPolarity,
                         VerticalSyncPolarity,
                         DoubleScannedMode);

    // Set the flat panel timing registers (PRAMDAC_FP).
    // We must program the DAC before we load the palette, because the DAC is driving the 
    // VGA clock.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        U032 fpMode, fpMaxX, fpMaxY;
        BOOL fpConnect;
        BOOL fpNative;
   
// TO DO: do not use the registry for NT
#ifndef NTRM
        status = dacGetFlatPanelInfo(pDev, Head, &fpMode, &fpMaxX, &fpMaxY, &fpConnect, &fpNative,
            ((pDev->Power.MobileOperation)?FALSE:TRUE) /* from registry */);

        //XXX: Special workaround for Toshiba. There are times when doing a modeset on 
        //a flat panel where the CR registers can become locked after we generate an
        //INT10 to our video bios, which in turn generates an INT15 to the system
        //bios. The real solution is to work with either the SBIOS or VBIOS people
        //to ensure that our lock state is being saved and restored correctly. For
        //now re-unlock the extended registers and enable vga subsystem after the
        //ReadEdid call.
        if (pDev->Power.MobileOperation == 2)
        {
            CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x57, Head);
            EnableHead(pDev, Head);
            REG_WR08(NV_PRMVIO_VSE2, 1);                    // enable VGA subsystem
            data08 = REG_RD08(NV_PRMVIO_MISC__READ);
            REG_WR08(NV_PRMVIO_MISC__WRITE, data08 | 1);    // enable CGA I/O space
        }
#else
        status = dacGetFlatPanelInfo
        (
            pDev, 
            Head, 
            &fpMode, 
            &fpMaxX, 
            &fpMaxY, 
            &fpConnect, 
            &fpNative,
            FALSE           /* NOT from registry for NT */
        );
#endif

        // if Native mode requested, make sure this monitor supports it
        if ((fpMode == NV_CFGEX_GET_FLATPANEL_INFO_NATIVE) && (!fpNative))
            fpMode = NV_CFGEX_GET_FLATPANEL_INFO_SCALED;    // no, then do scaled
        status = dacSetFlatPanelMode(pDev, Head, pVidLutCurDac, fpMode, FALSE /* don't commit changes */);
    }
    else
    {
        //
        // If we aren't driving the panel through this head, or
        // (or the other head) turn it off.
        // 
        if (pDev->Power.MobileOperation)
        {
            if ((pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac == NULL) ||
                (((PVIDEO_LUT_CURSOR_DAC_OBJECT)(pDev->Dac.CrtcInfo[Head^1].pVidLutCurDac))->DisplayType != DISPLAY_TYPE_FLAT_PANEL))
            {
                dacPowerOffMobilePanel(pDev, Head);
            }
        }
    }

    // If using an analog CRT with the external DAC, program the PRAMDAC_FP register to generate timing
    if ((GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_MONITOR) && (Head == 1))
    {
        U032 fpMode, fpMaxX, fpMaxY;
        BOOL fpConnect;
        BOOL fpNative;
   
        status = dacGetFlatPanelInfo(pDev, Head, &fpMode, &fpMaxX, &fpMaxY, &fpConnect, &fpNative, FALSE ); /* NOT from registry */
        status = dacSetFlatPanelMode(pDev, Head, pVidLutCurDac, NV_CFGEX_GET_FLATPANEL_INFO_NATIVE, FALSE);
        dacAdjustCRTCForFlatPanel(pDev, Head, pVidLutCurDac);
    }
    
    // This code is necessary to fix a bug found where the memory controller would hang if a delay
    // was NOT inserted before turning on the display after programming the pixel clock PLL's.
    // Only required for SMA mode.
    if(IsNV0A(pDev)){
        if(pDev->Framebuffer.HalInfo.RamType == BUFFER_CRUSH_UMA){
            save_sr1 = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
            data = save_sr1;
            data |= 0x2000;                             // Full Bandwidth bit ON
            WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit
        }
    }

    //
    // Program the new VPLL clock rate
    // If this is a flat panel, or flat panel engine is driving the analog monitor, we should not change the clocks
    if ((GETDISPLAYTYPE(pDev, Head) != DISPLAY_TYPE_FLAT_PANEL) && (Head != 1))
    {
        dacProgramPClk(pDev, Head, PixelClock);
    }

    //
    // Native modes require a divide-by-2 clock ratio
    //                                    
    if (Head == 0) 
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB2);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK_TV, _NONE);   // assume no TV for now
    }
    else
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB2);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _NONE);  // assume no TV for now
    }
    pDev->Framebuffer.CursorAdjust = 0;   // default to no adjustment of cursor position
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
    {
        dacAdjustCRTCForTV(pDev, Head);              // CRTC tweaks for TV
    }
    else    
    {
        // Not TV, if flat panel, we may need to adjust CRTC's
        if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
            dacAdjustCRTCForFlatPanel(pDev, Head, pVidLutCurDac);
        if (Head == 0) 
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG);
        }
        else
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG);
        }
    }        
    
    //
    // Load default palette values. Do this after clock is running, else we hang.
    //
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        // Set NEWPIX before programming palette to prevent hang on some systems (i.e. VIA).
        // This prevents the PCLK from being held off. Stopping PCLK is done to allow the pixel
        // stream to sync with the flat panel controller, but is also causes the palette to stop 
        // responding, causing bus retries. The VIA chipset doesn't like a lot of bus retries, 
        // and may eventually hang the bus.
        data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);           
        data32 |= (NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX << 16);  // set NEWPIX
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);
    }

#ifdef MACOS
    // We don't init the palette on either Mac os; its already been set
    //   to their own style of LUT and these defaults just cause flashing
#else
    dacLoadPalette(pDev, Head, PixelDepth);
#endif

    // Restore normal clocking (flat panel can hold off)
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL)
    {
        data32 = DAC_REG_RD32(NV_PRAMDAC_FP_DEBUG_0, Head);           
        data32 &= ~(NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH << 16); // set to normal mode
        DAC_REG_WR32(NV_PRAMDAC_FP_DEBUG_0, data32, Head);
    }

    if(!IsNV0A(pDev)){
        //
        // FullCpuOff()
        //
        data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
        data &= 0xDFFF;                             // Full Bandwidth bit OFF
        WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit            
    }else{
        if(pDev->Framebuffer.HalInfo.RamType != BUFFER_CRUSH_UMA){
            data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
            data &= 0xDFFF;                             // Full Bandwidth bit OFF
            WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit            
        }
    }
    
    //
    // ATCOn()
    //
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);       // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x20);               // Turn off screen at AR
    ////WritePriv08(NV_PRMCIO_ARX, 0x20);        // Turn off screen at AR
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    ////ReadPriv32(NV_PRMCIO_INP0__COLOR);       // Reset ATC FlipFlop
      
    // make sure test modes are off, else screen may be blanked
    DAC_REG_WR32(NV_PRAMDAC_TEST_CONTROL, 0, Head); // make sure test modes are off!

    // Enable active display, blank all non-active displays
    //  (TV is blanked in encoder-specific function).
    // + in mobile case, update BIOS's record of enabled displays
    cr3Bmod = 0;
    switch (GETDISPLAYTYPE(pDev, Head))
    {
        case DISPLAY_TYPE_MONITOR:
            if (Head == 0) // if normal VGA (internal DAC) 
            {
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _ON, Head);  // CRT on
                //
                // We need to be careful about powering down the TMDS
                // transmitter on NV11 because we can lose a flat
                // panel connected to the second crtc (head 1).
                //
                // XXX doing this on the P11 kills the FP on head 1.
                // commenting it out doesn't seem to break anything on the Mac....
                
#ifndef MACOS
                if (IsNV11(pDev))
                    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_FPCLK);     // FPCLK off only;leave TMDS going for secondary crtc
                else
                    dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_BOTH);      // FPCLK/TMDS both off
#endif       
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, (data08 & ~0x02), Head);  // clear CR33[1] (BIOS flag)

                // enable H&V sync's
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & 0x3F, Head);
                
                // make sure that head 0 is NOT driving FP output
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, data08 & ~0x10, Head);    // Bit 4 = 0
                
                dacSetCursorBlink(pDev, Head, 0); // set cursor blink rate for DOS
            }
            else // PRAMDAC_FP is driving analog
            {
                DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head); // CRT off
                CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 & ~0x40, Head);
                
                // make head 0 drive FP output
                CRTC_RD(0x33, data08, Head);
                CRTC_WR(0x33, data08 | 0x10, Head);    // Bit 4 = FP 2
                
                dacSetCursorBlink(pDev, Head, 1); // set cursor blink rate for DOS
            }

            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
                dacDisableTV(pDev, Head);
            //Update BIOS's record of enabled displays

            cr3Bmod = 0x20;
            break;                              
        case DISPLAY_TYPE_TV:
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head); // CRT offs
            //
            // We need to be careful about powering down the TMDS
            // transmitter on NV11 because we can lose a flat
            // panel connected to the second crtc (head 1).  This wouldn't
            // be an issue if we could 
            //
            if (IsNV11(pDev))
                dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_FPCLK);     // FPCLK off only;leave TMDS going for secondary crtc
            else
                dacWriteLinkPLL(pDev, Head, NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_BOTH);      // FPCLK/TMDS both off
            // Turn Hsync off and Vsync on, or leave both on, depending on what we found in registry
            CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
            data08 &= ~0xC0;
            if (pDev->Dac.HsyncOff) 
            {
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 |= 0x80, Head); // disable horiz sync to put CRT in suspend
            }
            else
            {
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08, Head);    // leave both syncs on
            }
            dacSetCursorBlink(pDev, Head, 1); // set cursor blink rate for DOS

            //Update BIOS's record of enabled displays
            cr3Bmod = 0x40;
            break;                              
        case DISPLAY_TYPE_FLAT_PANEL:
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TEST_CONTROL, _PWRDWN_DAC, _OFF, Head); // CRT off
            // Turn Hsync off and Vsync on, or leave both on, depending on what we found in registry
            CRTC_RD(NV_CIO_CRE_RPC1_INDEX, data08, Head);
            data08 &= ~0xC0;
            if (pDev->Dac.HsyncOff) 
            {
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08 |= 0x80, Head); // disable horiz sync to put CRT in suspend
            }
            else
            {
                CRTC_WR(NV_CIO_CRE_RPC1_INDEX, data08, Head);    // leave both syncs on
            }
            CRTC_RD(0x33, data08, Head);
            CRTC_WR(0x33, data08 | 0x10, Head);    // Bit 4 = FP 2
            // If no head is using TV, blank image.
            for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
                if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
                    break;
            if (i == pDev->Dac.HalInfo.NumCrtcs)
                dacDisableTV(pDev, Head);
            // Need to actually power on the panel as well
            if (pDev->Power.MobileOperation)
                dacPowerOnMobilePanel(pDev, Head);
            dacSetCursorBlink(pDev, Head, 1); // set cursor blink rate for DOS

            //Update BIOS's record of enabled displays
            if (Head == 1) {
                cr3Bmod = 0x10;    //internal LCD
            } else {
                cr3Bmod = 0x80;    //external DFP
            }
            break;                              
    }

    //Update BIOS's record of enabled displays
    if (pDev->Power.MobileOperation  && !pDev->Vga.Enabled) {
        U008 lock;

        lock = UnlockCRTC(pDev, Head);

        CRTC_RD(0x3B, data08, Head);
        CRTC_WR(0x3B, (data08 & 0x0F) | cr3Bmod, Head);

        RestoreLock(pDev, Head, lock);
    }

    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
    {
        shadow &= ~0x80;          // shadow Horiz only
        CRTC_WR(0x21, shadow, Head);    // restore the shadow lock

        // restore macrovision mode if appropriate
        if (pDev->Dac.TVLastMacrovision.mode & 0x3)
            SetMacrovisionMode(pDev, Head, (RM_MACROVISION_CONTROL *)&(pDev->Dac.TVLastMacrovision));

    }

    //Fix for Crush. TV and Flat Panel share some registers. We must
    //set the mux to pick the correct display.
    if (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_FLAT_PANEL) 
    {
        if (IsNV0A(pDev)) 
        {
            data32 = 0x00000005;
            DAC_REG_WR32(NV_PRAMDAC_TV_SETUP, data32, Head); 
        }
    }    
    //
    // For NV4, change the default flip functionality to end of vsync, not start
    //
    // BUG BUG BUG:  There is a hardware bug in NV4/NV5 relating to this particular
    // register.  You must access another register in this general area before
    // accessing PCRTC_CONFIG
    //
    data32 = DAC_REG_RD32(NV_PCRTC_START, Head);
    DAC_FLD_WR_DRF_DEF(_PCRTC, _CONFIG, _START_ADDRESS, _NON_VGA, Head);
    
    //
    // Update arb settings for each mode set
    // test: if this is the modeset class' allocation, do arbitration setup. Else skip
    if(pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].pVidLutCurDac==(VOID_PTR)pVidLutCurDac)
    {   
        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO,"updating arb settings for modeset");
        nvHalDacUpdateArbSettings(pDev,(VOID*)&pVidLutCurDac->HalObject);
    }

    // Save the retrace start/end values (display position default)
    dacSaveMonitorDefaultPosition(pDev, Head);

    // We have successfully set a new mode. Do any os specific actions.
    // This includes any registry settings that should take effect at a mode set.
    osPostModeSet(pDev, Head);

    //
    // Determine if it's possible to support a video overlay in this resolution
    //

    //LPL: will later either add a new multichip function for multi-display,
    // or expand the parameter list on the existing fn.  For now, this hack
    // minimizes the changes to other files.
    nvHalDacValidateArbSettings(pDev, 
                                PixelDepth, 
                                1, 0, 
                                (PixelClock * 10000), Head,
                                &(pDev->Video.HalInfo.OverlayAllowed));


    //
    // Set ReadOnly CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x99, Head);

    if(IsNV0A(pDev)){
        if(pDev->Framebuffer.HalInfo.RamType == BUFFER_CRUSH_UMA){
            tmrDelay(pDev,/*U032 nsec*/100000000);
            save_sr1 &= 0xDFFF;                         // Full Bandwidth bit OFF
            WriteIndexed(NV_PRMVIO_SRX, save_sr1);      // Set bit            
        }
    }

    //
    // If we're on an NV11, restore VGA accesses to the primary device.
    //
    if (IsNV11(pDev))
    {
        if ((pDev->Chip.BiosRevision & 0xFF00FFFF) < 0x03000020)
        {
            // Not a multi-head aware BIOS, back to head 0
            EnableHead(pDev, 0);
        }
        else if (pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].PrimaryDevice == FALSE)
        {
            // Point VGA accesses back to the other (primary) head
            EnableHead(pDev, Head^1);
        }
    }
    
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NV_PCRTC_START : ",DAC_REG_RD32(NV_PCRTC_START,Head));
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NV_PCRTC_CONFIG: ",DAC_REG_RD32(NV_PCRTC_CONFIG,Head));

    //
    // Clear out panning state.
    //
    pDev->Dac.CrtcInfo[Head].CurrentPanOffset = 0;
    pDev->Video.HalInfo.PanOffsetDeltaX[Head] = 0;
    pDev->Video.HalInfo.PanOffsetDeltaY[Head] = 0;

    //
    // Finally, make sure VBlank will be serviced
    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_0, _VBLANK, _RESET, DACGETHEAD(pVidLutCurDac));
    DAC_REG_WR_DRF_DEF(_PCRTC, _INTR_EN_0, _VBLANK, _ENABLED, DACGETHEAD(pVidLutCurDac));
    pDev->Dac.CrtcInfo[DACGETHEAD(pVidLutCurDac)].StateFlags |= DAC_CRTCINFO_VBLANK_ENABLED;
    {
        volatile U032 rasterPos;
        rasterPos = REG_RD32(NV_PCRTC_RASTER + CurDacAdr(Head));
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"dacSetModeMulti,Exit, raster : ",rasterPos);

    }
    return RM_OK;
} // end of dacSetModeMulti


//
// Program the dac video parameters, and JUST the dac video parameters
//
// This routine is called primarily during VGA connect testing for
// minimal clocking
//
RM_STATUS dacSetModeMini(
    PHWINFO pDev,
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac
)
{
    U016      data,save_sr1 = 0;
    U008      shadow,data08,savedCR3D;
    volatile U032 scratch;
    
    // Extract parameters from the VIDEO_LUT_CURSOR_DAC object.
    U032      HorizontalVisible         = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    U032      HorizontalBlankStart      = pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart;
    U032      HorizontalRetraceStart    = pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart;
    U032      HorizontalRetraceEnd      = (pVidLutCurDac->HalObject.Dac[0].HorizontalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].HorizontalSyncWidth);
    U032      HorizontalBlankEnd        = (pVidLutCurDac->HalObject.Dac[0].HorizontalBlankStart +
                                           pVidLutCurDac->HalObject.Dac[0].HorizontalBlankWidth);
    U032      HorizontalTotal           = pVidLutCurDac->HalObject.Dac[0].TotalWidth;
    U032      VerticalVisible           = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
    U032      VerticalBlankStart        = pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart;
    U032      VerticalRetraceStart      = pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart;
    U032      VerticalRetraceEnd        = (pVidLutCurDac->HalObject.Dac[0].VerticalSyncStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalSyncHeight);
    U032      VerticalBlankEnd          = (pVidLutCurDac->HalObject.Dac[0].VerticalBlankStart +
                                           pVidLutCurDac->HalObject.Dac[0].VerticalBlankHeight);
    U032      VerticalTotal             = pVidLutCurDac->HalObject.Dac[0].TotalHeight;
    U032      PixelDepth                = pVidLutCurDac->HalObject.Dac[0].PixelDepth;
    U032      PixelClock                = pVidLutCurDac->HalObject.Dac[0].PixelClock;
    U032      HorizontalSyncPolarity    = pVidLutCurDac->HalObject.Dac[0].Format.HorizontalSyncPolarity;
    U032      VerticalSyncPolarity      = pVidLutCurDac->HalObject.Dac[0].Format.VerticalSyncPolarity;
    U032      DoubleScannedMode         = pVidLutCurDac->HalObject.Dac[0].Format.DoubleScanMode;
    U032      Head                      = pVidLutCurDac->HalObject.Head;
    

    //
    // There is a bug in NV hardware where the hardware cursor will not clip correctly
    // if a border is defined in the display timings (blank start != visible end).  
    // Borders are only defined in two specific DMT modes.
    //
    // To fix this, set the blank starts to match the visible totals and remove the 
    // implicit borders.
    //
    // Remove this code when the hardware gets fixed.  Since this bug has been in the 
    // hardware since 1994, don't expect a fix soon.
    //
    HorizontalBlankStart = HorizontalVisible;
    HorizontalBlankEnd   = HorizontalTotal;
    VerticalBlankStart   = VerticalVisible;
    VerticalBlankEnd     = VerticalTotal;

    //
    // Enable full CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x57, Head);

    //
    // If this is for CRTC2, set CRTC access bit and PRAMDAC address
    // This access bit controls accesses to Sequencer and Graphics Controller (C03xx).
    // CRTC and Attribute Controller must be accessed at different addresses for each head
    // (6103xx/6033xx), since there is only one bus.
    //
    if (IsNV11(pDev))
    {

        // point CR44 at this head, for the rest of the modeset
        EnableHead(pDev, Head);

        REG_WR08(NV_PRMVIO_VSE2, 1);                    // enable VGA subsystem
        data08 = REG_RD08(NV_PRMVIO_MISC__READ);
        REG_WR08(NV_PRMVIO_MISC__WRITE, data08 | 1);    // enable CGA I/O space
    }


    CRTC_RD(NV_CIO_CR_VRE_INDEX, data08, Head);
    CRTC_WR(NV_CIO_CR_VRE_INDEX, data08 & ~0x80, Head);    // unlock CR0-7

    // Before unlocking / reading CR21 we should write CR3D[0] to 1 to enable reading of
    // the shadow registers.  This will allow us to read the real CR register values from
    // the locked registers.
    CRTC_RD(0x3D, savedCR3D, Head);     // read CR3D
    savedCR3D |= 0x1;                   // set CR3D[0] to 1
    CRTC_WR(0x3D, savedCR3D, Head);     // write back CR3D[0] = 1

    CRTC_RD(0x21, shadow, Head);        // read shadow lock
    shadow |= 0xfa;                     // enable HDE, VDE, and 8/9 dot chars too, for NV5.

    // Before programming the shadow registers you must set CR3D[0] to 0
    savedCR3D &= ~0x1;                  // set CR3D[0] to 0
    CRTC_WR(0x3D, savedCR3D, Head);     // write back CR3D[0] = 0

    CRTC_WR(0x21, shadow, Head);        // write back shadow
      
    // Set H and V retrace start to a large value to prevent possible lock-up.
    // This is because if the CRTC is slaved to an external device (the TV encoder),
    // it will stall waiting for retrace start to sync up with the external clock. 
    // When we switch from TV to CRT, we may get stuck in this stall. Setting retrace 
    // start to a large value guarantees this won't happen.
    CRTC_WR(NV_CIO_CR_HRS_INDEX, 0xff, Head);
    CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xff, Head);

    //
    // Disable the visible screen
    //
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x00);               // Turn off screen at AR
        
    //
    // FullCPUOn()
    //
    data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
    data |= 0x2000;                             // Full Bandwidth bit ON
    WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit

    //
    // Set the sequencer & graphics controller values that are common for all packed-pixel
    // graphics modes.
    //            
    dacProgramSeq(pDev, Head);
    //
    // Program the CRTC & SR values for this particular mode.
    //
    dacProgramCRTC(pDev, Head, pVidLutCurDac,
                         HorizontalVisible,
                         HorizontalBlankStart,
                         HorizontalRetraceStart,
                         HorizontalRetraceEnd,
                         HorizontalBlankEnd,
                         HorizontalTotal,
                         VerticalVisible,
                         VerticalBlankStart,
                         VerticalRetraceStart,
                         VerticalRetraceEnd,
                         VerticalBlankEnd,
                         VerticalTotal,
                         PixelDepth,
                         PixelClock,
                         HorizontalSyncPolarity,
                         VerticalSyncPolarity,
                         DoubleScannedMode);


    // This code is necessary to fix a bug found where the memory controller would hang if a delay
    // was NOT inserted before turning on the display after programming the pixel clock PLL's.
    // Only required for SMA mode.
    if(IsNV0A(pDev)){
        if(pDev->Framebuffer.HalInfo.RamType == BUFFER_CRUSH_UMA){
            save_sr1 = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
            data = save_sr1;
            data |= 0x2000;                             // Full Bandwidth bit ON
            WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit
        }
    }

    //
    // Program the new VPLL clock rate
    //
    dacProgramPClk(pDev, Head, PixelClock);

    //
    // Native modes require a divide-by-2 clock ratio
    //                                    
    if (Head == 0) 
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V1SOURCE, _PROG);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB2);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK_TV, _NONE);   // assume no TV for now
    }
    else
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _V2SOURCE, _PROG);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB2);
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _NONE);  // assume no TV for now
    }
        
    if(!IsNV0A(pDev)){
        //
        // FullCpuOff()
        //
        data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
        data &= 0xDFFF;                             // Full Bandwidth bit OFF
        WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit            
    }else{
        if(pDev->Framebuffer.HalInfo.RamType != BUFFER_CRUSH_UMA){
            data = ReadIndexed(NV_PRMVIO_SRX, 0x01);    // Read SR1
            data &= 0xDFFF;                             // Full Bandwidth bit OFF
            WriteIndexed(NV_PRMVIO_SRX, data);          // Set bit            
        }
    }
    
    //
    // ATCOn()
    //
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
    REG_WR08(NV_PRMCIO_ARX, 0x20);               // Turn off screen at AR
    scratch = REG_RD32(NV_PRMCIO_INP0__COLOR);   // Reset ATC FlipFlop
      
    //
    // Set ReadOnly CRTC access
    //           
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, 0x99, Head);

    if(IsNV0A(pDev)){
        if(pDev->Framebuffer.HalInfo.RamType == BUFFER_CRUSH_UMA){
            tmrDelay(pDev,/*U032 nsec*/100000000);
            save_sr1 &= 0xDFFF;                         // Full Bandwidth bit OFF
            WriteIndexed(NV_PRMVIO_SRX, save_sr1);      // Set bit            
        }
    }

    return RM_OK;

} // end of dacSetModeMini

//
// Mobile systems may require further notifications be made to the BIOS
// that we are changing display devices.
//
RM_STATUS dacMobileDisplayNotifyBegin
(
    PHWINFO pDev,
    U032    OldDevices,
    U032    NewDevices
)
{
#if !defined(MACOS) 
    U032    EAX, EBX, ECX, EDX;
    RM_STATUS status;
    U008    lock, crtcdata;
    U032    timeHI, timeLO;
#endif

// until osCallVideoBIOS() is added to the other os's
#if !defined(MACOS) 
    //
    // If we're not running mobile, don't do this
    //
    // NOTE: We can probably stop limiting this to just Toshiba
    //
    if (!pDev->Power.MobileOperation)
        return RM_OK;

    //Removed for non-Toshiba mobiles since backlight manufacture script implementation
    //    if (pDev->Power.MobileOperation != 2)
    //            return RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: dacMobileDisplayNotifyBegin\n");

    // If we aren't switching any devices, just ignore this notification
    //
    //Keeping this in will leave one screen blank during resume from hibernation
    // when in clone or extended mode.  Doh.  Other than that, it's a good idea...
//    if (OldDevices == NewDevices)
//        return RM_OK;

    // Incurr smart delay for stalling from power on to power off
    // This fixes 32252 and 31237 - Going from Clone to Extended mode
    // we get called 3 times to change the mode.  This will slow those modechanges down.
    if (pDev->Power.MobileOperation == 2)
    {
        tmrGetCurrentTime(pDev, &timeHI, &timeLO);
        if((pDev->Dac.PanelOffTimestampHI > timeHI) ||
           ((pDev->Dac.PanelOffTimestampHI == timeHI) &&
            (pDev->Dac.PanelOffTimestampLO > timeLO)) )
        {
            // Delay the difference of the times.  Unsigned math shouldn't matter.
            // Somehow this is sending delays over 500 ms. Since in 
            // MobileDisplayEnd we set the delay to 500, this is wrong.
            // So, now, I should just delay if it's under 500 ms.
            if((pDev->Dac.PanelOffTimestampLO - timeLO) < 500000000)
              tmrDelay(pDev, (pDev->Dac.PanelOffTimestampLO - timeLO));
        }
    }

    // 
    // If the FP is involved, unconditionally turn off the backlight
    // (with more work, we probably could make this test smarter).
    //
    if ((OldDevices & TOSHIBA_FP) && (NewDevices & TOSHIBA_FP) && !(pDev->Power.Flags & DAC_POWER_PENDING))
    {
        dacBacklightOffMobilePanel(pDev);

        // 40ms delay between power and bl enable
        // I don't understand it, but it fixes bug 31339.
        // Before removing this, make sure to test 31339.
        // Well now, I'm upping the ante. We're setting this to 100 ms to fix
        // bug 31847.  So before removing this, check bug 31847 as well.
        // Now I'm making it 120 ms to fix 32383.  110 doesn't work.
        tmrDelay(pDev, 120000000);
    }

        //This is Toshiba bios specific code
    if (pDev->Power.MobileOperation == 2)
    {
        //
        // Generate a DeviceControlBegin message to the video BIOS
        // so the system knows we're about to change displays
        //
        EAX = 0x4F14;
        EBX = 0x028F;
        ECX = 0;
    
        //To know the arg order for DX, we have to check a scratch bit that tells
        // us whether this SBIOS got it right or wrong...
        lock = UnlockCRTC(pDev, 0);
        CRTC_RD(NV_CIO_CRE_SCRATCH6__INDEX, crtcdata, 0);
        RestoreLock(pDev, 0, lock);
    
        if (crtcdata & NV_CORRECT_ARG_ORDER) {
            EDX = (NewDevices << 8) | OldDevices;
        } else {
            EDX = (OldDevices << 8) | NewDevices;
        }
    
        status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
    
        // Toshiba turns off the panel if it's not used.
        if(!(NewDevices & TOSHIBA_FP))
            pDev->Dac.DevicesEnabled &= ~(DAC_PANEL_ENABLED);
    
        if (status)
            return status;
    }
#endif

    return RM_OK;
}

RM_STATUS dacMobileDisplayNotifyEnd
(
    PHWINFO pDev,
    U032    OldDevices,
    U032    NewDevices
)
{
#if !defined(MACOS)
    U032    i;
    U032    EAX, EBX, ECX, EDX;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    RM_STATUS status;
#endif

// until osCallVideoBIOS() is added to the other os's
#if !defined(MACOS)
    //
    // If we're not running mobile, don't do this
    //
    // NOTE: We can probably stop limiting this to just Toshiba
    //
    if (!pDev->Power.MobileOperation)
        return RM_OK;


    //Removed for non-Toshiba mobiles since backlight manufacture script implementation
    //    if (pDev->Power.MobileOperation != 2)
    //            return RM_OK;

    // If we aren't switching any devices, just ignore this notification
    //
//    if (OldDevices == NewDevices)
//        return RM_OK;

    DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: dacMobileDisplayNotifyEnd\n");

    if (pDev->Power.MobileOperation == 2)
    {
        //
        // Track what has been set as the active devices
        // Since this routine can exit early from about 50,000,000,000 different places, I've
        // moved this code to the begining rather than the end, since it should always be executed.
        //
        // For now just set current display type to DISPLAY_TYPE_NONE to effectively disable the 
        // code in dacMobileDisplayNotifyBegin because executing it seems to cause other problems
        // even though it shouldn't.  Need to get Toshiba's help in debugging what's going on in the
        // sbios black box.  I suspect there is a bug in there somewhere.
        //
//        if (pDev->Dac.CrtcInfo[0].pVidLutCurDac)
//            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = ((PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[0].pVidLutCurDac)->DisplayType;
//        else
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = DISPLAY_TYPE_NONE;
//        if (pDev->Dac.CrtcInfo[1].pVidLutCurDac)
//            pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType = ((PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[1].pVidLutCurDac)->DisplayType;
//        else
            pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType = DISPLAY_TYPE_NONE;
        //
        // Generate a DeviceControlEnd message to the video BIOS
        // so the system knows we're done changing displays
        //
        EAX = 0x4F14;
        EBX = 0x038F;
        ECX = 0;
        EDX = NewDevices;
        status = osCallVideoBIOS(pDev, &EAX, &EBX, &ECX, &EDX, NULL);
    
        if (status)
            return status;
    }
    else
    {
        //
        // Track what has been set as the active devices
        // Since this routine can exit early from about 50,000,000,000 different places, I've
        // moved this code to the begining rather than the end, since it should always be executed.
        //
        // For non-Toshiba, this still needs to be tracked.
        // And hopefully we can actually do the right thing on non-toshiba and actually track the
        // devices correctly (unlike on Toshiba for some reason).
        //
        if (pDev->Dac.CrtcInfo[0].pVidLutCurDac)
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = ((PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[0].pVidLutCurDac)->DisplayType;
        else
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = DISPLAY_TYPE_NONE;
        if (pDev->Dac.CrtcInfo[1].pVidLutCurDac)
            pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType = ((PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[1].pVidLutCurDac)->DisplayType;
        else
            pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType = DISPLAY_TYPE_NONE;
    }

    // APS -- added for Bug 33993 -- if we are switching to LCD and the BackLights are not on then turn them on
    if (((OldDevices & TOSHIBA_FP) && (NewDevices & TOSHIBA_FP)) || ((NewDevices & TOSHIBA_FP) && (!(pDev->Dac.DevicesEnabled & DAC_PANEL_ENABLED))))
    {
        if(!(pDev->Power.Flags & DAC_POWER_PENDING))
        {
            // For Toshiba only delay a bit to make sure that last bios call has finished up.
            // don't need for non-toshiba, so don't penalize them.
            if (pDev->Power.MobileOperation == 2)
                tmrDelay(pDev, 1000000*75); // 75ms
            // Turn on the backlight
            dacBacklightOnMobilePanel(pDev);
            pDev->Dac.DevicesEnabled |= DAC_PANEL_ENABLED;
        }

        //
        // Note: in the case of a hotkey-based DFP+TV modeset, turning on the
        // backlight displays the DFP, but for some reason turns off the TV.
        //
        // I imagine we've confused Toshiba with our manipulations of the
        // backlight to clean up the modesets. To workaround this, we'll follow
        // up with dacEnableImage calls for any heads that have modes set.
        //
        for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
        {
            pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT)pDev->Dac.CrtcInfo[i].pVidLutCurDac;
            if (pVidLutCurDac && (pVidLutCurDac->DisplayType != DISPLAY_TYPE_NONE))
                dacEnableImage(pDev, i);
        }
    }

    //We've done for all vendors except Toshiba
    if(pDev->Power.Flags & DAC_POWER_PENDING)
        return RM_OK;
    
    if (pDev->Power.MobileOperation == 2)
    {
        // Start the 500 ms smart delay for stalling from power on to power off
        // This fixes 32252 and 31237 - Going from Clone to Extended mode
        // we get called 3 times to change the mode.  This will slow those modechanges down.
        tmrGetCurrentTime(pDev, 
            &(pDev->Dac.PanelOffTimestampHI), &(pDev->Dac.PanelOffTimestampLO));
            
        // Go ahead and add the delay to the timestamp
        // Check for carry condition
        if((pDev->Dac.PanelOffTimestampLO + 500000000) < pDev->Dac.PanelOffTimestampLO)
        {
            pDev->Dac.PanelOffTimestampHI++;
        }
        pDev->Dac.PanelOffTimestampLO += 500000000;
    }
#endif

    return RM_OK;
}

// Disable slaving the CRTC to an external PCLK
// We must do this in such a way that the scanline counter doesn't stall (it can stall if unslaving during blanking)
VOID dacDisableCRTCSlave
(
    PHWINFO pDev, 
    U032    Head
)
{
        BOOL          bCrtcSlaved;
        volatile U032 retryCount, rasterPos0, rasterPos1, rasterPosBase;
        U008          data08, crHRS;
        // Set HRS to > HT, so we never get into blanking
        // This will prevent the counter from getting stalled
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data08, Head);
        CRTC_RD(NV_CIO_CR_HRS_INDEX, crHRS, Head);
        CRTC_WR(NV_CIO_CR_HRS_INDEX, data08 + 6, Head);
        tmrDelay(pDev, 1000000);
        CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data08, Head);
        bCrtcSlaved = ((data08 & 0x80) != 0);
        data08 &= ~0x84;
        CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data08, Head);
        //
        // Work around a hardware bug that's present on all chips NV20 and earlier.
        // Should be fixed in NV17/NV25.
        //
        // Only do the workaround if the crtc was slaved when 
        //
        if (bCrtcSlaved)
        {
            //
            // After clearing CR28[7] make sure the raster position counter has not gotten stuck.
            // If it has, then re-enable CR28[7] to kick start the raster position counter and try
            // again.
            // It's not elegant but none of the suggested work arounds worked. Fortunately the problem
            // is intermittent enough that a stuck raster position counter should only have to be
            // kick started once.
            //

            U032 usec     = 2000000;
            U032 retryMax = 25;
            retryCount = 0;
            rasterPosBase = REG_RD32(NV_PCRTC_RASTER + CurDacAdr(Head));
            while (bCrtcSlaved && (retryCount < retryMax))
            {
                rasterPos0 = REG_RD32(NV_PCRTC_RASTER + CurDacAdr(Head));
                tmrDelay(pDev, usec);
                rasterPos1 = REG_RD32(NV_PCRTC_RASTER + CurDacAdr(Head));
                if (rasterPos0 == rasterPos1)
                {
                    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, (data08 | 0x80), Head);
                    tmrDelay(pDev, 1000000);
                    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data08, Head);
                    retryCount++;
                }
                else
                    bCrtcSlaved = FALSE;
            }
            if (bCrtcSlaved)
            {
                //
                // failed to kick start the raster position count.
                // unslave the crtc one last time and continue on.  Hopefully nothing bad is about to happen!
                //
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data08, Head);
                DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: dacDisableCRTCSlave - Exceeded maximum retry count.  Hope nothing bad is about to happen!!\r\n");
            }
            else
            {
                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: dacDisableCRTCSlave-Unslaved,Retry count \r\n",retryCount);

            }
        }
        else
        {
            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: dacDisableCRTCSlave, not slaved \r\n");

        }
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: dacDisableCRTCSlave,   rasterPosBase : ",rasterPosBase);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: dacDisableCRTCSlave,      rasterPos0 : ",rasterPos0);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO,"NVRM: dacDisableCRTCSlave exit, rasterPos1 : ",rasterPos1);
        //
        // Restore the original value of CR_HRS.
        // During power management (monitor off) there isn't any modeset to restore this value,
        // so if it is not restored now, it will result in an incorrect tv display when the tv is
        // turned back on.
        // ***Hopefully restoring this after we've made sure that the raster counter did not get
        // ***stuck will not have any nasty side effects.
        //
        CRTC_WR(NV_CIO_CR_HRS_INDEX, crHRS, Head);
}

RM_STATUS ExtractLastModeset(PHWINFO pDev, U032 Head, PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pHalVidLutCurDac)
{
    U032 TemporaryValue;
    U032 TMVal,TNVal,TPVal;
    U032 TvA;
    U008 * pGeneric;
    U032 count;
    RM_STATUS OpStatus;
    U008 lock;
    
    lock=UnlockCRTC(pDev,Head);

    if(pHalVidLutCurDac)
    {    
        pGeneric=(U008 *)pHalVidLutCurDac;
        
        //clear the structure to all zero's
        for(count=0;count<sizeof(VIDEO_LUT_CURSOR_DAC_HAL_OBJECT);count++)
        {
            pGeneric[count]=(U008)0;
        }
        
        if(pHalVidLutCurDac)
        {
            pHalVidLutCurDac->Head=Head;
            
            pHalVidLutCurDac->Dac[0].TotalWidth = dacGetCRTC(pDev, Head, H_TOTAL);    
            pHalVidLutCurDac->Dac[0].VisibleImageWidth = dacGetCRTC(pDev, Head, H_DISPLAY_END);    
            pHalVidLutCurDac->Dac[0].HorizontalBlankStart = dacGetCRTC(pDev, Head, H_BLANK_START);    
            pHalVidLutCurDac->Dac[0].HorizontalBlankWidth = dacGetCRTC(pDev, Head, H_BLANK_END)-dacGetCRTC(pDev, Head, H_BLANK_START);    
            pHalVidLutCurDac->Dac[0].HorizontalSyncStart = dacGetCRTC(pDev, Head, H_RETRACE_START);    
            pHalVidLutCurDac->Dac[0].HorizontalSyncWidth = dacGetCRTC(pDev, Head, H_RETRACE_END)-dacGetCRTC(pDev, Head, H_RETRACE_START);    
            pHalVidLutCurDac->Dac[0].TotalHeight = dacGetCRTC(pDev, Head, V_TOTAL);    
            pHalVidLutCurDac->Dac[0].VisibleImageHeight = dacGetCRTC(pDev, Head, V_DISPLAY_END);    
            pHalVidLutCurDac->Dac[0].VerticalSyncStart = dacGetCRTC(pDev, Head, V_RETRACE_START);    
            pHalVidLutCurDac->Dac[0].VerticalSyncHeight = dacGetCRTC(pDev, Head, V_RETRACE_END)-dacGetCRTC(pDev, Head, V_RETRACE_START);    
            pHalVidLutCurDac->Dac[0].VerticalBlankStart = dacGetCRTC(pDev, Head, V_BLANK_START);    
            pHalVidLutCurDac->Dac[0].VerticalBlankHeight = dacGetCRTC(pDev, Head, V_BLANK_END)-dacGetCRTC(pDev, Head, V_BLANK_START); 
                    
            //Read raw pixel clock on NV11
            if (Head == 0) 
            {
                TemporaryValue = REG_RD32( NV_PRAMDAC_VPLL_COEFF );
                
                TMVal=DRF_VAL(_PRAMDAC,_VPLL_COEFF,_MDIV,TemporaryValue);
                TNVal=DRF_VAL(_PRAMDAC,_VPLL_COEFF,_NDIV,TemporaryValue);
                TPVal=DRF_VAL(_PRAMDAC,_VPLL_COEFF,_PDIV,TemporaryValue);
            }
            else
            {
                TemporaryValue = REG_RD32( NV_PRAMDAC_VPLL2_COEFF );
                    
                TMVal=DRF_VAL(_PRAMDAC,_VPLL2_COEFF,_MDIV,TemporaryValue);
                TNVal=DRF_VAL(_PRAMDAC,_VPLL2_COEFF,_NDIV,TemporaryValue);
                TPVal=DRF_VAL(_PRAMDAC,_VPLL2_COEFF,_PDIV,TemporaryValue);
            }
            
            pHalVidLutCurDac->Dac[0].PixelDepth=(U032)((TemporaryValue==1)?8:(TemporaryValue==2)?16:(TemporaryValue==3)?32:8);
            
            CRTC_RD(0x28,TvA,Head);
            TemporaryValue=((U032)TvA)&0x3;
            pHalVidLutCurDac->Dac[0].PixelClock=(14318180*(TNVal/TMVal))/(1<<TPVal); 
            
            //educated guess at the color format
            pHalVidLutCurDac->Dac[0].ColorFormat=(U032)((pHalVidLutCurDac->Dac[0].PixelDepth==16)?NVFF6_SET_COLOR_FORMAT_LE_X16A1R5G5B5:(pHalVidLutCurDac->Dac[0].PixelDepth==32)?NVFF6_SET_COLOR_FORMAT_LE_X24Y8:(pHalVidLutCurDac->Dac[0].PixelDepth==8)?NVFF6_SET_COLOR_FORMAT_LE_X8R8G8B8:0); 
            
            CRTC_RD(0x09,TvA,Head);
            pHalVidLutCurDac->Dac[0].Format.DoubleScanMode=(BIT(7)&((U032)TvA)?1:0);
            
            CRTC_RD(0x39,TvA,Head);
            pHalVidLutCurDac->Dac[0].Format.InterlacedMode=(((U032)TvA)==0xff?0:1);
            
            TvA=REG_RD08(NV_PRMVIO_MISC__READ);
            pHalVidLutCurDac->Dac[0].Format.HorizontalSyncPolarity=(BIT(6)&((U032)TvA)?1:0);
            pHalVidLutCurDac->Dac[0].Format.VerticalSyncPolarity=(BIT(7)&((U032)TvA)?1:0);
            
        }
        
        //this debug is always active on Mac, though I can disable it if it hurts anyone.
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Start HAL Dac Struct print out");
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: --------------------------------------------------------------------------");
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Visible Image Width     : ",pHalVidLutCurDac->Dac[0].VisibleImageWidth);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Visible Image Height    : ",pHalVidLutCurDac->Dac[0].VisibleImageHeight);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Horizontal Blank Start  : ",pHalVidLutCurDac->Dac[0].HorizontalBlankStart);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Horizontal Blank Width  : ",pHalVidLutCurDac->Dac[0].HorizontalBlankWidth);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Horizontal Sync Start   : ",pHalVidLutCurDac->Dac[0].HorizontalSyncStart);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Horizontal Sync Width   : ",pHalVidLutCurDac->Dac[0].HorizontalSyncWidth);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Vertical Blank Start    : ",pHalVidLutCurDac->Dac[0].VerticalBlankStart);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Vertical Blank Height   : ",pHalVidLutCurDac->Dac[0].VerticalBlankHeight);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Vertical Sync Start     : ",pHalVidLutCurDac->Dac[0].VerticalSyncStart);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Vertical Sync Height    : ",pHalVidLutCurDac->Dac[0].VerticalSyncHeight);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Total Width             : ",pHalVidLutCurDac->Dac[0].TotalWidth);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Total Height            : ",pHalVidLutCurDac->Dac[0].TotalHeight);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Pixel Clock             : ",pHalVidLutCurDac->Dac[0].PixelClock);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Color Format            : ",pHalVidLutCurDac->Dac[0].ColorFormat);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Pixel Depth             : ",pHalVidLutCurDac->Dac[0].PixelDepth);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Double Scan Mode        : ",pHalVidLutCurDac->Dac[0].Format.DoubleScanMode);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Interlaced Mode         : ",pHalVidLutCurDac->Dac[0].Format.DoubleScanMode);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Horizontal Sync Polarity: ",pHalVidLutCurDac->Dac[0].Format.DoubleScanMode);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Vertical Sync Polarity  : ",pHalVidLutCurDac->Dac[0].Format.DoubleScanMode);
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: --------------------------------------------------------------------------");
        
        OpStatus=RM_OK;
    }
    else
    {
        OpStatus=RM_ERROR;
    }
    
    RestoreLock(pDev,Head,lock);
    
    
    return OpStatus;
}

RM_STATUS initPVidLutCurDacStructs(PHWINFO pDev)
{
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDacObj;
    U032 count;
    RM_STATUS OpStatus=RM_OK;
    
    PHALHWINFO pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    
    pHalHwInfo=&(pDev->halHwInfo);
    pDacHalInfo=(pHalHwInfo->pDacHalInfo);
    
    //all cards have head zero, so scan all heads avail.
    for(count=0;(count<pDev->Dac.HalInfo.NumCrtcs)&&(OpStatus==RM_OK);count++)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: init vidlutcurdacs - counting");

        if(GETDISPLAYTYPE(pDev,count)!=DISPLAY_TYPE_NONE)
        {
            OpStatus = osAllocMem((VOID **) &pVidLutCurDacObj, sizeof(VIDEO_LUT_CURSOR_DAC_OBJECT));
            initRmPVidLutCurDacStructs(pDev, count, pVidLutCurDacObj);
            
            pDev->Dac.CrtcInfo[count].pVidLutCurDac=(VOID_PTR)pVidLutCurDacObj;
            
            //set the hal ptrs for this
            pDacHalInfo->CrtcInfo[count].pVidLutCurDac=&(pVidLutCurDacObj->HalObject);
            
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Good VidLutCur created on Head: ",count);
            
            /*
            //this routine assumes there can only be one flat panel on this device
            if(GETDISPLAYTYPE(pDev,count)==DISPLAY_TYPE_FLAT_PANEL)
            {
                //load in data from the registers to the pDev
                pDev->Dac.fpHActive=DAC_REG_RD32(NV_PRAMDAC_FP_HDISPLAY_END,count)+1;
                pDev->Dac.fpHDispEnd=DAC_REG_RD32(NV_PRAMDAC_FP_HDISPLAY_END,count);
                pDev->Dac.fpHValidEnd=DAC_REG_RD32(NV_PRAMDAC_FP_HVALID_END,count);
                pDev->Dac.fpHSyncStart=DAC_REG_RD32(NV_PRAMDAC_FP_HSYNC_START,count);
                pDev->Dac.fpHSyncEnd=DAC_REG_RD32(NV_PRAMDAC_FP_HSYNC_END,count);
                pDev->Dac.fpHValidStart=DAC_REG_RD32(NV_PRAMDAC_FP_HVALID_START,count);
                pDev->Dac.fpHTotal=DAC_REG_RD32(NV_PRAMDAC_FP_HTOTAL,count);
                pDev->Dac.fpVActive=DAC_REG_RD32(NV_PRAMDAC_FP_VDISPLAY_END,count)+1;
                pDev->Dac.fpVDispEnd=DAC_REG_RD32(NV_PRAMDAC_FP_VDISPLAY_END,count);
                pDev->Dac.fpVValidEnd=DAC_REG_RD32(NV_PRAMDAC_FP_VVALID_END,count);
                pDev->Dac.fpVSyncStart=DAC_REG_RD32(NV_PRAMDAC_FP_VSYNC_START,count);
                pDev->Dac.fpVSyncEnd=DAC_REG_RD32(NV_PRAMDAC_FP_VSYNC_END,count);
                pDev->Dac.fpVValidStart=DAC_REG_RD32(NV_PRAMDAC_FP_VVALID_START,count);
                pDev->Dac.fpVTotal=DAC_REG_RD32(NV_PRAMDAC_FP_VTOTAL,count);
            }
            */
        }
        else
        {
            //NULL everything to be consistent with docs in class7c
            //kill it off now while we have the chance!!!
            pDev->Dac.CrtcInfo[count].pVidLutCurDac=NULL;
            
            //set the hal ptrs for this
            pDacHalInfo->CrtcInfo[count].pVidLutCurDac=NULL;
            
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: No display on Head: ",count);
        }
    }
    
    if(OpStatus!=RM_OK)
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS,"NVRM: Error Detected: Cleaning up.\n");
        
        for(count=0;count < pDev->Dac.HalInfo.NumCrtcs; count++)
        {
            if(pDev->Dac.CrtcInfo[count].pVidLutCurDac)
            {
                //null the hal pointer
                pDacHalInfo->CrtcInfo[count].pVidLutCurDac=NULL;
                
                //free the memory
                osFreeMem((void *)pDev->Dac.CrtcInfo[count].pVidLutCurDac);
                
                //null the second pointer
                pDev->Dac.CrtcInfo[count].pVidLutCurDac=NULL;
            }
        }
    }
            
    return OpStatus;
}

RM_STATUS initRmPVidLutCurDacStructs(PHWINFO pDev, U032 Head, PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac)
{
    RM_STATUS OpStatus=RM_ERROR;  //we might be just passin' thru if we have a NULL pointer
    U032 Height,Width,PixelClock;
    U008 lock;
    
    lock=UnlockCRTC(pDev,Head);
    
    if(pVidLutCurDac)
    {
        OpStatus=RM_OK;
    
        //blank the structure
        osMemSet((void*)pVidLutCurDac,0,sizeof(VIDEO_LUT_CURSOR_DAC_OBJECT));
        
        //setup the Hal object
        ExtractLastModeset(pDev, Head, &(pVidLutCurDac->HalObject));
        
        //code stolen from dacGetDisplayType() (its statically declared)
        //get something
        pVidLutCurDac->DisplayType=GETDISPLAYTYPE(pDev,Head);
        
        //TV guys, feel free to elaborate here if you need the current function
        pVidLutCurDac->TVStandard=0;                                 // variations of NTSC and PAL
        
        //calculate RefreshRate (Pixel clock/)
        Height=pVidLutCurDac->HalObject.Dac[0].TotalHeight;
        Width=pVidLutCurDac->HalObject.Dac[0].TotalWidth;
        PixelClock=pVidLutCurDac->HalObject.Dac[0].PixelClock;
        
        pVidLutCurDac->RefreshRate=PixelClock/(Height*Width);
        
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Display Type        : ",pVidLutCurDac->DisplayType);
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS,"NVRM: Display Pixel Clock : ",pVidLutCurDac->RefreshRate);
    }
    
    RestoreLock(pDev,Head, lock);
   
    return OpStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dactv.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* DAC TV Control ****************************\
*                                                                           *
* Module: DACTV.C                                                           *
*   Mode set for TV is done here.                                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include "vga.h"
#include "i2c.h"
#include "tv.h"
#include <nvcm.h>
#include <edid.h>

extern char strDevNodeRM[];

U008 dacGetTVmode(PHWINFO, U032);

//
//  I2C  Strings
//
//---------------------------------------------------------------------------------------
// Philips


//-----------------------------------------------------------------------------
U008 Ph_Gen_Init0[] = {  
              0x01,            //subaddress 01
              0x00,            //reg 1 - load macrovision registers with 0's ???  
              0x00,            //reg 2  
              0x00,            //reg 3  
              0x00,            //reg 4  
              0x00,            //reg 5  
              0x00,            //reg 6  
              0x00,            //reg 7  
              0x00,            //reg 8  
              0x00,            //reg 9  
              0x00,            //reg a  
              0x00,            //reg b  
              0x00,            //reg c  
              0x00,            //reg d  
              0x00,            //reg e  
              0x00,            //reg f  
              0x00,            //reg 10 
              0x00,            //reg 11 
              0x00,            //reg 12 
              0x00,            //reg 13  
              0x00,            //reg 14
              0x00,            //reg 15  
              0x00,            //reg 16
              0x1b,            //reg 17
              0x1b,            //reg 18  
              0x1f,            //reg 19
              0x46,            //reg 1a
              0x00,            //reg 1b  
              0x00,            //reg 1c
              0x00,            //reg 1d  
              0x00,            //reg 1e
              0x00,            //reg 1f  
              0x00,            //reg 20
              0x1b,            //reg 21
              0x00,            //reg 22
              0x00,            //reg 23  
              0x00,            //reg 24
              0x00,            //reg 25  
              0xff,            //reg26                  
              0x3f,            //reg27                  
              0x19,            //reg28 Burst start: PAL=21h,NTSC=19h                 
              0x1d,            //reg29 Burst End: PAL=1dh,NTSC=1dh                 
              0xff,            //reg2a copy guard          
              0xff,            //reg2b copy guard          
              0x0f,            //reg2c cg data             
              0xb4,            //reg2d (clock polarity) 
              0x00,            //reg2e null             
              0x00,            //reg2f null             
              0x00,            //reg30 macro-vision     
              0x00,            //reg31 macro data 0        
              0x00,            //reg32                  
              0x00,            //reg33 data                
              0x00,            //reg34                  
              0x00,            //reg35                  
              0x00,            //reg36 data             
              0x00,            //reg37                  
              0x1a,            //reg38 RGB luma gain       
              0x1a,            //reg39 color gain diff.    
              0x00             //reg3a Color burst Enable    3Ah = 58
};
#define Ph_Gen_Init0_Len sizeof(Ph_Gen_Init0)
        
//----------------------------------------------------------------------------
U008 Ph_Gen_Init1[] = {
              0xa2,            //subaddress a2                2
              0x10,            //rega2 border color black     3   
              0x80,            //rega3 border color           4   
              0x80             //rega4 border color           5
};
#define Ph_Gen_Init1_Len sizeof(Ph_Gen_Init1)

//-----------------------------------------------------------------------------
U008 Ph_Gen_Init2[] = {
              0xfc,            
              0x03,            //regfc cursor position, move cursor off screen     
              0x98             //regfd lut off for now...         
};
#define Ph_Gen_Init2_Len sizeof(Ph_Gen_Init2)

// Format dependent init tables
// Init string 0
U008 Ph_NTSC_Init0[] = {
              0x54,            //start at address 54,
              0x01,            //reg 54 Internal PPD1 & PPD2 clock edge
              0x0f,            //reg 55
              0xc3,            //reg 56
              0x00,            //reg 57
              0x02,            //reg 58
              0x30,            //reg 59
              0x00,            //reg 5a Chrominance Phase (was 88)
              0x76,            //reg 5b
              0xa5,            //reg 5c 
              0x3a,            //reg 5d 
              0x2e,            //reg 5e 
              0x2e,            //reg 5f Cross Color Reduction (was 6e)
              0x00,            //reg 60                 
              0x15,            //reg 61 
              0x3f,            //reg 62 
              0x1f,            //reg 63 
              0x7c,            //reg 64 
              0xf0,            //reg 65  
              0x21,            //reg 66  
              0x00,            //reg 67  
              0x00,            //reg 68  
              0x00,            //reg 69  
              0x00,            //reg 6a
              0x00,            //reg 6b reserved
              0x01,            //reg 6c  
              0x20,            //reg 6d  
              0x00,            //reg 6e Blanking Control
              0x42,            //reg 6f CCN b[7:6], SCCLN b[4:0] (was 00)
              0x48,            //reg 70
              0x44,            //reg 71
              0x61,            //reg 72
              0x90,            //reg 73
              0x94,            //reg 74
              0xB0,            //reg 75
              0x78,            //reg 76
              0xf9,            //reg 77
              0x2a,            //reg 78
              0x2a,            //reg 79
              0x29,            //reg 7a >>> was 29, maybe 1d
              0x01,            //reg 7b >>> was 01, maybe f9 or de
              0x00,            //reg 7c
              0x00,            //reg 7d
              0x0c,            //reg 7e
              0x0d,            //reg 7f
              0x00,            //reg 80
              0x48,            //reg 81 >>> was 48, maybe ad
              0x2a,            //reg 82
              0x21             //reg 83
};
#define Ph_NTSC_Init0_Len sizeof(Ph_NTSC_Init0)

//-----------------------------------------------------------------------------
U008 Ph_NTSC_Init1[] = {
              0x90,            //start at address 90,
              0x5c,            //reg 90
              0x40,            //reg 91
              0x58,            //reg 92
              0x58,            //reg 93
              0x04,            //reg 94
              0xa0,            //reg 95
              0x02,            //reg 96
              0x2e,            //reg 97
              0x1f,            //reg 98
              0x13,            //reg 99
              0xf4,            //reg 9a
              0x33,            //reg 9b
              0x7f,            //reg 9c
              0x99,            //reg 9d
              0x99             //reg 9e
};
#define Ph_NTSC_Init1_Len sizeof(Ph_NTSC_Init1)

// Init string 0
U008 Ph_PAL_Init0[] = {
              0x54,            //start at address 54,
              0x01,            //reg 54 Internal PPD1 & PPD2 clock edge
              0x0f,            //reg 55
              0xc3,            //reg 56
              0x00,            //reg 57
              0x02,            //reg 58
              0x30,            //reg 59
              0x00,            //reg 5a Chrominance Phase (was 88)
              0x7d,            //reg 5b
              0xaf,            //reg 5c 
              0x33,            //reg 5d 
              0x35,            //reg 5e 
              0x75,            //reg 5f Cross Color Reduction (was 6e)
              0x00,            //reg 60                 
              0x02,            //reg 61 
              0x2f,            //reg 62 
              0xcb,            //reg 63 
              0x8a,            //reg 64 
              0x09,            //reg 65  
              0x2a,            //reg 66  
              0x00,            //reg 67  
              0x00,            //reg 68  
              0x00,            //reg 69  
              0x00,            //reg 6a
              0x00,            //reg 6b reserved
              0x01,            //reg 6c  
              0x20,            //reg 6d  
              0x00,            //reg 6e Blanking Control
              0x42,            //reg 6f CCN b[7:6], SCCLN b[4:0] (was 00)
              0x56,            //reg 70
              0x52,            //reg 71
              0x61,            //reg 72
              0x90,            //reg 73
              0x94,            //reg 74
              0xB0,            //reg 75
              0x78,            //reg 76
              0xf9,            //reg 77
              0x2a,            //reg 78
              0xfa,            //reg 79
              0x26,            //reg 7a >>> was 29, maybe 1d
              0x27,            //reg 7b >>> was 01, maybe f9 or de
              0x40,            //reg 7c
              0x00,            //reg 7d
              0x0c,            //reg 7e
              0x0d,            //reg 7f
              0x00,            //reg 80
              0x00,            //reg 81 >>> was 48, maybe ad
              0x00,            //reg 82
              0x1c             //reg 83
};
#define Ph_PAL_Init0_Len sizeof(Ph_PAL_Init0)

//-----------------------------------------------------------------------------
U008 Ph_PAL_Init1[] = {
              0x90,            //start at address 90,
              0x68,            //reg 90
              0x40,            //reg 91
              0x45,            //reg 92
              0x45,            //reg 93
              0x04,            //reg 94
              0xb8,            //reg 95
              0x02,            //reg 96
              0x2e,            //reg 97
              0x25,            //reg 98
              0x53,            //reg 99
              0xf4,            //reg 9a
              0x89,            //reg 9b
              0x8f,            //reg 9c
              0x43,            //reg 9d
              0x43,            //reg 9e
              0x4c
};
#define Ph_PAL_Init1_Len sizeof(Ph_PAL_Init1)

// Mode Tables
U008 Ph_NTSC_640[] = {
                0x70,       //start at address 70  
                0x3e,       //reg 70 Active display H Start (horizontal centering)
                0x3e,       //reg 71 Active display H End
                0x61,       //reg 72=0x61
                0x90,       //reg 73=0x90
                0x94,       //reg 74=0x94
                0xb0,       //reg 75=0xb0
                0x78,       //reg 76=0x78
                0xf9,       //reg 77=0xf9
                0x2a,       //reg 78=0x2a
                0xfa,       //reg 79=0xfa
                0x20,       //reg 7a
                0xf6,       //reg 7b
                0x00,       //reg 7c=0x00
                0x00,       //reg 7d=0x00
                0x0c,       //reg 7e=0x0c
                0x0d,       //reg 7f=0x0d
                0x00,       //reg 80=0x00
                0x00,       //reg 81  Pix clk 0
                0x00,       //reg 82  Pix clk 1
                0x20,       //reg 83  Pix Clk 2
                0x00,       //reg 84=0x00
                0x00,       //reg 85=0x00
                0x00,       //reg 86=0x00
                0x00,       //reg 87=0x00
                0x00,       //reg 88=0x00
                0x00,       //reg 89=0x00
                0x00,       //reg 8a=0x00
                0x00,       //reg 8b=0x00
                0x00,       //reg 8c=0x00
                0x00,       //reg 8d=0x00
                0x00,       //reg 8e=0x00
                0x00,       //reg 8f=0x00
                0x64,       //reg 90=0x60
                0x40,       //reg 91=0x40
                0x45,       //reg 92
                0x45,       //reg 93
                0x04,       //reg 94=0x04
                0xa0,       //reg 95=0xa0
                0x02,       //reg 96=0x02
                0x2e,       //reg 97=0x2e
                0xf9,       //reg 98=0x1f
                0x12,       //reg 99=0x13
                0x00,       //reg 9a=0x00
                0x1b,       //reg 9b
                0x70,       //reg 9c
                0x8d,       //reg 9d
                0x8d,       //reg 9e
                0x3b,       //reg 9f=0x3b
                0x00,       //reg a0=0x00
                0x00,       //reg a1=0x00
                0x10,       //reg a2 
                0x80,       //reg a3  
                0x80        //reg a4  
};
#define Ph_NTSC_Res_Len sizeof(Ph_NTSC_640)

U008 Ph_NTSC_800[] = {
                0x70,        //begin at register 70
                0x4b,        //reg 70
                0x23,        //reg 71
                0x61,        //reg 72
                0x90,        //reg 73
                0x94,        //reg 74
                0xb0,        //reg 75
                0x78,        //reg 76
                0xf9,        //reg 77
                0x2a,        //reg 78
                0xfa,        //reg 79
                0x1e,        //reg 7a
                0xf4,        //reg 7b
                0x00,        //reg 7c
                0x00,        //reg 7d
                0x0c,        //reg 7e
                0x0d,        //reg 7f
                0x00,        //reg 80
                0x00,        //reg 81 Pix clk 0
                0x00,        //reg 82 Pix clk 1
                0x40,        //reg 83 Pix clk 2
                0x00,        //reg 84
                0x00,        //reg 85
                0x00,        //reg 86
                0x00,        //reg 87
                0x00,        //reg 88
                0x00,        //reg 89
                0x00,        //reg 8a
                0x00,        //reg 8b
                0x00,        //reg 8c
                0x00,        //reg 8d
                0x00,        //reg 8e
                0x00,        //reg 8f
                0x62,        //reg 90 [Wiped out by fine adjust]
                0x90,        //reg 91
                0x51,        //reg 92
                0x51,        //reg 93
                0x04,        //reg 94
                0xb8,        //reg 95
                0x02,        //reg 96
                0x2e,        //reg 97
                0xc5,        //reg 98 HLen 
                0x64,        //reg 99 IDEL + HLen
                0x67,        //reg 9a
                0xb1,        //reg 9b
                0x5c,        //reg 9c
                0xd8,        //reg 9d
                0xd8,        //reg 9e
                0x2a,        //reg 9f
                0x00,        //reg a0
                0x00,        //reg a1
                0x10,        //reg a2
                0x80,        //reg a3
                0x80         //reg a4
};

U008 Ph_PAL_640[] = {
                0x70,       //start at address 70  
                0x81,       //reg 70=0x44
                0x59,       //reg 71=0x44
                0x61,       //reg 72=0x61
                0x90,       //reg 73=0x90
                0x94,       //reg 74=0x94
                0xb0,       //reg 75=0xb0
                0x78,       //reg 76=0x78
                0xf9,       //reg 77=0xf9
                0x2a,       //reg 78=0x2a
                0xfa,       //reg 79=0xfa
                0x26,       //reg 7a=0x29  >>> was 29, maybe 1d
                0x27,       //reg 7b=0x01  >>> was 01, maybe f9 or de
                0x40,       //reg 7c=0x00
                0x00,       //reg 7d=0x00
                0x0c,       //reg 7e=0x0c
                0x0d,       //reg 7f=0x0d
                0x00,       //reg 80=0x00
                0x00,       //reg 81=0x48  Pix clk 0
                0x00,       //reg 82=0x21  Pix clk 1
                0x1c,       //reg 83=0x21  Pix Clk 2
                0x00,       //reg 84=0x00
                0x00,       //reg 85=0x00
                0x00,       //reg 86=0x00
                0x00,       //reg 87=0x00
                0x00,       //reg 88=0x00
                0x00,       //reg 89=0x00
                0x00,       //reg 8a=0x00
                0x00,       //reg 8b=0x00
                0x00,       //reg 8c=0x00
                0x00,       //reg 8d=0x00
                0x00,       //reg 8e=0x00
                0x00,       //reg 8f=0x00
                0x68,       //reg 90=0x60
                0x40,       //reg 91=0x40
                0x45,       //reg 92=0x58  >>> was 58, maybe 3d
                0x45,       //reg 93=0x58  >>> was 58, maybe 3d
                0x04,       //reg 94=0x04
                0xb8,       //reg 95=0xa0
                0x02,       //reg 96=0x02
                0x2e,       //reg 97=0x2e
                0x25,       //reg 98=0x1f
                0x53,       //reg 99=0x13
                0x81,       //reg 9a=0x00
                0x89,       //reg 9b=0x33  >>> was 33, maybe 4e
                0x8f,       //reg 9c=0x70  >>> was 70, maybe 70
                0x43,       //reg 9d=0x99  >>> was 99, maybe a6
                0x43,       //reg 9e=0x99  >>> was 99, maybe a6
                0x4c,       //reg 9f=0x3b
                0x00,       //reg a0=0x00
                0x00,       //reg a1=0x00
                0x10,       //reg a2 
                0x80,       //reg a3  
                0x80        //reg a4  
};
#define Ph_PAL_Res_Len sizeof(Ph_PAL_640)

U008 Ph_PAL_800[] = {
                0x70,        //begin at register 70
                0x5d,        //reg 70
                0x51,        //reg 71
                0x61,        //reg 72
                0x90,        //reg 73
                0x94,        //reg 74
                0xb0,        //reg 75
                0x78,        //reg 76
                0xf9,        //reg 77
                0x2a,        //reg 78
                0xfa,        //reg 79
                0x24,        //reg 7a
                0x29,        //reg 7b
                0x40,        //reg 7c
                0x00,        //reg 7d
                0x0c,        //reg 7e
                0x0d,        //reg 7f
                0x00,        //reg 80
                0x00,        //reg 81 Pix clk 0
                0x00,        //reg 82 Pix clk 1
                0x2c,        //reg 83 Pix clk 2
                0x00,        //reg 84
                0x00,        //reg 85
                0x00,        //reg 86
                0x00,        //reg 87
                0x00,        //reg 88
                0x00,        //reg 89
                0x00,        //reg 8a
                0x00,        //reg 8b
                0x00,        //reg 8c
                0x00,        //reg 8d
                0x00,        //reg 8e
                0x00,        //reg 8f
                0x66,        //reg 90 [Wiped out by fine adjust]
                0x90,        //reg 91
                0x50,        //reg 92
                0x50,        //reg 93
                0x04,        //reg 94
                0xb8,        //reg 95
                0x02,        //reg 96
                0x2e,        //reg 97
                0x07,        //reg 98 ,LEN was 0xxff, c,anged to non-sentinel value
                0x54,        //reg 99
                0xaf,        //reg 9a
                0xf2,        //reg 9b
                0x6c,        //reg 9c
                0x77,        //reg 9d
                0x77,        //reg 9e
                0x3b,        //reg 9f
                0x00,        //reg a0
                0x00,        //reg a1
                0x10,        //reg a2
                0x80,        //reg a3
                0x80         //reg a4
};


// Autoconfigure hack
U008    Bt_NM800[] = { 0xB8, 0x02, 0xff };
U008    Bt_NM640[] = { 0xB8, 0x00, 0xff };
//
// Brooktree strings
//

//  Init string               C4    C6    C8            CA           CC             CE
U008    BT_Init[] = { 0xC4, 0x01, 0x98, BT_FLICKER_MED, BT_LUMA_DEF, BT_CHROMA_DEF, (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL), 0xff };
U008    BT871_Init[] = { 0xC4, 0x01, 0x98, BT_FLICKER_MED, BT871_LUMA_DEF, BT871_CHROMA_DEF, (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL), 0xff };

/************************************************************************************************
    We now support 6 distinct TV standards: NTSC M, NTSC J, PAL NC, PAL M, PAL N, and
    PAL B, D, G, I (which are the same as far as we are concerned).
*/
//---------------------------------------------------------------------------------------
// Brooktree 800x600

// NTSC M 800x600
U008 Bt_NM600[] = {
// 0x6e, 0xe7, 0xc2, 0x00, 0x01,
// 76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90
 0x76, 
 0xA0, 0x20, 0xB6, 0xD8, 0xB9, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF,
// 92    94    96    98    9A    9C    9E    A0    A2    A4    A6    A8    AA    AC    AE
 0x56, 0x58, 0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x0A, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA,
// B0    B2    B4    B6
 0xE8, 0xA2, 0x17, 0x00, 
 0xff};

// NTSC J 800x600
U008 Bt_NJ600[] = {
// 0x6e, 0xe7, 0xc2, 0x00, 0x01,
 0x76, 
 0xA0, 0x20, 0xB6, 0xD8, 0xB9, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF,
 0x56, 0x58, 0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x08, 0xE5, 0x74, 0x77, 0x43, 0x85, 0xBA,
 0xE8, 0xA2, 0x17, 0x00,
 0xff};

// PAL NC 800x600
U008 Bt_NC600[] = {
// 0x6e, 0xe7, 0xc2, 0x00, 0x01,
 0x76, 
 0x00, 0x20, 0xAA, 0xCA, 0xA4, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE, 
 0x5F, 0x58, 0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x24, 0xF0, 0x56, 0x7F, 0x47, 0x8C, 0x35,
 0xEF, 0x78, 0x19, 0x00,
 0xff};

// PAL B,D,G,I 800x600
U008 Bt_PA600[] = {
// 0x6e, 0x31, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x20, 0xAA, 0xCA, 0x9A, 0x0D, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE,
 0x5F, 0x58, 0x3A, 0x66, 0x96, 0x00, 0x00, 0x10, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18,
 0x28, 0x87, 0x1F, 0x00,
 0xff};

// PAL M 800x600
U008 Bt_PM600[] = {
// 0x6e, 0x31, 0x02, 0x00, 0x01,
 0x76, 
 0xA0, 0x20, 0xB6, 0xE0, 0xC2, 0x55, 0x20, 0xD8, 0x39, 0x00, 0x70, 0x42, 0x03, 0xDF,
 0x56, 0x58, 0x3A, 0xCD, 0x9C, 0x14, 0x3B, 0x11, 0x2A, 0xF0, 0x56, 0x7E, 0x47, 0x8C, 0x7E,
 0x42, 0x9C, 0x17, 0x00,
 0xff};

// PAL N 800x600
U008 Bt_PN600[] = {
// 0x6e, 0x31, 0x02, 0x00, 0x01,
0x76, 
0x00, 0x20, 0xAA, 0xCA, 0x9A, 0xF3, 0x29, 0xFC, 0x39, 0x00, 0xC0, 0x8C, 0x03, 0xEE,
0x5F, 0x58, 0x3A, 0x66, 0x56, 0x00, 0x00, 0x10, 0x2E, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x18,
0x28, 0x87, 0x1F, 0x00,
0xff};

//---------------------------------------------------------------------------------------
// Native TV modes with no overscan.  For use when playing DVD's

// Brooktree 720x480 NTSC
U008 Bt_NMDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94
    0x76, 
    0xE0, 0xD0, 0x82, 0x92, 0x5C, 0x1B, 0x13, 0xF2, 0x26, 0x00, 0x70, 0x8C, 0x03, 0x0D, 0x24, 0xE0, 
    0x36, 0x00, 0x50, 0xC5, 0x4E, 0x0C, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0xD1, 0x45, 0x17, 0x21, 
    0x00, 0xff};

U008 Bt_NJDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90    92    94
    0x76, 
    0x66, 0xD0, 0x82, 0x92, 0x5C, 0x1B, 0x13, 0xF2, 0x27, 0x00, 0x70, 0x8C, 0x03, 0x0D, 0x24, 0xE0, 
    0x36, 0x00, 0x50, 0xC5, 0x4E, 0x0C, 0x08, 0xE5, 0x76, 0x79, 0x44, 0x85, 0xD1, 0x45, 0x17, 0x21, 
    0x00, 0xff};

U008 Bt_NCDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

U008 Bt_PADVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

U008 Bt_PMDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

U008 Bt_PNDVD[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	  8E	90    92    94
    0x76,
    0xF0, 0xD0, 0x82, 0x9C, 0x5A, 0x31, 0x16, 0x22, 0xa6, 0x00, 0x78, 0x93, 0x03, 0x71, 0x2A, 0x40,
    0x3A, 0x00, 0x50, 0x55, 0x55, 0x0C, 0x24, 0xF0, 0x59, 0x82, 0x49, 0x8C, 0x8E, 0xB0, 0xE6, 0x28,
    0x00, 0xff};

//---------------------------------------------------------------------------------------

// Two no-overscan modes, which will be the default on X-box:

// Brooktree 640x480 NTSC
U008 Bt_NM480x[] = {
//    76    78    7A    7C    7E    80    82    84    86    88    8A    8C	   8E	 90
    0x76,
    0x08, 0x80, 0x72, 0x80, 0x42, 0xf1, 0x13, 0xf2, 0x26, 0x00, 0x04, 0x73, 0x03, 0x0d, 
    0x24, 0xe0, 0x00, 0x00, 0x10, 0x15, 0xcc, 0x0a, 0x0a, 0xe5, 0x77, 0x7a, 0x45, 0x85, // 92-AC
    0x81, 0x5f, 0xb8, 0x25, 0x00,             // AE-B6 (stop here: B8 is the autoconfig mode register)
    0xff};

// Brooktree 640x480 PAL. This one starts at reg 38.
U008 Bt_PA480x[] = {
// 38,   3A,   3C,   3E,   40,   42,   44,   46,   48,   4A,   4C,   4E,   50,   52,   54,   56,   58,   5A,   5C,   5E 
 0x38,
 0x00, 0x00, 0x80, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x1a, 0x01, 0x2e, 0x1a, 0x01, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00,
 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x46, 0x00, 0x01,                                  // 60-74
 0x3c, 0x80, 0x76, 0x8c, 0x44, 0x1b, 0x16, 0x20, 0xA6, 0x00, 0xB6, 0xFB, 0x03, 0x0D,    // 76-90
 0x23, 0xe0, 0x06, 0xe1, 0x4a, 0x55, 0x15, 0x0b, 0x24, 0xf0, 0x59, 0x83, 0x4a, 0x8c,    // 92-AC
 0x33, 0x98, 0x83, 0x2d, 0x00,                                                          // AE-B6
 0xff};

// Normal modes used with 868/869:

 //---------------------------------------------------------------------------------------
// Brooktree 640x480

// NTSC 640x480
U008 Bt_NM480[] = {
// 0x6e, 0x26, 0x02, 0x00, 0x01,
// 76    78    7A    7C    7E    80    82    84    86    88    8A    8C    8E    90
 0x76, 
 0x00, 0x80, 0x84, 0x9E, 0x65, 0x7D, 0x22, 0xD4, 0x27, 0x00, 0x10, 0x7E, 0x03, 0x58,
 0x4B, 0xE0, 0x36, 0x92, 0x54, 0x0E, 0x88, 0x0C, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
 0x00, 0x80, 0x20, 0x00,
 0xff};

// NTSC J 640x480
U008 Bt_NJ480[] = {
// 0x6e, 0x26, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0x9E, 0x65, 0x7D, 0x22, 0xD4, 0x27, 0x00, 0x10, 0x7E, 0x03, 0x58, 
 0x4B, 0xE0, 0x36, 0x92, 0x54, 0x0E, 0x88, 0x0C, 0x08, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
 0x00, 0x80, 0x20, 0x00,
 0xff};

// PAL NC 640x480
U008 Bt_NC480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x60, 0x80, 0x8A, 0xA6, 0x70, 0xC1, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71, 
 0x5A, 0xE0, 0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x1E,
 0xC0, 0x15, 0x1F, 0x00,
 0xff};

// PAL B,D,G,I 640x480
U008 Bt_PA480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
// 0x76, 78    7a    7c    7e    80    82    84    86    88    8a    8c    8e    90
 0x76,
 0x60, 0x80, 0x8A, 0xA6, 0x68, 0xC1, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71,
// 92    94    96    98    9a    9c    a0    a2    a4    a6    a8    aa    ac    ae    b0
 0x5A, 0xE0, 0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x24, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0x0C,
 0x8C, 0x79, 0x26, 0x00,
 0xff};

// PAL M 640x480
U008 Bt_PM480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0xA4, 0x6A, 0x7D, 0x22, 0xD4, 0x27, 0x00, 0x10, 0x7E, 0x03, 0x58, 
 0x4B, 0xE0, 0x36, 0x92, 0x54, 0x0E, 0x88, 0x0C, 0x2A, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x6E, 
 0xDB, 0x76, 0x20, 0x00,
 0xff};

// PAL N 640x480
U008 Bt_PN480[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x60, 0x80, 0x8A, 0xA6, 0x68, 0xAB, 0x2E, 0xF2, 0x27, 0x00, 0xB0, 0x0A, 0x0B, 0x71, 
 0x5A, 0xE0, 0x36, 0x00, 0x50, 0x72, 0x1C, 0x0D, 0x2E, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0x0C,
 0x8C, 0x79, 0x26, 0x00,
 0xff};

//---------------------------------------------------------------------------------------
// Brooktree 640x400

// NTSC M 640x400
U008 Bt_NM400[] = {
// 0x6e, 0xb2, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0x96, 0x60, 0x7D, 0x20, 0xD8, 0x27, 0x00, 0xC0, 0x18, 0x0B, 0xEA, 
 0x39, 0x90, 0x35, 0xDE, 0x4D, 0x0E, 0x88, 0x0C, 0x0A, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00,
 0x00, 0x80, 0x20, 0x00,
 0xff};

// NTSC J 640x400
U008 Bt_NJ400[] = {
// 0x6e, 0xc0, 0x02, 0x00, 0x01,
 0x76, 
 0x00, 0x80, 0x84, 0x96, 0x60, 0x7D, 0x20, 0xD8, 0x27, 0x00, 0xC0, 0x18, 0x0B, 0xEA, 
 0x39, 0x90, 0x35, 0xDE, 0x4D, 0x0E, 0x88, 0x0C, 0x08, 0xE5, 0x76, 0x79, 0x44, 0x85, 0x00, 
 0x00, 0x80, 0x20, 0x00,
 0xff};

// PAL NC 640x400
U008 Bt_NC400[] = {
// 0x6e, 0xc0, 0x02, 0x00, 0x01,
0x76, 
0x90, 0x80, 0x8E, 0xAA, 0x76, 0xDD, 0x35, 0xE5, 0x27, 0x00, 0x4C, 0x92, 0x0C, 0x26, 
0x5B, 0x90, 0x36, 0x29, 0x4C, 0xC7, 0x71, 0x0D, 0x24, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x6B, 
0x73, 0x50, 0x1E, 0x00, 
0xff};

// PAL B,D,G,I 640x400
U008 Bt_PA400[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
//0x76,  78    7a    7c    7e    80    82    84    86    88    8a    8c    8e    90
  0x90, 0x80, 0x8E, 0xAA, 0x6E, 0xDD, 0x35, 0xE5, 0x27, 0x00, 0x4C, 0x92, 0x0C, 0x26, 
//  92    94    96    98    9a    9c    a0    a2    a4    a6    a8    aa    ac    ae    b0
  0x5B, 0x90, 0x36, 0x29, 0x4C, 0xC7, 0x71, 0x0D, 0x24, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0xEA, 
  0x57, 0x85, 0x25, 0x00,
 0xff};

// PAL M 640x400
U008 Bt_PM400[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
// 0x76, 
 0x00, 0x80, 0x84, 0xA4, 0x6A, 0x7D, 0x20, 0xD8, 0x27, 0x00, 0xC0, 0x18, 0x0B, 0xEA, 
 0x39, 0x90, 0x35, 0xDE, 0x4D, 0x0E, 0x88, 0x0C, 0x2A, 0xF0, 0x57, 0x80, 0x48, 0x8C, 0x6E, 
 0xDB, 0x76, 0x20, 0x00,
 0xff};

// PAL N 640x400
U008 Bt_PN400[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
//0x76 
0x90, 0x80, 0x8E, 0xAA, 0x6E, 0xC5, 0x35, 0xE5, 0x27, 0x00, 0x4C, 0x92, 0x0C, 0x26, 
0x5B, 0x90, 0x36, 0x29, 0x4C, 0xC7, 0x71, 0x0D, 0x2E, 0xF0, 0x58, 0x81, 0x49, 0x8C, 0xEA, 
0x57, 0x85, 0x25, 0x00, 
0xff};


//---------------------------------------------------------------------------------------
//  Centering
//  H, V Offset. 6E = H Offset Low, 70[7,6] = H Offset High, 70[5:0] = H Sync Width
//               72 = V Offset Low, 74[5:3] = V Offset High, 74[2:0] = V Sync Width
//  NV4 Horizontal Offset should be 8 pixels less than NV5 & up (see programBrooktree()).
//---------------------------------------------------------------------------------------

// NTSC M 800x600
U008 Btc_NM600[] = {
 0x6e, 0xe0, 0xc2, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 800x600
U008 Btc_PA600[] = {
 0x6e, 0x2a, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC 720x480
U008 Btc_NMDVD[] = {
 0x6e, 0x28, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 720x576
U008 Btc_PADVD[] = {
 0x6e, 0x28, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC 640x480
U008 Btc_NM480[] = {
 0x6e, 0x1e, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 640x480
U008 Btc_PA480[] = {
 0x6e, 0xac, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 640x400
U008 Btc_NM400[] = {
 0x6e, 0xb6, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 640x400
U008 Btc_PA400[] = {
 0x6e, 0x2e, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 320x400
// CURRENTLY UNUSED
U008 Btc_NM3x4[] = {
 0x6e, 0x00, 0x42, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 320X400
U008 Btc_PA3x4[] = {
 0x6e, 0x20, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 512x384
U008 Btc_NM384[] = {
 0x6e, 0x08, 0x42, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 512x384
U008 Btc_PA384[] = {
 0x6e, 0x80, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 480x360
U008 Btc_NM360[] = {
 0x6e, 0x08, 0x42, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 480x360
U008 Btc_PA360[] = {
 0x6e, 0x80, 0x42, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 400x300
U008 Btc_NM300[] = {
 0x6e, 0xac, 0xc2, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 400x300
U008 Btc_PA300[] = {
 0x6e, 0x05, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// NTSC M 320x240
U008 Btc_NM240[] = {
 0x6e, 0xd2, 0xc2, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 320x240
U008 Btc_PA240[] = {
 0x6e, 0x60, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// Brooktree 320x200

// NTSC M 320x200
U008 Btc_NM200[] = {
 0x6e, 0x6b, 0x02, 0x00, 0x01,
 0xff};

// PAL B,D,G,I 320x200
U008 Btc_PA200[] = {
 0x6e, 0xd8, 0x02, 0x00, 0x01,
 0xff};

//---------------------------------------------------------------------------------------
// Brooktree I2C tables for TV modes 0..9
// Some modes are scanline and/or character doubled (e.g. 320x200 is really 640x400)
// Some modes do not have specific encoder tables; they use the next larger format
// (e.g. 512x384 uses 640x400).
// DVD native mode is the native TV resolution with overscan compensation disabled
// There are 3 sets of tables (400, 480, 600) times 6 TV formats.
//    320x200   320x240   320x400   400x300   480x360   512x384   640x400   640x480   800x600  DVD native
U008 *Bt_NM[] =    // NTSC M
    {Bt_NM400, Bt_NM480, Bt_NM400, Bt_NM600, Bt_NM400, Bt_NM400, Bt_NM400, Bt_NM480, Bt_NM600, Bt_NMDVD};

U008 *Bt_NJ[] =    // NTSC J
    {Bt_NJ400, Bt_NJ480, Bt_NJ400, Bt_NJ600, Bt_NJ400, Bt_NJ400, Bt_NJ400, Bt_NJ480, Bt_NJ600, Bt_NJDVD};

U008 *Bt_PM[] =    // PAL M
    {Bt_PM400, Bt_PM480, Bt_PM400, Bt_PM600, Bt_PM400, Bt_PM400, Bt_PM400, Bt_PM480, Bt_PM600, Bt_PMDVD};

U008 *Bt_PA[] =    // PAL BDHGI
    {Bt_PA400, Bt_PA480, Bt_PA400, Bt_PA600, Bt_PA400, Bt_PA400, Bt_PA400, Bt_PA480, Bt_PA600, Bt_PADVD};

U008 *Bt_PN[] =    // PAL N
    {Bt_PM400, Bt_PN480, Bt_PN400, Bt_PN600, Bt_PN400, Bt_PN400, Bt_PN400, Bt_PN480, Bt_PN600, Bt_PNDVD};

U008 *Bt_NC[] =   // PAL NC
    {Bt_NC400, Bt_NC480, Bt_NC400, Bt_NC600, Bt_NC400, Bt_NC400, Bt_NC400, Bt_NC480, Bt_NC600, Bt_NCDVD};

//---------------------------------------------------------------------------------------
// Brooktree Centering tables
// Centering is NTSC-like (NTSC-M, NTSC-J, PAL-M) or PAL-like (PAL-BDGHI, PAL-N, PAL-NC).
// There are 2 sets of tables for 6 TV formats.
//    320x200   320x240    320x400    400x300    480x360    512x384    640x400    640x480    800x600
U008 *Btc_NM[] =    // NTSC M
    {Btc_NM200, Btc_NM240, Btc_NM3x4, Btc_NM300, Btc_NM360, Btc_NM384, Btc_NM400, Btc_NM480, Btc_NM600, Btc_NMDVD};

U008 *Btc_NJ[] =    // NTSC J
    {Btc_NM400, Btc_NM480, Btc_NM3x4, Btc_NM300, Btc_NM360, Btc_NM384, Btc_NM400, Btc_NM480, Btc_NM600, Btc_NMDVD};

U008 *Btc_PM[] =   // PAL M
    {Btc_NM200, Btc_NM480, Btc_NM3x4, Btc_NM300, Btc_NM360, Btc_NM384, Btc_NM400, Btc_NM480, Btc_NM600, Btc_NMDVD};

U008 *Btc_PA[] =   // PAL BDHGI
    {Btc_PA200, Btc_PA240, Btc_PA3x4, Btc_PA300, Btc_PA360, Btc_PA384, Btc_PA400, Btc_PA480, Btc_PA600, Btc_PADVD};

U008 *Btc_PN[] =   // PAL N
    {Btc_PA200, Btc_PA480, Btc_PA3x4, Btc_PA300, Btc_PA360, Btc_PA384, Btc_PA400, Btc_PA480, Btc_PA600, Btc_PADVD};

U008 *Btc_NC[] =   // PAL NC
    {Btc_PA200, Btc_PA480, Btc_PA3x4, Btc_PA300, Btc_PA360, Btc_PA384, Btc_PA400, Btc_PA480, Btc_PA600, Btc_PADVD};


//---------------------------------------------------------------------------------------
// Brooktree Autoconfig tables
//
// Bit 0 indicates NTSC/PAL
// Bits 5:4 indicate overscan ratio, but not in a consistent way (640x480 standard is 0 for PAL and 1 for NTSC, and lower is the reverse).
#define BTAN_640x400    0x08    //001000b
#define BTAN_640x480    0x10    //010000b   Conexant has taken this out of the data sheet -- but with mode 0 we lose some pixels in horiz
#define BTAN_800x600    0x12    //010010b
#define BTAN_1024x768   0x0a    //001010b
#define BTAP_640x400    0x09    //001001b
#define BTAP_640x480    0x01    //000001b
#define BTAP_800x600    0x13    //010011b
#define BTAP_1024x768   0x0b    //001011b

//              640x400  640x480  800x600  1024x768
U008 BTA[] = {  BTAN_640x400, BTAN_640x480, BTAN_800x600, BTAN_1024x768,
                BTAP_640x400, BTAP_640x480, BTAP_800x600, BTAP_1024x768
};
#define BTA_LEN sizeof(BTA)/2

// H Sync
U008 BTHS0[] = { 0x1B, 0x19, 0xEB, 0x23,
                 0xAC, 0xAA, 0x35, 0xE5};
U008 BTHS1[] = { 0x02, 0x02, 0x02, 0x02,
                 0x02, 0x02, 0x02, 0x02};
// Coring & Attenuation
U008 BTCA0[] = { 0xC3, 0xC3, 0xC3, 0xC3,
                 0xC3, 0xC3, 0xC3, 0xC3 };
U008 BTCA1[] = { 0xC2, 0xC2, 0xC2, 0xC2,
                 0xC2, 0xC2, 0xC2, 0xC2 };
// V Active & Lines
U008 BTVAL[] = { 0x06, 0x06, 0x0A, 0x0F,
                 0x06, 0x06, 0x0B, 0x0F };
// Flicker Filter
U008 BTFF0[] = { 0x1B, 0x1B, 0x1B, 0x00,
                 0x12, 0x12, 0x1B, 0x00 };
U008 BTFF1[] = { 0x9B, 0x9B, 0x80, 0x80,
                 0x9B, 0x9B, 0x80, 0x80 };
U008 BTFF2[] = { 0xC0, 0xC0, 0x92, 0xF6,
                 0xC0, 0xC0, 0x92, 0xF6 };

//
//  Chrontel strings
//

//  The I2C init string
//  Reg 3D and reg 10[7:5] are Macrovision bits, and on the 7008 they must be cleared when the device
//  powers up (standby D3 cold) or else the clock will stop.
U008 CH_Init[] = { 0xea, CH_REG_04, 0x05, CH_REG_06, 0x40, CH_REG_0D, 0x07, CH_REG_0E, 0x0B, CH_REG_10, 
                   0x00, CH_REG_1B, 0x20, CH_REG_1C, 0xC0, CH_REG_3D, 0x00, 0xff };

CH_string  CH_NULL_STRING = {   0xff    };

//  The I2C disable string
U008    CH_Disable[] = { 0xea, CH_REG_0D, 0x03, CH_REG_0E, 0x09, 0xff };

//  Flicker filter, Brightness, and Contrast.
U008    CH_FBC[] = { 0xea, CH_REG_01, CH_FF, CH_REG_09, CH_BL, CH_REG_11, CH_CE, 0xff };

//
// Chrontel I2C timing tables. All resolutions are multiples of these modes.
// Reg A is horizontal position; Reg B is vertical position
// DEVICE REG 0       REG 7       REG A       REG B       REG13, AUTOINC TO REG 15
CH_string  CH_NTSC320X200 =
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x34, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // NTSC 320x200 (640x400)
CH_string  CH_NTSC320X240 =
{   0xea, CH_REG_00, 0x6a, CH_REG_07, 0x5C, CH_REG_0A, 0x2a, CH_REG_0B, 0x04, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3f, 0x7e, 0xff };  // NTSC 320x240 (640x480)
CH_string CH_NTSC400X300 =
{   0xea, CH_REG_00, 0x8d, CH_REG_07, 0x84, CH_REG_0A, 0x38, CH_REG_0B, 0xe8, CH_REG_13 | I2C_AUTOINC, 0x02, 0x59, 0x2E, 0xff };  // NTSC 400x300 (800x600)
CH_string  CH_NTSC480X360 =
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x34, CH_REG_0B, 0x16, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // NTSC 480x360 (640x400) 
CH_string  CH_NTSC512X384 = 
//{   0xea, CH_REG_00, 0x09, CH_REG_07, 0xd4, CH_REG_0A, 0x0a, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x63, 0x16, 0xff };  // NTSC 512x384
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x48, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // use NTSC 640x400 
CH_string  CH_NTSC640X400 =
{   0xea, CH_REG_00, 0x49, CH_REG_07, 0x70, CH_REG_0A, 0x34, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x0b, 0x16, 0xff };  // NTSC 640x400 mode 11
CH_string  CH_NTSC640X480 = 
{   0xea, CH_REG_00, 0x6A, CH_REG_07, 0x5e, CH_REG_0A, 0x2b, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3F, 0x7E, 0xff };  // NTSC 640x480 mode 17
CH_string  CH_NTSC720X480 = 
//{   0xea, CH_REG_00, 0x69, CH_REG_07, 0x46, CH_REG_0A, 0x1E, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3F, 0x6E, 0xff };
//{   0xea, CH_REG_00, 0x8C, CH_REG_07, 0x84, CH_REG_0A, 0x2D, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x13, 0x3E, 0xff };  //mode 23
{   0xea, CH_REG_00, 0x8D, CH_REG_07, 0x8E, CH_REG_0A, 0x3c, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x02, 0x59, 0x2E, 0xff };  // copy of NTSC 800x600 mode 24
CH_string  CH_NTSC720X576 = 
{   0xea, CH_REG_00, 0x8B, CH_REG_07, 0x7C, CH_REG_0A, 0x29, CH_REG_0B, 0xF4, CH_REG_13 | I2C_AUTOINC, 0x00, 0x21, 0x5E, 0xff };
CH_string  CH_NTSC800X600 = 
{   0xea, CH_REG_00, 0x8D, CH_REG_07, 0x8E, CH_REG_0A, 0x3c, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x02, 0x59, 0x2E, 0xff };  // NTSC 800x600 mode 24

// PAL values 
CH_string  CH_PAL320X200 =
{   0xea, CH_REG_00, 0x42, CH_REG_07, 0xf0, CH_REG_0A, 0x30, CH_REG_0B, 0x08, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL 320x200 (640x400)
CH_string  CH_PAL320X240 =
{   0xea, CH_REG_00, 0x61, CH_REG_07, 0xc0, CH_REG_0A, 0x38, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x04, 0x09, 0xff };  // PAL 320x240 (640x480)
CH_string  CH_PAL400X300 = 
{   0xea, CH_REG_00, 0x83, CH_REG_07, 0x8c, CH_REG_0A, 0x40, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 (800x600)
CH_string  CH_PAL480X360 = 
{   0xea, CH_REG_00, 0x42, CH_REG_07, 0x5c, CH_REG_0A, 0x40, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL  480x360 (640x400)
CH_string  CH_PAL512X384 = 
{   0xea, CH_REG_00, 0x42, CH_REG_07, 0xc0, CH_REG_0A, 0x20, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL  512x384 (640x400)
CH_string  CH_PAL640X400 = 
{   0xea, CH_REG_00, 0x42, CH_REG_07, 0xee, CH_REG_0A, 0x30, CH_REG_0B, 0x10, CH_REG_13 | I2C_AUTOINC, 0x00, 0x3d, 0x6c, 0xff };  // PAL  640x400 100
CH_string  CH_PAL640X480 = 
{   0xea, CH_REG_00, 0x61, CH_REG_07, 0x6e, CH_REG_0A, 0x34, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x04, 0x09, 0xff };  // PAL  640x480 101
CH_string  CH_PAL720X480 = 
{   0xea, CH_REG_00, 0x83, CH_REG_07, 0x7e, CH_REG_0A, 0x40, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 103
//{   0xea, CH_REG_00, 0x81, CH_REG_07, 0x84, CH_REG_0A, 0x2D, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x05, 0x39, 0x87, 0xff };  // PAL  720x480
CH_string  CH_PAL720X576 = 
{   0xea, CH_REG_00, 0x81, CH_REG_07, 0x84, CH_REG_0A, 0x2D, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x05, 0x39, 0x87, 0xff };  // PAL  720x576
CH_string  CH_PAL800X600 = 
{   0xea, CH_REG_00, 0x83, CH_REG_07, 0x7e, CH_REG_0A, 0x40, CH_REG_0B, 0x00, CH_REG_13 | I2C_AUTOINC, 0x00, 0x21, 0x56, 0xff };  // PAL  800x600 103

// FSCI data (subcarrier frequency adjustment). If reg 21 bit 0 is set, the subcarrier frequency is automatically selected.
U008 CH_FSCI_640x480[] = {0x02, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00 }; // mode 17
//U008 CH_FSCI_720x480[] = {0x01, 0x0D, 0x09, 0x0C, 0x00, 0x04, 0x06, 0x0F }; // mode 23
U008 CH_FSCI_720x480[] = {0x01, 0x09, 0x08, 0x0B, 0x03, 0x0A, 0x06, 0x03 }; // mode 24
//U008 CH_FSCI_720x576[] = {0x02, 0x05, 0x02, 0x04, 0x09, 0x0C, 0x07, 0x0A }; // mode 16
U008 CH_FSCI_720x576[] = {0x01, 0x0F, 0x01, 0x0C, 0x07, 0x0A, 0x05, 0x00 }; // mode 22
U008 CH_FSCI_800x600[] = {0x01, 0x09, 0x08, 0x0B, 0x03, 0x0A, 0x06, 0x03 }; // mode 24
U008 CH_FSCI_640x480NC[] = {0x01, 0x0f, 0x00, 0x0d, 0x05, 0x04, 0x05, 0x0e }; // PAL NC 640x480
//U008 CH_FSCI_720x480NC[] = {0x02, 0x06, 0x07, 0x09, 0x08, 0x0C, 0x00, 0x0C }; // mode 19
U008 CH_FSCI_720x480NC[] = {0x01, 0x09, 0x07, 0x08, 0x0e, 0x0f, 0x03, 0x05 }; // PAL NC 800x600
U008 CH_FSCI_720x576NC[] = {0x02, 0x06, 0x07, 0x39, 0xC8, 0x0C, 0x00, 0x0C }; // ??
U008 CH_FSCI_800x600NC[] = {0x01, 0x09, 0x07, 0x08, 0x0e, 0x0f, 0x03, 0x05 }; // PAL NC 800x600

#define numFSCIbytes    sizeof CH_FSCI_640x480

//
//  NV4 TV adjustments for Chrontel
//
TV_ADJUST CHRONTEL_NTSC[] =
{
//   hRes  vRes  SR01  CR00  CR04  CR06  CR07  CR08  CR10  CR12  CR28  encoderStringPtr,          htotal vtotal hdelay
    {320,  200,  0x09, 0x2b, 0x2b, 0x0c, 0x3e, 0x00, 0xc0, 0x8f, 0x98, (U008 *)(&CH_NTSC320X200), 0x1A4, 0x20D, 0x18},
    {320,  240,  0x09, 0x2b, 0x2b, 0x3c, 0x3e, 0x40, 0xe4, 0xdf, 0x88, (U008 *)(&CH_NTSC320X240), 0x188, 0x258, 0x0d},
    {400,  300,  0x09, 0x3d, 0x3d, 0x72, 0xf0, 0x20, 0x59, 0x57, 0x80, (U008 *)(&CH_NTSC400X300), 0x000, 0x000, 0x00},
    // 480x360 and 512x384 use 640x400 encoder mode 
    {480,  360,  0x01, 0x49, 0x40, 0x20, 0xB3, 0x00, 0x90, 0x67, 0x80, (U008 *)(&CH_NTSC480X360), 0x000, 0x000, 0x00}, 
    {512,  384,  0x01, 0x5b, 0x57, 0x3c, 0x3e, 0x00, 0xd0, 0x7f, 0x80, (U008 *)(&CH_NTSC512X384), 0x000, 0x000, 0x00},
    {640,  400,  0x01, 0x5b, 0x57, 0x3c, 0x3e, 0x00, 0xd0, 0x8f, 0x80, (U008 *)(&CH_NTSC640X400), 0x348, 0x20D, 0x03},
    {640,  480,  0x01, 0x5f, 0x5c, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x80, (U008 *)(&CH_NTSC640X480), 0x310, 0x258, 0x0d},
    {720,  480,  0x01, 0x68, 0x6f, 0x80, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_NTSC720X480), 0x428, 0x2EE, 0x00}, //correct?
    {720,  576,  0x01, 0x65, 0x6f, 0x92, 0xf0, 0x00, 0x50, 0x57, 0x80, (U008 *)(&CH_NTSC720X576), 0x410, 0x276, 0x00},
    {800,  600,  0x01, 0x76, 0x6d, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_NTSC800X600), 0x428, 0x2EE, 0x0d},
};
//
TV_ADJUST  CHRONTEL_PAL[] =
{
//   hRes  vRes  SR01  CR00  CR04  CR06  CR07  CR08  CR10  CR12  CR28  encoderStringPtr,         htotal vtotal hdelay
    {320,  200,  0x09, 0x2e, 0x29, 0x0c, 0x3e, 0x00, 0xc0, 0x8f, 0x98, (U008 *)(&CH_PAL320X200), 0x1F4, 0x1F4, 0x06},
    {320,  240,  0x09, 0x2c, 0x2a, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x88, (U008 *)(&CH_PAL320X240), 0x1A4, 0x271, 0x08},
    {400,  300,  0x09, 0x3c, 0x3c, 0xb0, 0xf0, 0x00, 0x57, 0x57, 0x80, (U008 *)(&CH_PAL400X300), 0x000, 0x000, 0x00},
    // 480x360 and 512x384 use 640x400 encoder mode
    {480,  360,  0x01, 0x49, 0x48, 0xf0, 0xB2, 0x00, 0x90, 0x67, 0x80, (U008 *)(&CH_PAL480X360), 0x000, 0x000, 0x00},
    {512,  384,  0x01, 0x75, 0x57, 0x0e, 0x3e, 0x00, 0xc0, 0x7f, 0x80, (U008 *)(&CH_PAL512X384), 0x000, 0x000, 0x00},
    {640,  400,  0x01, 0x6a, 0x56, 0x0C, 0x3e, 0x00, 0xc0, 0x8f, 0x80, (U008 *)(&CH_PAL640X400), 0x3E8, 0x1F4, 0x05},
    {640,  480,  0x01, 0x5a, 0x56, 0x3c, 0x3e, 0x00, 0xe4, 0xdf, 0x80, (U008 *)(&CH_PAL640X480), 0x348, 0x271, 0x05},
    {720,  480,  0x01, 0x74, 0x6a, 0xe0, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_PAL720X480), 0x3C0, 0x2EE, 0x05},  //copied from 720x576
//    {720,  576,  0x01, 0x6f, 0x6a, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_PAL720X576) },
//    {720,  576,  0x01, 0x65, 0x6f, 0x92, 0xf0, 0x00, 0x50, 0x57, 0x80, (U008 *)(&CH_PAL720X576) },
    {720,  576,  0x01, 0x6f, 0x6a, 0x70, 0xf0, 0x00, 0x48, 0x57, 0x80, (U008 *)(&CH_PAL720X576), 0x3B0, 0x271, 0x00},
    {800,  600,  0x01, 0x70, 0x6a, 0xb8, 0xf0, 0x00, 0x59, 0x57, 0x80, (U008 *)(&CH_PAL800X600), 0x3C0, 0x2EE, 0x05},
};
    
//
//  adjustments for Brooktree 
//
// New method eliminates most of the table entries. Only VT needs to be table driven.
// Now we can use normal CRTC values, except HRS = HDE + 1, HT = HRS + 1.
// There are some exceptions to this (see programTV()).
U008    VT_BT_NTSC[] =
   // 320x200,320x240,320x400,400x300,480x360,512x384,640x400,640x480,800x600, DVD
    { 0xd3,   0x32,   0xc8,   0xac,   0xe4,   0x39,   0xca,   0x34,   0xac,    0x0D}; 
U008    VT_BT_PAL[] =
    { 0xf5,   0x42,   0xcf,   0xb6,   0xe8,   0x5a,   0xf4,   0x43,   0xb6,    0x54};


/*************************** Helper functions *******************************/

// Read register, mask off bits, or with new value
// Write Mask is positive mask of data (e.g. use 0x14 to alter bits 4 and 2)
U008 dacTVReadModifyWrite
(
    PHWINFO pDev, 
    U032    Head,
    U008    Reg,
    U008    WriteData,
    U008    WriteMask
)
{
U008 ReadData, ack;

     // Read register
     i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) Reg); 
     i2cStart(pDev, Head, pDev->Dac.TVOutPortID); // Start w/o Stop = Restart
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
     i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &ReadData, 1);
     i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
     
     // Combine data and write
     WriteData &= WriteMask;   // just to be safe
     WriteData |= (ReadData & ~WriteMask);
     
     i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) Reg); 
     ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) WriteData); 
     i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
     
     return ReadData;
}

//  Read encoder register
//  This will work on Chrontel, Philips, and Conexant 870/871, but not 868/869
U008 dacTVReadReg
(
    PHWINFO pDev,
    U032    Head,
    U008    Reg
)
{
    U008 read;

    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID));     
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) Reg);                        // subaddress
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID+1));     
    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    return read;
}
 
static U032 dacGetTVAdjustTableArray
(
    PHWINFO pDev,
    U032 Head,
    TV_ADJUST **adjustTablePtr
)
{
    U032  numEntries;

    numEntries = 0;
    if (TV_ENCODER_FAMILY(pDev->Dac.EncoderType) == TV_ENCODER_CHRONTEL)
    {
        // Chrontel encoder.
        switch (pDev->Dac.TVStandard)
        {
            // modes with NTSC CRTC timing
            case NTSC_M:
            case NTSC_J:
            case PAL_M:
                *adjustTablePtr = (TV_ADJUST *)&CHRONTEL_NTSC;
                numEntries = sizeof(CHRONTEL_NTSC) / sizeof(TV_ADJUST);
                break;
            // modes with PAL CRTC timing
            case PAL_A:
            case PAL_N:
            case PAL_NC:
                *adjustTablePtr = (TV_ADJUST *)&CHRONTEL_PAL;
                numEntries = sizeof(CHRONTEL_PAL) / sizeof(TV_ADJUST);
                break;
        }
    }
#if 0   // this style table lookup not used
    else
    {
        // Brooktree encoder.
        if (pDev->Dac.TVStandard == NTSC)
        {
            // NTSC 
            *adjustTablePtr = (TV_ADJUST *)&BROOKTREE_NTSC;
            numEntries = sizeof(BROOKTREE_NTSC) / sizeof(TV_ADJUST);
        }
        else
        {
            // PAL
            *adjustTablePtr = (TV_ADJUST *)&BROOKTREE_PAL;
            numEntries = sizeof(BROOKTREE_PAL) / sizeof(TV_ADJUST);
        }
    }
#endif

    return numEntries;
} // end of dacGetTVAdjustTableArray

static RM_STATUS dacGetI2CModeString
(
    PHWINFO pDev, 
    U032 Head,
    U032 hRes, 
    U032 vRes,
    U008 **encoderStringPtr,
    U032 *hTotalPM, //(optional) pseudo-master mode param
    U032 *vTotalPM, //(optional) pseudo-master mode param
    U008 *hDelayPM  //(optional) pseudo-master mode param
)
{
    U032 i, numEntries;
    TV_ADJUST * adjustTable;

    numEntries = dacGetTVAdjustTableArray(pDev, Head, &adjustTable);
    for (i = 0; i < numEntries; i++)
    {
        if (adjustTable[i].hRes == hRes &&
            adjustTable[i].vRes == vRes)
        {
            // found a match.
            *encoderStringPtr = adjustTable[i].encoderString;
            if (hTotalPM) *hTotalPM = adjustTable[i].hTotalPM;
            if (vTotalPM) *vTotalPM = adjustTable[i].vTotalPM;
            if (hDelayPM) *hDelayPM = adjustTable[i].hDelayPM;

            return RM_OK;
        }
    }

    // did not find a match.
    return RM_ERROR;
} // end of dacGetI2CModeString

static RM_STATUS dacGetTVAdjustTableEntry
(
    PHWINFO pDev,
    U032 Head,
    U032 hRes,
    U032 vRes,
    TV_ADJUST **adjustTableEntry
)
{
    U032 i, numEntries;
    TV_ADJUST * adjustTable;

    numEntries = dacGetTVAdjustTableArray(pDev, Head, &adjustTable);
    for (i = 0; i < numEntries; i++)
    {
        if (adjustTable[i].hRes == hRes &&
            adjustTable[i].vRes == vRes)
        {
            // found a match.
            *adjustTableEntry = &adjustTable[i];
            return RM_OK;
        }
    }

    // did not find a match.
    return RM_ERROR;
} // end of dacGetTVAdjustTableEntry

// Autoconfiguration requires writing a single register.
// The resolution, TV standard, and overscan ration is encapsulated in this mode number.
// Currently, only "standard" overscan is used. 
// Note: in order to get non-overscan modes for 640x480, we can't use autoconfig, so I've added discrete tables.
RM_STATUS dacProgramBrooktreeAuto(PHWINFO pDev, U032 Head)
{
    U032    hRes, vRes;
    U016    status = 0;
    U008    mode, config1, config2, autoConfigMode, *strptr, i, bths0, bths_override=0;
    hRes = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
    vRes = pDev->Framebuffer.HalInfo.VertDisplayWidth;

    // generate an index into our mode table
    mode = 0; // not really needed but some compilers complain about uninitialized use
    
    switch (hRes) 
    {
        case 320:
            switch (vRes) 
            {
                case 200:
                    mode = 0;       // 640x400
                    bths0 = 0x10;   //table override
                    bths_override = 1;
                    break;
                case 240:
                    mode = 1;   // 640x480
                    bths_override = 1;
                    if (pDev->Dac.TVStandard == PAL_M)
                        bths0 = 0x00;
                    else
                        bths0 = 0x02;
                    break;
                default:
                    return RM_ERROR;
            }
            break;
        case 400:
            if (vRes == 300) 
                mode = 2; // 800x600
            else
                return RM_ERROR;
            break;
        case 480:
            if (vRes == 360) 
                mode = 1;   // 640x480
            else
                return RM_ERROR;
            break;
        case 512:
            if (vRes == 384) 
                mode = 3;   // 1024x768
            break;
        case 640:
            switch (vRes)
            {
                case 400:
                    mode = 0;   // 640x400
                    break;
                case 480:
                    mode = 1;
                    break;
                default:
                    return RM_ERROR;
            }
            break;
        case 800:
            if (vRes == 600) 
            {
                mode = 2;
                if (pDev->Dac.TVStandard == PAL_M)
                {
                    bths_override = 1;
                    bths0 = 0x3C;
                }
            }
            else
                return RM_ERROR;
            break;
        case 1024:
            if (vRes == 768) 
                mode = 3;
            else
                return RM_ERROR;
            break;
        default:
            return RM_ERROR;
    }
    // 640x480 defaults to non-overscan, for which there is no autoconfig. Use tables.
    if ((mode == 1) && pDev->Dac.TVOverscanDisabled)
    {
        // Set the auto-config mode 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CONFIG);	// subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0);	// 
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
        
        // send an init string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        strptr = (U008 *)&BT871_Init;          // send init sequence
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
            if (status)
                break;
        }     
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
        
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
                strptr = (U008 *)&Bt_NM480x;
                break;
            case PAL_NC:
            case PAL_A:
            case PAL_M:
            case PAL_N:
                strptr = (U008 *)&Bt_PA480x;                
                break;
            default:
                break;
        }
        
        // send a timing string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
            if (status)
                break;
        }
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
        
        // Toggle TIMING_RST
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x44);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
        tmrDelay(pDev, 10000000);
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xC4);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

    }
    else // do autoconfig
    {
        // Now adjust index for TV standard
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
                break;
            case PAL_NC:
            case PAL_A:
            case PAL_M:
            case PAL_N:
                mode += BTA_LEN;  // second row of table
                break;
            default:
                break;
        }
        autoConfigMode = BTA[mode];
        // The HW designer shoved a reserved bit into the middle of the config info.
        // I could account for this in the table, but I want my table to correspond to the values in the manual, and
        // if the reserved bit is ever used, we'll have to preserve it, so it's better to leave the table as is, and insert
        // into the config byte here.
        config1 = autoConfigMode & 0x07;
        config2 = autoConfigMode & 0x38;
        config2 <<= 1;   // put a 0 in bit 3
        autoConfigMode = config2 | config1;

        // Set the auto-config mode
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CONFIG);	// subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) autoConfigMode);	// 
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        strptr = (U008 *)&BT871_Init;          // send init sequence
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
            if (status)
                break;
        }     
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C
    }
    
    
    if (!bths_override)
        bths0 = BTHS0[mode];

    // Some adjustments
    // Hsync offset + width
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_HS0);	    // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) bths0);	        // 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_HS1);	    // subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTHS1[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // Coring + attenuation
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CA0);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTCA0[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CA1);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTCA1[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // VActive + VLines
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_VAL);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTVAL[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // Flicker Filter
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_FF0);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTFF0[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_FF1);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTFF1[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_FF2);	// subaddress
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BTFF2[mode]);	// 
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    // Set proper clock edge (default for autoconfig is wrong)
// This causes worse problems: the encoder is sometimes not readable after setting this.
//    dacTVReadModifyWrite(pDev, Head, 0xA0, 0x80, 0x80);
    
    // Save positioning regs. These will become our defaults
    pDev->Dac.TV871_80 = (U032)dacTVReadReg(pDev, Head, 0x80);
    pDev->Dac.TV871_82 = (U032)dacTVReadReg(pDev, Head, 0x82);
    pDev->Dac.TV871_92 = (U032)dacTVReadReg(pDev, Head, 0x92);
    pDev->Dac.TV871_98 = (U032)dacTVReadReg(pDev, Head, 0x98);
    pDev->Dac.TV871_9A = (U032)dacTVReadReg(pDev, Head, 0x9a);
    pDev->Dac.TV871_C8 = (U032)dacTVReadReg(pDev, Head, 0xC8);
    pDev->Dac.TV871_CA = (U032)dacTVReadReg(pDev, Head, 0xCA);
    pDev->Dac.TV871_CC = (U032)dacTVReadReg(pDev, Head, 0xCC);
    return(RM_OK);
}

//****************************************************************************************
//  Program the Brooktree device for a display mode
static RM_STATUS dacProgramBrooktree(PHWINFO pDev, U032 Head)
{
U016    i, status;
U008    *strptr, *strptr2;
U008    Data, TVmode;

    status = RM_OK;

    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence

    TVmode = dacGetTVmode(pDev, Head);
    // Turn DAC on
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
    status |= i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);   // subaddress
    status |= i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008) BT_DAC_ON);    // DAC ON
    i2cStop(pDev, Head,  pDev->Dac.TVOutPortID);
    tmrDelay(pDev, 20000000);   // delay 20 ms to allow DAC to power up. If we don't wait, check status could give wrong input.
    
    // Use Autoconfiguration for 871
    if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871)
    {
        dacProgramBrooktreeAuto(pDev, Head);

        // Set Check Status bit to tell encoder to check for TV connected.
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_STAT);   // set check stat
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

        // Using 871 non-legacy readback, Read Monitor Status bits into Data.
        Data = dacTVReadReg(pDev, Head, 0x6);

        // Reset Check Status -- not documented, but very important (can't program encoder if not done).
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
        if (Data & BT_MONSTAT_A)   // see if A is loaded
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF); // set check stat off, turn on all DAC's
        else
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF_A_OFF); // set check stat, turn off DAC A
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    }
    else
    {
        // send an init string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        strptr = (U008 *)&BT_Init;          // send init sequence
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
            if (status)
                break;
        }     
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

        // Get pointers to the strings to write to the I2C controller.
        // One string sets the timing for a particular resolution.
        // The other string sets the position (centering).
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
                strptr = (U008 *)Bt_NM[TVmode];
                strptr2 = (U008 *)Btc_NM[TVmode];
                break;
            case NTSC_J:
                strptr = (U008 *)Bt_NJ[TVmode];
                strptr2 = (U008 *)Btc_NJ[TVmode];
                break;
            case PAL_NC:
                strptr = (U008 *)Bt_NC[TVmode];
                strptr2 = (U008 *)Btc_NC[TVmode];
                break;
            case PAL_A:
                strptr = (U008 *)Bt_PA[TVmode];
                strptr2 = (U008 *)Btc_PA[TVmode];
                break;
            case PAL_M:
                strptr = (U008 *)Bt_PM[TVmode];
                strptr2 = (U008 *)Btc_PM[TVmode];
                break;
            case PAL_N:
                strptr = (U008 *)Bt_PN[TVmode];
                strptr2 = (U008 *)Btc_PN[TVmode];
                break;
            default:
                strptr = (U008 *)Bt_NM[TVmode];
                strptr2 = (U008 *)Btc_NM[TVmode];
                break;
        }
        // send a timing string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr != 0xff; i++)
        {
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
            if (status)
                break;
        }
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

        // send a centering string
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        for (i=0; *strptr2 != 0xff; i++)
        {
            Data = *strptr2++;
            if (i == 1) // second byte is H Offset, which differs between NV4 and NV5
            {
                if(IsNV4(pDev))
                {
                    // NV4 timing 8-16 pixels different, generally
                    if (TVmode <= TV_MODE_400x300)
                        Data -= 16;
                    else
                        Data -= 8; 
                    switch (TVmode)
                    {
                        case TV_MODE_400x300:
                            if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                                Data = 0x31;
                            break;
                        case TV_MODE_640x480:                                           
                            if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                                Data = 0xa2;
                            break;
                        case TV_MODE_800x600:
                            if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                                Data = 0x22;
                            else
                                Data = 0xd8;
                            break;
                        case TV_MODE_320x200:
                            if ((pDev->Dac.TVStandard != NTSC_M) && (pDev->Dac.TVStandard != NTSC_J))
                                Data = 0xca;
                            break;
                    }
                }
            }
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, Data);
            if (status)
                break;
        }
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         // end state for I2C

        // Set Check Status bit to tell encoder to check for TV connected.
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_STAT);   // set check stat
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

        // Set Estat to select status register 1
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xC4);  // subaddress
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x41);  // set estat (estat 01 + en_out)
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

        // Read Monitor Status bits into Data
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID+1));
        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &Data, 1);
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

        // Reset Check Status -- not documented, but very important (can't program encoder if not done).
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
        if (Data & BT_MONSTAT_A)   // see if A is loaded
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF); // set check stat off, turn on all DAC's
        else
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_CHK_OFF_A_OFF); // set check stat, turn off DAC A
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    }

    // Read registry to decide how to output on the S-video connector--do we use straight
    // S-video, or do we output composite?
    // DAC A is always composite out. DAC B and C are S-video (chroma and luma).
    // If the user has an S-video cable attached to a TV with composite input, we want
    // to output composite on the S-video (DAC C). We try to sense whether both 
    // B and C are loaded (S-video) or only C is loaded (composite).
    // Unfortunately, we may falsely detect composite even with an S-video monitor,
    // so the registry setting is necessary to override our detection.
    // Brooktree reg CE: D7  D6  D5  D4  D3  D2  D1  D0
    //                   MUX D   MUX C   MUX  B  MUX  A 
    // MUX n:   00 = output Video 0 on DAC n
    //          01 =              1
    //          10 =              2
    //          11 =              3
    // Our default init is 18 -- DAC A = mode 0, DAC B = mode 2, DAC C = mode 1
    // DAC A is always set to composite out (mode 0), which has a value of 0.
    switch (pDev->Dac.TVoutput)
    {
        case NV_CFG_VIDEO_OUTPUT_FORMAT_AUTOSELECT:
            if ((Data & BT_MONSTAT) == BT_MONSTAT_C)    // Stat A, B, C
            {
                // Set composite out on B if DAC C only is loaded.
                // Set DAC C to output composite.
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
                // mode 2 on DAC B,  mode 0 on DAC C
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_COMP | BT_OUT_MUX_C_COMP));
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            else
            {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
                // mode 2 on DAC B, mode 1 on DAC C
                status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL));    
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            break;
        case NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_COMPOSITE:
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_COMP | BT_OUT_MUX_C_COMP));   
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
        case NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_SVIDEO:
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL));    
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
        default:
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX);    // subaddress
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_OUT_MUX_B_SVID | BT_OUT_MUX_C_ALL);  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
    }

    // If no head is using TV, blank image.
    for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
        if (GETDISPLAYTYPE(pDev, i) == DISPLAY_TYPE_TV)
            break;
    if (i == pDev->Dac.HalInfo.NumCrtcs)
        dacDisableTV(pDev, Head);

    return (status);
} // end of dacProgramBrooktree

//****************************************************************************************
//
//  Program the Chrontel device for a display mode
//  args:       internal TV mode
//  returns:    status word
static RM_STATUS dacProgramChrontel(PHWINFO pDev, U032 Head)
{    
    RM_STATUS status;
    U016    i;
    U008    *strptr, FsciReg, read, hDelayPM;
    U032    hRes, vRes, reg32, hTotalPM, vTotalPM;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
   
    if (pDev->Dac.EncoderType == NV_ENCODER_NONE) 
    {
        // Used to check for known Chrontel types. Checking in dacinit now, this is probably useless.
        return ERR_I2C_UNKNOWN;
    }
    status = RM_OK;
    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence
    // Chrontel 7007 wants bit 7 of the register address set (on others it's a don't care).
        
    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    // power up
    dacEnableTV(pDev, Head);
    
    // send an init string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    strptr = (U008 *)&CH_Init;     // send init sequence
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C

    // get a pointer to the string to write to the I2C controller
    status = dacGetI2CModeString(pDev, Head, hRes, vRes, &strptr, &hTotalPM, &vTotalPM, &hDelayPM);
    if (status)
    {
        // could not get the encoder string for this mode.
        return ERR_I2C_MODE;
    }
            
    //the init string may have put put the 7007 into master mode.
    //but we may want pseudo-master mode (where we provide syncs, 7007 provides clock)
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0D);
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                                        //restart
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));    //read
    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    read |= 0x04;
    switch (pDev->Dac.EncoderType)
    {
        case NV_ENCODER_CHRONTEL_7007:
        case NV_ENCODER_CHRONTEL_7008:
            if (IsNV11(pDev) || IsNV20(pDev))
            {
                if (!pDev->Dac.TVMasterMode)
                {
                    //these sync widths apply to every mode
                    DAC_REG_WR32(NV_PRAMDAC_TV_VSYNC_START,  0x00000001, Head);
                    DAC_REG_WR32(NV_PRAMDAC_TV_VSYNC_END,    0x00000010, Head);
                    DAC_REG_WR32(NV_PRAMDAC_TV_HSYNC_START,  0x00000001, Head);
                    DAC_REG_WR32(NV_PRAMDAC_TV_HSYNC_END,    0x00000040, Head);

                    //some modes need a horizontal sync delay
                    reg32  =  DAC_REG_RD32(NV_PRAMDAC_TV_SYNC_DELAY,   Head);
                    reg32 &= ~DRF_NUM(_PRAMDAC, _TV_SYNC_DELAY, _HSYNC,  0xFFFFFFFF);
                    reg32 |=  DRF_NUM(_PRAMDAC, _TV_SYNC_DELAY, _HSYNC,  hDelayPM);
                    DAC_REG_WR32(NV_PRAMDAC_TV_SYNC_DELAY, reg32,  Head);

                    //htotal and vtotal need to match what
                    //the encoder will expect to receive.
                    reg32  =  DAC_REG_RD32(NV_PRAMDAC_TV_HTOTAL,   Head);
                    reg32 &= ~DRF_NUM(_PRAMDAC, _TV_HTOTAL, _VAL,  0xFFFFFFFF);
                    reg32 |=  DRF_NUM(_PRAMDAC, _TV_HTOTAL, _VAL,  hTotalPM);
                    DAC_REG_WR32(NV_PRAMDAC_TV_HTOTAL, reg32,  Head);

                    reg32  =  DAC_REG_RD32(NV_PRAMDAC_TV_VTOTAL,   Head);
                    reg32 &= ~DRF_NUM(_PRAMDAC, _TV_VTOTAL, _VAL,  0xFFFFFFFF);
                    reg32 |=  DRF_NUM(_PRAMDAC, _TV_VTOTAL, _VAL,  vTotalPM);
                    DAC_REG_WR32(NV_PRAMDAC_TV_VTOTAL, reg32,  Head);
                    
                    //tell Chrontel to expect syncs from the slave
                    read &= ~0x04;
                }
            }
            break;
    }

    //write modified reg 0x0D back out to hardware
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0D);
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

    // send a timing string
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
//        DBG_PRINT_STRING_VALUE (DEBUGLEVEL_TRACEINFO, " ", *strptr);
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C

    // send default flicker filter, brightness, and contrast
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    strptr = (U008 *)&CH_FBC;
    strptr++;                                  // string includes ID, skip it
    for (i=0; *strptr != 0xff; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);
        if (status)
            break;
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
    
    // Set register 21 for PAL/NTSC, and reg 3 for mode 24 (800x600 NTSC)
    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    
    // Reg 3 bit 7 set for mode 24 only. (Flicker filter used in 7/10 scaling modes)
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_03); // reg 3 
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); // 
    
    switch (pDev->Dac.TVStandard) // not supporting scaling on PAL. What happens on NTSC unscaled modes?
    {
        case NTSC_J:
        case NTSC_M:
            if ((hRes == 800) || (hRes == 720) || ((hRes == 640) && (vRes == 480)))
            {
                // 800x600 & 640x480 modes use programmed FSCI values (subcarrier frequency), others use subcarrier free-run
                // set carrier free-run bit in reg 6 and clear ACIV bit in reg 21

                // set carrier free-run bit
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // 
                read |= CH_CFR;                                             // set carrier freerun
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
                
                // Clear ACIV bit            
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); 
                
                switch (hRes)
                {
                case 800:
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_03); // reg 3 
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x80); // 
                    strptr = (U008 *)&CH_FSCI_800x600;
                    break;
                case 720:
                    if (vRes == 576) {
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_03); // reg 3 
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x80); // 
                
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_08); // reg 8
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x30); // 

                        strptr = (U008 *)&CH_FSCI_720x576;
                    } else {
                        strptr = (U008 *)&CH_FSCI_720x480;
                    }
                    break;
                case 640:
                default:
                    strptr = (U008 *)&CH_FSCI_640x480;
                    break;
                }

                FsciReg = CH_REG_18; // starting at reg 0x18
                for (i=0; i<numFSCIbytes; i++) 
                {
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, FsciReg++); // 
                    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++); // 
                }
            }
            else    // Other NTSC modes use subcarrier free run
            {
                // set ACIV 
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, 0x01); // reg 21 bit 0 = 1 -> automatically increment subcarrier
                i2cStop(pDev, Head,  pDev->Dac.TVOutPortID);                       // end state for I2C

                // clear carrier free-run bit when in ACIV mode
                i2cStart(pDev, Head,  pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                i2cStart(pDev, Head,  pDev->Dac.TVOutPortID);   // RESTART = start without previous end
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                i2cReceiveByte(pDev, Head,  pDev->Dac.TVOutPortID, &read,1);
                i2cStop(pDev, Head,  pDev->Dac.TVOutPortID);                       // 
                read &= ~CH_CFR;                                            // clear carrier freerun
                i2cStart(pDev, Head,  pDev->Dac.TVOutPortID);                      // start state for I2C
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
                status = i2cSendByte(pDev, Head,  pDev->Dac.TVOutPortID, read);  
            }
            break;
        case PAL_NC:
            // set carrier free-run bit
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // 
            read |= CH_CFR;                                             // set carrier freerun
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  

            // Clear ACIV bit            
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x00); 
            switch (hRes) 
            {
                case 640:
                case 320:
                    strptr = (U008 *)&CH_FSCI_640x480NC;
                break;
                case 720:
                    if (vRes == 576) {
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_08); // reg 8
                        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x01); // 
                        strptr = (U008 *)&CH_FSCI_720x576NC;
                    } else {
                        strptr = (U008 *)&CH_FSCI_720x480NC;
                    }
                break;
                case 800:
                case 400:
                    strptr = (U008 *)&CH_FSCI_800x600NC;
                break;
                default:
                    strptr = (U008 *)&CH_FSCI_640x480NC;    // 512x384 will fit in 640x480
            }
            FsciReg = CH_REG_18; // starting at reg 0x18
            for (i=0; i<numFSCIbytes; i++) 
            {
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, FsciReg++); // 
                status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++); // 
            }
            break;
        default:
        {
            // set ACIV 
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_21); // reg 21
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x01); // reg 21 bit 0 = 1 -> automatically increment subcarrier
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C

            // clear carrier free-run bit when in ACIV mode
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // 
            read &= ~CH_CFR;                                            // clear carrier freerun
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_06); // reg 6
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
        }
    }
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
    
    // Set gain of DAC. Read/modify/write reg 4. NTSC-M and PAL-M use one level, all others use another level.
    switch (pDev->Dac.TVStandard) 
    {
        case NTSC_M:
        case PAL_M:
        {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
            read &= CH_GAIN;                                            // set GAIN bits
            read |= CH_GAIN_NTSC;
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
            break;
        }
        default:
        {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
            read &= CH_GAIN;                                            // set GAIN bits
            read |= CH_GAIN_PAL;
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_04); // reg 4
            status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        }
    }
    // Default TV standards (in Chrontel reg 0) is 00 (PAL) or 01 (NTSC). There are 2 bits, so 4 combinations.
    // PAL B, D, G, H, I, N, NC = 00
    // NTSC-M                   = 01
    // PAL-M                    = 10
    // NTSC-J                   = 11
    
    // Set special TV standards
    if (pDev->Dac.TVStandard == NTSC_J) 
    {
        // NTSC-J should have reg 0[4:3] = 11
        // Read/Modify/Write reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        read |= CH_NTSC_J;                                          // set NTSC-J bits
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        
        // Brightness range for NTSC-J is wider
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_09); // reg 9
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_BL_J);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
    
    }
    if (pDev->Dac.TVStandard == PAL_M) 
    {
        // PAL-M should have reg 0[4:3] = 10. 
        // Read/Modify/Write reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
        i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
        read &= 0xe7;                                               // mask bits 4:3
        read |= CH_PAL_M;                                           // set PAL_M bits
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      // start state for I2C
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_00); // reg 0
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, read);  
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
    }
    // Fix for NV15/NV20: invert encoder clock out, to give NV a little more time to sample HSYNC.
    if (IsNV15orBetter(pDev)) 
    {
        // check for registry key to override this default behavior
        if (!pDev->Dac.TVClockInversionDisabled)
            dacTVReadModifyWrite(pDev, Head, CH_REG_1B, 0x10, 0x10);
    }
    return (status);
} // end of dacProgramChrontel

//****************************************************************************************
RM_STATUS dacSendEncoderString(PHWINFO pDev, U032 Head, U008 *strptr, U016 len)
{
RM_STATUS status;
U016 i;

    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   // start state for I2C
    status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
    for (i=0; i<len; i++)
    {
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, *strptr++);  
        if (status)
            break;
    }     
    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
    return (status);
}

//****************************************************************************************
//
//  Program the Philips device for a display mode
//  args:       internal TV mode
//  returns:    status word
static RM_STATUS dacProgramPhilips(PHWINFO pDev, U032 Head)
{    
    RM_STATUS status;
    U008    read, tvdacs;
    U032    hRes, vRes;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // to send a string to the I2C: send the start sequence, send the string, send the stop sequence

    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    // Send the init strings
    // Each string is a block of consecutive registers, some blocks are unique to the TV standard.
    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_Gen_Init0, Ph_Gen_Init0_Len);
    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_Gen_Init1, Ph_Gen_Init1_Len);
    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_Gen_Init2, Ph_Gen_Init2_Len);

    switch (pDev->Dac.TVStandard)
    {
        case NTSC_M:
        case NTSC_J:
            // Do NTSC init
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_Init0, Ph_NTSC_Init0_Len);
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_Init1, Ph_NTSC_Init1_Len);
            // Program the resolution    
            switch (hRes)
            {
                case 320:
                case 640:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_640, Ph_NTSC_Res_Len);
                    break;        
                case 400:
                case 800:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_800, Ph_NTSC_Res_Len);
                    break;
                default:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_NTSC_640, Ph_NTSC_Res_Len);
            }            
            break;        
        break;

        case PAL_M:
        case PAL_A:
        case PAL_N:
        case PAL_NC:
            // Do PAL init
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_Init0, Ph_PAL_Init0_Len);
            status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_Init1, Ph_PAL_Init1_Len);
            // Program the resolution    
            switch (hRes)
            {
                case 320:
                case 640:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_640, Ph_PAL_Res_Len);
                    break;        
                case 400:
                case 800:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_800, Ph_PAL_Res_Len);
                    break;
                default:
                    status = dacSendEncoderString(pDev, Head, (U008 *)&Ph_PAL_640, Ph_PAL_Res_Len);
            }            
            break;
        break;
    }

    if (pDev->Dac.EncoderType == NV_ENCODER_PHILIPS_7108B)
    {
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                      
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);  
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x54); // reg 54[1:0] = clocking mode (inverted on B)
        status = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 2);    // 1 on later devices, 2 on 7108B
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                       // end state for I2C
    }

    switch (pDev->Dac.EncoderType)
    {
        case NV_ENCODER_PHILIPS_7102:
        case NV_ENCODER_PHILIPS_7108:
        case NV_ENCODER_PHILIPS_7108B:
            //read output port control
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
            status  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x2d);
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &tvdacs,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

            switch (pDev->Dac.TVoutput)
            {
                case NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_COMPOSITE:
                    read = ~0x03;  //GREEN and BLUE connected
                    break;

                case NV_CFG_VIDEO_OUTPUT_FORMAT_FORCE_SVIDEO:
                    read = ~0x06;  //RED and GREEN connected
                    break;

                default:
                case NV_CFG_VIDEO_OUTPUT_FORMAT_AUTOSELECT:
                    //set monitor sense threshold
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    status  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1a);   // subaddress
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x46);   // MSM threshold
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    
                    //set monitor sense mode
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    status  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1b);   // subaddress
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x80);   // MSM
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

                    //read sense bits
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
                    status  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x1b);
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
                    i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);

                    //reset monitor sense mode
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    status  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1b);   // subaddress
                    status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x00);   // MSM
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                    break;
            }

            if (~read & 0x01)  //BLUE connected
                tvdacs |=  0x20;  //CVBSEN0=1  (CVBS out the blue DAC)

            switch (~read & 0x06)
            {
                case 0x02: //GREEN only
                    tvdacs |=  0x40;    //CVBSEN1=1
                    tvdacs &= ~0x80;    //VBSEN=0 (CVBS out the green DAC.)
                    break;

                case 0x06: //RED and GREEN
                    tvdacs &= ~0x40;    //CVBSEN1=0 (luminance out the green DAC.)
                    tvdacs |=  0x90;    //CEN=1, VBSEN=1 (chroma out the red DAC, luma out the green DAC.)
                    break;
            }

            //set output port control
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   
            status  = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x2d);
            status |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, tvdacs);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            break;
    }

    return (status);
} // end of dacProgramPhilips

//*************************** Exported functions *****************************************
//
//  Program the I2C device for a display mode
//  returns:    status word
RM_STATUS dacSetupTVEncoder(PHWINFO pDev, U032 Head)   
{
    RM_STATUS status;

    pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
    // Identify which part: Chrontel or Brooktree?
    // ID was done at dacInit.
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_NONE:
            status = ERR_I2C_UNKNOWN;
            break;                        
        case TV_ENCODER_BROOKTREE:
            i2cInit(pDev, Head, pDev->Dac.TVOutPortID);
            status = dacProgramBrooktree(pDev, Head);
            break;
        case TV_ENCODER_CHRONTEL:
            i2cInit(pDev, Head, pDev->Dac.TVOutPortID);
            status = dacProgramChrontel(pDev, Head);
            break;                        
        case TV_ENCODER_PHILIPS:
            i2cInit(pDev, Head, pDev->Dac.TVOutPortID);
            status = dacProgramPhilips(pDev, Head);
            break;                        
        default:
            status = ERR_I2C_UNKNOWN;
            break;                        
    }
    return (status);
}

RM_STATUS dacAdjustCRTC_CH(PHWINFO pDev, U032 Head)
{
    RM_STATUS status;
    U008    data, hbeAdjust;
    U016    data16;
    TV_ADJUST * adjustEntry;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032    hRes, vRes;
    
    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

    // Look up the array of CRTC adjustments for Chrontel
    status = dacGetTVAdjustTableEntry(pDev,Head,
                                      hRes,
                                      vRes,
                                      &adjustEntry);
    if (status)
    {
        // did not find a match.
        return status;
    }
    switch (pDev->Dac.TVStandard)
    {
        case NTSC_M:
        case NTSC_J:
            if ((hRes == 720) && (vRes == 576)) {
                CRTC_WR(NV_CIO_CR_HDT_INDEX, adjustEntry->CR00, Head);
                CRTC_WR(NV_CIO_CR_VRS_INDEX, adjustEntry->CR10, Head);
                break;
            }
            //else, fall through to next section
        case PAL_M:
            if ((hRes == 720) && (vRes == 480)) {
                CRTC_WR(NV_CIO_CR_HDT_INDEX, adjustEntry->CR00, Head);
                CRTC_WR(NV_CIO_CR_VDT_INDEX, adjustEntry->CR06, Head);
            }
            else
            {
                CRTC_WR(NV_CIO_CR_HDT_INDEX, adjustEntry->CR00, Head);
                CRTC_WR(NV_CIO_CR_HRS_INDEX, adjustEntry->CR04, Head);
                CRTC_WR(NV_CIO_CR_VDT_INDEX, adjustEntry->CR06, Head);
                CRTC_WR(NV_CIO_CR_OVL_INDEX, adjustEntry->CR07, Head);
                CRTC_WR(NV_CIO_CR_RSAL_INDEX, adjustEntry->CR08, Head);
                CRTC_WR(NV_CIO_CR_VRS_INDEX, adjustEntry->CR10, Head);
                CRTC_WR(NV_CIO_CR_VDE_INDEX, adjustEntry->CR12, Head);
                if (IsNV4(pDev))    // NV4 timing is slightly different
                {
                    if (vRes == 240) 
                        CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0x60, Head);
                    if  (vRes == 300)
                        CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0x40, Head);
                }
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);      // read pixel format
                data |= adjustEntry->CR28;        // OR with horizontal pixel adjust and slave TV to encoder
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);
                // write Seq 01
                WriteIndexed(NV_PRMVIO_SRX, (U016) ((adjustEntry->SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
            }
            break;

        case PAL_A:
        case PAL_N:
        case PAL_NC:
            CRTC_WR(NV_CIO_CR_HDT_INDEX, adjustEntry->CR00, Head);
            CRTC_WR(NV_CIO_CR_HRS_INDEX, adjustEntry->CR04, Head);
            CRTC_WR(NV_CIO_CR_VDT_INDEX, adjustEntry->CR06, Head);
            CRTC_WR(NV_CIO_CR_OVL_INDEX, adjustEntry->CR07, Head);
            CRTC_WR(NV_CIO_CR_RSAL_INDEX, adjustEntry->CR08, Head);
            CRTC_WR(NV_CIO_CR_VRS_INDEX, adjustEntry->CR10, Head);
            CRTC_WR(NV_CIO_CR_VDE_INDEX, adjustEntry->CR12, Head);
            if (IsNV4(pDev))    // NV4 timing is slightly different
            {
                if ((vRes == 200) ||
                    (vRes == 240) ||
                    (vRes == 300) ||
                    (vRes == 384))
                    CRTC_WR(NV_CIO_CR_RSAL_INDEX, 0x20, Head);
                if (vRes == 480)
                    CRTC_WR(NV_CIO_CR_HRS_INDEX, adjustEntry->CR04 + 1, Head);
            }
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);      // read pixel format
            data |= adjustEntry->CR28;           // OR with horizontal pixel adjust and slave TV to encoder
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

            // write Seq 01
            WriteIndexed(NV_PRMVIO_SRX, (U016) ((adjustEntry->SR01 << 8) | NV_PRMVIO_SR_CLOCK_INDEX));         
            break;
    }
    if (hRes == 320)
    {
        // adjust HBE = HT. This lets the cursor move across the whole screen.
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data16, Head);           // get HT (CR0)
        CRTC_RD(NV_CIO_CR_HBE_INDEX, data, Head);             // CR03
        data &= ~0x1f;                                  // lose the HBE bits
        data |= (U008) data16 & 0x1F;
        CRTC_WR(NV_CIO_CR_HBE_INDEX, data, Head);             // HBE 4:0
        pDev->Framebuffer.CursorAdjust = 8;
    }
    else
    {
        if (hRes == 400)
        {
            // 400x300
            CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);          // get CR28
            data &= ~0x38;
            CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data | (5<<3), Head); // bits[5:3] shift 5 pixels right        
            pDev->Framebuffer.CursorAdjust = 0;
            if (pDev->Dac.TVStandard == NTSC)   // PAL 400x300 requires special case for HBE for cursor position
                hbeAdjust = 4;
            else                
                hbeAdjust = 2;
        }
        else
        {
            pDev->Framebuffer.CursorAdjust = 5;
            hbeAdjust = 4;
        }
        // adjust HBE = HT + 4. This lets the cursor move across the whole screen.
        CRTC_RD(NV_CIO_CR_HDT_INDEX, data16, Head);           // get HT (CR0)
        CRTC_RD(NV_CIO_CRE_HEB__INDEX, data, Head);           // MS bit HT (CR2D)            
        if (data & 1)
            data16 |= 0x100;
        data16 += hbeAdjust;                            // HT effective
    
        CRTC_RD(NV_CIO_CR_HBE_INDEX, data, Head);             // CR03
        data &= ~0x1f;                                  // lose the HBE bits
        data |= (U008) data16 & 0x1F;
        CRTC_WR(NV_CIO_CR_HBE_INDEX, data, Head);             // HBE 4:0

        CRTC_RD(NV_CIO_CR_HRE_INDEX, data, Head);             // CR05
        data &= ~0x80;                                  // lose the HBE bit
        if (data16 & 0x20)
            data |= 0x80;
        CRTC_WR(NV_CIO_CR_HRE_INDEX, data, Head);             // HBE 5
                            
        CRTC_RD(NV_CIO_CRE_LSR_INDEX, data, Head);            // CR25
        data &= ~0x10;
        if (data16 & 0x40)
            data |= 0x10;
        CRTC_WR(NV_CIO_CRE_LSR_INDEX, data, Head);            // HBE 6
    }
    // adjust normally scanline doubled modes which are not doubled for TV
    // (512x384 and 480x360)
    if (hRes == 512 ||   // 512x384
        hRes == 480)     // 480x360
    {
        CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, 0x40, Head);
    }
    if (!IsNV4(pDev))
        pDev->Framebuffer.CursorAdjust = 0; // cursor adjust not needed 

    return status;
}

RM_STATUS dacAdjustCRTC_BT(PHWINFO pDev, U032 Head)
{
RM_STATUS status = RM_OK;
U008    tvmode, data;
U016    data16;

        // Use the "TV mode number" lookup method
        tvmode = dacGetTVmode(pDev, Head);

        // adjust normally scanline doubled modes which are not doubled for TV
        if ((tvmode == TV_MODE_512x384) | (tvmode == TV_MODE_480x360))
            CRTC_WR(NV_CIO_CR_CELL_HT_INDEX, 0x40, Head);

        if (tvmode <= TV_MODE_400x300)
            WriteIndexed(NV_PRMVIO_SRX, 0x901); // dot clock /2 for low res modes

        // Horizontal adjustment is very simple: HT = HDE + 2, HRS = HDE + 1
        CRTC_RD(NV_CIO_CR_HDE_INDEX, data, Head);           // get HDE
        CRTC_WR(NV_CIO_CR_HRS_INDEX, data + 1, Head);       // write HRS
        if (tvmode == TV_MODE_400x300)  // 400x300 is a special case
            data += 1;
        else
            data += 2;
        CRTC_WR(NV_CIO_CR_HDT_INDEX, data, Head);   // write HT=DE+2
        
        // NV10 makes us do some more special casing. The reason is that the video overlay
        // syncs to the CRTC differntly. Instead of using display end, it syncs off the blank
        // signal, so we have to make an adjustment to HBE.
        // We'll also add offsets via PVIDEO_POINT_OUT (see class63 for NV10).
        if (IsNV10orBetter(pDev)) 
        {
            if (tvmode == TV_MODE_640x480)
            {
                CRTC_WR(NV_CIO_CR_HBE_INDEX, 0x95, Head);       // write HBE
                CRTC_WR(NV_CIO_CR_HRE_INDEX, 0x1F, Head);       // write HBE msb
            }
            if (tvmode == TV_MODE_800x600)
            {
                CRTC_WR(NV_CIO_CR_HBE_INDEX, 0x89, Head);       // write HBE
                CRTC_WR(NV_CIO_CR_HRE_INDEX, 0x9A, Head);       // write HBE msb
            }
        }
        // Vertical total must be adjusted per resolution
        switch (pDev->Dac.TVStandard)
        {
            case NTSC_M:
            case NTSC_J:
            case PAL_M:
                CRTC_WR(NV_CIO_CR_VDT_INDEX, VT_BT_NTSC[ tvmode ], Head);
                break;              
            case PAL_A:
            case PAL_N:
            case PAL_NC:
                CRTC_WR(NV_CIO_CR_VDT_INDEX, VT_BT_PAL[ tvmode ], Head);
                break;
            default:
                CRTC_WR(NV_CIO_CR_VDT_INDEX, VT_BT_NTSC[ 0 ], Head);    // default to NTSC_M
        }
        if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871)
        {
            // Adjust CRTC vertical -- adjustment is dependent on mode (Conexant mode, i.e. overscan ration, as well as resolution)
            if (tvmode == TV_MODE_640x480)
            {
//                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x18, Head);   
                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x41, Head);     // normal 
//                CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xF6, Head);     
            }
            if (tvmode == TV_MODE_800x600)
            {
                switch (pDev->Dac.TVStandard)
                {
                    case PAL_NC:
                    case PAL_A:
                    case PAL_N:
                        CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x64, Head);
                        CRTC_WR(NV_CIO_CR_HDE_INDEX, 0x64, Head);
                        CRTC_WR(NV_CIO_CR_HBS_INDEX, 0x65, Head);
                        CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x65, Head);
                        CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xC5, Head);
                        break;

                    case PAL_M:     //525,60Hz PAL
                        CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x62, Head);
                        CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xC4, Head);
                        break;

                    case NTSC_M:
                    case NTSC_J:
                        // Adjust CRTC vertical
                        CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xB5, Head);
                        break;              
                }
            }
            if (tvmode == TV_MODE_1024x768)
            {
                CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x83, Head);   
                // Adjust horizontal skew
                CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);          // get CR28
                data &= ~0x38;
                CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data | (4<<3), Head); // bits[5:3] shift 4 pixels right        
            }
            if (IsNV15orBetter(pDev))   //RYAN@20010420, this might apply to older, too... but I don't know.
            {
                if (tvmode == TV_MODE_640x400)
                {
                    switch (pDev->Dac.TVStandard)
                    {
                        case PAL_M:     //525,60Hz PAL
                        case NTSC_M:
                        case NTSC_J:
                            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x62, Head);
                            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xE6, Head);
                            break;              
                    }
                }
                if (tvmode == TV_MODE_320x200)
                {
                    switch (pDev->Dac.TVStandard)
                    {
                        case PAL_M:     //525,60Hz PAL
                        case NTSC_M:
                        case NTSC_J:
                            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x2C, Head);
                            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xE5, Head);
                            break;              
                    }
                }
                if (tvmode == TV_MODE_320x240)
                {
                    //RYAN@TVOUT, it doesn't seem possible to dial these modes in perfectly.
                    //perhaps if we switch to pseudo-master mode...
                    switch (pDev->Dac.TVStandard)
                    {
                        case PAL_A:
                        case PAL_NC:
                        case PAL_N:
                            //add more front porch to the total horizontal time
                            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x3E, Head);   //increase HTOTAL
                            CRTC_WR(NV_CIO_CR_HDE_INDEX, 0x27, Head);   //start of HBLANK
                            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x38, Head);   //put sync near end of line
                            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x41, Head);
                            break;

                        case PAL_M:     //525,60Hz PAL
                            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x2E, Head);
                            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x42, Head);
                            break;

                        case NTSC_M:
                        case NTSC_J:
                            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x25, Head);
                            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x41, Head);
                            break;
                    }
                }
            }
        }
        if (tvmode == TV_MODE_480x360)  // a special case
        {
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0xe806);     // VT
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0xb207);     // extra bits
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x9010);     // VRS
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x6712);     // VDE
        }
        if (tvmode == TV_MODE_512x384)  // another special case
        {
            // On a monitor, the vertical is 768, scan doubled.
            // On the TV, we want 384.
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0x7f12);     // VDE
            WriteIndexed(NV_PRMCIO_CRX__COLOR, 0xb707);     // extra bits
        }
        // NV4 has a hw bug which requires adjustment to the cursor position
        if (IsNV4(pDev))
        {
            // adjust HBE = HT + 4. This lets the cursor move across the whole screen.
            CRTC_RD(NV_CIO_CR_HDT_INDEX, data16, Head);           // get HT (CR0)
            CRTC_RD(NV_CIO_CRE_HEB__INDEX, data, Head);           // MS bit HT (CR2D)            
            if (data & 1)
                data16 |= 0x100;
            data16 += 4;                                    // HT effective

            CRTC_RD(NV_CIO_CR_HBE_INDEX, data, Head);             // CR03
            data &= ~0x1f;                                  // lose the HBE bits
            data |= (U008) data16 & 0x1F;
            CRTC_WR(NV_CIO_CR_HBE_INDEX, data, Head);             // HBE 4:0

            CRTC_RD(NV_CIO_CR_HRE_INDEX, data, Head);             // CR05
            data &= ~0x80;                                  // lose the HBE bit
            if (data16 & 0x20)
                data |= 0x80;
            CRTC_WR(NV_CIO_CR_HRE_INDEX, data, Head);             // HBE 5
                            
            CRTC_RD(NV_CIO_CRE_LSR_INDEX, data, Head);            // CR25
            data &= ~0x10;
            if (data16 & 0x40)
                data |= 0x10;
            CRTC_WR(NV_CIO_CRE_LSR_INDEX, data, Head);            // HBE 6
            switch (tvmode)
            {
                // modes which are shoehorned in to 640x400 need a horiz cursor adjustment
                case TV_MODE_512x384:
                case TV_MODE_480x360:
                // likewise 640 modes
                case TV_MODE_640x400:
                case TV_MODE_640x480:
                case TV_MODE_800x600:
                    pDev->Framebuffer.CursorAdjust = 5;
                    break;          
                default:
                    pDev->Framebuffer.CursorAdjust = 0;
            }
        }
        return status;
} 


void dacSetTvoutLatency(PHWINFO pDev, U032 Head, U008 latency)
{
    U008 data;

    latency &= 0x07;

    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);
    data &= ~0x38;
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data | (latency<<3), Head); // bits[5:3]
}


RM_STATUS dacAdjustCRTC_PH(PHWINFO pDev, U032 Head)
{
    RM_STATUS status = RM_OK;

    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;
    U032    hRes, vRes, std;

    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;

#define NV_ARCH(pDev) ((pDev->halHwInfo.pMcHalInfo->Architecture & 0x30)   >> 4) //2 bits
#define NV_IMPL(pDev) ((pDev->halHwInfo.pMcHalInfo->Implementation & 0x07) >> 0) //3 bits
#define NV_CHIP(pDev) ((NV_ARCH(pDev) << 3) | NV_IMPL(pDev))  //5 bits

#define TV_CHIPMASK 0xFE000000  /* 7  bits */
#define TV_HRESMASK 0x01FFC000  /* 11 bits */
#define TV_VRESMASK 0x00003FF8  /* 11 bits */
#define TV_STDMASK  0x00000007  /* 3  bits */

#define NV11 (((MC_ARCHITECTURE_NV10 & 0x30)>>1) | (MC_IMPLEMENTATION_NV11 & 0x07))
#define NV20 (((MC_ARCHITECTURE_NV20 & 0x30)>>1) | (MC_IMPLEMENTATION_NV20 & 0x07))

#define PDEV_TVMODE(pDev, h, v, std) ((NV_CHIP(pDev)<<27) | (((h-1)&0x7FF)<<14) | (((v-1)&0x7FF)<<3) | (std&0x07))
#define TV_MODE(nv, h, v, std)       ((nv<<27)            | (((h-1)&0x7FF)<<14) | (((v-1)&0x7FF)<<3) | (std&0x07))

    //special handling for certain low-res modes.
    switch (hRes)
    {
        case 320:
        case 400:
            WriteIndexed(NV_PRMVIO_SRX, 0x901); // dot clock /2 for low res modes
            break;
    }

    //PAL_Nc only differs from PAL_BDGHI by its color subcarrier.
    std = pDev->Dac.TVStandard;
    if (std == PAL_NC) { std = PAL_A; }
    if (std == PAL_M)  { std = NTSC_M; }

    //RYAN@TV: TODO: PAL_N tweakage (need Uruguay TV)
    //RYAN@TV: TODO: Try to compact this code a little more

    switch (PDEV_TVMODE(pDev, hRes, vRes, std))
    {
        case TV_MODE(NV11, 320, 200, PAL_N):
        case TV_MODE(NV11, 320, 200, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x30, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xD4, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x90, Head);   // CR10
            //vertical scale is too narrow
            break;

        case TV_MODE(NV20, 320, 200, PAL_N):
        case TV_MODE(NV20, 320, 200, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x30, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xD4, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x90, Head);   // CR10
            //vertical scale is too narrow
            //image needs moved to the left a little, but this seems to be impossible with CRTCs
            break;

        case TV_MODE(NV11, 320, 200, NTSC_M):
        case TV_MODE(NV11, 320, 200, NTSC_J):
        case TV_MODE(NV20, 320, 200, NTSC_M):
        case TV_MODE(NV20, 320, 200, NTSC_J):
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x27, Head);   // CR0
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xDE, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x9A, Head);   // CR10
            //image needs moved to the left a little, but this seems to be impossible with CRTCs
            break;

        case TV_MODE(NV11, 320, 240, PAL_N):
        case TV_MODE(NV11, 320, 240, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x30, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x24, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xE0, Head);   // CR10
            break;

        case TV_MODE(NV20, 320, 240, PAL_N):
        case TV_MODE(NV20, 320, 240, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x30, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x24, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xE0, Head);   // CR10
            //image needs moved to the left a little, but this seems to be impossible with CRTCs
            break;

        case TV_MODE(NV11, 320, 240, NTSC_M):
        case TV_MODE(NV11, 320, 240, NTSC_J):
        case TV_MODE(NV20, 320, 240, NTSC_M):
        case TV_MODE(NV20, 320, 240, NTSC_J):
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x27, Head);   // CR0
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x2C, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xE8, Head);   // CR10
            //image needs moved to the left a little, but this seems to be impossible with CRTCs
            break;

        case TV_MODE(NV11, 640, 400, PAL_N):
        case TV_MODE(NV11, 640, 400, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x5D, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xEF, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x8F, Head);   // CR10
            dacSetTvoutLatency(pDev, Head, 1);
            //vertical scale is too narrow
            break;
        
        case TV_MODE(NV20, 640, 400, PAL_N):
        case TV_MODE(NV20, 640, 400, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x5E, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xEF, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x8F, Head);   // CR10
            dacSetTvoutLatency(pDev, Head, 6);
            //vertical scale is too narrow
            break;

        case TV_MODE(NV11, 640, 400, NTSC_M):
        case TV_MODE(NV11, 640, 400, NTSC_J):
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x53, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xDC, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x90, Head);   // CR10
            dacSetTvoutLatency(pDev, Head, 7);
            //vertical scale is narrow
            //horizontal scale is too wide
            break;

        case TV_MODE(NV20, 640, 400, NTSC_M):
        case TV_MODE(NV20, 640, 400, NTSC_J):
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x53, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xDC, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0x90, Head);   // CR10
            dacSetTvoutLatency(pDev, Head, 4);
            //vertical scale is narrow
            //horizontal scale is too wide
            break;

        case TV_MODE(NV11, 640, 480, PAL_N):
        case TV_MODE(NV11, 640, 480, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x5D, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x25, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xDF, Head);   // CR10
            dacSetTvoutLatency(pDev, Head, 1);
            break;

        case TV_MODE(NV20, 640, 480, PAL_N):
        case TV_MODE(NV20, 640, 480, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x5E, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x25, Head);   // CR6
            CRTC_WR(NV_CIO_CR_VRS_INDEX, 0xDF, Head);   // CR10
            dacSetTvoutLatency(pDev, Head, 6);
            break;

        case TV_MODE(NV11, 640, 480, NTSC_M):
        case TV_MODE(NV11, 640, 480, NTSC_J):
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x53, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x2F, Head);   // CR6
            dacSetTvoutLatency(pDev, Head, 7);
            //horizontal scale is too wide
            break;

        case TV_MODE(NV20, 640, 480, NTSC_M):
        case TV_MODE(NV20, 640, 480, NTSC_J):
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x53, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x2F, Head);   // CR6
            dacSetTvoutLatency(pDev, Head, 4);
            //horizontal scale is too wide
            break;

        case TV_MODE(NV11, 800, 600, PAL_N):
        case TV_MODE(NV11, 800, 600, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x7D, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xA8, Head);   // CR6
            dacSetTvoutLatency(pDev, Head, 5);
            break;

        case TV_MODE(NV20, 800, 600, PAL_N):
        case TV_MODE(NV20, 800, 600, PAL_A):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x7D, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xA8, Head);   // CR6
            dacSetTvoutLatency(pDev, Head, 2);
            break;

        case TV_MODE(NV11, 800, 600, NTSC_M):
        case TV_MODE(NV11, 800, 600, NTSC_J):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x7E, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xA9, Head);   // CR6
            dacSetTvoutLatency(pDev, Head, 4);
            break;

        case TV_MODE(NV20, 800, 600, NTSC_M):
        case TV_MODE(NV20, 800, 600, NTSC_J):
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x7E, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0xA9, Head);   // CR6
            dacSetTvoutLatency(pDev, Head, 1);
            break;

        default:  //RYAN@TV, what is this for?!?
            CRTC_WR(NV_CIO_CR_HDT_INDEX, 0x54, Head);   // CR0
            CRTC_WR(NV_CIO_CR_HRS_INDEX, 0x52, Head);   // CR4
            CRTC_WR(NV_CIO_CR_VDT_INDEX, 0x30, Head);   // CR6
            break;
    }
    return status;

#undef NV11
#undef NV20
}

RM_STATUS dacAdjustCRTCForTV(PHWINFO pDev, U032 Head)
{
    U008    data, lock;
    U032    hRes, vRes;
    PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

    // Get resolution
    pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
    hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
    vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
    
    CRTC_WR(NV_CIO_CRE_FFLWM__INDEX, 0x20, Head);     // if TV, we can fix low water mark at 20.
    
    // slave the CRTC clock to the encoder
    CRTC_RD(NV_CIO_CRE_LCD__INDEX, data, Head);
    data &= ~(DRF_MASK(NV_CIO_CRE_LCD_LCD_SELECT) << DRF_SHIFT(NV_CIO_CRE_LCD_LCD_SELECT)); // don't slave to LCD
    data &= ~(DRF_MASK(NV_CIO_CRE_LCD_EXT_SELECT) << DRF_SHIFT(NV_CIO_CRE_LCD_EXT_SELECT)); // don't drive LCD ext data pins
    CRTC_WR(NV_CIO_CRE_LCD__INDEX, data, Head); // clear LCD bits
    
    // Toshiba SBIOS behaves badly: it may lock ext CRTC's on us during SMI.
    lock = UnlockCRTC(pDev, 0);
    if (lock != NV_CIO_SR_UNLOCK_RW_VALUE) 
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ext CRTC's are locked in dacAdjustCRTCForTV\r\n");
    }
    CRTC_RD(NV_CIO_CRE_PIXEL_INDEX, data, Head);
    data |= 0x80;       // slave mode
    data &= ~0x38;      // clear the pixel skew
    CRTC_WR(NV_CIO_CRE_PIXEL_INDEX, data, Head);

    //  fix up CRTC timing per encoder
    //  NOTE: Brooktree and Chrontel have incompatible CRTC and encoder tables.
    //  Until this is resolved, this code is going to be ugly.
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            dacAdjustCRTC_CH(pDev, Head);
            break;
        case TV_ENCODER_BROOKTREE: 
            dacAdjustCRTC_BT(pDev, Head);
            break;
        case TV_ENCODER_PHILIPS:
            dacAdjustCRTC_PH(pDev, Head);
            break;
        default:
            return RM_ERROR;
    }        
    // Fix the video scalar vertical on NV4. Also allows full range of cursor movement.
    if(IsNV4(pDev))
    {
        // adjust VBE = VT. This adjusts the position of the video scalar window.
        CRTC_RD(NV_CIO_CR_VDT_INDEX, data, Head);             // CR6
        // 7 bits of CR16 are used
        CRTC_WR(NV_CIO_CR_VBE_INDEX, data, Head);             // CR16
    }

    if (hRes <= 400)    // if clock doubling
    {
        // Clock doubled mode
//        DAC_REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, 0x01030700, Head);   
        if (Head == 0) 
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB2);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB1);
        }
        else
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB2);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB1);
        }
    }
    else
    {
        // Normal clock mode
//        DAC_REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, 0x10030700, Head);
        if (Head == 0) 
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB1);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK_RATIO, _DB1);
        }
        else
        {
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _TVCLK_RATIO, _DB1);
            FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VCLK2_RATIO, _DB1);
        }
    }
    // Set source of PCLK and VSCLK to be TV encoder
    if (Head == 0) 
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK_TV, _BOTH);
    }
    else
    {
        FLD_WR_DRF_DEF(_PRAMDAC, _PLL_COEFF_SELECT, _VS_PCLK2_TV, _BOTH);
    }

    switch (pDev->Dac.EncoderType)
    {
        case NV_ENCODER_CHRONTEL_7007:
        case NV_ENCODER_CHRONTEL_7008:
            if (IsNV11(pDev) || IsNV20(pDev))
            {
                if (!pDev->Dac.TVMasterMode)
                {
                    //setup the head as the pseudo-slave.  Because of a hardware bug,
                    //we have to do this to  both heads.  dacProgramChrontel()
                    //already set up the timing parameters required for this.
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _DEV_TYPE, _SLAVE, 0);
                    DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _DEV_TYPE, _SLAVE, 1);
                    break;
                }
            }
            //intentional fall-through to default

        default:
            // setup the appropriate head as the master.
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _DEV_TYPE, _MASTER, Head);
            DAC_FLD_WR_DRF_DEF(_PRAMDAC, _TV_SETUP, _DEV_TYPE, _MASTER, Head^1);
    }

    return RM_OK;
} // end of dacAdjustCRTCForTV

// Chrontel and Brooktree tables are incompatible
// Until we have a uniform way to deal with this, we'll use the "mode number"
// method for Brooktree (ala release 2) and the table lookup for Chrontel.
// This function is for Brooktree only.
U008 dacGetTVmode(PHWINFO pDev, U032 Head)
{
U032    hRes, vRes;
U008    TVmode;
PVIDEO_LUT_CURSOR_DAC_OBJECT pVidLutCurDac;

        // Get resolution
        pVidLutCurDac = (PVIDEO_LUT_CURSOR_DAC_OBJECT) pDev->Dac.CrtcInfo[Head].pVidLutCurDac;
        hRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageWidth;
        vRes = pVidLutCurDac->HalObject.Dac[0].VisibleImageHeight;
        
        // Assign a mode number based on the resolution
        switch (hRes)
        {
            case 320:
                if (vRes == 200)
                    TVmode = TV_MODE_320x200;
                else
                    TVmode = TV_MODE_320x240;
                break;
            case 400:
                TVmode = TV_MODE_400x300;
                break;
            case 480:
                TVmode = TV_MODE_480x360;
                break;
            case 512:
                TVmode = TV_MODE_512x384;
                break;
            case 640:
                if (vRes == 400)
                    TVmode = TV_MODE_640x400;
                else
                    TVmode = TV_MODE_640x480;
                break;
            case 800:
                TVmode = TV_MODE_800x600;
                break;
            case 720:
            case 704:
                TVmode = TV_MODE_DVD;
                break;
            case 1024:
                TVmode = TV_MODE_1024x768;
                break;
            default:
                TVmode = TV_MODE_640x480;
                break;
        }
        return TVmode;
}

//  Return the default register values for position, brightness, contrast and flicker filter.
VOID dacGetDefaultTVPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    EncoderId,
    U008    Default,
    U032    *encoderParms
)
{
    U008    Cr07, Cr25;
    U032    Hrs, Hre, Vrs, Vre;
    U008    TVmode;
    U032    hRes, vRes;
    U008   *strptr;
    RM_STATUS status;
        
    if (EncoderId & TV_ENCODER_BROOKTREE)
    {
        PARAMS_BROOKTREE *regsBt;
        BT_MODE_REGS *pReg;
        BT_INIT_REGS *pRegI;

        // Get default parameters from tables
        TVmode = dacGetTVmode(pDev, Head);
        regsBt = (PARAMS_BROOKTREE *)encoderParms;

        if (pDev->Dac.EncoderType == NV_ENCODER_BROOKTREE_871)
        {
            pRegI = (BT_INIT_REGS *) &BT871_Init;
            regsBt->reg0xC8 = (U008)pDev->Dac.TV871_C8;
            regsBt->reg0xCA = (U008)pDev->Dac.TV871_CA;
            regsBt->reg0xCC = (U008)pDev->Dac.TV871_CC;
            
            regsBt->reg0x80 = (U008)pDev->Dac.TV871_80;
            regsBt->reg0x82 = (U008)pDev->Dac.TV871_82;
            regsBt->reg0x92 = (U008)pDev->Dac.TV871_92;
            regsBt->reg0x98 = (U008)pDev->Dac.TV871_98;
            regsBt->reg0x9A = (U008)pDev->Dac.TV871_9A;
        }
        else
        {
            pRegI = (BT_INIT_REGS *) &BT_Init;
            regsBt->reg0xC8 = pRegI->reg0xC8;
            regsBt->reg0xCA = pRegI->reg0xCA;
            regsBt->reg0xCC = pRegI->reg0xCC;
            switch (pDev->Dac.TVStandard)
            {
                case NTSC_M:
                    strptr = (U008 *)Bt_NM[TVmode];
                    break;
                case NTSC_J:
                    strptr = (U008 *)Bt_NJ[TVmode];
                    break;
                case PAL_NC:
                    strptr = (U008 *)Bt_NC[TVmode];
                    break;
                case PAL_A:
                    strptr = (U008 *)Bt_PA[TVmode];
                    break;
                case PAL_M:
                    strptr = (U008 *)Bt_PM[TVmode];
                    break;
                case PAL_N:
                    strptr = (U008 *)Bt_PN[TVmode];
                    break;
                default:
                    strptr = (U008 *)Bt_NM[TVmode];
                break;
            }
            pReg = (BT_MODE_REGS *) strptr;
            regsBt->reg0x80 = pReg->reg0x80;
            regsBt->reg0x82 = pReg->reg0x82;
            regsBt->reg0x92 = pReg->reg0x92;
            regsBt->reg0x98 = pReg->reg0x98;
            regsBt->reg0x9A = pReg->reg0x9A;
        }

        // Construct Horizontal Retrace Start, End, and Vertical Retrace Start, End
        CRTC_RD(NV_CIO_CR_OVL_INDEX, Cr07, Head);
        CRTC_RD(NV_CIO_CRE_LSR_INDEX, Cr25, Head);

        // Construct Hrs
        CRTC_RD(NV_CIO_CR_HRS_INDEX, Hrs, Head);

        // Construct Hre
        CRTC_RD(NV_CIO_CR_HRE_INDEX, Hre, Head);
        Hre = Hrs + ( ((short)Hre - (short)Hrs) & BITS0_4 );

        // Construct Vrs
        CRTC_RD(NV_CIO_CR_VRS_INDEX, Vrs, Head);
        if (Cr25 & BIT2)
            Vrs |= BIT10;
        if (Cr07 & BIT7)
            Vrs |= BIT9;
        if (Cr07 & BIT2)
            Vrs |= BIT8;

        // Construct Vre
        CRTC_RD(NV_CIO_CR_VRE_INDEX, Vre, Head);
        Vre = Vrs + ( ((short)Vre - (short)Vrs) & BITS0_3 );

        regsBt->HRetraceStart = Hrs;        
        regsBt->HRetraceEnd = Hre;      
        regsBt->VRetraceStart = Vrs;        
        regsBt->VRetraceEnd = Vre;      
    }
    if (EncoderId & TV_ENCODER_CHRONTEL)
    {
        PARAMS_CHRONTEL *regsCh;
        PCH_string  pReg;

        regsCh = (PARAMS_CHRONTEL *)encoderParms;

        hRes = pDev->Framebuffer.HalInfo.HorizDisplayWidth;
        vRes = pDev->Framebuffer.HalInfo.VertDisplayWidth;
        status = dacGetI2CModeString(pDev, Head, hRes, vRes, &strptr, NULL, NULL, NULL);
        pReg = (PCH_string) strptr;
        if (status)
        {
            regsCh->reg0x0A = 0;
            regsCh->reg0x0B = 0;
        }
        else
        {
            regsCh->reg0x0A = pReg->data0x0A;
            regsCh->reg0x0B = pReg->data0x0B;
        }
        regsCh->reg0x08 = 0x00;
        regsCh->reg0x09 = 0x7f;
        regsCh->reg0x11 = 0x03;
        if (EncoderId == NV_ENCODER_CHRONTEL_7003)
            regsCh->reg0x01 = 0x03;
        else
            regsCh->reg0x01 = 0x29;
    }
}
//  Write TV encoder positioning registers, as well as contrast, brightness, flicker filter
//  For Brooktree positioning, we must change the CRTC's also.
VOID dacSetTVPosition
(
    PHWINFO pDev,
    U032    Head,
    U032    *encoderParms
)
{
    U008 Adr, Data, Device, lock;
    NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *Parms = (NV_CFGEX_DESKTOP_POSITION_TV_MULTI_PARAMS *) encoderParms;

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    if (TV_ENCODER_FAMILY(Parms->Encoder_ID) == TV_ENCODER_BROOKTREE)
    {
        // Write CRTC values (we can use the monitor position function)
        dacSetMonitorPosition(pDev, Head, Parms->u.regsBt.HRetraceStart, Parms->u.regsBt.HRetraceEnd,
                                Parms->u.regsBt.VRetraceStart, Parms->u.regsBt.VRetraceEnd);

        Data = Parms->u.regsBt.reg0x80;
        Adr = 0x80;
        Device = (U008)(pDev->Dac.EncoderID >> 1);
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x82;
        Adr = 0x82;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x92;
        Adr = 0x92;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x98;
        Adr = 0x98;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0x9A;
        Adr = 0x9a;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0xC8;
        Adr = 0xc8;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0xCA;
        Adr = 0xca;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsBt.reg0xCC;
        Adr = 0xcc;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
    } else if (TV_ENCODER_FAMILY(Parms->Encoder_ID) == TV_ENCODER_CHRONTEL)
    {
        // Chrontel is positioned completely thru the encoder
        Data = Parms->u.regsCh.reg0x01;
        Adr = 0x01;
        Device = (U008)(pDev->Dac.EncoderID >> 1);
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x08;
        Adr = 0x08;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x09;
        Adr = 0x09;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x0A;
        Adr = 0x0A;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x0B;
        Adr = 0x0B;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
        Data = Parms->u.regsCh.reg0x11;
        Adr = 0x11;
        i2cWrite(pDev, Head, pDev->Dac.TVOutPortID, Device, (U016) 1, &Adr, 1, &Data);
    }
    RestoreLock(pDev, Head, lock);
}


//  Return the default TV mode stored in the bios.
RM_STATUS dacGetBiosDefaultTVType
(
    PHWINFO pDev,
    U032    *biostvdefault
)
{
 
    U008  data, lock;
    U032  Head = 0;  // BIOS knows only about head 0

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    
    CRTC_RD(NV_CIO_CRE_SCRATCH0__INDEX, data, Head); 
    
    RestoreLock(pDev, Head, lock);
    
    *biostvdefault = data & 0x07;
    
    return RM_OK;
}

// Set the default TV mode stored in the bios.
// Normally, this will only persist till shutdown.  But in the
// mobile case we call through the VGA BIOS to the system BIOS
// to commit the new setting to CMOS.
// This register is referred to (through a call to dacGetBiosDefaultTVType)
// by the control panel and QuickTweak to determine the preferred TV setting
// when referring to the registry is not appropriate.
RM_STATUS dacSetBiosDefaultTVType
(
    PHWINFO pDev,
    U032    biosTVSetting
)
{
 
    U008  data, lock;
    U032  Head = 0;  // BIOS knows only about head 0

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    
    CRTC_RD(NV_CIO_CRE_SCRATCH0__INDEX, data, Head);
    data &= ~0x07;
    data |= (biosTVSetting & 0x07);
    CRTC_WR(NV_CIO_CRE_SCRATCH0__INDEX, data, Head); 
    
    RestoreLock(pDev, Head, lock);
    
#if !defined(MACOS) && !defined(LINUX)
    //
    // If this is a mobile BIOS that supports storing the tv state in the system
    // cmos, we need to pass the information down.
    //
    if (pDev->Power.MobileOperation == 2)
    {
        // Call through VGA BIOS to system BIOS to set tv mode CMOS bit.
        RM_STATUS status;
        U032 eax, ebx, ecx, edx;
        eax = 0x4F14;       // NV VESA function
        ebx = 0x8105;       // set TV format and commit to CMOS
        ecx = biosTVSetting;
        edx = 0;
        status = osCallVideoBIOS(pDev, &eax, &ebx, &ecx, &edx, NULL);
    }
#endif
    return RM_OK;
}
        
//  Detect TV encoder 
//  Find the encoder ID (i2c address) and the type (maker and version) and save in the pDev dac structure.
VOID    dacDetectEncoder
(
    PHWINFO pDev,
    U032    Head
)
{
    U008    lock, ack, read, retry;

    // see if we have a TV encoder, and what type it is.
    // Identify which part: Chrontel or Brooktree? There are 2 possible ID's for each part
    // Unlock CRTC extended regs
    if (IsNV11(pDev))
    {
        AssocDDC(pDev, Head);
        AssocTV(pDev, Head);
    }

    lock = UnlockCRTC(pDev, Head);

    if (IsNV4(pDev) && Head == 0)   // TV and CRT share the i2c port
        EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);   // this will stop the CRT from driving DDC1 data on the bus

    i2cInit(pDev, Head, pDev->Dac.TVOutPortID);

    for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x8A);     // is it Brooktree?
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
    }
    if (ack == 0) { // We got a response, so this must be our device
        pDev->Dac.EncoderID = 0x8A;
        pDev->Dac.EncoderType = TV_ENCODER_BROOKTREE;
    } else {    // Not address 8A, try alternate
        for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x88); // Brooktree alt address
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
        }
        if (ack == 0) { // We got a response, so this must be our device
            pDev->Dac.EncoderID = 0x88;
            // Differentiate between Brooktree and Philips
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x1C); // Philips ID reg
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID); // Start w/o Stop = Restart
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            if (ack) 
                pDev->Dac.EncoderType = TV_ENCODER_BROOKTREE;
            else
            {
                pDev->Dac.EncoderType = TV_ENCODER_PHILIPS; // generic ID
                switch (read) 
                {
                    case 0x02:
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7102;
                        break;    
                    case 0x03:
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7103;
                        break;    
                }
                // If there is a decoder on the chip, then it is considered to be a 7108 or 7109
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x40); // 7114 decoder address    
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                if (ack == 0) 
                {
                    if (pDev->Dac.EncoderType == NV_ENCODER_PHILIPS_7102) 
                    {
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7108;
                    }
                    if (pDev->Dac.EncoderType == NV_ENCODER_PHILIPS_7103) 
                    {
                        pDev->Dac.EncoderType = NV_ENCODER_PHILIPS_7109;
                    }
                }
            }
        } else {    // Not Brooktree
            for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xEA); // is it Chrontel?
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            }
            if (ack == 0) { // We got a response, so this must be our device
                pDev->Dac.EncoderID = 0xEA;
                pDev->Dac.EncoderType = TV_ENCODER_CHRONTEL;
            } else {    // Try alternate Chrontel address
                for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
                    i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
                    ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xEC); // try Chrontel alt address
                    i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
                }
                if (ack == 0) { // We got a response, so this must be our device
                    pDev->Dac.EncoderID = 0xEC;
                    pDev->Dac.EncoderType = TV_ENCODER_CHRONTEL;
                } else {
                    pDev->Dac.EncoderType = NV_ENCODER_NONE;
                }
            }
        }
    }

    // if the part responded to the Chrontel address, check subaddress
    // we may have another Chrontel part (7002?)
    if (pDev->Dac.EncoderType == TV_ENCODER_CHRONTEL)
    {
        // See what BIOS booted to.
        if (dacGetBiosDisplayType(pDev, Head) == DISPLAY_TYPE_TV)  // H
            // Temporarily set DisplayType to TV. This prevents the BIOS from hanging when
            // it gets called to do a modeset, because TVConnectStatus will turn off the encoder
            // if its not the current display. The correct display type will be set later.
            // If the VCLK is coming from the encoder, we must not turn it off.

            SETDISPLAYTYPE(pDev, Head, DISPLAY_TYPE_TV);

        for (ack = 1, retry = I2C_ADDRESS_RETRIES; (ack != 0) && (retry != 0); retry--) {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
        }
        if ((ack != 0) || (i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x25))) // 25 = version register
        {
            pDev->Dac.EncoderType = NV_ENCODER_NONE;                    
        }
        else
        {
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);   // RESTART = start without previous end
            ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID | 1));  // prepare for read
            i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read,1);
            if (ack)    // if read failed, the reg doesn't exist, probably 7002
            {
                pDev->Dac.EncoderType = NV_ENCODER_NONE; 
            }
            else
            {
                switch (read & 0xFF)
                {
                    case 0x00:  // 7003 according to spec
                    case 0x01:  // 7003 observed
                    case 0x02:  // 7003B
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7003;
                        break;
                    case 0x30:  // 7004A  From Chrontel, their data sheets are incorrect.
                    case 0x31:  // 7004B
                    case 0x32:  // 7004C
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7004;
                        break;
                    case 0x38:  // 7005A
                    case 0x39:  // 7005B
                    case 0x3a:  // 7005C
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7005;
                        break;
                    case 0x28:  // 7006A
                    case 0x29:  // 7006B
                    case 0x2A:  // 7006C
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7006;
                        break;
                    case 0x50:  // 7007
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7007;
                        break;
                    case 0x40:  // 7008
                        pDev->Dac.EncoderType = NV_ENCODER_CHRONTEL_7008;
                        break;
                    default:    // 7002 should return FF
                        pDev->Dac.EncoderType = NV_ENCODER_NONE;
                        break;
                }
            }
        }
    }

    // if Brooktree, identify which variety
    if (pDev->Dac.EncoderType == TV_ENCODER_BROOKTREE)
    {
        // enable non-legacy readback mode for 870/871 by doing a reset - harmless for older parts
        // (this enables read of any register on 87x -- 868/869 has only one read subaddress)
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);     // subaddress
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x44);     // TIMING_RST low, set readback mode, EACTIVE
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
        tmrDelay(pDev, 10000000);
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xC4);      // TIMING_RST high
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         

        // Read register 0 for the device ID.
        // If this is an 86x part, we need to set Estat so that the reg read from subaddress 0 is reg 0.
        // (There are four registers which can be read at subaddress 0; Estat selects which one.)
        // If this is an 87x part and we are in non-legacy mode, setting Estat doesn't matter.
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);  
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xC4);   // subaddress
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x01);   // set estat (estat 0 + en_out)
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
        // Now read register 0, the ID register.
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        ack = i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID));     
        ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0);              // subaddress
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
        ack |= i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)(pDev->Dac.EncoderID+1));     
        ack |= i2cReceiveByte(pDev, Head, pDev->Dac.TVOutPortID, &read, 1);
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
        
        // Check upper 3 bits: 000 = 868, 001 = 869, 010 = 870, 011 = 871
        switch (read & 0xe0) 
        {
            case 0:
                pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_868;
                break;
            case 0x20:
                pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_869;
                break;
            case 0x60:
                pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_871;
                // disable Macrovision
                i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                   
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);  
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0xFC);   // subaddress
                i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) 0x00);   //
                i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
                
                break;
            case 0x40:
                pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_870;
                break;
            default:
                pDev->Dac.EncoderType = NV_ENCODER_BROOKTREE_868;
        }
    }                
      
    //
    // Relock if necessary
    //
    RestoreLock(pDev, Head, lock);            
}

VOID dacTV871Readback
(
    PHWINFO  pDev,
    U032     Head,
    U008     Mode
)
{
    U008 lock;

    if (IsNV11(pDev))
    {
        AssocDDC(pDev, Head);
        AssocTV(pDev, Head);
    }

    lock = UnlockCRTC(pDev, Head);
    if (Mode == 0) 
    {
        // enable legacy readback mode for 870/871
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);     // subaddress
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x04);     // TIMING_RST low, set legacy readback mode, !EACTIVE
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
        tmrDelay(pDev, 10000000);
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x84);      // TIMING_RST high
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
    }
    else
    {
        // enable non-legacy readback mode for 870/871
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       // start state for I2C
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);     // subaddress
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x44);     // TIMING_RST low, set legacy readback mode, !EACTIVE
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
        tmrDelay(pDev, 10000000);
        i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                       
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);   // send ID
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0x6C);  
        i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, 0xC4);      // TIMING_RST high
        i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                         
    }
    RestoreLock(pDev, Head, lock);
    
    // restore TV connection if TV is connected on the other head
    if (GETDISPLAYTYPE(pDev, Head ^ 0x1) == DISPLAY_TYPE_TV) 
    {
        AssocDDC(pDev, Head ^ 0x1);
        AssocTV(pDev, Head ^ 0x1);
    }
}

VOID
dacDisableTV
(
    PHWINFO pDev,
    U032 Head
)
{
    U032 data32;
    U008 lock;
    U008 data08;

	// Another check to see if we're already off.
	if(!(pDev->Dac.DevicesEnabled & DAC_TV_ENABLED))
		return;

    if (pDev->Power.MobileOperation) Head = 0;  //Set to proper head to unlock and
                                                //modify CR28.

    // On dual-headed devices, enable I2C interface
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);
    }
    lock = UnlockCRTC(pDev, Head);
    //
    // Sequence per KevinM:
    //  - clear bits 7,2 in CR28
    //  - clear bits 24,20,17:16 in PLL_COEFF_SELECT
    //  - delay 200ms
    //  - turn off encoder
    //
    if ((GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_TV)
        || (GETDISPLAYTYPE(pDev, Head) == DISPLAY_TYPE_NONE)) {    //This fn is called during dacSetModeMulti
        // with a Head parameter that need not be the one with the TV.  In that case, it would be
        // dangerous to go overwriting these registers...
        dacDisableCRTCSlave(pDev, Head); 
    }
    //
    // We're about to turn off the encoder, so be sure to
    // clear any pixel clock dependencies on tv.
    //
    data32 = REG_RD32(NV_PRAMDAC_PLL_COEFF_SELECT);
    data32 &= ~((DRF_MASK(NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV) <<
                 DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV)) |
                (DRF_MASK(NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK2_TV) <<
                 DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK2_TV)) |
                (DRF_MASK(NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_SOURCE) <<
                 DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_SOURCE)) |
                (DRF_MASK(NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_RATIO) <<
                 DRF_SHIFT(NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_RATIO)));
    REG_WR32(NV_PRAMDAC_PLL_COEFF_SELECT, data32);

    tmrDelay(pDev, 200000000);   // delay 200 ms

    
    // Toshiba can do an SMI, and they may leave the ext CRTC's locked!!!
    // So before doing I2C, make sure they are still unlocked.
    CRTC_RD(NV_CIO_SR_LOCK_INDEX, data08, Head);
    if (!data08) 
    {
        lock = UnlockCRTC(pDev, Head);  // do it again.
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: ext CRTC's are locked in dacDisableTV\r\n");
    }
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            // power down to blank screen
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                    // start state for I2C
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E);      // PM register 
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_OFF);         // power down (+ reset high)  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                     // end state for I2C
            break;
        case TV_ENCODER_BROOKTREE:
            // Turn DAC off
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_OFF);    // DAC OFF
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            dacTVReadModifyWrite(pDev, Head, BT_EN_OUT, BT_EN_OUT_OFF, BT_EN_OUT_ON);
            break;
        case TV_ENCODER_PHILIPS:
            dacTVReadModifyWrite(pDev, Head, PH_STDCTL, PH_DAC_OFF, PH_DAC_POWER);
            break;
        case TV_ENCODER_NONE:
        default:
            // what can we do?
            break;
    }
    RestoreLock(pDev, Head, lock);
    
	pDev->Dac.DevicesEnabled &= ~(DAC_TV_ENABLED);
}

VOID
dacEnableTV
(
    PHWINFO pDev,
    U032 Head
)
{
    U008 lock;
    // On dual-headed devices, enable I2C interface
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);
    }
    lock = UnlockCRTC(pDev, Head);
    
    switch (TV_ENCODER_FAMILY(pDev->Dac.EncoderType))
    {
        case TV_ENCODER_CHRONTEL:
            // power up DAC
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);                // start state for I2C
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008)pDev->Dac.EncoderID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_REG_0E);  // PM register 
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, CH_ON);      // power on (+ reset high)  
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);                 // end state for I2C
            break;
        case TV_ENCODER_BROOKTREE:
            // Turn DAC on
            i2cStart(pDev, Head, pDev->Dac.TVOutPortID);
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) (pDev->Dac.EncoderID));
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_CTL);    // subaddress
            i2cSendByte(pDev, Head, pDev->Dac.TVOutPortID, (U008) BT_DAC_ON);    // DAC ON
            i2cStop(pDev, Head, pDev->Dac.TVOutPortID);
            dacTVReadModifyWrite(pDev, Head, BT_EN_OUT, BT_EN_OUT_ON, BT_EN_OUT_ON);
            break;
        case TV_ENCODER_PHILIPS:
            dacTVReadModifyWrite(pDev, Head, PH_STDCTL, PH_DAC_ON, PH_DAC_POWER);
            break;
        case TV_ENCODER_NONE:
        default:
            // what can we do?
            break;
    }
    RestoreLock(pDev, Head, lock);

	pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\grayclk.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/***************************** Gray Code Support *****************************
 *                                                                           *
 * Module: grayclk.c                                                         *
 *                                                                           *
 *****************************************************************************/

#include <nvrm.h>
#include <nvhw.h>
#include <nvos.h>
#include <bios.h>            // need BIOS_ROM_CODE_SIZE
#include <nv10_ref.h>

#define __KERNEL__
#include <nv.h>
#include <Nvcm.h>

//doubled table length to avoid wasted effort of boundary checking for something so small
static const U032 GrayCodeLookupTable[16]={0,1,3,2,6,7,5,4,0,1,3,2,6,7,5,4};
static const U032 GrayCodeLookupTableLength=16;

static U032 GrayCodeLookup(U032 Value,U032 starting_position)
{
	U032 x;
	
	Value=Value&0x7;
	
	//looks up 3 bit value in lookup table and returns the position
	for(x=starting_position;x<GrayCodeLookupTableLength;x++)
	{
		if(GrayCodeLookupTable[x]==Value)
		{
			return x;
		}
	}
	
	return 0;
}

void RmProperClockPdivProgrammer(PHWINFO pDev,U032 ClockAddress,U032 NewValue)
{
	U032 OldValue;
	U032 OldPdiv;
	U032 NewPdiv;
	U032 PllValLessPdiv;
	U032 ListPosition;
	U032 TargetPosition;
	U032 CurrentPosition;
	
	//read old value
	OldValue=REG_RD32(ClockAddress);
	
	//obtain old pdiv (16 though 18)
	OldPdiv=(OldValue>>16)&0x7;
	
	//obtain the desired Pll value less the Pdiv
	PllValLessPdiv=NewValue&0xffff;
	
	//obtain the desired Pdiv
	NewPdiv=(NewValue>>16)&0x7;
	
	//lookup position of the items we have and want
	ListPosition=GrayCodeLookup(OldPdiv,0);
	TargetPosition=GrayCodeLookup(NewPdiv,ListPosition);
	
	//transition via gray code to desired setting
	for(CurrentPosition=ListPosition;CurrentPosition<=TargetPosition;CurrentPosition++)
	{
		REG_WR32(ClockAddress,(GrayCodeLookupTable[CurrentPosition]<<16)|PllValLessPdiv);
		
		//wait to allow settle before transitioning again
		osDelay(10);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\edid.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* EDID Functions *****************************
*                                                                           *
* Module: EDID.C                                                            *
*   All EDID related fuctions are in this module.                           *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/

#include <nvrm.h>
#include <i2c.h>
#include <tmr.h>
#include <edid.h>
#include "nvhw.h"
#include <dac.h>
#include <devinit.h>
#include <vga.h>


U032 getI2CPort(PHWINFO pDev, U032 Head, U032 dispType )
{
    // We have to know what the mappings of ports to display devices are.
    // Until we can get this from the BIOS, assume the following:
    switch (dispType)
    {
        case DISPLAY_TYPE_MONITOR:
        case DISPLAY_TYPE_DUALSURFACE:
            if (Head == 0) 
                return pDev->Dac.CRTPortID; // VGA Head 0 use port 0
            else
                return pDev->Dac.CRT2PortID; // DVI Head 1 use port 1
        case DISPLAY_TYPE_FLAT_PANEL:
            if (Head == 0) 
                return pDev->Dac.DFPPortID; // DVI Head 0
            else
                return pDev->Dac.DFP2PortID; // DVI Head 1
        case DISPLAY_TYPE_TV:
            return pDev->Dac.TVOutPortID;
        default:
            return NV_I2C_PORT_PRIMARY;
    }
}

static U032 edidTranslateDisplayType(U032 displayType)
{
    switch (displayType)
    {
        case DCB_DEV_REC_TYPE_CRT:
        {
            return DISPLAY_TYPE_MONITOR;
        }
        case DCB_DEV_REC_TYPE_TV:
        {
            return DISPLAY_TYPE_TV;
        }
        case DCB_DEV_REC_TYPE_DD_SLINK:
        case DCB_DEV_REC_TYPE_DD_DLINK:
        {
            return DISPLAY_TYPE_FLAT_PANEL;
        }
        default:
            return DISPLAY_TYPE_NONE;
    }
}

static RM_STATUS getDefaultEDIDFromBIOS(PHWINFO, U032, U032);

// Get the monitor to stop driving the DDC bus (DDC1)
// This may only stop the CRT momentarily; we must send a valid DDC2 address
// to be sure it stops permanently.
RM_STATUS StopDDC1(PHWINFO pDev, U032 Head, U032 dispType)
{
U032	i2cPortId = 0;	
U016	status = 1, i;
U008	Data;

    i2cPortId = getI2CPort(pDev, Head, dispType);
    i2cHardwareInit(pDev, Head, i2cPortId);
    tmrDelay(pDev, 15000);
    ResetSCLLine(pDev, Head, i2cPortId);     // drive clock low (data tristated)
    tmrDelay(pDev, 2000000);
    SetSCLLine(pDev, Head, i2cPortId);       // clock high
    SetSDALine(pDev, Head, i2cPortId);       // data high
    for (i=0; i<16; i++)	// give it 16 times
    {
        tmrDelay(pDev, 15000);
        ReadSDA(pDev, Head, i2cPortId, &Data);
        if(Data)        	// SDA = 1?
        {
            status=0;
            break;
        }
    }
    tmrDelay(pDev, 10000);
    i2cStop(pDev, Head, i2cPortId);
    
    // Leave it with clock low (problem with ViewSonic monitors)
    ResetSCLLine(pDev, Head, i2cPortId);     // drive clock low (data tristated)
    tmrDelay(pDev, 2000000);
	
    if (status)
        return (RM_ERROR);
    return (RM_OK);
}

//****************************************************************************************
/*	Determine if monitor is DDC, and in doing so, get it ready to read the EDID or VDIF
	This means get it in DDC2 mode and send the address. Try addresses A0 and A2.
*/
RM_STATUS IsMonitorDDC(PHWINFO pDev, U032 Head, U032 dispType, U008 *dispAddr)
{
    RM_STATUS status;
    U008	Adr, Data;
    U032    i2cPortId;
    BOOL    NV15Retry = FALSE;

    i2cPortId = getI2CPort(pDev, Head, dispType);
    // NV11 can drive a CRT on either head; earlier devices only on port 0.
    if (IsNV11(pDev) || (i2cPortId == 0))  
    {
        StopDDC1(pDev, Head, dispType);	// stop the CRT from driving the bus
    }

    // now monitor is in DDC2 mode; we can talk to it
    // send address 0 (start of EDID), no other data
IsMonitorDDC_NV15_Retry:
    Adr = 0;
    *dispAddr = DDC_CRT_ADR1;
    if (dispType == DISPLAY_TYPE_MONITOR) {
        status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data);   // if it fails, its not DDC
    }
    else if (dispType == DISPLAY_TYPE_FLAT_PANEL)
    {
        // if flat panel, device address can be A0, A2, or A6 (50/51/53 shifted left)
	    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data);   
        if (status)
        {
            *dispAddr = DDC_CRT_ADR2;
		    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR2, 1, &Adr, 0, &Data);  
            if (status)
            {
                *dispAddr = DDC_CRT_ADR3;
    		    status = i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR3, 1, &Adr, 0, &Data);  
            }
        }
    }
    else
    {
        // not a DDC device
        status = RM_ERROR;
    }

    if ((status != RM_OK) && IsNV15(pDev) && (dispType == DISPLAY_TYPE_MONITOR) && !NV15Retry) {
        NV15Retry = TRUE;
        i2cPortId = getI2CPort(pDev, 1, dispType);
        goto IsMonitorDDC_NV15_Retry;
    }

    return status;
}

U032 edidGetVersion(PHWINFO pDev, U032 Head)
{
    U008 i, index = 0;

    // check for version 1
    if (pDev->Dac.CrtcInfo[Head].EDID[0]	== 0x00)
    {
        for (i=1; i<8; i++)
            if (pDev->Dac.CrtcInfo[Head].EDID[i] == 0xff)
                index = i;
            else 
                break;
        if (pDev->Dac.CrtcInfo[Head].EDID[index+1]	== 0x00)
            return 1;		
    }	
    if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_VERSION_NUMBER_INDEX] & 0xf0) == 0x20)
        return 2;

    return 0;	// Invalid or unknown EDID
}

//****************************************************************************************
/*	Checksum an EDID
 */
static BOOL EDIDCheckSumOk(
    PHWINFO pDev, 
    U032    Head, 
    U008   *edid,
    U032    length
)
{
    U032 j;
    int  chksum;

    // This is version 1 header
    // checksum the block
    chksum = 0;

    for (j=0; j<length; j++)
        chksum += *edid++;
 
    return ((U008) chksum) == 0;
}

//****************************************************************************************
/*	Read EDID
    Read the EDID of the specified device into the caller's buffer
    The device is specified by the DWORD which is a bit map of up to 8 CRT's, 8 DFP's, and 8 TV's.
*/
RM_STATUS edidReadDevEDID(PHWINFO pDev, U032 device, U008 *pEdid)
{
    RM_STATUS    status = RM_ERROR;
#ifndef IKOS    // This is just too painfully slow
    int	    i,j;
    U008    block_ID;
    U032    i2cPortID, Head, dispType;
	U008 	dispAddr;



    status = dacGetDisplayInfo(pDev, device, &Head, &dispType, 0, 0);

    if (status != RM_OK)
    {
        return status;
    }

    dispType = edidTranslateDisplayType(dispType);

    if (dispType == DISPLAY_TYPE_NONE)
    {
        status = RM_ERROR;
        return status;
    }
    //
    // Look for EDID overrides for mobile operation
    //
    if (dispType == DISPLAY_TYPE_FLAT_PANEL && pDev->Power.MobileOperation)
    {
        status = edidConstructMobileInfo(pDev, Head, pEdid);
        if (status == RM_OK)
            return RM_OK;
    }

	// See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }

    if (IsNV15(pDev) && (device == 0x2))        // CRT on DVI-I connector
        i2cPortID = getI2CPort(pDev, 1, dispType);
    else
        i2cPortID = getI2CPort(pDev, Head, dispType);

	for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block 
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortID, dispAddr, 1, &block_ID, 128, pEdid);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2, we need to read
            // another 128 bytes.
            if (pEdid[0] == 0 && pEdid[1] == 0xff &&
                pEdid[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
            	if (EDIDCheckSumOk(pDev, Head, pEdid, 128))
            	    goto done;
            }
            else if ((pEdid[0] >> 4) == 2)
            {
                // This is a version 2 header. Read the next 128 byte block.
                block_ID = 128;
                // send a write command and read the next block 
                // NOTE: the device address is shifted up in our function (50->A0)
                status = i2cRead(pDev, Head, i2cPortID, dispAddr, 1, &block_ID, 128, 
                                 &(pEdid[128]));
                if (status == RM_OK)
	            	if (EDIDCheckSumOk(pDev, Head, pEdid, 256))
	            	    goto done;
            }
    	}
        // if we failed, try to reset the slave
        for (j=0; j< 10; j++) 
        {
            i2cStart(pDev, Head, i2cPortID);
            tmrDelay(pDev, 10000);
            i2cStop(pDev, Head, i2cPortID);
            tmrDelay(pDev, 10000);
        }


    } // retry

	// if we fall out of the retry loop, then its an error
	status = RM_ERROR;
	
done:
	if (status == RM_OK)
	    return RM_OK;

    // one last chance to get an EDID
    status = getDefaultEDIDFromBIOS(pDev, Head, dispType);
#endif // defined IKOS

    return status;
}


//****************************************************************************************
/*	Read EDID
	dispType is the display we want to read, not necessarily the current device.
    This will alwasy return RM_OK, since we'll get the BIOS default EDID if none if found,
    UNLESS this if for mobile?
*/
RM_STATUS EDIDRead(PHWINFO pDev, U032 Head, U032 dispType)
{
    RM_STATUS    status = RM_ERROR;
#ifndef IKOS    // This is just too painfully slow
    int	    i,j;
    U008    block_ID;
    U032    i2cPortId;
	U008 	dispAddr;
    BOOL    NV15Retry = FALSE;

    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }
    
    //
    // Look for EDID overrides for mobile operation
    //
    if ((dispType == DISPLAY_TYPE_FLAT_PANEL) && pDev->Power.MobileOperation)
    {
        status = edidConstructMobileInfo(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID);
        if (status == RM_OK)
            return RM_OK;
    }

	// See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }

    i2cPortId = getI2CPort(pDev, Head, dispType);

EDIDRead_NV15_Retry:
	for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block 
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 128, pDev->Dac.CrtcInfo[Head].EDID);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2, we need to read
            // another 128 bytes.
            if (pDev->Dac.CrtcInfo[Head].EDID[0] == 0 && pDev->Dac.CrtcInfo[Head].EDID[1] == 0xff &&
                pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
            	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 128))
            	    goto done;
            }
            else if ((pDev->Dac.CrtcInfo[Head].EDID[0] >> 4) == 2)
            {
                // This is a version 2 header. Read the next 128 byte block.
                block_ID = 128;
                // send a write command and read the next block 
                // NOTE: the device address is shifted up in our function (50->A0)
                status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 128, 
                                 &(pDev->Dac.CrtcInfo[Head].EDID[128]));
                if (status == RM_OK)
	            	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, 256))
	            	    goto done;
            }
    	}
        // if we failed, try to reset the slave (may be hung up and not responding)
        for (j=0; j< 20; j++) 
        {
            i2cStart(pDev, Head, i2cPortId);
            tmrDelay(pDev, 20000);      // 20 us
            i2cStop(pDev, Head, i2cPortId);
            tmrDelay(pDev, 20000);
            // one last desparate measure 
            StopDDC1(pDev, Head, dispType);	// stop the CRT from driving the bus
            tmrDelay(pDev, 2000000);    // 2 ms
        }


    } // retry

	// if we fall out of the retry loop, then its an error
	status = RM_ERROR;
	
done:
    if ((status != RM_OK) && IsNV15(pDev) && (dispType == DISPLAY_TYPE_MONITOR) && !NV15Retry) {
        NV15Retry = TRUE;
        i2cPortId = getI2CPort(pDev, 1, dispType);
        goto EDIDRead_NV15_Retry;
    }

	if (status == RM_OK)
	    return RM_OK;

    // one last chance to get an EDID
    status = getDefaultEDIDFromBIOS(pDev, Head, dispType);
#endif // defined IKOS

    return status;
}

//****************************************************************************************
/*	See if a device has an EDID 
	dispType is the display we want to read, not necessarily the current device.
*/
RM_STATUS EDIDDetect(PHWINFO pDev, U032 Head, U032 dispType)
{
#ifndef IKOS    // This is just too painfully slow
    int	    i;
    RM_STATUS    status;
    U008    block_ID, lock;
    U032    i2cPortId;
    U008    dispAddr;
    U008    EdidBuffer[128];
    BOOL    NV15Retry = FALSE;

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);
    
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);  // Connect the head to the I2C pins
    }
	// See if device supports DDC and which address it uses
    if (IsMonitorDDC(pDev, Head, dispType, &dispAddr) != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        status = RM_ERROR;
        goto done;
    }

    i2cPortId = getI2CPort(pDev, Head, dispType);

EDIDDetect_NV15_Retry:
	for (i=0; i<DDC_RETRIES; i++)
	{
        block_ID = 0;
        // send a write command and read back a block (at least 0x50 bytes to get version 2 display technology byte).
        // NOTE: the device address is shifted up in our function (50->A0)
        status = i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &block_ID, 0x50, EdidBuffer);
        if (status == RM_OK)
        {
            // Check which version of the header. If it was version 2,
            if (EdidBuffer[0] == 0 && EdidBuffer[1] == 0xff &&
                EdidBuffer[EDID_V1_VERSION_NUMBER_INDEX] == 0x1)
            {
                // This is version 1 header, get video input definition
                if (EdidBuffer[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))     // digital device?
                {
                    if (dispType == DISPLAY_TYPE_FLAT_PANEL) 
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
                else
                {
                    if (dispType == DISPLAY_TYPE_MONITOR)                   // we're looking for analog
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
            }
            else if ((EdidBuffer[0] >> 4) == 2)
            {
                // This is a version 2 header.
                if ((EdidBuffer[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0) // analog device?
                {
                    if (dispType == DISPLAY_TYPE_MONITOR)                   // we're looking for analog
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
                else
                {
                    if (dispType == DISPLAY_TYPE_FLAT_PANEL) 
                    {
                        status = RM_OK;                                       // we're looking for digital
                        goto   done;
                    }
                    else
                    {
                        status = RM_ERROR;
                        goto   done;
                    }
                }
            }
            else
            {
                // Unknown edid header.
                status = RM_ERROR;
            }
    	} // Successfully read the first 128 byte block.
    } // retry
done:    
    if ((status != RM_OK) && IsNV15(pDev) && (dispType == DISPLAY_TYPE_MONITOR) && !NV15Retry) {
        NV15Retry = TRUE;
        i2cPortId = getI2CPort(pDev, 1, dispType);
        goto EDIDDetect_NV15_Retry;
    }


    RestoreLock(pDev, Head, lock);

    return status;
#else   // defined IKOS
    return RM_ERROR;
#endif  // IKOS
}

static RM_STATUS getDefaultEDIDFromBIOS(
    PHWINFO pDev,
    U032    Head,
    U032    dispType
)
{
#ifdef MACOS
    U032 edid_len;               //012345
    char edid_registry_name[16] = "EDID,x";

    // on the Mac, a fallback EDID could be in the registry (published by fcode)
    // Check here before falling back to the BIOS image
    // If it is in the registry
    // XXX this could be generic, I guess.
    
    edid_len = sizeof(pDev->Dac.CrtcInfo[Head].EDID);
    edid_registry_name[5] = 'A' + Head;     // "EDID,A" or "EDID,B"
    
	if ((RM_OK == osReadRegistryBinary(pDev, "", edid_registry_name, pDev->Dac.CrtcInfo[Head].EDID, &edid_len)))
	{
    	if (EDIDCheckSumOk(pDev, Head, pDev->Dac.CrtcInfo[Head].EDID, edid_len))
        {
        	// Ok, it looks good so far, but is it the right "type" (fp or crt)
        	// Can't be too careful, you know....
        	BOOL analog_display;
        	BOOL expected_analog;

        	analog_display  = edidIsAnalogDisplay(pDev, Head);
        	expected_analog = dispType == DISPLAY_TYPE_MONITOR;
        	
        	if (analog_display != expected_analog)
        	{
	            DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: found 'canned' EDID; but wrong type\n");
        	    return RM_ERROR;
        	}
        	
	        DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: using 'canned' EDID from registry\n");
    	    return RM_OK;
    	}
	}
#endif //  MACOS

    return RM_ERROR;
}


//****************************************************************************************
/*	Read VDIF
	VDIF follows after last EDID block, so to read a VDIF block we need to get the
	number of EDID blocks (*128) and add the VDIF block (*64)
*/
RM_STATUS ReadVDIF(PHWINFO pDev, U032 Head, U032 dispType, U008 *buffer, U008 device, U008 address)
{
    int     i;
    RM_STATUS  status;
    U008    Adr;
    U032    i2cPortId;

// FILL IN THIS !!!

    // get number of EDID blocks

    // calc VDIF block address

    // read VDIF
    i2cPortId = getI2CPort(pDev, Head, dispType);
    status = RM_OK;       /* macosX's version of gcc thinks 'status' may not be init before use */
    for (i=0; i<DDC_RETRIES; i++)
    {
        // send a write command and read back a block (NOTE: the device address is shifted up in our function, so 50->A0)
        status = i2cRead(pDev, Head, i2cPortId, 0x50, 0, &Adr, 128, buffer);
        if (status == RM_OK)
            break;		
    }

    return (status);
}

RM_STATUS ReadAnyEdidBlock(PHWINFO pDev, U032 Head, U032 dispType, U016 ByteAddress, U008 *VesaDataBuffer)
{
    U008 dispAddr;
    RM_STATUS status;
    U032 i2cPortId;
    U032 retry_count;
    U008 RealByteAddress;
    U008 RealSegmentAddress;
    U008 LockStat;

    LockStat=UnlockCRTC(pDev, Head);

    //Connect the head to the I2C pins
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);
    }
    
    // See if device supports DDC and which address it uses
    status = IsMonitorDDC(pDev, Head, dispType, &dispAddr);
    
    if (status != RM_OK)
    {
		DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Display is not DDC; head ", Head);
   	    // Monitor is not DDC compliant.
        goto done;
    }
    
    if(ByteAddress>128)
    {
        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Byte Address greater than 128 specified ", Head);
        
        status=RM_ERROR;
        
        goto done;
    }
    
    //the true byte address cannot exceed 255, in the future I will implement the segment access code
    RealByteAddress=(U008)(ByteAddress%256);
    
    //calculate the segment address
    RealSegmentAddress=(U008)(ByteAddress/256);
    
    //be sure the segment does not exceed 0x7f (EDDCv1.pdf Version 1 of the Enhanced DDC spec for retrieving > 256 EDIDs)
    RealSegmentAddress=(U008)((RealSegmentAddress>0x7f)?0:RealSegmentAddress);
    
    i2cPortId = getI2CPort(pDev, Head, dispType);
   
    retry_count=0;
    
    //do read
    do
    {
        //if segment is not zero, set the segment here (segment set is not currently implemented)
        
        /*
        //note, at this rev, we can't actually get the next chunk. Most of the infrastructure is here though
        status=i2cRead(pDev, Head, i2cPortId, dispAddr, 1, &RealByteAddress, 128,VesaDataBuffer);
        */
        
        status=i2cRead_EDDC(pDev, Head, i2cPortId, RealSegmentAddress, dispAddr, RealByteAddress, 128, VesaDataBuffer);

        
    }while((++retry_count!=DDC_RETRIES)&&(status!=RM_OK));
    
    //we do not verify checksum here, as if the user is retrieving a V2 or V3 EDID, the checksum may not fall at 127
    
done:
    RestoreLock(pDev,Head,LockStat);

    return status;
}

// Checks to see if the EDID is present in the pDev and if it matches a valid version.
// The version and revision is returned, as well as a pointer to the requested EDID buffer.
static BOOL EDIDIsValid
(
    PHWINFO pDev,
    U008    **edidPtr,
    U032    *version,
    U032    *revision,
    U032    Head
)
{
    U008 *edid;


    edid = pDev->Dac.CrtcInfo[Head].EDID;
    // Check the version of the edid header.
	if (!(edid[0] == 0 && edid[1] == 0xff))
	{
		// this is not version 1 edid header
		// check if it is version 2 header.
        // Bits 7-4 of byte 0 is the version and bits 3-0 of byte 0 is the revision
		if (((edid[0] & 0xf0) >> 4) == 2)
		{
            *version = 2;
            *revision = edid[0] & 0x0f;
            *edidPtr = edid;
            return TRUE;
		}

		// Unknown edid header.
        return FALSE;
	}

    // Check for version 1 edid header.
    if (edid[EDID_V1_VERSION_NUMBER_INDEX] == 1)
    {
        *version = 1;
        *revision = edid[EDID_V1_REVISION_NUMBER_INDEX];
        *edidPtr = edid;
        return TRUE;
    }

    // Unknown edid header.
    return FALSE;

}

// Checks to see if the EDID is present in the pDev and if it matches a valid version.
// The version and revision is returned, as well as a pointer to the requested EDID buffer.
BOOL edidLogicalEDIDIsValid
(
    U008    **edidPtr,
    U032    *version,
    U032    *revision
)
{
    U008 *edid;


    edid = *edidPtr;
    // Check the version of the edid header.
	if (!(edid[0] == 0 && edid[1] == 0xff))
	{
		// this is not version 1 edid header
		// check if it is version 2 header.
        // Bits 7-4 of byte 0 is the version and bits 3-0 of byte 0 is the revision
		if (((edid[0] & 0xf0) >> 4) == 2)
		{
            *version = 2;
            *revision = edid[0] & 0x0f;
            *edidPtr = edid;
            return TRUE;
		}

		// Unknown edid header.
        return FALSE;
	}

    // Check for version 1 edid header.
    if (edid[EDID_V1_VERSION_NUMBER_INDEX] == 1)
    {
        *version = 1;
        *revision = edid[EDID_V1_REVISION_NUMBER_INDEX];
        *edidPtr = edid;
        return TRUE;
    }

    // Unknown edid header.
    return FALSE;

}

static RM_STATUS EDIDV1Copy
(
    PHWINFO pDev,
    U008    *edid,
    U008    *buffer,
    U032    *bufLen
)
{
    // version 1
    if (*bufLen < EDID_V1_SIZE)
    {
        // There is not enough space in the buffer.
        *bufLen = 0;
        return RM_ERROR;
    }

    // There is enough space in the buffer.
    *bufLen = EDID_V1_SIZE;

	osMemCopy((U008*) buffer, (U008*) edid, *bufLen);
    return RM_OK;
}

static RM_STATUS EDIDV2Copy
(
    PHWINFO pDev,
    U008    *edid,
    U008    *buffer,
    U032    *bufLen
)
{
    // Version 2
    if (*bufLen < EDID_V2_SIZE)
    {
        // There is not enough space in the buffer.
        *bufLen = 0;
        return RM_ERROR;
    }

    // There is enough space in the buffer.
    *bufLen = EDID_V2_SIZE;
    
    osMemCopy((U008*) buffer, (U008*) edid, *bufLen);
    return RM_OK;
}

// This function copies the edid from the pDev into the buffer passed.
// Currently only version 1 edid header is supported.
RM_STATUS EDIDCopy
(
    PHWINFO pDev,
    U008    *buffer,
    U032    *bufLen,
    U032    Head
)
{
    U032 edidVersion, edidRevision;
    U008 *edid;

    if (!EDIDIsValid(pDev, &edid, &edidVersion, &edidRevision, Head)) // verify EDID and get a pointer to it
    {
        // edid not valid
        *bufLen = 0;
        return RM_ERROR;
    }

    if (edidVersion == 1)
    {
        return EDIDV1Copy (pDev, edid, buffer, bufLen);
    }
    else if (edidVersion == 2)
    {
        return EDIDV2Copy (pDev, edid, buffer, bufLen);
    }

    // Unknown edid header.
    *bufLen = 0;
    return RM_ERROR;
} // end of EDIDCopy

#if 0 // no one calling this, so turn it off 
static RM_STATUS EDIDV1GetMaxRefreshRate
(
    PHWINFO pDev,
    U008   *edid,
    U032    hRes,
    U032    vRes,
    U032   *maxRefreshRate
)
{
    U032      i, j, tmpHRes, tmpVRes = ~0, tmpRefresh;

    *maxRefreshRate = 0;
    // Get the max from the established timing section
    switch (hRes)
    {
        case 720:
            if (vRes == 400)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x40)
                {
                    // Supports 720x400 @ 88Hz.
                    *maxRefreshRate = 88;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x80)
                {
                    // supports 720x400 @ 70Hz
                    *maxRefreshRate = 70;
                }

            }
            break;
        case 640:
            if (vRes == 480)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x04)
                {
                    // Supports 640x480 @ 75Hz.
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x08)
                {
                    // supports 640x480 @ 72Hz
                    *maxRefreshRate = 72;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x10)
                {
                    // supports 640x480 @ 67Hz
                    *maxRefreshRate = 67;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x20)
                {
                    // supports 640x480 @ 60Hz
                    *maxRefreshRate = 60;
                }
            }
            break;
        case 800:
            if (vRes == 600)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x40)
                {
                    // Supports 800x600 @ 75Hz.
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x80)
                {
                    // supports 800x600 @ 72Hz
                    *maxRefreshRate = 72;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x01)
                {
                    // supports 800x600 @ 60Hz
                    *maxRefreshRate = 60;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_1_INDEX] & 0x02)
                {
                    // supports 800x600 @ 56Hz
                    *maxRefreshRate = 56;
                }
            }
            break;
        case 832:
            if (vRes == 624)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x20)
                {
                    // Supports 832x624 @ 75Hz.
                    *maxRefreshRate = 75;
                }
            }
            break;
        case 1024:
            if (vRes == 768)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x10)
                {
                    // Supports 1024x768 @ 87Hz
                    *maxRefreshRate = 87;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x02)
                {
                    // supports 1024x768 @ 75Hz
                    *maxRefreshRate = 75;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x04)
                {
                    // supports 1024x768 @ 70Hz
                    *maxRefreshRate = 70;
                }
                else if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x08)
                {
                    // supports 1024x768 @ 60Hz
                    *maxRefreshRate = 60;
                }
            }
            break;
        case 1280:
            if (vRes == 1024)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_2_INDEX] & 0x01)
                {
                    // Supports 1280x1024 @ 75Hz
                    *maxRefreshRate = 75;
                }
            }
            break;
        case 1152:
            if (vRes == 870)
            {
                if (edid[EDID_V1_ESTABLISHED_TIMING_3_INDEX] & 0x80)
                {
                    // Supports 1152x870 @ 75Hz 
                    *maxRefreshRate = 75;
                }
            }
            break;
        default:
            break;
    } // switch on hRes


    // Now check the standard timings to see if there is a higher refresh rate specified.
   	for (i = 0; i < 8; i++)
	{
		if (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i * 2)] != 0x01)
		{
			// there is a standard timing specification.
			tmpHRes = (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2)] + 31) * 8;
			tmpRefresh = (edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2) + 1] & 0x3f) + 60;
			switch ((edid[EDID_V1_STANDARD_TIMINGS_START_INDEX + (i*2) + 1] & 0xc0) >> 6)
			{
			case 0x0:
				// aspect ratio 1:1
				tmpVRes = tmpHRes;
				break;
			case 0x1:
				// aspect ratio 4:3
				tmpVRes = (tmpHRes * 3) / 4;
				break;
			case 0x2:
				// aspect ratio 5:4
				tmpVRes = (tmpHRes * 4) / 5;
				break;
			case 0x3:
				// aspect ratio 16:9
				tmpVRes = (tmpHRes * 9) / 16;
				break;
			}

            // Check if this standard timing matches the resolution we want.
            if (tmpHRes == hRes && tmpVRes == vRes)
            {
                // Resolution matches. 
                // If this refresh rate is > than the one found in established timings, use it.
                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            }
		} // A valid standard timing spec
	} // iterate over all 8 standard timings

    // Now check the detailed timing specification for a macting resolution.
	for (i = 0; i < 4; i++)
	{
		int startIndex = EDID_V1_DETAILED_TIMINGS_START_INDEX + (i * EDID_V1_DETAILED_TIMINGS_SIZE);
		if (edid[startIndex] == 0 && edid[startIndex + 1] == 0)
		{
			// This is a Monitor descriptor instead of a detailed timing descriptor.
			switch (edid[startIndex + 3])
			{
                case 0xFA:
                    // Descriptor contains 6 additional standard timing identifications
                    for (j = 0; j < 6; j++)
                    {
                        if (edid[startIndex + 5 + (j * 2)] != 0x01)
                        {
                            // there is a standard timing specification.
                            tmpHRes = (edid[startIndex + 5 + (j*2)] + 31) * 8;
                            tmpRefresh = (edid[startIndex + 5 + (j*2) + 1] & 0x3f) + 60;
                            switch ((edid[startIndex + 5 + (j*2) + 1] & 0xc0) >> 6)
                            {
                            case 0x0:
                                // aspect ratio 1:1
                                tmpVRes = tmpHRes;
                                break;
                            case 0x1:
                                // aspect ratio 4:3
                                tmpVRes = (tmpHRes * 3) / 4;
                                break;
                            case 0x2:
                                // aspect ratio 5:4
                                tmpVRes = (tmpHRes * 4) / 5;
                                break;
                            case 0x3:
                                // aspect ratio 16:9
                                tmpVRes = (tmpHRes * 9) / 16;
                                break;
                            } // switch on aspect ratio

                            // Check if this standard timing matches the resolution we want.
                            if (tmpHRes == hRes && tmpVRes == vRes)
                            {
                                // Resolution matches. 
                                // If this refresh rate is > than the one found in established timings, use it.
                                if (tmpRefresh > *maxRefreshRate)
                                {
                                    *maxRefreshRate = tmpRefresh;
                                }
                            }
                        } // a valid standard timing spec
                    } // iterate over the 6 additional standard timings
                    break;
                default:
                    break;
			}
		} // monitor descriptor.
		else
		{
			// This is a detailed timing descriptor.
            // The detailed timing specification does not include the refresh rate.
			U032 pixelClock;
			U032 hActive, vActive, hBlank, vBlank;
			U032 hTotal, vTotal;


			hActive = edid[startIndex + 2] | ((edid[startIndex + 4] & 0xf0) << 4);
			vActive = edid[startIndex + 5] | ((edid[startIndex + 7] & 0xf0) << 4);
            if (hActive == hRes && vActive == vRes)
            {
                // Resolution matches the detailed spec.
                // Get the rest of the detailed timing info needed to calculate the refresh rate.
                pixelClock = edid[startIndex] | (edid[startIndex + 1] << 8);
                hBlank  = edid[startIndex + 3] | ((edid[startIndex + 4] & 0x0f) << 8);
                vBlank  = edid[startIndex + 6] | ((edid[startIndex + 7] & 0x0f) << 8);

                // Horizontal Total (hActive + hBlank) gives # of pixels / line
                // Vertical total (vActive + vBlank) gives # of lines / frame
                // so HT * VT = total # pixels per frame.
                // Pixel clock is # pixels drawn / sec
                // so pixelClock / (HT * VT) gives the refresh rate (frames / sec).
                hTotal = hActive + hBlank;
                vTotal = vActive + vBlank;
                pixelClock = pixelClock * 10000;
                tmpRefresh = pixelClock / (hTotal * vTotal);

                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            } // resolution matches the detailed spec
		} // This is a detailed timing spec
	} // parse detailed section

    return RM_OK;
}

static RM_STATUS EDIDV2GetMaxRefreshRate
(
    PHWINFO pDev,
    U008   *edid,
    U032    hRes,
    U032    vRes,
    U032   *maxRefreshRate
)
{
    U032 lumTabSize, numLumTables;
    U032 numFreqRanges, numDetailedRanges, numTimingCodes, numDetailedTimings;
    U032 detailedTimingIndex, timingCodesIndex;
    U008 timingMap1, timingMap2;
    U032 index, i;

    // We need to look in the 4-byte timing codes section and the detailed timing section for
    // the given resolution.

    // The way the 127 byte detailed information is used is given by reading bytes 0x7e and 0x7f.
    // The size and the order of the 127 byte timing section that start at byte 0x80 is:
    // x*A + 8*B + 27*c + 4*D + 18*E where
    // A = number of luminance tables (0 or 1), (given by byte 0x7e bit 5)
    // x = size of the luminance table (given by the first byte of the table itself)
    // B = number of frequency rages listed (0-7), (given by bits 4-2 of byte 0x7e)
    // C = number of detailed rage limits (0-3), (given by (bits 1-0 of byte 0x7e)
    // D = number of timing codes (0-31), (given by bits 7-3 of byte 0x7f)
    // E = number of detailed timing descriptions (0-7) (given by bits 2-0 of byte 0x7f)
    timingMap1 = edid[EDID_V2_TIMING_MAP1_INDEX];
    timingMap2 = edid[EDID_V2_TIMING_MAP2_INDEX];
    numLumTables       = (timingMap1 & 0x20) >> 5; // Bit 5
    numFreqRanges      = (timingMap1 & 0x1C) >> 2; // Bits 4-2
    numDetailedRanges  = (timingMap1 & 0x03);      // Bits 1-0
    numTimingCodes     = (timingMap2 & 0xf8) >> 3; // Bits 7-3
    numDetailedTimings = (timingMap2 & 0x07);      // Bits 2-0
    if (numLumTables != 0)
    {
        // Calculate the size of the lum table by reading byte 0x80
        U032 numLumValues;

        numLumValues = edid[EDID_V2_TIMING_SECTION_START_INDEX] & 0x1f; // bits 4-0
        if (edid[EDID_V2_TIMING_SECTION_START_INDEX] & 0x80)
        {
            // size of lum table is ((3 * numLumValues) + 1) bytes
            lumTabSize = 3 * numLumValues + 1;
        }
        else
        {
            // size of lum table is (numLumValues + 1) bytes
            lumTabSize = numLumValues + 1;
        }
    }
    else
        lumTabSize = 0;

    timingCodesIndex = EDID_V2_TIMING_SECTION_START_INDEX 
                       + lumTabSize 
                       + (8 * numFreqRanges)
                       + (27 * numDetailedRanges);
    detailedTimingIndex = timingCodesIndex + (8 * numTimingCodes);

    *maxRefreshRate = 0;

    {
        // Look in the timing codes section.
        U032 hActive;
        U032 aspectRatio;
        U032 vActive;
        for (i = 0; i < numTimingCodes; i++)
        {
            index = timingCodesIndex + (4 * i);
            hActive = (edid[index] * 16) + 256;
            aspectRatio = edid[index + 2];
            // Aspect ratio is stored in terms of N:100.
			// This is not very useful because we don't get the standard vertical values.
			// So we will use the standard aspect ratios whenever we can.
			switch (aspectRatio)
			{
			case 133:
				// 4:3
				vActive = (hActive * 3) / 4;
				break;
			case 125:
				// 5:4
				vActive = (hActive * 4) / 5;
				break;
			case 177:
				// 16:9
				vActive = (hActive * 9) / 16;
				break;
			default:
                vActive = (hActive * 100) / aspectRatio;
				break;
			}
            if (hActive == hRes && vActive == vRes)
            {
                // This is the needed resolution.
                if (edid[index + 3] > *maxRefreshRate)
                {
                    *maxRefreshRate = edid[index + 3];
                }
            } // resolution matches
        } // loop over all the timing codes
    } // look in timing codes

    {
        // look in the detailed timing section
        // The detailed timing specification does not include the refresh rate.
        U032 pixelClock;
        U032 hActive, vActive, hBlank, vBlank;
        U032 hTotal, vTotal;
        U032 tmpRefresh;

        for (i = 0; i < numDetailedTimings; i++)
        {
            index = detailedTimingIndex + (18 * i);
            hActive = edid[index + 2] | ((edid[index + 4] & 0xf0) << 4);
            vActive = edid[index + 5] | ((edid[index + 7] & 0xf0) << 4);
            if (hActive == hRes && vActive == vRes)
            {
                // Resolution matches the detailed spec.
                // Get the rest of the detailed timing info needed to calculate the refresh rate.
                pixelClock = edid[index] | (edid[index + 1] << 8);
                hBlank  = edid[index + 3] | ((edid[index + 4] & 0x0f) << 8);
                vBlank  = edid[index + 6] | ((edid[index + 7] & 0x0f) << 8);

                // Horizontal Total (hActive + hBlank) gives # of pixels / line
                // Vertical total (vActive + vBlank) gives # of lines / frame
                // so HT * VT = total # pixels per frame.
                // Pixel clock is # pixels drawn / sec
                // so pixelClock / (HT * VT) gives the refresh rate (frames / sec).
                hTotal = hActive + hBlank;
                vTotal = vActive + vBlank;
                pixelClock = pixelClock * 10000;
                tmpRefresh = pixelClock / (hTotal * vTotal);

                if (tmpRefresh > *maxRefreshRate)
                {
                    *maxRefreshRate = tmpRefresh;
                }
            } // resolution matches the detailed spec
        } // loop over all the detailed timing specs
    } // look in detailed timing section

    return RM_OK;
}
#endif  // #if 0; no one calling this puppy


// EDID Version 1.3
// Super set of 1.2, allows range limits descriptor to define coeficients for secondary GTF curve,
// and mandates a certain set of monitor descriptors.
RM_STATUS ParseEDID13(PHWINFO pDev, U032 Head)
{
	return ParseEDID11(pDev, Head);	// we can probably treat it the same as rev 1.1
}

// EDID Version 1.2
RM_STATUS ParseEDID12(PHWINFO pDev, U032 Head)
{
	return ParseEDID11(pDev, Head);	// we can probably treat it the same as rev 1.1
}

//	Parse a detailed timing block in the current EDID
//	The EDID has been saved in the global device data structure (nvInfo).
//	When native mode is requested, it is necessary to find the correct detailed timing;
//  otherwise fpParseEDID will be used to get timing info.
U032 edidParseDetailedTimingBlock(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
	switch (pDev->Dac.CrtcInfo[Head].EdidVersion)
	{
		case EDID_VERSION_10:
		case EDID_VERSION_11:
		case EDID_VERSION_12:
		case EDID_VERSION_13:
			return edidParseDetailed1(pDev, block, fpTim, Head);
		case EDID_VERSION_20:
			return edidParseDetailed2(pDev, block, fpTim, Head);
	}

	return(0);
}

//	Parse a specific detailed timing block for EDID version 1.x
//  Detailed timings are at a fixed offset from the start of the buffer.
U032 edidParseDetailed1(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;

		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block);
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0xf) | (SyncOvf & 0x30)<<4;

			// Return this resolution
			fpTim->PixClk = pClk;
			fpTim->HActive = HRes;
 			fpTim->HDispEnd = HRes - 1;
			fpTim->HValidEnd = HRes - 1;
	 		fpTim->HSyncStart = HSyncOffset + fpTim->HDispEnd;
 			fpTim->HSyncEnd = HSyncPulse + fpTim->HSyncStart;
 			fpTim->HValidStart = 0;
	 		fpTim->HTotal = HTotal;
				
	 		fpTim->VActive = VRes;
 			fpTim->VDispEnd = VRes - 1;
 			fpTim->VValidEnd = VRes - 1;
	 		fpTim->VSyncStart =  VSyncOffset + fpTim->VDispEnd;
	 		fpTim->VSyncEnd = VSyncPulse + fpTim->VSyncStart;
 			fpTim->VValidStart = 0;
 			fpTim->VTotal = VTotal;
			fpTim->Flags = Flags;	// includes sync polarities
			return TRUE;
		}
		return FALSE;
} // edidParseDetailedTimingBlock

// Parse detailed timings for EDID Version 2.x
// This gets a specific timing block.
// For version 2, we have to parse from the start to find the location of the block.
U032 edidParseDetailed2(PHWINFO pDev, U008 block, PDACFPTIMING fpTim, U032 Head)
{
U008	map1, map2, index, lum, rangeLimits, detailedRangeLimits;
U008	detailedTimings, timingCodes, timingCode[4];
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags, i;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;

	map1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX];
	map2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX+1];
	index =  EDID_V2_TIMING_SECTION_START_INDEX;
	// if there is a lum table, bump index beyond
	if (map1 & EDID_V2_LUM_TABLE_EXIST)
	{
		// 1st byte in timing section gives # of bytes in lum table
		lum = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_SECTION_START_INDEX];
		if (lum & TRIPLE_LUM_ENTRIES)
			index += (lum & NUM_LUM_ENTRIES*3) + 1;
		else
			index += (lum & NUM_LUM_ENTRIES) + 1;
	}
	// if there are timing range limits, bump index
	if ((rangeLimits = (map1 & EDID_V2_FREQ_RANGES)>>EDID_V2_FREQ_RANGE_SHIFT))
		index += rangeLimits * 8;
	// if there are detailed range limits, bump index
	if ((detailedRangeLimits = map1 & EDID_V2_DETAILED_RANGE_LIMITS))
		index += detailedRangeLimits * 27;
	// if there are timing codes, save them
	if ((timingCodes = (map2 & EDID_V2_TIMING_CODES)>>EDID_V2_TIMING_CODES_SHIFT))
		for (i=0; i!=timingCodes; i++)
		{
			timingCode[i] = pDev->Dac.CrtcInfo[Head].EDID[index];
			timingCode[i+1] = pDev->Dac.CrtcInfo[Head].EDID[index+1];
			timingCode[i+2] = pDev->Dac.CrtcInfo[Head].EDID[index+2];
			timingCode[i+3] = pDev->Dac.CrtcInfo[Head].EDID[index+3];
			index += 4;
		}
	// now index points to the detailed timings (if present)
	if ((detailedTimings = (map2 & EDID_V2_DETAILED_TIMINGS)))
	{
		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = index + 18 * block;
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
			VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;

			// Return this resolution
			fpTim->PixClk = pClk;
			fpTim->HActive = HRes;
	 		fpTim->HDispEnd = HRes - 1;
			fpTim->HValidEnd = HRes - 1;
	 		fpTim->HSyncStart = HSyncOffset + fpTim->HDispEnd;
	 		fpTim->HSyncEnd = HSyncPulse + fpTim->HSyncStart;
	 		fpTim->HValidStart = 0;
	 		fpTim->HTotal = HTotal;
				
	 		fpTim->VActive = VRes;
	 		fpTim->VDispEnd = VRes - 1;
	 		fpTim->VValidEnd = VRes - 1;
	 		fpTim->VSyncStart =  VSyncOffset + fpTim->VDispEnd;
	 		fpTim->VSyncEnd = VSyncPulse + fpTim->VSyncStart;
	 		fpTim->VValidStart = 0;
	 		fpTim->VTotal = VTotal;

			fpTim->Flags = Flags;
			return RM_OK;
		} // if 
	} // if detailed timings
	// check 4 byte timing codes

	return RM_ERROR;	// not supported yet
}

// EDID Version 2.0 
// Get flat panel timing from 4 byte timing code
// Use VESA GTF timing.
RM_STATUS GetTimingFromCode(U008 code, PDACFPTIMING fpTim)
{
U016	HorizCode;

	// We should be able to determine the mode from the first byte only, UNLESS
	// we start seeing panels with variable refresh rates.
	// byte 1: active pixels/line (pixels - 256)/16. Range = 256-4336.
	// byte 2: arcane info, don't know what it means. See EDID standard.
	// byte 3: aspect ration H:V.
	// byte 4: refresh rate.
	HorizCode = code * 16 + 256;
	fpTim->Flags = 0;	// sync polarities: neg, neg
	switch (HorizCode)
	{
		case 1280:
			// 1280x1024x75;
			fpTim->HActive = 1280;
			fpTim->HDispEnd = 1279;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 1279;
			fpTim->HSyncStart = 1280+15;
			fpTim->HSyncEnd = 1280+15+2;
			fpTim->HTotal = 1280+320;
			fpTim->VActive = 1024;
			fpTim->VDispEnd = 1023;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd = 1023;
			fpTim->VSyncStart = 1023+2;
			fpTim->VSyncEnd = 1023+2+24;
			fpTim->VTotal = 1024+40;
			fpTim->PixClk = 10800;	// 108 MHz
			fpTim->Flags = VSYNC_POS | HSYNC_POS;

			break;
		case 1024:
			fpTim->HActive = 1024;
			fpTim->HDispEnd = 1023;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 1023;
			fpTim->HSyncStart = 1040;
			fpTim->HSyncEnd = 1089;
			fpTim->HTotal = 1344;
			fpTim->VActive = 768;
			fpTim->VDispEnd = 767;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd = 767;
			fpTim->VSyncStart = 770;
			fpTim->VSyncEnd = 776;
			fpTim->VTotal = 805;
			fpTim->PixClk = 6500;	// 65 MHz
			fpTim->Flags = VSYNC_NEG | HSYNC_NEG;
			break;
		case 800:
			fpTim->HActive =  800;
			fpTim->HDispEnd = 799;
			fpTim->HValidStart = 0;
			fpTim->HValidEnd = 799;
			fpTim->HSyncStart = 799+16;
			fpTim->HSyncEnd =  799+16+24;
			fpTim->HTotal = 800+320;
			fpTim->VActive = 600;
			fpTim->VDispEnd = 599;
			fpTim->VValidStart = 0;
			fpTim->VValidEnd =  599;
			fpTim->VSyncStart = 599+2;
			fpTim->VSyncEnd = 599+2+24;
			fpTim->VTotal = 600+38;
			fpTim->PixClk = 4000;	// 40 MHz
			fpTim->Flags = VSYNC_POS | HSYNC_POS;
			break;
		default:
			return RM_ERROR;
	}
	return RM_OK;
}
							
// EDID Version 1.1
// Return error if no valid resolution found
RM_STATUS ParseEDID11(PHWINFO pDev, U032 Head)
{
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;
U008	est_tim1, est_tim2, block, offset, mode_count;
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags;
U032	est_tim_total, i;

	// Look for multiple resolutions in established timings to see if it supports native mode.
	// meaning the monitor can do the scaling.
 	est_tim1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_1_INDEX];
 	est_tim2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_ESTABLISHED_TIMING_2_INDEX];
	est_tim_total = est_tim1 | (est_tim2<<8);
	mode_count = 0;
	pDev->Dac.fpNative = 0;
	for (i=1; i<0x10000; i<<=1)
		if (est_tim_total & i)
			mode_count++;
	if (mode_count > 1)	// if more than 1 mode, monitor supports native mode.
		pDev->Dac.fpNative = 1;

	// We'll check detailed timings first. If none, look for established timings.
	// Search for largest resolution. 
	// NEED TO ADD: There could be extensions in next EDID block, too.
	pDev->Dac.fpHActive = 0;
	mode_count = 0; // check again--multiple detailed timing block also indicates native
	for (block = 0; block <4; block++)
	{
		// detailed timing block is 18 (0x12) bytes starting at offset 0x36.
		pClk = pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block];
		pClk |= (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_DETAILED_TIMINGS_START_INDEX + 18 * block + 1])<<8;
		if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
		{
			// Seems valid, get info
			offset = EDID_V1_DETAILED_TIMINGS_START_INDEX + (18 * block);
			HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
			HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
			HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
			VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
			VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
			VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
			HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
			HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
			VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
			SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
			Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

			// Get timing into useful format
			HRes = HActive1 | (HActive2 & 0xf0)<<4;
			VRes = VActive1 | (VActive2 & 0xf0)<<4;
			HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
			VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
			HTotal = HRes + HBlank;
			VTotal = VRes + VBlank;
			HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
			HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
			VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<6;
			VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;
#if 0
			// Do some error checking
			if ((HRes + HSyncOffset + HSyncPulse) > (HTotal))
			{
				HSyncPulse &= 0x0f;		// pulse is too wide
				if (HSyncPulse == 0)
					HSyncPulse = 24;		// should work
			}
			if ((VRes + VSyncOffset + VSyncPulse) > (VTotal))
			{
				HSyncPulse &= 0x0f;		// pulse is too wide
				if (VSyncPulse == 0)
					VSyncPulse = 24;		// should work
			}
#endif
			if (HRes > pDev->Dac.fpHActive)	// largest yet?
			{
				// Does this fp support native mode?
				mode_count++;	
				if (mode_count > 1)
					pDev->Dac.fpNative = 1;	
				// Save this resolution as potential maximum.
				pDev->Dac.fpPixClk = pClk;
				pDev->Dac.fpHActive = HRes;
		 		pDev->Dac.fpHDispEnd = HRes - 1;
				pDev->Dac.fpHValidEnd = HRes - 1;
		 		pDev->Dac.fpHSyncStart = HSyncOffset + pDev->Dac.fpHDispEnd;
		 		pDev->Dac.fpHSyncEnd = HSyncPulse + pDev->Dac.fpHSyncStart;
		 		pDev->Dac.fpHValidStart = 0;
		 		pDev->Dac.fpHTotal = HTotal;
					
		 		pDev->Dac.fpVActive = VRes;
		 		pDev->Dac.fpVDispEnd = VRes - 1;
		 		pDev->Dac.fpVValidEnd = VRes - 1;
		 		pDev->Dac.fpVSyncStart =  VSyncOffset + pDev->Dac.fpVDispEnd;
		 		pDev->Dac.fpVSyncEnd = VSyncPulse + pDev->Dac.fpVSyncStart;
		 		pDev->Dac.fpVValidStart = 0;
		 		pDev->Dac.fpVTotal = VTotal;
				pDev->Dac.fpFlags = Flags;

			}
		}
	}
	// save the max resolution this fp supports 
	pDev->Dac.fpHMax = pDev->Dac.fpHActive;
	pDev->Dac.fpVMax = pDev->Dac.fpVActive;

	// If we found a valid detailed timing descriptor, use it.
	if (pDev->Dac.fpHActive)
		return RM_OK;

	// Check the "established timings" and if more than one, pick the highest.
	// There are currently no flat panels supporting refresh other than 60 Hz, so 
	// treat timings with different refresh but the same resolution as the same.
	if(est_tim1 & 0x3c)
 	{
		pDev->Dac.fpHActive = 0;	// no 640 panels. Return error unless we find higher res.
	}
	if(est_tim1 & 0x03)
	{
		// 800x600 60
		pDev->Dac.fpHActive =  800;
		pDev->Dac.fpHDispEnd = 799;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 799;
		pDev->Dac.fpHSyncStart = 799+16;
		pDev->Dac.fpHSyncEnd =  799+16+24;
		pDev->Dac.fpHTotal = 800+320;
		pDev->Dac.fpVActive = 600;
		pDev->Dac.fpVDispEnd = 599;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd =  599;
		pDev->Dac.fpVSyncStart = 599+2;
		pDev->Dac.fpVSyncEnd = 599+2+24;
		pDev->Dac.fpVTotal = 600+38;
		pDev->Dac.fpPixClk = 4000;	// 40 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}

	// established timing 2 should take precedence over 1, since it has higher resolutions
	if(est_tim2 & 0xc0)
 	{
		// 800x600 60
		pDev->Dac.fpHActive =  800;
		pDev->Dac.fpHDispEnd = 799;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 799;
		pDev->Dac.fpHSyncStart = 799+16;
		pDev->Dac.fpHSyncEnd =  799+16+24;
		pDev->Dac.fpHTotal = 800+320;
		pDev->Dac.fpVActive = 600;
		pDev->Dac.fpVDispEnd = 599;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd =  599;
		pDev->Dac.fpVSyncStart = 599+2;
		pDev->Dac.fpVSyncEnd = 599+2+24;
		pDev->Dac.fpVTotal = 600+38;
		pDev->Dac.fpPixClk = 4000;	// 40 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}
	if(est_tim2 & 0x1e)	// lumping together 60Hz, 70 Hz, 75 Hz, and 87 Hz under the assumption
						// that DFP's which support > 60 Hz (if any) will have detailed timings.
	{
		// 1024x768x60;
		pDev->Dac.fpHActive = 1024;
		pDev->Dac.fpHDispEnd = 1023;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 1023;
		pDev->Dac.fpHSyncStart = 1040;
		pDev->Dac.fpHSyncEnd = 1089;
		pDev->Dac.fpHTotal = 1344;
		pDev->Dac.fpVActive = 768;
		pDev->Dac.fpVDispEnd = 767;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd = 767;
		pDev->Dac.fpVSyncStart = 770;
		pDev->Dac.fpVSyncEnd = 776;
		pDev->Dac.fpVTotal = 805;
		pDev->Dac.fpPixClk = 6500;	// 65 MHz
		pDev->Dac.fpFlags = VSYNC_NEG | HSYNC_NEG;
	}
	if(est_tim2 & 0x01)
	{
		// 1280x1024x75;
		pDev->Dac.fpHActive = 1280;
		pDev->Dac.fpHDispEnd = 1279;
		pDev->Dac.fpHValidStart = 0;
		pDev->Dac.fpHValidEnd = 1279;
		pDev->Dac.fpHSyncStart = 1280+15;
		pDev->Dac.fpHSyncEnd = 1280+15+2;
		pDev->Dac.fpHTotal = 1280+320;
		pDev->Dac.fpVActive = 1024;
		pDev->Dac.fpVDispEnd = 1023;
		pDev->Dac.fpVValidStart = 0;
		pDev->Dac.fpVValidEnd = 1023;
		pDev->Dac.fpVSyncStart = 1023+2;
		pDev->Dac.fpVSyncEnd = 1023+2+24;
		pDev->Dac.fpVTotal = 1024+40;
		pDev->Dac.fpPixClk = 10800;	// 108 MHz
		pDev->Dac.fpFlags = VSYNC_POS | HSYNC_POS;
	}

	if (pDev->Dac.fpHActive)
	{
		// save the max resolution this fp supports 
		pDev->Dac.fpHMax = pDev->Dac.fpHActive;
		pDev->Dac.fpVMax = pDev->Dac.fpVActive;
		return RM_OK;
	}
	else
		return RM_ERROR;
 }

// EDID Version 2.x
// The first 128 bytes is not very interesting to us (I think), except the last 2 bytes,
// which are the map into second 128 bytes, which contain the luminance table and 
// timing descriptions.
// In order to get to the detailed timings, we have to parse thru the lum table, frequency
// ranges, detailed range limits, and timing codes. These are optional fields, so nothing is
// found at a fixed offset. The map bytes tell whether the fields are present.
RM_STATUS ParseEDID2(PHWINFO pDev, U032 Head)
{
RM_STATUS status;
U008	map1, map2, index, lum, rangeLimits, detailedRangeLimits;
U008	detailedTimings, block, timingCodes;
U008	HActive1, HActive2, HBlank1, HSyncOff1, HSyncPW, offset;
U008	VActive1, VActive2, VBlank1, VSyncOff1, SyncOvf, Flags, i;
U016	pClk, HRes, VRes, HSyncOffset, VSyncOffset, HSyncPulse, VSyncPulse, HBlank, VBlank;
U016	HTotal, VTotal;
U008    mode_count = 0;
U008	timingCode[4*31];
DACFPTIMING fpTim;

	map1 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX];
	map2 = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_MAP1_INDEX+1];
	index =  EDID_V2_TIMING_SECTION_START_INDEX;
	// if there is a lum table, bump index beyond
	if (map1 & EDID_V2_LUM_TABLE_EXIST)
	{
		// 1st byte in timing section gives # of bytes in lum table
		lum = pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_TIMING_SECTION_START_INDEX];
		if (lum & TRIPLE_LUM_ENTRIES)
			index += ((lum & NUM_LUM_ENTRIES)*3) + 1;
		else
			index += (lum & NUM_LUM_ENTRIES) + 1;
	}
	// if there are timing range limits, bump index
	if ((rangeLimits = (map1 & EDID_V2_FREQ_RANGES)>>EDID_V2_FREQ_RANGE_SHIFT))
		index += rangeLimits * 8;
	// if there are detailed range limits, bump index
	if ((detailedRangeLimits = map1 & EDID_V2_DETAILED_RANGE_LIMITS))
		index += detailedRangeLimits * 27;
	// if there are timing codes, save them
	if ((timingCodes = (map2 & EDID_V2_TIMING_CODES)>>EDID_V2_TIMING_CODES_SHIFT))
		for (i=0; i!=timingCodes; i++)
		{
			timingCode[i] = pDev->Dac.CrtcInfo[Head].EDID[index];
			timingCode[i+1] = pDev->Dac.CrtcInfo[Head].EDID[index+1];
			timingCode[i+2] = pDev->Dac.CrtcInfo[Head].EDID[index+2];
			timingCode[i+3] = pDev->Dac.CrtcInfo[Head].EDID[index+3];
			index += 4;
		}
	// now index points to the detailed timings (if present)
	if ((detailedTimings = (map2 & EDID_V2_DETAILED_TIMINGS)))
	{
		for (block = 0; block < detailedTimings; block++)
		{
			// A detailed timing block is 27 bytes
			// There can be up to 7 detailed timing blocks, immediately following the timing codes
			pClk = pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block];
			pClk |= (pDev->Dac.CrtcInfo[Head].EDID[index + 18 * block + 1])<<8;
			if ((pClk != 0) && (pClk != 0x0101))	// 0 and 1 could be fillers or alternate info
			{
				// Does this fp support native mode?
				// Another way to check would be to see if detailedTimings > 1,
				// but what if we find multiple detailed timings for the same resolution?
				mode_count++;	
				if (mode_count > 1)
					pDev->Dac.fpNative = 1;	

				// Seems valid, get info
				offset = index + 18 * block;
				HActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 2];
				HActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 4];
				HBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 3];
				VActive1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 5];
				VBlank1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 6];
				VActive2 = pDev->Dac.CrtcInfo[Head].EDID[offset + 7];
				HSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 8];
				HSyncPW = pDev->Dac.CrtcInfo[Head].EDID[offset + 9];
				VSyncOff1 = pDev->Dac.CrtcInfo[Head].EDID[offset + 10];
				SyncOvf = pDev->Dac.CrtcInfo[Head].EDID[offset + 11];
				Flags = pDev->Dac.CrtcInfo[Head].EDID[offset + 17];

				// Get timing into useful format
				HRes = HActive1 | (HActive2 & 0xf0)<<4;
				VRes = VActive1 | (VActive2 & 0xf0)<<4;
				HBlank = HBlank1 | (HActive2 & 0x0f)<<8;
				VBlank = VBlank1 | (VActive2 & 0x0f)<<8;
				HTotal = HRes + HBlank;
				VTotal = VRes + VBlank;
				HSyncPulse = HSyncPW | (SyncOvf & 0x30)<<4;
				HSyncOffset = HSyncOff1 | (SyncOvf & 0xc0)<<2;
				VSyncOffset = (VSyncOff1>>4) | (SyncOvf & 0x0c)<<2;
				VSyncPulse = (VSyncOff1 & 0x0f) | (SyncOvf & 0x30)<<4;

				if (HRes > pDev->Dac.fpHActive)	// largest yet?
				{
					// Return this resolution
					pDev->Dac.fpPixClk = pClk;
					pDev->Dac.fpHActive = HRes;
	 				pDev->Dac.fpHDispEnd = HRes - 1;
					pDev->Dac.fpHValidEnd = HRes - 1;
			 		pDev->Dac.fpHSyncStart = HSyncOffset + pDev->Dac.fpHDispEnd;
			 		pDev->Dac.fpHSyncEnd = HSyncPulse + pDev->Dac.fpHSyncStart;
	 				pDev->Dac.fpHValidStart = 0;
	 				pDev->Dac.fpHTotal = HTotal;
				
		 			pDev->Dac.fpVActive = VRes;
			 		pDev->Dac.fpVDispEnd = VRes - 1;
		 			pDev->Dac.fpVValidEnd = VRes - 1;
	 				pDev->Dac.fpVSyncStart =  VSyncOffset + pDev->Dac.fpVDispEnd;
		 			pDev->Dac.fpVSyncEnd = VSyncPulse + pDev->Dac.fpVSyncStart;
		 			pDev->Dac.fpVValidStart = 0;
		 			pDev->Dac.fpVTotal = VTotal;
	
					// save the max resolution this fp supports 
					pDev->Dac.fpHMax = pDev->Dac.fpHActive;
					pDev->Dac.fpVMax = pDev->Dac.fpVActive;
					pDev->Dac.fpFlags = Flags;
				}
			} // if 
		} // for
		return RM_OK;
	} // if detailed timings

	// If no detailed timings, check 4 byte timing codes
	// byte 1: active pixels/line (pixels - 256)/16. Range = 256-4336.
	// byte 2: arcane info, don't know what it means. See EDID standard.
	// byte 3: aspect ration H:V.
	// byte 4: refresh rate.
	pDev->Dac.fpHActive = 0;
	mode_count = 0;
	for (i=0; i < timingCodes; i++)	// search all codes for max res
	{
		status =  GetTimingFromCode(timingCode[i*4], &fpTim);		
		if (status == RM_OK)
			if (fpTim.HTotal > pDev->Dac.fpHActive) // new max?
			{
				mode_count++;
				pDev->Dac.fpPixClk = fpTim.PixClk;
				pDev->Dac.fpHActive = fpTim.HActive;
			 	pDev->Dac.fpHDispEnd = fpTim.HDispEnd;
				pDev->Dac.fpHValidEnd = fpTim.HValidEnd;
	 			pDev->Dac.fpHSyncStart = fpTim.HSyncStart;
			 	pDev->Dac.fpHSyncEnd = fpTim.HSyncEnd;
			 	pDev->Dac.fpHValidStart = fpTim.HValidStart;
			 	pDev->Dac.fpHTotal = fpTim.HTotal;
					
	 			pDev->Dac.fpVActive = fpTim.VActive;
			 	pDev->Dac.fpVDispEnd = fpTim.VDispEnd;
			 	pDev->Dac.fpVValidEnd = fpTim.VValidEnd;
			 	pDev->Dac.fpVSyncStart = fpTim.VSyncStart;
		 		pDev->Dac.fpVSyncEnd = fpTim.VSyncEnd;
			 	pDev->Dac.fpVValidStart = fpTim.VValidStart;
	 			pDev->Dac.fpVTotal = fpTim.VTotal;
				pDev->Dac.fpFlags = fpTim.Flags;
				pDev->Dac.fpHMax = pDev->Dac.fpHActive;
				pDev->Dac.fpVMax = pDev->Dac.fpVActive;
			}
	}
	if (pDev->Dac.fpHActive)	// if we found a mode
	{
		if (mode_count > 1)
			pDev->Dac.fpNative = 1;	
		return RM_OK;
	}
	return RM_ERROR;
}

// Parse the EDID buffer (read earlier) to determine if we have valid timings.
// 
RM_STATUS fpParseEDID(PHWINFO pDev, U032 Head)
{
U032 status = RM_ERROR;	
    // The EDID may contain "established timings", a bit map of flags showing supported 
	// resolutions, or "standard timings", a 2-byte description of horizontal res + aspect ratio,
	// or "detailed timings", an 18-byte description.
	// Version 1.x EDID starts with an 8-byte header: 00 FF FF FF FF FF FF 00.
    if (pDev->Dac.CrtcInfo[Head].EDID[0] == 0)
        if (pDev->Dac.CrtcInfo[Head].EDID[1] == 0xFF)
            if (pDev->Dac.CrtcInfo[Head].EDID[7] == 0)
            {
                // Version 1 header
                if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VERSION_NUMBER_INDEX] == 1)
                {
                    switch (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_REVISION_NUMBER_INDEX]) 
                    {
                        case 0:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_10;
                            status = ParseEDID11(pDev, Head);	// Version 1.0 just like 1.1
                            break;
                        case 1:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_11;
                            status = ParseEDID11(pDev, Head);	// Version 1.1
                            break;
                        case 2:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_12;
                            status = ParseEDID12(pDev, Head);
                            break;
                        case 3:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_13;
                            status = ParseEDID13(pDev, Head);
                            break;
                        default:
                            pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_14; // This doesn't currently exist, but just in case
                            status = ParseEDID13(pDev, Head);
                            break;
                    }

                    // Is this is a digital device or analog?
                    if (!(pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7)))
                        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_MONITOR;    
                    else    
                        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;    
                    return status;	

                }
                else // Version 1 header, but not version 1 ID?
                {
                    return RM_ERROR;
                }
            }
	// Does not have version 1 header, check version 2
    if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0)
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_MONITOR;    
        return RM_ERROR; // its a CRT	
    }
    else    
    {
        pDev->Dac.CrtcInfo[Head].EdidDisplayType = DISPLAY_TYPE_FLAT_PANEL;    
    }

    pDev->Dac.CrtcInfo[Head].EdidVersion = EDID_VERSION_20;
    return	ParseEDID2(pDev, Head);
}

BOOL edidIsAnalogDisplay(PHWINFO pDev, U032 Head) 
{
U032 version;

 	version = edidGetVersion(pDev, Head);
	if (version == 1)
	{
		// Verify this is an analog device
		if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))
			return FALSE; // 1=digital
		else
			return TRUE;
	}
	if (version == 2)
		if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) == 0)
			return TRUE;
	return FALSE;
}

BOOL edidIsDigitalDisplay(PHWINFO pDev, U032 Head) 
{
U032 version;

 	version = edidGetVersion(pDev, Head);
	if (version == 1)
	{
		// Verify this is an analog device
		if (pDev->Dac.CrtcInfo[Head].EDID[EDID_V1_VIDEO_INPUT_DEF_INDEX] & BIT(7))
			return TRUE;
		else
            return FALSE; // 1=digital
	}
	if (version == 2)
		if ((pDev->Dac.CrtcInfo[Head].EDID[EDID_V2_DISPLAY_TECHNOLOGY_INDEX] & DISPLAY_TECHNOLOGY_TYPE_MASK) != 0)
			return TRUE;
	return FALSE;
}

//
// Generate an EDID appropriate for the current mobile panel in use
//
RM_STATUS edidConstructMobileInfo
(
    PHWINFO pDev,
    U032    Head,
    U008    *pEdid
)
{

    //
    // We need to generate an EDID given the current BIOS default panel
    // info, but until the BIOS is ready for this, just return the
    // default EDID for the mobile panels
    //
    // 
    // We need to construct the EDID from the BIOS data, but for now just drop in a std panel EDID
    //
    U032 i, panel_type;
    U008 dfp_edid_SXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x30, 0x2A, 0x78, 0x20, 0x51, 0x1A,
         0x10, 0x40, 0x30, 0x70, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3c, 0x3c, 0x1E,
         // original 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x53, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xCF
         // original 0x53, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xD4
    };

    U008 dfp_edid_UXGA[] = {
         0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x3A, 0xC4,
         0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0x1C, 0x09, 0x01, 0x02,
         0x80, 0x1E, 0x17, 0xBC, 0xEA, 0xA8, 0xE0, 0x99, 0x57, 0x4B,
         0x92, 0x25, 0x1C, 0x50, 0x54, 0x00, 0x00, 0x00, 0x01, 0x41,
         0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
         0x01, 0x01, 0x01, 0x01, 0x48, 0x3F, 0x40, 0x30, 0x62, 0xB0,
         0x32, 0x40, 0x40, 0xC0, 0x13, 0x00, 0x2C, 0xE4, 0x10, 0x00,
         0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x3c, 0x3c, 0x1E,
         // original 0x00, 0x1E, 0x00, 0x00, 0x00, 0xFD, 0x00, 0x28, 0x4B, 0x1E,
         0x64, 0x11, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         // original 0x64, 0x0C, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
         0x00, 0x00, 0x00, 0xFF, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30,
         0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, 0x00, 0x00,
         0x00, 0xFC, 0x00, 0x4E, 0x56, 0x49, 0x44, 0x49, 0x41, 0x5F,
         0x55, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0x99
         // original 0x55, 0x58, 0x47, 0x41, 0x0A, 0x20, 0x00, 0xA4
    };

    U008 dfp_edid_Toshiba_10x7[] = {
        //EDID provided by Toshiba's system BIOS.
        0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x51, 0xf3, 0x82, 0x50, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1d, 0x16, 0x00, 0xca, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x64, 0x19, 0x00, 0x40, 0x41, 0x00, 0x26, 0x30, 0x18, 0x88,
        0x36, 0x00, 0x1e, 0xd7, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x54, 0x4f, 0x53,
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x0a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x72,
        0x6e, 0x61, 0x6c, 0x20, 0x31, 0x30, 0x32, 0x34, 0x78, 0x37, 0x36, 0x0a, 0x00, 0x00, 0x00, 0xfc,
        0x00, 0x38, 0x20, 0x50, 0x61, 0x6e, 0x65, 0x6c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0a, 0x00, 0xe3
    };

#if 1
    //LPL: must have been a checksum error in the older EDID below -- comparing the two,
    // in addition to two swapped bytes (checksum neutral) there is a 0x00 instead of 0x08
    // at loc. 0x24.  Yet both have a checksum byte of 0xC0.  Manually verified this one.
    U008 dfp_edid_Toshiba_14x10[] = {
        0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x51, 0xF3, 0x86, 0x50, 0x00, 0x00, 0x00, 0x00, //814
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1F, 0x17, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //184
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x90, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, //0D8
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x30, 0x2A, 0x78, 0x20, 0x51, 0x1A, 0x10, 0x40, 0x30, 0x70, //253
        0x13, 0x00, 0x31, 0xE5, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x54, 0x4F, 0x53, //343
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x0A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x72, //43C
        0x6E, 0x61, 0x6C, 0x20, 0x31, 0x34, 0x30, 0x30, 0x78, 0x31, 0x30, 0x0A, 0x00, 0x00, 0x00, 0xFC, //3FF
        0x00, 0x35, 0x30, 0x20, 0x50, 0x61, 0x6E, 0x65, 0x6C, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x00, 0xC0  //2FF = 40 + C0 = 0
    };
#else
    U008 dfp_edid_Toshiba_14x10[] = {
        0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x51, 0xF3, 0x86, 0x50, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x01, 0x03, 0x80, 0x1F, 0x17, 0x00, 0xCA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
        0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x90, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x2A, 0x30, 0x78, 0x20, 0x51, 0x1A, 0x10, 0x40, 0x30, 0x70, 
        0x13, 0x00, 0x31, 0xE5, 0x10, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x54, 0x4F, 0x53, 
        0x48, 0x49, 0x42, 0x41, 0x20, 0x49, 0x6E, 0x74, 0x65, 0x0A, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x72, 
        0x6E, 0x61, 0x6C, 0x20, 0x31, 0x34, 0x30, 0x30, 0x78, 0x31, 0x30, 0x0A, 0x00, 0x00, 0x00, 0xFC, 
        0x00, 0x35, 0x30, 0x20, 0x50, 0x61, 0x6E, 0x65, 0x6C, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x00, 0xC0, 
    };
#endif

    // Toshiba?
    if (pDev->Power.MobileOperation == 2)
    {
#if !defined(MACOS) && !defined(NTRM)
        RM_STATUS status;
        U032 eax, ebx, ecx, edx;
#endif

        //Default - use a hardwired version (not needed in 9x version, unless
        // osCallVideoBIOS fails).
        U032 strap = REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_USER_MOBILE);
        if (strap == 2) {
            for (i=0;i<128;i++) pEdid[i] = dfp_edid_Toshiba_10x7[i];
        } else {
            for (i=0;i<128;i++) pEdid[i] = dfp_edid_Toshiba_14x10[i];
        }
//
// When the active device is the CRT, this call takes 30 seconds to complete
// and returns an error code.
//
// Until we get this straightened out with Toshiba, just go with the fallback
// info
//
#if !defined(MACOS) && !defined(NTRM)
        // 
        // We need to recover the DFP EDID from the Toshiba BIOS by running through
        // our VESA EDID call.  Only implemented in Win9x at this point.
        //
        eax = 0x4F15;       // VESA EDID function
        ebx = 0x0001;
        ecx = Head;            // controller number
        edx = 0;            // EDID block number
        status = osCallVideoBIOS(pDev, &eax, &ebx, &ecx, &edx, pEdid);
#endif
    } 
    else
    {

        //
        // Dell Strapping assignments
        //
        //- SXGA+ panels            Panel ID     Timing        
        //    Hitachi  15"           0xE          SXGA+ (pclk = 108Mhz)      
        //    Sharp 15"              0x8          SXGA+       
        //    Unknown supplier       0x2          SXGA+       
        //    Unknown supplier       0x7          SXGA+      
        //  
        //- UXGA panels                
        //    Unknown supplier       0x3          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0x4          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0x5          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0xA          UXGA  ( pclk =162Mhz )
        //    Unknown supplier       0xB          UXGA  ( pclk =162Mhz )
    
        //
        // Strapped for UXGA???
        //
        panel_type = REG_RD_DRF(_PEXTDEV, _BOOT_0, _STRAP_USER_MOBILE) & 0x0F; 
        if ((panel_type == 0x03) || (panel_type == 0x04) || (panel_type == 0x05) 
            || (panel_type == 0x0A) || (panel_type == 0x0B))
        {
            for (i=0;i<128;i++)
                //pDev->Dac.CrtcInfo[Head].EDID[i] = dfp_edid_UXGA[i];
                pEdid[i] = dfp_edid_UXGA[i];
        }
        //
        // Strapped for SXGA+???
        //
        else    // assume SXGA+ if nothing else
        {
            for (i=0;i<128;i++)
                //pDev->Dac.CrtcInfo[Head].EDID[i] = dfp_edid_SXGA[i];
                pEdid[i] = dfp_edid_SXGA[i];
        }
    }

    return RM_OK;

}

//  Get the VESA DDC Capabilites status word
//  The lower 5 bits is a bit map of addresses at which a display will respond (A0, A2, A6);
//  bit 7 is set if there is more than one controller;
//  the upper byte is the response latency in seconds.
U032 edidGetDDCCaps
(
    PHWINFO pDev
)
{
    U008 lock, Adr = 0, Data = 0;
    U032 Caps = 0x100;  // set 1 second response (minimum)
    U032 Head, i2cPortId;

    if (IsNV5orBetter(pDev)) 
    {
        Caps |= 0x80;   // multiple DDC ports
    }

    if (pDev->Power.MobileOperation) {
        Caps |= 0x02;        // fake DDC to the always attached flatpanel
    }

    // Currently we can access any device from Head 0, but in the future, who knows?
    //    for (Head = 0; Head < pDev->Dac.HalInfo.NumCrtcs; Head++)   // for all heads
    for (Head = 0; Head < 1; Head++) 
    {
        // unlock the extended regs
        lock = UnlockCRTC(pDev, Head);

        if (IsNV11(pDev)) 
        {
           AssocDDC(pDev, Head);  // Connect the head to the I2C pins
        }
        // Try all I2c ports
        // NOTE: we have to know how many I2C ports there are--there is no define.
        for (i2cPortId = 0; i2cPortId < 3; i2cPortId++) 
        {
            // Send a byte (any data) to subaddress 0 and see if the device acks it.
            // Try all three monitor addresses
            if (!(Caps & 0x02)) // if we already set this bit, no need to do it again, as there is a noticeable delay
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR1, 1, &Adr, 0, &Data))
                    Caps |= 0x02;
            if (!(Caps & 0x08))
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR2, 1, &Adr, 0, &Data))
                    Caps |= 0x08;
            if (!(Caps & 0x10))
                if (!i2cWrite(pDev, Head, i2cPortId, DDC_CRT_ADR3, 1, &Adr, 0, &Data))
                    Caps |= 0x10;
        }
        RestoreLock(pDev, Head, lock);
    }
    return Caps;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\dacinit.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Manager ******************************\
*                                                                           *
* Module: DACINIT.C                                                         *
*   The DAC is initialized in this module.                                  *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <dac.h>
#include <os.h>
#include <i2c.h>
#include <edid.h>
#include "nvhw.h"
#include "nvcm.h"
#include <devinit.h>

//
// DAC names.
//
char dac16Name[] = "SGS 16-bit DAC                ";
char dac32Name[] = "SGS 32-bit DAC (Van Gogh)     ";
char dac64Name[] = "SGS 64-bit DAC (Van Dyke)     ";
char dac128Name[] = "NV 128-bit DAC (Picasso)    ";

//
// Externals.
//

extern char strDevNodeRM[];
char strEnable256Burst[] = "Enable256Burst";
char strTVOutOnPrimary[] = "TVOutOnPrimary";
char strLastExtDevice[] = "LastExtDevice";
char strCurWinDevices[] = "strCurWinDevices";

BOOL dacTVConnected(PHWINFO);

BOOL dacMonitorConnectStatus(PHWINFO,U032);
BOOL dacFlatPanelConnectStatus(PHWINFO pDev, U032);

static U032 dacGetDisplayType(PHWINFO, U032);

static RM_STATUS dacInitCurrentDevices(PHWINFO);
static RM_STATUS dacInitGetMobileEDIDFromBios(PHWINFO);
static VOID dacInitFPTableToEDID(PHWINFO, PBIOSFPTable, U008 *);

char digits[16] = {'0', '1', '2', '3', '4', '5', '6', '7',
                   '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
#define DIGIT(i,n) digits[((n >> (i * 4)) & 0xF)]
#define COMPRESSEDASCIIVAL(i) ((i - 'A') + 1)
//
// Initialize the DAC.
//
RM_STATUS initDac
(
    PHWINFO pDev
)
{
    U032 i;
    U032 j;
    U032 k;
    U032 data, data32, type;
#ifndef IKOS
    U008 data08, lockA;
#endif
    U032 freq = 0;

    //
    // Initialize flags.
    //
    pDev->Dac.UpdateFlags = 0;
    pDev->Dac.DisplayChangeInProgress = 0;

    //
    // Disable I/O broadcast mode for now until we can figure
    // out why we can't reach HeadB through privSpace with
    // this enabled
    //
    FLD_WR_DRF_DEF(_PBUS, _DEBUG_1, _DISP_MIRROR, _DISABLE);

    nvHalDacControl(pDev, DAC_CONTROL_INIT);

    //
    // Initialize CR44 shadow contents to UNKNOWN and determine/set the
    // current boot head (call EnableHead to make things consistent).
    // 
    pDev->Dac.HalInfo.Head2RegOwner = HEAD2_OWNER_UNKNOWN;
    EnableHead(pDev, dacGetBiosDisplayHead(pDev));

    if ( BiosGetMaxExternalPCLKFreq( pDev, 1, &freq ) == RM_OK )
    {
        if ( freq != 0 )
        {
            // Convert freq from freq(Mhz)*100 to plain Hz
            freq = freq * 10000;
            pDev->halHwInfo.pDacHalInfo->CrtcInfo[1].PCLKLimit8bpp  = freq;
            pDev->halHwInfo.pDacHalInfo->CrtcInfo[1].PCLKLimit16bpp = freq;
            pDev->halHwInfo.pDacHalInfo->CrtcInfo[1].PCLKLimit32bpp = freq;
        }
    }
    //
    // Determine how to handle syncs on CRT.  This key, if it exists, tells us
    // to leave HSync ON during power mgmt of the display (CRT)
    //
    if (dacReadMonitorSyncsFromRegistry(pDev, &data32) == RM_OK)
        pDev->Dac.HsyncOff = 0;
    else
        pDev->Dac.HsyncOff = 1;     // default is to leave it off like normal

    // Determine I2C setup from BIOS
    dacReadBIOSI2CSettings(pDev);

    // Read/Parse BIOS Display Config Block
    dacParseDCBFromBIOS(pDev);

    //
    // Find out where to send TV Out commands (overrides dacReadBIOSI2CSettings)
    //
    // NV_I2C_PORT_SECONDARY is the default (unless the BIOS overrode it), but
    // we can override everything here with the registry
    if ( OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strTVOutOnPrimary, &data32) == RM_OK)
    {
        pDev->Dac.TVOutPortID = NV_I2C_PORT_PRIMARY;
    }

    //
    // Initialize cursor.
    //
    for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        pDev->Dac.CrtcInfo[i].CursorType      = DAC_CURSOR_TWO_COLOR_XOR;
        pDev->Dac.CrtcInfo[i].UpdateFlags = 0;
    }

    //
    // Start the cursor cache at 0
    //
    pDev->Dac.CursorCacheCount = 0;
    pDev->Dac.CursorCacheEntry = 0;
    pDev->Dac.CursorCacheEnable = 1;
    
    //
    // Clear the initial cursor cache data
    //
    for (k = 0; k < MAX_CACHED_CURSORS; k++)
    {
        pDev->Dac.CursorMaskCRC[k] = 0;    
        for (i = 0; i < 32; i++)    
            for (j = 0; j < 32; j++)
                pDev->Dac.CursorImageCache[i][j][k] = 0;
    }                
            
    //
    // Initialize palette to grey scale ramp.
    //
    for (i = 0; i < 256; i++)
        pDev->Dac.Palette[i] = (i << 16) | (i << 8) | i;
    //
    // Initialize gamma to unity translation.
    //
    for (i = 0; i < 256; i++)
        pDev->Dac.Gamma[i] = (i << 16) | (i << 8) | i;
    //
    // Initialize power management state.
    //
    pDev->Dac.DpmLevel = 0;

    //Initialize device properties bits, used to interpret scratch register settings.
    if (osReadRegistryDword(pDev, strDevNodeRM, "RMMaintainDevs", &data32) == RM_OK)
        pDev->Dac.DeviceProperties.RMMaintainDevs = data32;
    else
        pDev->Dac.DeviceProperties.RMMaintainDevs = 0;

    pDev->Dac.DeviceProperties.OverrideSBIOSDevs = ((pDev->Power.MobileOperation == 2) || (pDev->Power.MobileOperation == 4))?TRUE:FALSE;
    // For Toshiba, we'd like to set the infer property only in the case of spanning mode.
    // Unfortunately, at this stage the display driver hasn't told us if we're in spanning
    // mode or not.  I've seen that, at least in Win9x, the display driver enables the
    // second display itself once it is started.  But I'd rather not have the logic in
    // two locations like this.
//    pDev->Dac.DeviceProperties.InferAuxDev = FALSE;
    pDev->Dac.DeviceProperties.Spanning = FALSE;
    pDev->Dac.DeviceProperties.LastSwitchEvent = SWITCH_FROM_COLD_START;

    //
    // Check for a registry override to temporarily enable the 256Burst setting
    // within the DAC.
    //    
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, strEnable256Burst, &data) == RM_OK)
        pDev->Dac.HalInfo.Enable256Burst = data;

    //
    // Set the min/max VCO values from the BIOS. This call may fail if we're
    // running an older BIOS, so in this case we'll use the RM defaults.
    //
    if (DevinitGetMinMaxVCOValues(pDev,
                                  &pDev->Dac.FminVco,
                                  &pDev->Dac.FmaxVco) != RM_OK)
    {
        // Use the RM default values for these chips
        // NOTE: These defaults are duplicated in dacCalcMNP() which may
        //       be called before initDac()
        if (IsNV15orBetter(pDev)) {
            if (IsNV15MaskRevA01(pDev))
                pDev->Dac.FminVco = 200000;
            else
                pDev->Dac.FminVco = 250000;

            pDev->Dac.FmaxVco = pDev->Dac.FminVco * 2; 
        } else {
            pDev->Dac.FminVco = 128000;
            pDev->Dac.FmaxVco = 256000;
        }
    }

    //
    // Look for a registry override for min/max VCO (in MHz).
    //
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "FminVCO", &data32) == RM_OK)
        pDev->Dac.FminVco = data32 * 1000;

    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "FmaxVCO", &data32) == RM_OK)
        pDev->Dac.FmaxVco = data32 * 1000;

    //
    // Look for a registry override to set the maximum M value for the PLL equation
    // when driving the external DAC on NV11.  Value must be greater than or equal
    // to 1.  A value of 0 is not allowed, and therefore means the limit feature
    // is disabled.
    //
    // This value is used in dacfp.c
    //
    pDev->Dac.ExtDacMaxM = 0;   // default to off
    if (OS_READ_REGISTRY_DWORD(pDev, strDevNodeRM, "EXTERNALDACMAXM", &data32) == RM_OK)
        if ((data32 > 0) && (data32 <= 0xFF))
            pDev->Dac.ExtDacMaxM = data32;

    //
    // Attempt to detect the presense of an external TV chip.  Attempt to also
    // identify the part so we know how to program it up when a modeset comes
    // through a bit later.
    //    

    //Skip TV encoder detection for IKOS.
#ifndef IKOS
    //
    // If Canopus, skip the detection
    //
    if (pDev->Video.HalInfo.CustomizationCode & CUSTOMER_CANOPUS)
        pDev->Dac.EncoderType = NV_ENCODER_NONE;
    else
    {        
        // Use head 0 for decoder detection.
        dacDetectEncoder(pDev, 0);
    } // !Canopus

    // Get TV output format from the registry.
    if (dacReadTVOutFromRegistry(pDev, 0, &data32) == RM_OK)
        pDev->Dac.TVoutput = data32;
    else
        pDev->Dac.TVoutput = 0xffffffff;

    //
    // Get TV standard format from what the BIOS chose
    //
    lockA = ReadCRTCLock(pDev, 0);           //Back up lock state
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, 0);    //Unlock CRTC extended regs
    CRTC_RD(NV_CIO_CRE_SCRATCH0__INDEX, data08, 0);  //scratch value on HeadA only!!
    CRTC_WR(NV_CIO_SR_LOCK_INDEX, lockA, 0); // Restore lock state

    pDev->Dac.TVStandard = data08 & 0x7;
    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "DacInit - read TV standard:", pDev->Dac.TVStandard);
    
    if (!pDev->Power.MobileOperation)
    {
        // Check for User override of TV standard
        if (dacReadTVStandardFromRegistry(pDev, &type) == RM_OK)
        {
            pDev->Dac.TVStandard = type;
        }
    }
    //
    // By default on Chrontel encoders, we need to invert the encoder clock
    // out in order to lengthen our time to sample HSYNC.  Some systems require
    // this feature to be disabled, so look for a registry key to override
    // this functionality
    //
    // Default is enabled, override means disabled
    //
    if (osReadRegistryDword(pDev, strDevNodeRM, "DisableTVClockInversion", &data32) == RM_OK)
        pDev->Dac.TVClockInversionDisabled = 1;
    else
        pDev->Dac.TVClockInversionDisabled = 0;

    if (osReadRegistryDword(pDev, strDevNodeRM, "DisableTVOverscan", &data32) == RM_OK)
        pDev->Dac.TVOverscanDisabled = data32;
    else
        pDev->Dac.TVOverscanDisabled = 0;

    if (RM_OK != osReadRegistryDword(pDev, pDev->Registry.DBstrDevNodeDisplayNumber, "TVMasterMode", &pDev->Dac.TVMasterMode))
        pDev->Dac.TVMasterMode = 0;

    //
    // Default Macrovision mode (OFF)
    //
    pDev->Dac.TVLastMacrovision.devAddr         = 0;
    pDev->Dac.TVLastMacrovision.mode            = 0;
    pDev->Dac.TVLastMacrovision.port            = 0;
    pDev->Dac.TVLastMacrovision.encoderType     = 0;
    pDev->Dac.TVLastMacrovision.tvStandard      = 0;
    pDev->Dac.TVLastMacrovision.resx            = 0;
    pDev->Dac.TVLastMacrovision.resy            = 0;

    //
    // We're about to setup head 0's default display type.
    // Before we do that, invalidate any other heads.
    //
    for (i = 1; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        SETDISPLAYTYPE(pDev, i, 0xffffffff);
        SETMONITORTYPE(pDev, i, 0xffffffff);
    }


    
    //Mobile hotkey support initialization.

    pDev->HotKeys.queueHead = 0;
    pDev->HotKeys.queueTail = 0;
    pDev->HotKeys.enabled = FALSE;

    if (pDev->Power.MobileOperation)
        EnableMobileHotkeyHandling(pDev);

    //
    //Set boot display types.
    //
    dacDetectDevices(pDev, TRUE, FALSE);

    // Assume BIOS panel programming initally for all Mobile platforms
    if(pDev->Power.MobileOperation)
      pDev->Dac.BIOSPanelProgramming = 1;

    dacInitCurrentDevices(pDev);


    // We need to setup the DevicesEnabled SW flag.
    // First turn off all devices
    pDev->Dac.DevicesEnabled &= ~(DAC_ALL_DEVICES_ENABLED);
    // loop on all CRTCs
    for (i = 0; i < MAX_CRTCS; i++) 
    {
        // make sure to switch on the CurrentDisplayType
        switch(pDev->Dac.HalInfo.CrtcInfo[i].CurrentDisplayType)
        {
            case DISPLAY_TYPE_MONITOR:
                // pDev->Dac.DevicesEnabled |= DAC_CRT_ENABLED;  // CRT not currently used
                break;
            case DISPLAY_TYPE_FLAT_PANEL:
                pDev->Dac.DevicesEnabled |= DAC_PANEL_ENABLED;
                break;
            case DISPLAY_TYPE_TV:
                pDev->Dac.DevicesEnabled |= DAC_TV_ENABLED;
                break;
            default:
                break;
        }
    }

    //Use what we know about the boot devices to set up a mapping of logical->physical devices
    // for the display driver's benefit.  This is a recommendation of which head should drive
    // the primary device. Logical device 0 is the primary, logical device 1 is the secondary.
    // By default, we set head 0 to the primary.
    // This initialization should only be of interest to mobile systems that don't do explicit
    // reenumerations when the display driver changes devices (read 'Toshiba'), on desktops it's
    // all run via registry keys.  Later changes to the logical device mapping are made via
    // rmUsrAPI calls to NVRM_API_DISPLAY_SET_PHYS_MAPPING.
    pDev->Dac.LogicalDeviceMap[0] = 0;
    pDev->Dac.LogicalDeviceMap[1] = 1;
    if (pDev->Power.MobileOperation) {
        //We use a simple rule set:
        // 1) if there is only one device, leave it alone.  Except for Toshiba, which wants both
        //   devices regardless.
        // 2) if there are two, one is the internal LCD.  That's the primary.
        if ((pDev->Power.MobileOperation == 2)
            || ((pDev->Dac.BootDevicesBitMap - 1) & pDev->Dac.BootDevicesBitMap)) {
            pDev->Dac.LogicalDeviceMap[0] = 1;
            pDev->Dac.LogicalDeviceMap[1] = 0;
        }
    }

    //
    // Set the MonitorType for head 0 *only*
    //
    switch (GETDISPLAYTYPE(pDev, 0))
    {
        case DISPLAY_TYPE_MONITOR:
            SETMONITORTYPE(pDev, 0, MONITOR_TYPE_VGA);
            break;
        case DISPLAY_TYPE_TV:
            switch (pDev->Dac.TVStandard)
            {
                case NTSC_M:
                case NTSC_J:
                    SETMONITORTYPE(pDev, 0, MONITOR_TYPE_NTSC);
                    break;
                case PAL_A:
                case PAL_M:
                case PAL_N:
                case PAL_NC:
                    SETMONITORTYPE(pDev, 0, MONITOR_TYPE_PAL);
                    break;
            }
            break;
        case DISPLAY_TYPE_FLAT_PANEL:        
            SETMONITORTYPE(pDev, 0, MONITOR_TYPE_FLAT_PANEL);
            break;
        default:
            SETDISPLAYTYPE(pDev, 0, DISPLAY_TYPE_MONITOR);
    }

#endif // not IKOS

    //
    // initialize per-crtc state
    //
    for (i = 0; i < pDev->Dac.HalInfo.NumCrtcs; i++)
    {
        pDev->Dac.CrtcInfo[i].RefCount = 0;
        pDev->Dac.CrtcInfo[i].StateFlags = 0;
        pDev->Dac.CrtcInfo[i].VBlankCounter = 0;
        pDev->Dac.CrtcInfo[i].VBlankToggle = 0;
        pDev->Dac.CrtcInfo[i].VBlankCallbackList = NULL;
        pDev->Dac.CrtcInfo[i].CurrentPanOffset = 0;
        pDev->Dac.CrtcInfo[i].CurrentImageOffset = 0;
    }

    //
    // Perform any os initialization
    //
    initDacEx(pDev);
    
    //
    // initialize I2C lock flags
    //
    pDev->I2CAcquired = 0;

    //
    // Initialize mclk divide.  Default is 1 which is no
    // divide
    //
    pDev->Dac.HalInfo.MClkDivide = 1;

    //
    // Determine which head was used to boot the system
    //
    // NEED TO DO: Get this from the BIOS, but for now if we're
    // a mobile system booting the DFP let's get the drivers to swing
    // over to the secondary head.
    // LPL : preliminary version that reads from BIOS in place above.
    //
    pDev->Dac.HalInfo.InitialBootHead = 0;
    if (pDev->Power.MobileOperation && (GETDISPLAYTYPE(pDev, 0) == DISPLAY_TYPE_FLAT_PANEL))
        pDev->Dac.HalInfo.InitialBootHead = 1;

    //
    // WORKAROUND - REMOVE QUICKLY BEFORE SCOTT LONG CATCHES ME
    //
    // The current PCLK limits programmed by the HAL are head driven.
    // They really need to be device driven, as the head can drive any
    // one of many devices.  The current HeadB limits were dictated by
    // an external CRT (150MHz max) and were fine while the possible
    // DFP's and TV's stayed below that ceiling.  Now mobile is appearing
    // with huge DFP's, and therefore the 150 limit is insufficient.
    //
    // Since mobile will never use an external DAC, override in this one
    // case to 170MHz in order to handle 16x12 panels.
    //
    // The real limits will actually come from the BIOS via the BIP/3
    // parser.
    //
    if (pDev->Power.MobileOperation)
    {
        pDev->Dac.HalInfo.CrtcInfo[1].PCLKLimit8bpp = 170000000;
        pDev->Dac.HalInfo.CrtcInfo[1].PCLKLimit16bpp = 170000000;
        pDev->Dac.HalInfo.CrtcInfo[1].PCLKLimit32bpp = 170000000;
    }

    //
    // WORKAROUND FOR INCORRECT BOARD STRAPPING ON TOSHIBA SYSTEMS
    //
    // Toshiba mobile is incorrectly strapped for 24bit DFP operation,
    // which precludes the use of the TV encoder.  Force back to the
    // correct 12bit until the boards are reworked.
    //
    if (pDev->Power.MobileOperation == 2)
    {
        FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_OVERWRITE, _ENABLED);
        FLD_WR_DRF_DEF(_PEXTDEV, _BOOT_0, _STRAP_FP_IFACE, _12BIT);
    }

    // Make sure we initialize the panel strap and Mobile EDID
    dacPreInitEDID(pDev);
    
    // determine broadcast support
    // Read Head A CRTC regs
    {
      U008 Cr3C, lock;

      lock = UnlockCRTC(pDev, 0);
      CRTC_RD(NV_CIO_CRE_SCRATCH4__INDEX, Cr3C, 0);     // find out if BIOS supports broadcast mode
      RestoreLock(pDev, 0, lock);
      if((pDev->Power.MobileOperation) && // only for mobiles right now.
         (Cr3C & 0x02)  && // Bit 1 shows BIOS support for broadcast mode. 0-no support 1-supported
         (0)) //(pDev->Chip.BiosRevision > 0x3110134))  Don't support broadcast mode until I get this fixed.
        pDev->Dac.BroadcastSupport = 1;
      else
        pDev->Dac.BroadcastSupport = 0;
    }

    return (RM_OK);
}

// WinNT / Win2k Notes:
//
//        Before RmInitDevice() is called in the NT miniport, we need
//        to make sure that any non-primary monitor is 'alive',  so that
//        dacMonitorConnectStatus() works correctly.  We do this by using
//        the 'WakeUpCard' function in the miniport.
//  
//        dacMonitorConnectStatus() sometimes returns FALSE POSITIVE 
//        when on a FLAT PANEL panel or TV.  So to make NT initialization
//        as safe as possible, we need to use combinations of these functions.
//
//        1) Check for CRT first
//        2) Check for Flat Panel
//        3) Check for TV
//        4) Fall back to CRT
//

#ifdef MACOS        /* macos9 or macosX */

// Mac algorithm for monitor selection is different from windows:
//
//   if flat panel avail
//      use it
//   else if CRT attached
//      use it
//   else
//      no device, error.
//

static U032 dacGetDisplayType(
    PHWINFO pDev,
    U032 Head
)
{
    U032   BootDisplayDevice;
    U008   lock;
    RM_STATUS status;

    //
    // Use our current setting as the desired display type.
    //
    BootDisplayDevice = GETDISPLAYTYPE(pDev, Head);

    if (dacFlatPanelConnectStatus(pDev, Head))
    {
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Digital Flat Panel\n");

        BootDisplayDevice = DISPLAY_TYPE_FLAT_PANEL;
        
        dacGetPWMController(pDev);          
    }
    else if (dacMonitorConnectStatus(pDev, Head))
    {
        lock = UnlockCRTC(pDev, Head);
        status = EDIDRead(pDev, Head, DISPLAY_TYPE_MONITOR);
        RestoreLock(pDev, Head, lock);
        
        if ((status == RM_OK) && (edidIsAnalogDisplay(pDev, Head)))
            BootDisplayDevice = DISPLAY_TYPE_MONITOR;
    }

    return BootDisplayDevice;
}

#else

static U032 dacGetDisplayType(
    PHWINFO pDev,
    U032 Head
)
{
    U032 BootDisplayDevice;
    BOOL MonitorAvail, FlatPanelAvail, TVAvail, RequestedDisplayDeviceAvail;
    U032 RequestedDisplayDevice;

    //
    // Use our current setting as the desired display type.
    //
    RequestedDisplayDevice = GETDISPLAYTYPE(pDev, Head);

    // @ Detect avail display devices
    // - Check the MONITOR status
    if(dacMonitorConnectStatus(pDev, Head)) {
        MonitorAvail = TRUE;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Monitor connected\n\r");
    }
    else {
        MonitorAvail = FALSE;
    }

    // - Check the FLATPANEL status
    if(IsNV5orBetter(pDev) && dacFlatPanelConnectStatus(pDev, Head)) {
        FlatPanelAvail = TRUE;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Digital Flat Panel connected\n\r");
    }
    else {
        FlatPanelAvail = FALSE;
    }

    // - Check the TV status
    if(dacTVConnectStatus(pDev, Head)) {
        TVAvail = TRUE;
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - TV connected\n\r");
    }
    else {
        TVAvail = FALSE;
    }

    // - Assume the requested display device is not available
    RequestedDisplayDeviceAvail = FALSE;

    switch(RequestedDisplayDevice) {
        case DISPLAY_TYPE_MONITOR:
            if(MonitorAvail)
                RequestedDisplayDeviceAvail = TRUE;
            break;

        case DISPLAY_TYPE_FLAT_PANEL:
            if(FlatPanelAvail)
                RequestedDisplayDeviceAvail = TRUE;
            break;

        case DISPLAY_TYPE_TV:
            if(TVAvail)
                RequestedDisplayDeviceAvail = TRUE;
            break;

        default:
            break;
    }

    // - If the requested device is unavail, determine the next best thing
    if(!RequestedDisplayDeviceAvail)
    {
        if(MonitorAvail)
        {
            BootDisplayDevice = DISPLAY_TYPE_MONITOR;
        }
        else
        {
            if(FlatPanelAvail)
            {
                BootDisplayDevice = DISPLAY_TYPE_FLAT_PANEL;
            }
            else
            {
                if(TVAvail)
                    BootDisplayDevice = DISPLAY_TYPE_TV;
                else
                    BootDisplayDevice = dacGetBiosDisplayType(pDev, 0);
            }
        }
    }

    // - If the requested device is present, use it
    if(RequestedDisplayDeviceAvail)
        BootDisplayDevice = RequestedDisplayDevice;

    // Display the resulting display device
    switch(BootDisplayDevice) {

        case DISPLAY_TYPE_MONITOR:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Monitor selected as display device\n\r");
            break;

        case DISPLAY_TYPE_FLAT_PANEL:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Digital Flat Panel selected as display device\n\r");
            break;

        case DISPLAY_TYPE_TV:
               DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - TV selected as display device\n\r");
               break;

        default:
            DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "DacInit - Display device is unknown\n\r");
            break;
    }

    return BootDisplayDevice;
}
#endif   /* ! MACOS */


//Note this function is only intended for mobile system lookup (assumes internal LCD on head 1)
U032 dispTypeToHotkeyLookup(U032 Head, U032 dispType)
{
    if (dispType == DISPLAY_TYPE_MONITOR)
        return NV_HOTKEY_STATUS_DISPLAY_ENABLE_CRT;
    if (dispType == DISPLAY_TYPE_TV)
        return NV_HOTKEY_STATUS_DISPLAY_ENABLE_TV;
    if (dispType == DISPLAY_TYPE_FLAT_PANEL) {
        if (Head)
            return NV_HOTKEY_STATUS_DISPLAY_ENABLE_LCD;
        else
            return NV_HOTKEY_STATUS_DISPLAY_ENABLE_DFP;
    }

    return 0;
}

RM_STATUS dacDetectDevices
(
    PHWINFO pDev,
    BOOL    bStartup,
    BOOL    spoofKey
)
{
    U008 lockA, lockB, cr3BhA, cr3BhB;
    U032 i, j, curDispType[MAX_CRTCS], origDispType[MAX_CRTCS], devmask;
    U032 noCheckDevices = 0;

    // Disable I/O broadcast mode for now to work around a
    // a hardware bug that prevents us from reaching
    // HeadB through privSpace with this enabled
    FLD_WR_DRF_DEF(_PBUS, _DEBUG_1, _DISP_MIRROR, _DISABLE);

    for (i = 0; i < MAX_CRTCS; i++) {
        curDispType[i] = GETDISPLAYTYPE(pDev, i);
        //I'm seeing the display type set to a valid value when the display isn't in use.  So...
        if (!pDev->Dac.CrtcInfo[i].pVidLutCurDac) curDispType[i] = DISPLAY_TYPE_NONE;
        origDispType[i] = curDispType[i];
    }

    if (pDev->Power.MobileOperation) {
        if (pDev->Dac.DeviceProperties.RMMaintainDevs) { //Ignore SBIOS/VBIOS and apply our own selection scheme
            //Could make it so we only need to read the reg key at startup and cache the changes
            // the rest of the time.  This would avoid the problem of being unable to access
            // the registry under NT while at raised IRQL.  But I think we're safe whenever this
            // fn is called.
            if(osReadRegistryDword(pDev, strDevNodeRM, strCurWinDevices, &i) == RM_OK) {
                //Seems unfortunate to break down the bitmask into devices, only to reconstruct
                // a bitmask later, but since part of that later process is detection, and it
                // alreasy works, we'll stick with this format for now.
                curDispType[0] = DISPLAY_TYPE_NONE;
                curDispType[1] = DISPLAY_TYPE_NONE;
                if (i & DAC_DD_MASK_IN_MAP) curDispType[1] = DISPLAY_TYPE_FLAT_PANEL;
                if (i & DAC_TV_MASK_IN_MAP) curDispType[0] = DISPLAY_TYPE_TV;
                if (i & DAC_CRT_MASK_IN_MAP) curDispType[0] = DISPLAY_TYPE_MONITOR;
            } else {    //No reg key? Fallback rules apply.
                curDispType[0] = DISPLAY_TYPE_MONITOR;
                curDispType[1] = DISPLAY_TYPE_FLAT_PANEL;
            }
        } else {    //Check and use current VBIOS settings
            // Unlock both heads
            lockA = UnlockCRTC(pDev, 0);
            lockB = UnlockCRTC(pDev, 1);

            //Read CR3B regs -- used below to set default display types.
            // Write back the registers with the 'enable' bits cleared.
            // They will be set as needed via display driver calls to dacSetModeMulti.
            CRTC_RD(0x3B, cr3BhA, 0);
            CRTC_RD(0x3B, cr3BhB, 1);

            //Removed because calls to detect devices after boot but before any modesets
            //will detect no devices enabled.  If there is a modeset to each head at startup
            //this is safe.  If there were only one, and the other head had been enabled
            //in DOS but not in Windows, I think invalid CR3B settings may slip through.
        //    if (bStartup) { //May not be needed anymore -- explicit clear of what's enabled
        //                    // at startup.  Modesets will then enable whatever is needed.
        //        CRTC_WR(0x3B, cr3BhA & 0x0F, 0);
        //        CRTC_WR(0x3B, cr3BhB & 0x0F, 1);
        //    }

            RestoreLock(pDev, 0, lockA);
            RestoreLock(pDev, 1, lockB);

            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B/0 register:", cr3BhA);
            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: CR3B/1 register:", cr3BhB);

            //Set startup display options based on BIOS CR3B settings.
            if (cr3BhA & 0x20) {
                curDispType[0] = DISPLAY_TYPE_MONITOR;
            } else if (cr3BhA & 0x40) {
                curDispType[0] = DISPLAY_TYPE_TV;
            } else if (cr3BhA & 0x80) {
                curDispType[0] = DISPLAY_TYPE_FLAT_PANEL; //external DFP
            } else {
                curDispType[0] = DISPLAY_TYPE_NONE;
            }
            if (cr3BhB & 0x10) {
                curDispType[1] = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
            } else {
                curDispType[1] = DISPLAY_TYPE_NONE;
            }

            // Since the VGA modes do not support twinview modes, we may need a
            // way to infer that in Windows a second display should be enabled
            // (Since it won't be reflected in the CR3B scratch register settings).
            // We currently only apply this for Toshiba.  Dell's system BIOS
            // largely sets the values correctly, and they have agreed they'd
            // rather keep control of it themselves than have us add in logic
            // here.  God bless 'em.
            if (pDev->Dac.DeviceProperties.OverrideSBIOSDevs) {
                noCheckDevices = pDev->Dac.DevicesNoCheck;

                if(osReadRegistryDword(pDev, strDevNodeRM, strLastExtDevice, &i) == RM_OK) {
    //                DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: read ext dev:", i);
                } else {
                    i = DISPLAY_TYPE_NONE;
                }
                switch (pDev->Dac.DeviceProperties.LastSwitchEvent) {
                case SWITCH_FROM_FS_DOS:
                    //If we were in spanning mode in Windows, restore to same devices.
                    // Otherwise switch to one device, with preference for LCD.
                    if (pDev->Dac.DeviceProperties.Spanning) {
                        curDispType[0] = i;
                        curDispType[1] = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
                    } else {
                        //This should already be set properly by SBIOS coming from
                        // hibernation or cold boot, but for Win2K may not be set
                        // correctly returning from FS-DOS.
                        if (curDispType[1] != DISPLAY_TYPE_NONE)
                            curDispType[0] = DISPLAY_TYPE_NONE;
                    }
                    break;
                case SWITCH_FROM_COLD_START:
    #if 1
                    if (i != DISPLAY_TYPE_NONE) {
                        curDispType[0] = i;
                        curDispType[1] = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
                    
                        // If we hibernate in LCD+CRT Clone mode, Toshiba wants to return 
                        // to LCD+CRT whether or not the CRT is actually present.  
                        // To fix this, we use pDev->Dac.DevicesNoCheck so that when 
                        // we call dacDevicesConnectStatus() later in this function,
                        // it will return TRUE always for that particular device.
                        // This fixes bug 32780.
      //                  noCheckDevices = pDev->Dac.DevicesNoCheck;
                    }
    #else
                    if (pDev->Dac.DeviceProperties.Spanning) {
                        curDispType[0] = DISPLAY_TYPE_MONITOR;
                        curDispType[1] = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
                    } else {
                        //This should already be set properly by SBIOS coming from
                        // hibernation or cold boot, but for Win2K may not be set
                        // correctly returning from FS-DOS.
                        if (curDispType[1] != DISPLAY_TYPE_NONE)
                            curDispType[0] = DISPLAY_TYPE_NONE;
                    }
    #endif
                    break;
                case SWITCH_FROM_WINDOWS:
                default:
                    break;
                }
            }

            //
            // BUG WORKAROUND
            //
            // We used to do a device scan on every boot, but now with the new DEVICES_CONNECTED
            // API in place, this is only done on demand.
            //
            // Now with the Chrontel encoders Windows sometimes boots up all wavy.
            //
            // There appears to be a bug in programming the initial mode on the Chrontel 7007
            // TV encoder where some values are incorrect.  For whatever reason, we didn't
            // see this before because of the detection sequence that occurred before the
            // modeset.
            // 
            // In any event, asking the encoder to detect the presence of the TV clears 
            // everything up.
            //
            // Until we can find the underlying cause, force a detect even though we
            // don't need it.  This will act as a workaround until I can get someone
            // to debug the TV programming.
            //
            // PLEASE remove this as soon as possible.
            //
            // Only do this at boot time.
            if(bStartup)
                i = dacGetDisplayType(pDev, 0);  // don't really care what we get, just scan
        }

    } else {    //Desktop, not mobile
    //
    // Set default boot display type...first, use what the
    // CR28/CR33 registers tell us via the BIOS settings.
    //
        if (bStartup) {
            SETDISPLAYTYPE(pDev, 0, dacGetBiosDisplayType(pDev, 0));
            SETDISPLAYTYPE(pDev, 0, dacGetDisplayType(pDev, 0));
            curDispType[0] = GETDISPLAYTYPE(pDev, 0);
        }
    }


    //Determine which displays the VGA BIOS enabled at boot time, so that on mobile systems
    //we can have the same ones enabled in Windows.  The result is reported to the display
    //driver as a device bit mask rather than the old head-based system.
    // (We now do this re-detect at several other times, including resume from hibernation
    // and whenever the boot mask is requested).
    devmask = 0;   //clear boot device bitmask
    //Loop over all heads
    for (j = 0; j < MAX_CRTCS; j++) {   //Head
        //Loop over all list entries
        for (i = 0; (i < DCB_MAX_NUM_DEVDESCS) && (pDev->Dac.DCBDesc[i].DCBRecType != DCB_DEV_REC_TYPE_EOL); i++)
        {
//            DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "  *** Checking for: ", pDev->Dac.DCBDesc[i].DevTypeUnit);
            //If list entry is for this head...
            if (pDev->Dac.DCBDesc[i].DCBRecHead == (U032)(j?DCB_DEV_REC_HEAD_B:DCB_DEV_REC_HEAD_A))
            {
                //...and display type matches the BIOS's...
                U032 typematch = 0;
                switch (pDev->Dac.DCBDesc[i].DCBRecType) {
                case DCB_DEV_REC_TYPE_CRT:
                    if (curDispType[j] == DISPLAY_TYPE_MONITOR) typematch = 1;
                    break;
                case DCB_DEV_REC_TYPE_TV:
                    if (curDispType[j] == DISPLAY_TYPE_TV) typematch = 1;
                    break;
                case DCB_DEV_REC_TYPE_DD_SLINK:
                case DCB_DEV_REC_TYPE_DD_DLINK:
                case DCB_DEV_REC_TYPE_DD:
                    if (curDispType[j] == DISPLAY_TYPE_FLAT_PANEL) typematch = 1;
                    break;
                default:
                    break;
                }

                if (typematch) {
                    //...OR this entry's mask into the boot device mask
                    U032 temp = pDev->Dac.DCBDesc[i].DevTypeUnit;
//                    if (pDev->Power.MobileOperation != 2) //Toshiba doesn't want non-existence to prevent enabling a device
                        dacDevicesConnectStatus(pDev, &temp, noCheckDevices);   //Test for presence of this device
                    if (!temp) {
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Discarding as boot dev:", pDev->Dac.DCBDesc[i].DevTypeUnit);
                        curDispType[j] = DISPLAY_TYPE_NONE;
                    }
                    devmask |= temp;   //Device bitmask for device on this head.
                }
            }
        }

        if (bStartup && pDev->Power.MobileOperation)
            SETDISPLAYTYPE(pDev, j, curDispType[j]);
    }

    //What if nothing turned up?
    if (!devmask) {
        if (pDev->Power.MobileOperation) { 
            devmask = 0x1 << DAC_DD_OFFSET_IN_MAP;  // Fall back to the internal LCD
            curDispType[1] = DISPLAY_TYPE_FLAT_PANEL;
        } else {
            devmask = 0x1 << DAC_CRT_OFFSET_IN_MAP; // Fall back to a CRT
            curDispType[0] = DISPLAY_TYPE_MONITOR;
        }
        
        DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: No boot device determined.  Using default.\r\n");
    }
    
    // Only assign the devmask to BootDevicesBitMap if we are mobile or doing
    // startup; desktop systems calling dacDetectDevices during non-startup
    // may build an incorrect devmask (and since the BootDevicesBitMap is
    // static on desktops, we don't want to reassign it anyway)
    
    if (pDev->Power.MobileOperation || bStartup)
        pDev->Dac.BootDevicesBitMap = devmask;

    DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: Boot device(s):", pDev->Dac.BootDevicesBitMap);

#ifndef NTRM
    // There may have been a change in which devices are connected during power-down.
    // When we resume, on mobile systems we emulate the state the system BIOS powered
    // up in.  Under Win2K, this is handled with ACPI events.  Under Win9x, we may generate
    // a fake hotkey event here which will switch the displays if needed.  Currently
    // only used with Toshiba.
    if (spoofKey && pDev->Power.MobileOperation) {
        if ((curDispType[0] != origDispType[0]) || (curDispType[1] != origDispType[1])) {
            U032 induceSwitch;
            induceSwitch = dispTypeToHotkeyLookup(0, curDispType[0]) | dispTypeToHotkeyLookup(1, curDispType[1]);
            hotkeyAddEvent(pDev, NV_HOTKEY_EVENT_DISPLAY_ENABLE, induceSwitch);
        }
    }
#endif

    return RM_OK;
}

static RM_STATUS dacInitCurrentDevices
(
    PHWINFO pDev
)
{
    U008 lockA, lockB, cr3BhA, cr3BhB;

    if (pDev->Power.MobileOperation) {

        // Unlock both heads
        lockA = UnlockCRTC(pDev, 0);
        lockB = UnlockCRTC(pDev, 1);
    
        //Read CR3B regs -- used below to set default display types.
        CRTC_RD(0x3B, cr3BhA, 0);
        CRTC_RD(0x3B, cr3BhB, 1);
        RestoreLock(pDev, 0, lockA);
        RestoreLock(pDev, 1, lockB);

        //Set startup display options based on BIOS CR3B settings.
        if (cr3BhA & 0x20) {
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = DISPLAY_TYPE_MONITOR;
        } else if (cr3BhA & 0x40) {
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = DISPLAY_TYPE_TV;
        } else if (cr3BhA & 0x80) {
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = DISPLAY_TYPE_FLAT_PANEL; //external DFP
        } else {
            pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = DISPLAY_TYPE_NONE;
        }
        
        if (cr3BhB & 0x10) {
            pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType = DISPLAY_TYPE_FLAT_PANEL; //internal LCD
        } else {
            pDev->Dac.HalInfo.CrtcInfo[1].CurrentDisplayType = DISPLAY_TYPE_NONE;
        }
    } else { // Non-mobile case already detected in dacDetectDevices.
        pDev->Dac.HalInfo.CrtcInfo[0].CurrentDisplayType = pDev->Dac.HalInfo.CrtcInfo[0].DisplayType;
    }
    return RM_OK;
}

static RM_STATUS dacInitGetMobileEDIDFromBios(PHWINFO pDev)
{
    U032 rmStatus = RM_ERROR;
    U032 offset;
    BMP_Control_Block bmpCtrlBlk;
    BIOSFPTable biosFPTable;
    U008 fpTableIndex;
    U008 fpXlateTable[SIZE_FP_XLATE_TABLE];
    U032 useDynEDIDs;

    //The sequence of events here is
    //A.) Find the control block
    //B.) If correct ver/subver grab the BMP Table
    //C.) Get strappings from vbios call
    //D.) Read a translate table from the bios
    //E.) Use the straps to index into the translate table
    //F.) Take the entry at that index in the xlate talbe
    //    and that is the index of the FP_TABLE you want to
    //    use.
    //G.) Mult the xlate table entry by # bytes in an FP_TABLE
    //    then add this to the FP_TABLE ptr in the control blk.
    //    This gets you to the FP_TABLE you need.
    //H.) Read in the FP_TABLE and extract EDID DTD.

    //Check to see if this feature is desired, based on registry key setting:
    pDev->Dac.MobileEDID[0] = 1;    //Assure the EDID is invalid unless we get all the way through.
                                    // (checked in edidConstructMobileInfo())
    rmStatus = osReadRegistryDword(pDev, strDevNodeRM, "SoftEDIDs", &useDynEDIDs);
    if ((rmStatus != RM_OK) || !useDynEDIDs) {
        rmStatus = RM_ERROR;
    } else {
        rmStatus = DevinitGetBMPControlBlock(pDev, &bmpCtrlBlk, &offset);
    }

    if (rmStatus == RM_OK)
    {
        //According to the bios guys only Rev5 Subver14 BMP Tables
        //can be guaranteed to have this structure. We cannot 
        //necessarily assume this will stay the same in later subvers.
        if (bmpCtrlBlk.CTL_Version == BMP_INIT_TABLE_VER_5 &&
            bmpCtrlBlk.CTL_Flags >= BMP_INIT_TABLE_SUBVER_0x14)
        {
            BMP_Struc_Rev5_0x14 bmpInitTableInfo;

            rmStatus = BiosReadStructure(pDev, 
                                        (U008*)&bmpInitTableInfo,
                                        offset,
                                        (U032 *)0,
                                        BMP_INIT5_0x14_FMT);
            if (rmStatus == RM_OK)
            {
                //Read the 16 byte XLate table
                rmStatus = BiosReadBytes(pDev,
                                         fpXlateTable,
                                         bmpInitTableInfo.BMP_FPXlateTablePtr,
                                         sizeof( fpXlateTable )); 
                if (rmStatus == RM_OK)
                {
                    //Index into the XLate table to determine
                    //which FPTable we want.
                    fpTableIndex = fpXlateTable[pDev->Dac.PanelStrap];

                    //Multiply the index of the desired FPTable
                    //by the size of the FPTable and add that
                    //to the base pointer found in the BMP
                    //table. This should get us to exactly the
                    //FPTable we want.
                    rmStatus = BiosReadStructure(pDev,
                                                 &biosFPTable,
                                                 bmpInitTableInfo.BMP_FPTablePtr + 
                                                 (fpTableIndex * BMP_FP_TABLE_SIZE),
                                                 (U032 *)0, BMP_FP_TABLE_FMT);
                    if (rmStatus == RM_OK)
                    {
                        //Now that we have the FPTable, extract
                        //out everything we need to make an EDID.
                        dacInitFPTableToEDID(pDev, &biosFPTable, pDev->Dac.MobileEDID);
                        DBG_PRINT_STRING_VALUE(DEBUGLEVEL_ERRORS, "NVRM: MobileEDID ptr:", (U032)(NV_UINTPTR_T)(pDev->Dac.MobileEDID));
                    }
                }
            }
        }
        else
        {
            rmStatus = RM_ERROR;
        }
    }

    return rmStatus;
}


//Looks up numerical value of a character interpreted as a hex digit,
// and shifts it in to the low nibble of an 8-bit result.
// Non-hex characters have no effect.  This automatically handles
// most leading/trailing characters.  Returns TRUE is a hex char was found.
BOOL convNibbleFromHex(U008 textchar, U008 *cumulative)
{
    if ((textchar >= '0') && (textchar <= '9'))
        *cumulative = (*cumulative << 4) | (textchar - '0');
    else if ((textchar >= 'A') && (textchar <= 'F'))
        *cumulative = (*cumulative << 4) | (textchar - 'A' + 10);
    else if ((textchar >= 'a') && (textchar <= 'f'))
        *cumulative = (*cumulative << 4) | (textchar - 'a' + 10);
    else
        return FALSE;

    return TRUE;
}


// Read Straps from bios and create Mobile EDID
VOID dacPreInitEDID(PHWINFO pDev)
{
    // Check to see if we've initialized the panel strap
    if(!(pDev->Dac.DevicesEnabled & DAC_PRE_EDID_INITIALIZED))
    {
        // Create Mobile EDID
        if (pDev->Power.MobileOperation)
        {
            // Get Panel Strap
            U032 eax, ebx, ecx, edx;
            // FP Straps come back in CL.
            eax = 0x4F14;
            ebx = 0x0186;
            ecx = edx = 0;
            
            // Call BIOS to get strap
            osCallVideoBIOS(pDev, &eax, &ebx, &ecx, &edx, NULL);
            
            // If the BIOS call fails, it will return 0x014f
            if (eax == 0x014F)
                pDev->Dac.PanelStrap = 0;  // BIOS call didn't support it
            else if (eax == 0x004F)
                pDev->Dac.PanelStrap = ecx & 0xF; //We only care about the lower nibble.
            else
            {
                // In WinXP, this call can occur before the int10 handler has been
                // hooked, so that osCallVideoBIOS doesn't get to our vbios. In this
                // case, don't set the DAC_PRE_EDID_INITIALIZED flag, so we can try
                // again on a subsequent call.
                pDev->Dac.PanelStrap = 0;
                return;
            }
        
            dacInitGetMobileEDIDFromBios(pDev);
        }
        else
            pDev->Dac.PanelStrap = 0;  // Panel straps only for Mobile BIOSes
    
        // Set flag so we don't have to run this function again.
        pDev->Dac.DevicesEnabled |= DAC_PRE_EDID_INITIALIZED;
    }
}


//Calculate and assign the EDID checksum, defined as the value that causes the
// sum of all 128 bytes, mod 256, to total 0.
static VOID dacInitCalculateEDIDChkSum(PHWINFO pDev, U008 *pEdid)
{
    U032 i;
    U008 chksum = 0;

    for (i = 0; i < 127; i++)
    {
        chksum += pEdid[i];
    }

    pEdid[0x7F] = (~chksum) + 1;
}


#define DD_BLOCK_LENGTH 18
#define DD_BLOCK_DESC_LENGTH 5
#define MAX_MON_STRING_LENGTH ((DD_BLOCK_LENGTH - DD_BLOCK_DESC_LENGTH) * 3)

static VOID dacInitFPTableToEDID(PHWINFO pDev, PBIOSFPTable pFPTable, U008 *pEdid)
{
    U032 i, j, RegHImageSize, RegVImageSize;
    U008 HActive, HBlank, HAcHBlnk;
    U008 HSyncOffset, HSyncPW, HImageSize, HBorder;
    U008 VActive, VBlank, VAcVBlnk;
    U008 VSyncOffset, VSyncPW, VImageSize, VBorder;
    U008 VSyncOffPW, HVSyncOffPW, HVImageSize;
    U008 Flags;
    U032 panelStrap = pDev->Dac.PanelStrap;
    U032 numbytes;
    U032 HexManufacturerName = 0, blknum = 0, curblk;
    char PanelXX[16];// = "Panel";
    char EDIDPanelXX[16];// = "EDIDPanel";
    char *manufacturername = "NVD";
    char panelname[MAX_MON_STRING_LENGTH];// = "Nvidia Default Flat Panel";
    char featuresupport = (U008)0xEA;
    char PanelRegKeyVal[800];   //Needs to be big enough to hold a string describing
                                //a full EDID (128 * x chars per entry, e.g. "3, a, 4" or "0x23, 0x50")

    /* XXX  temporary hack to work around gcc curiosity on linux: gcc was
       implicity inserting a memset into this code to clear the bytes of
       PanelXX[] from after "Panel" through the end of the array (and
       likewise for EDIDPanelXX[] and panelname[] -- any statically
       sized character array that was assigned a string smaller than
       the array size).  This results in an unresolved symbol when insmod'ing
       NVdriver into a 2.2.x kernel.  The quick 'n dirty solution is to
       explicitly clear the memory and strcpy the default string values into
       the arrays, though I don't quite understand what the difference is
       between gcc's inserted memset, and the memset called by osMemSet.
       My guess is that the preprocessor does something with the memset
       called by osMemSet to change it into a symbol defined by the kernel,
       while the memset inserted by gcc gets inserted after preprocessing,
       and thus does not get translated into a symbol defined by the
       kernel... that's only a guess, though.
       
       remove this hack as soon as we find a better solution. */

    osMemSet (PanelXX, 0, 16);
    osStringCopy (PanelXX, "Panel");

    osMemSet (EDIDPanelXX, 0, 16);
    osStringCopy (EDIDPanelXX, "EDIDPanel");

    osMemSet (panelname, 0, MAX_MON_STRING_LENGTH);
    osStringCopy (panelname, "Nvidia Default Flat Panel");
    
    //Just in case
    for (i = 0; i < 128; i++)
    {
        pEdid[i] = 0x00;
    }

    //Construct registry key for individual parameter overrides.
    // Format is 'Panel'+ a 2-digit strap index.
    i = osStringLength(PanelXX);
    PanelXX[i++] = DIGIT(1, panelStrap);
    PanelXX[i++] = DIGIT(0, panelStrap);
    PanelXX[i] = NULL;

    //XXX: Not really needed here. Can be moved to edidConstructMobileInfo
    //Construct registry key for full-EDID override.
    // Format is 'EDIDPanel'+ a 2-digit strap index.
    i = osStringLength(EDIDPanelXX);
    EDIDPanelXX[i++] = DIGIT(1, panelStrap);
    EDIDPanelXX[i++] = DIGIT(0, panelStrap);
    EDIDPanelXX[i] = NULL;

    //Now read out field-based overrides.
    // The fields are all packed into one comma-separated string, with most commonly
    // overriden elements first.  In order to skip a field in the string without
    // overriding it, follow the preceding comma immediately with another comma.
    // Field order: Manufacturer descriptor string, manufacturer ID (3 chars), Feature Support
    numbytes = sizeof(PanelRegKeyVal);
    if (osReadRegistryBinary(pDev, strDevNodeRM, PanelXX, (U008 *)PanelRegKeyVal, &numbytes) == RM_OK) 
    {
        i = j = 0;

        while ((PanelRegKeyVal[j] != ',') && (PanelRegKeyVal[j] != '\0'))
        {
            panelname[i++] = PanelRegKeyVal[j++];
        }
        if (i) {  //if this field had at least one char
            for (;i < MAX_MON_STRING_LENGTH; i++) panelname[i] = '\0';  //pad the rest of the field with NULLs
        }

        if (PanelRegKeyVal[j] != '\0') {
            j++;
            i = 0;

            //Extract manufacturer code
            while ((PanelRegKeyVal[j] != ',') && (PanelRegKeyVal[j] != '\0'))
            {
                manufacturername[i++] = PanelRegKeyVal[j++];
            }
//            if (i) manufacturername[i] = '\0';  //if this field had at least one char

            if (PanelRegKeyVal[j] != '\0') {
                U008 entry = 0;
                j++;
                i = 0;

                while ((PanelRegKeyVal[j] != ',') && (PanelRegKeyVal[j] != '\0'))
                {
                    if (convNibbleFromHex(PanelRegKeyVal[j++], &entry)) i++;
                }
                if (i) featuresupport = entry;  //if this field had at least one digit
            }
        }
    }

    //Convert to 5 bit compressed ASCII to encode in 2 bytes of the EDID.
    HexManufacturerName = (COMPRESSEDASCIIVAL(manufacturername[0]) & 0x1F) << 10;
    HexManufacturerName |= (COMPRESSEDASCIIVAL(manufacturername[1]) & 0x1F) << 5;
    HexManufacturerName |= COMPRESSEDASCIIVAL(manufacturername[2]) & 0x1F;


    // Extract out all the relevant bits from the BIOS FP_TABLE
    // We need to fill in a Detailed Timing Descriptor (DTD) in an EDID.
    // The following is from the VESA EDID spec (sec 3.16) and descibes 
    // why we have to do all the shifting and masking below.

    /****************************************************************/
    /* Bytes|   Detailed Timing Desc.   |           Format          */
    /* ------------------------------------------------------------ */
    /*  2   | Pixel Clock/10,000        | Stored LSB First          */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Active         | Pixels, lower 8bits       */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Blanking       | Pixels, lower 8bits       */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Active:        | Upper nibble: Upper 4 bits*/
    /*      | Horizontal Blanking       | of Horizontal Active.     */
    /*      |                           | Lower nibble: Upper 4 bits*/
    /*      |                           | of Horzinontal Blanking   */
    /* ------------------------------------------------------------ */
    /*  1   | Vertical Active           | Lines, lower 8bits        */
    /* ------------------------------------------------------------ */
    /*  1   | Vertical Blanking         | Lines, lower 8bits        */
    /* ------------------------------------------------------------ */
    /*  1   | Vertical Active:          | Upper nibble: Upper 4 bits*/
    /*      | Vertical Blanking         | of Vertical Active.       */
    /*      |                           | Lower nibble: Upper 4 bits*/
    /*      |                           | of Vertical Blanking      */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Sync Offset    | Pixelss, from blanking    */
    /*      |                           | starts. Lower 8 bits      */
    /* ------------------------------------------------------------ */
    /*  1   | Horiz Sync Pulse Width    | Pixels, lower 8 bits      */
    /* ------------------------------------------------------------ */
    /*  1   | Vertical Sync Offset:     | Upper nibble: lines, lower*/
    /*      | Vertical Sync Pulse Width | 4 bits of VSync Offset.   */
    /*      |                           | Lower nibble: lines, lower*/
    /*      |                           | 4 bits of VSync PW        */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Sync Offset    | bits 7,6: upper 2bits HSO */
    /*      | HSync Pulse Width         | bits 5,4: upper 2bits HSPW*/
    /*      | Vertical Sync Offset      | bits 3,2: upper 2bits VSO */
    /*      | VSync Pulse Width         | bits 0,1: upper 2bits VSPW*/
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Image Size     | mm, lower 8 bits          */
    /* ------------------------------------------------------------ */
    /*  1   | Vertical Image Size       | mm, lower 8 bits          */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal & Vertical     | Upper nibble: upper 4bits */
    /*      | Image Size                | of Horiz Image Size.      */
    /*      |                           | Lower nibble: upper 4bits */
    /*      |                           | of Vert Image Size.       */
    /* ------------------------------------------------------------ */
    /*  1   | Horizontal Border         | Pixels, see vesa spec 3.12*/
    /* ------------------------------------------------------------ */
    /*  1   | Vertical Border           | Lines, see vesa spec 3.12 */
    /* ------------------------------------------------------------ */
    /*  1   | Flags                     | See Vesa Spec 3.16        */
    /* ------------------------------------------------------------ */

    HActive     = (U008)(pFPTable->HActive & 0xFF);
    HBlank      = (U008)(((pFPTable->HTotal - pFPTable->HActive) + 0x01) & 0xFF);
    HAcHBlnk    = (U008)(((pFPTable->HActive & 0x0F00) >> 4) | 
                        (((pFPTable->HTotal - pFPTable->HActive) >> 8) & 0x0F));
    VActive     = (U008)(pFPTable->VActive & 0xFF);
    VBlank      = (U008)(((pFPTable->VTotal - pFPTable->VActive) + 0x01) & 0xFF);
    VAcVBlnk    = (U008)(((pFPTable->VActive & 0x0F00) >> 4) | 
                  (((pFPTable->VTotal - pFPTable->VActive) >> 8) & 0x0F));
    HSyncOffset = (U008)(((pFPTable->HSyncStart - pFPTable->HActive) + 0x01) & 0xFF);
    HSyncPW     = (U008)((pFPTable->HSyncEnd - pFPTable->HSyncStart) & 0xFF);
    VSyncOffset = (U008)(((pFPTable->VSyncStart - pFPTable->VActive) + 0x01) & 0xFF);
    VSyncPW     = (U008)((pFPTable->VSyncEnd - pFPTable->VSyncStart) & 0xFF);
    VSyncOffPW  = (U008)(((VSyncOffset & 0x0F) << 4) | (VSyncPW & 0x0F));
    HVSyncOffPW = (U008)(((pFPTable->HSyncStart - pFPTable->HActive) & 0xC000)  |
                  (((pFPTable->HSyncEnd - pFPTable->HSyncStart) & 0xC000) >> 2) |
                  (((pFPTable->VSyncStart - pFPTable->VActive) & 0xC000) >> 4)  |
                  (((pFPTable->VSyncEnd - pFPTable->VSyncStart) & 0xC000) >> 6));
    HBorder     = (U008)(((pFPTable->HValidEnd - pFPTable->HDispEnd) & 0xFF));
    VBorder     = (U008)(((pFPTable->VValidEnd - pFPTable->VDispEnd) & 0xFF));
    //OR 0x18 into flags. This means:Non-Interlaced, No Stereo, Digital Separate.
    //The lower 2 bits of pFPTable->Flags tells us the sync polarities.
//    Flags       = (U008)(0x18 | (pFPTable->Flags & 0x03)); 
    //Meaning of bits 1 & 2 vary with setting, but for Digital Separate they are
    //Vsync polarity (bit 0 in BMP entry) and Hsync polarity (bit 4 in BMP entry)
    Flags       = (U008)(0x18 | ((pFPTable->Flags << 2) & 0x04) | ((pFPTable->Flags >> 3) & 0x02)); 

    //11 inches x 7 inches
    RegHImageSize = 0x011E;
    RegVImageSize = 0x00D7;

    HImageSize  = (U008)(RegHImageSize & 0xFF);
    VImageSize  = (U008)(RegVImageSize & 0xFF);
    HVImageSize = (U008)(((RegHImageSize & 0x0F00) >> 4) | ((RegVImageSize & 0x0F00) >> 8));

    //Construct a valid version 1 EDID header {00, FF, FF, FF, FF, FF, FF, 00}
    (*(U032*)pEdid)      = 0xFFFFFF00;
    (*(U032*)(pEdid +4)) = 0x00FFFFFF;

    pEdid[0x8] = (U008)((HexManufacturerName & 0xFF00) >> 8);
    pEdid[0x9] = (U008)(HexManufacturerName & 0x00FF);

    pEdid[0xB] = (U008)panelStrap; //Encode strapping number as a monitor ID digit.
                                   //This makes each EDID unique from Windows' perspective.

    //Fill in a version of 0x01
    //Fill in a revision of 0x03
    pEdid[0x12] = 0x01;
    pEdid[0x13] = 0x03;

    //Basic Display parameters
    pEdid[0x14] = 0x80; //Digital Signal level
    pEdid[0x15] = 0x1D; //Max Horiz Image Size (cm)
    pEdid[0x16] = 0x16; //Max Vert Image Size (cm)

    //Set Feature Support to indicate that we support
    //Standby, Suspend, Non-RGB MultiColor display,
    //and our prefered timing is in the first DTD block
    //(defined below).
    pEdid[0x18] = featuresupport; //0xCA;

    //Fill standard timings with 0x01 (means 'unused' in EDID parlance)
    *(U032*)(pEdid + 0x026) = 0x01010101;
    *(U032*)(pEdid + 0x02A) = 0x01010101;
    *(U032*)(pEdid + 0x02E) = 0x01010101;
    *(U032*)(pEdid + 0x032) = 0x01010101;

    //Begin Detailed Timing Description
    pEdid[0x36] = (U008)(pFPTable->PixClk & 0x00FF);
    pEdid[0x37] = (U008)((pFPTable->PixClk & 0xFF00) >> 8);
    pEdid[0x38] = HActive;
    pEdid[0x39] = HBlank;
    pEdid[0x3A] = HAcHBlnk;
    pEdid[0x3B] = VActive;
    pEdid[0x3C] = VBlank;
    pEdid[0x3D] = VAcVBlnk;
    pEdid[0x3E] = HSyncOffset;
    pEdid[0x3F] = HSyncPW;
    pEdid[0x40] = VSyncOffPW;
    pEdid[0x41] = HVSyncOffPW;
    pEdid[0x42] = HImageSize;
    pEdid[0x43] = VImageSize;
    pEdid[0x44] = HVImageSize;
    pEdid[0x45] = HBorder;
    pEdid[0x46] = VBorder;
    pEdid[0x47] = Flags;

    //Fill in panel name.  LPL: should we enforce a null terminator as last char?
    i = 0;
    while (i < MAX_MON_STRING_LENGTH)
    {
        curblk = 0x48 + (blknum * DD_BLOCK_LENGTH);
        pEdid[curblk+3] = 0xFC; //header is
        for (j = DD_BLOCK_DESC_LENGTH; j < DD_BLOCK_LENGTH; j++, i++)
        {
            if (panelname[i] != NULL)
            {
                pEdid[0x48 + (blknum * DD_BLOCK_LENGTH) + j] = panelname[i];
            }
        }
        blknum++;
        if (panelname[i] == NULL) break;
    }


    //Check if there is a full-EDID override key.  Parsing assumes a hexadecimal, comma-separated list.
    //Should we enforce a correct checksum, ignore it, or calculate it for them?  Currently we calc
    // it for them.
    if (osReadRegistryBinary(pDev, strDevNodeRM, EDIDPanelXX, (U008 *)PanelRegKeyVal, &numbytes) == RM_OK) 
    {
        U008 entry;
        i = 0;
        //Parsing presumes a comma-separate list, but is otherwise robust enough for
        // most hex digit formats. (padded to 2 digits or not, leading or trailing $, h, 0x, or none, etc.)
        for (j = 0; j <= numbytes; j++) {   //include terminating null char
            if ((PanelRegKeyVal[j] == ',') || (PanelRegKeyVal[j] == '\0')) {
                pEdid[i++] = entry;
                entry = 0;
            } else {
                convNibbleFromHex(PanelRegKeyVal[j], &entry);
            }
        }
    }


    //Make sure Num 128byte blocks to follow is 0
    pEdid[0x7E] = 0x00;
    //Make sure Checksum makes the edid add up to 0 
    dacInitCalculateEDIDChkSum(pDev, pEdid);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\dac\nv\i2c.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-1997 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-1997  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************* I2C Control *******************************\
*                                                                           *
* Module: I2C.C                                                             *
*   The I2C port is managed within this module.                             *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nvrm.h>
#include <state.h>
#include <class.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>
#include "i2c.h"

#include <nvmisc.h>
#define xxx(d, fmt) nv_debug(99, fmt)

//---------------------------------------------------------------------------
//
//  I2C support routines.
//
//---------------------------------------------------------------------------

// Serial Port Bits
#define I2C_SRCK        0x20    // Serial Clock write
#define I2C_SRD         0x10    // Serial Data  write
#define I2C_SRCK_IN     0x04    // Serial Clock read
#define I2C_SRD_IN      0x08    // Serial Data  read
#define I2C_ENABLE      0x01    // Enable Serial Port Function

///////////////////////////////////////////////////////////////////

// Constants used by I2C Protocol:

#define SDA_REG         0x02
#define SCL_REG         0x01


#define ACK             0   // I2C Acknowledge
#define NACK            1   // I2C No Acknowledge

#define I2CDELAY 10000   // 10usec
	
// Module Global Variables

// variables could be modified via INI file
// U008 iniFlag = FALSE;
#ifdef  IKOS
U032 wMaxWaitStates=2;     // max wait states for I2C bus syncronisation
#else   // IKOS
U032 wMaxWaitStates=3000;  // max wait states for I2C bus syncronisation
#endif  // IKOS
U032 wGpo=0;               // GPO bits for switching to I2C operation

//
// Insure register updates have been flushed out of the write buffer
// by performing a cpuid instruction
//
// XXX this should be in common/nvUtil/ or somewhere else
#ifdef WIN31

#ifdef NEWWIN31

void __cdecl FlushWB(void)
{
    __asm push esi
    __asm push edi
    __asm push ebx
    __asm mov eax, 0x0
        __asm _emit 0x0f
        __asm _emit 0xa2
    __asm pop ebx
    __asm pop edi
    __asm pop esi
}

#else  //old win31

void FlushWB(void);
#pragma aux FlushWB =				\
            "mov    EAX, 0x0"			\
            0x0F 0xA2
#endif

#elif defined(__PPC__)

void FlushWB(void)
{
    __eieio();
}


#elif defined(__GNUC__)		// UNIX and DJPP
void FlushWB(void)
{
#ifndef IA64
    // save regs (especially ebx) that might get stomped by 'cpuid'
    __asm__("push %esi");
    __asm__("push %edi");
    __asm__("push %ebx");
        __asm__("xorl %eax, %eax");
        __asm__("cpuid");
    __asm__("pop %ebx");
    __asm__("pop %edi");
    __asm__("pop %esi");
#endif
}

#else   // !WIN31 !UNIX !DJPP

void __cdecl FlushWB(void)
{
// TO DO: what to do about inline asm for IA-64?       
#ifndef IA64
    __asm push esi
    __asm push edi
    __asm push ebx
    __asm mov eax, 0x0
        __asm _emit 0x0f
        __asm _emit 0xa2
    __asm pop ebx
    __asm pop edi
    __asm pop esi
#endif // IA-64 cannot tolerate inline asm
}

#endif

void i2cWriteCRTCWrIndex
(
    PHWINFO pDev,
    U032 Head,
    U032 portID,
    U008 data
)
{
    switch (portID) 
    {
    case NV_I2C_PORT_PRIMARY:
        CRTC_WR(pDev->Dac.I2CPrimaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_SECONDARY:
        CRTC_WR(pDev->Dac.I2CSecondaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_TERTIARY:
        CRTC_WR(pDev->Dac.I2CTertiaryWriteIndex, data, Head);
        break;
    }
}

   
U008 i2cReadCRTCWrIndex
(
    PHWINFO pDev,
    U032 Head,
    U032 portID
)
{
    U008 data = 0xFF;

    switch (portID) 
    {
    case NV_I2C_PORT_PRIMARY:
        CRTC_RD(pDev->Dac.I2CPrimaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_SECONDARY:
        CRTC_RD(pDev->Dac.I2CSecondaryWriteIndex, data, Head);
        break;
    case NV_I2C_PORT_TERTIARY:
        CRTC_RD(pDev->Dac.I2CTertiaryWriteIndex, data, Head);
        break;
    }
    return data;
}
   

U008 i2cReadCRTCStatusIndex
(
    PHWINFO pDev,
    U032 Head,
    U032 portID
)
{
    U008 data = 0xFF;

    switch (portID) 
    {
    case NV_I2C_PORT_PRIMARY:
        CRTC_RD(pDev->Dac.I2CPrimaryStatusIndex, data, Head);
        break;
    case NV_I2C_PORT_SECONDARY:
        CRTC_RD(pDev->Dac.I2CSecondaryStatusIndex, data, Head);
        break;
    case NV_I2C_PORT_TERTIARY:
        CRTC_RD(pDev->Dac.I2CTertiaryStatusIndex, data, Head);
        break;
    }
    return data;
}

U008 i2cHardwareInit
(
    PHWINFO pDev,
    U032 Head,
    U032 portID
)
{
    // On dual-headed devices, enable I2C interface
    if (IsNV11(pDev)) 
    {
        AssocDDC(pDev, Head);
    }
    
    //
    // If the initialization has already been done then just return
    //
    // if (iniFlag == TRUE)
    //    return TRUE;

    i2cWriteCRTCWrIndex(pDev, Head, portID, 0x31);
	
	pDev->Dac.I2cIniFlag = TRUE;
	return TRUE;
}


VOID i2cWriteCtrl
(
    PHWINFO pDev,
    U032 Head,
    U032 portID,
    U008 reg,
    U008 bit
)
{
    U008 data;

    //
    // Get the current status and toggle
    //
	data = i2cReadCRTCWrIndex(pDev, Head, portID);

	data &= 0xf0;
    data |= I2C_ENABLE;
    
    if (reg == SCL_REG)
    {
      if (bit)
        data |=  I2C_SRCK;
      else
        data &= ~I2C_SRCK;
    }
    else
    {
      if (bit)
        data |=  I2C_SRD;
      else
        data &= ~I2C_SRD;
    }    

	i2cWriteCRTCWrIndex(pDev, Head, portID, data);
    FlushWB();
}

U008 i2cReadCtrl
(
    PHWINFO pDev,
    U032 Head,
    U032 portID,
    U008 reg
)
{
    U008 data;
   
    data = i2cReadCRTCStatusIndex(pDev, Head, portID);    

    if (reg == SCL_REG)
        return ( (data & I2C_SRCK_IN) != 0);
    else
        return ( (data & I2C_SRD_IN) != 0);
}
   
/**********************************************************************/

VOID ReadSDA(PHWINFO pDev, U032 Head, U032 portID, U008 *data)
{
	*data = i2cReadCtrl(pDev, Head, portID, SDA_REG);
}

VOID ReadSCL(PHWINFO pDev, U032 Head, U032 portID, U008 *data)
{
	*data = i2cReadCtrl(pDev, Head, portID, SCL_REG);
}   

VOID SetSCLLine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SCL_REG, 1);
}

VOID ResetSCLLine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SCL_REG, 0);
}

VOID SetSDALine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SDA_REG, 1);
}

VOID ResetSDALine(PHWINFO pDev, U032 Head, U032 portID)
{
	i2cWriteCtrl(pDev, Head, portID, SDA_REG, 0);
} 
 
/*
 * waits for a specified line til it goes high
 * giving up after MAX_WAIT_STATES attempts
 * return:  0 OK
 *         -1 fail (time out)
 */
U008 WaitHighSDALine(PHWINFO pDev, U032 Head, U032 portID)
{
    U008    data_in;
    U032    retries = wMaxWaitStates;

    do
    {
        ReadSDA(pDev, Head, portID, &data_in);      // wait for the line going high
        if (data_in)
            break;
        tmrDelay(pDev, I2CDELAY); 
    } while (--retries);        // count down is running

    if (!retries)
        return((U008)-1);
    return 0;
}                    

U008 WaitHighSCLLine(PHWINFO pDev, U032 Head, U032 portID)
{
    U008    data_in;
    U032    retries = wMaxWaitStates;

    do
    {
        tmrDelay(pDev, 1000);              // 1.0 us delay   NEEDED?? 
        ReadSCL(pDev, Head, portID, (U008 *)&data_in);   // wait for the line going high
        if (data_in)
            break;
    } while (--retries);            // count down is running

    if (!retries)
        return((U008)-1);
    return(0);    
}


VOID i2cStart(PHWINFO pDev, U032 Head, U032 portID)
{
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY); 
    SetSCLLine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);     // spec requires clock to be high min of 4us
    WaitHighSCLLine(pDev, Head, portID);
    ResetSDALine(pDev, Head, portID);
    tmrDelay(pDev, I2CDELAY);
    ResetSCLLine(pDev, Head, portID);
}


VOID i2cStop(PHWINFO pDev, U032 Head, U032 portID)
{
    tmrDelay(pDev, I2CDELAY * 20);
    ResetSCLLine(pDev, Head, portID);
    ResetSDALine(pDev, Head, portID);
    tmrDelay(pDev, I2CDELAY); 
    SetSCLLine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);     // spec requires clock to be high min of 4us
    WaitHighSCLLine(pDev, Head, portID); 
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);
}


/*
 * I2cAck() returns 1: fail
 *                  0: acknolege
 */

U008 i2cAck(PHWINFO pDev, U032 Head, U032 portID)
{
    U008 ack;

    ResetSCLLine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);
    SetSCLLine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);     // spec requires clock to be high min of 4us
    WaitHighSCLLine(pDev, Head, portID);
    ReadSDA(pDev, Head, portID, &ack);
    ResetSCLLine(pDev, Head, portID);
    return (ack);
}


VOID i2cInit(PHWINFO pDev, U032 Head, U032 portID)
{
    SetSCLLine(pDev, Head, portID); 
    tmrDelay(pDev, I2CDELAY);     // spec requires clock to be high min of 4us
    WaitHighSCLLine(pDev, Head, portID);
    SetSDALine(pDev, Head, portID); 
}


U008 i2cSendByte(PHWINFO pDev, U032 Head, U032 portID, U008 byte)
{
    U008 i;

    for (i=0;i<8;i++)
    {
	    ResetSCLLine(pDev, Head, portID);
	    tmrDelay(pDev, I2CDELAY/2);
        if (byte & 0x80)
		    SetSDALine(pDev, Head, portID);
	    else
		    ResetSDALine(pDev, Head, portID);
	    tmrDelay(pDev, I2CDELAY/2);
	    SetSCLLine(pDev, Head, portID);
	    tmrDelay(pDev, I2CDELAY);    // clock must be high at least 4us
	    WaitHighSCLLine(pDev, Head, portID);
	    byte <<= 1;
    }
    
    return i2cAck(pDev, Head, portID);
}


RM_STATUS i2cReceiveByte(PHWINFO pDev, U032 Head, U032 portID, U008 *byte, U008 nack)
{
    U008 data=0;
    U008 i;
    RM_STATUS status;

    ResetSCLLine(pDev, Head, portID);
    SetSDALine(pDev, Head, portID); 
    tmrDelay(pDev, 1000);

    for (i=0;i<8;i++)
	{
        ResetSCLLine(pDev, Head, portID);
        ResetSCLLine(pDev, Head, portID);  // 2nd needed?
        tmrDelay(pDev, I2CDELAY);
	    SetSCLLine(pDev, Head, portID); 
        status = WaitHighSCLLine(pDev, Head, portID) ? RM_ERROR : RM_OK;
        if (status != RM_OK)
            goto done;
	    tmrDelay(pDev, I2CDELAY);    // clock must be high at least 4us

	    ReadSDA(pDev, Head, portID, &data);
	    *byte <<= 1;
	    *byte  |= (data == 1);
	}

    ResetSCLLine(pDev, Head, portID);
    if (nack) 
    {
        SetSDALine(pDev, Head, portID);         // send Nack
    }
    else
        ResetSDALine(pDev, Head, portID);       // send Ack

    tmrDelay(pDev, I2CDELAY);
    SetSCLLine(pDev, Head, portID); 
    status = WaitHighSCLLine(pDev, Head, portID) ? RM_ERROR : RM_OK;
	tmrDelay(pDev, I2CDELAY);    // clock must be high at least 4us
    ResetSCLLine(pDev, Head, portID);
    tmrDelay(pDev, I2CDELAY);   // clock width must be 4.7us

done:
    return status;
}


RM_STATUS i2cWrite(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    if ( i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1)) ) // send chip adr. with write bit
    {
        i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
        return(RM_ERROR); 
    }
    for ( ; AdrLen; AdrLen--)             
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )        // send sub-register byte(s)
        {
            i2cStop(pDev, Head, portID);                    // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }
    for ( ; DataLen; DataLen--)            // send data byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Data++) )
        {
            i2cStop(pDev, Head, portID);                     // ack failed --> generate stop condition
            return(RM_ERROR);
        }
    }
    i2cStop(pDev, Head, portID);
    return(RM_OK);
}


RM_STATUS i2cRead(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    U008 dat;
    RM_STATUS status = RM_ERROR;        // pessimist
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ChipAdr ", (U032)ChipAdr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AdrLen ", (U032)AdrLen);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Adr ", (U032)*Adr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: DataLen ", (U032)DataLen);

    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1));        // send chip adr. with write bit

    for ( ; AdrLen; AdrLen--)               // send sub-register address byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )
        {
            goto done;
        }
    }
    
    tmrDelay(pDev, I2CDELAY);    // give the device some time to parse the subaddress
    
    i2cStart(pDev, Head, portID);                             // send again chip address for switching to read mode
    if ( i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1)) )  // send chip adr. with read bit
    {
        goto done;
    }

    for (status = RM_OK; DataLen && (status == RM_OK); DataLen--)
    {
        status = i2cReceiveByte(pDev,
                                Head,
                                portID, 
                                (U008 *)&dat, 
                                (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }

done:
    i2cStop(pDev, Head, portID);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return status;
}

RM_STATUS i2cRead_EDDC(PHWINFO pDev, U032 Head, U032 portID, U008 SegmentAddr,U008 ChipAdr, U008 SubByteAddr,U016 DataLen, U008 *Data)
{
    //extended DDC compatibility not confirmed on date modified. No monitors with edids greater than 256 are
    //easily obtainable or locatable.

    U008 dat;
    RM_STATUS status = RM_ERROR;        // pessimist
    
    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    //if segment!=0, set the segment with this sequence first
    if(SegmentAddr)
    {
        //send start
        i2cStart(pDev, Head, portID);
        
        //send segment register addr
        i2cSendByte(pDev, Head, portID, 0x60);
        
        //send the segment number
        i2cSendByte(pDev, Head, portID, SegmentAddr);
    }

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1));        // send chip adr. with write bit    
    i2cSendByte(pDev, Head, portID, (U008)SubByteAddr);

    i2cStart(pDev, Head, portID);                             // send again chip address for switching to read mode
    if ( i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1)) )  // send chip adr. with read bit
    {
        goto done;
    }

    for (status = RM_OK; DataLen && (status == RM_OK); DataLen--)
    {
        status = i2cReceiveByte(pDev,
                                Head,
                                portID, 
                                (U008 *)&dat, 
                                (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }

done:
    i2cStop(pDev, Head, portID);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return status;
}

RM_STATUS i2cSend(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data, U032 NoStopFlag)
{

    if ( ChipAdr ) {
        //
        // Enable writes to the I2C port
        //
        i2cHardwareInit(pDev, Head, portID);

        i2cStart(pDev, Head, portID);
        if ( i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1)) ) // send chip adr. with write bit
        {
            i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }

    for ( ; AdrLen; AdrLen--)             
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )        // send sub-register byte(s)
        {
            i2cStop(pDev, Head, portID);                    // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }

    for ( ; DataLen; DataLen--)            // send data byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Data++) )
        {
            i2cStop(pDev, Head, portID);                     // ack failed --> generate stop condition
            return(RM_ERROR);
        }
    }

    if ( NoStopFlag == 0 )
        i2cStop(pDev, Head, portID);

    return(RM_OK);
}


RM_STATUS i2cWrite_ALT(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    if ( i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1)) ) // send chip adr. with write bit
    {
        i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
        return(RM_ERROR); 
    }
    for ( ; DataLen; DataLen--)            // send data byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Data++) )
        {
            i2cStop(pDev, Head, portID);                     // ack failed --> generate stop condition
            return(RM_ERROR);
        }
    }
    i2cStop(pDev, Head, portID);
    return(RM_OK);
}


RM_STATUS i2cRead_ALT(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    U008 dat;
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ChipAdr ", (U032)ChipAdr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AdrLen ", (U032)AdrLen);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Adr ", (U032)*Adr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: DataLen ", (U032)DataLen);

    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1));        // send chip adr. with write bit
    for ( ; DataLen ; DataLen--)
    {
        i2cReceiveByte(pDev, Head, portID, (U008 *)&dat, (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }
    i2cStop(pDev, Head, portID);
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return(RM_OK);
}


RM_STATUS i2cRead_ALT2(PHWINFO pDev, U032 Head, U032 portID, U008 ChipAdr, U016 AdrLen, U008 *Adr, U016 DataLen, U008 *Data)
{
    U008 dat;
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: ChipAdr ", (U032)ChipAdr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: AdrLen ", (U032)AdrLen);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Adr ", (U032)*Adr);
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: DataLen ", (U032)DataLen);

    //
    // Enable writes to the I2C port
    //
    i2cHardwareInit(pDev, Head, portID);

    i2cStart(pDev, Head, portID);
    i2cSendByte(pDev, Head, portID, (U008)(ChipAdr<<1));        // send chip adr. with write bit

    for ( ; AdrLen; AdrLen--)               // send sub-register address byte(s)
    {
        if ( i2cSendByte(pDev, Head, portID, *Adr++) )
        {
            i2cStop(pDev, Head, portID);                      // ack failed --> generate stop condition
            return(RM_ERROR); 
        }
    }
    i2cStop(pDev, Head, portID);
    
    i2cStart(pDev, Head, portID);                             // send again chip address for switching to read mode
    if ( i2cSendByte(pDev, Head, portID, (U008)((ChipAdr<<1) | 1)) )  // send chip adr. with read bit
    {
        i2cStop(pDev, Head, portID);                         // ack failed --> generate stop condition
        return(RM_ERROR); 
    }

    for ( ; DataLen ; DataLen--)
    {
        i2cReceiveByte(pDev, Head, portID, (U008 *)&dat, (U008)((DataLen == 1) ? NACK : ACK));         // receive byte(s)
        *Data++ = dat;
    }

    i2cStop(pDev, Head, portID);
    
    //DBG_PRINT_STRING_VALUE(DEBUGLEVEL_TRACEINFO, "NVRM: Data ", (U032)*Data);
    
    return(RM_OK);
}

RM_STATUS i2cAccess
(
    PHWINFO pDev,
    U032 Head,
    NVRM_I2C_ACCESS_CONTROL    *pCtrl
)
{

    RM_STATUS rmStatus = RM_OK;

    U032	startFlag;
    U032	stopFlag;
    U032	ackFlag;
    U032	port;
    U008	data = 0;
    U008    lock;
    
    /*
     * verify the token
     *
     * NOTE: we allow I2C Access if the token is 0 AND no one
     * else has acquired it.  The idea is that 3rd party vendors
     * will not be able to acquire/lock I2C; however, we can still
     * acquire/lock I2C internally and lock 3rd party access out.
     * The reason is that we don't a 3rd party app to crash while
     * still holding a lock on I2C and thus lock us out from internal
     * access.  We have priority in this scheme and 3rd party
     * apps must deal with contention by checking return codes for
     * errors.
     */
     
    if (pDev->Power.State == MC_POWER_LEVEL_3)
    {
    	DBG_PRINT_STRING(DEBUGLEVEL_ERRORS, "NVRM: Attempted I2C access before waking up. Invalid request denied.\n");
    
    	//if we are at a state of power management, we need to reject this call
    	return NVRM_I2C_ACCESS_STATUS_ERROR;
    }

    // unlock the extended regs
    lock = UnlockCRTC(pDev, Head);

	//point to correct head and enable i2c
	EnableHead(pDev, Head);
	AssocDDC(pDev, Head);

    if ((pCtrl->cmd == NVRM_I2C_ACCESS_CMD_WRITE_BYTE) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_READ_BYTE) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_NULL) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_RESET) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_READ_SDA) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_READ_SCL) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_WRITE_SDA) ||
        (pCtrl->cmd == NVRM_I2C_ACCESS_CMD_WRITE_SCL)) {

        if (pCtrl->token != pDev->I2CAcquired) {
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY;
            rmStatus = RM_ERROR;
            goto done;
        }
    }

    /*
     * retrieve the flags and port
     */

    startFlag = pCtrl->flags & NVRM_I2C_ACCESS_FLAG_START;
    stopFlag = pCtrl->flags & NVRM_I2C_ACCESS_FLAG_STOP;
    ackFlag = pCtrl->flags & NVRM_I2C_ACCESS_FLAG_ACK;

    if ( pCtrl->port == NVRM_I2C_ACCESS_PORT_PRIMARY ) {
        port = NV_I2C_PORT_PRIMARY;
    }
    else {
        port = NV_I2C_PORT_SECONDARY;
    }

    /*
     * handle the command
     */

    pCtrl->status = NVRM_I2C_ACCESS_STATUS_SUCCESS;

    switch ( pCtrl->cmd ) {

      case NVRM_I2C_ACCESS_CMD_ACQUIRE:

        if ( pDev->I2CAcquired ) {
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_DEVICE_BUSY;
            rmStatus = RM_ERROR;
        }
        else {
            pDev->I2CAcquired = 0xbeeffeed; /* arbtrary */
            pCtrl->token = pDev->I2CAcquired;
            i2cHardwareInit(pDev, Head, port);
        }

        break;

      case NVRM_I2C_ACCESS_CMD_RELEASE:

        if ( pDev->I2CAcquired != pCtrl->token ) {
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_ERROR;
            rmStatus = RM_ERROR;
        }
        else {
            pDev->I2CAcquired = 0;
            pCtrl->token = 0;
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_SUCCESS;
        }

        break;

      case NVRM_I2C_ACCESS_CMD_WRITE_BYTE:

        if ( startFlag ) {
            i2cStart(pDev, Head, port);
        }

        data = (U008)(pCtrl->data);
        if ( i2cSendByte(pDev, Head, port,data) ) {
            i2cStop(pDev, Head, port);
            pCtrl->status = NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR;
            rmStatus = RM_ERROR;
        }

        if ( stopFlag ) {
            i2cStop(pDev, Head, port);
        }

      	break;

      case NVRM_I2C_ACCESS_CMD_READ_BYTE:

        if ( startFlag ) {
            i2cStart(pDev, Head, port);
        }

        // check for restart read 
        if ( startFlag ) {
            data = (U008)(pCtrl->data);
            if ( i2cSendByte(pDev, Head, port,data) ) {
                i2cStop(pDev, Head, port);
                pCtrl->status = NVRM_I2C_ACCESS_STATUS_PROTOCOL_ERROR;
                rmStatus = RM_ERROR;
            }
        }
        else {
            i2cReceiveByte(pDev, Head, port, &data, (U008)((ackFlag) ? 0 : 1));
            pCtrl->data = data;
        }

        if ( stopFlag ) {
            i2cStop(pDev, Head, port);
        }

      	break;

      case NVRM_I2C_ACCESS_CMD_NULL:

        if ( startFlag ) {
            i2cStart(pDev, Head, port);
        }

        if ( stopFlag ) {
            i2cStop(pDev, Head, port);
        }

      	break;

      case NVRM_I2C_ACCESS_CMD_RESET:

        i2cStop(pDev, Head, port);

      	break;

      case NVRM_I2C_ACCESS_CMD_READ_SDA:

        ReadSDA(pDev, Head, port, &data);
        pCtrl->data = data;

        break;

      case NVRM_I2C_ACCESS_CMD_READ_SCL:

        ReadSCL(pDev, Head, port, &data);
        pCtrl->data = data;

        break;

      case NVRM_I2C_ACCESS_CMD_WRITE_SDA:

        if ( pCtrl->data ) {
            SetSDALine(pDev, Head, port);
        }
        else {
            ResetSDALine(pDev, Head, port);
        }

      case NVRM_I2C_ACCESS_CMD_WRITE_SCL:

        if ( pCtrl->data ) {
            SetSCLLine(pDev, Head, port);
        }
        else {
            ResetSCLLine(pDev, Head, port);
        }

        break;

      default:

        pCtrl->status = NVRM_I2C_ACCESS_STATUS_ERROR;
        rmStatus = RM_ERROR;
        break;

    }

done:
    RestoreLock(pDev, Head, lock);
    return rmStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\xbox_leak_may_2020\xbox trunk\xbox\private\ntos\video\nv20\drivers\resman\kernel\dac\nv4\dacnv04.c ===
/***************************************************************************\
|*                                                                           *|
|*        Copyright (c) 1993-2000 NVIDIA, Corp.  All rights reserved.        *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.   NVIDIA, Corp. of Sunnyvale, California owns     *|
|*     the copyright  and as design patents  pending  on the design  and     *|
|*     interface  of the NV chips.   Users and possessors of this source     *|
|*     code are hereby granted  a nonexclusive,  royalty-free  copyright     *|
|*     and  design  patent license  to use this code  in individual  and     *|
|*     commercial software.                                                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*     Copyright (c) 1993-2000  NVIDIA, Corp.    NVIDIA  design  patents     *|
|*     pending in the U.S. and foreign countries.                            *|
|*                                                                           *|
|*     NVIDIA, CORP.  MAKES  NO REPRESENTATION ABOUT  THE SUITABILITY OF     *|
|*     THIS SOURCE CODE FOR ANY PURPOSE.  IT IS PROVIDED "AS IS" WITHOUT     *|
|*     EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORP. DISCLAIMS     *|
|*     ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,  INCLUDING  ALL     *|
|*     IMPLIED   WARRANTIES  OF  MERCHANTABILITY  AND   FITNESS   FOR  A     *|
|*     PARTICULAR  PURPOSE.   IN NO EVENT SHALL NVIDIA, CORP.  BE LIABLE     *|
|*     FOR ANY SPECIAL, INDIRECT, INCIDENTAL,  OR CONSEQUENTIAL DAMAGES,     *|
|*     OR ANY DAMAGES  WHATSOEVER  RESULTING  FROM LOSS OF USE,  DATA OR     *|
|*     PROFITS,  WHETHER IN AN ACTION  OF CONTRACT,  NEGLIGENCE OR OTHER     *|
|*     TORTIOUS ACTION, ARISING OUT  OF OR IN CONNECTION WITH THE USE OR     *|
|*     PERFORMANCE OF THIS SOURCE CODE.                                      *|
|*                                                                           *|
 \***************************************************************************/

/******************************** DAC Arbitration **************************\
*                                                                           *
* Module: DACARB.C                                                          *
*   The DAC Arbitration management.                                         *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*                                                                           *
\***************************************************************************/
#include <nv_ref.h>
#include <nv4_ref.h>
#include <nvrm.h>
#include <nv4_hal.h>
#include <state.h>
#include <class.h>
#include <vblank.h>
#include <dma.h>
#include <gr.h>
#include <dac.h>
#include <os.h>
#include "nvhw.h"
#include <vga.h>

/* This file simulates the NV arbitor */
#include <arb_fifo.h>
#include "nvhalcpp.h"

//////////////////////////////////////////
//
// Arbitration routines
//

//
// Calculate the closest arbitration values for a given system configuration
//

static
VOID NV04_dacCalculateArbitration
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
    PFBHALINFO      pFbHalInfo = pHalHwInfo->pFbHalInfo;
    PMCHALINFO      pMcHalInfo = pHalHwInfo->pMcHalInfo;
    PVIDEOHALINFO   pVideoHalInfo = pHalHwInfo->pVideoHalInfo;

    int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
    int nvclk_fill, us_extra, clwm_mt;
    int found, mclk_extra, mclk_loop, cbs, m1;
    int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
    int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
    int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
    int craw, vraw, m2us, us_pipe, p1clk, p2;
    int h_size, v_size;
    int ram_conf;
  
    fifo->valid = 1;
    pclk_freq = arb->pclk_khz; // freq in KHz
    mclk_freq = arb->mclk_khz;
    nvclk_freq = arb->nvclk_khz;
    pagemiss = arb->mem_page_miss;
    cas = arb->mem_latency;
    width = arb->memory_width/64;
    video_enable = arb->enable_video;
    color_key_enable = arb->gr_during_vid;
    bpp = arb->pix_bpp;
    align = arb->mem_aligned;
    mp_enable = arb->enable_mp;
    clwm = 0;
    vlwm = 0;

    h_size   = pFbHalInfo->HorizDisplayWidth;
    v_size   = pFbHalInfo->VertDisplayWidth;
    ram_conf = arb->ram_config;

    // NV4 can not support 256 burst
    if (IsNV4_NV04(pMcHalInfo))
        cbs = 128;
    else
        cbs = 256;

    pclks = 2;   // lwm detect.

    nvclks = 2;  // lwm -> sync.
    nvclks += 2; // fbi bus cycles (1 req + 1 busy)
    nvclks += 1; // fbi reqsync

    mclks = 5;  // Fifo
    mclks += 3; // MA0 -> MA2
    mclks += 1; // pad->out
    mclks += cas; // Cas Latency.
    mclks += 1; // pad in
    mclks += 1; // latch data
    mclks += 1; // fifo load
    mclks += 1; // fifo write
  
  
    if ((video_enable) && (arb->memory_width == 128))
        mclk_extra = 3; // Margin of error
    else    
        mclk_extra = 17; // Margin of error

    nvclks += 2; // fifo sync
    nvclks += 1; // read data
    nvclks += 1; // fbi_rdata
    nvclks += 1; // crtfifo load

    if(mp_enable)
        mclks+=4; // Mp can get in with a burst of 8.
        
    // Extra clocks determined by heuristics
    nvclks += 0;
    pclks += 0;
    found = 0;
    while(found != 1) 
    {
        fifo->valid = 1;
        found = 1;
        mclk_loop = mclks+mclk_extra;
        us_m = mclk_loop *1000*1000 / mclk_freq;    // Mclk latency in us
        us_n = nvclks*1000*1000 / nvclk_freq;       // nvclk latency in us
        us_p = nvclks*1000*1000 / pclk_freq;        // nvclk latency in us
        us_pipe = us_m + us_n + us_p;
        us_extra = 0;
        if(video_enable) 
        {
            video_drain_rate = pclk_freq * 2;       // MB/s
            crtc_drain_rate = pclk_freq * bpp/8;    // MB/s

            vpagemiss = 1; // self generating page miss
            vpagemiss += 1; // One higher priority before

            crtpagemiss = 2; // self generating page miss

            vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = 256*1000*1000 / 16 / nvclk_freq ;
            else
                video_fill_us = 256*1000*1000 / (8 * width) / mclk_freq;

            us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

            vlwm = us_video * video_drain_rate/(1000*1000);
            vlwm+=2; // fixed point <= float_point - 1.  Fixes that
            vbs = 128;

            //
            // Video tweaking specific to Canopus
            //
            if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
            {
                //
                // Canopus specific code
                //      
                if (IsNV4_NV04(pMcHalInfo))
                {
                    if(bpp == 32)
                    {
                        if(vlwm > 110)
                            vbs = 64;
                        if(vlwm > (256-64))
                            vbs = 32;
                    }
                    else
                    {
                        if(vlwm > 110)
                            vbs = 64;
                        if(vlwm > (256-27)) // 229
                            vbs = 32;
                    }
                }
                else
                {
                    if(bpp == 32)
                    {
                        if(vlwm > 77)
                            vbs = 64;
                        if(vlwm > (256-64)) // 192
                            vbs = 32;
                    }
                    else
                    {
                        if(vlwm > 135)      // 146)
                            vbs = 64;
                        if(vlwm > 201)
                            vbs = 32;
                    }
                }

            } else {
                //
                // Generic code
                //
                if(vlwm > 256 - 64)
                    vbs = 32;
                else if(vlwm > 146) 
                    vbs = 64;
            }        

            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
            else
                video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =
              us_video  // Wait for video
              +video_fill_us // Wait for video to fill up
              +cpm_us // CRT Page miss
              +us_m + us_n +us_p // other latency
              ;
              
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that

            //
            // Video tweaking specific to Canopus
            //
            if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
            {
                if(ram_conf == 0x0003)  
                {
                    clwm -= 32;     // SPECTRA Lite 
                    if(bpp == 32)
                        clwm -= 72; // SPECTRA Lite 
                }
            }

        } 
        else    // !video_enable
        {
        
            crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

            crtpagemiss = 1; // self generating page miss
            crtpagemiss += 1; // MA0 page miss
            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =  cpm_us + us_m + us_n + us_p ;
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that
    
            //
            // Another concern, only for high pclks so don't do this
            // with video:
            // What happens if the latency to fetch the cbs is so large that
            // fifo empties.  In that case we need to have an alternate clwm value
            // based off the total burst fetch
            //
            us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
            clwm_mt = us_crt * crtc_drain_rate/(1000*1000); 
            clwm_mt ++;
            if(clwm_mt > clwm)
                clwm = clwm_mt;
                
            //    
            // Finally, a heuristic check when width == 64 bits
            //
            if(width == 1)
            {
                nvclk_fill = nvclk_freq * 8;
                if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    clwm = 0xfff; //Large number to fail
                else if (crtc_drain_rate * 100  >= nvclk_fill * 98) 
                {
                    clwm = 512;
                    cbs = 256;
                    us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
                    //if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    //    clwm = 0xfff; //Large number to fail
                }
            }         
        }
    
    
        //
        // Overfill check:
        //

        m1 = clwm + cbs -  512; /* Amount of overfill */

        //
        // Video tweaking specific to Canopus
        //
        if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
        {
            p2 = m1 * pclk_freq / mclk_freq;  // pclk cycles to drain
            p2 = p2 * bpp / 8;                // bytes drained.
        }
        else
        {
            // Generic coding
            //      
            m2us = us_pipe + us_extra;
            p1clk = m2us * pclk_freq/(1000*1000); /* pclk cycles to drain */
            p2 = p1clk * bpp / 8; // bytes drained.
        }   
           
        if((p2 < m1) && (m1 > 0)) 
        {
            fifo->valid = 0;
            found = 0;
            if (video_enable)
            {
                if(cbs <= 32) 
                    found = 1;      // Can't adjust anymore!
                else
                    cbs = cbs/2;    // reduce the burst size
            } 
            else
            {
            
                //
                // Video tweaking specific to Canopus
                //
                if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
                {
                    if(mclk_extra ==0)   
                        found = 1; // Can't adjust anymore!
                    mclk_extra--;
                }
                else
                {         
                    //
                    // Generic coding
                    //   
                    if(mclk_extra ==0)   
                    {
                        if(cbs <= 32) 
                            found = 1;      // Can't adjust anymore!
                        else
                            cbs = cbs/2;    // reduce the burst size
                    } 
                    else 
                        mclk_extra--;
                }            
            }            
        }
        else if (video_enable)
        {

            //
            // Canopus specific code
            //
            if (IsNV4_NV04(pMcHalInfo) && (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS))
            {
                if ((clwm > 621) || (vlwm > 255)) 
                {
                    fifo->valid = 0;
                    found = 0;
                    if(mclk_extra == 0)   
                        found = 1; // Can't adjust anymore!
                    mclk_extra--;
                }
            }
            else
            {
                //
                // Generic coding
                //
                if ((clwm > 511) || (vlwm > 255)) 
                {
                    fifo->valid = 0;
                    found = 0;
                    if(mclk_extra <= 5)   
                        found = 1; // Can't adjust anymore!
                    mclk_extra--;
                }
            }            
            
        } 
        else 
        {  
            if (clwm > 519)
            { // Have some margin
                fifo->valid = 0;
                found = 0;
                if(mclk_extra ==0)   
                    found = 1; // Can't adjust anymore!
                mclk_extra--;
            }
        }
        
        craw = clwm;
        vraw = vlwm;
        //if(clwm < 256) clwm = 256;
        if (clwm < (512-cbs)) 
            clwm = 512-cbs;

        //
        // Video tweaking specific to Canopus
        //
        if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
        {    
            if (IsNV4_NV04(pMcHalInfo))
            {
                if (vlwm < 128)
                {
                    if (bpp == 32)
                    {
                        if (h_size == 1408)
                        {
                            vlwm = 176;
                            vbs = 64;
                        }
                        else if (h_size == 1024)
                        {
                            vlwm = 144;
                            vbs = 64;
                        }
                        else if (h_size < 1024)
                        {
                            vlwm = 128-16;
                        }
                        else
                        {
                            vlwm = 160;
                            vbs = 64;
                        }
                    }
                    else
                        vlwm = 128;
                }
            }
            else
            {
                if (vlwm < 128)
                {
                    if (bpp == 32)  
                    {
                        if (h_size >= 1152)
                        {
                            vlwm = 176;
                            vbs = 64;
                        }
                        else
                            vlwm = 144-16;
                    }
                    else
                        vlwm = 128;
                }

                if ((!video_enable) && (ram_conf == 0x0003))    
                {
                    if (bpp == 32)
                    {
                        if ((h_size >= 1024) && (h_size <= 1408))
                            clwm += 88;     // SPECTRA Lite 
                        else if (h_size == 960)
                            clwm += 48;
                        else
                            clwm += 32;
                    }
                    else if ((bpp == 16) && (h_size == 1920) && (v_size == 1440))
                    {
                        clwm += 8;
                    }
                }

                if (cbs == 256)    
                {
                    if (clwm > 271)    
                        clwm -= 16;
                    if ((!video_enable) && (ram_conf == 0x0003))    
                    {
                        if (clwm > 400)     // SP Lite
                            clwm = 400;
                    }
                    else
                    {
                        if (clwm > 384)     
                            clwm = 384; // 400;
                    }
                }

                // For 1920x1440x32 of Spectra5400PE
                if ((!video_enable) && (ram_conf != 0x0003) && (clwm < 384) &&
                    (h_size == 1920) && (v_size == 1440) && (bpp == 32))
                {
                    clwm = 384;
                }

            }
            
            if(clwm > 511)
                clwm = 511;
        } 
        else
        {    
            //
            // Generic coding
            //
            if(vlwm < 128) 
                vlwm = 128;
        }        
    
    
        if(vlwm < 128) vlwm = 128;
    
        data = (int)(clwm);
        //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
        fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;
        //    fifo->craw = craw;

        //
        // Video tweaking specific to Canopus
        //
        if (pVideoHalInfo->CustomizationCode & CUSTOMER_CANOPUS)
        {    
            if (IsNV4_NV04(pMcHalInfo))
                data = (int)((vlwm+24));
            else
                data = (int)((vlwm+24));        // 15));

            if (data > 255)
                data = 255;
        }
        else      
        {
            // Generic coding    
            //
            data = (int)((vlwm+15));
            
            // Preset ranges for vlwm and vbs based on calculated vlwm
            if (vlwm > 256-32) 
            {
                data = 256;
                vbs = 32;
            } 
            else if (vlwm > 256-64) 
            {
                data = 256-32+16;
                vbs = 32;
            } 
            else if (vlwm > 256-128) 
            {
                data = 256-64+16;
                vbs = 64;
            } 
            else 
            {
                data = 256-128+16;
                vbs = 128;
            }
            
        }        

        //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
        fifo->video_lwm = data;  
        fifo->video_burst_size = vbs;
    }
}


static
void NV04_dacCalculateArbitration_SMA
(
    PHALHWINFO pHalHwInfo,
    fifo_info *fifo,
    sim_state  *arb
)
{
    PFBHALINFO  pFbHalInfo = pHalHwInfo->pFbHalInfo;

    int data, pagemiss, cas,width, video_enable, color_key_enable, bpp, align;
    int nvclks, mclks, pclks, vpagemiss, crtpagemiss, vbs;
    int nvclk_fill, us_extra, clwm_mt;
    int found, mclk_extra, mclk_loop, cbs, m1;
    int mclk_freq, pclk_freq, nvclk_freq, mp_enable;
    int us_m, us_n, us_p, video_drain_rate, crtc_drain_rate;
    int vpm_us, us_video, vlwm, video_fill_us, cpm_us, us_crt,clwm;
    int craw, vraw, m2us, us_pipe, p1clk, p2;
    int h_size, v_size;
    int ram_conf;
  
  
    fifo->valid = 1;
    pclk_freq = arb->pclk_khz; // freq in KHz
    //mclk_freq = arb->mclk_khz;
    mclk_freq = 100000;
    nvclk_freq = arb->nvclk_khz;
    //pagemiss = arb->mem_page_miss;
    pagemiss = 7;
    //cas = arb->mem_latency;
    cas = 3;
    width = 1;
    video_enable = arb->enable_video;
    color_key_enable = arb->gr_during_vid;
    bpp = arb->pix_bpp;
    align = arb->mem_aligned;
    mp_enable = arb->enable_mp;
    clwm = 0;
    vlwm = 0;

    h_size   = pFbHalInfo->HorizDisplayWidth;
    v_size   = pFbHalInfo->VertDisplayWidth;
    ram_conf = arb->ram_config;

    // NV4 can not support 256 burst
    //if (IsNV4(pDev))
    if (/*IsNV4(pDev)*/ 1)
        cbs = 128;
    else
        cbs = 256;

    pclks = 2;   // lwm detect.

    nvclks = 2;  // lwm -> sync.
    nvclks += 2; // fbi bus cycles (1 req + 1 busy)
    nvclks += 1; // fbi reqsync

    mclks = 5;  // Fifo
    mclks += 3; // MA0 -> MA2
    mclks += 4; // prev burst
    mclks += 2; // ALI arb
    mclks += 1; // pad->out
    mclks += cas; // Cas Latency.
    mclks += 1; // pad in
    mclks += 2; // ALI rd pipe
    mclks += 1; // latch data
    mclks += 1; // fifo load
    mclks += 1; // fifo write
  
  
    if ((video_enable) && (arb->memory_width == 128))
        mclk_extra = 12; // Margin of error
    else    
        mclk_extra = 17; // Margin of error

    nvclks += 2; // fifo sync
    nvclks += 1; // read data
    nvclks += 1; // fbi_rdata
    nvclks += 1; // crtfifo load

    if(mp_enable)
        mclks+=4; // Mp can get in with a burst of 8.
        
    // Extra clocks determined by heuristics
    nvclks += 0;
    pclks += 0;
    found = 0;
    while(found != 1) 
    {
        fifo->valid = 1;
        found = 1;
        mclk_loop = mclks+mclk_extra;
        us_m = mclk_loop *1000*1000 / mclk_freq; // Mclk latency in us
        us_n = nvclks*1000*1000 / nvclk_freq;// nvclk latency in us
        us_p = nvclks*1000*1000 / pclk_freq;// nvclk latency in us
        us_pipe = us_m + us_n + us_p;
        us_extra = 0;
        if(video_enable) 
        {
            video_drain_rate = pclk_freq * 2; // MB/s
            crtc_drain_rate = pclk_freq * bpp/8; // MB/s

            vpagemiss = 1; // self generating page miss
            vpagemiss += 1; // One higher priority before

            crtpagemiss = 2; // self generating page miss

            vpm_us = (vpagemiss * pagemiss)*1000*1000/mclk_freq;


            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = 256*1000*1000 / 16 / nvclk_freq ;
            else
                video_fill_us = 256*1000*1000 / (8 * width) / mclk_freq;

            us_video = vpm_us + us_m + us_n + us_p + video_fill_us;

            vlwm = us_video * video_drain_rate/(1000*1000);
            vlwm+=2; // fixed point <= float_point - 1.  Fixes that
            vbs = 128;

            //
            // Generic code
            //
            if(vlwm > 256 - 64)
                vbs = 32;
            else if(vlwm > 146) 
                vbs = 64;

            if(nvclk_freq * 2 > mclk_freq * width) // nvclk is faster than mclk
                video_fill_us = vbs *1000*1000/ 16 / nvclk_freq ;
            else
                video_fill_us = vbs*1000*1000 / (8 * width) / mclk_freq;

            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =
              us_video  // Wait for video
              +video_fill_us // Wait for video to fill up
              +cpm_us // CRT Page miss
              +us_m + us_n +us_p // other latency
              ;
              
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that

        } 
        else    // !video_enable
        {
            crtc_drain_rate = pclk_freq * bpp/8; // bpp * pclk/8

            crtpagemiss = 1; // self generating page miss
            crtpagemiss += 1; // MA0 page miss
            cpm_us = crtpagemiss  * pagemiss *1000*1000/ mclk_freq;
            us_crt =  cpm_us + us_m + us_n + us_p ;
            clwm = us_crt * crtc_drain_rate/(1000*1000);
            clwm++; // fixed point <= float_point - 1.  Fixes that
    
            //
            // Another concern, only for high pclks so don't do this
            // with video:
            // What happens if the latency to fetch the cbs is so large that
            // fifo empties.  In that case we need to have an alternate clwm value
            // based off the total burst fetch
            //
            us_crt = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
            us_crt = us_crt + us_m + us_n + us_p + (4 * 1000 * 1000)/mclk_freq;
            clwm_mt = us_crt * crtc_drain_rate/(1000*1000); 
            clwm_mt ++;
            if(clwm_mt > clwm)
                clwm = clwm_mt;
                
            //    
            // Finally, a heuristic check when width == 64 bits
            //
            if(width == 1)
            {
                nvclk_fill = nvclk_freq * 8;
                if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    clwm = 0xfff; //Large number to fail
                else if (crtc_drain_rate * 100  >= nvclk_fill * 98) 
                {
                    clwm = 512;
                    cbs = 256;
                    us_extra = (cbs * 1000 * 1000)/ (8*width)/mclk_freq ;
                    //if(crtc_drain_rate * 100 >= nvclk_fill * 102) 
                    //    clwm = 0xfff; //Large number to fail
                }
        }         
        }
    
        //
        // Overfill check:
        //

        m1 = clwm + cbs -  512; /* Amount of overfill */

        // Generic coding
        //      
        m2us = us_pipe + us_extra;
        p1clk = m2us * pclk_freq/(1000*1000); /* pclk cycles to drain */
        p2 = p1clk * bpp / 8; // bytes drained.
           
        if((p2 < m1) && (m1 > 0)) 
        {
            fifo->valid = 0;
            found = 0;
            if (video_enable)
            {
                if(cbs <= 32) 
                    found = 1;      // Can't adjust anymore!
                else
                    cbs = cbs/2;    // reduce the burst size
            } 
            else
            {
            
                //
                // Generic coding
                //   
                if(mclk_extra ==0)   
                {
                    if(cbs <= 32) 
                        found = 1;      // Can't adjust anymore!
                    else
                        cbs = cbs/2;    // reduce the burst size
                } 
                else 
                    mclk_extra--;
            }            
        }
        else if (video_enable)
        {

            //
            // Generic coding
            //
            if ((clwm > 511) || (vlwm > 255)) 
            {
                fifo->valid = 0;
                found = 0;
                if(mclk_extra <= 5)   
                    found = 1; // Can't adjust anymore!
                mclk_extra--;
            }
            
        } 
        else 
        {  
            if (clwm > 519)
            { // Have some margin
                fifo->valid = 0;
                found = 0;
                if(mclk_extra ==0)   
                    found = 1; // Can't adjust anymore!
                mclk_extra--;
            }
        }
        
        craw = clwm;
        vraw = vlwm;
        //if(clwm < 256) clwm = 256;
        if (clwm < (512-cbs)) 
            clwm = 512-cbs;

        //
        // Generic coding
        //
        if(vlwm < 128) 
            vlwm = 128;
    
    
        if(vlwm < 128) vlwm = 128;
    
        data = (int)(clwm);
        //  printf("CRT LWM: %f bytes, prog: 0x%x, bs: 256\n", clwm, data );
        fifo->crtc1_lwm = data;   fifo->crtc1_burst_size = cbs;
        if (data > 511) fifo->valid = 0;
        //    fifo->craw = craw;

        //
        // Video tweaking 
        //
        data = (int)((vlwm+15));
        
        // Preset ranges for vlwm and vbs based on calculated vlwm
        if (vlwm > 256-32) 
        {
            data = 256;
            vbs = 32;
        } 
        else if (vlwm > 256-64) 
        {
            data = 256-32+16;
            vbs = 32;
        } 
        else if (vlwm > 256-128) 
        {
            data = 256-64+16;
            vbs = 64;
        } 
        else 
        {
            data = 256-128+16;
            vbs = 128;
        }
            

        if (data > 255) fifo->valid = 0;

        //  printf("VID LWM: %f bytes, prog: 0x%x, bs: %d\n, ", vlwm, data, vbs );
        fifo->video_lwm = data;  
        fifo->video_burst_size = vbs;
    }
}


typedef struct tagNV04_DacAGPClockEntry
{
    U032 frequency;
    U032 setting;
} NV04_DacAGPClockEntry;

NV04_DacAGPClockEntry NV04_dacAGPClockTable[] =
{
    { 133000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_133MHZ },
    { 126000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_126MHZ },
    { 120000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_120MHZ },
    { 113000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_113MHZ },
    { 106000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_106MHZ },
    { 100000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_100MHZ },
    { 94000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_94MHZ },
    { 87000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_87MHZ },
    { 80000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_80MHZ },
    { 73000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_73MHZ },
    { 66000000, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ },
    { 0, NV_PBUS_DEBUG_3_AGP_4X_NVCLK_ABOVE_66MHZ - 1 }
};

//
// HAL stuff
//
 
// forwards
RM_STATUS nvHalDacAlloc_NV04(VOID *);
RM_STATUS nvHalDacFree_NV04(VOID *);
RM_STATUS nvHalDacControl_NV04(VOID *);
RM_STATUS nvHalDacUpdateStartAddress_NV04(VOID *);
RM_STATUS nvHalDacProgramMClk_NV04(VOID *);
RM_STATUS nvHalDacProgramNVClk_NV04(VOID *);
RM_STATUS nvHalDacProgramPClk_NV04(VOID *);
RM_STATUS nvHalDacProgramCursorImage_NV04(VOID *);
RM_STATUS nvHalDacGetRasterPosition_NV04(VOID *);
RM_STATUS nvHalDacValidateBandwidth_NV04(VOID *arg);
RM_STATUS nvHalDacValidateArbSettings_NV04(VOID *arg);
RM_STATUS nvHalDacUpdateArbSettings_NV04(VOID *arg);

//
// nvHalDacControl
//
RM_STATUS
nvHalDacControl_NV04(VOID *arg)
{
    PDACCONTROLARG_000 pDacControlArg = (PDACCONTROLARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PFBHALINFO  pFbHalInfo;
    PMCHALINFO  pMcHalInfo;
    PVIDEOHALINFO pVideoHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PDACHALINFO_NV04    pDacHalPvtInfo;

    //
    // Verify interface revision.
    //
    if (pDacControlArg->id != DAC_CONTROL_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacControlArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pVideoHalInfo = pHalHwInfo->pVideoHalInfo;
    pProcessorHalInfo = pHalHwInfo->pProcessorHalInfo;
    pDacHalPvtInfo = (PDACHALINFO_NV04)pHalHwInfo->pDacHalPvtInfo;

    switch (pDacControlArg->cmd)
    {
        case DAC_CONTROL_INIT:
            //
            // Set bus width.
            //
            if (REG_RD_DRF(_PFB, _BOOT_0, _RAM_WIDTH_128) == NV_PFB_BOOT_0_RAM_WIDTH_128_ON)
                pDacHalInfo->InputWidth = 128;
            else
                pDacHalInfo->InputWidth = 64;

            //
            // Initialize video clock.
            //
            pDacHalInfo->VClk = 0;

            //
            // Determine the maximum pixel clock for 8bpp, 16bpp, and 32bpp for this configuration.
            //
            // This will rely on silicon DAC speed, memory bandwidth, and arbitration limits.
            //
            // For now, hardcode the known values.
            //
            if (IsNV4_NV04(pMcHalInfo))
            {
                pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 215000000;
            }
            else if (IsNV5_NV04(pMcHalInfo))
            {
                switch (REG_RD_DRF(_PBUS, _PCI_NV_0, _DEVICE_ID_FUNC))
                {
                    // Std TNT2
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_VGA:
                    // Std Ultra
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_ALT1:
                    // Std TNT2 Model64
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_LC1:
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 250000000;
                        break;

                    // Std Vanta
                    case NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_LC0:
                        //
                        // VantaLT check; drop the clocks for those chips below 100MHz
                        //
                        if (pDacHalInfo->NVClk < 100000000)
                        {
                            pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                            pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                            pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 162000000;  //32bpp hard limit at 162MHz
                        } 
                        else // regular Vanta
                        {
                            pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                            pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                            pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 203000000;
                        }
                        break;

                    // Default
                    default:
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 215000000;
                        break;
                } 

                // 
                // If we're running in SMA mode, drop down the limits accordingly
                //
                if (pFbHalInfo->RamType == BUFFER_CRUSH_UMA)
                {
                    //
                    // Determine how much bandwidth we probably have to system memory
                    //
                    if (pProcessorHalInfo->SystemMemoryFreq == 133000000)
                    {
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 300000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 162000000;
                    }
                    else if (pProcessorHalInfo->SystemMemoryFreq == 100000000)
                    {
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 126000000;
                    }
                    else // (pProcessorHalInfo->SystemMemoryFreq == 66000000)
                    {
                        pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 162000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 162000000;
                        pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp =  85000000;
                    }
                }

            }
            else
            {
                DBG_PRINT_STRING(DEBUGLEVEL_TRACEINFO, "NVRM: unknown chip; using pixelclock defaults\n");
                // defaults
                pDacHalInfo->CrtcInfo[0].PCLKLimit8bpp  = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit16bpp = 250000000;
                pDacHalInfo->CrtcInfo[0].PCLKLimit32bpp = 215000000;
            }
            pDacHalInfo->CrtcInfo[0].RegOffset = 0x00000000;

            //
            // All display types allowed.
            //
            pDacHalInfo->CrtcInfo[0].DisplayTypesAllowed =
                DISPLAYTYPEBIT(DISPLAY_TYPE_MONITOR) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_TV) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_DUALSURFACE) |
                DISPLAYTYPEBIT(DISPLAY_TYPE_FLAT_PANEL);

            //
            // No downscaling on nv4 and family...
            // 
            pVideoHalInfo->OverlayMaxDownscale_768  = 1;
            pVideoHalInfo->OverlayMaxDownscale_1280 = 1;
            pVideoHalInfo->OverlayMaxDownscale_1920 = 1;

            break;
        case DAC_CONTROL_DITHER_DISABLE:
            return (RM_ERR_BAD_ARGUMENT);
        case DAC_CONTROL_DITHER_ENABLE:
            return (RM_ERR_BAD_ARGUMENT);
        case DAC_CONTROL_LOAD:
        case DAC_CONTROL_UNLOAD:
        case DAC_CONTROL_DESTROY:
        case DAC_CONTROL_UPDATE:
            break;
        default:
            return (RM_ERR_BAD_ARGUMENT);
    }

    return (RM_OK);
}

RM_STATUS
nvHalDacAlloc_NV04(VOID *arg)
{
    PDACALLOCARG_000 pDacAllocArg = (PDACALLOCARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacAllocArg->id != DAC_ALLOC_000)
        return (RM_ERR_VERSION_MISMATCH);

    return (RM_OK);
}

RM_STATUS
nvHalDacFree_NV04(VOID *arg)
{
    PDACFREEARG_000 pDacFreeArg = (PDACFREEARG_000)arg;

    //
    // Verify interface revision.
    //
    if (pDacFreeArg->id != DAC_FREE_000)
        return (RM_ERR_VERSION_MISMATCH);    

    return (RM_OK);
}

RM_STATUS
nvHalDacSetStartAddr_NV04(VOID *arg)
{
    PDACSETSTARTADDRARG_000 pDacSetStartAddrArg = (PDACSETSTARTADDRARG_000)arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032 StartAddress = pDacSetStartAddrArg->startAddr;
    U032 prev_bit24, curr_bit24;
    U008 lock, crtc_index, temp;
    U032 CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    //
    // Verify interface revision.
    //
    if (pDacSetStartAddrArg->id != DAC_SET_START_ADDR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacSetStartAddrArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT)pDacSetStartAddrArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;
    
    // Only NV5 needs special treatment regarding PCRTC_START
    if (!IsNV5_NV04(pHalHwInfo->pMcHalInfo))
    {
        REG_WR32(NV_PCRTC_START, StartAddress);
        return (RM_OK);
    }

    //
    // NV5 Bug. Eventhough bit24 should be writable in PCRTC_START, it's not.
    // So, if we need to change its value (i.e. bit24 goes from 0->1 or 1->0),
    // then we'll set/clear bit24 value via the CRE_HEB CRTC reg.
    //
    prev_bit24 = REG_RD32(NV_PCRTC_START) & 0x1000000;
    curr_bit24 = StartAddress & 0x1000000;

    // For NV5, this will properly write bits 23:0
    REG_WR32(NV_PCRTC_START, StartAddress);
    if (prev_bit24 ^ curr_bit24)
    {
        // Save the current CRTC index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)          // color or mono?
            crtc_index = REG_RD08(NV_PRMCIO_CRX__COLOR);    // save crtc index
        else
            crtc_index = REG_RD08(NV_PRMCIO_CRX__MONO);     // save crtc index

        // Unlock CRTC extended regs (following is from ReadCRTCLock)
        // lock = ReadCRTCLock(pDev);
        CRTC_READ(NV_CIO_SR_LOCK_INDEX, temp);
        switch (temp)
        {
            case 0x03:
                lock = 0x57;
                break;
            case 0x01:
                lock = 0x75;
                break;
            case 0x00:
                lock = 0x99;
                break;
            default:
                lock = temp;
                break;
        }
        CRTC_WRITE(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE);

        // bit6 corresponds to StartAddress bit24. All other
        // bits were successfully written via PCRTC_START.
        CRTC_READ(NV_CIO_CRE_HEB__INDEX, temp);
        temp &= 0xBF;                           // mask off bit6
        temp |= ((curr_bit24 >> 24) << 6);      // set/clear bit6
        CRTC_WRITE(NV_CIO_CRE_HEB__INDEX, temp);

        // Relock extended regs
        CRTC_WRITE(NV_CIO_SR_LOCK_INDEX, lock);
        // Restore index
        if (REG_RD08(NV_PRMVIO_MISC__READ) & 0x01)
            REG_WR08(NV_PRMCIO_CRX__COLOR, crtc_index);     // restore crtc index
        else
            REG_WR08(NV_PRMCIO_CRX__MONO, crtc_index);      // restore crtc index
    }

    return (RM_OK);
}

//  Read extended CRTC lock register and return corresponding write value
static U008 ReadCRTCLock_NV04
(
    PHALHWINFO pHalHwInfo,
    U032    Head
)
{
    U008 data;

    HAL_CRTC_RD(NV_CIO_SR_LOCK_INDEX, data, Head);
    switch (data)
    {
        case 0x03:
            data = 0x57;
            break;
        case 0x01:
            data = 0x75;
            break;
        case 0x00:
            data = 0x99;
            break;
    }
    return data;
}

//
// nvHalDacProgramMClk_NV04 - Program MCLK based on the value in pDev->Dac.HalInfo.MClk
//
// This routine uses the value in pDev->Dac.HalInfo.MClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramMClk_NV04(VOID *arg)
{
    PDACPROGRAMMCLKARG_000 pDacProgramMClkArg = (PDACPROGRAMMCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 temp;
    U032 oldMClk;
    U032 oldCyclesPerRefresh;
    U032 oldPeriod;
    U032 newCyclesPerRefresh;
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramMClkArg->id != DAC_PROGRAMMCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramMClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->MPllM;
    nNew = pDacHalInfo->MPllN;
    pNew = pDacHalInfo->MPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _MPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_MPLL_COEFF,
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pOld)
            );

        // Read the register to give the PLL enough time to adjust
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_MPLL_COEFF );
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_MPLL_COEFF,
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _MPLL_COEFF, _PDIV, pNew)
        );

    // Update the number of clock cycles per memory refresh cycle

    // Determine original frequency from old M, N, P values
    oldMClk  = (nOld * pMcHalInfo->CrystalFreq / (1 << pOld) / mOld);

    // Determine original cycles per refresh
    oldCyclesPerRefresh = REG_RD_DRF( _PFB, _DEBUG_0, _REFRESH_COUNTX64 ) * 64;

    // Determine original refresh period
    oldPeriod = oldCyclesPerRefresh * 1024 / ( oldMClk / 1000 );
    
    // Now using the new MCLK, figure out the new cycles per refresh
    newCyclesPerRefresh = ( pDacHalInfo->MClk / 1000 ) * oldPeriod / 1024;

    // Store the new value
    FLD_WR_DRF_NUM( _PFB, _DEBUG_0, _REFRESH_COUNTX64, newCyclesPerRefresh / 64 );
    
    return status;
}

//
// nvHalDacProgramNVClk_NV04 - Program NVCLK based on the value in pDev->Dac.HalInfo.NVClk
//
// This routine uses the value in pDev->Dac.HalInfo.NVClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramNVClk_NV04(VOID *arg)
{
    PDACPROGRAMNVCLKARG_000 pDacProgramNVClkArg = (PDACPROGRAMNVCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 temp;
    U032 i;
    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramNVClkArg->id != DAC_PROGRAMNVCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramNVClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;

    mNew = pDacHalInfo->NVPllM;
    nNew = pDacHalInfo->NVPllN;
    pNew = pDacHalInfo->NVPllP;

    // Program the hardware

    // Retrieve original coefficients
    coeff = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    mOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _NVPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first
        REG_WR32
            (
                NV_PRAMDAC_NVPLL_COEFF,
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pOld)
            );

        // Read the register to give the PLL enough time to adjust
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
        temp = REG_RD32( NV_PRAMDAC_NVPLL_COEFF );
    }

    // Now we can write the final value
    REG_WR32
        (
            NV_PRAMDAC_NVPLL_COEFF,
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _NVPLL_COEFF, _PDIV, pNew)
        );

    // Update NV_PBUS_DEBUG_3 to control data throttling in AGP 4X mode
    i = 0;
    while ( ( pDacHalInfo->NVClk <= NV04_dacAGPClockTable[ i ].frequency ) &&
        ( i < sizeof( NV04_dacAGPClockTable ) / sizeof( NV04_dacAGPClockTable[ 0 ] ) - 1 ) )
    {
        i++;
    }

    FLD_WR_DRF_NUM( _PBUS, _DEBUG_3, _AGP_4X_NVCLK, NV04_dacAGPClockTable[ i ].setting );
    
    return status;
}

//
// nvHalDacProgramPClk_NV04 - Program PCLK based on the value in pDev->Dac.PClk
//
// This routine uses the value in pDev->Dac.PClk (in Hz) to calculate
// M, N, and P values.  Those values are then stored in the pDev->Dac
// structure.  The hardware is then programmed with the new M, N, and P
// values in a manner that is safe for the PLL.
//
RM_STATUS
nvHalDacProgramPClk_NV04(VOID *arg)
{
    PDACPROGRAMPCLKARG_000 pDacProgramPClkArg = (PDACPROGRAMPCLKARG_000) arg;
    PHALHWINFO      pHalHwInfo;
    PDACHALINFO     pDacHalInfo;
    PMCHALINFO      pMcHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032            CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo
    U032            Head;
    U032            PixelClock;

    RM_STATUS status;
    U032 mNew;
    U032 nNew;
    U032 pNew;
    U032 mOld;
    U032 nOld;
    U032 pOld;
    U032 coeff;
    U032 Loops;
    U032 IsPllLocked;

    status = RM_OK;

    //
    // Verify interface revision.
    //
    if (pDacProgramPClkArg->id != DAC_PROGRAMPCLK_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramPClkArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pMcHalInfo = pHalHwInfo->pMcHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramPClkArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    mNew = pDacHalInfo->VPllM;
    nNew = pDacHalInfo->VPllN;
    pNew = pDacHalInfo->VPllP;

    Head = pDacHalObj->Head;
    PixelClock = pDacProgramPClkArg->PixelClock;

    // Program the hardware

    // Retrieve original coefficients
    // NV11 VPLL2 unfortunately is not at the "expected" offset, so we can't use the HAL macro (DAC_REG_RD32)
    if (Head == 0) 
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL_COEFF );
    }
    else
    {
        coeff = REG_RD32( NV_PRAMDAC_VPLL2_COEFF );
    }
    mOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _MDIV, coeff);
    nOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _NDIV, coeff);
    pOld = DRF_VAL( _PRAMDAC, _VPLL_COEFF, _PDIV, coeff);

    // If p decreates then be careful
    if ( pNew < pOld )
    {
        // Write M and N first. 
        if (Head == 0) 
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }
        else
        {
            REG_WR32
            (
                NV_PRAMDAC_VPLL2_COEFF,
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
                DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pOld)
            );
        }

        // Wait until V PLL is locked
        IsPllLocked = FALSE;
        for ( Loops = 100; Loops; --Loops )
        {
            if
            (
                HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                    == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
            )
            {
                // Check again, just to make sure.
                if
                (
                    HAL_DAC_REG_RD_DRF(_PRAMDAC, _PLL_TEST_COUNTER, _VPLL_LOCK, CurDacAdr)
                        == NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED
                )
                {
                    IsPllLocked = TRUE;
                    break;
                }
            }

            osDelay(1 /* ms */);
        }

        if ( !IsPllLocked )
        {
            DBG_PRINT_STRING(DEBUGLEVEL_WARNINGS, "NVRM: VPLL not locked\n");
        }
    }

    // Now we can write the final value
    if (Head == 0) 
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }
    else
    {
        REG_WR32
        (
            NV_PRAMDAC_VPLL2_COEFF,
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _MDIV, mNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _NDIV, nNew) | 
            DRF_NUM( _PRAMDAC, _VPLL_COEFF, _PDIV, pNew)
        );
    }

    return status;
}

//
// nvHalDacProgramCursorImage_NV04
//
RM_STATUS
nvHalDacProgramCursorImage_NV04(VOID *arg)
{
    PDACPROGRAMCURSORARG_000 pDacProgramCursorImgArg = (PDACPROGRAMCURSORARG_000) arg;
    PHALHWINFO  pHalHwInfo;
    PDACHALINFO pDacHalInfo;
    PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT pDacHalObj;
    U032        CurDacAdr; // must be defined for CRTC_RD macro & must point to pDacHalInfo

    U008    cr31, cr2f;
    U008    lock;

    //
    // Verify interface revision.
    //
    if (pDacProgramCursorImgArg->id != DAC_PROGRAMCURSOR_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacProgramCursorImgArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pDacHalObj = (PVIDEO_LUT_CURSOR_DAC_HAL_OBJECT) pDacProgramCursorImgArg->pHalObjInfo;
    CurDacAdr = pDacHalInfo->CrtcInfo[pDacHalObj->Head].RegOffset;

    // Unlock CRTC extended regs
    lock = ReadCRTCLock_NV04(pHalHwInfo, pDacHalObj->Head);
    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, NV_CIO_SR_UNLOCK_RW_VALUE, CurDacAdr);

    // On chips < NV10, the cursor image is always assumed to be a 32x32 image with a color
    // format LE_ROP1R5G5B5. So we ignore the width, height and colorFormat parameters.

    // Mark the Address Space Indicator (bit 7 in NV_CIO_CRE_HCUR_ADDR0_INDEX) 
    // to indicate where the cursor image is based on the param "asi".

    // If the address space indicator says it is in Instance Memory, the startAddr is in terms of 
    // paragraphs instead of bytes. Adjust it to bytes.
    if (pDacProgramCursorImgArg->asi == DAC_ASI_INSTMEM)
    {
        pDacProgramCursorImgArg->startAddr <<= 4;
    }

    // The startAddr is programmed into two config registers as follows:
    // cr2f<0>   = startAddr<24>
    // cr30<6:0> = startAddr<23:17>
    // cr31<7:2> = startAddr<16:11>
    // startAddr<10:0> is assumed to be 0.
    HAL_CRTC_RD(NV_CIO_CRE_HCUR_ADDR2_INDEX, cr2f, CurDacAdr);
    cr2f &= 0xFE;
    cr2f |= (U008)((pDacProgramCursorImgArg->startAddr >> 24) & 0x01);
    HAL_CRTC_WR(NV_CIO_CRE_HCUR_ADDR2_INDEX, cr2f, CurDacAdr);
    
    HAL_CRTC_WR(NV_CIO_CRE_HCUR_ADDR0_INDEX, 
               (U008) ( ((pDacProgramCursorImgArg->startAddr >> 17) & 0x7f) | (pDacProgramCursorImgArg->asi << DEVICE_BASE(NV_CIO_CRE_HCUR_ASI)) ),
               CurDacAdr);
            
    // store startAddr bits 16:11 in cr31 bits 7:2
    HAL_CRTC_RD(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, CurDacAdr);
    cr31 &= 0x03; // Clear bits 7:2
    cr31 |= (U008)((pDacProgramCursorImgArg->startAddr >> 9) & 0xfc); // Set the new start address
    HAL_CRTC_WR(NV_CIO_CRE_HCUR_ADDR1_INDEX, cr31, CurDacAdr);

    // Restore original state of CRTC lock register
    HAL_CRTC_WR(NV_CIO_SR_LOCK_INDEX, lock, CurDacAdr);
    
    return RM_OK;
}

//
// nvHalDacGetRasterPosition_NV04
//
RM_STATUS
nvHalDacGetRasterPosition_NV04(VOID *arg)
{
    PDACRASTERPOSARG_000 pDacRasterPosArg = (PDACRASTERPOSARG_000) arg;
    PHALHWINFO pHalHwInfo;

    //
    // Verify interface revision.
    //
    if (pDacRasterPosArg->id != DAC_RASTERPOS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacRasterPosArg->pHalHwInfo;

    // TO DO: use head number

    // no RL0/RL1 index regs, so return NV_PCRTC_RASTER_POSITION
    pDacRasterPosArg->result = (U016) REG_RD_DRF(_PCRTC, _RASTER, _POSITION);

    return (RM_OK);
}


//         
// Called from display driver to confirm that sufficient bandwidth is available
// for the proposed configuration.
// For this chip, stubbed out to always return success...
//
RM_STATUS
nvHalDacValidateBandwidth_NV04(VOID *arg)
{
    return RM_OK;
}


//
// Attempt to validate the given parameters will work with the current configuration
//       
//  Return 0  if not capable
//  Return ~0 if valid  
//
RM_STATUS
nvHalDacValidateArbSettings_NV04(VOID *arg)
{
    PDACVALIDATEARBSETTINGSARG_000    pDacValidateArbSettingsArg = (PDACVALIDATEARBSETTINGSARG_000) arg;
    PHALHWINFO          pHalHwInfo;
    PDACHALINFO         pDacHalInfo;
    PFBHALINFO          pFbHalInfo;
    PMCHALINFO          pMcHalInfo;
    PPROCESSORHALINFO   pProcessorHalInfo;
    PVIDEOHALINFO       pVideoHalInfo;

    fifo_info fifo_data;
    sim_state sim_data;
    U032 pclk_limit;

    //
    // Verify interface revision.
    //
    if (pDacValidateArbSettingsArg->id != DAC_VALIDATEARBSETTINGS_000)
        return (RM_ERR_VERSION_MISMATCH);

    pHalHwInfo = pDacValidateArbSettingsArg->pHalHwInfo;
    pDacHalInfo = pHalHwInfo->pDacHalInfo;
    pFbHalInfo = pHalHwInfo->pFbHalInfo;
    pMcHalInfo = pHalHwInf